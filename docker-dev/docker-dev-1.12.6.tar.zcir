t
 * Size of the operation.
 */

struct IOStorageExtent
{
    UInt64 byteStart;
    UInt64 byteCount;
};

/*!
 * @typedef IOStorageCompletionAction
 * @discussion
 * The IOStorageCompletionAction declaration describes the C (or C++) completion
 * routine that is called once an asynchronous storage operation completes.
 * @param target
 * Opaque client-supplied pointer (or an instance pointer for a C++ callback).
 * @param parameter
 * Opaque client-supplied pointer.
 * @param status
 * Status of the data transfer.
 * @param actualByteCount
 * Actual number of bytes transferred in the data transfer.
 */

typedef void (*IOStorageCompletionAction)(void *   target,
                                          void *   parameter,
                                          IOReturn status,
                                          UInt64   actualByteCount);

/*!
 * @struct IOStorageCompletion
 * @discussion
 * The IOStorageCompletion structure describes the C (or C++) completion routine
 * that is called once an asynchronous storage operation completes.   The values
 * passed for the target and parameter fields will be passed to the routine when
 * it is called.
 * @field target
 * Opaque client-supplied pointer (or an instance pointer for a C++ callback).
 * @field action
 * Completion routine to call on completion of the data transfer.
 * @field parameter
 * Opaque client-supplied pointer.
 */

struct IOStorageCompletion
{
    void *                    target;
    IOStorageCompletionAction action;
    void *                    parameter;
};

/*!
 * @class IOStorage
 * @abstract
 * The common base class for mass storage objects.
 * @discussion
 * The IOStorage class is the common base class for mass storage objects.  It is
 * an abstract class that defines the open/close/read/write APIs that need to be
 * implemented in a given subclass.  Synchronous versions of the read/write APIs
 * are provided here -- they are coded in such a way as to wrap the asynchronous
 * versions implemented in the subclass.
 */

class IOStorage : public IOService
{
    OSDeclareAbstractStructors(IOStorage);

protected:

    struct ExpansionData { /* */ };
    ExpansionData * _expansionData;

    /*!
     * @function handleOpen
     * @discussion
     * The handleOpen method grants or denies permission to access this object
     * to an interested client.  The argument is an IOStorageAccess value that
     * specifies the level of access desired -- reader or reader-writer.
     *
     * This method can be invoked to upgrade or downgrade the access level for
     * an existing client as well.  The previous access level will prevail for
     * upgrades that fail, of course.   A downgrade should never fail.  If the
     * new access level should be the same as the old for a given client, this
     * method will do nothing and return success.  In all cases, one, singular
     * close-per-client is expected for all opens-per-client received.
     * @param client
     * Client requesting the open.
     * @param options
     * Options for the open.  Set to zero.
     * @param access
     * Access level for the open.  Set to kIOStorageAccessReader or
     * kIOStorageAccessReaderWriter.
     * @result
     * Returns true if the open was successful, false otherwise.
     */

    virtual bool handleOpen(IOService *  client,
                            IOOptionBits options,
                            void *       access) = 0;

    /*!
     * @function handleIsOpen
     * @discussion
     * The handleIsOpen method determines whether the specified client, or any
     * client if none is specified, presently has an open on this object.
     * @param client
     * Client to check the open state of.  Set to zero to check the open state
     * of all clients.
     * @result
     * Returns true if the client was (or clients were) open, false otherwise.
     */

    virtual bool handleIsOpen(const IOService * client) const = 0;

    /*!
     * @function handleClose
     * @discussion
     * The handleClose method closes the client's access to this object.
     * @param client
     * Client requesting the close.
     * @param options
     * Options for the close.  Set to zero.
     */

    virtual void handleClose(IOService * client, IOOptionBits options) = 0;

public:

#ifdef __x86_64__
    virtual bool attach(IOService * provider);
#endif /* __x86_64__ */

    /*!
     * @function complete
     * @discussion
     * Invokes the specified completion action of the read/write request.  If
     * the completion action is unspecified, no action is taken.  This method
     * serves simply as a convenience to storage subclass developers.
     * @param completion
     * Completion information for the data transfer.
     * @param status
     * Status of the data transfer.
     * @param actualByteCount
     * Actual number of bytes transferred in the data transfer.
     */

    static void complete(IOStorageCompletion * completion,
                         IOReturn              status,
                         UInt64                actualByteCount = 0);

    /*!
     * @function open
     * @discussion
     * Ask the storage object for permission to access its contents; the method
     * is equivalent to IOService::open(), but with the correct parameter types.
     *
     * This method may also be invoked to upgrade or downgrade the access of an
     * existing open (if it fails, the existing open prevails).
     * @param client
     * Client requesting the open.
     * @param options
     * Options for the open.  Set to zero.
     * @param access
     * Access level for the open.  Set to kIOStorageAccessReader or
     * kIOStorageAccessReaderWriter.
     * @result
     * Returns true if the open was successful, false otherwise.
     */

    virtual bool open(IOService *     client,
                      IOOptionBits    options,
                      IOStorageAccess access);

    /*!
     * @function read
     * @discussion
     * Read data from the storage object at the specified byte offset into the
     * specified buffer, synchronously.   When the read completes, this method
     * will return to the caller.  The actual byte count field is optional.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn read(IOService *           client,
                          UInt64                byteStart,
                          IOMemoryDescriptor *  buffer,
                          IOStorageAttributes * attributes      = 0,
                          UInt64 *              actualByteCount = 0);

    /*!
     * @function write
     * @discussion
     * Write data into the storage object at the specified byte offset from the
     * specified buffer, synchronously.   When the write completes, this method
     * will return to the caller.  The actual byte count field is optional.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.
     * @param actualByteCount
     * Returns the actual number of bytes transferred in the data transfer.
     * @result
     * Returns the status of the data transfer.
     */

    virtual IOReturn write(IOService *           client,
                           UInt64                byteStart,
                           IOMemoryDescriptor *  buffer,
                           IOStorageAttributes * attributes      = 0,
                           UInt64 *              actualByteCount = 0);

#ifdef __x86_64__
    virtual IOReturn synchronizeCache(IOService * client) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function read
     * @discussion
     * Read data from the storage object at the specified byte offset into the
     * specified buffer, asynchronously.   When the read completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the read.
     * @param client
     * Client requesting the read.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void read(IOService *           client,
                      UInt64                byteStart,
                      IOMemoryDescriptor *  buffer,
                      IOStorageAttributes * attributes,
                      IOStorageCompletion * completion) = 0;

    /*!
     * @function write
     * @discussion
     * Write data into the storage object at the specified byte offset from the
     * specified buffer, asynchronously.   When the write completes, the caller
     * will be notified via the specified completion action.
     *
     * The buffer will be retained for the duration of the write.
     * @param client
     * Client requesting the write.
     * @param byteStart
     * Starting byte offset for the data transfer.
     * @param buffer
     * Buffer for the data transfer.  The size of the buffer implies the size of
     * the data transfer.
     * @param attributes
     * Attributes of the data transfer.  See IOStorageAttributes.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     * @param completion
     * Completion routine to call once the data transfer is complete.  It is the
     * responsibility of the callee to maintain the information for the duration
     * of the data transfer, as necessary.
     */

    virtual void write(IOService *           client,
                       UInt64                byteStart,
                       IOMemoryDescriptor *  buffer,
                       IOStorageAttributes * attributes,
                       IOStorageCompletion * completion) = 0;

#ifdef __x86_64__
    virtual IOReturn discard(IOService * client,
                             UInt64      byteStart,
                             UInt64      byteCount) __attribute__ ((deprecated));
#endif /* __x86_64__ */

    /*!
     * @function unmap
     * @discussion
     * Delete unused data from the storage object at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param options
     * Options for the unmap.  See IOStorageUnmapOptions.
     * @result
     * Returns the status of the operation.
     */

#ifdef __x86_64__
    virtual IOReturn unmap(IOService *           client,
                           IOStorageExtent *     extents,
                           UInt32                extentsCount,
                           IOStorageUnmapOptions options = 0); /* 10.6.6 */
#else /* !__x86_64__ */
    virtual IOReturn unmap(IOService *           client,
                           IOStorageExtent *     extents,
                           UInt32                extentsCount,
                           IOStorageUnmapOptions options = 0) = 0;
#endif /* !__x86_64__ */

    /*!
     * @function lockPhysicalExtents
     * @discussion
     * Lock the contents of the storage object against relocation temporarily,
     * for the purpose of getting physical extents.
     * @param client
     * Client requesting the operation.
     * @result
     * Returns true if the lock was successful, false otherwise.
     */

    virtual bool lockPhysicalExtents(IOService * client); /* 10.7.0 */

    /*!
     * @function copyPhysicalExtent
     * @discussion
     * Convert the specified byte offset into a physical byte offset, relative
     * to a physical storage object.  This call should only be made within the
     * context of lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     * @param byteStart
     * Starting byte offset for the operation.  Returns a physical byte offset,
     * relative to the physical storage object, on success.
     * @param byteCount
     * Size of the operation.  Returns the actual number of bytes which can be
     * transferred, relative to the physical storage object, on success. 
     * @result
     * A reference to the physical storage object, which should be released by
     * the caller, or a null on error.
     */

    virtual IOStorage * copyPhysicalExtent(IOService * client,
                                           UInt64 *    byteStart,
                                           UInt64 *    byteCount); /* 10.7.0 */

    /*!
     * @function unlockPhysicalExtents
     * @discussion
     * Unlock the contents of the storage object for relocation again.  This
     * call must balance a successful call to lockPhysicalExtents().
     * @param client
     * Client requesting the operation.
     */

    virtual void unlockPhysicalExtents(IOService * client); /* 10.7.0 */

    /*!
     * @function setPriority
     * @discussion
     * Reprioritize read or write requests at the specified byte offsets.
     * @param client
     * Client requesting the operation.
     * @param extents
     * List of extents.  See IOStorageExtent.  It is legal for the callee to
     * overwrite the contents of this buffer in order to satisfy the request.
     * @param extentsCount
     * Number of extents.
     * @param priority
     * New priority.  See IOStoragePriority.
     * @result
     * Returns the status of the operation.
     */

    virtual IOReturn setPriority(IOService *       client,
                                 IOStorageExtent * extents,
                                 UInt32            extentsCount,
                                 IOStoragePriority priority); /* 10.10.0 */

    /*!
     * @function synchronize
     * @discussion
     * Flush the cached data in the storage object, if any.
     * @param client
     * Client requesting the synchronization.
     * @param byteStart
     * Starting byte offset for the synchronization.
     * @param byteCount
     * Size of the synchronization.  Set to zero to specify the end-of-media.
     * @param options
     * Options for the synchronization.  See IOStorageSynchronizeOptions.
     * @result
     * Returns the status of the synchronization.
     */

#ifdef __x86_64__
    virtual IOReturn synchronize(IOService *                 client,
                                 UInt64                      byteStart,
                                 UInt64                      byteCount,
                                 IOStorageSynchronizeOptions options = 0); /* 10.11.0 */
#else /* !__x86_64__ */
    virtual IOReturn synchronize(IOService *                 client,
                                 UInt64                      byteStart,
                                 UInt64                      byteCount,
                                 IOStorageSynchronizeOptions options = 0) = 0;
#endif /* !__x86_64__ */

    OSMetaClassDeclareReservedUsed(IOStorage,  0);
    OSMetaClassDeclareReservedUsed(IOStorage,  1);
    OSMetaClassDeclareReservedUsed(IOStorage,  2);
    OSMetaClassDeclareReservedUsed(IOStorage,  3);
    OSMetaClassDeclareReservedUsed(IOStorage,  4);
    OSMetaClassDeclareReservedUsed(IOStorage,  5);
    OSMetaClassDeclareReservedUnused(IOStorage,  6);
    OSMetaClassDeclareReservedUnused(IOStorage,  7);
    OSMetaClassDeclareReservedUnused(IOStorage,  8);
    OSMetaClassDeclareReservedUnused(IOStorage,  9);
    OSMetaClassDeclareReservedUnused(IOStorage, 10);
    OSMetaClassDeclareReservedUnused(IOStorage, 11);
    OSMetaClassDeclareReservedUnused(IOStorage, 12);
    OSMetaClassDeclareReservedUnused(IOStorage, 13);
    OSMetaClassDeclareReservedUnused(IOStorage, 14);
    OSMetaClassDeclareReservedUnused(IOStorage, 15);
};

#ifdef __x86_64__
#ifdef KERNEL_PRIVATE
#define _kIOStorageSynchronizeOption_super__synchronizeCache 0xFFFFFFFF
#define _respondsTo_synchronizeCache ( IOStorage::_expansionData )
#endif /* KERNEL_PRIVATE */
#endif /* __x86_64__ */

#endif /* __cplusplus */
#endif /* KERNEL */
#endif /* !_IOSTORAGE_H */
                                                                                                IOStorageCardCharacteristics.h                                                                      0100644 0001750 0001750 00000021771 12567452411 041331  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_CARD_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_CARD_CHARACTERISTICS_H_

		
/*
 *	Card Characteristics - Characteristics defined for cards.
 */

/*!
@defined kIOPropertyCardCharacteristicsKey
@discussion This key is used to define Card Characteristics for a particular
piece of MMC/SD media and it has an associated dictionary which lists the
card characteristics.
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardCharacteristicsKey				"Card Characteristics"


/*!
@defined kIOPropertySlotKey
@discussion This key is used to define the slot number for the device
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Slot</key>
	<integer>1<integer>
 </dict>
@/textblock
</pre>
*/
#define kIOPropertySlotKey								"Slot"


/*!
@defined kIOProperty64BitKey
@discussion This key defines wether the device supports 64-bit.
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>64-bit</key>
	<true/>
</dict>
@/textblock
</pre>
*/
#define kIOProperty64BitKey								"64-bit"


/*!
@defined kIOPropertyClockDivisorKey
 @discussion This key defines the current clock divisor for the device.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Clock Divisor</key>
	<integer>128</integer>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyClockDivisorKey						"Clock Divisor"


/*!
@defined kIOPropertyBaseFrequencyKey
@discussion This key defines the current base frequency for the device.
 
Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Base Frequency</key>
	<integer>50</integer>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBaseFrequencyKey						"Base Frequency"


/*!
@defined kIOPropertyBusVoltageKey
@discussion This key defines the current bus voltage for the device in mV
 
Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Bus Voltage</key>
	<integer>3300</integer>
</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBusVoltageKey						"Bus Voltage"


/*!
@defined kIOPropertyBusWidthKey
@discussion This key defines the current bus width for the device.

Requirement: Mandatory.
 
Example:
<pre>
@textblock
<dict>
	<key>Bus Width</key>
	<integer>4</integer>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBusWidthKey							"Bus Width"


/*!
@defined kIOPropertyCardPresentKey
@discussion This key defines wether a MMC or SD card is physically present.
 
Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Card Present</key>
	<true/>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardPresentKey						"Card Present"


/*!
 @defined kIOPropertyProductSerialNumberKey
 @discussion This key is used to indicate the card serial number ID.
 
 Requirement: Mandatory
 
 Example:
 <pre>
 @textblock
 <dict>
	 <key>Card Characteristics</key>
	 <dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		 <key>Card Type</key>
		 <string>SDHC</string>
		 <key>Serial Number</key>
		 <data>0045ff</data>
	 </dict>
 </dict>
 @/textblock
 </pre>
 */
#define kIOPropertyProductSerialNumberKey				"Serial Number"


/*!
 @defined kIOPropertyManufacturerIDKey
 @discussion This key is used to indicate the card manufacturer ID.
 
 Requirement: Optional
 
 Example:
 <pre>
 @textblock
 <dict>
	 <key>Card Characteristics</key>
	 <dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Manufacturer ID</key>
		<data>03</data>
	 </dict>
 </dict>
 @/textblock
 </pre>
 */
#define kIOPropertyManufacturerIDKey					"Manufacturer ID"


/*!
@defined kIOPropertyApplicationIDKey
 @discussion This key is used to indicate the card application ID.

Requirement: Optional

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Application ID</key>
		<data>ffff</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyApplicationIDKey						"Application ID"


/*!
@defined kIOPropertyManufacturingDateKey
 @discussion This key is used to indicate the card manufacturing date.

Requirement: Mandatory.
 
Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Manufacturing Date</key>
		<string>2009-12</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyManufacturingDateKey					"Manufacturing Date"


/*!
@defined kIOPropertySpeedClassKey
 @discussion This key is used to indicate SD card speed class.

Requirement: Mandatory.
 
Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Speed Class</key>
		<data>02</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySpeedClassKey						"Speed Class"


/*!
@defined kIOPropertySpecificationVersionKey
@discussion This key is used to indicate the card specification version.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
		<key>Specification Version</key>
		<string>3.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySpecificationVersionKey				"Specification Version"


/*!
@defined kIOPropertyCardTypeKey
 @discussion This key is used to indicate the card type is MMC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>MMC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeKey							"Card Type"


/*!
@defined kIOPropertyCardTypeMMCKey
 @discussion This key is used to indicate the card type is MMC.

 Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		 <key>Card Type</key>
		 <string>MMC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeMMCKey						"MMC"


/*!
@defined kIOPropertyCardTypeSDSCKey
 @discussion This key is used to indicate the card type is SDSC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		 <key>Product Name</key>
		 <string>SD32G</string>
		 <key>Product Revision Level</key>
		 <string>1.0</string>
		 <key>Card Type</key>
		 <string>SDSC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeSDSCKey						"SDSC"


/*!
@defined kIOPropertyCardTypeSDHCKey
 @discussion This key is used to indicate the card type is SDHC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDHC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeSDHCKey						"SDHC"


/*!
@defined kIOPropertyCardTypeSDXCKey
 @discussion This key is used to indicate the card type is SDXC.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Card Characteristics</key>
	<dict>
		<key>Product Name</key>
		<string>SD32G</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Card Type</key>
		<string>SDXC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCardTypeSDXCKey						"SDXC"


#endif	/* _IOKIT_IO_STORAGE_CARD_CHARACTERISTICS_H_ */
       IOStorageControllerCharacteristics.h                                                                0100644 0001750 0001750 00000073443 12567452411 042606  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_CONTROLLER_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_CONTROLLER_CHARACTERISTICS_H_


/*
 *	Controller Characteristics - Characteristics defined for controllers.
 */


/*!
@defined kIOPropertyControllerCharacteristicsKey
@discussion This key is used to define Controller Characteristics for a particular
device and it has an associated dictionary which lists the
controller characteristics.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyControllerCharacteristicsKey		"Controller Characteristics"


/*!
@defined kIOPropertySASAddressKey
@discussion This key is the unique 64-bit SAS Address for the device server
node located at this port, or for the initiating host port.

Requirement: Mandatory for SAS.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SAS Address</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySASAddressKey					"SAS Address"


/*!
@defined kIOPropertySCSIPortIdentifierKey
@discussion This key is the unique port identifier for the device server
node located at this port, or for the initiating host port.  The format for
this data is allowed to be vendor-specific, as long as it is guaranteed to
be unique.  Length is arbitrary, to allow for itnerfaces with non-standard
identifier rules.  It is recommended to have this be a copy of an existing
standard unique identifier for this port, should one  already exist for your
interface type

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Unique SCSI Port Identifier</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIPortIdentifierKey		"Unique SCSI Port Identifier"


/*!
@defined kIOPropertyFibreChannelNodeWorldWideNameKey
@discussion This key is the unique 64-bit World Wide Name for the device server
node located at this port, or for the initiating host port.

Requirement: Mandatory for Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Node World Wide Name</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelNodeWorldWideNameKey		"Node World Wide Name"


/*!
@defined kIOPropertyFibreChannelPortWorldWideNameKey
@discussion This key is the unique 64-bit World Wide Name for the port.

Requirement: Mandatory for Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port World Wide Name</key>
		<data>0011223344556677</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelPortWorldWideNameKey		"Port World Wide Name"


/*!
@defined kIOPropertyFibreChannelAddressIdentifierKey
@discussion This key is the 24-bit Address Identifier (S_ID or D_ID) as
defined in the FC-FS specification. It contains the address identifier
of the source or destination Nx_Port.

Note: This value can change. It is not a static value.

Requirement: Optional (only necessary for Fibre Channel Interface).

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Address Identifier</key>
		<data>001122</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelAddressIdentifierKey		"Address Identifier"


/*!
@defined kIOPropertyFibreChannelALPAKey
@discussion This key is the 8-bit Arbitrated Loop Physical Address
(AL_PA) value as defined in the FC-AL-2 specification.

Note: This value can change. It is not a static value.

Requirement: Optional (only necessary for Fibre Channel Interface).

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>AL_PA</key>
		<data>04</data>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelALPAKey					"AL_PA"


/*!
@defined kIOPropertyPortStatusKey
@discussion This key is associated with the current port
status of the physical link. The port status is either
"Link Established", "No Link Established", or "Link Failed".

Note: This value can change when the port status changes. It
is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>Link Established</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusKey						"Port Status"


/*!
@defined kIOPropertyPortSpeedKey
@discussion This key is associated with the current port
speed. The port speed can be any valid speed for the interconnect.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (1 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedKey							"Port Speed"


/*!
@defined kIOPropertyPortTopologyKey
@discussion This key is associated with the current port
topology. The port topology can be any valid topology for the interconnect.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic (N_Port)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyKey						"Port Topology"


/*!
@defined kIOPropertyPortDescriptionKey
@discussion This key is associated with an human
readable port description. Examples include
"Channel A", "Port 1", etc.

Requirement: Optional for all interconnects.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Description</key>
		<string>Channel A</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortDescriptionKey					"Port Description"


/*!
@defined kIOPropertySCSIParallelSignalingTypeKey
@discussion This key is associated with the signaling type
used for this SCSI Parallel bus. Valid values include
"High Voltage Differential", "Low Voltage Differential",
and "Single Ended".

Requirement: Optional for SCSI Parallel Interface. Not
defined for any other physical interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>High Voltage Differential</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeKey			"SCSI Parallel Signaling Type"


/*!
@defined kIOPropertyFibreChannelCableDescriptionKey
@discussion This key is associated with the cabling type
used for this Fibre Channel port. Valid values include
"Copper" and "Fiber Optic".

Requirement: Optional for Fibre Channel Interface. Not
defined for any other physical interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Fibre Channel Cabling Type</key>
		<string>Copper</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelCableDescriptionKey		"Fibre Channel Cabling Type"


/*!
@defined kIOPropertyEncryptionTypeKey
@discussion This key is associated with the encryption type
used for this storage controller. Valid values currently include
"AES-XTS", "AES-XEX" and "AES-CBC".

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-XTS</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyEncryptionTypeKey	"Encryption Type"


/*!
@defined kIOPropertyLowPowerModeKey
@discussion This key is associated with whether the storage
device has low-power mode enabled. If enabled, it will set this 
key to true.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Low Power Mode</key>
		<true/>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyLowPowerModeKey		"Low Power Mode"


/*
 *	Values - Values for the characteristics defined above.
 */


/*!
@defined kIOPropertyPortStatusLinkEstablishedKey
@discussion This key defines the value of Link Established for the key
kIOPropertyPortStatusKey.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>Link Established</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusLinkEstablishedKey			"Link Established"


/*!
@defined kIOPropertyPortStatusNoLinkEstablishedKey
@discussion This key defines the value of No Link Established for the key
kIOPropertyPortStatusKey.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>No Link Established</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusNoLinkEstablishedKey		"No Link Established"


/*!
@defined kIOPropertyPortStatusLinkFailedKey
@discussion This key defines the value of Link Failed for the key
kIOPropertyPortStatusKey.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Status</key>
		<string>Link Failed</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortStatusLinkFailedKey				"Link Failed"


/*!
@defined kIOPropertyPortSpeedAutomaticKey
@discussion This key defines the value of Automatic for the key
kIOPropertyPortSpeedKey. If the speed of the port is automatically
adjusted by the host/device and a definitive speed is not known,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomaticKey				"Automatic"


/*!
@defined kIOPropertyPortSpeed1GigabitKey
@discussion This key defines the value of 1 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 1 Gigabit
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>1 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed1GigabitKey					"1 Gigabit"

/*!
@defined kIOPropertyPortSpeed1_5GigabitKey
@discussion This key defines the value of 1.5 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 1.5 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>1.5 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed1_5GigabitKey				"1.5 Gigabit"


/*!
@defined kIOPropertyPortSpeed2GigabitKey
@discussion This key defines the value of 2 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 2 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>2 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed2GigabitKey					"2 Gigabit"


/*!
@defined kIOPropertyPortSpeed3GigabitKey
@discussion This key defines the value of 3 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 3 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>3 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed3GigabitKey					"3 Gigabit"


/*!
@defined kIOPropertyPortSpeed4GigabitKey
@discussion This key defines the value of 4 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 4 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>4 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed4GigabitKey					"4 Gigabit"

/*!
@defined kIOPropertyPortSpeed6GigabitKey
@discussion This key defines the value of 6 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 6 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>6 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed6GigabitKey					"6 Gigabit"


/*!
@defined kIOPropertyPortSpeed8GigabitKey
@discussion This key defines the value of 8 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 8 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>8 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed8GigabitKey					"8 Gigabit"


/*!
@defined kIOPropertyPortSpeed10GigabitKey
@discussion This key defines the value of 10 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 10 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>10 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed10GigabitKey				"10 Gigabit"


/*!
@defined kIOPropertyPortSpeed12GigabitKey
@discussion This key defines the value of 12 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 12 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>12 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed12GigabitKey				"12 Gigabit"


/*!
@defined kIOPropertyPortSpeed16GigabitKey
@discussion This key defines the value of 16 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 16 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>16 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
 */
#define kIOPropertyPortSpeed16GigabitKey				"16 Gigabit"


/*!
@defined kIOPropertyPortSpeed40GigabitKey
@discussion This key defines the value of 40 Gigabit for the key
kIOPropertyPortSpeedKey. If the speed of the port is 40 Gigabits
per second and is not automatically determined (i.e. the user
configured the port to be exactly this speed),
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>40 Gigabit</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeed40GigabitKey				"40 Gigabit"


/*!
@defined kIOPropertyPortSpeedAutomatic1GigabitKey
@discussion This key defines the value of Automatic (1 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
1 Gigabit per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (1 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic1GigabitKey		"Automatic (1 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic1_5GigabitKey
@discussion This key defines the value of Automatic (1.5 Gigabit) for the key
kIOPropertyPortSpeedKey. If the speed of the port is
1.5 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (1.5 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic1_5GigabitKey		"Automatic (1.5 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic2GigabitKey
@discussion This key defines the value of Automatic (2 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
2 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (2 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic2GigabitKey		"Automatic (2 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic3GigabitKey
@discussion This key defines the value of Automatic (3 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
3 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (3 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic3GigabitKey		"Automatic (3 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic4GigabitKey
@discussion This key defines the value of Automatic (4 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
4 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (4 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic4GigabitKey		"Automatic (4 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic6GigabitKey
@discussion This key defines the value of Automatic (6 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
6 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (6 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic6GigabitKey		"Automatic (6 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic8GigabitKey
@discussion This key defines the value of Automatic (8 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
8 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (8 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic8GigabitKey		"Automatic (8 Gigabit)"


/*!
@defined kIOPropertyPortSpeedAutomatic10GigabitKey
@discussion This key defines the value of Automatic (10 Gigabit)
for the key kIOPropertyPortSpeedKey. If the speed of the port is
10 Gigabits per second and is automatically determined by host
software, this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Speed</key>
		<string>Automatic (10 Gigabit)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortSpeedAutomatic10GigabitKey		"Automatic (10 Gigabit)"


/*!
@defined kIOPropertyPortTopologyAutomaticKey
@discussion This key defines the value of Automatic for the key
kIOPropertyPortTopologyKey. If the topology of the port is automatically
adjusted by the host/device and a definitive topology is not known,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyAutomaticKey				"Automatic"


/*!
@defined kIOPropertyPortTopologyNPortKey
@discussion This key defines the value of N_Port for the key
kIOPropertyPortTopologyKey. If the topology of the port is an N_Port,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>N_Port</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyNPortKey					"N_Port"


/*!
@defined kIOPropertyPortTopologyNLPortKey
@discussion This key defines the value of NL_Port for the key
kIOPropertyPortTopologyKey. If the topology of the port is an NL_Port,
this key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>NL_Port</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyNLPortKey				"NL_Port"


/*!
@defined kIOPropertyPortTopologyAutomaticNPortKey
@discussion This key defines the value of Automatic (N_Port) for the key
kIOPropertyPortTopologyKey. If the topology of the port is
N_Port and is automatically determined by host software, this
key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic (N_Port)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyAutomaticNPortKey		"Automatic (N_Port)"


/*!
@defined kIOPropertyPortTopologyAutomaticNLPortKey
@discussion This key defines the value of Automatic (NL_Port) for the key
kIOPropertyPortTopologyKey. If the topology of the port is
NL_Port and is automatically determined by host software, this
key should be used.

Note: This value can change. It is not a static value.

Requirement: Optional for any interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Port Topology</key>
		<string>Automatic (NL_Port)</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPortTopologyAutomaticNLPortKey		"Automatic (NL_Port)"


/*!
@defined kIOPropertySCSIParallelSignalingTypeHVDKey
@discussion This key defines the value of High Voltage Differential for the key
kIOPropertySCSIParallelSignalingTypeKey. If the signaling type of the port is
High Voltage Differential, this key should be used.

Requirement: Optional for SCSI Parallel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>High Voltage Differential</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeHVDKey		"High Voltage Differential"


/*!
@defined kIOPropertySCSIParallelSignalingTypeLVDKey
@discussion This key defines the value of Low Voltage Differential for the key
kIOPropertySCSIParallelSignalingTypeKey. If the signaling type of the port is
Low Voltage Differential, this key should be used.

Requirement: Optional for SCSI Parallel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>Low Voltage Differential</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeLVDKey		"Low Voltage Differential"


/*!
@defined kIOPropertySCSIParallelSignalingTypeSEKey
@discussion This key defines the value of Single Ended for the key
kIOPropertySCSIParallelSignalingTypeKey. If the signaling type of the port is
Single Ended, this key should be used.

Requirement: Optional for SCSI Parallel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>SCSI Parallel Signaling Type</key>
		<string>Single Ended</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIParallelSignalingTypeSEKey		"Single Ended"


/*!
@defined kIOPropertyFibreChannelCableDescriptionCopperKey
@discussion This key defines the value of Copper for the key
kIOPropertyFibreChannelCableDescriptionKey. If the cabling is
Copper, this key should be used.

Requirement: Optional for Fibre Channel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Fibre Channel Cabling Type</key>
		<string>Copper</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelCableDescriptionCopperKey		"Copper"


/*!
@defined kIOPropertyFibreChannelCableDescriptionFiberOpticKey
@discussion This key defines the value of Fiber Optic for the key
kIOPropertyFibreChannelCableDescriptionKey. If the cabling is
Fiber Optic, this key should be used.

Requirement: Optional for Fibre Channel Interface interconnect.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Fibre Channel Cabling Type</key>
		<string>Fiber Optic</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyFibreChannelCableDescriptionFiberOpticKey	"Fiber Optic"


/*!
@defined kIOPropertyAESCBCKey
@discussion This key defines the value of AES-CBC for the key
kIOPropertyEncryptionTypeKey. If the encryption used is
AES-CBC, this key should be used.

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-CBC</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyAESCBCKey	"AES-CBC"


/*!
@defined kIOPropertyAESXTSKey
@discussion This key defines the value of AES-XTS for the key
kIOPropertyEncryptionTypeKey. If the encryption used is
AES-XTS, this key should be used.

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-XTS</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyAESXTSKey	"AES-XTS"


/*!
@defined kIOPropertyAESXEXKey
@discussion This key defines the value of AES-XEX for the key
kIOPropertyEncryptionTypeKey. If the encryption used is
AES-XEX, this key should be used.

Requirement: Optional for all storage controllers.

Example:
<pre>
@textblock
<dict>
	<key>Controller Characteristics</key>
	<dict>
		<key>Encryption Type</key>
		<string>AES-XEX</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyAESXEXKey	"AES-XEX"


#endif	/* _IOKIT_IO_STORAGE_CONTROLLER_CHARACTERISTICS_H_ */
                                                                                                                                                                                                                             IOStorageDeviceCharacteristics.h                                                                    0100644 0001750 0001750 00000034616 12567452411 041661  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_DEVICE_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_DEVICE_CHARACTERISTICS_H_

#include <IOKit/storage/IOStorageProtocolCharacteristics.h>

/*
 *	Device Characteristics - Characteristics defined for devices.
 */

/*!
@defined kIOPropertyDeviceCharacteristicsKey
@discussion This key is used to define Device Characteristics for a particular
device and it has an associated dictionary which lists the
device characteristics. The device characteristics are Command Set specific
and are listed in the header files for each command set.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyDeviceCharacteristicsKey		"Device Characteristics"


/*!
@defined kIOPropertyVendorNameKey
@discussion This key is used to define the Vendor Name for a particular device
and it has an associated string.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyVendorNameKey				"Vendor Name"


/*!
@defined kIOPropertyProductNameKey
@discussion This key is used to define the Product Name for a particular device
and it has an associated string.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyProductNameKey				"Product Name"


/*!
@defined kIOPropertyProductRevisionLevelKey
@discussion This key is used to define the Product Revision Level for a
particular device and it has an associated string.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyProductRevisionLevelKey		"Product Revision Level"


/*!
@defined kIOPropertyProductSerialNumberKey
@discussion This key is used to define the Product Serial Number for a
particular device and it has an associated data.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Serial Number</key>
		<string>123456789</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyProductSerialNumberKey		"Serial Number"


/*!
@defined kIOPropertySupportedCDFeaturesKey
@discussion This key is used to define the supported CD Features for a
particular optical device and it has an associated bitfield. See
<IOKit/scsi/IOSCSIMultimediaCommandsDevice.h> for definitions of the
bits and associated bitmasks.

Requirement: Mandatory for optical devices (Peripheral Device Type 05h).

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>SuperDrive</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>CD Features</key>
		<integer>1663</integer>
		<key>DVD Features</key>
		<integer>103</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySupportedCDFeaturesKey		"CD Features"


/*!
@defined kIOPropertySupportedDVDFeaturesKey
@discussion This key is used to define the supported DVD Features for a
particular optical device and it has an associated bitfield. See
<IOKit/scsi/IOSCSIMultimediaCommandsDevice.h> for definitions of the
bits and associated bitmasks.

Requirement: Mandatory for optical devices (Peripheral Device Type 05h).

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>SuperDrive</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>CD Features</key>
		<integer>1663</integer>
		<key>DVD Features</key>
		<integer>103</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySupportedDVDFeaturesKey		"DVD Features"


/*!
@defined kIOPropertySupportedBDFeaturesKey
@discussion This key is used to define the supported BD Features for a
particular optical device and it has an associated bitfield. See
<IOKit/scsi/IOSCSIMultimediaCommandsDevice.h> for definitions of the
bits and associated bitmasks.

Requirement: Mandatory for optical devices (Peripheral Device Type 05h).

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>SuperDrive</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>CD Features</key>
		<integer>1663</integer>
		<key>DVD Features</key>
		<integer>103</integer>
		<key>BD Features</key>
		<integer>21</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySupportedBDFeaturesKey		"BD Features"


/*!
@defined kIOPropertyRigidDiskGeometryKey
@discussion This key is used to define a dictionary containing
rigid disk geometry information.

Requirement: Optional. If a device publishes this dictionary, it
must publish all key/value pairs which are deemed Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyRigidDiskGeometryKey			"Rigid Disk Geometry"


/*!
@defined kIOPropertySectorCountPerTrackKey
@discussion This key is used to define the number of sectors per
each track for a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySectorCountPerTrackKey		"Sector Count per Track"


/*!
@defined kIOPropertyHeadCountKey
@discussion This key is used to define the number of heads for
a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyHeadCountKey					"Head Count"


/*!
@defined kIOPropertyCylinderCountKey
@discussion This key is used to define the number of heads for
a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyCylinderCountKey				"Cylinder Count"


/*!
@defined kIOPropertyBytesPerPhysicalSectorKey
@discussion This key is used to define the number of heads for
a particular medium.

Requirement: Mandatory element of the Rigid Disk Geometry dictionary.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Rigid Disk Geometry</key>
		<dict>
			<key>Sector Count per Track</key>
			<integer>12345</integer>
			<key>Head Count</key>
			<integer>12</integer>
			<key>Cylinder Count</key>
			<integer>12345</integer>
			<key>Bytes per Physical Sector</key>
			<integer>512</integer>
		</dict>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyBytesPerPhysicalSectorKey	"Bytes per Physical Sector"


/*!
@defined kIOPropertyPhysicalBlockSizeKey
@discussion This key is used to define the physical block size of a hard disk drive.

Requirement: Mandatory for hard disk drives with physical block size other than 512 bytes.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Physical Block Size</key>
		<integer>4096</integer>
		<key>Logical Block Size</key>
		<integer>512</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalBlockSizeKey		"Physical Block Size"


/*!
@defined kIOPropertyLogicalBlockSizeKey
@discussion This key is used to define the logical block size of a hard disk drive.

Requirement: Mandatory for hard disk drives with logical block size other than 512 bytes
or that does not match its physical block size.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>Apple</string>
		<key>Product Name</key>
		<string>iPod</string>
		<key>Product Revision Level</key>
		<string>1.0</string>
		<key>Physical Block Size</key>
		<integer>4096</integer>
		<key>Logical Block Size</key>
		<integer>512</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyLogicalBlockSizeKey		"Logical Block Size"


/*!
@defined kIOPropertyTargetDiskModeKey
@discussion This key is used to indicate the device is another computer in Target Disk Mode.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Target Disk Mode</key>
		<true/>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyTargetDiskModeKey		"Target Disk Mode"


/*!
@defined kIOPropertyMediumTypeKey
@discussion This key is used to indicate the medium type of the device.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Medium Type</key>
		<string>Rotational</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumTypeKey		"Medium Type"


/*!
@defined kIOPropertyMediumTypeRotationalKey
@discussion This key is used to indicate the medium type of the device is rotational.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Medium Type</key>
		<string>Rotational</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumTypeRotationalKey		"Rotational"


/*!
@defined kIOPropertyMediumTypeSolidStateKey
@discussion This key is used to indicate the medium type of the device is solid state.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Medium Type</key>
		<string>Solid State</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumTypeSolidStateKey		"Solid State"


/*!
@defined kIOPropertyMediumRotationRateKey
@discussion This key is used to indicate the medium rotation rate in RPM of the device.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Device Characteristics</key>
	<dict>
		<key>Vendor Name</key>
		<string>AAPL</string>
		<key>Product Name</key>
		<string>FireWire Target</string>
		<key>Product Revision Level</key>
		<string>0000</string>
		<key>Rotation Rate</key>
		<integer>7200</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyMediumRotationRateKey		"Rotation Rate"


#endif	/* _IOKIT_IO_STORAGE_DEVICE_CHARACTERISTICS_H_ */
                                                                                                                  IOStorageProtocolCharacteristics.h                                                                  0100644 0001750 0001750 00000036220 12567452411 042254  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        /*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_STORAGE_PROTOCOL_CHARACTERISTICS_H_
#define _IOKIT_IO_STORAGE_PROTOCOL_CHARACTERISTICS_H_

#include <IOKit/storage/IOStorageControllerCharacteristics.h>

/*
 *	Protocol Characteristics - Characteristics defined for protocols.
 */

/*!
@defined kIOPropertyProtocolCharacteristicsKey
@discussion This key is used to define Protocol Characteristics for a particular
protocol and it has an associated dictionary which lists the
protocol characteristics.

Requirement: Mandatory

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATAPI</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define	kIOPropertyProtocolCharacteristicsKey		"Protocol Characteristics"


/*!
@defined kIOPropertySCSIInitiatorIdentifierKey
@discussion An identifier that will uniquely identify this SCSI Initiator for the
SCSI Domain.

Requirement: Mandatory for SCSI Parallel Interface, SAS,
and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Initiator Identifier</key>
		<integer>7</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIInitiatorIdentifierKey		"SCSI Initiator Identifier"


/*!
@defined kIOPropertySCSIDomainIdentifierKey
@discussion An identifier that will uniquely identify this SCSI Domain for the
Physical Interconnect type. This identifier is only guaranteed to be unique for
any given Physical Interconnect and is not guaranteed to be the same across
restarts or shutdowns.

Requirement: Mandatory for SCSI Parallel Interface and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Domain Identifier</key>
		<integer>0</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIDomainIdentifierKey			"SCSI Domain Identifier"


/*!
@defined kIOPropertySCSITargetIdentifierKey
@discussion This is the SCSI Target Identifier for a given SCSI Target Device.

Requirement: Mandatory for SCSI Parallel Interface and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Target Identifier</key>
		<integer>3</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSITargetIdentifierKey			"SCSI Target Identifier"


/*!
@defined kIOPropertySCSILogicalUnitNumberKey
@discussion This key is the SCSI Logical Unit Number for the device server
controlled by the driver.

Requirement: Mandatory for SCSI Parallel Interface, SAS, and Fibre Channel Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
		<key>SCSI Logical Unit Number</key>
		<integer>2</integer>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSILogicalUnitNumberKey			"SCSI Logical Unit Number"


/*!
@defined kIOPropertyPhysicalInterconnectTypeKey
@discussion This key is used to define the Physical Interconnect to which
a device is attached.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeKey		"Physical Interconnect"


/*!
@defined kIOPropertyPhysicalInterconnectLocationKey
@discussion This key is used to define the Physical Interconnect
Location.

Requirement: Mandatory.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectLocationKey	"Physical Interconnect Location"


/*!
@defined kIOPropertySCSIProtocolMultiInitKey
@discussion This protocol characteristics key is used to inform the system
that the protocol supports having multiple devices that act as initiators.

Requirement: Optional.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Fibre Channel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
		<key>Multiple Initiators</key>
		<string>True</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertySCSIProtocolMultiInitKey			"Multiple Initiators"


/*
 *	Values - Values for the characteristics defined above.
 */


/*!
@defined kIOPropertyInternalKey
@discussion This key defines the value of Internal for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is
connected to an internal bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATA</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInternalKey						"Internal"


/*!
@defined kIOPropertyExternalKey
@discussion This key defines the value of External for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is
connected to an external bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Fibre Channel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyExternalKey						"External"


/*!
@defined kIOPropertyInternalExternalKey
@discussion This key defines the value of Internal/External for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is connected
to a bus and it is indeterminate whether it is internal or external,
this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>Internal/External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInternalExternalKey				"Internal/External"


/*!
@defined kIOPropertyInterconnectFileKey
@discussion This key defines the value of File for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is a file
that is being represented as a storage device, this key should be set.

NOTE: This key should only be used when the Physical Interconnect is set to
Virtual Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Virtual Interface</string>
		<key>Physical Interconnect Location</key>
		<string>File</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInterconnectFileKey						"File"


/*!
@defined kIOPropertyInterconnectRAMKey
@discussion This key defines the value of RAM for the key
kIOPropertyPhysicalInterconnectLocationKey. If the device is system memory
that is being represented as a storage device, this key should be set.

NOTE: This key should only be used when the Physical Interconnect is set to
Virtual Interface.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Virtual Interface</string>
		<key>Physical Interconnect Location</key>
		<string>RAM</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyInterconnectRAMKey						"RAM"


/*!
@defined kIOPropertyPhysicalInterconnectTypeATA
@discussion This key defines the value of ATA for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to an ATA bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATA</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeATA				"ATA"


/*!
@defined kIOPropertyPhysicalInterconnectTypeSerialATA
@discussion This key defines the value of SATA for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a SATA bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SATA</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeSerialATA		"SATA"


/*!
@defined kIOPropertyPhysicalInterconnectTypeSerialAttachedSCSI
@discussion This key defines the value of SAS for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a SAS bus, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SAS</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeSerialAttachedSCSI	"SAS"


/*!
@defined kIOPropertyPhysicalInterconnectTypeATAPI
@discussion This key defines the value of ATAPI for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to an ATA bus and follows the ATAPI command specification, this key
should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>ATAPI</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeATAPI			"ATAPI"


/*!
@defined kIOPropertyPhysicalInterconnectTypeUSB
@discussion This key defines the value of USB for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a USB port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>USB</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeUSB				"USB"


/*!
@defined kIOPropertyPhysicalInterconnectTypeFireWire
@discussion This key defines the value of USB for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a FireWire port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>FireWire</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeFireWire			"FireWire"


/*!
 @defined kIOPropertyPhysicalInterconnectTypeSecureDigital
 @discussion This key defines the value of Secure Digital for the key
 kIOPropertyPhysicalInterconnectTypeSecureDigital. If the device is
 connected to a Secure Digital port and follows the Secure Digital 
 specification, this key should be set. 
 
 Example:
 <pre>
 @textblock
 <dict>
    <key>Protocol Characteristics</key>
    <dict>
        <key>Physical Interconnect</key>
        <string>Secure Digital</string>
        <key>Physical Interconnect Location</key>
        <string>Internal</string>
    </dict>
 </dict>
 @/textblock
 </pre>
 */
#define kIOPropertyPhysicalInterconnectTypeSecureDigital	"Secure Digital"


/*!
@defined kIOPropertyPhysicalInterconnectTypeSCSIParallel
@discussion This key defines the value of SCSI Parallel Interface for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a SCSI Parallel port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>SCSI Parallel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeSCSIParallel		"SCSI Parallel Interface"


/*!
@defined kIOPropertyPhysicalInterconnectTypeFibreChannel
@discussion This key defines the value of Fibre Channel Interface for the key
kIOPropertyPhysicalInterconnectTypeKey. If the device is connected
to a Fibre Channel port, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Fibre Channel Interface</string>
		<key>Physical Interconnect Location</key>
		<string>External</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeFibreChannel		"Fibre Channel Interface"


/*!
@defined kIOPropertyPhysicalInterconnectTypeVirtual
@discussion This key defines the value of Virtual Interface for the key
kIOPropertyPhysicalInterconnectTypeVirtual. If the device is being made to look
like a storage device, but is not such in actuality, such as a File or RAM, this
key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>Virtual Interface</string>
		<key>Physical Interconnect Location</key>
		<string>File</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypeVirtual		"Virtual Interface"


/*!
@defined kIOPropertyPhysicalInterconnectTypePCI
@discussion This key defines the value of PCI for the key
kIOPropertyPhysicalInterconnectTypePCI. If the device is connected
via PCI, this key should be set.

Example:
<pre>
@textblock
<dict>
	<key>Protocol Characteristics</key>
	<dict>
		<key>Physical Interconnect</key>
		<string>PCI</string>
		<key>Physical Interconnect Location</key>
		<string>Internal</string>
	</dict>
</dict>
@/textblock
</pre>
*/
#define kIOPropertyPhysicalInterconnectTypePCI		"PCI"


#endif	/* _IOKIT_IO_STORAGE_PROTOCOL_CHARACTERISTICS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                ata/                                                                                                0040755 0001750 0001750 00000000000 12612224742 034231  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage                                                        IOATAPIProtocolTransport.h                                                                          0100644 0001750 0001750 00000035065 12567471030 041140  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage/ata                                                    /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
  @header IOATAPIProtocolTransport
  Contains the class definition for IOATAPIProtocolTransport.
*/


#ifndef _IOKIT_IO_ATAPI_PROTOCOL_TRANSPORT_H_
#define _IOKIT_IO_ATAPI_PROTOCOL_TRANSPORT_H_

#define kIOPropertyATAPIMassStorageCharacteristics 		"ATAPI Mass Storage Characteristics"

#if defined(KERNEL) && defined(__cplusplus)

/* General IOKit includes */
#include <IOKit/IOLib.h>
#include <IOKit/IOMessage.h>
#include <IOKit/IOService.h>
#include <IOKit/IOCommandPool.h>

/* IOKit ATA Family includes */
#include <IOKit/ata/IOATADevice.h>
#include <IOKit/ata/IOATATypes.h>

/* IOKit ATA Storage includes */
#include <IOKit/storage/ata/IOATAStorageDefines.h>

/* SCSI Architecture Model Family includes */
#include <IOKit/scsi/IOSCSIProtocolServices.h>

// Forward class declaration
class IOATAPIProtocolTransport;

/*! 
	@typedef ATAPIClientData
	@param cmd IOATACommand for request.
	@param self Pointer to the object. 
	@param scsiTask SCSITaskIdentifier of request. 
	@discussion This structure is stuffed into the refcon so we can associate which
	IOATACommand and SCSITaskIdentifier is completing.
*/

struct ATAPIClientData
{
	IOATACommand *				cmd;
	IOATAPIProtocolTransport *	self;
	SCSITaskIdentifier			scsiTask;
};
typedef struct ATAPIClientData ATAPIClientData;


/*!
	@class IOATAPIProtocolTransport
	@abstract SCSI Protocol Driver Family for ATAPI Devices. 
	@discussion IOATAPIProtocolTransport contains all the bus specific support for ATAPI compliant devices.
	To add vendor specific features or workarounds you will sub-class the appropriate
	methods of this family. 
*/

class IOATAPIProtocolTransport : public IOSCSIProtocolServices
{
	
	OSDeclareDefaultStructors ( IOATAPIProtocolTransport )
	
public:

	// ---- IOService methods overridden ----
	
	bool 			init 	( OSDictionary * propTable );
	
	// The start method is called to start our services. If the device
	// can be controlled by this object, then we return true, else we
	// return false. start() is usually used to allocate resources once
	// it is determined that the device can be controlled by this object.
	virtual bool 	start 	( IOService * provider );
	
	// The stop method is called to stop our services. It is primarily
	// called for deallocation of resources.
	virtual void 	stop 	( IOService *  provider );
	
	// This method is our last chance to free all resources allocated.
	virtual void	free	( void );
	
	
protected:

	// ---- member variables ----
	
	IOATADevice *			fATADevice;
	ataUnitID				fATAUnitID;
	ataDeviceType			fATADeviceType;
	ataSocketType			fATASocketType;
	atapiConfig				fATAPIPacketConfig;
	UInt8					fPIOMode;
	UInt8					fDMAMode;
	UInt8					fUltraDMAMode;
	IOCommandGate *			fCommandGate;
	IOCommandPool *			fCommandPool;
	IOATACommand *			fResetCommand;
	IOATACommand *			fConfigCommand;
	IOATACommand *			fIdentifyCommand;
	char					fRevision[kSizeOfATARevisionString + 1];
	char					fModel[kSizeOfATAModelString + 1];
	bool					fWakeUpResetOccurred;
	bool					fPhysicallyConnected;
	
	// Used for low-power polling support
	thread_call_t			fPollingThread;
	
	UInt16					fDeviceIdentifyData[256];
	IOMemoryDescriptor *	fDeviceIdentifyBuffer;
	bool					fResetInProgress;

	// Binary Compatibility instance variable expansion
	struct ExpansionData
	{
		UInt32		fSemaphore;
		UInt32		fMediaNotifyValue;
	};
	ExpansionData * reserved;
	
	// ---- IOService methods overridden ----
	
	// The message method is used to listen to messages from our provider, the ATA controller.
	// It sends messages for bus reset notifications and for device removal (such as MediaBay,
	// PC card, etc.)
	virtual IOReturn message ( UInt32 type, IOService * provider, void * argument = 0 );
	
	// ---- Protocol transport methods overridden ----

	// Send a SCSI Command to the device.  If the command was sent to the
	// device and is pending completion, the subclass should return true and
	// return back the kSCSIServiceResponse_Request_In_Process response. 
	// If the command completes immediately with an error, the subclass will
	// return true and return back the appropriate status.
	// if the subclass is currently processing all the commands it can, the
	// subclass will return false and the command will be resent next time
	// CommandCompleted is called.  
	virtual bool SendSCSICommand ( 	SCSITaskIdentifier 		request,
									SCSIServiceResponse * 	serviceResponse,
									SCSITaskStatus *		taskStatus );
		
	// This is a stub - not implemented in upper layer yet. Eventually, there
	// will be a way to abort a task or task set and this method will be called.
	// It will abort any commands which have not been executed by the ATA controller
	virtual SCSIServiceResponse AbortSCSICommand ( SCSITaskIdentifier request );
	
	// The IsProtocolServiceSupported method will return true if the protocol
	// layer supports the specified feature.
	virtual bool IsProtocolServiceSupported ( SCSIProtocolFeature feature, void * serviceValue );
	
	// The HandleProtocolServiceFeature method will return true if the protocol
	// layer properly handled the specified feature.
	virtual bool HandleProtocolServiceFeature ( SCSIProtocolFeature feature, void * serviceValue );

	// ------ Power Management Support ------

	// The HandlePowerOff method is called to do any bus specific activity
	// necessary before shutting down and going to sleep.
	virtual IOReturn 		HandlePowerOff 	( void );

	// The HandlePowerOn method is called to do any bus specific activity
	// necessary to recover from power-on/wake from sleep (e.g. device reset on ATAPI)
	virtual IOReturn 		HandlePowerOn 	( void );

	
	// ---- Methods defined by this class ----

	// Static callback proc for all SCSITask objects, it calls through to
	// SCSITaskCallbackFunction.
	static void 			sSCSITaskCallbackProc ( IOATACommand * cmd );
	
	// Callback proc for synchronous ATA only type commands.
	static void 			sATACallbackSync ( IOATACommand * cmd );

	// Callback proc for asynchronous ATAPI resets.
	static void 			sATAPIResetCallback ( IOATACommand * cmd );

	// Callback proc that does nothing.
	static void 			sATAPIVoidCallback ( IOATACommand * cmd );

	// State machine for device configuration.
	static void				sATAPIConfigStateMachine ( IOATACommand * cmd );
	
	// Used for low-power polling.
	static void				sPollStatusRegister ( void * xptDriver, void * refCon );
	
	// Static callback for low-power polling.
	static void				sPollStatusRegisterCallback ( IOATACommand * cmd );

	// This method is called by the SCSITaskCallbackFunction and it calls the
	// inherited CommandCompleted message with the results of the task.
	virtual void CompleteSCSITask ( SCSITaskIdentifier 	scsiTask,
									SCSIServiceResponse serviceResponse,
									SCSITaskStatus		taskStatus );

	// The SCSITaskCallbackFunction method is called by the static callback procedure
	// to complete SCSITask operations. This method may be subclassed if a device
	// workaround is necessary.
	virtual void SCSITaskCallbackFunction ( IOATACommand * 		cmd,
											SCSITaskIdentifier 	scsiTask );
	
	// The ReportATAPIDeviceType method returns the ataDeviceType for ATAPI
	virtual ataDeviceType 	ReportATAPIDeviceType ( void ) const;
	
	// The InspectDevice method is called to inspect the ATA device and verify
	// that it is a device which can be controlled by this object
	virtual bool			InspectDevice ( IOATADevice * ataDevice );
	
	// The AllocateATACommandObjects method is called to allocate a pool of
	// IOATACommands for general purpose I/O usage.
	virtual void 			AllocateATACommandObjects ( void );
	
	// The DeallocateATACommandObjects method is called to deallocate a pool of
	// IOATACommands for general purpose I/O usage.
	virtual void 			DeallocateATACommandObjects ( void );
	
	// The GetATACommandObject method is called to retrieve a command from
	// the pool. Pass true to allow the method to sleep waiting for a command,
	// else pass false. If false is passed, there is NO guarantee that a valid
	// command will be returned. If true is passed, it IS guaranteed that a
	// valid command will be returned, but the thread may be slept waiting for
	// those resources.
	virtual IOATACommand *	GetATACommandObject	( bool okToSleep = true );
	
	// The ReturnATACommandObject method is called to return a command to
	// the pool.
	virtual void			ReturnATACommandObject	( IOATACommand * cmd );

	// The sSwapBytes16 method is used to word-swap the Device Identify data
	// on big endian systems. Since all identify data is returned in little endian
	// values, it must be word-swapped before inspected.
	static void				sSwapBytes16 ( UInt8 * buffer, IOByteCount numBytesToSwap );
	
	// The sConvertHighestBitToNumber method is used to find the highest bit in a
	// word and return a numeric value.	This is used to find the highest possible
	// values for PIO, DMA, and UltraDMA transfer modes.
	static UInt8			sConvertHighestBitToNumber ( UInt16 bitField );

	// The sSetWakeupResetOccurred method is used to safely set member variables
	// behind the command gate.
	static void				sSetWakeupResetOccurred ( IOATAPIProtocolTransport * driver,
												   	  bool resetOccurred );

	// The sCheckWakeupResetOccur method is used to safely check member variables
	// behind the command gate.
	static void				sCheckWakeupResetOccurred ( IOATAPIProtocolTransport * driver,
														bool * resetOccurred );
	
	// The DidWakeupResetOccur method is used to safely find out if a reset
	// occurred while we were asleep.
	virtual bool			CheckWakeupResetOccurred ( void );
	
	// The WakeupResetOccurred method is used to safely set/clear the reset flag.
	virtual void			SetWakeupResetOccurred ( bool resetOccurred );

	// The SetPIOTransferMode method is used to set the programmed input-output (PIO)
	// transfer mode. The highest value reported by the device is used.
	virtual IOReturn		SetPIOTransferMode ( IOATACommand * cmd, bool forceSync );
	
	// The SetDMATransferMode method is used to set the direct memory access (DMA)
	// transfer mode. The highest value reported by the device is used.
	virtual IOReturn		SetDMATransferMode ( IOATACommand * cmd, bool forceSync );
	
	// The IdentifyAndConfigureATAPIDevice method is called to correctly identify
	// and configure an ATAPI device.
	virtual IOReturn 		IdentifyAndConfigureATAPIDevice ( void );
	
	// The ConfigureATAPIDevice method is called to correctly configure the ATAPI
	// device. It currently configures any PIO/DMA/UDMA transfer modes but may be
	// expanded in the future.
	virtual IOReturn 		ConfigureATAPIDevice ( void );

	// The ReconfigureATAPIDevice method is called to correctly reconfigure the ATAPI
	// device after a reset event has occurred (bus reset or device reset). It
	// currently reconfigures any PIO/DMA/UDMA transfer modes but may be expanded in
	// the future.
	virtual IOReturn 		ReconfigureATAPIDevice ( void );
	
	// The IdentifyATAPIDevice method is called to correctly identify the ATAPI
	// device. It currently issues the Identify ATAPI Device packet command and
	// uses the data to correctly configure the device.
	virtual IOReturn 		IdentifyATAPIDevice ( void );
	
	// The ResetATAPIDevice method is called to issue a Device Reset (also known
	// as a SOFT RESET). This method will only reset the specified device on the
	// bus.
	virtual IOReturn 		ResetATAPIDevice ( void );
	
	// The SendATASleepCommand method is called to put an ATAPI drive in sleep
	// mode.
	virtual IOReturn		SendATASleepCommand ( void );
	
	// The EnablePollingOfStatusRegister method is called to set up a timer for
	// the call to PollStatusRegister. It is called when the SCSI Application Layer
	// driver wants to enable low-power polling and after a poll which does not
	// see a change in the register status.
	virtual void			EnablePollingOfStatusRegister ( void );

	// The DisablePollingOfStatusRegister method is called to cancel any thread
	// call which is doing a poll and drop the retain count on the object.
	virtual void			DisablePollingOfStatusRegister ( void );
	
	// The PollStatusRegister method is used to do low-power polling on drives which
	// support it. This feature is enabled by the SCSI Application Layer driver.
	virtual void			PollStatusRegister ( void * refCon );
	
	// Callback method for the polling of the status register.
	virtual void			PollStatusRegisterCallback ( IOATACommand * cmd );
	
	// The TurnDrivePowerOff method is called to turn power to the drive OFF
	IOReturn				TurnDrivePowerOff ( void );
	
	IOReturn				SendCommand ( IOATACommand * cmd );
	IOReturn				GatedWaitForRequest ( void * data );
	
private:
	
	// Binary Compatibility reserved method space
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 1 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 2 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 3 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 4 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 5 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 6 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 7 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 8 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 9 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 10 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 11 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 12 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 13 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 14 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 15 );
	OSMetaClassDeclareReservedUnused ( IOATAPIProtocolTransport, 16 );
	
};

#endif /* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_IO_ATAPI_PROTOCOL_TRANSPORT_H_ */                                                                                                                                                                                                                                                                                                                                                                                                                                                                           IOATAStorageDefines.h                                                                               0100644 0001750 0001750 00000022315 12567452710 040071  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/storage/ata                                                    /*
 * Copyright (c) 1998-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IO_ATA_STORAGE_DEFINES_H_
#define _IOKIT_IO_ATA_STORAGE_DEFINES_H_

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif
	
/*
 * Important word offsets in device identify data as
 * defined in ATA-5 standard
 */
	
enum
{
	kATAIdentifyConfiguration				= 0,
	kATAIdentifyLogicalCylinderCount 		= 1,
	kATAIdentifyLogicalHeadCount			= 3,
	kATAIdentifySectorsPerTrack				= 6,
	kATAIdentifySerialNumber				= 10,
	kATAIdentifyFirmwareRevision			= 23,
	kATAIdentifyModelNumber					= 27,
	kATAIdentifyMultipleSectorCount			= 47,
	kATAIdentifyDriveCapabilities			= 49,
	kATAIdentifyDriveCapabilitiesExtended	= 50,
	kATAIdentifyPIOTiming					= 51,
	kATAIdentifyExtendedInfoSupport			= 53,
	kATAIdentifyCurrentCylinders			= 54,
	kATAIdentifyCurrentHeads				= 55,
	kATAIdentifyCurrentSectors				= 56,
	kATAIdentifyCurrentCapacity				= 57,
	kATAIdentifyCurrentMultipleSectors		= 59,
	kATAIdentifyLBACapacity					= 60,
	kATAIdentifySingleWordDMA				= 62,
	kATAIdentifyMultiWordDMA				= 63,
	kATAIdentifyAdvancedPIOModes			= 64,
	kATAIdentifyMinMultiWordDMATime			= 65,
	kATAIdentifyRecommendedMultiWordDMATime	= 66,
	kATAIdentifyMinPIOTime					= 67,
	kATAIdentifyMinPIOTimeWithIORDY			= 68,
	kATAIdentifyQueueDepth					= 75,
	kATAIdentifyMajorVersion				= 80,
	kATAIdentifyMinorVersion				= 81,
	kATAIdentifyCommandSetSupported			= 82,
	kATAIdentifyCommandSetSupported2		= 83,
	kATAIdentifyCommandExtension1			= 84,
	kATAIdentifyCommandExtension2			= 85,
	kATAIdentifyCommandsEnabled				= 86,
	kATAIdentifyCommandsDefault				= 87,
	kATAIdentifyUltraDMASupported			= 88,
	kATAIdentifyPhysicalLogicalSectorSize	= 106,
	kATAIdentifyWordsPerLogicalSector1		= 117,
	kATAIdentifyWordsPerLogicalSector2		= 118,
	kATAIdentifyLogicalSectorAlignment		= 209,
	kATAIdentifyIntegrity					= 255
};
	

/* 
 * Important bits in device identify data
 * as defined in ATA-5 standard
 */
 
enum
{
	// Configuration field (word 0)
	kFixedDeviceBit			= 6,							// Fixed disk indicator bit
	kRemoveableMediaBit		= 7,							// Removable media indicator bit
	kNonMagneticDriveBit	= 15,							// Non-magnetic drive indicator bit
	
	kFixedDeviceMask		= (1 << kFixedDeviceBit),		// Mask for fixed disk indicator
	kRemoveableMediaMask	= (1 << kRemoveableMediaBit),	// Mask for removable media indicator
	kNonMagneticDriveMask	= (1 << kNonMagneticDriveBit),	// Mask for non-magnetic drive indicator

	// Capabilities field (word 49)
	kDMABit					= 8,							// DMA supported bit
	kLBABit					= 9,							// LBA supported bit
	kIORDYDisableBit		= 10,							// IORDY can be disabled bit
	kIORDYBit				= 11,							// IORDY supported bit
	kStandbyTimerBit		= 13,							// Standby timer supported bit

	kDMASupportedMask		= (1 << kDMABit),				// Mask for DMA supported
	kLBASupportedMask		= (1 << kLBABit),				// Mask for LBA supported
	kDMADisableMask			= (1 << kIORDYDisableBit),		// Mask for DMA supported
	kIORDYSupportedMask		= (1 << kIORDYBit),				// Mask for IORDY supported
	kStandbySupportedMask	= (1 << kStandbyTimerBit),		// Mask for Standby Timer supported

	// Extensions field (word 53)
	kCurFieldsValidBit		= 0,							// Bit to show words 54-58 are valid
	kExtFieldsValidBit		= 1,							// Bit to show words 64-70 are valid
	kCurFieldsValidMask		= (1 << kCurFieldsValidBit),	// Mask for current fields valid
	kExtFieldsValidMask		= (1 << kExtFieldsValidBit),	// Extension word valid

	// Advanced PIO Transfer Modes field (word 64)
	kMode3Bit				= 0,							// Bit to indicate mode 3 is supported
	kMode3Mask				= (1 << kMode3Bit),				// Mask for mode 3 support
	
	// Integrity of Identify data (word 255)
	kChecksumValidCookie	= 0xA5							// Bits 7:0 if device supports feature
	
};


/* String size constants */
enum
{
	kSizeOfATAModelString 		= 40,
	kSizeOfATARevisionString	= 8
};

/* ATA Command timeout constants ( in milliseconds ) */
enum
{
	kATATimeout10Seconds	= 10000,
	kATATimeout30Seconds	= 30000,
	kATATimeout45Seconds	= 45000,
	kATATimeout1Minute		= 60000,
	kATADefaultTimeout		= kATATimeout30Seconds
};


/* Retry constants */
enum
{
	kATAZeroRetries		= 0,
	kATADefaultRetries	= 4
};

/* max number of blocks supported in ATA transaction */
enum
{
	kIOATASectorCount8Bit	= 8,
	kIOATASectorCount16Bit	= 16
};

enum
{
	kIOATAMaximumBlockCount8Bit		= (1 << kIOATASectorCount8Bit),
	kIOATAMaximumBlockCount16Bit	= (1 << kIOATASectorCount16Bit),
	
	// For backwards compatibility
	kIOATAMaxBlocksPerXfer			= kIOATAMaximumBlockCount8Bit
};



/* Power Management time constants (in seconds) */
enum
{
	kSecondsInAMinute	= 60,
	k5Minutes			= 5 * kSecondsInAMinute
};

/* Bits for features published in Word 82 of device identify data */
enum
{
	kATASupportsSMARTBit					= 0,
	kATASupportsPowerManagementBit  		= 3,
	kATASupportsWriteCacheBit				= 5
};

/* Masks for features published in Word 82 of device identify data */
enum
{
	kATASupportsSMARTMask					= (1 << kATASupportsSMARTBit),
	kATASupportsPowerManagementMask 		= (1 << kATASupportsPowerManagementBit),
	kATASupportsWriteCacheMask				= (1 << kATASupportsWriteCacheBit)
};

/* Bits for features published in Word 83 of device identify data */
enum
{
	kATASupportsCompactFlashBit				= 2,
	kATASupportsAdvancedPowerManagementBit 	= 3,
	
	kATASupports48BitAddressingBit			= 10,
	
	kATASupportsFlushCacheBit				= 12,
	kATASupportsFlushCacheExtendedBit		= 13
};

/* Masks for features published in Word 83 of device identify data */
enum
{
	kATASupportsCompactFlashMask			= (1 << kATASupportsCompactFlashBit),
	kATASupportsAdvancedPowerManagementMask = (1 << kATASupportsAdvancedPowerManagementBit),
	
	kATASupports48BitAddressingMask			= (1 << kATASupports48BitAddressingBit),
	
	kATASupportsFlushCacheMask				= (1 << kATASupportsFlushCacheBit),
	kATASupportsFlushCacheExtendedMask		= (1 << kATASupportsFlushCacheExtendedBit),
	
	// Mask to ensure data is valid
	kIdentifyWordValidationMask				= 0xC000,
	kIdentifyWordValid						= 0x4000
};

/* Bits for features published in Word 84 of device identify data */
enum
{
	kATAForceUnitAccessFeatureBit			= 6,
};

/* Masks for features published in Word 84 of device identify data */
enum
{
	kATAForceUnitAccessFeatureMask			= (1 << kATAForceUnitAccessFeatureBit),
};

/* Bits for features published in Word 85 of device identify data */
enum
{
	kATAWriteCacheEnabledBit				= 5
};

/* Masks for features published in Word 85 of device identify data */
enum
{
	kATAWriteCacheEnabledMask				= (1 << kATAWriteCacheEnabledBit)
};


/* Bits for features published in Word 106 of device identify data */
enum
{
	kATAPhysicalLogicalEnabledBit0			= 15,
	kATAPhysicalLogicalEnabledBit1			= 14,
	kATAMultipleLogicalSectorsBit			= 13,
	kATAValidLogicalSectorSizeBit			= 12	
};

/* Masks for features published in Word 106 of device identify data */
enum
{
	kATAPhysicalLogicalEnabledMask			= (1 << kATAPhysicalLogicalEnabledBit0) | (1 << kATAPhysicalLogicalEnabledBit1),
	kATAPhysicalLogicalEnabledValue			= (0 << kATAPhysicalLogicalEnabledBit0) | (1 << kATAPhysicalLogicalEnabledBit1),
	kATAMultipleLogicalSectorsMask			= (1 << kATAMultipleLogicalSectorsBit),
	kATAValidLogicalSectorSizeMask			= (1 << kATAValidLogicalSectorSizeBit),
	kATAPhysicalSectorSizeMask				= 0xF,
	kATALogicalSectorAlignmentMask			= 0x3FFF
};

// Property table keys
#define kIOATASupportedFeaturesKey		"ATA Features"

/* ATA supported features */
enum
{
	kIOATAFeaturePowerManagement			= 0x01,		/* OBSOLETE */
	kIOATAFeatureWriteCache					= 0x02,		/* OBSOLETE */
	kIOATAFeatureAdvancedPowerManagement 	= 0x04,
	kIOATAFeatureCompactFlash				= 0x08,
	kIOATAFeature48BitLBA					= 0x10,
	kIOATAFeatureSMART						= 0x20
};

/* ATA Advanced Power Management settings (valid settings range from 1-254),
the settings below are the more common settings */
enum
{
	kIOATAMaxPerformance					= 0xFE,
	kIOATADefaultPerformance			 	= 0x80,
	kIOATAMaxPowerSavings					= 0x01
};

/* ATA Transfer Mode bit masks */
enum
{
	kATAEnableUltraDMAModeMask 		= 0x40,
	kATAEnableMultiWordDMAModeMask	= 0x20,
	kATAEnablePIOModeMask			= 0x08
};


typedef uint32_t	ATAOperationType;
enum
{
	kATAOperationTypeRead				= 0,
	kATAOperationTypeWrite				= 1,
	kATAOperationTypeFlushCache			= 2,
	kATAOperationTypeSMART				= 3,
	kATAOperationTypeConfiguration		= 4,
	kATAOperationTypePowerManagement	= 5,
	kATAOperationTypeSMS				= 6
};

#if defined(KERNEL)

typedef struct __ATAIORequest *	ATARequestIdentifier;

#endif	// defined(KERNEL)
	
#ifdef __cplusplus
}
#endif

#endif	/* _IOKIT_IO_ATA_STORAGE_DEFINES_H_ */
                                                                                                                                                                                                                                                                                                                   stream/                                                                                             0040755 0001750 0001750 00000000000 12612224742 033313  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOStream.h                                                                                          0100644 0001750 0001750 00000052352 12567451750 035165  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/stream                                                         /*
 *  Copyright 2006 Apple Computer, Inc. All rights reserved.
 *
 */

#if !defined(__IOKIT_IOSTREAM_H)
#define __IOKIT_IOSTREAM_H

#include <IOKit/IOService.h>
#include <IOKit/IOMemoryDescriptor.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/IOUserClient.h>

#include <IOKit/stream/IOStreamShared.h>

/*!
    @header IOStream.h
    Definitions for IOStream family.
 */

class IOStreamBuffer;

/*!
    @class IOStream
    @abstract
    A class representing a stream of data buffers passed from kernel to
    user space and back again.
    @discussion
    The IOStream class defines a mechanism for moving buffers of data from
    kernel space to user space or vice-versa.  The policy for which direction
    the data flows and the nature of the data is left up the the implementer
    of the driver which uses IOStream.

    Although it is expected that the client of an IOStream will be in user space,
    this is not required.
 
    References to "output" mean "from the IOStream to the user client", and
    "input" means "from the user client to the IOStream."

 */

class IOStream : public IOService
{
    OSDeclareDefaultStructors(IOStream);

 protected:
    OSArray *               _buffers;       // IOStreamBuffer objects in this stream

    IOItemCount             _queueCount;    // Number of entries for the queues
    
    IOMemoryDescriptor *    _inputQueueDescriptor;
    IOMemoryMap *           _inputQueueMap;
    
    IOMemoryDescriptor *    _outputQueueDescriptor;
    IOMemoryMap *           _outputQueueMap;
    
    IOStreamBufferQueue *   _outputQueue;   // Shared memory for buffers out to user space
    IOStreamBufferQueue *   _inputQueue;    // Shared memory for buffers in from user space
    
    mach_port_t             _outputPort;
    mach_port_t             _inputPort;
    
    OSArray *               _memoryMaps;    // Maps for data queues
    
    IOStreamMode            _streamMode;
    
 public:
        
    /*!
        @functiongroup Creating IOStream objects
     */
        
    /*!
        @function withBuffers
     @param mode The initial mode of the stream, either output, input, or input/output.
     @param queueLength The nuber of queue entries to reserve in the input and output queue.
     Zero means to make the queues big enough to accommodate all the buffers at once.
     @param properties
     A dictionary of properties which will be set on the stream.
     @param buffers
     An array of IOStreamBuffer objects which will be the buffers for this stream.
     */
        
    static IOStream *withBuffers(OSArray *buffers, IOStreamMode mode = kIOStreamModeOutput, IOItemCount queueLength = 0, OSDictionary *properties = 0);
    
    virtual bool init(OSDictionary *properties = 0);
    
    /*!
        @function initWithBuffers
     @param mode The initial mode of the stream, either output, input, or input/output.
     @param queueLength The nuber of queue entries to reserve in the input and output queue.
     Zero means to make the queues big enough to accommodate all the buffers at once.
     @param properties
     A dictionary of properties which will be set on the stream.
     @param buffers
     An array of IOStreamBuffer objects which will be the buffers for this stream.
     */
    virtual bool initWithBuffers(OSArray *buffers, IOStreamMode mode = kIOStreamModeOutput, IOItemCount queueLength = 0, OSDictionary *properties = 0);
    
    /*!
        @function free
     */
    virtual void free(void);
    
    /*!
        @functiongroup Opening and closing streams
     */
    
    /*!
        @function handleOpen
        @abstract The handleOpen() method relies on the default IOService behavior
        to ensure that
        only one client has the stream open at a time.
        The shared input and output queues are created at open time.
     @param options
     @param arg
     */
    virtual bool handleOpen( 	IOService *	  forClient,
                                IOOptionBits	  options,
                                void *		  arg );
    
    /*!
        @function handleClose
        @abstract The handleClose method destroys the shared input and output
        queues.
     @param options
     */
    virtual void handleClose(   IOService *	  forClient,
                                IOOptionBits  options );

    /*!
        @functiongroup Managing shared queues
     */
    
    /*!
        @function createQueues
        @abstract Creates the shared input and output queues, without regard
        to whether the stream is open or not.
        Normally this is called by handleOpen().
     @param queueLength
     @param options
     @result Returns kIOReturnSuccess if the queues were successfully created.
     */
    virtual IOReturn createQueues( IOItemCount queueLength = 0, IOOptionBits options = 0 );
    
    /*!
        @function destroyQueues
        @abstract Releases the shared input and output queues.
     @result Returns kIOReturnSuccess if the queues were successfully destroyed.
     The queues cannot be destroyed while the stream is open by a client.
     */
    virtual IOReturn destroyQueues( void );
    
    /*!
        @function getOutputQueue
     @result A pointer to the output IOStreamBufferQueue structure for the stream,
     or NULL if the stream is not open and the queue has not been created yet.
     */
    virtual IOStreamBufferQueue *getOutputQueue(void);           // get shared-memory output queue
    
    /*!
        @function getOutputQueueMemoryDescriptor
     @result An IOMemoryDescriptor object repesenting the shared memory
     output queue buffer.
     */
    virtual IOMemoryDescriptor *getOutputQueueMemoryDescriptor(void);
    
    /*!
        @function getInputQueue
     @result A pointer to the input IOStreamBufferQueue structure for the stream,
     or NULL if the stream is not open and the queue has not been created yet.
     */
    virtual IOStreamBufferQueue *getInputQueue(void);            // get shared-memory input queue
    
    /*!
        @function getInputQueueMemoryDescriptor
     @result An IOMemoryDescriptor object repesenting the shared memory
     input queue buffer.
     */
    virtual IOMemoryDescriptor *getInputQueueMemoryDescriptor(void);
    
    
    /*!
        @functiongroup Managing buffers in an IOStream
     */
    
    /*!
        @function addBuffer
        @abstract Add a buffer to an IOStream.
        @param buffer
        @discussion
        Adds an IOStreamBuffer to an IOStream.  It will be added to the end
     of the buffer array, so the buffer ID of existing buffers will not change.
     */
    virtual IOReturn addBuffer(IOStreamBuffer *buffer);  // add a new buffer to the stream
    
    /*!
        @function addBuffers
     @param buffers
     @result
     */
    virtual IOReturn addBuffers(OSArray *buffers);

    /*!
        @function removeBuffer
     @param buffer A pointer to an IOStreamBuffer object in the stream.
     @result Returns kIOReturnSuccess if the buffer was removed, or kIOReturnNotFound
     if the buffer was not in this stream.
     @abstract
     Removes a buffer from the stream.  Buffers cannot be removed
     while the stream is open, as this will change the buffer IDs of existing
     buffers.
     */
    virtual IOReturn removeBuffer(IOStreamBuffer *buffer);
    
    /*!
        @function removeBuffer
     @param bufferID The ID of the buffer to remove.
     @result Returns kIOReturnSuccess if the buffer was removed.
     @abstract
     Removes a buffer from the stream.  Buffers cannot be removed
     while the stream is open, as this will change the buffer IDs of existing
     buffers.
     */
    
    virtual IOReturn removeBuffer(IOStreamBufferID bufferID);
    
    /*!
        @function removeAllBuffers
     @result
     */
    virtual IOReturn removeAllBuffers( void );
    
    /*!
        @function removeAllBuffers
     @result Returns kIOReturnSuccess if all the buffers were successfully
     removed.   Buffers cannot be removed
     while the stream is open, as this will change the buffer IDs of existing
     buffers.
     
     */
    virtual IOItemCount getBufferCount( void );
    
    /*!
        @function getBuffers
        @abstract Get an array containing all the buffers in the stream.
        @discussion
        Returns an OSArray containing all the buffers in the stream in order of their buffer ID.
     */
    virtual OSArray *getBuffers( void );
    
    
    /*!
        @function getBufferWithID
     @param bufferID
     The ID of the buffer to get.
     @result
     A pointer to an IOStreamBuffer object, or NULL if the
     buffer ID was invalid for this stream.
     */
    
    virtual IOStreamBuffer *getBufferWithID(IOStreamBufferID bufferID);
    
    /*!
        @functiongroup Managing notification ports
     */
    
    /*!
        @function getInputPort
        @abstract Get the Mach port used to receive notifications
        from user space that a buffer has been added to the input queue.
     */
    virtual mach_port_t getInputPort(void);
    
    /*!
        @function setInputPort
        @abstract Set the Mach port used to receive notifications from
        user space that a buffer has been added to the input queue.
        @param port

     */
    virtual IOReturn setInputPort(mach_port_t port);
    
    /*!
        @function getOutputPort
        @abstract Get the Mach port used to send notifications to user space
        that a buffer has been added to the output queue.
     */
    virtual mach_port_t getOutputPort(void);
    
    /*!
        @function setOutputPort
        @abstract Set the Mach port used to send notifications to user space
        that a buffer has been added to the output queue.
        @param port
     */
    virtual IOReturn setOutputPort(mach_port_t port);
    
    /*!
        @function sendOutputNotification
     @abstract Send a notification to the user client that data is available
     for reading on the output queue.  This will result in the user's output
     handler being called, if they registered one.
     @result Returns kIOReturnSuccess if the notification was successfully sent.
     */
    virtual IOReturn sendOutputNotification(void);
    
    /*!
        @functiongroup Queueing and dequeueing buffers
     */
    
    /*!
        @function enqueueOutputBuffer
        @abstract A convenience method for enqueueing a buffer.
        @param buffer
     @param dataOffset
     @param dataLength
     @param controlOffset
     @param controlLength
     @result
     */
    virtual IOReturn enqueueOutputBuffer(IOStreamBuffer *buffer,
                                         IOByteCount dataOffset = 0,
                                         IOByteCount dataLength = 0,
                                         IOByteCount controlOffset = 0,
                                         IOByteCount controlLength = 0);
    
    
    /*!
        @function enqueueOutputEntry
        @param entry
        @result
     */
    virtual IOReturn enqueueOutputEntry( IOStreamBufferQueueEntry *entry );
    
    /*!
        @function dequeueInputEntry
        @param entry
     @result
     */
    virtual IOReturn dequeueInputEntry( IOStreamBufferQueueEntry *entry );
    
    /*!
        @functiongroup Managing notifications
     */
    
    /*!
        @function inputCallback
        @abstract Input callback function to be implemented by a subclass;
        @param token
        A 32-bit token value that can be used by convention to communicate
        from user space to the stream.  The semantics of this value are
        defined by the IOStream subclass.
        @discussion
        The inputCallback() method is called as a result of a fast trap
        from user space.  It is called on the same thread as the user request,
        but the subclass should implement this call as a notification sent
        to a workloop so that the request is asynchronous.
     */
    virtual void inputCallback( UInt32 token );
    
    /*!
        @function inputSyncCallback
        @abstract Input callback function to be implemented by a subclass.
        @param token
        A 32-bit token value that can be used by convention to communicate
        from user space to the stream.  The semantics of this value are
        defined by the IOStream subclass.
        @discussion
        The inputSyncCallback() method is called as a result of a fast trap
        from user space.  It is called on the same thread as the user request,
        so no context switch is necessary.
     */
    virtual void inputSyncCallback( UInt32 token );
    
    /*!
        @functiongroup Stream control
     */
    
    /*!
        @function getStreamMode
     @abstract Returns the mode of the stream, either input or output.
     @result The mode of the stream, either kIOStreamModeInput
     (from user space to kernel space) or the default
     kIOStreamModeOutput (from kernel space to user space).
     */
    virtual IOStreamMode getStreamMode(void);
    
    /*!
        @function setStreamMode
     @abstract Sets the mode of the stream, either input or output.
     @discussion Subclasses may define whether it is possible
     to change the mode of a stream.
     */
    virtual IOReturn setStreamMode(IOStreamMode mode);

    /*!
        @function startStream
     @abstract Start sending data on a stream.
     @result Returns kIOReturnSuccess if the stream was successfully started.
     @discussion This must be implemented by a subclass.
     */
    virtual IOReturn startStream(void);
    
    /*!
        @function stopStream
     @abstract Stop sending data on a stream.
     @result Returns kIOReturnSuccess if the stream was successfully stopped.
     @discussion This must be implemented by a subclass.
     */
    virtual IOReturn stopStream(void);
    
    /*!
        @function suspendStream
     @abstract Temporarily suspend data flow on the stream.
     @result Returns kIOReturnSuccess if the stream was successfully suspended.
     @discussion This must be implemented by a subclass.
     */
    virtual IOReturn suspendStream(void);
    
    /*!
        @functiongroup Managing user clients
     */
    
    /*!
        @function newUserClient
     @abstract See the documentation for the IOService method newUserClient.
     */
    virtual IOReturn newUserClient( task_t owningTask, void * securityID,
                                    UInt32 type,  OSDictionary * properties,
                                    IOUserClient ** handler );
    

    /* Reserved slots */
    
    OSMetaClassDeclareReservedUnused(IOStream, 0);
    OSMetaClassDeclareReservedUnused(IOStream, 1);
    OSMetaClassDeclareReservedUnused(IOStream, 2);
    OSMetaClassDeclareReservedUnused(IOStream, 3);
    OSMetaClassDeclareReservedUnused(IOStream, 4);
    OSMetaClassDeclareReservedUnused(IOStream, 5);
    OSMetaClassDeclareReservedUnused(IOStream, 6);
    OSMetaClassDeclareReservedUnused(IOStream, 7);
    OSMetaClassDeclareReservedUnused(IOStream, 8);
    OSMetaClassDeclareReservedUnused(IOStream, 9);
    OSMetaClassDeclareReservedUnused(IOStream, 10);
    OSMetaClassDeclareReservedUnused(IOStream, 11);
    OSMetaClassDeclareReservedUnused(IOStream, 12);
    OSMetaClassDeclareReservedUnused(IOStream, 13);
    OSMetaClassDeclareReservedUnused(IOStream, 14);
    OSMetaClassDeclareReservedUnused(IOStream, 15);
    OSMetaClassDeclareReservedUnused(IOStream, 16);
    OSMetaClassDeclareReservedUnused(IOStream, 17);
    OSMetaClassDeclareReservedUnused(IOStream, 18);
    OSMetaClassDeclareReservedUnused(IOStream, 19);
    OSMetaClassDeclareReservedUnused(IOStream, 20);
    OSMetaClassDeclareReservedUnused(IOStream, 21);
    OSMetaClassDeclareReservedUnused(IOStream, 22);
    OSMetaClassDeclareReservedUnused(IOStream, 23);
    OSMetaClassDeclareReservedUnused(IOStream, 24);
    OSMetaClassDeclareReservedUnused(IOStream, 25);
    OSMetaClassDeclareReservedUnused(IOStream, 26);
    OSMetaClassDeclareReservedUnused(IOStream, 27);
    OSMetaClassDeclareReservedUnused(IOStream, 28);
    OSMetaClassDeclareReservedUnused(IOStream, 29);
    OSMetaClassDeclareReservedUnused(IOStream, 30);
    OSMetaClassDeclareReservedUnused(IOStream, 31);
    
};


/*!
    @class IOStreamBuffer
    A class representing a data buffer that is part of an IOStream.
 */

class IOStreamBuffer : public OSObject
{
    OSDeclareDefaultStructors(IOStreamBuffer);

protected:
    IOMemoryDescriptor *     _dataBuffer;        // The data buffer is expected to be filled by hardware.
    IOMemoryDescriptor *     _controlBuffer;     // The control buffer is expected to be defined by the hardware driver.
        
    IOStreamBufferID         _bufferID;          // Client handle for this buffer.
    
    OSArray *                _clientMemoryMaps;  // Maps for clients who are sharing these buffers.
    
    SInt32                   _clientReferenceCount;    // Count of client uses of this buffer.  May be negative.
    
public:
    /*!
        @function initWithMemoryDescriptors
     */        
    virtual bool initWithMemoryDescriptors(IOMemoryDescriptor *dataBuffer,
                                           IOMemoryDescriptor *controlBuffer,
                                           IOStreamBufferID bufferID = 0);
    
    /*!
        @function withMemoryDescriptors
     */    
    static IOStreamBuffer *withMemoryDescriptors(IOMemoryDescriptor *dataBuffer,
                                                 IOMemoryDescriptor *controlBuffer,
                                                 IOStreamBufferID bufferID = 0);
    
    virtual void free(void);
    
    /*!
        @function getBufferID
        @abstract Gets the buffer identifier for the IOStreamBuffer object.
        @discussion The buffer identifier is unique across all buffers in a stream.
     */
    virtual IOStreamBufferID getBufferID(void);
    
    /*!
        @function setBufferID
        @abstract Sets the buffer identifier for the IOStreamBuffer object.
     */
    
    virtual void setBufferID( IOStreamBufferID bufferID );
    
    /*!
        @function setDataBuffer
        @abstract Sets the data buffer for the IOStreamBuffer object.
     */
    virtual void setDataBuffer(IOMemoryDescriptor *dataBuffer);
    
    /*!
        @function setControlBuffer
        @abstract Sets the control buffer for the IOStreamBuffer object.
     */
    virtual void setControlBuffer(IOMemoryDescriptor *controlBuffer);
    
    /*!
        @function getDataBuffer
     @result A pointer to the IOMemoryDescriptor for the data buffer.
     */
    virtual IOMemoryDescriptor *getDataBuffer(void);
    
    /*!
        @function getControlBuffer
     @result A pointer to the IOMemoryDescriptor for the control buffer.
     */
    virtual IOMemoryDescriptor *getControlBuffer(void);
    
    /*!
        @function getClientReferenceCount
     @result The count of client references to this buffer.  It may be positive
     or negative, depending on whether the client is sending data into the kernel,
     or the kernel is sending data out to the client.
     */
    virtual SInt32 getClientReferenceCount( void );
    
    /*!
        @function sendClientReference
     @param offset The offset in the buffer of the data sent to the client.
     @param length The length of the data sent to the client.
     @result The new client reference count.
     @abstract
     */
    virtual SInt32 sendClientReference( IOByteCount offset = 0, IOByteCount length = 0 );
    
    /*!
        @function receiveClientReference
     @param offset The offset in the buffer of the data from the client.
     @param length The length of the data from the client.
     @abstract
     */
    virtual SInt32 receiveClientReference( IOByteCount offset = 0, IOByteCount length = 0 );
    
    /* Reserved slots */
    
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 0);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 1);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 2);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 3);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 4);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 5);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 6);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 7);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 8);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 9);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 10);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 11);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 12);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 13);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 14);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 15);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 16);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 17);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 18);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 19);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 20);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 21);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 22);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 23);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 24);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 25);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 26);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 27);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 28);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 29);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 30);
    OSMetaClassDeclareReservedUnused(IOStreamBuffer, 31);
    
};

#endif /* ! __IOKIT_IOSTREAM_H */

                                                                                                                                                                                                                                                                                      IOStreamFamily.h                                                                                    0100644 0001750 0001750 00000000400 12567451750 036312  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/stream                                                         /*
 *  Copyright 2006 Apple Computer, Inc. All rights reserved.
 *
 */

#ifndef __IOKIT_IOSTREAMFAMILY_H
#define __IOKIT_IOSTREAMFAMILY_H

#include <IOKit/stream/IOStream.h>
#include <IOKit/stream/IOStreamShared.h>


#endif /* !__IOKIT_IOSTREAMFAMILY_H */
                                                                                                                                                                                                                                                                IOStreamShared.h                                                                                    0100644 0001750 0001750 00000011167 12567451750 036313  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/stream                                                         /*
 *  IOStreamShared.h
 *  IOStreamFamily
 *
 *  Copyright 2006 Apple Computer, Inc. All rights reserved.
 *
 */

#if !defined(__IOKIT_IOSTREAMSHARED_H)
#define __IOKIT_IOSTREAMSHARED_H

#include <sys/cdefs.h>

#include <IOKit/IOTypes.h>

/*!
    @header IOStreamShared.h
    IOStream definitions shared between kernel and user space.
 */

__BEGIN_DECLS    
   
// Buffer numbers are guaranteed to go from 0 to bufferCount - 1.
/*!
    @typedef IOStreamBufferID
 */
typedef UInt32 IOStreamBufferID;
#define kIOStreamBufferIDInvalid (~0)

// This is the header for the shared-memory queue used to send buffer notifications
// from kernel to user space or vice versa.

// Queue entry in input or output queue

#ifdef __cplusplus

/*!
    @struct IOStreamBufferQueueEntry
    @field bufferID     The ID of the buffer passed in this queue entry.
    @field dataLength   The length of the valid data in the buffer.
    @field reserved     Reserved for future use.
*/
    
struct IOStreamBufferQueueEntry {
    IOStreamBufferID    bufferID;
    UInt32              dataOffset;
    UInt32              dataLength;
    UInt32              controlOffset;
    UInt32              controlLength;
    UInt32              reserved[3];
};


/*!
    @struct IOStreamBufferQueue
    @field entryCount   The number of queue entries in the queue.
    @field headIndex    The index of the next queue slot that will be filled in by the queue writer.
    @field tailIndex    The index of the next queue slot that can be read by the queue reader.
    @field reserved     Reserved for future use.
    @field queue        The array of queue entries.
 */

struct IOStreamBufferQueue {
    UInt32                      entryCount;
    volatile UInt32             headIndex;
    volatile UInt32             tailIndex;
    UInt32                      reserved;
    IOStreamBufferQueueEntry    queue[0];
};

#else

typedef struct __IOStreamBufferQueueEntry {
    IOStreamBufferID    bufferID;
    UInt32              dataOffset;
    UInt32              dataLength;
    UInt32              controlOffset;
    UInt32              controlLength;
    UInt32              reserved[3];
} IOStreamBufferQueueEntry;

typedef struct __IOStreamBufferQueue {
    UInt32                      entryCount;
    volatile UInt32             headIndex;
    volatile UInt32             tailIndex;
    UInt32                      reserved;
    IOStreamBufferQueueEntry    queue[0];
} IOStreamBufferQueue;

#endif

/*!
    @enum Memory mapping types
    @constant kIOStreamMemoryTypeOutputQueue
    @constant kIOStreamMemoryTypeInputQueue
    @constant kIOStreamMemoryTypeBufferData
    @constant kIOStreamMemoryTypeBufferControl
    @constant kIOStreamBufferIDMask
    @constant kIOStreamMemoryTypeMask
    @abstract Memory types used with IOConnectMapMemory().
    @discussion
 */
enum {
    kIOStreamMemoryTypeOutputQueue   = 0x10000000,
    kIOStreamMemoryTypeInputQueue    = 0x20000000,
    kIOStreamMemoryTypeBufferData    = 0x30000000,
    kIOStreamMemoryTypeBufferControl = 0x40000000,
    kIOStreamBufferIDMask            = 0x0FFFFFFF,
    kIOStreamMemoryTypeMask          = 0xF0000000
};

/*!
    @enum Mach port types
    @constant kIOStreamPortTypeOutput
    @constant kIOStreamPortTypeInput
    @abstract Port types used with IOConnectSetNotificationPort().
    @discussion
 */
enum {
    kIOStreamPortTypeOutput,
    kIOStreamPortTypeInput
};

/*!
    @enum IOStream open options
    @discussion
 */
 
enum {
    kIOStreamOptionOpenExclusive = 0x00010000,
    kIOStreamOptionOpenShared    = 0x00020000
};

/*!
    @enum User client methods
    @constant kIOStreamMethodOpen
    @constant kIOStreamMethodClose
    @constant kIOStreamMethodStart
    @constant kIOStreamMethodStop
    @constant kIOStreamMethodSuspend
    @constant kIOStreamMethodGetMode
    @constant kIOStreamMethodSetMode
 
    @abstract Client method numbers used with IOConnectMethod...() functions.
    @discussion
 */
enum {
    kIOStreamMethodOpen,
    kIOStreamMethodClose,
    kIOStreamMethodStart,
    kIOStreamMethodStop,
    kIOStreamMethodSuspend,
    kIOStreamMethodGetMode,
    kIOStreamMethodSetMode,
    kIOStreamMethodGetBufferCount
};

/*!
    @enum User client traps
    @constant kIOStreamEnqueueInputTrap
    @constant kIOStreamEnqueueInputSyncTrap
    @abstract Client trap numbers used with IOConnectTrap..() functions.
    @discussion
 */
enum {
    kIOStreamEnqueueInputTrap,
    kIOStreamEnqueueInputSyncTrap
};

typedef enum {
    kIOStreamModeInput,         // From user to kernel space
    kIOStreamModeOutput,        // From kernel to user space
    kIOStreamModeInputOutput    // bidirectional
} IOStreamMode;


__END_DECLS

#endif /* ! __IOKIT_IOSTREAMSHARED_H */

                                                                                                                                                                                                                                                                                                                                                                                                         IOStreamUserClient.h                                                                                0100644 0001750 0001750 00000004706 12567451750 037163  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/stream                                                         /*
 *  IOStreamUserClient.h
 *  IOStreamFamily
 *
 *  Copyright 2006 Apple Computer, Inc. All rights reserved.
 *
 */

#if !defined( __IOKIT_IOSTREAMUSERCLIENT_H )
#define __IOKIT_IOSTREAMUSERCLIENT_H


#include <IOKit/IOUserClient.h>

#include <IOKit/stream/IOStreamShared.h>
#include <IOKit/stream/IOStream.h>

class IOStreamUserClient : public IOUserClient
{
    OSDeclareDefaultStructors( IOStreamUserClient )
    
protected:
    IOStream * _owner;
    task_t     _task;
    
public:
    virtual bool initWithTask(
                                  task_t owningTask, void * securityToken, UInt32 type,
                                  OSDictionary * properties);
    virtual bool initWithTask(
                              task_t owningTask, void * securityToken, UInt32 type);
    
    virtual IOReturn clientClose( void );
    virtual IOReturn clientDied( void );

    virtual IOService * getService( void );
    
    virtual IOReturn registerNotificationPort(
                                              mach_port_t port, UInt32 type, UInt32 refCon );
    
    virtual IOReturn connectClient( IOUserClient * client );
    
    virtual IOExternalMethod * getTargetAndMethodForIndex(
                                                          IOService ** targetP, UInt32 index );
    
    virtual IOExternalTrap *
      getTargetAndTrapForIndex( IOService **targetP, UInt32 index );

    virtual IOReturn clientMemoryForType( UInt32 type,
                                          IOOptionBits * options,
                                          IOMemoryDescriptor ** memory );
    
    virtual bool start( IOService * provider );
    
    
protected:
    virtual IOReturn openMethod(  char * dataIn, char * dataOut,
                                  IOByteCount inputSize, IOByteCount * outputSize );
    virtual IOReturn closeMethod( void );
    virtual IOReturn startMethod( void );
    virtual IOReturn stopMethod( void );
    virtual IOReturn suspendMethod( void );
    virtual IOReturn getModeMethod(  char * dataOut,
                                     IOByteCount * outputSize );
    virtual IOReturn setModeMethod(  char * dataIn, 
                                     IOByteCount inputSize );
    virtual IOReturn getBufferCountMethod(  char * dataOut,
                                            IOByteCount * outputSize );
    
    virtual IOReturn inputTrap( UInt32 token );
    virtual IOReturn inputSyncTrap( UInt32 token );

};

#endif /* ! __IOKIT_IOSTREAMUSERCLIENT_H */

                                                          system.h                                                                                            0100644 0001750 0001750 00000004133 12567450747 033532  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                /*
 * Copyright (c) 1998-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef __IOKIT_SYSTEM_H
#define __IOKIT_SYSTEM_H

#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS
#endif

#include <sys/cdefs.h>

__BEGIN_DECLS

#include <mach/mach_types.h>
#include <mach/mach_interface.h>
#include <mach/memory_object_types.h>

#include <stdarg.h>
#include <stdint.h>
#include <string.h>

#include <IOKit/assert.h>  /* Must be before other includes of kern/assert.h */

#include <kern/kern_types.h>
#include <kern/thread.h>
#include <kern/debug.h>
#include <kern/task.h>
#include <kern/sched_prim.h>
#include <kern/locks.h>
#include <kern/queue.h>
#include <kern/ipc_mig.h>
#include <libkern/libkern.h>


#ifndef	_MISC_PROTOS_H_
extern void	_doprnt( const char *format, va_list *arg,
			void (*lputc)(char), int radix );
#endif

__END_DECLS

#endif /* !__IOKIT_SYSTEM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                     system_management/                                                                                  0040755 0001750 0001750 00000000000 12612224742 035540  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOWatchDogTimer.h                                                                                   0100644 0001750 0001750 00000004130 12567450740 040645  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/system_management                                              /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _IOWATCHDOGTIMER_H
#define _IOWATCHDOGTIMER_H

#include <IOKit/IOService.h>

class IOWatchDogTimer : public IOService
{
  OSDeclareAbstractStructors(IOWatchDogTimer);
  
protected:
  IONotifier *notifier;
  struct ExpansionData { };
  ExpansionData *reserved;
  
public:
  virtual bool start(IOService *provider) APPLE_KEXT_OVERRIDE;
  virtual void stop(IOService *provider) APPLE_KEXT_OVERRIDE;
  virtual IOReturn setProperties(OSObject *properties) APPLE_KEXT_OVERRIDE;
  virtual void setWatchDogTimer(UInt32 timeOut) = 0;
  
  OSMetaClassDeclareReservedUnused(IOWatchDogTimer,  0);
  OSMetaClassDeclareReservedUnused(IOWatchDogTimer,  1);
  OSMetaClassDeclareReservedUnused(IOWatchDogTimer,  2);
  OSMetaClassDeclareReservedUnused(IOWatchDogTimer,  3);
};

#endif /* !_IOWATCHDOGTIMER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                        usb/                                                                                                0040755 0001750 0001750 00000000000 12612224742 032611  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOUFIStorageServices.h                                                                              0100644 0001750 0001750 00000010670 12567471024 036675  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 

#ifndef _IOKIT_UFI_STORAGE_SERVICES_H_
#define _IOKIT_UFI_STORAGE_SERVICES_H_

#if defined(KERNEL) && defined(__cplusplus)

#include <IOKit/IOTypes.h>
#include <IOKit/storage/IOBlockStorageDevice.h>
#include <IOKit/usb/IOUSBMassStorageUFISubclass.h>


class IOUFIStorageServices : public IOBlockStorageDevice
{
	
	OSDeclareDefaultStructors ( IOUFIStorageServices )

private:
	bool							fMediaChanged;
	bool							fMediaPresent;

protected:
	
    IOUSBMassStorageUFIDevice *		fProvider;

	UInt64							fMaxReadBlocks;
	UInt64							fMaxWriteBlocks;
	
	virtual bool	attach ( IOService * provider );
	virtual void	detach ( IOService * provider );
	
    // Reserve space for future expansion.
    struct IOUFIStorageServicesExpansionData { };
    IOUFIStorageServicesExpansionData *fIOUFIStorageServicesReserved;
	
public:

	virtual IOReturn 	message ( UInt32 type, IOService * provider, void * argument );

	static void 		AsyncReadWriteComplete ( void * 			clientData,
                                				 IOReturn			status,
                                				 UInt64 			actualByteCount );

    // Deprecated
    virtual IOReturn    doAsyncReadWrite (	IOMemoryDescriptor *	buffer,
											UInt32					block,
											UInt32					nblks,
											IOStorageCompletion		completion );
                                            
	virtual IOReturn	doAsyncReadWrite (  IOMemoryDescriptor *    buffer,
                                            UInt64                  block, 
                                            UInt64                  nblks,
                                            IOStorageAttributes *   attributes,
                                            IOStorageCompletion *   completion );

	virtual IOReturn	doSyncReadWrite ( 	IOMemoryDescriptor *	buffer,
											UInt32					block,
											UInt32					nblks );

    virtual IOReturn	doEjectMedia ( void );

    virtual IOReturn	doFormatMedia ( UInt64 byteCapacity );

    virtual UInt32		doGetFormatCapacities ( UInt64 *	capacities,
    											UInt32		capacitiesMaxCount ) const;

    virtual IOReturn	doSynchronizeCache ( void );
        
    virtual char *		getVendorString ( void );
    
    virtual char *		getProductString ( void );
    
    virtual char *		getRevisionString ( void );
    
    virtual char *		getAdditionalDeviceInfoString ( void );
    
    virtual IOReturn	reportBlockSize ( UInt64 * blockSize );
    
    virtual IOReturn	reportEjectability ( bool * isEjectable );
    
    virtual IOReturn	reportMediaState ( bool * mediaPresent, bool * changed );
    
    virtual IOReturn	reportMaxValidBlock ( UInt64 * maxBlock );
    
    virtual IOReturn	reportRemovability ( bool * isRemovable );
    
    virtual IOReturn	reportWriteProtection ( bool * isWriteProtected );

    virtual IOReturn	getWriteCacheState ( bool * enabled );
	
	virtual IOReturn	setWriteCacheState ( bool enabled );
    
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 1 );
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 2 );
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 3 );
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 4 );
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 5 );
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 6 );
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 7 );
    OSMetaClassDeclareReservedUnused( IOUFIStorageServices, 8 );

};

#endif	/* defined(KERNEL) && defined(__cplusplus) */

#endif	/* _IOKIT_UFI_STORAGE_SERVICES_H_ */
                                                                        IOUSBHostDevice.h                                                                                   0100644 0001750 0001750 00000136367 12567452451 035647  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright (c) 1998-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.2 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef IOUSBHostFamily_IOUSBHostDevice_h
#define IOUSBHostFamily_IOUSBHostDevice_h

#include <IOKit/usb/StandardUSB.h>
#include <IOKit/usb/IOUSBHostFamily.h>
#include <IOKit/usb/IOUSBHostPipe.h>
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/IOWorkLoop.h>
#include <IOKit/IOCommandGate.h>
#include <IOKit/pwr_mgt/RootDomain.h>
#include <kern/thread_call.h>

// The following are definitions for errata properties needed for different devices.  This
// should be but in the dictionary of the IOUSBHostDevice in question.  This can be achieved
// by using the AppleUSBHostMergeProperties class and having an IOProviderMergeProperties dictionary
// with the required properties.

// This property allows a device to specify a configuration value of 0 in its configuration
// descriptor.  This does not follow the spec, but we will allow it in order to get the device
// to work.  The property should be a Boolean
//
#define kAllowConfigValueOfZero         "kAllowZeroConfigValue"
#define kAllowNumConfigsOfZero          "kAllowZeroNumConfigs"

#define kUSBHostDeviceForceSuspend "kUSBHostDeviceForceSuspend"

class AppleUSBHostController;
class IOUSBHostInterface;
class AppleUSBHostDeviceIdler;
class AppleUSBHostRequestCompleter;
class AppleUSBHostSynchronousRequestCompleter;
class AppleUSBHostPort;
class AppleUSBHostDescriptorCache;
class AppleUSBHostResources;

/*!
    @class IOUSBHostDevice
    @abstract The IOService object representing a device on the USB bus.
    @discussion This class provides functionality to configure a device and to create
        IOUSBHostInterface objects to represent the interfaces of the device.
 */

/*!
 * @class IOUSBHostDevice
 *
 * @brief The IOService object representing a device on the USB bus.
 *
 * @discussion  This class provides functionality to configure a device and to create IOUSBHostInterface objects to 
 * represent the interfaces of the device.
 */
class IOUSBHostDevice : public IOService
{
    friend class AppleUSBHostController;
    friend class IOUSBHostInterface;
    friend class IOUSBHostIOSource;
    friend class IOUSBHostPipe;
    friend class IOUSBHostStream;
    friend class AppleUSBIORequest;
    friend class AppleUSBHostDeviceIdler;

    OSDeclareDefaultStructors(IOUSBHostDevice)

public:
    /*!
     * @brief Powerstates supported by an IOUSBHostDevice
     *
     * @constant kPowerStateOff The device has been powered off and is likely in the process of terminating
     * @constant kPowerStateSuspended The device is suspended.  All I/O has been paused and the bus will be
     * suspended once its AppleUSBHostPort power parent enters the suspend state.
     * @constant kPowerStateOn The device is powered on and I/O is possible.
     * @constant kPowerStateCount Number of possible power states 
     */
    enum tPowerState
    {
        kPowerStateOff = 0,
        kPowerStateSuspended,
        kPowerStateOn,
        kPowerStateCount
    };

    /*!
     * @brief Factory method for creating an IOUSBHostDevice object
     *
     * @param controller Controller to which the USB device is attached
     *
     * @param speed Speed at which the device enumerated
     *
     * @param address Address that was assigned during enumeration
     *
     * @return Pointer to an IOUSBHostDevice object is successful
     */
    static IOUSBHostDevice* withController(AppleUSBHostController* controller, UInt8 speed, tUSBHostDeviceAddress address);

protected:
    virtual bool initWithController(AppleUSBHostController* controller, UInt8 speed, tUSBHostDeviceAddress address);
    
    // Pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 0);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 1);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 2);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 3);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 4);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 5);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 6);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 7);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 8);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 9);
    
#pragma mark IOService overrides
public:
    virtual bool attach(IOService* provider);
    virtual bool start(IOService* provider);
    virtual bool terminate(IOOptionBits options = 0);
    virtual void stop(IOService* provider);
    virtual void free(void);

    virtual bool compareProperty(OSDictionary* matching, const char* key);
    virtual bool compareProperty(OSDictionary* matching, const OSString* key);
    virtual bool matchPropertyTable(OSDictionary* table, SInt32* score);

    virtual bool open(IOService* forClient, IOOptionBits options = 0, void* arg = 0);
    virtual bool handleOpen(IOService* forClient, IOOptionBits options, void* arg);
    virtual bool handleIsOpen(const IOService* forClient) const;
    virtual void close(IOService* forClient, IOOptionBits options = 0);
    virtual void handleClose(IOService* forClient, IOOptionBits options);
    
    virtual IOReturn message(UInt32 type, IOService* provider,  void* argument = 0);

    virtual const char* stringFromReturn(IOReturn rtn);

protected:
    virtual IOReturn terminateGated(IOOptionBits options = 0);
    
    virtual IOReturn openGated(IOService* forClient, IOOptionBits options, void* arg);
    virtual IOReturn closeGated(IOService* forClient, IOOptionBits options);

    // Protected pad slots for IOService overrides
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 10);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 11);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 12);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 13);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 14);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 15);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 16);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 17);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 18);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 19);
    
protected:
    int32_t                                  _terminationPending;
    AppleUSBHostResources*                   _resources;
    AppleUSBHostController*                  _controller;
    AppleUSBHostPort*                        _port;
    OSSet*                                   _clients;
    IOWorkLoop*                              _workLoop;
    IOCommandGate*                           _commandGate;
    
#pragma mark Power management
public:
    /*!
     * @methodgroup Power management
     *
     * @discussion The following mthods should be considered private and should not be called by client drivers.
     * In general the below methods are overriden IOService power methods used internally to implement idling
     * and maintain proper device state.
     */
    virtual void          registerPowerService();
    virtual IOReturn      addPowerChild(IOService* theChild);
    virtual IOReturn      removePowerChild(IOPowerConnection* theChild);
    virtual IOReturn      powerStateWillChangeTo(IOPMPowerFlags capabilities, unsigned long stateNumber, IOService* whatDevice);
    virtual IOReturn      setPowerState(unsigned long stateNumber, IOService* whatDevice);
    virtual IOReturn      powerStateDidChangeTo(IOPMPowerFlags capabilities, unsigned long stateNumber, IOService* whatDevice);
    virtual unsigned long initialPowerStateForDomainState(IOPMPowerFlags domainState);
    virtual void          PMstop(void);
    virtual IOReturn      forcePower(tPowerState powerState, bool clamp, uint32_t timeoutMs = 0);
    
    /*!
     * @brief Allocate bus current in addition to the bMaxPower value specified by the configuration descriptor
     *
     * @discussion Some hosts are able to source more than the standard-defined bus current to attached devices, or
     * may use less current than defined in the bMaxPower field of the configuration descriptor.
     *
     * Devices can use this interface to request more or less bus current.  The parameters passed in are abolute values
     * of current required for operation in kPowerStateOn and kPowerStateSuspended IOUSBHostDevice power levels, and
     * override the bMaxPower field in the configuration descriptor.  For example, if bMaxPower indicates the device
     * requires 500mA to operate, then a request for 1000mA will double the allocated power for the device.
     *
     * A setConfiguration(0) call to unconfigure the device will reset these overrides.
     *
     * The parameters are passed by reference, and may be modified by the software stack before being returned.
     * If more bus current is being requested than is available, the value may be reduced to stay within system limits.
     *
     * @param wakeUnits The number of extra mA requested when the device is in kPowerStateOn
     *
     * @param sleepUnits The number of extra mA requested when the device is in kPowerStateSuspended
     *
     * @return IOReturn kIOReturnSuccess if the device's allocation amounts were updated
     */
    virtual IOReturn allocateDownstreamBusCurrent(uint32_t& wakeUnits, uint32_t& sleepUnits);
    
    enum tIdleAssertion
    {
        kIdleAssertionInhibit = 0,
        kIdleAssertionPermit
    };
    virtual IOReturn idleAssertion(IOService* forService, tIdleAssertion assertion);

    // Public pad slots for power management
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 20);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 21);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 22);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 23);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 24);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 25);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 26);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 27);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 28);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 29);

protected:
    static IOPMPowerState  _sPowerStates[kPowerStateCount];
    static const OSSymbol* _sPowerStateSymbols[kPowerStateCount];
    
    virtual void     powerChangeDone(unsigned long stateNumber);
    virtual IOReturn powerStateWillChangeToGated(IOPMPowerFlags capabilities, unsigned long stateNumber, IOService* whatDevice);
    virtual IOReturn setPowerStateGated(unsigned long stateNumber, IOService* whatDevice);
    virtual IOReturn powerStateDidChangeToGated(IOPMPowerFlags capabilities, unsigned long stateNumber, IOService* whatDevice);
    virtual IOReturn forcePowerGated(tPowerState powerState, bool clamp, uint32_t timeoutMs);
    virtual void     addPowerChildThreadCall(thread_call_t threadCall);
    virtual IOReturn addPowerChildGated(void);

    virtual void     pmStopThreadCall(thread_call_t threadCall);

    virtual IOReturn allocateDownstreamBusCurrentGated(uint32_t& wakeUnits, uint32_t& sleepUnits);

    virtual IOReturn updateIdlePolicy(bool asynchronous = false);
    virtual void updateIdlePolicyAsync(thread_call_t threadCall);
    virtual IOReturn updateIdlePolicyGated();

    // Protected pad slots for power management
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 30);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 31);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 32);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 33);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 34);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 35);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 36);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 37);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 38);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 39);
    
protected:
    bool                    _allowUpdateIdlePolicy;
    bool                    _forcePowerInProgress;
    IOLock*                 _powerChildrenLock;
    OSSet*                  _powerChildren;
    OSSet*                  _activePowerChildren;
    IOPMDriverAssertionID   _externalDevicePowerAssertion;
    tPowerState             _currentPowerState;
    bool                    _powerOffPending;

#pragma mark Descriptors
public:
    /*!
     * @brief Store the provided descriptor in the set of cached descriptors.
     *
     * @discussion This method will store the provided descriptor in the set of caced descriptors.  Internally,
     * the cache is an OSDictionary containing OSSets indexted by the bDescriptorType field.  There can only be
     * one cached descriptor in the set with identical <code>bDescriptorType</code>, <code>index</code>, and 
     * <code>languageID</code>.  The descriptor is copied into the cache.
     *
     * @param descriptor Pointer to the descriptor to cache
     *
     * @param length Length of the descriptor, if 0 the length will be extracted from the descriptor itself.
     *
     * @param index Descriptor index value.  Low byte of <code>wValue</code> of the SET_DESCRIPTOR control request described
     * in section 9.4.8 of the USB 2.0 specification.
     *
     * @param languageID Descriptor language ID.  <code>wIndex</code> of the SET_DESCRIPTOR control request described in 
     * section 9.4.8 of the USB 2.0 specification.
     *
     * @return IOReturn result code
     */
    virtual IOReturn cacheDescriptor(const StandardUSB::Descriptor* descriptor, uint16_t length = 0, uint8_t index = 0, uint16_t languageID = 0);
    
    /*!
     * @brief Search the cache for the descriptor
     *
     * @discussion This method will search the descriptor cache for the descriptor that matches the input arguments.  If
     * the descriptor is not in the cache, a device request will be issued to retrieve the descriptor from the USB device.
     * If the device request is successful, the resulting descriptor will be added to the cache.
     *
     * @param type <bDescriptorType> of the descriptor to find.
     *
     * @param length Reference to a uint16_t which will be updated with the length of the descriptor
     *
     * @param index Descriptor index value.  Low byte of <code>wValue</code> of the GET_DESCRIPTOR control request described
     * in section 9.4.3 of the USB 2.0 specification.
     *
     * @param languageID Descriptor language ID.  <code>wIndex</code> of the GET_DESCRIPTOR control request described in
     * section 9.4.3 of the USB 2.0 specification.
     *
     * @param requestType tDeviceRequestType to be used for the GET_DESCRIPTOR control request
     *
     * @param requestRecipient tDeviceRequestRecipient to be used for the GET_DESCRIPTOR control request
     *
     * @return Pointer to the descriptor if found.
     */
    virtual const StandardUSB::Descriptor* getDescriptor(uint8_t type,
                                                         uint16_t& length,
                                                         uint8_t index = 0,
                                                         uint16_t languageID = 0,
                                                         tDeviceRequestType requestType = kRequestTypeStandard,
                                                         tDeviceRequestRecipient requestRecipient = kRequestRecipientDevice);
    
    // Retrieve and cache the entire length of standard descriptor types
    // TODO: We are handing out pointers to cached descriptors, which could theoretically be invalidated
    // TODO: We might want to make it so cached descriptors can't be replaced or removed by anyone but us
    /*!
     * @brief Return the device descriptor
     *
     * @discussion This method is simply a convenience method to retrieve the device descriptor.  Internally this method
     * simply calls @link getDescriptor @/link.
     *
     * @return Pointer to the device descriptor if found.
     */
    virtual const StandardUSB::DeviceDescriptor* getDeviceDescriptor();

    /*!
     * @brief Return the configuration descriptor with the specified index
     *
     * @discussion This method is simply a convenience method to retrieve the configuration descriptor.  Internally this method
     * simply calls @link getDescriptor @/link.
     *
     * @param index  Descriptor index value.  Low byte of <code>wValue</code> of the GET_DESCRIPTOR control request described
     * in section 9.4.3 of the USB 2.0 specification.
     *
     * @return Pointer to the configuration descriptor if found
     */
    virtual const StandardUSB::ConfigurationDescriptor* getConfigurationDescriptor(uint8_t index);

    /*!
     * @brief Return the configuration descriptor with the specified <code>bConfigurationValue</code>
     *
     * @discussion This method will iterate through all configuration descriptors by index looking for the one whose
     * <code>bConfigurationValue</code> matches the input value.
     *
     * @param bConfigurationValue Value to match
     *
     * @return Pointer to the configuration descriptor if found
     */
    virtual const StandardUSB::ConfigurationDescriptor* getConfigurationDescriptorWithValue(uint8_t bConfigurationValue);
    
    /*!
     * @brief Return the currently selected configuration descriptor
     *
     * @discussion This method will return the configuration descriptor currently selected by a successful setConfiguration call
     *
     * @return Pointer to the configuration descriptor if found, or NULL if the device is not configured
     */
    virtual const StandardUSB::ConfigurationDescriptor* getConfigurationDescriptor();

    /*!
     * @brief Return the capability descriptors of the device
     *
     * @discussion This method will attempt to return the Binary Device Object Store descriptors described in section
     * 9.6.2 of the USB 3.1 specification.
     *
     * @return Pointer to the BOS descriptor if found
     */
    virtual const StandardUSB::BOSDescriptor* getCapabilityDescriptors();

    /*!
     * @brief Return a string descriptor from the device
     *
     * @discussion This method is simply a convenience method to retieve the desired string descriptor.  Internally this method
     * simply calls @link getDescriptor @/link.
     *
     * @param index  Descriptor index value.  Low byte of <code>wValue</code> of the GET_DESCRIPTOR control request described
     * in section 9.4.3 of the USB 2.0 specification.
     *
     * @param languageID  Descriptor language ID.  <code>wIndex</code> of the GET_DESCRIPTOR control request described in 
     * section 9.4.3 of the USB 2.0 specification.
     *
     * @return Pointer to the descriptor if found
     */
    virtual const StandardUSB::StringDescriptor* getStringDescriptor(uint8_t index, uint16_t languageID = StandardUSB::kLanguageIDEnglishUS);

    // Public pad slots for descriptors
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 40);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 41);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 42);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 43);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 44);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 45);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 46);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 47);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 48);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 49);

protected:
    virtual IOReturn cacheDescriptorGated(const StandardUSB::Descriptor* descriptor, uint16_t length, uint8_t index, uint16_t languageID);
    
    struct tDescriptorSelectors
    {
        uint8_t                 index;
        uint16_t                languageID;
        tDeviceRequestType      requestType;
        tDeviceRequestRecipient requestRecipient;
    };
    virtual IOReturn getDescriptorGated(uint8_t type, uint16_t& length, tDescriptorSelectors& selectors, const StandardUSB::Descriptor*& result);
    
    // Protected pad slots for descriptors
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 50);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 51);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 52);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 53);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 54);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 55);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 56);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 57);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 58);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 59);

protected:
    bool                         _getDescriptorInProgress;
    AppleUSBHostDescriptorCache* _descriptorCache;
    
#pragma mark Configuration, interface, and pipe management
public:
    /*!
     * @brief Select a new configuration for the device
     *
     * @discussion This method will select a new configuration for a device.  If the device was previously configured all
     * child interfaces will be terminated prior to setting the new configuration.  This method will send the SET_CONFIGURATION
     * request to the device as described by section 9.4.7 of the USB 2.0 specification.
     *
     * @param bConfigurationValue Configuration to select
     *
     * @param matchInterfaces If true, any interfaces within the new configuration will be registered for matching.
     *
     * @return IOReturn result code
     */
    virtual IOReturn setConfiguration(uint8_t bConfigurationValue, bool matchInterfaces = true);
    
    /*!
     * @brief Factory method to create IOUSBHostPipe objects
     *
     * @param descriptor Endpoint descriptor for this pipe (used to decide direction, bandwidth requirements, etc).
     *
     * @param companionDescriptor Companion descriptor for the endpint
     *
     * @param interface Interface to which the endpoint belongs
     *
     * @return Pointer to the newly created IOUSBHostPipe object
     */
    virtual IOUSBHostPipe* createPipe(const StandardUSB::EndpointDescriptor* descriptor, const StandardUSB::SuperSpeedEndpointCompanionDescriptor* companionDescriptor, IOUSBHostInterface* interface);
    
    /*!
     * @brief Issue an aynchronous setup request on the default control pipe
     *
     * @discussion This method will issue an asynchronous control request on the defaul pipe.
     *
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to the memory to be used for the I/O.
     *
     * @param completion Pointer to a valid, non NULL, IOUSBHostCompletion object.  This will be copied and can therefore be stack-allocated.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(IOService* forClient, StandardUSB::DeviceRequest& request, void* dataBuffer, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);

    /*!
     * @brief Issue an aynchronous setup request on the default control pipe
     *
     * @discussion This method will issue an asynchronous control request on the defaul pipe.
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to an IOMemoryDescriptor for the memory to be used for the I/O.
     *
     * @param completion Pointer to a valid, non NULL, IOUSBHostCompletion object.  This will be copied and can therefore be stack-allocated.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(IOService* forClient, StandardUSB::DeviceRequest& request, IOMemoryDescriptor* dataBuffer, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);
    
    /*!
     * @brief Issue a synchronous setup request on the default control pipe.
     *
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to the memory to be used for the I/O.
     *
     * @param bytesTransferred Reference which will be updated with the bytes transferred during the request.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(IOService* forClient, StandardUSB::DeviceRequest& request, void* dataBuffer, uint32_t& bytesTransferred, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);

    /*!
     * @brief Issue a synchronous setup request on the default control pipe.
     *
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to an IOMemoryDescriptor for the memory to be used for the I/O.
     *
     * @param bytesTransferred Reference which will be updated with the bytes transferred during the request.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(IOService* forClient, StandardUSB::DeviceRequest& request, IOMemoryDescriptor* dataBuffer, uint32_t& bytesTransferred, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);

    /*!
     * @brief Abort device requests made via the @link deviceRequest @\link methods by <code>forClient</code>
     *
     * @discussion This method will abort any requests made via the @link deviceRequest @\link methods.  It will not abort
     * requests made through other interface objects.
     *
     * @param forClient Client which issued the requests
     *
     * @param options IOUSBHostIOSource::tAbortOptions
     *
     * @param withError IOReturn error value to return with the requests.
     *
     * @return IOReturn result code
     */
    virtual IOReturn abortDeviceRequests(IOService* forClient = NULL, IOOptionBits options = IOUSBHostIOSource::kAbortAsynchronous, IOReturn withError = kIOReturnAborted);
    
    // Public pad slots for configuration, interface, and pipe management
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 60);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 61);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 62);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 63);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 64);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 65);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 66);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 67);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 68);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 69);

protected:
    virtual IOReturn setConfigurationGated(uint8_t bConfigurationValue, bool matchInterfaces);
    
    virtual IOReturn createPipeGated(const StandardUSB::EndpointDescriptor* descriptor, const StandardUSB::SuperSpeedEndpointCompanionDescriptor* companionDescriptor, IOUSBHostInterface* interface, IOUSBHostPipe*& result);

    virtual IOReturn deviceRequest(IOService* forClient, StandardUSB::DeviceRequest& request,
                                   void* rawBuffer, IOMemoryDescriptor* descriptorBuffer,
                                   uint32_t& bytesTransferred, IOUSBHostCompletion* completion,
                                   uint32_t completionTimeoutMs);

    virtual IOReturn internalDeviceRequest(IOService* forClient, StandardUSB::DeviceRequest& request,
                                           void* rawBuffer, IOMemoryDescriptor* descriptorBuffer,
                                           uint32_t& bytesTransferred, IOUSBHostCompletion* completion,
                                           uint32_t completionTimeoutMs);
    
    virtual IOReturn internalDeviceRequestGated(IOUSBHostPipe::tInternalControlRequestParameters& parameters);

    virtual IOReturn abortDeviceRequestsGated(IOService* forClient, IOOptionBits options, IOReturn withError);
    
    // Protected pad slots for configuration, interface, and pipe management
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 70);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 71);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 72);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 73);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 74);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 75);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 76);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 77);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 78);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 79);

#pragma mark Miscellaneous
public:
    /*!
     * @brief Return the device's address
     *
     * @return Current address of the device
     */
    virtual tUSBHostDeviceAddress getAddress() const;
    
    /*!
     * @brief Return the device's speed
     *
     * @return The enumerated speed of the device:
     * @constant kUSBHostConnectionSpeedLow
     * @constant kUSBHostConnectionSpeedFull
     * @constant kUSBHostConnectionSpeedHigh
     * @constant kUSBHostConnectionSpeedSuper
     */
    virtual uint8_t getSpeed() const;
    
    /*!
     * @brief Return the current frame number of the USB bus
     *
     * @description This method will return the current frame number of the USB bus.  This is most useful for
     * scheduling future isochronous requests.
     *
     * @param theTime If not NULL, this will be updated with the current system time
     *
     * @return The current frame number
     */
    virtual uint64_t getFrameNumber(AbsoluteTime* theTime = NULL);
    
    /*!
     * @brief Reset and re-emerate the device
     *
     * @discussion This function will reset and re-enumerate the USB device.  The current IOUSBHostDevice object and all
     * of its children will be terminated.  A new IOUSBHostDevice object will be created and registered if the reset
     * is successful and the previous object has finished terminating.  This function may not be called from the port
     * workloop thread.
     *
     * @return IOReturn result code
     */
    virtual IOReturn reset();
    
    /*!
     * @brief Return the current port status
     *
     * @discussion This method will return the current port status as a logical OR of bits described by @link tUSBHostPortStatus @\link
     *
     * @return port status
     */
    virtual uint32_t getPortStatus();
    
    /*!
     * @brief Allocate a buffer to be used for I/O
     *
     * @discussion The underlying host controller hardware may have alignment and fragmentation restrictions.  This
     * method will return a buffer which is guaranteed to meet the restrictions the host controller may have.
     *
     * @param options kIODirectionOut, kIODirectionIn to set the direction of the I/O transfer.
     *
     * @param capacity Size of the buffer to allocate
     *
     * @return Pointer to the newly allocated memory descriptor or NULL
     */
    virtual IOBufferMemoryDescriptor* createIOBuffer(IOOptionBits options, mach_vm_size_t capacity);

    // Public pad slots for miscellaneous
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 80);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 81);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 82);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 83);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 84);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 85);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 86);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 87);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 88);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 89);

protected:
    // Protected pad slots for miscellaneous
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 90);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 91);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 92);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 93);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 94);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 95);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 96);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 97);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 98);
    OSMetaClassDeclareReservedUnused(IOUSBHostDevice, 99);

public:
    // Removed legacy methods
    
    // virtual UInt16 GetbcdUSB() __attribute__((deprecated));
    // Replacement: USBToHost16(getDeviceDescriptor()->bcdUSB);
    
    // virtual UInt8  GetDeviceClass() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor()->bDeviceClass;
    
    // virtual UInt8  GetDeviceSubClass() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor()->bDeviceSubClass
    
    // virtual UInt8  GetProtocol() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor()->bDeviceProtocol
    
    // virtual UInt8  GetMaxPacketSize() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor->bMaxPacketSize0
    
    // virtual UInt16 GetVendorID() __attribute__((deprecated));
    // Replacement: USBToHost16(getDeviceDescriptor()->idVendor)
    
    // virtual UInt16 GetProductID() __attribute__((deprecated));
    // Replacement: USBToHost16(getDeviceDescriptor()->idProduct)
    
    // virtual UInt16 GetDeviceRelease() __attribute__((deprecated));
    // Replacement: USBToHost16(getDeviceDescriptor()->bcdDevice)

    // virtual UInt8  GetNumConfigurations() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor()->bNumConfigurations
    
    // virtual UInt8  GetManufacturerStringIndex() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor()->iManufacturer
    
    // virtual UInt8  GetProductStringIndex() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor()->iProduct

    // virtual UInt8  GetSerialNumberStringIndex() __attribute__((deprecated));
    // Replacement: getDeviceDescriptor()->iSerialNumber
    
    // virtual IOReturn FindNextInterfaceDescriptor(const IOUSBConfigurationDescriptor* configDescIn,
    //                                              const IOUSBInterfaceDescriptor*     intfDesc,
    //                                              const IOUSBFindInterfaceRequest*    request,
    //                                              IOUSBInterfaceDescriptor**          descOut) __attribute__((deprecated));
    // Replacement:
    // ConfigurationDescriptor* confDesc = getConfigurationDescriptor(1);
    // InterfaceDescriptor* intDesc = NULL;
    // while((intDesc = getNextInterfaceDescriptor(confDesc, intDesc)) != NULL)
    // {
    //     if(intDesc->bInterfaceClass == kMyClass)
    //     {
    //         break;
    //     }
    // }
    
    // virtual const IOUSBConfigurationDescriptor* GetCachedConfigurationDescriptor(UInt8 configIndex) __attribute__((deprecated));
    // virtual const IOUSBConfigurationDescriptor* GetFullConfigurationDescriptor(UInt8 configIndex) __attribute__((deprecated));
    // Replacement: getConfigurationDescriptor(configIndex)
    
    // virtual IOReturn GetConfigurationDescriptor(UInt8 configValue, void* data, UInt32 len) __attribute__((deprecated));
    // Replacement: getConfigurationDescriptorWithValue(configValue)


    // virtual IOUSBHostInterface* FindNextInterface(IOUSBHostInterface*        current,
    //                                               IOUSBFindInterfaceRequest* request) __attribute__((deprecated));
    // virtual OSIterator* CreateInterfaceIterator(IOUSBFindInterfaceRequest* request) __attribute__((deprecated));
    // Replacement:
    // OSIterator* iterator = _device->getChildIterator(gIOServicePlane);
    // OSObject* candidate = NULL;
    // while(iterator != NULL && (candidate = iterator->getNextObject()) != NULL)
    // {
    //     IOUSBHostInterface* interfaceCandidate = OSDynamicCast(IOUSBHostInterface, candidate);
    //     if(   interfaceCandidate != NULL
    //        && interfaceCandidate->getInterfaceDescriptor()->bInterfaceClass == kUSBHubClass)
    //     {
    //         _interface = interfaceCandidate;
    //         break;
    //     }
    // }
    // OSSafeReleaseNULL(iterator);
    
    // virtual IOReturn SetConfiguration(IOService* forClient, UInt8 configNumber, bool startMatchingInterfaces = true) __attribute__((deprecated));
    // Replacement: setConfiguration(configNumber, startMatchingInterfaces)

    // No longer supported.
    // Use getSpeed instead.
    // virtual UInt8 GetSpeed(void) __attribute__((deprecated));

    // virtual AppleUSBHostController* GetBus(void) __attribute__((deprecated));
    // Use getFrameNumber and createIOBuffer instead.

    // No longer supported.
    // Use allocateDownstreamBusCurrent instead.
    // virtual UInt32 GetBusPowerAvailable(void) __attribute__((deprecated));

    // virtual IOReturn DeviceRequest(IOUSBDevRequest* request,
    //                                IOUSBCompletion* completion = 0) __attribute__((deprecated));
    // virtual IOReturn DeviceRequest(IOUSBDevRequestDesc* request,
    //                                IOUSBCompletion*     completion = 0) __attribute__((deprecated));
    // virtual IOReturn DeviceRequest(IOUSBDevRequest* request,
    //                                UInt32           noDataTimeout,
    //                                UInt32           completionTimeout,
    //                                IOUSBCompletion* completion = 0) __attribute__((deprecated));
    // virtual IOReturn DeviceRequest(IOUSBDevRequestDesc* request,
    //                                UInt32               noDataTimeout,
    //                                UInt32               completionTimeout,
    //                                IOUSBCompletion*     completion = 0) __attribute__((deprecated));
    // Replacment:
    // deviceRequest(...)
    
    // virtual IOReturn GetConfiguration(UInt8* configNumber) __attribute__((deprecated));
    // Replacment:
    // uint8_t configNumber  = 0;
    // StandardUSB::DeviceRequest request;
    // request.bmRequestType = makeDeviceRequestbmRequestType(kRequestDirectionIn, kRequestTypeStandard, kRequestRecipientDevice);
    // request.bRequest      = kDeviceRequestGetConfiguration;
    // request.wValue        = 0;
    // request.wIndex        = 0;
    // request.wLength       = sizeof(configNumber);
    //
    // uint32_t bytesTransferred = 0;
    //    
    // deviceRequest(this, request, &configNumber, bytesTransferred, kUSBHostStandardRequestCompletionTimeout);
    
    // virtual IOReturn GetDeviceStatus(USBStatus* status) __attribute__((deprecated));
    // Replacement:
    // uint16_t status       = 0;
    // StandardUSB::DeviceRequest request;
    // request.bmRequestType = makeDeviceRequestbmRequestType(kRequestDirectionIn, kRequestTypeStandard, kRequestRecipientDevice);
    // request.bRequest      = kDeviceRequestGetStatus;
    // request.wValue        = 0;
    // request.wIndex        = 0;
    // request.wLength       = sizeof(status);
    //
    // uint32_t bytesTransferred = 0;
    //
    // deviceRequest(this, request, &status, bytesTransferred, kUSBHostStandardRequestCompletionTimeout);
    
    // virtual IOUSBHostPipe* GetPipeZero() __attribute__((deprecated));
    // virtual IOUSBHostPipe* getPipeZero() __attribute__((deprecated));
    // Replacement: none.  Use deviceRequest(...) and abortDeviceRequests(...) interfaces to interact with the default endpoint

    // virtual IOReturn GetStringDescriptor(UInt8 index, char* buf, int maxLen, UInt16 lang = 0x409) __attribute__((deprecated));
    // Replacement: getStringDescriptor(index, languageID)
    // Use sys/utfconv.h to extract UTF strings from string descriptors:
    // char stringBuffer[256] = { 0 };
    // size_t utf8len = 0;
    // const StringDescriptor* stringDescriptor = getStringDescriptor(index);
    // if(   stringDescriptor != NULL
    //    && stringDescriptor->bLength > StandardUSB::kDescriptorSize)
    // {
    //     utf8_encodestr(reinterpret_cast<const u_int16_t*>(stringDescriptor->bString), stringDescriptor->bLength - kDescriptorSize,
    //                    reinterpret_cast<u_int8_t*>(stringBuffer), &utf8len, sizeof(stringBuffer), '/', UTF_LITTLE_ENDIAN);
    // }

    // virtual const IOUSBDescriptorHeader* FindNextDescriptor(const void* cur, UInt8 descType) __attribute__((deprecated));
    // Replacement: StandardUSB::getNextDescriptor(getConfigurationDescriptor(currentConfig), cur, descType)

    // virtual IOReturn SuspendDevice(bool suspend) __attribute__((deprecated));
    // Replacement: forcePower(kPowerStateSuspended, false) or forcePower(kPowerStateOn, false)

    // virtual IOReturn ReEnumerateDevice(UInt32 options) __attribute__((deprecated));
    // Replacement: reset()

    // virtual IOReturn GetDeviceInformation(UInt32* info) __attribute__((deprecated));
    // Replacement: getPortStatus()

    // virtual UInt32 RequestExtraPower(UInt32 type, UInt32 requestedPower) __attribute__((deprecated));
    // virtual IOReturn ReturnExtraPower(UInt32 type, UInt32 returnedPower) __attribute__((deprecated));
    // TODO: Replacement

    // virtual tUSBHostDeviceAddress GetAddress(void) __attribute__((deprecated));
    // Replacement: getAddress()
    
    // virtual IOReturn ResetDevice() __attribute__((deprecated));
    // virtual UInt32 GetExtraPowerAllocated(UInt32 type) __attribute__((deprecated));
    // virtual void ForceIdlePolicy(UInt32 deviceIdleTimeout, UInt32 ioIdleTimeout) __attribute__((deprecated));
    // void SetBusPowerAvailable(UInt32 newPower) __attribute__((deprecated));
    // Replacement: none

protected:
    enum
    {
        kClientsDefaultCapacity          = 16,
        kPowerChildrenDefaultCapacity    = 16,
        kSetConfigurationIORetries       = 3,
        kSetConfigurationIORetryInterval = 100
    };

    AppleUSBHostRequestCompleter*            _requestCompleter;
    AppleUSBHostSynchronousRequestCompleter* _synchronousRequestCompleter;
    AppleUSBHostDeviceIdler*                 _deviceIdler;
    tUSBHostDeviceAddress                    _address;
    IOUSBHostPipe*                           _pipeZero;
    UInt8                                    _speed;
    StandardUSB::EndpointDescriptor          _endpointZero;
    IOBufferMemoryDescriptor**               _configList;
    uint32_t                                 _configListCount;
    uint8_t                                  _currentConfigValue;
    bool                                     _setConfigurationInProgress;
    uint32_t                                 _configurationBusCurrent; // mA
    uint32_t                                 _allocatedWakeBusCurrent; // mA
    uint32_t                                 _allocatedSleepBusCurrent;// mA
    uint32_t                                 _pendingCloseCount;
    
    uint32_t _debugLoggingMask;

    struct tExpansionData
    {
    };

    tExpansionData* _expansionData;

private:
    enum
    {
        kForcePowerTimeoutMs  = 1000ULL,      // Milliseconds
        kSuspendDeviceTimeout = 1000ULL,      // Milliseconds
        kTerminationTimeout   = 5000ULL       // Milliseconds
    };
};

#endif // IOUSBHostFamily_IOUSBHostDevice_h
                                                                                                                                                                                                                                                                         IOUSBHostFamily.h                                                                                   0100644 0001750 0001750 00000057177 12567452451 035672  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            //
//  IOUSBHostFamily.h
//  IOUSBHostFamily
//
//  Created by Dan Wilson on 1/14/15.
//
//

#ifndef IOUSBHostFamily_IOUSBHostFamily_h
#define IOUSBHostFamily_IOUSBHostFamily_h

#include <IOKit/usb/StandardUSB.h>

#pragma mark Typedefs

typedef uint16_t tUSBHostDeviceAddress;

#pragma mark General enumerations

#ifdef __cplusplus
using namespace StandardUSB;
#endif

enum tEndpointDirection
{
    kEndpointDirectionOut       = (kEndpointDescriptorDirectionOut >> kEndpointDescriptorDirectionPhase),
    kEndpointDirectionIn        = (kEndpointDescriptorDirectionIn >> kEndpointDescriptorDirectionPhase),
    kEndpointDirectionUnknown   = 2
};

typedef enum tEndpointDirection tEndpointDirection;

enum tEndpointType
{
    kEndpointTypeControl        = (kEndpointDescriptorTransferTypeControl >> kEndpointDescriptorTransferTypePhase),
    kEndpointTypeIsochronous    = (kEndpointDescriptorTransferTypeIsochronous >> kEndpointDescriptorTransferTypePhase),
    kEndpointTypeBulk           = (kEndpointDescriptorTransferTypeBulk >> kEndpointDescriptorTransferTypePhase),
    kEndpointTypeInterrupt      = (kEndpointDescriptorTransferTypeInterrupt >> kEndpointDescriptorTransferTypePhase)
};

typedef enum tEndpointType tEndpointType;

enum tDeviceRequestDirection
{
    kRequestDirectionOut            = (kDeviceRequestDirectionOut >> kDeviceRequestDirectionPhase),
    kRequestDirectionIn             = (kDeviceRequestDirectionIn >> kDeviceRequestDirectionPhase)
};

typedef enum tDeviceRequestDirection tDeviceRequestDirection;

enum tDeviceRequestType
{
    kRequestTypeStandard            = (kDeviceRequestTypeStandard >> kDeviceRequestTypePhase),
    kRequestTypeClass               = (kDeviceRequestTypeClass >> kDeviceRequestTypePhase),
    kRequestTypeVendor              = (kDeviceRequestTypeVendor >> kDeviceRequestTypePhase)
};

typedef enum tDeviceRequestType tDeviceRequestType;

enum tDeviceRequestRecipient
{
    kRequestRecipientDevice         = (kDeviceRequestRecipientDevice >> kDeviceRequestRecipientPhase),
    kRequestRecipientInterface      = (kDeviceRequestRecipientInterface >> kDeviceRequestRecipientPhase),
    kRequestRecipientEndpoint       = (kDeviceRequestRecipientEndpoint >> kDeviceRequestRecipientPhase),
    kRequestRecipientOther          = (kDeviceRequestRecipientOther >> kDeviceRequestRecipientPhase)
};

typedef enum tDeviceRequestRecipient tDeviceRequestRecipient;

inline uint8_t makeDeviceRequestbmRequestType(tDeviceRequestDirection direction, tDeviceRequestType type, tDeviceRequestRecipient recipient)
{
    return   ((direction << kDeviceRequestDirectionPhase) & kDeviceRequestDirectionMask)
            | ((type << kDeviceRequestTypePhase) & kDeviceRequestTypeMask)
            | ((recipient << kDeviceRequestRecipientPhase) & kDeviceRequestRecipientMask);
}

enum
{
    kUSBHostVendorSpecificClass             = 255,
    kUSBHostHubClass                        = 9,
    kUSBHostMaxDevices                      = 128,           // The largest number of devices permitted on USB 2.0 buses
    kUSBHostMaxPipes                        = 32,            // The largest number of endpoints permitted on USB devices
    kUSBHostMaxCountFullSpeedIsochronous    = 1023,       // max size (bytes) of any one Isoc frame for 1 FS endpoint
    kUSBHostVendorIDAppleComputer           = 0x05AC
};

/*!
 * @brief Connection speeds used internally by IOUSBHostFamily
 */
enum
{
    kUSBHostConnectionSpeedLow   = 0,
    kUSBHostConnectionSpeedFull  = 1,
    kUSBHostConnectionSpeedHigh  = 2,
    kUSBHostConnectionSpeedSuper = 3,
    kUSBHostConnectionSpeedCount = 4
};

/*!
 @define IOUSBHostFamily message codes
 @discussion Messages specific to the IOUSBHostFamily
 */

// The two most significant bits of the error and message code are used to indicate a USB subgroup.
#define iokit_usblegacy_group    (0 << StandardUSBBitRangePhase(12, 13))
#define iokit_usbhost_group      (1 << StandardUSBBitRangePhase(12, 13))
#define iokit_usb_codemask       StandardUSBBitRange(0, 11)

#define iokit_usbhost_msg(message) ((uint32_t)(iokit_family_msg(sub_iokit_usb, iokit_usbhost_group | (message & iokit_usb_codemask))))
#define	iokit_usblegacy_err_msg(message)     ((uint32_t)(sys_iokit | sub_iokit_usb | message))

#define kUSBHostMessageConfigurationSet               iokit_usbhost_msg(0x00)       // 0xe0005000  IOUSBHostDevice -> clients upon a setConfiguration call.
#define kUSBHostMessageRenegotiateCurrent             iokit_usbhost_msg(0x01)       // 0xe0005001  Request clients to renegotiate bus current allocations

#define kUSBHostMessageUpdateIdlePolicy               iokit_usbhost_msg(0x100)      // 0xe0005100  Internal use only.  IOUSBHostInterface -> IOUSBHostDevice to update its idle policy.
#define kUSBHostMessageRemoteWake                     iokit_usbhost_msg(0x101)      // 0xe0005101  Internal use only.  AppleUSBHostPort -> IOUSBHostDevice upon a remote wake event.
#define kUSBHostMessageDeviceSuspend                  iokit_usbhost_msg(0x102)      // 0xe0005102  Internal use only.  IOUSBHostDevice -> clients upon a suspend event.
#define kUSBHostMessageDeviceResume                   iokit_usbhost_msg(0x103)      // 0xe0005103  Internal use only.  IOUSBHostDevice -> clients upon a resume event.
#define kUSBHostMessagePortsCreated                   iokit_usbhost_msg(0x104)      // 0xe0005104  Internal use only.  AppleUSBHostController and AppleUSBHub -> clients after all ports have been created.
#define kUSBHostMessageDeviceConnected                iokit_usbhost_msg(0x105)      // 0xe0005105  Apple Internal use only.  AppleUSBRemovablePort -> clients after a connect.
#define kUSBHostMessageDeviceDisconnected             iokit_usbhost_msg(0x106)      // 0xe0005106  Apple Internal use only.  AppleUSBRemovablePort -> clients after a disconnect.

// User Message Support
#define kUSBHostMessageOvercurrentCondition           iokit_usblegacy_err_msg(0x13) // 0xe0004013  Message sent to the clients of the device's hub parent, when a device causes an overcurrent condition.  The message argument contains the locationID of the device
#define kUSBHostMessageNotEnoughPower                 iokit_usblegacy_err_msg(0x14) // 0xe0004014  Message sent to the clients of the device's hub parent, when a device causes an low power notice to be displayed.  The message argument contains the locationID of the device
#define kUSBHostMessageEndpointCountExceeded          iokit_usblegacy_err_msg(0x19) // 0xe0004019  Message sent to a device when endpoints cannot be created because the USB controller ran out of resources
#define kUSBHostMessageDeviceCountExceeded            iokit_usblegacy_err_msg(0x1a) // 0xe000401a  Message sent by a hub when a device cannot be enumerated because the USB controller ran out of resources
#define kUSBHostMessageUnsupportedConfiguration       iokit_usblegacy_err_msg(0x1c) // 0xe000401c  Message sent to the clients of the device when a device is not supported in the current configuration.  The message argument contains the locationID of the device
#define kUSBHostMessageHubCountExceeded               iokit_usblegacy_err_msg(0x1d) // 0xe000401d  Message sent when a 6th hub was plugged in and was not enumerated, as the USB spec only support 5 hubs in a chain
#define kUSBHostMessageTDMLowBattery                  iokit_usblegacy_err_msg(0x1e) // 0xe000401e  Message sent when when an attached TDM system battery is running low.

/*!
 @defined IOUSBHostFamily error codes
 @discussion  Errors specific to the IOUSBHostFamily.  Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
 */
#define iokit_usbhost_err(message) ((IOReturn)(iokit_family_err(sub_iokit_usb, iokit_usbhost_group | (message & iokit_usb_codemask))))

#define kUSBHostReturnPipeStalled   iokit_usbhost_err(0x0)  // 0xe0005000  Pipe has issued a STALL handshake.  Use clearStall to clear this condition.
#define kUSBHostReturnNoPower       iokit_usbhost_err(0x1)  // 0xe0005001  A setConfiguration call was not able to succeed because all configurations require more power than is available.

/*!
 * @brief Port types returned by IOUSBHostDevice::getPortStatus
 *
 * @constant kUSBHostPortTypeStandard A general-purpose USB port.
 * @constant kUSBHostPortTypeCaptive The attached device cannot be physically disconnected from the port.
 * @constant kUSBHostPortTypeInternal The attached device cannot be physically disconnected from the host machine.
 * @constant kUSBHostPortTypeAccessory The attached device may require authentication before function drivers can access it.
 * @constant kUSBHostPortTypeCount The number of entries in this enum.
 */
enum tUSBHostPortType
{
    kUSBHostPortTypeStandard = 0,
    kUSBHostPortTypeCaptive,
    kUSBHostPortTypeInternal,
    kUSBHostPortTypeAccessory,
    kUSBHostPortTypeCount
};

/*!
 * @brief Connection speeds returned by IOUSBHostDevice::getPortStatus
 * @discussion This enumeration matches the default speed ID mappings defined in XHCI 1.0 Table 147.
 *
 * @constant kUSBHostPortConnectionSpeedNone No device is connected
 * @constant kUSBHostPortConnectionSpeedFull A full-speed (12 Mb/s) device is connected
 * @constant kUSBHostPortConnectionSpeedLow A low-speed (1.5 Mb/s) device is connected
 * @constant kUSBHostPortConnectionSpeedHigh A high-speed (480 Mb/s) device is connected)
 * @constant kUSBHostPortConnectionSpeedSuper A superspeed (5 Gb/s) device is connected)
 */
enum tUSBHostConnectionSpeed
{
    kUSBHostPortConnectionSpeedNone  = 0,
    kUSBHostPortConnectionSpeedFull  = 1,
    kUSBHostPortConnectionSpeedLow   = 2,
    kUSBHostPortConnectionSpeedHigh  = 3,
    kUSBHostPortConnectionSpeedSuper = 4,
    kUSBHostPortConnectionSpeedCount = 5
};

/*!
 * @brief Values returned by IOUSBHostDevice::getPortStatus
 *
 * @constant kUSBHostPortStatusPortTypeMask The mask for bits representing the port type.
 * @constant kUSBHostPortStatusPortTypeStandard A general-purpose USB port.
 * @constant kUSBHostPortStatusPortTypeCaptive The attached device cannot be physically disconnected from the port.
 * @constant kUSBHostPortStatusPortTypeInternal The attached device cannot be physically disconnected from the host machine.
 * @constant kUSBHostPortStatusPortTypeAccessory The attached device may require authentication before function drivers can access it.
 * @constant kUSBHostPortStatusConnectedSpeedMask The mask for bits representing the connection state.
 * @constant kUSBHostPortStatusConnectedSpeedNone The port does not have a connected device.
 * @constant kUSBHostPortStatusConnectedSpeedFull The port has a full-speed device connected.
 * @constant kUSBHostPortStatusConnectedSpeedLow The port has a low-speed device connected.
 * @constant kUSBHostPortStatusConnectedSpeedHigh The port has a high-speed device connected.
 * @constant kUSBHostPortStatusConnectedSpeedSuper The port has a superspeed device connected.
 * @constant kUSBHostPortStatusResetting The port is currently resetting the link.
 * @constant kUSBHostPortStatusEnabled The port is enabled and packets are permitted to reach the device.  Not valid unless kUSBHostPortStatusConnectedSpeedMask is nonzero.
 * @constant kUSBHostPortStatusSuspended The port is suspended.  Not valid unless kUSBHostPortStatusConnectedSpeedMask is nonzero.
 * @constant kUSBHostPortStatusOvercurrent The port is in the overcurrent condition.
 * @constant kUSBHostPortStatusTestMode The port is in test mode.
 */
enum tUSBHostPortStatus
{
    kUSBHostPortStatusPortTypeMask          = StandardUSBBitRange(0, 3),
    kUSBHostPortStatusPortTypePhase         = StandardUSBBitRangePhase(0, 3),
    kUSBHostPortStatusPortTypeStandard      = (kUSBHostPortTypeStandard << StandardUSBBitRangePhase(0, 3)),
    kUSBHostPortStatusPortTypeCaptive       = (kUSBHostPortTypeCaptive << StandardUSBBitRangePhase(0, 3)),
    kUSBHostPortStatusPortTypeInternal      = (kUSBHostPortTypeInternal << StandardUSBBitRangePhase(0, 3)),
    kUSBHostPortStatusPortTypeAccessory     = (kUSBHostPortTypeAccessory << StandardUSBBitRangePhase(0, 3)),
    kUSBHostPortStatusPortTypeReserved      = StandardUSBBitRange(4, 7),
    kUSBHostPortStatusConnectedSpeedMask    = StandardUSBBitRange(8, 10),
    kUSBHostPortStatusConnectedSpeedPhase   = StandardUSBBitRangePhase(8, 10),
    kUSBHostPortStatusConnectedSpeedNone    = (kUSBHostPortConnectionSpeedNone << StandardUSBBitRangePhase(8, 10)),
    kUSBHostPortStatusConnectedSpeedFull    = (kUSBHostPortConnectionSpeedFull << StandardUSBBitRangePhase(8, 10)),
    kUSBHostPortStatusConnectedSpeedLow     = (kUSBHostPortConnectionSpeedLow << StandardUSBBitRangePhase(8, 10)),
    kUSBHostPortStatusConnectedSpeedHigh    = (kUSBHostPortConnectionSpeedHigh << StandardUSBBitRangePhase(8, 10)),
    kUSBHostPortStatusConnectedSpeedSuper   = (kUSBHostPortConnectionSpeedSuper << StandardUSBBitRangePhase(8, 10)),
    kUSBHostPortStatusResetting             = StandardUSBBit(11),
    kUSBHostPortStatusEnabled               = StandardUSBBit(12),
    kUSBHostPortStatusSuspended             = StandardUSBBit(13),
    kUSBHostPortStatusOvercurrent           = StandardUSBBit(14),
    kUSBHostPortStatusTestMode              = StandardUSBBit(15)
};

/*!
 @enum Default control request timeout values in milliseconds
 @discussion default values used for data and completion timeouts.
 */
enum
{
#if USB_COMPLIANCE_MODE
    kUSBHostSetAddressTimeout                      = 50,    // USB 2.0 9.2.6.3
    kUSBHostStandardRequestNoDataTimeout           = 500,   // USB 2.0 9.2.6.4
    kUSBHostStandardRequestCompletionTimeout       = 5000,  // USB 2.0 9.2.6.4
    kUSBHostStandardRequestSimpleCompletionTimeout = 50,    // USB 2.0 9.2.6.4 Standard request with no data stage
    kUSBHostClassRequestNoDataTimeout              = 500,   // USB 2.0 9.2.6.5
    kUSBHostClassRequestCompletionTimeout          = 5000,  // USB 2.0 9.2.6.5
    kUSBHostVendorRequestNoDataTimeout             = 0,
    kUSBHostVendorRequestCompletionTimeout         = 5000,
#else
    // More tolerant timeout values for noncompliant devices
    kUSBHostSetAddressTimeout                      = 1000,
    kUSBHostStandardRequestNoDataTimeout           = 0,
    kUSBHostStandardRequestCompletionTimeout       = 5000,
    kUSBHostStandardRequestSimpleCompletionTimeout = 1000,
    kUSBHostClassRequestNoDataTimeout              = 0,
    kUSBHostClassRequestCompletionTimeout          = 5000,
    kUSBHostVendorRequestNoDataTimeout             = 0,
    kUSBHostVendorRequestCompletionTimeout         = 5000,
#endif
    kUSBHostDefaultControlNoDataTimeoutMS          = 0,
    kUSBHostDefaultControlCompletionTimeoutMS      = 5000
};

#pragma mark Registry property names

#define kUSBHostMatchingPropertySpeed                           "USBSpeed"
#define kUSBHostMatchingPropertyPortType                        "USBPortType"

#define kUSBHostMatchingPropertyVendorID                        "idVendor"
#define kUSBHostMatchingPropertyProductID                       "idProduct"
#define kUSBHostMatchingPropertyProductIDMask                   "idProductMask"
#define kUSBHostMatchingPropertyProductIDArray                  "idProductArray"
#define kUSBHostMatchingPropertyDeviceClass                     "bDeviceClass"
#define kUSBHostMatchingPropertyDeviceSubClass                  "bDeviceSubClass"
#define kUSBHostMatchingPropertyDeviceProtocol                  "bDeviceProtocol"
#define kUSBHostMatchingPropertyDeviceReleaseNumber             "bcdDevice"
#define kUSBHostMatchingPropertyConfigurationValue              "bConfigurationValue"
#define kUSBHostMatchingPropertyInterfaceClass                  "bInterfaceClass"
#define kUSBHostMatchingPropertyInterfaceSubClass               "bInterfaceSubClass"
#define kUSBHostMatchingPropertyInterfaceProtocol               "bInterfaceProtocol"
#define kUSBHostMatchingPropertyInterfaceNumber                 "bInterfaceNumber"

#define kUSBHostPropertyLocationID                              "locationID"
#define kUSBHostPropertyDataToggleResetOverride                 "kUSBDataToggleResetOverride"
#define kUSBHostPropertyDebugOptions                            "kUSBDebugOptions"
#define kUSBHostPropertyWakePowerSupply                         "kUSBWakePowerSupply"
#define kUSBHostPropertySleepPowerSupply                        "kUSBSleepPowerSupply"
#define kUSBHostPropertyWakePortCurrentLimit                    "kUSBWakePortCurrentLimit"
#define kUSBHostPropertySleepPortCurrentLimit                   "kUSBSleepPortCurrentLimit"
#define kUSBHostPropertyFailedRemoteWake                        "kUSBFailedRemoteWake"

// Legacy power properties
#define kAppleMaxPortCurrent                "AAPL,current-available"
#define kAppleCurrentExtra                  "AAPL,current-extra"
#define kAppleMaxPortCurrentInSleep         "AAPL,max-port-current-in-sleep"
#define kAppleCurrentExtraInSleep           "AAPL,current-extra-in-sleep"
#define kAppleExternalConnectorBitmap       "AAPL,ExternalConnectorBitmap"

#if TARGET_OS_EMBEDDED
// Only define these properties on embedded platforms because the legacy IOUSBLib code still uses them
#define kUSBHostDevicePropertyAddress                           "kUSBAddress"
#define kUSBHostDevicePropertyManufacturerStringIndex           "iManufacturer"
#define kUSBHostDevicePropertySerialNumberStringIndex           "iSerialNumber"
#define kUSBHostDevicePropertyProductStringIndex                "iProduct"
#define kUSBHostDevicePropertyProductString                     "kUSBProductString"
#define kUSBHostDevicePropertyNumConfigs                        "bNumConfigurations"
#define kUSBHostDevicePropertyMaxPacketSize                     "bMaxPacketSize0"
#define kUSBHostDevicePropertyStandardVersion                   "bcdUSB"
#endif
#define kUSBHostDevicePropertyVendorString                      "kUSBVendorString"
#define kUSBHostDevicePropertySerialNumberString                "kUSBSerialNumberString"
#define kUSBHostDevicePropertyContainerID                       "kUSBContainerID"
#define kUSBHostDevicePropertyFailedRequestedPower              "kUSBFailedRequestedPower"
#define kUSBHostDevicePropertyResumeRecoveryTime                "kUSBResumeRecoveryTime"
#define kUSBHostDevicePropertyPreferredConfiguration            "kUSBPreferredConfiguration"
#define kUSBHostDevicePropertyCurrentConfiguration              "kUSBCurrentConfiguration"
#define kUSBHostDevicePropertyRemoteWakeOverride                "kUSBRemoteWakeOverride"
#define kUSBHostDevicePropertyConfigurationDescriptorOverride   "kUSBConfigurationDescriptorOverride"
#define kUSBHostDevicePropertyConfigurationCurrentOverride      "kUSBConfigurationCurrentOverride"
#define kUSBHostDevicePropertyResetDurationOverride             "kUSBResetDurationOverride"

#if TARGET_OS_EMBEDDED
#define kUSBHostInterfacePropertyStringIndex                    "iInterface"
#define kUSBHostInterfacePropertyString                         "kUSBString"
#define kUSBHostInterfacePropertyNumEndpoints                   "bNumEndpoints"
#endif
#define kUSBHostInterfacePropertyAlternateSetting               "bAlternateSetting"

#define kUSBHostPortPropertyPortNumber                          "port"
#define kUSBHostPortPropertyRemovable                           "removable"
#define kUSBHostPortPropertyTestMode                            "kUSBTestMode"
#define kUSBHostPortPropertySimulateInterrupt                   "kUSBSimulateInterrupt"
#define kUSBHostPortPropertyBusCurrentAllocation                "kUSBBusCurrentAllocation"
#define kUSBHostPortPropertyBusCurrentSleepAllocation           "kUSBBusCurrentSleepAllocation"
#define kUSBHostPortPropertyConnectable                         "UsbConnectable"
#define kUSBHostPortPropertyConnectorType                       "UsbConnector"
#define kUSBHostPortPropertyMux                                 "UsbMux"
#define kUSBHostPortPropertyCompanionIndex                      "kUSBCompanionIndex"

#define kUSBHostHubPropertyPowerSupply                          "kUSBHubPowerSupply"                    // OSNumber mA available for downstream ports, 0 for bus-powered
#define kUSBHostHubPropertyIdlePolicy                           "kUSBHubIdlePolicy"                     // OSNumber ms to be used as device idle policy
#define kUSBHostHubPropertyStartupDelay                         "kUSBHubStartupDelay"                   // OSNumber ms delay before creating downstream ports
#define kUSBHostHubPropertyPortSequenceDelay                    "kUSBHubPortSequenceDelay"              // OSNumber ms delay between port creation

#define kUSBHostControllerPropertyIsochronousRequiresContiguous "kUSBIsochronousRequiresContiguous"
#define kUSBHostControllerPropertyDebugError                    "kUSBDebugError"
#define kUSBHostControllerPropertySleepSupported                "kUSBSleepSupported"
#define kUSBHostControllerPropertyMuxEnabled                    "kUSBMuxEnabled"
#define kUSBHostControllerPropertyCompanion                     "kUSBCompanion"                         // OSBoolean false to disable all companion controllers
#define kUSBHostControllerPropertyLowSpeedCompanion             "kUSBLowSpeedCompanion"                 // OSBoolean false to disable low-speed companion controller
#define kUSBHostControllerPropertyFullSpeedCompanion            "kUSBFullSpeedCompanion"                // OSBoolean false to disable full-speed companion controller
#define kUSBHostControllerPropertyHighSpeedCompanion            "kUSBHighSpeedCompanion"                // OSBoolean false to disable high-speed companion controller
#define kUSBHostControllerPropertySuperSpeedCompanion           "kUSBSuperSpeedCompanion"               // OSBoolean false to disable superspeed companion controller

#define kUSBHostPortPropertyExternalDeviceResetController       "kUSBHostPortExternalDeviceResetController"
#define kUSBHostPortPropertyExternalDevicePowerController       "kUSBHostPortExternalDevicePowerController"

#define kUSBHostPortPropertyCardReader                          "kUSBHostPortPropertyCardReader"

#define kUSBHostPortPropertyOffset                              "kUSBHostPortPropertyOffset"

#if !TARGET_OS_EMBEDDED
#define kUSBExpressCardCantWake                                 "kUSBExpressCardCantWake"
#endif

#pragma mark APCI enumerations

// UPC definitions from ACPI Rev 4.0
typedef enum
{
    kUSBHostPortNotConnectable = 0,                 // Port is not connectable
    kUSBHostPortConnectable    = 1                  // Port is connectable either user visible or invisible
} tUSBHostPortConnectable;

typedef enum
{
    kUSBHostConnectorTypeA              = 0x00,
    kUSBHostConnectorTypeMiniAB         = 0x01,
    kUSBHostConnectorTypeExpressCard    = 0x02,
    kUSBHostConnectorTypeUSB3A          = 0x03,
    kUSBHostConnectorTypeUSB3B          = 0x04,
    kUSBHostConnectorTypeUSB3MicroB     = 0x05,
    kUSBHostConnectorTypeUSB3MicroAB    = 0x06,
    kUSBHostConnectorTypeUSB3PowerB     = 0x07,
    kUSBHostConnectorTypeUnknown        = 0xFE,
    kUSBHostConnectorTypeProprietary    = 0xFF
} tUSBHostConnectorType;

#if !TARGET_OS_EMBEDDED

#ifndef kACPIDevicePathKey
#define kACPIDevicePathKey          "acpi-path"
#endif

#ifndef kACPIInterruptTypeValid
#define kACPIInterruptTypeValid     (1 << 1)
#endif

// ACPI methods
#define kUSBHostACPIPropertyXHCICompanion   "XHCN"      // The number of the companion XHCI controller, used for multiplexed ports
#define kUSBHostACPIPropertyMultiplexor     "MUXS"      // The ACPI method name for the port multiplexor

// _UPC
// _EJD

#define kSDControllerGPIOResetACPIMethod                "SRST"
#define kSDControllerGPIOPowerACPIMethod                "SPWR"
#define kSDPortConnectionBehaviorACPIMethod             "SBHV"
#define kSDControllerGPIOResetPropertyKey               "GPIO_RESET"
#define kSDControllerCaptiveUSB3ReaderKey               "U3SD"
#define kGetBehaviorACPIMethod                          "GBHV"
#define kGPEACPIString                                  "_GPE"
#define kRDYForGPIOTest                                 "RDYG"
#define kReconfiguredCount                              "RCFG"
#define kUSBPlatformProperties                          "USBX"


#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                 IOUSBHostHIDDevice.h                                                                                0100644 0001750 0001750 00000021716 12567452506 036164  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef IOUSBHOSTHIDDEVICE_H
#define IOUSBHOSTHIDDEVICE_H

#include <IOKit/IOBufferMemoryDescriptor.h>

#include <IOKit/hid/IOHIDDevice.h>

#include <IOKit/usb/IOUSBHostInterface.h>
#include <IOKit/usb/StandardUSB.h>
#include <IOKit/usb/IOUSBHostFamily.h>
#include <IOKit/IOTimerEventSource.h>


#define ENABLE_HIDREPORT_LOGGING	0

enum
{
    kUSBHIDDesc                         = 0x21,
    kUSBReportDesc                      = 0x22,

    kHIDNoInterfaceProtocol       = 0,
    kHIDKeyboardInterfaceProtocol = 1,
    kHIDMouseInterfaceProtocol    = 2,
    kUSBVendorSpecificProtocol    = 0xff,
    
    kUSBHIDClass          = 3,
    kUSBHIDInterfaceClass = 3,
    kUSBHIDBootInterfaceSubClass = 0x01,
    
    kHIDBootProtocolValue   = 0,
    kHIDReportProtocolValue = 1,
    
    kHIDRqGetReport   = 1,
    kHIDRqGetIdle     = 2,
    kHIDRqGetProtocol = 3,
    kHIDRqSetReport   = 9,
    kHIDRqSetIdle     = 10,
    kHIDRqSetProtocol = 11,
    
    kHIDRtInputReport   = 1,
    kHIDRtOutputReport  = 2,
    kHIDRtFeatureReport = 3,

    kInterruptRetries  = 10
};

//	from IOHIDDescriptorParser.h:
//    // types of HID reports (input, output, feature)
//    enum
//    {
//        kHIDInputReport			= 	1,
//        kHIDOutputReport,
//        kHIDFeatureReport,
//        kHIDUnknownReport		=	255
//    };
//
// Report types from high level HID Manager:
//	from IOHIDKeys.h:
//    enum IOHIDReportType
//    {
//        kIOHIDReportTypeInput = 0,
//        kIOHIDReportTypeOutput,
//        kIOHIDReportTypeFeature,
//        kIOHIDReportTypeCount
//    };
//
#define HID_MGR_2_USB_REPORT_TYPE(x) (x + 1)

#define USB_2_HID_MGR_REPORT_TYPE(x) (x - 1)

#define kHIDDriverRetryCount	3

#define	kUSBHIDReportLoggingLevel	"USB HID Report Logging Level"

#define kUSBHID_DeviceIdleTimeout "Device Idle Timeout"

#define kUSBHID_IoIdleTimeout "I/O Idle Timeout"

/*!
 @typedef IOUSBHostHIDDescriptor
 @discussion USB HID Descriptor.  See the USB HID Specification at <a href="http://www.usb.org"TARGET="_blank">http://www.usb.org</a>.  (This structure
 should have used the #pragma pack(1) compiler directive to get byte alignment.
 */
struct IOUSBHostHIDDescriptor : public StandardUSB::Descriptor
{
    uint16_t descVersNum;
    uint8_t  hidCountryCode;
    uint8_t  hidNumDescriptors;
    uint8_t  hidDescriptorType;
    uint8_t  hidDescriptorLengthLo;
    uint8_t  hidDescriptorLengthHi;
} __attribute__((packed));

/*!
 @typedef IOUSBHIDReportDesc
 @discussion USB HID Report Descriptor header.  See the USB HID Specification at <a href="http://www.usb.org"TARGET="_blank">http://www.usb.org</a>.  (This structure
 should have used the #pragma pack(1) compiler directive to get byte alignment.
 */
struct IOUSBHostHIDReportDescriptor
{
    uint8_t hidDescriptorType;
    uint8_t hidDescriptorLengthLo;
    uint8_t hidDescriptorLengthHi;
} __attribute__((packed));

/*!
 @class IOUSBHostHIDDevice
 @abstract Driver that matches to USB HID devices.
 @discussion This class can be overriden to provide for specific behaviors.
 */
class IOUSBHostHIDDevice : public IOHIDDevice
{
    OSDeclareDefaultStructors(IOUSBHostHIDDevice)
    
private:
    typedef struct IOUSBHidExpansionData
    {
        
    } tIOUSBHidExpansionData;
    
    tIOUSBHidExpansionData *_expansionData;
    
    typedef struct
    {
        IOUSBHostCompletion     usbCompletion;
        IOHIDCompletion*        hidCompletion;
        IOMemoryDescriptor*     report;
    } tAsyncContext;
    
    
protected:
    IOWorkLoop               *_workLoop;
    IOCommandGate            *_gate;
    IOUSBHostDevice          *_device;
    IOUSBHostInterface       *_interface;
    IOUSBHostPipe            *_interruptPipe;
    IOUSBHostPipe            *_interruptOutPipe;
    IOBufferMemoryDescriptor *_buffer;
    IOMemoryDescriptor       *_zlpDescriptor;
    IOUSBHostCompletion       _completion;
    IOUSBHostCompletion       _zlpCompletion;
    bool                      _interruptReadPending;
    uint32_t                  _interruptOutMaxSize;
    uint32_t                  _zlpBuffer;
    uint32_t                  _debugLoggingMask;
    int32_t                   _interruptRetries;
    IOTimerEventSource       *_interruptRetriesTimer;

    // IOHIDDevice Methods
    virtual bool      handleStart (IOService *provider);
    virtual void      interruptRetry(IOTimerEventSource* timer);

    // IOUSBHIDDevice Methods
    virtual IOReturn  setProtocol (uint16_t protocol);
    
    virtual OSString* getStringAtIndex (uint8_t index, uint16_t lang = 0x0409) const;
    
    virtual IOReturn  getHidDescriptor (uint8_t inDescriptorType, uint8_t inDescriptorIndex, uint8_t *vOutBuf, uint32_t *vOutSize) const;
    
    virtual IOReturn  getHidDescriptorGated (uint8_t inDescriptorType, uint8_t inDescriptorIndex, uint8_t *vOutBuf, uint32_t *vOutSize) const;
    
    virtual IOReturn  readInterruptPipeAsync (void);
    
    virtual IOReturn  readInterruptPipeAsyncGated (void);
    
    virtual void      interruptReadComplete (void *parameter, IOReturn status, uint32_t bytesTransferred);
    
    virtual void      setReportComplete (void *parameter, IOReturn status, uint32_t bytesTransferred);
    
    virtual void      zlpWriteComplete (void *parameter, IOReturn status, uint32_t bytesTransferred);
    
    // Protected pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 0);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 1);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 2);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 3);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 4);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 5);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 6);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 7);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 8);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 9);

public:
    // IOService Methods
    virtual bool start (IOService *provider);
    
    virtual bool willTerminate (IOService *provider, IOOptionBits options);
    
    virtual void stop (IOService *provider);
    
    virtual void free (void);
    
    
    // IOHIDDevice Methods
    virtual IOReturn  newReportDescriptor (IOMemoryDescriptor **descriptor ) const;
    
    virtual OSString* newTransportString (void) const;
    
    virtual OSString* newManufacturerString (void) const;
    
    virtual OSString* newProductString (void) const;
    
    virtual OSString* newSerialNumberString (void) const;
    
    virtual OSNumber* newVendorIDNumber (void) const;
    
    virtual OSNumber* newProductIDNumber (void) const;
    
    virtual OSNumber* newVersionNumber (void) const;
    
    virtual OSNumber* newLocationIDNumber (void) const;
    
    virtual OSNumber* newCountryCodeNumber (void) const;
    
    virtual IOReturn getReport (IOMemoryDescriptor *report, IOHIDReportType reportType, IOOptionBits options);
    
    virtual IOReturn setReport (IOMemoryDescriptor *report, IOHIDReportType reportType, IOOptionBits options = 0);
    
    virtual IOReturn setReport(IOMemoryDescriptor * report, IOHIDReportType reportType, IOOptionBits options, UInt32 completionTimeout, IOHIDCompletion* completion = 0);
    
    
    // IOUSBHIDDevice Methods
    virtual IOReturn  SetIdleMillisecs (UInt16 msecs);
    
    virtual UInt32    getMaxReportSize (void) const;
    
    virtual OSString* newIndexedString (UInt8 index) const;
    
    // Public pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 10);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 11);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 12);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 13);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 14);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 15);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 16);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 17);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 18);
    OSMetaClassDeclareReservedUnused(IOUSBHostHIDDevice, 19);
};

#endif	// IOUSBHOSTHIDDEVICE_H
                                                  IOUSBHostIOSource.h                                                                                 0100644 0001750 0001750 00000026455 12567452451 036134  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            //
//  IOUSBHostIOSource.h
//  IOUSBHostFamily
//
//  Created by Dan Wilson on 2/17/14.
//
//

/*!
 * @header IOUSBHostIOSource.h
 *
 * @brief Provides IOUSBHostIOSource API
 */

#ifndef IOUSBHostFamily_IOUSBHostIOSource_h
#define IOUSBHostFamily_IOUSBHostIOSource_h

#include <libkern/c++/OSObject.h>
#include <IOKit/IOCommandGate.h>
#include <IOKit/IOTimerEventSource.h>
#include <IOKit/IOMemoryDescriptor.h>
#include <IOKit/usb/IOUSBHostFamily.h>

class AppleUSBHostController;
class IOUSBHostDevice;
class AppleUSBHostRequestPool;

typedef void (*IOUSBHostCompletionAction)(void* owner, void* parameter, IOReturn status, uint32_t bytesTransferred);
struct IOUSBHostCompletion
{
    void* owner;
    IOUSBHostCompletionAction action;
    void* parameter;
};

/*!
 * @typedef IOUSBHostIsochronousFrame
 * @discussion Structure representing a single frame in an isochronous transfer.
 * @param status Completion status for this individual frame.  IOUSBHostFamily will initialize this to kIOReturnInvalid
 * and will update the field with a valid status code upon completion of the frame.
 * @param requestCount The number of bytes requested to transfer for this frame.  This field must be initialized by the caller
 * before this structure is submitted to IOUSBHostFamily.
 * @param completeCount The number of bytes actually transferred for this frame.  IOUSBHostFamily will update this field
 * upon completion of the frame.
 * @param timeStamp The observed AbsoluteTime for this frame's completion.
 */
struct IOUSBHostIsochronousFrame
{
    IOReturn     status;
    uint32_t     requestCount;
    uint32_t     completeCount;
    AbsoluteTime timeStamp;
};

typedef void (*IOUSBHostIsochronousCompletionAction)(void* owner, void* parameter, IOReturn status, IOUSBHostIsochronousFrame* frameList);
struct IOUSBHostIsochronousCompletion
{
    void* owner;
    IOUSBHostIsochronousCompletionAction action;
    void* parameter;
};

/*!
 * @class IOUSBHostIOSource
 *
 * @brief IOUSBHostIOSource object
 *
 * @discussion Provides the base class API for controlling pipe policy and performing I/O.
 */
class IOUSBHostIOSource : public OSObject
{
    friend class AppleUSBIORequest;
    friend class IOUSBHostInterface;

    OSDeclareAbstractStructors(IOUSBHostIOSource)

protected:
    virtual void free();
    
    virtual bool initWithOwners(AppleUSBHostController* controller, IOUSBHostDevice* device);
    
    // Pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 0);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 1);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 2);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 3);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 4);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 5);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 6);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 7);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 8);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 9);
    
public:
    /*!
     * @brief Return value for <code>getState()</code>
     *
     * @constant kStateReady The I/O source is idle and fully-functional.
     * @constant kStateRunningCompletions The I/O source is currently running completions.
     * @constant kStateAborting The I/O source is currently aborting all requests.
     * @constant kStateInactive The I/O source has been closed.
     */
    enum tState
    {
        kStateReady,
        kStateRunningCompletions,
        kStateAborting,
        kStateInactive
    };

    /*!
     * @brief Returns the current state of the I/O source.
     *
     * @return @link tState @/link
     */
    virtual tState getState();

    /*!
     * @brief Options for <code>abort()</code>
     *
     * @constant kAbortAsynchronous the abort should occur asynchronously.
     * @constant kAbortSynchronous the abort should occur synchronously.
     */
    enum tAbortOptions
    {
        kAbortAsynchronous = 0x0,
        kAbortSynchronous  = 0x1
    };

    /*!
     * @brief Abort pending I/O requests.
     *
     * @discussion This method will abort all pending I/O requests.  If <code>options</code> is  <code>kAbortSynchronous</code>
     * this method will block any new requests that are not submitted from one of the aborted request's callback until the abort
     * completes.
     *
     * @param options Whether the abort operation should be synchronous or not.
     *
     * @param withError Error code which will be passed to any request which hasn't successfully completed.
     *
     * @param forClient Service for which to abort requests.  If NULL, all requests will be aborted.  Only control endpoints can
     * specify a non-NULL value.
     *
     * @return IOReturn result code
     */
    virtual IOReturn abort(IOOptionBits options = kAbortAsynchronous, IOReturn withError = kIOReturnAborted, IOService* forClient = NULL);
    
    // Public pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 10);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 11);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 12);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 13);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 14);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 15);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 16);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 17);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 18);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 19);
    
protected:
    // Protected pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 20);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 21);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 22);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 23);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 24);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 25);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 26);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 27);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 28);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 29);
        
protected:
    struct tSynchronousParameter
    {
        uint32_t bytesTransferred;
        IOReturn status;
    };

    virtual void synchronousCompletion(void* parameter, IOReturn status, uint32_t bytesTransferred);
    virtual void synchronousIsochronousCompletion(void* parameter, IOReturn status, IOUSBHostIsochronousFrame* pFrames);

    virtual IOReturn getStateGated(tState& state);

    virtual IOReturn close();

    virtual IOReturn closeGated();

    virtual IOReturn abortGated(IOOptionBits options, IOReturn withError, IOService* forClient);

    virtual void timerCompletion(IOTimerEventSource* timer);

    AppleUSBHostController* _controller;
    IOUSBHostDevice*        _device;

    IOWorkLoop*              _workloop;
    IOCommandGate*           _commandGate;
    IOTimerEventSource*      _timer;
    AppleUSBHostRequestPool* _requestPool;

    tState                  _state;
    UInt32                  _outstandingIO;
    UInt32                  _completionRunning;
    
#pragma mark IO
public:
    /*!
     * @brief Issue an asynchronous I/O request on the source.
     *
     * @discussion This method is used to issue an asynchronous I/O request on a bulk or interrupt pipe.
     *
     * See IOUSBHostPipe::io and IOUSBHostStream::io for object-specific interface notes.
     *
     * @param dataBuffer Pointer to a valid memory descriptor to use as the backing store for the I/O.
     *
     * @param dataBufferLength Length of the request.  Must be >= <code>dataBuffer->getLength()</code>
     *
     * @param completion Pointer to a valid, non NULL, IOUSBHostCompletion object.  This will be copied and can therefore be stack-allocated.
     *
     * @param completionTimeoutMs Timeout of the request in milliseconds.  If 0, the request will never timeout.
     * Must be 0 for interrupt pipes and streams.
     *
     * @return IOReturn result code
     */
    virtual IOReturn io(IOMemoryDescriptor* dataBuffer, uint32_t dataBufferLength, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs = 0);
    
    /*!
     * @brief Issue a synchronous I/O request on the source.
     *
     * @discussion This method is used to issue a synchronous I/O request on a bulk or interrupt pipe.  Although this
     * is a synchronous call, it is permitted to be called from the completion callback of an asynchronous request.
     *
     * See IOUSBHostPipe::io and IOUSBHostStream::io for object-specific interface notes.
     *
     * @param dataBuffer Pointer to the memory to be used for the I/O.
     *
     * @param dataBufferLength Length of the request.  Must be >= the amount of memory allocated to <code>dataBuffer</code>
     *
     * @param bytesTransferred Reference which will be updated with the bytes transferred during the request.
     *
     * @param completionTimeoutMs Timeout of the request in milliseconds.  If 0, the request will never timeout.
     * Must be 0 for interrupt pipes and streams.
     *
     * @return IOReturn result code
     */
    virtual IOReturn io(IOMemoryDescriptor* dataBuffer, uint32_t dataBufferLength, uint32_t& bytesTransferred, uint32_t completionTimeoutMs = 0);
    
    // Public pad slots for IO
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 30);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 31);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 32);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 33);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 34);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 35);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 36);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 37);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 38);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 39);

protected:
    // Protected pad slots for IO
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 40);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 41);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 42);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 43);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 44);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 45);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 46);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 47);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 48);
    OSMetaClassDeclareReservedUnused(IOUSBHostIOSource, 49);
    
protected:
    struct tInternalDataTransferParameters
    {
        IOMemoryDescriptor*             dataBuffer;
        uint32_t                        dataBufferLength;
        uint32_t*                       bytesTransferred;
        IOUSBHostCompletion*            completion;
        uint32_t                        completionTimeoutMs;
        IOUSBHostIsochronousFrame*      frameList;
        uint32_t                        frameListCount;
        uint64_t                        firstFrameNumber;
        IOUSBHostIsochronousCompletion* isochronousCompletion;
    };
    
    virtual IOReturn ioGated(tInternalDataTransferParameters& parameters);
    
    struct tExpansionData
    {
    };
    
    tExpansionData* _expansionData;
    
#pragma mark Debug
    uint32_t                _debugLoggingMask;
};

#endif
                                                                                                                                                                                                                   IOUSBHostInterface.h                                                                                0100644 0001750 0001750 00000064407 12567452451 036343  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright (c) 1998-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOUSBHostInterface.h
 *
 * @brief Provides IOUSBHostInterface API
 */

#ifndef IOUSBHostFamily_IOUSBHostInterface_h
#define IOUSBHostFamily_IOUSBHostInterface_h

#include <IOKit/IOService.h>
#include <libkern/c++/OSData.h>

#include <IOKit/usb/IOUSBHostFamily.h>
#include <IOKit/usb/IOUSBHostDevice.h>

/*!
 * @class IOUSBHostInterface
 *
 * @abstract The object representing an interface of a device on the USB bus.
 *
 * @discussion This class provides functionality to find the pipes of an interface and to read the descriptors associated
 * with an interface. When an interface is open()ed,  all its pipes are created.
 */
class IOUSBHostInterface : public IOService
{
    OSDeclareDefaultStructors(IOUSBHostInterface)

public:
    static IOUSBHostInterface* withDescriptors(const StandardUSB::ConfigurationDescriptor* configurationDescriptor, const StandardUSB::InterfaceDescriptor* interfaceDescriptor);

protected:
    virtual bool initWithDescriptors(const StandardUSB::ConfigurationDescriptor* configurationDescriptor, const StandardUSB::InterfaceDescriptor* interfaceDescriptor);

    // Pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 0);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 1);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 2);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 3);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 4);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 5);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 6);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 7);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 8);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 9);

#pragma mark IOService overrides
public:
    virtual bool        attach(IOService* provider);
    virtual bool        start(IOService* provider);
    virtual bool        terminate(IOOptionBits options = 0);
    virtual void        stop(IOService* provider);
    virtual void        free();

    virtual bool compareProperty(OSDictionary* matching, const char* key);
    virtual bool compareProperty(OSDictionary* matching, const OSString* key);
    virtual bool matchPropertyTable(OSDictionary* table, SInt32* score);

    enum
    {
        kOpenOptionsSelectAlternateInterface = StandardUSBBit(16)
    };
    virtual bool        open(IOService* forClient, IOOptionBits options = 0, void* arg = 0);
    virtual void        close(IOService* forClient, IOOptionBits options = 0);
    
    virtual IOReturn    message(UInt32 type, IOService* provider,  void* argument = 0);

    virtual const char* stringFromReturn(IOReturn rtn);
    
protected:
    virtual IOReturn openGated(IOService* forClient, IOOptionBits options, void* arg);
    virtual IOReturn closeGated(IOService* forClient, IOOptionBits options);
    
    // Pad slots for IOService overrides
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 10);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 11);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 12);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 13);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 14);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 15);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 16);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 17);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 18);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 19);
    
protected:
    IOCommandGate* _commandGate;
    IOWorkLoop*    _workLoop;

#pragma mark Power management
public:
    /*!
     * @brief Sets the desired idle policy for the device
     *
     * @discussion TODO talk about device idleness, largest deviceIdleTimeout wins etc
     *
     * @param deviceIdleTimeout The amount of time, in milliseconds, after all pipes are idle to wait before suspending the device.
     *
     * @return IOReturn result code
     */
    virtual IOReturn setIdlePolicy(uint32_t deviceIdleTimeout);
    
    /*!
     * @brief Returns the current device idle timeout.  See @link IOUSBHostInterface::setIdlePolicy @/link
     *
     * @return The amount of time, in milliseconds, after all pipes are idle to wait before suspending the device,
     */
    virtual uint32_t getIdlePolicy();
    
    // Public pad slots for power management
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 20);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 21);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 22);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 23);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 24);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 25);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 26);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 27);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 28);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 29);
    
protected:
    // Protected pad slots for power management
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 30);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 31);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 32);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 33);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 34);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 35);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 36);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 37);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 38);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 39);

protected:
    uint32_t _deviceIdleTimeout;
    
#pragma mark Descriptors
public:
    /*!
     * @brief Return the configuration descriptor in which this interface is defined
     *
     * @return Pointer to the configuration descriptor
     */
    virtual const StandardUSB::ConfigurationDescriptor* getConfigurationDescriptor();
    
    /*!
     * @brief Return the interface descriptor associated with this interface
     *
     * @return Pointer to the interface descriptor for this interface
     */
    virtual const StandardUSB::InterfaceDescriptor* getInterfaceDescriptor();
    
    /*!
     * @brief Return a string descriptor from the device
     *
     * @discussion This method is simply a convenience method to retieve the desired string descriptor.
     *
     * @param index  Descriptor index value.  Low byte of <code>wValue</code> of the GET_DESCRIPTOR control request described
     * in section 9.4.3 of the USB 2.0 specification.
     *
     * @param languageID  Descriptor language ID.  <code>wIndex</code> of the GET_DESCRIPTOR control request described in
     * section 9.4.3 of the USB 2.0 specification.
     *
     * @return Pointer to the descriptor if found
     */
    virtual const StandardUSB::StringDescriptor* getStringDescriptor(uint8_t index, uint16_t languageID = StandardUSB::kLanguageIDEnglishUS);
    
    // Public pad slots for descriptors
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 40);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 41);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 42);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 43);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 44);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 45);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 46);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 47);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 48);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 49);
    
protected:
    virtual IOReturn getInterfaceDescriptorGated(const StandardUSB::InterfaceDescriptor*& result);
    
    // Protected pad slots for descriptors
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 50);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 51);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 52);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 53);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 54);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 55);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 56);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 57);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 58);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 59);
    
#pragma mark Alternate setting and pipe management
public:
    /*!
     * @brief Select an alternate setting for this interface
     *
     * @discussion This method is used to select an alternate setting for the interface.  All open pipes will be closed and
     * the new alternate setting will be selected via SET_INTERFACE control request (see section 9.4.10 of the USB 2.0
     * specification).  If the alternate setting was successfully selected, the interface will be re-registered for matching
     *
     * @param bAlternateSetting Alternate interface number to activate
     *
     * @return IOReturn result code
     */
    virtual IOReturn selectAlternateSetting(uint8_t bAlternateSetting);
    
    /*!
     * @brief Return the pipe whose <code>bEndpointAddress</code> matches <code>address</code>
     *
     * @discussion This method will return the pipe whose <code>bEndpointAddress</code> matches <code>address</code>.  If
     * the pipe doesn't exist yet, but is part of the interface, it will first be created.  This method returns a
     * <code>retain()</code>ed object that must be <code>release()</code>ed by the caller.
     *
     * @param address Address of the pipe
     *
     * @return Pointer to a retain()ed IOUSBHostPipe object or NULL
     */
    virtual IOUSBHostPipe* copyPipe(uint8_t address);
    
    /*!
     * @brief Issue an aynchronous setup request on the default control pipe
     *
     * @discussion This method will issue an asynchronous control request on the defaul pipe.
     *
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to the memory to be used for the I/O.
     *
     * @param completion Pointer to a valid, non NULL, IOUSBHostCompletion object.  This will be copied and can therefore be stack-allocated.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(StandardUSB::DeviceRequest& request, void* dataBuffer, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);
    
    /*!
     * @brief Issue an aynchronous setup request on the default control pipe
     *
     * @discussion This method will issue an asynchronous control request on the defaul pipe.
     *
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to an IOMemoryDescriptor for the memory to be used for the I/O.
     *
     * @param completion Pointer to a valid, non NULL, IOUSBHostCompletion object.  This will be copied and can therefore be stack-allocated.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(StandardUSB::DeviceRequest& request, IOMemoryDescriptor* dataBuffer, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);
    
    /*!
     * @brief Issue a synchronous setup request on the default control pipe.
     *
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to the memory to be used for the I/O.
     *
     * @param bytesTransferred Reference which will be updated with the bytes transferred during the request.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(StandardUSB::DeviceRequest& request, void* dataBuffer, uint32_t& bytesTransferred, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);
    
    /*!
     * @brief Issue a synchronous setup request on the default control pipe.
     *
     * <pre>
     * @textblock
     * The following request types are reserved and cannot be made as generic control requests, the appropriate API call should be used instead.
     *
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetAddress  reserved, this request cannot be sent by drivers.
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientDevice), kDeviceRequestSetConfiguration  see setConfiguration().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientInterface), kDeviceRequestSetInterface  see IOUSBHostInterface::selectAlternateSetting().
     *    (kRequestDirectionOut, kRequestTypeStandard, kRequestRecipientEndpoint), kRequestRecipientEndpoint  see IOUSBHostPipe::clearStall().
     *
     * @/textblock
     * </pre>
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to an IOMemoryDescriptor for the memory to be used for the I/O.
     *
     * @param bytesTransferred Reference which will be updated with the bytes transferred during the request.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn deviceRequest(StandardUSB::DeviceRequest& request, IOMemoryDescriptor* dataBuffer, uint32_t& bytesTransferred, uint32_t completionTimeoutMs = kUSBHostDefaultControlCompletionTimeoutMS);
    
    /*!
     * @brief Abort any requests made via the @link deviceRequest @\link methods
     *
     * @discussion This method will abort any requests made via the @link deviceRequest @\link methods.  It will not abort
     * requests made through other interface objects.
     *
     * @param options IOUSBHostIOSource::tAbortOptions
     *
     * @param withError IOReturn error value to return with the requests.
     *
     * @return IOReturn result code
     */
    IOReturn abortDeviceRequests(IOOptionBits options = IOUSBHostIOSource::kAbortAsynchronous, IOReturn withError = kIOReturnAborted);
    
    // Public pad slots for alternate setting and pipe management
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 60);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 61);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 62);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 63);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 64);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 65);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 66);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 67);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 68);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 69);

protected:
    enum
    {
        kInitIORetries       = 3,
        kInitIORetryInterval = 100
    };
    
    virtual void updateMatchingProperties();
    
    virtual IOReturn selectAlternateSettingGated(uint8_t bAlternateSetting);
    
    virtual IOReturn copyPipeGated(uint8_t address, IOUSBHostPipe*& result);

    virtual void closePipes();
    virtual IOReturn closePipesGated();

    // Must be called on the command gate
    virtual void pipeLockLock();
    virtual void pipeLockUnlock();

    // Protected pad slots for alternate setting and pipe management
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 70);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 71);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 72);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 73);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 74);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 75);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 76);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 77);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 78);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 79);
    
protected:
    IOUSBHostPipe*                      _pipeList[kUSBHostMaxPipes];
    
    bool _pipeLock;

    const StandardUSB::ConfigurationDescriptor* _configurationDescriptor;
    const StandardUSB::InterfaceDescriptor*     _interfaceDescriptor;
    IOUSBHostDevice*                            _device;
    
    uint32_t _debugLoggingMask;

#pragma mark Miscellaneous
public:
    /*!
     * @brief Return the parent/provider IOUSBHostDevice object of this interface.
     *
     * @return Pointer to the parent/provider IOUSBHostDevice object.
     */
    virtual IOUSBHostDevice* getDevice() const;
    
    /*!
     * @brief Return the current frame number of the USB bus
     *
     * @description This method will return the current frame number of the USB bus.  This is most useful for
     * scheduling future isochronous requests.
     *
     * @param theTime If not NULL, this will be updated with the current system time
     *
     * @return The current frame number
     */
    virtual uint64_t getFrameNumber(AbsoluteTime* theTime = NULL) const;
    
    /*!
     * @brief Return the current port status
     *
     * @discussion This method will return the current port status as a logical OR of bits described be @link USBDeviceInformationBits @\link
     *
     * @return port status
     */
    virtual uint32_t getPortStatus() const;

    /*!
     * @brief Allocate a buffer to be used for I/O
     *
     * @discussion The underlying host controller hardware may have alignment and fragmentation restrictions.  This
     * method will return a buffer which is guaranteed to meet the restrictions the host controller may have.
     *
     * @param options kIODirectionOut, kIODirectionIn to set the direction of the I/O transfer.
     *
     * @param capacity Size of the buffer to allocate
     *
     * @return Pointer to the newly allocated memory descriptor or NULL
     */
    virtual IOBufferMemoryDescriptor* createIOBuffer(IOOptionBits options, mach_vm_size_t capacity);
    
    // Public pad slots for miscellaneous
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 80);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 81);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 82);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 83);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 84);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 85);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 86);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 87);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 88);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 89);

protected:
    // Protected pad slots for miscellaneous
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 90);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 91);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 92);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 93);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 94);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 95);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 96);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 97);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 98);
    OSMetaClassDeclareReservedUnused(IOUSBHostInterface, 99);

protected:
    struct tExpansionData
    {
    };
    tExpansionData* _expansionData;
    
#pragma mark Deprecated
public:
    
    // virtual const IOUSBInterfaceDescriptor* FindNextAltInterface(const IOUSBInterfaceDescriptor* current,
    //                                                              IOUSBFindInterfaceRequest*      request) __attribute__((deprecated));
    // Replacement: StandardUSB::getNextInterfaceDescriptor

    // virtual IOUSBHostPipe* FindNextPipe(IOUSBHostPipe* current, IOUSBFindEndpointRequest* request) __attribute__((deprecated));
    // virtual IOUSBHostPipe* FindNextPipe(IOUSBHostPipe* current, IOUSBFindEndpointRequest* request, bool withRetain) __attribute__((deprecated));
    // Replacement: getInterfaceDescriptor and StandardUSB::getNextAssociatedDescriptorWithType to find an endpoint descriptor,
    // then use copyPipe to retrieve the pipe object

    // virtual const IOUSBDescriptorHeader* FindNextAssociatedDescriptor(const void* current, UInt8 type) __attribute__((deprecated));
    // Replacement: getInterfaceDescriptor and StandardUSB::getNextAssociatedDescriptorWithType

    // virtual IOReturn SetAlternateInterface(IOService* forClient, UInt16 alternateSetting) __attribute__((deprecated));
    // Replacement: selectAlternateSetting

    // virtual IOUSBHostPipe* GetPipeObj(UInt8 index) __attribute__((deprecated));
    // virtual IOUSBHostPipe* GetPipeObjRetain(UInt8 index) __attribute__((deprecated));
    // Replacement: copyPipe

    // virtual UInt8 GetConfigValue() __attribute__((deprecated));
    // Replacement: getConfigurationDescriptor

    // Deprecated.  Use getProvider
    // virtual IOUSBHostDevice* GetDevice() __attribute__((deprecated));

    // virtual UInt8 GetInterfaceNumber() __attribute__((deprecated));
    // virtual UInt8 GetAlternateSetting() __attribute__((deprecated));
    // virtual UInt8 GetNumEndpoints() __attribute__((deprecated));
    // virtual UInt8 GetInterfaceClass() __attribute__((deprecated));
    // virtual UInt8 GetInterfaceSubClass() __attribute__((deprecated));
    // virtual UInt8 GetInterfaceProtocol() __attribute__((deprecated));
    // virtual UInt8 GetInterfaceStringIndex() __attribute__((deprecated));
    // Replacement: getInterfaceDescriptor

    // virtual IOReturn DeviceRequest(IOUSBDevRequest* request, IOUSBCompletion* completion = 0) __attribute__((deprecated));
    // virtual IOReturn DeviceRequest(IOUSBDevRequestDesc* request, IOUSBCompletion* completion = 0) __attribute__((deprecated));
    // Replacement: deviceRequest

    // virtual IOReturn GetEndpointProperties(UInt8 alternateSetting, UInt8 endpointNumber, UInt8 direction, UInt8* transferType, UInt16* maxPacketSize, UInt8* interval) __attribute__((deprecated));
    // Replacement: StandardUSB::getEndpoint*

    // virtual IOReturn SetIdlePolicy(UInt32 deviceIdleTimeout, UInt32 ioIdleTimeout) __attribute__((deprecated));
    // Replacement: setIdlePolicy and IOUSBHostPope::setIdlePolicy

    // virtual void GetIdlePolicy(UInt32& deviceIdleTimeout, UInt32& ioIdleTimeout) __attribute__((deprecated));
    // Replacement: getIdlePolicy and IOUSBHostPipe::getIdlePolicy

    // IOBufferMemoryDescriptor* CreateIOBuffer(IOOptionBits options, mach_vm_size_t capacity) __attribute__((deprecated));
    // Replacement: createIOBuffer
};

#endif // IOUSBHostFamily_IOUSBHostInterface_h
                                                                                                                                                                                                                                                         IOUSBHostPipe.h                                                                                     0100644 0001750 0001750 00000107534 12567452451 035337  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.2 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

/*!
 * @header IOUSBHostPipe.h
 *
 * @brief Provides IOUSBHostPipe API
 */
#ifndef IOUSBHostFamily_IOUSBHostPipe_h
#define IOUSBHostFamily_IOUSBHostPipe_h

#include <IOKit/IOService.h>
#include <IOKit/IOMemoryDescriptor.h>

#include <IOKit/usb/StandardUSB.h>
#include <IOKit/usb/IOUSBHostFamily.h>
#include <IOKit/usb/IOUSBHostIOSource.h>
#include <IOKit/usb/IOUSBHostStream.h>

class IOUSBHostInterface;
class AppleUSBHostController;

/*!
 * @class IOUSBHostPipe
 *
 * @brief IOUSBHostPipe object
 *
 * @discussion Provides the API for controlling pipe policy and performing I/O.
 */
class IOUSBHostPipe : public IOUSBHostIOSource
{
    friend class IOUSBHostInterface;
    friend class IOUSBHostDevice;
    friend class AppleUSBHostController;
    friend class AppleUSBIORequest;

    OSDeclareDefaultStructors(IOUSBHostPipe)

public:
    static IOUSBHostPipe* withDescriptorsAndOwners(const StandardUSB::EndpointDescriptor* descriptor, const StandardUSB::SuperSpeedEndpointCompanionDescriptor* companionDescriptor,
                                                   AppleUSBHostController* controller, IOUSBHostDevice* device, IOUSBHostInterface* interface, UInt8 speed, tUSBHostDeviceAddress address);

protected:
    virtual bool initWithDescriptorsAndOwners(const StandardUSB::EndpointDescriptor* descriptor, const StandardUSB::SuperSpeedEndpointCompanionDescriptor* companionDescriptor,
                                              AppleUSBHostController* controller, IOUSBHostDevice* device, IOUSBHostInterface* interface, UInt8 speed, tUSBHostDeviceAddress address);
    
#pragma mark IOUSBHostIOSource overrides
public:
    virtual void free();
    
    /*!
     * @brief Abort pending I/O requests.
     *
     * @discussion See IOUSBHostIOSource::abort for documentation
     */
    virtual IOReturn abort(IOOptionBits options = kAbortAsynchronous, IOReturn withError = kIOReturnAborted, IOService* forClient = NULL);
    
protected:
    virtual IOReturn closeGated();
    
    virtual IOReturn abortGated(IOOptionBits options, IOReturn withError, IOService* forClient);

    // Protected pad slots for IOUSBHostIOSource overrides
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 0);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 1);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 2);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 3);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 4);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 5);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 6);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 7);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 8);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 9);
    
protected:
    UInt8               _speed;
    IOUSBHostInterface* _interface;

#pragma mark Descriptors and policies
public:
    /*!
     * @methodgroup Descriptors and Policies
     */
    
    /*!
     * @brief Options for <code>getEndpointDescriptor()</code> and <code>getSuperSpeedEndpointCompanionDescriptor()</code>
     *
     * @discussion
     * @constant kGetEndpointDescriptorOriginal - Original descriptor as returned as part of the configuration descriptor.
     * @constant kGetEndpointDescriptorCurrentPolicy - Descriptor controlling the current endpoint policy.  This may differ from
     * kGetEndpointDescriptorOriginal if <code>adjustPipe()</code> has been called.
     */
    enum tGetEndpointDescriptorOptions
    {
        kGetEndpointDescriptorOriginal = 0,
        kGetEndpointDescriptorCurrentPolicy
    };
    
    /*!
     * @brief This method will return an endpoint descriptor associated with the pipe.
     *
     * @param type The desired endpoint descriptor type to return.  See @link //apple_ref/cpp/tag/IOUSBHostPipe/tGetEndpointDescriptorOptions
     * IOUSBHostPipe::tGetEndpointDescriptorOptions @/link for more details.
     *
     * @return If successful a pointer to the endpoint descriptor is returned.  Otherwise, NULL is returned.
     */
    virtual const StandardUSB::EndpointDescriptor* getEndpointDescriptor(tGetEndpointDescriptorOptions type = kGetEndpointDescriptorCurrentPolicy);
    
    /*!
     * @brief This method will return the Super-Speed endpoint companion descriptor associated with the pipe.
     *
     * @param type The desired endpoint descriptor type to return. See @link //apple_ref/cpp/tag/IOUSBHostPipe/tGetEndpointDescriptorOptions
     * IOUSBHostPipe::tGetEndpointDescriptorOptions @/link for more details.
     *
     * @return If successful a pointer to the companion descriptor is returned.  Otherwise, NULL is returned.
     */
    virtual const StandardUSB::SuperSpeedEndpointCompanionDescriptor* getSuperSpeedEndpointCompanionDescriptor(tGetEndpointDescriptorOptions type = kGetEndpointDescriptorCurrentPolicy);
    
    /*!
     * @brief This method is used to change the amount of bandwidth currently allocated to the pipe.
     *
     * @discussion This method is only valid for interrupt and isochronous endpoints.  There is only a finite amount of
     * bandwith available for interrupt and isochronous endpoints on the USB bus TODO
     *
     * @param endpointDescriptor Pointer to an endpoint descriptor describing the bandwidth request
     *
     * @param companionDescriptor Pointer to a companion descriptor describing the bandwidth request
     *
     * @return IOReturn result code
     */
    virtual IOReturn adjustPipe(const StandardUSB::EndpointDescriptor* endpointDescriptor, const StandardUSB::SuperSpeedEndpointCompanionDescriptor* companionDescriptor);
    
    /*!
     * @brief Set the idle policy of the pipe
     *
     * @discussion TODO Detailed discussion about idling.  This method is only valid for interrupt and bulk endpoints.
     *
     * @param idleTimeoutMs The time, in milliseconds, after which if no I/O has completed the IOUSBHostPipe is consider idle.
     *
     * @return IOReturn result code
     */
    virtual IOReturn setIdlePolicy(uint32_t idleTimeoutMs);
    
    /*!
     * @brief Get the idle policy of the pipe
     *
     * @discussion This method is only valid for interrupt and bulk endpoints.
     *
     * @return The current idle timeout in milliseconds
     */
    virtual uint32_t getIdlePolicy();
    
    /*!
     * @brief Clear the halt condition of the pipe.
     *
     * @discussion  This method will abort all pending I/O, clear the halted condition, and reset the data toggle for the pipe.
     * In general, this must be done after a non-control I/O call returns or completes with an error condition.  This method
     * will also clear the transaction translator if this is a 'split' pipe as described in section 11.17.5 of the 
     * USB 2.0 specification.
     *
     * @param withRequest If true the USB device request: CLEAR_FEATURE::ENDPOINT_HALT for this endnpoint request will be
     * issued on the default pipe.  See section 9.4.1 of the USB 2.0 specification for more details.
     *
     * @return IOReturn result code
     */
    virtual IOReturn clearStall(bool withRequest);
    
    // Public pad slots for descriptors and policies
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 10);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 11);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 12);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 13);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 14);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 15);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 16);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 17);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 18);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 19);
    
protected:
    virtual IOReturn adjustPipeGated(const StandardUSB::EndpointDescriptor* endpointDescriptor, const StandardUSB::SuperSpeedEndpointCompanionDescriptor* companionDescriptor);
    
    virtual IOReturn setIdlePolicyGated(uint32_t idleTimeoutMs);
    virtual IOReturn getIdlePolicyGated(uint32_t& result);
    
    virtual IOReturn clearStallGated(bool withRequest);

    // Protected pad slots for descriptors and policies
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 20);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 21);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 22);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 23);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 24);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 25);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 26);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 27);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 28);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 29);
    
protected:
    const StandardUSB::EndpointDescriptor*                    _descriptor;
    const StandardUSB::SuperSpeedEndpointCompanionDescriptor* _companionDescriptor;

    StandardUSB::EndpointDescriptor                    _currentPolicyDescriptor;
    StandardUSB::SuperSpeedEndpointCompanionDescriptor _currentPolicyCompanionDescriptor;

    // Cached values
    UInt32 _maxPacketSize;
    UInt32 _burstSize;

    UInt32 _ioIdleTimeout;

#pragma mark Control requests
public:
    /*!
     * @methodgroup Control Requests
     */
    
    /*!
     * @brief Issue an asynchronous control request on the pipe.
     *
     * @discussion This method will issue an asynchronous control request on the pipe.  A trivial example is provided below:
     *
     * <pre>
     * @textblock
     * uint8_t                    dataBuffer[4];
     * IOReturn                   result;
     * StandardUSB::DeviceRequest request;
     * IOUSBHostCompletion        completion;
     *
     * request.bmRequestType = makeDeviceRequestbmRequestType(kRequestDirectionIn, kRequestTypeClass, kRequestRecipientInterface);
     * request.bRequest      = 0x12;
     * request.wValue        = 0x3456;
     * request.wIndex        = 0x7890;
     * request.wLength       = sizeof(uint32_t);
     *
     * completion.owner     = this;
     * completion.action    = OSMemberFunctionCast(IOUSBHostCompletionAction, this, &MyDriver::controlRequestComplete);
     * completion.parameter = NULL;
     *
     * result = _controlPipe->controlRequest(this, request, &dataBuffer, &completion, 1000);<br>
     *
     * ...
     *
     * void MyDriver::controlRequestComplete(void* parameter, IOReturn status, uint32_t bytesTransferred)
     * {
     *     if(status == kIOReturnSuccess)
     *     {
     *         IOLog("received %u bytes\n", bytesTransferred);
     *     }
     *
     * @/textblock
     * </pre>
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to the memory to be used for the I/O.
     *
     * @param completion Pointer to a valid, non NULL, IOUSBHostCompletion object.  This will be copied and can therefore be stack-allocated.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn controlRequest(IOService* forClient, StandardUSB::DeviceRequest& request, void* dataBuffer, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs);
    
    /*!
     * @brief Issue an asynchronous control request on the pipe.
     *
     * @discussion This method will issue an asynchronous control request on the pipe.  This method differs from
     * @link //apple_ref/cpp/instm/IOUSBHostPipe/controlRequest/IOReturn/(IOService*,StandardUSB::DeviceRequest%26,void*,IOUSBHostCompletion*,uint32_t) @/link
     * in that it takes an IOMemoryDescriptor instead of a void * for <code>dataBuffer</code>.
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to an IOMemoryDescriptor for the memory to be used for the I/O.
     *
     * @param completion Pointer to a valid, non NULL, IOUSBHostCompletion object.  This will be copied and can therefore be stack-allocated.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn controlRequest(IOService* forClient, StandardUSB::DeviceRequest& request, IOMemoryDescriptor* dataBuffer, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs);
    
    /*!
     * @brief Issue a synchronous control request on the pipe.
     *
     * @discussion This method will issue a synchronous control request on the pipe. A trivial example is provided below:
     *
     * <pre>
     * @textblock
     * uint8_t                    dataBuffer[4];
     * uint32_t                   bytesTransferred;
     * IOReturn                   result;
     * StandardUSB::DeviceRequest request;
     *
     * request.bmRequestType = makeDeviceRequestbmRequestType(kRequestDirectionIn, kRequestTypeClass, kRequestRecipientInterface);
     * request.bRequest      = 0x12;
     * request.wValue        = 0x3456;
     * request.wIndex        = 0x7890;
     * request.wLength       = sizeof(uint32_t);
     *
     * result = _controlPipe->controlRequest(this, request, &dataBuffer, bytesTransferred, 1000);
     * if(result == kIOReturnSuccess)
     * {
     *     IOLog("received %u bytes\n", bytesTransferred);
     * }
     * @/textblock
     * </pre>
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to the memory to be used for the I/O.
     *
     * @param bytesTransferred Reference which will be updated with the bytes transferred during the request.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn controlRequest(IOService* forClient, StandardUSB::DeviceRequest& request, void* dataBuffer, uint32_t& bytesTransferred, uint32_t completionTimeoutMs);
    
    /*!
     * @brief Issue a synchronous control request on the pipe.
     *
     * @discussion This method will issue a synchronous control request on the pipe.  This method differs from
     * @link //apple_ref/cpp/instm/IOUSBHostPipe/controlRequest/IOReturn/(IOService*,StandardUSB::DeviceRequest%26,void*,uint32_t%26,uint32_t) @/link
     * in that it takes an IOMemoryDescriptor instead of a void * for <code>dataBuffer</code>.
     *
     * @param forClient The object issuing the request (generally the <code>this</code> pointer).
     *
     * @param request Reference to a valid StandardUSB::DeviceRequest object.  This will be copied and can therefore be stack-allocated.
     *
     * @param dataBuffer Pointer to an IOMemoryDescriptor for the memory to be used for the I/O.
     *
     * @param bytesTransferred Reference which will be updated with the bytes transferred during the request.
     *
     * @param completionTimeoutMs Time-out of the request in milliseconds.  If 0, the request will never time-out.
     *
     * @return IOReturn result code
     */
    virtual IOReturn controlRequest(IOService* forClient, StandardUSB::DeviceRequest& request, IOMemoryDescriptor* dataBuffer, uint32_t& bytesTransferred, uint32_t completionTimeoutMs);

    // Public pad slots for control requests
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 30);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 31);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 32);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 33);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 34);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 35);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 36);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 37);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 38);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 39);

protected:
    struct tInternalControlRequestParameters
    {
        IOService*                  forClient;
        StandardUSB::DeviceRequest* request;
        void*                       rawBuffer;
        IOMemoryDescriptor*         descriptorBuffer;
        uint32_t*                   bytesTransferred;
        IOUSBHostCompletion*        completion;
        uint32_t                    completionTimeoutMs;
    };
    virtual IOReturn controlRequestGated(tInternalControlRequestParameters& parameters);

    static void rawBufferControlRequestCompletion(void* target, void* parameter, IOReturn status, uint32_t bytesTransferred);

    // Protected pad slots for control requests
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 40);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 41);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 42);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 43);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 44);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 45);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 46);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 47);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 48);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 49);

#pragma mark IO
public:
    /*!
     * @methodgroup I/O
     *
     * @discussion All I/O calls will synchronize with the workloop.  Furthermore, all completion callbacks will also
     * synchronize with the workloop.  Therefore, when using the asynchronous I/O methods it is most performant to make
     * subsequent calls from completion callback as the workloop lock will already be owned.
     */
    
    /*!
     * @brief Issue an asynchronous I/O request
     *
     * @discussion See IOUSBHostIOSource::io for documentation

     * @param completionTimeoutMs Must be 0 for interrupt endpoints.
     */
    virtual IOReturn io(IOMemoryDescriptor* dataBuffer, uint32_t dataBufferLength, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs = 0);
    
    /*!
     * @brief Issue a synchronous I/O request
     *
     * @discussion See IOUSBHostIOSource::io for documentation
     *
     * @param completionTimeoutMs Must be 0 for interrupt endpoints.
     */
    virtual IOReturn io(IOMemoryDescriptor* dataBuffer, uint32_t dataBufferLength, uint32_t& bytesTransferred, uint32_t completionTimeoutMs = 0);
    
    /*!
     * @brief Issue an I/O request to an isochronous pipe.
     *
     * @discussion This method is used to issue isochronout I/O requests.  To ensure minimal latency the
     * IOUSBHostIsochronousFrame::status and IOUSBHostIsochronousFrame::completeCount fields of <code>frameList</code> are
     * updated at interrupt time.  In the case of an asynchronous call, this allows software to peek at the frame list and
     * detect completed frames prior to receiving the completion callback.
     *
     * @param dataBuffer Pointer to a valid memory descriptor to be used as the backing store for the I/O.
     *
     * @param frameList Pointer to the frame list describing the request.  See <link>IOUSBHostIsochronousFrame</link> for
     * information regarding structure initialization requirements and usage.
     *
     * @param frameListCount Number of elements in <code>frameList</code>.
     *
     * @param firstFrameNumber Frame number which this request should begin on.  The current frame number can be queried via
     * <code>IOUSHostDevice::getFrameNumber()</code> or <code>IOUSBHostInterface::getFrameNumber()</code> .  If 0, the request
     * will be enqueued on the next available frame.
     *
     * @param completion To create a synchronous I/O request, this parameter must be NULL.  For an asynchronous request this
     * paramater must be properly filled out prior to calling this method.  If not NULL, this parameter will be copied and
     * can therefore be stack-allocated.
     *
     * @return IOReturn result code
     */
    virtual IOReturn io(IOMemoryDescriptor* dataBuffer, IOUSBHostIsochronousFrame* frameList, uint32_t frameListCount, uint64_t firstFrameNumber = 0, IOUSBHostIsochronousCompletion* completion = NULL);
    
    // Public pad slots for IO
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 50);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 51);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 52);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 53);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 54);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 55);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 56);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 57);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 58);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 59);

protected:
    virtual IOReturn isochronousIoGated(tInternalDataTransferParameters& parameters);
    
    // Protected pad slots for IO
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 60);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 61);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 62);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 63);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 64);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 65);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 66);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 67);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 68);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 69);
    
#pragma mark Streams
public:
    /*!
     * @methodgroup Streams
     */
    
    /*!
     * @brief Enable streams for the IOUSBHostPipe
     * 
     * @discussion This method changes the operational mode of the IOUSBHostPipe to allow streaming endpoint
     * transfers, and must be called before copyStream will return any IOUSBHostStream objects.
     *
     * @return IOReturn result code.  An error will be returned if the pipe, device, or underlying host
     * controller does not support streams.
     */
    virtual IOReturn enableStreams();
    
    /*!
     * @brief Disable streams for the IOUSBHostPipe
     *
     * @discussion This method changes the operational mode of the IOUSBHostPipe to disable streaming endpoint
     * transfers.  Calling this method will synchronously abort any outstanding calls on existing IOUSBHostStream
     * objects, and therefore all stream contexts should first be set as non-active on the device via an out-of-band
     * (class-defined) mechanism.
     *
     * @return IOReturn result code.  An error will be returned if streams were not enabled for this IOUSBHostPipe.
     */
    virtual IOReturn disableStreams();
    
    /*!
     * @brief Return the stream associated with <code>streamID</code>
     *
     * @discussion This method will return the stream associated with <code>streamID</code>.  If the stream
     * doesn't exist yet it will be created.  This method returns a <code>retain()</code>ed object that must
     * be <code>release()</code>ed by the caller.  <code>IOUSBHostPipe::enableStreams</code> must be called before
     * this method will return a stream object.
     *
     * @param streamID Stream ID in the range of 1 to <code>max</code>, where <code>max</code> can be retrieved
     * by calling <code>StandardUSB::getEndpointMaxStreams</code> with the endpoint descriptors.
     *
     * @return Pointer to a retain()ed IOUSBHostStream object or NULL.  NULL may be returned if either the device
     * or the underlying host controller do not support that stream ID.
     */
    virtual IOUSBHostStream* copyStream(uint32_t streamID);
    
    // Public pad slots for streams
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 70);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 71);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 72);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 73);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 74);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 75);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 76);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 77);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 78);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 79);

protected:
    virtual IOReturn enableStreamsGated();
    
    virtual IOReturn disableStreamsGated();
    
    virtual IOReturn copyStreamGated(uint32_t streamID, IOUSBHostStream*& result);

    // Protected pad slots for streams
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 80);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 81);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 82);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 83);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 84);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 85);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 86);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 87);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 88);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 89);

protected:
    IOUSBHostStream** _streamArray;
    bool              _streamsEnabled;
    
#pragma mark Miscellaneous
public:
    virtual uint8_t getSpeed() const;
    
    virtual tUSBHostDeviceAddress getDeviceAddress() const;
    
    // Public pad slots for miscellaneous
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 90);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 91);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 92);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 93);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 94);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 95);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 96);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 97);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 98);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 99);
    
protected:
    struct tRawBufferControlRequestCompletionParameter
    {
        IOMemoryDescriptor* memoryDescriptor;
        IOUSBHostCompletion clientCompletion;
    };
        
    // Protected pad slots for miscellaneous
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 100);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 101);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 102);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 103);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 104);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 105);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 106);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 107);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 108);
    OSMetaClassDeclareReservedUnused(IOUSBHostPipe, 109);

#pragma mark Deprecated
public:
    enum tPipeAbortOptions
    {
        kIOUSBPipeAbortAsync = 0,
        kIOUSBPipeAbortSync  = 1
    };

    enum tUSBPipeState
    {
        kUSBPipeStateReady,
        kUSBPipeStateRunningCompletions,
        kUSBPipeStateAborting,
        kUSBPipeStateInactive
    };
    
    // IOUSBHostPipe::tUSBPipeState GetPipeState() __attribute__((deprecated));
    // Replacement: getState

    // virtual IOReturn Abort(IOOptionBits options = kIOUSBPipeAbortAsync, IOReturn withError = kIOReturnAborted) __attribute__((deprecated));
    // Replacement: abort

    // virtual IOReturn Reset(void) __attribute__((deprecated));
    // virtual IOReturn ClearStall(void) __attribute__((deprecated));
    // Replacement: clearStall(false)

    // virtual IOReturn ClearPipeStall(bool withDeviceRequest = false) __attribute__((deprecated));
    // Replacement: clearStall

    // virtual IOReturn Read(IOMemoryDescriptor* buffer,
    //                       IOUSBCompletion*    completion = 0,
    //                       UInt32*             bytesRead = 0) __attribute__((deprecated));
    // virtual IOReturn Read(IOMemoryDescriptor* buffer,
    //                       UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame* frameList,
    //                       IOUSBIsocCompletion* completion = 0) __attribute__((deprecated));
    // virtual IOReturn Read(IOMemoryDescriptor* buffer,
    //                       UInt32              noDataTimeout,
    //                       UInt32              completionTimeout,
    //                       IOUSBCompletion*    completion = 0,
    //                       UInt32*             bytesRead = 0) __attribute__((deprecated));
    // virtual IOReturn Read(IOMemoryDescriptor* buffer,
    //                       UInt64 frameStart, UInt32 numFrames, IOUSBLowLatencyIsocFrame* frameList,
    //                       IOUSBLowLatencyIsocCompletion*       completion = 0, UInt32 updateFrequency = 0) __attribute__((deprecated));
    // virtual IOReturn Read(IOMemoryDescriptor* buffer,
    //                       UInt32              noDataTimeout,
    //                       UInt32              completionTimeout,
    //                       IOByteCount         reqCount,
    //                       IOUSBCompletion*    completion = 0,
    //                       UInt32*             bytesRead = 0) __attribute__((deprecated));
    // virtual IOReturn Read(IOMemoryDescriptor*           buffer,
    //                       UInt32                        noDataTimeout,
    //                       UInt32                        completionTimeout,
    //                       IOByteCount                   reqCount,
    //                       IOUSBCompletionWithTimeStamp* completion = 0,
    //                       UInt32*                       bytesRead = 0) __attribute__((deprecated));
    // virtual IOReturn Write(IOMemoryDescriptor* buffer,
    //                        IOUSBCompletion*    completion = 0) __attribute__((deprecated));
    // virtual IOReturn Write(IOMemoryDescriptor* buffer,
    //                        UInt64 frameStart, UInt32 numFrames, IOUSBIsocFrame* frameList,
    //                        IOUSBIsocCompletion* completion = 0) __attribute__((deprecated));
    // virtual IOReturn Write(IOMemoryDescriptor* buffer,
    //                        UInt32              noDataTimeout,
    //                        UInt32              completionTimeout,
    //                        IOUSBCompletion*    completion = 0) __attribute__((deprecated));
    // virtual IOReturn Write(IOMemoryDescriptor* buffer,
    //                        UInt32              noDataTimeout,
    //                        UInt32              completionTimeout,
    //                        IOByteCount         reqCount,
    //                        IOUSBCompletion*    completion = 0) __attribute__((deprecated));
    // virtual IOReturn Write(IOMemoryDescriptor* buffer,
    //                        UInt64 frameStart, UInt32 numFrames, IOUSBLowLatencyIsocFrame* frameList,
    //                        IOUSBLowLatencyIsocCompletion* completion = 0, UInt32 updateFrequency = 0) __attribute__((deprecated));
    // Replacement: io

    // virtual IOReturn ControlRequest(IOUSBDevRequestDesc* request, IOUSBCompletion* completion = NULL,
    //                                 UInt32 noDataTimeout = kUSBHostDefaultControlNoDataTimeoutMS, UInt32 completionTimeout = kUSBHostDefaultControlCompletionTimeoutMS) __attribute__((deprecated));
    // virtual IOReturn ControlRequest(IOUSBDevRequest* request, IOUSBCompletion* completion = NULL) __attribute__((deprecated));
    // virtual IOReturn ControlRequest(IOUSBDevRequestDesc* request, UInt32 noDataTimeout, UInt32 completionTimeout, IOUSBCompletion* completion = 0) __attribute__((deprecated));
    // virtual IOReturn ControlRequest(IOUSBDevRequest* request, UInt32 noDataTimeout, UInt32 completionTimeout, IOUSBCompletion* completion = 0) __attribute__((deprecated));
    // Replacement: controlRequest

    // virtual const AppleUSBHostController::Endpoint* GetEndpoint() __attribute__((deprecated));
    // virtual const StandardUSB::EndpointDescriptor* GetEndpointDescriptor(tGetEndpointDescriptorOptions type = kGetEndpointDescriptorOriginal) __attribute__((deprecated));
    // virtual const StandardUSB::SuperSpeedEndpointCompanionDescriptor* GetEndpointCompanionDescriptor(tGetEndpointDescriptorOptions type = kGetEndpointDescriptorOriginal) __attribute__((deprecated));
    // virtual UInt8 GetDirection() __attribute__((deprecated));
    // virtual UInt8 GetType() __attribute__((deprecated));
    // virtual UInt8            GetEndpointNumber() __attribute__((deprecated));
    // virtual UInt16           GetMaxPacketSize() __attribute__((deprecated));
    // virtual UInt16           GetBurstSize() __attribute__((deprecated));
    // virtual UInt8            GetInterval() __attribute__((deprecated));
    // Replacement: getEndpointDescriptor and getEndpointCompanionDescriptor

    // virtual tUSBHostDeviceAddress GetAddress() __attribute__((deprecated));
    // Replacement: getDeviceAddress
    
    // virtual UInt8            GetSpeed() __attribute__((deprecated));
    // Replacement: getSpeed
    
    // virtual IOReturn GetPipeStatus(void) __attribute__((deprecated));
    // Replacement: none

    // virtual IOReturn SetPipePolicy(UInt16 maxPacketSize, UInt8 maxInterval) __attribute__((deprecated));
    // Replacement: adjustPipe

    // virtual void OverrideIdlePolicy(bool override, UInt32 ioIdleTimeout = 0) __attribute__((deprecated));
    // Replacement: setIdlePolicy

    // virtual void GetIdlePolicy(UInt32& ioIdleTimeout) __attribute__((deprecated));
    // Replacement: setIdlePolicy

    // virtual IOReturn Read(UInt32              streamID,
    //                       IOMemoryDescriptor* buffer,
    //                       UInt32              noDataTimeout,
    //                       UInt32              completionTimeout,
    //                       IOByteCount         reqCount,
    //                       IOUSBCompletion*    completion = 0,
    //                       IOByteCount*        bytesRead = 0) __attribute__((deprecated));
    // virtual IOReturn Write(UInt32              streamID,
    //                        IOMemoryDescriptor* buffer,
    //                        UInt32              noDataTimeout,
    //                        UInt32              completionTimeout,
    //                        IOByteCount         reqCount,
    //                        IOUSBCompletion*    completion = 0) __attribute__((deprecated));
    // virtual IOReturn Abort(UInt32 streamID, IOOptionBits options, IOReturn withError) __attribute__((deprecated));
    // virtual UInt32 GetConfiguredStreams(void) __attribute__((deprecated));
    // Replacement: copyStream and IOUSBHostStream interfaces

    // virtual UInt32 SupportsStreams(void) __attribute__((deprecated));
    // Replacement: StandardUSB::getEndpointMaxStreams

    // virtual IOReturn CreateStreams(UInt32 maxStreams) __attribute__((deprecated));
    // Replacement: enableStreams
    
    // virtual const StandardUSB::SuperSpeedEndpointCompanionDescriptor* GetSuperSpeedEndpointCompanionDescriptor(tGetEndpointDescriptorOptions type = kGetEndpointDescriptorOriginal) __attribute__((deprecated));
    // Replacement: getSuperSpeedEndpointCompanionDescriptor

    // virtual UInt8 GetMaxBurst() __attribute__((deprecated));
    // virtual UInt8 GetMult() __attribute__((deprecated));
    // virtual UInt16 GetBytesPerInterval() __attribute__((deprecated));
    // Replacement: StandardUSB::getEndpoint*
};

#endif // IOUSBHostFamily_IOUSBHostPipe_h
                                                                                                                                                                    IOUSBHostStream.h                                                                                   0100644 0001750 0001750 00000006775 12567452451 035702  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            //
//  IOUSBHostStream.h
//  IOUSBHostFamily
//
//  Created by Dan Wilson on 2/13/14.
//
//

#ifndef IOUSBHostFamily_IOUSBHostStream_h
#define IOUSBHostFamily_IOUSBHostStream_h

#include <IOKit/usb/IOUSBHostFamily.h>
#include <IOKit/usb/IOUSBHostIOSource.h>

class IOUSBHostPipe;

class IOUSBHostStream : public IOUSBHostIOSource
{
    OSDeclareDefaultStructors(IOUSBHostStream)

    friend class IOUSBHostPipe;

public:
    IOUSBHostStream* withOwnersAndStreamID(AppleUSBHostController* controller, IOUSBHostDevice* device, IOUSBHostPipe* pipe, uint32_t streamID);

    virtual void free();
    
    /*!
     * @brief Abort pending I/O requests
     *
     * @discussion See IOUSBHostIOSource::abort for documentation
     * 
     * A stream context must be set as non-active on the device via an out-of-band (class-defined) mechanism before this method is called.
     * A non-active stream will not be selected by the device to become the current stream on the endpoint.
     */
    virtual IOReturn abort(IOOptionBits options = kAbortAsynchronous, IOReturn withError = kIOReturnAborted, IOService* forClient = NULL);

    virtual IOUSBHostPipe* getPipe() const { return _pipe; }

    virtual uint32_t getStreamID() const { return _streamID; }
    
    /*!
     * @brief Issue an asynchronous I/O request
     *
     * @discussion See IOUSBHostIOSource::io for documentation
     *
     * @param completionTimeoutMs Must be 0 for streams
     */
    virtual IOReturn io(IOMemoryDescriptor* dataBuffer, uint32_t dataBufferLength, IOUSBHostCompletion* completion, uint32_t completionTimeoutMs = 0);
    
    /*!
     * @brief Issue a synchronous I/O request
     *
     * @discussion See IOUSBHostIOSource::io for documentation
     *
     * @param completionTimeoutMs Must be 0 for streams
     */
    virtual IOReturn io(IOMemoryDescriptor* dataBuffer, uint32_t dataBufferLength, uint32_t& bytesTransferred, uint32_t completionTimeoutMs = 0);

    // Public pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 0);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 1);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 2);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 3);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 4);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 5);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 6);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 7);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 8);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 9);

protected:
    virtual bool initWithOwnersAndStreamID(AppleUSBHostController* controller, IOUSBHostDevice* device, IOUSBHostPipe* pipe, uint32_t streamID);

    virtual IOReturn closeGated();

    virtual IOReturn abortGated(IOOptionBits options, IOReturn withError, IOService* forClient);

    // Protected pad slots for future expansion
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 10);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 11);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 12);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 13);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 14);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 15);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 16);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 17);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 18);
    OSMetaClassDeclareReservedUnused(IOUSBHostStream, 19);

protected:
    IOUSBHostPipe* _pipe;
    uint32_t       _streamID;
};

#endif
   IOUSBLog.h                                                                                          0100644 0001750 0001750 00000025635 12567452726 034333  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright  1998-2014 Apple Inc.  All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOUSBLOG_H
#define _IOKIT_IOUSBLOG_H

#ifndef __IOUSBFAMILY__
#warning "Deprecated header file.  See IOUSBHostFamily for USB-Host KPI."
#endif

#ifdef KERNEL
    #include 	<IOKit/IOService.h>
    #include	<IOKit/IOLib.h>
    #include    <AssertMacros.h>


    // Other helpful macros (maybe some day these will make
    // their way into /usr/include/AssertMacros.h)
    #ifndef require_success
        #define require_success( errorCode, exceptionLabel ) \
        require( kIOReturnSuccess == (errorCode), exceptionLabel )
    #endif

    #ifndef require_success_action
        #define require_success_action( errorCode, exceptionLabel, action ) \
        require_action( kIOReturnSuccess == (errorCode), exceptionLabel, action )
    #endif

    #ifndef require_success_quiet
        #define require_success_quiet( errorCode, exceptionLabel ) \
        require_quiet( kIOReturnSuccess == (errorCode), exceptionLabel )
    #endif

    #ifndef require_success_action_quiet
        #define require_success_action_quiet( errorCode, exceptionLabel, action ) \
        require_action_quiet( kIOReturnSuccess == (errorCode), exceptionLabel, action )
    #endif

    #ifndef require_success_string
        #define require_success_string( errorCode, exceptionLabel, message ) \
        require_string( kIOReturnSuccess == (errorCode), exceptionLabel, message )
    #endif

    #ifndef require_success_action_string
        #define require_success_action_string( errorCode, exceptionLabel, action, message ) \
        require_action_string( kIOReturnSuccess == (errorCode), exceptionLabel, action, message )
    #endif

    #ifndef require_nonzero
        #define require_nonzero( obj, exceptionLabel ) \
        require( ( 0 != obj ), exceptionLabel )
    #endif

    #ifndef require_nonzero_action
        #define require_nonzero_action( obj, exceptionLabel, action ) \
        require_action( ( 0 != obj ), exceptionLabel, action )
    #endif

    #ifdef require_nonzero_quiet
        #define require_nonzero_quiet( obj, exceptionLabel ) \
        require_quiet( ( 0 != obj ), exceptionLabel )
    #endif

    #ifdef require_nonzero_action_quiet
        #define require_nonzero_action_quiet( obj, exceptionLabel, action ) \
        require_action_quiet( ( 0 != obj ), exceptionLabel, action )
    #endif

    #ifndef require_nonzero_string
        #define require_nonzero_string( obj, exceptionLabel, message ) \
        require_string( ( 0 != obj ), exceptionLabel, message )
    #endif

    #ifdef require_nonzero_action_string
        #define require_nonzero_action_string( obj, exceptionLabel, action, message ) \
        require_action_string( ( 0 != obj ), exceptionLabel, action, message )
    #endif

#endif

#ifdef	__cplusplus
	extern "C" {
#endif

// USB Specific defines
#define USBLog( LEVEL, ARGS...)		KernelDebugLogTag( LEVEL, 'USBF', ## ARGS )
#define USBError( LEVEL, ARGS...)	KernelDebugLogInternal( ( LEVEL ), 'USBF', ## ARGS )
#define USBStringFromReturn( IORETURN)	(IOUSBController::_log)->stringFromReturn( IORETURN )


// Possible Debug levels. If DEBUG_LEVEL is set to DEBUG_LEVEL_PRODUCTION, all debug logs will be 
// stripped of the final code. 

#define	DEBUG_LEVEL_PRODUCTION		0
#define	DEBUG_LEVEL_DEVELOPMENT		1
#define	DEBUG_LEVEL_ALPHA			2
#define	DEBUG_LEVEL_BETA			3
#define	DEBUG_LEVEL_FINAL			DEBUG_LEVEL_PRODUCTION

// Allow clients to define their own debug level.

#if ( !defined( DEBUG_LEVEL ) )
	#define	DEBUG_LEVEL			DEBUG_LEVEL_FINAL
#endif

// Index for user client methods
//
enum
{
    kUSBControllerUserClientOpen = 0,
    kUSBControllerUserClientClose,
    kUSBControllerUserClientEnableLogger,
    kUSBControllerUserClientSetDebuggingLevel,
    kUSBControllerUserClientSetDebuggingType,
    kUSBControllerUserClientGetDebuggingLevel,
    kUSBControllerUserClientGetDebuggingType,
#ifndef __OPEN_SOURCE__
    kUSBControllerUserClientSetTestMode,
    kUSBControllerUserClientReadRegister,
    kUSBControllerUserClientWriteRegister,
    kUSBControllerUserClientMessageController,
#endif
    kNumUSBControllerMethods
};

#ifndef __OPEN_SOURCE__
// Enums for the private kIOUSBMessageController message
enum
{
	kIOUSBMessageControllerDoGPIOReset = 0x00000001,
	kIOUSBMessageControllerDoPrintACPI = 0x00000002,
	
	kIOUSBMessageControllerDumpQueues						= 0x00000003,
	kIOUSBMessageControllerDumpQueuesMask					= 0x0000FFFF,			// for this message, we use the top 16 bits for options
	kIOUSBMessageControllerDumpQueuesOptionsMask			= 0xFFFF0000,
	kIOUSBMessageControllerDumpQueuesPrintSkippedOptionMask = (1 << 16),
	kIOUSBMessageControllerDumpQueuesPrintTDsMask			= (1 << 17),
	kIOUSBMessageControllerDumpQueuesPrintDoneQueue			= (1 << 18)				// For OHCI
	
};
#endif

// Info Debug Output Types.

typedef UInt32		KernelDebuggingOutputType;
enum
{
	kKernelDebugOutputIOLogType		= 0x00000001, 
	kKernelDebugOutputKextLoggerType	= 0x00000002
};


// Info Debug levels.

typedef UInt32		KernelDebugLevel;
enum
{
	kKernelDebugInfoLevel 		= 1000, 
	kKernelDebugRareInfoLevel	= 2000, 
	kKernelDebugAllowedErrorLevel	= 3000, 
	kKernelDebugAssertLevel 	= 4000, 
	kKernelDebugRequireLevel	= 5000, 
	kKernelDebugErrorLevel		= 6000, 
	kKernelDebugCriticalErrorLevel	= 7000, 
	kKernelDebugTragicErrorLevel	= 8000, 
	kKernelDebugAnyLevel		= 0
};

#ifdef KERNEL
// Function prototypes.

void			KernelDebugSetLevel( KernelDebugLevel inLevel );
KernelDebugLevel	KernelDebugGetLevel();
void			KernelDebugSetOutputType( KernelDebuggingOutputType inType );
KernelDebuggingOutputType	KernelDebugGetOutputType();
IOReturn 		KernelDebugFindKernelLogger();
void			KernelDebugEnable( bool enable );

//	Yes, you can call this directly. But, why? If you use the macros declared below, such as
//	KernelIOLog, you get the benefit of having your logs compiled out when you set the
//	DEBUG_LEVEL to production mode and recompile. Dude. Sweet. What's mine say?

void			KernelDebugLogInternal( KernelDebugLevel inLevel, UInt32 inTag, char const *inFormatString, ... )  __attribute__ ((format(printf,3,4)));;
void 			KernelDebugLogDataInternal( UInt32 inLevel,  UInt32 inTag, void *buffer, UInt32 byteCount, bool preBuffer);

// Handy macros.

#define REQUIRE_NO_ERR_PRINTF( VALUE, LABEL, ARGS... )							\
	if ( VALUE != kIOReturnSuccess )									\
	{												\
		KernelDebugLogInternal( kDebugInfoLevel, 'BluD', ## ARGS );				\
		goto LABEL;										\
	}

#define REQUIRE_PRINTF( TEST, LABEL, ARGS... )								\
	do												\
	{												\
		if ( !( TEST ) )										\
		{											\
			KernelDebugLogInternal( kDebugInfoLevel, 'BluD',  ## ARGS );			\
			goto LABEL;									\
		}											\
	} while( false )

// Some macros to call the debugging outputs. We'll strip out the debug logs if we are production code.

#if DEBUG_LEVEL != DEBUG_LEVEL_PRODUCTION
#define	KernelDebugLog( LEVEL, ARGS... )			KernelDebugLogInternal( ( LEVEL ), 'KDbg', ## ARGS ) __attribute__ ((format(printf,1,2)));
	#define	KernelDebugLogTag( LEVEL, TAG, ARGS... )		KernelDebugLogInternal( ( LEVEL ), ( TAG ),  ## ARGS )
	#define KernelDebugLogData( LEVEL, TAG, BUFFER, SIZE, HOLD)	KernelDebugLogDataInternal( ( LEVEL ), ( TAG ), ( BUFFER ), ( SIZE ), ( HOLD ))
#else
	#define	KernelDebugLog( LEVEL, ARGS... )
	#define	KernelDebugLogTag( LEVEL, TAG, ARGS... )
	#define KernelDebugLogData( LEVEL, TAG, BUFFER, SIZE, HOLD)
#endif


#ifdef	__cplusplus
	}
        
//================================================================================================
//   Forward declarations
//================================================================================================
class com_apple_iokit_KLogClient;

//================================================================================================
//   Defines
//================================================================================================
#define kLogKextName 	"com_apple_iokit_KLog"
#define MAXUSERS 	5

//================================================================================================
//   Custom Types
//================================================================================================

typedef UInt32 KLogLevel;
typedef UInt32 KLogTag;

//================================================================================================
//   com_apple_iokit_KLog
//================================================================================================

class com_apple_iokit_KLog : public IOService
{

    OSDeclareDefaultStructors(com_apple_iokit_KLog)

    com_apple_iokit_KLogClient *	mClientPtr[MAXUSERS+1];

    unsigned char *			mMsgBuffer;
    UInt8 				mClientCount;
    UInt8 				mMsgSize;
    bool 				mErrFlag;
    struct timeval *			mTimeVal;
    IOLock *				mLogLock;
    
public:

    static com_apple_iokit_KLog	*	logger;
    
    virtual bool 			init(OSDictionary *dictionary = 0);
    virtual void 			free(void);
   
    virtual IOService *			probe(IOService *provider, SInt32 *score);
    virtual bool 			start(IOService *provider);
    virtual void 			stop(IOService *provider);
    virtual IOReturn 			newUserClient( task_t owningTask, void * securityID,
                                                UInt32 type, IOUserClient ** handler );

    virtual SInt8			Log( KLogLevel level, KLogTag tag, const char *format, ... );
    virtual SInt8			vLog( KLogLevel level, KLogTag tag, const char *format, va_list in_va_list );
	
    void 				closeChild(com_apple_iokit_KLogClient *ptr);
    void 				setErr(bool set);
    
};

#define kMaxStatusBufSize	(8*1024)


class IOUSBLog : public IOService
{
    OSDeclareAbstractStructors(IOUSBLog)

private:
public:
    virtual bool	init( OSDictionary * dictionary = 0 );
  	virtual const char *			stringFromReturn( IOReturn rtn );
	static IOUSBLog	*usblog();
    virtual void 	AddStatusLevel (UInt32 level, UInt32 ref, char *status, UInt32 value);
    virtual void	AddStatus(char *message);
    virtual void	AddStatus(UInt32 level, char *message);
    virtual void 	USBLogPrintf(UInt32 level, char *format,...);
	virtual char *	strstr(const char *in, const char *str);
};


#endif              // __cplusplus
#endif              // KERNEL
#endif              // _IOKIT_IOUSBLOG_H
                                                                                                   IOUSBMassStorageClass.h                                                                             0100644 0001750 0001750 00000045604 12567471024 037016  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 

#ifndef _IOKIT_IOUSBMASSSTORAGECLASS_H
#define _IOKIT_IOUSBMASSSTORAGECLASS_H

// Headers for general IOKit definitions
#include <IOKit/IOLib.h>
#include <IOKit/IOService.h>
#include <IOKit/IOMemoryDescriptor.h>
#include <IOKit/IOMessage.h>

// Headers for USB specific definitions
#include <IOKit/usb/IOUSBInterface.h>
#include <IOKit/usb/IOUSBPipe.h>
#include <IOKit/usb/USBSpec.h>
#include <IOKit/usb/USB.h>

// Headers for SCSI Protocol support definitions
#include <IOKit/scsi/IOSCSIProtocolServices.h>

// BSD includes
#include <sys/sysctl.h>

#define UNUSED(x) ((void)x)

#pragma mark -
#pragma mark Vendor Specific Device Support
#define kIOUSBMassStorageCharacteristics		"USB Mass Storage Characteristics"
#define kIOUSBMassStoragePreferredSubclass		"Preferred Subclass"
#define kIOUSBMassStoragePreferredProtocol		"Preferred Protocol"
#define kIOUSBMassStorageUseStandardUSBReset	"Use Standard USB Reset"
#define kIOUSBKnownCSWTagIssues					"Known CSW Tag Issues"
#define kIOUSBMassStorageMaxLogicalUnitNumber	"Max Logical Unit Number"
#define kIOPropertyIOUnitKey					"IOUnit"
#define kIOUSBMassStorageDoNotMatch				"Do Not Match MSC"
#define kIOUSBMassStorageDoNotOperate			"Do Not Operate"
#define kIOUSBMassStorageEnableSuspendResumePM	"Enable Port Suspend-Resume PM"
#define kIOUSBMassStoragePostResetCoolDown		"Reset Recovery Time"

#ifndef EMBEDDED
#define kIOUSBMassStorageSuspendOnReboot        "Suspend On Reboot"
#define kIOUSBMassStorageResetOnResume			"Reset On Resume"
#endif // EMBEDDED

enum 
{
	kUSBDAddressLength = 10
};

enum 
{
	kIOUSBMassStorageReconfigurationTimeoutMS = 5000
};


#pragma mark -
#pragma mark CBI Protocol Strutures
// Structure for the global PB's
struct CBIRequestBlock
{
	SCSITaskIdentifier			request;
	IOUSBDevRequest				cbiDevRequest;
	SCSICommandDescriptorBlock	cbiCDB;
	IOUSBCompletion				cbiCompletion;
	UInt32						currentState;
	IOMemoryDescriptor *		cbiPhaseDesc;
	UInt8						cbiGetStatusBuffer[2];	// 2 bytes as specified in the USB spec
};

typedef struct CBIRequestBlock	CBIRequestBlock;

#pragma mark -
#pragma mark Bulk Only Protocol Structures

struct StorageBulkOnlyCBW
{
	UInt32		cbwSignature;
	UInt32		cbwTag;
	UInt32		cbwTransferLength;
	UInt8		cbwFlags;
	UInt8		cbwLUN;					// Bits 0-3: LUN, 4-7: Reserved
	UInt8		cbwCDBLength;			// Bits 0-4: CDB Length, 5-7: Reserved
	UInt8		cbwCDB[16];
};

typedef struct StorageBulkOnlyCBW	StorageBulkOnlyCBW;

struct	StorageBulkOnlyCSW
{
	UInt32		cswSignature;
	UInt32		cswTag;
	UInt32		cswDataResidue;
	UInt8		cswStatus;
};

typedef struct StorageBulkOnlyCSW	StorageBulkOnlyCSW;

struct	BulkOnlyRequestBlock
{
	SCSITaskIdentifier		request;
	IOUSBCompletion			boCompletion;
	UInt32					currentState;
	StorageBulkOnlyCBW		boCBW;
	StorageBulkOnlyCSW		boCSW;
	IOMemoryDescriptor *	boPhaseDesc;
	UInt8					boGetStatusBuffer[2];	// 2 bytes as specified in the USB spec
};

typedef struct BulkOnlyRequestBlock		BulkOnlyRequestBlock;


#pragma mark -
#pragma mark IOUSBMassStorageClass definition

class IOUSBMassStorageClass : public IOSCSIProtocolServices
{
    OSDeclareDefaultStructors(IOUSBMassStorageClass)

private:
	// ---- Member variables used by all protocols ----
	// The interface object that provides the driver with access to the 
	// USB so that it may talk to its device.
    IOUSBInterface *			fInterface;

	// The pipe objects that the driver uses to transport data through a
	// pipe to the appropriate endpoint.
    IOUSBPipe *					fBulkInPipe;
    IOUSBPipe *					fBulkOutPipe;
    IOUSBPipe *					fInterruptPipe;
    
	IOUSBDevRequest				fUSBDeviceRequest;
	UInt8						fPreferredSubclass;
	UInt8						fPreferredProtocol;
	
  	// The maximum Logical Unit Number.  This is the highest valid LUN
  	// that the USB device supports, so if the device only supports one
  	// LUN, such as CBI and CB, this number will be zero.
  	UInt8						fMaxLogicalUnitNumber;

	// ---- Member variables used by CBI protocol ----
	bool						fCBICommandStructInUse; 

	CBIRequestBlock				fCBICommandRequestBlock;
    
	// ---- Member variables used by Bulk Only protocol ----
 	// Command tag, this driver just uses a sequential counter that is
 	// incremented for each CBW that is sent to the device.
 	UInt32 						fBulkOnlyCommandTag;

	bool						fBulkOnlyCommandStructInUse; 
    
    // Dedicated CBW and CSW IOMemoryDescriptors are listed in the ExpansionData struct.
		
 	// The Request block that contains all the necessary data for 
 	// transporting a Bulk Only request across the USB.
 	BulkOnlyRequestBlock		fBulkOnlyCommandRequestBlock;

protected:
    // Reserve space for future expansion.
    
    // We flatten the ExpansionData for iOS since we're relieved of the burden binary compatibility.
#ifndef EMBEDDED
    struct ExpansionData
	{
#endif // EMBEDDED
		bool					fResetInProgress;
		OSSet *					fClients;
		IOUSBPipe *				fPotentiallyStalledPipe;
		bool					fUseUSBResetNotBOReset;
		bool					fAbortCurrentSCSITaskInProgress;
		IOMemoryDescriptor *	fCBIMemoryDescriptor;
		IOMemoryDescriptor *	fBulkOnlyCBWMemoryDescriptor;
		IOMemoryDescriptor *	fBulkOnlyCSWMemoryDescriptor;
        bool                    fDeviceAttached;
		bool                    fWaitingForReconfigurationMessage;
		bool					fTerminating;
        bool                    fKnownCSWTagMismatchIssues;
        bool                    fPortSuspendResumeForPMEnabled;
        bool                    fPortIsSuspended;
#ifndef EMBEDDED
		bool					fRequiresResetOnResume;
		bool					fAutonomousSpinDownWorkAround;
#endif // EMBEDDED
		UInt8					fConsecutiveResetCount;
#ifndef EMBEDDED
		bool					fClearStallInProgress;				/* OBSOLETE */
#endif // EMBEDDED
		bool					fTerminationDeferred;
#ifndef EMBEDDED
		UInt32					fRequiredMaxBusStall;
#endif // EMBEDDED
		bool					fBlockOnResetThread;
#ifndef EMBEDDED
        UInt32					fPostDeviceResetCoolDownInterval;
		bool					fSuspendOnReboot;
#endif // EMBEDDED
		UInt8					fResetStatus;
        
#ifndef EMBEDDED
	};
    ExpansionData *				reserved;
#endif // EMBEDDED
	
#ifndef EMBEDDED
	#define fResetInProgress					reserved->fResetInProgress
	#define fClients							reserved->fClients
	#define fPotentiallyStalledPipe				reserved->fPotentiallyStalledPipe
    #define fUseUSBResetNotBOReset				reserved->fUseUSBResetNotBOReset
	#define fAbortCurrentSCSITaskInProgress		reserved->fAbortCurrentSCSITaskInProgress
    #define fCBIMemoryDescriptor                reserved->fCBIMemoryDescriptor
	#define	fBulkOnlyCBWMemoryDescriptor		reserved->fBulkOnlyCBWMemoryDescriptor
	#define	fBulkOnlyCSWMemoryDescriptor		reserved->fBulkOnlyCSWMemoryDescriptor
    #define fDeviceAttached                     reserved->fDeviceAttached
	#define fWaitingForReconfigurationMessage	reserved->fWaitingForReconfigurationMessage
	#define fTerminating						reserved->fTerminating
    #define fKnownCSWTagMismatchIssues          reserved->fKnownCSWTagMismatchIssues
    #define fPortSuspendResumeForPMEnabled      reserved->fPortSuspendResumeForPMEnabled
    #define fPortIsSuspended                    reserved->fPortIsSuspended
    #define fRequiresResetOnResume				reserved->fRequiresResetOnResume
    #define fAutonomousSpinDownWorkAround		reserved->fAutonomousSpinDownWorkAround
    #define fConsecutiveResetCount				reserved->fConsecutiveResetCount
    #define fClearStallInProgress				reserved->fClearStallInProgress
    #define fTerminationDeferred				reserved->fTerminationDeferred
    #define fRequiredMaxBusStall				reserved->fRequiredMaxBusStall
    #define fBlockOnResetThread					reserved->fBlockOnResetThread
    #define fPostDeviceResetCoolDownInterval	reserved->fPostDeviceResetCoolDownInterval
    #define fSuspendOnReboot					reserved->fSuspendOnReboot
    #define fResetStatus						reserved->fResetStatus	
#endif // EMBEDDED
    
	// Enumerated constants used to control various aspects of this
	// driver.

	// Enumerates the fResetStatus
	enum
	{
		kUSBResetStatusSuccess				= 0,
		kUSBResetStatusFailure				= 1
	};
	
	// Enumerations for Mass Storage Class Subclass types
	enum
	{
		kUSBStorageRBCSubclass 				= 1,
		kUSBStorageSFF8020iSubclass 		= 2,
		kUSBStorageQIC157Subclass			= 3,
		kUSBStorageUFISubclass				= 4,
		kUSBStorageSFF8070iSubclass			= 5,
		kUSBStorageSCSITransparentSubclass	= 6
	};

	// The supported USB Mass Storage Class transport protocols.
	enum
	{
		kProtocolControlBulkInterrupt	= 0x00,
		kProtocolControlBulk			= 0x01,
		kProtocolBulkOnly				= 0x50
	};

	// ------- Protocol support functions ------------
	// The SendSCSICommand function will take a SCSITask Object and transport
	// it across the physical wire(s) to the device
	virtual bool    		SendSCSICommand( 	
								SCSITaskIdentifier 		request, 
								SCSIServiceResponse *	serviceResponse,
								SCSITaskStatus		*	taskStatus );

	// The AbortSCSICommand function will abort the indicated SCSITask object,
	// if it is possible and the SCSITask has not already completed.
    virtual SCSIServiceResponse    	AbortSCSICommand( SCSITaskIdentifier abortTask );

	virtual bool					IsProtocolServiceSupported( 
										SCSIProtocolFeature 	feature, 
										void * 					serviceValue );

	virtual bool					HandleProtocolServiceFeature( 
										SCSIProtocolFeature 	feature, 
										void * 					serviceValue );
 
	// Methods for retrieving and setting the object for the Interface
	IOUSBInterface *		GetInterfaceReference( void );
	void					SetInterfaceReference( IOUSBInterface * newInterface );
	
	UInt8					GetInterfaceSubclass( void );
	UInt8					GetInterfaceProtocol( void );
	
	// Methods for retrieving an object for a Pipe.
	IOUSBPipe *				GetControlPipe( void );
	IOUSBPipe *				GetBulkInPipe( void );
	IOUSBPipe *				GetBulkOutPipe( void );
	IOUSBPipe *				GetInterruptPipe( void );
    
	// Methods for getting and setting the maximum LUN of a device.
	UInt8					GetMaxLogicalUnitNumber( void ) const;
	void					SetMaxLogicalUnitNumber( UInt8 maxLUN );
	
	virtual void 			CompleteSCSICommand( 
								SCSITaskIdentifier request, 
								IOReturn status );

	virtual	bool			BeginProvidedServices( void );
	virtual	bool			EndProvidedServices( void );
	
	// The Protocol specific helper methods for SendSCSICommand	
	virtual IOReturn		SendSCSICommandForCBIProtocol(
                                                          SCSITaskIdentifier request );
	
	virtual IOReturn		SendSCSICommandForBulkOnlyProtocol(
                                                               SCSITaskIdentifier request );
    
	// The Protocol specific helper methods for AbortSCSICommand	
	virtual IOReturn		AbortSCSICommandForCBIProtocol(
                                                           SCSITaskIdentifier abortTask );
	
	virtual IOReturn		AbortSCSICommandForBulkOnlyProtocol(
                                                                SCSITaskIdentifier abortTask );

	// Helper methods for performing general USB device requests
	virtual IOReturn		ClearFeatureEndpointStall( 
								IOUSBPipe *			thePipe,
								IOUSBCompletion	*	completion );
	virtual IOReturn 		GetStatusEndpointStatus(
								IOUSBPipe *			thePipe,
								void *				endpointStatus,
								IOUSBCompletion	*	completion );
	
 	/* All CBI transport related methods.
 	 */
	// All definitions and structures for the CBI Protocol
	enum
	{
 		kUSBStorageAutoStatusSize	= 2		// Per the USB CBI Protocol
 	};

 	// Methods for accessing Bulk Only specific member variables.
	CBIRequestBlock *		GetCBIRequestBlock( void );

	void 					ReleaseCBIRequestBlock( 
								CBIRequestBlock *	cbiRequestBlock );

	// Methods used for CBI/CB command transportation.
	static void		CBIProtocolUSBCompletionAction(
						void *					target,
		                void *					parameter,
		                IOReturn				status,
		                UInt32					bufferSizeRemaining);

	IOReturn		CBIProtocolTransferData( 
						CBIRequestBlock *		cbiRequestBlock,
						UInt32					nextExecutionState );
		                
	IOReturn		CBIProtocolReadInterrupt( 
						CBIRequestBlock *		cbiRequestBlock,
						UInt32					nextExecutionState );

	IOReturn		CBIGetStatusEndpointStatus( 
						IOUSBPipe *				targetPipe,
						CBIRequestBlock *		cbiRequestBlock,
						UInt32					nextExecutionState );

	IOReturn		CBIClearFeatureEndpointStall( 
						IOUSBPipe *				targetPipe,
						CBIRequestBlock *		cbiRequestBlock,
						UInt32					nextExecutionState );
						
	void 			CBIProtocolCommandCompletion(
						CBIRequestBlock *		cbiRequestBlock,
		                IOReturn				resultingStatus,
		                UInt32					bufferSizeRemaining );
		                
 	/* All Bulk Only transport related methods, structures and enums.
 	 */
 	// All Bulk Only specific structures and enums.
	
	// All definitions and structures for the Bulk Only Protocol
	// Command Block Wrapper (CBW)
	enum
	{
		// CBW general struture definitions
		kCommandBlockWrapperSignature	= OSSwapHostToBigConstInt32 ( 'USBC' ),
		kByteCountOfCBW					= 31,

		// CBW LUN related definitions
		kCBWLUNMask						= 0x0F,

		kCBWFlagsDataOut				= 0x00,
		kCBWFlagsDataIn					= 0x80
	};
	
	// All definitions and structures for the Bulk Only Protocol
	// Command Status Wrapper (CSW)
	enum
	{
		// CSW general struture definitions
		kCommandStatusWrapperSignature	= OSSwapHostToBigConstInt32 ( 'USBS' ),
		kByteCountOfCSW					= 13,

		// CSW status definitions
		kCSWCommandPassedError 			= 0x00,	// No error occurred
		kCSWCommandFailedError			= 0x01,	/* An error occurred (probably a 
											 	 * bad command or parameter ) */
		kCSWPhaseError					= 0x02	/* A transfer was performed in 
											 	 * the wrong sequence */
	};

 	// Methods for accessing Bulk Only specific member variables.
	BulkOnlyRequestBlock *	GetBulkOnlyRequestBlock( void );

	void 			ReleaseBulkOnlyRequestBlock( 
						BulkOnlyRequestBlock * 		boRequestBlock );

	UInt32			GetNextBulkOnlyCommandTag( void );

	// Methods for Bulk Only specific utility commands
	IOReturn		BulkDeviceResetDevice(
						BulkOnlyRequestBlock *		boRequestBlock,
						UInt32						nextExecutionState );
						
	// Methods used for Bulk Only command transportation.
	IOReturn		BulkOnlySendCBWPacket(
						BulkOnlyRequestBlock *		boRequestBlock,
						UInt32						nextExecutionState );
	
	IOReturn		BulkOnlyTransferData( 
						BulkOnlyRequestBlock *		boRequestBlock,
						UInt32						nextExecutionState );
	
	IOReturn		BulkOnlyReceiveCSWPacket(
						BulkOnlyRequestBlock *		boRequestBlock,
						UInt32						nextExecutionState );
	
	void			BulkOnlyExecuteCommandCompletion (
						BulkOnlyRequestBlock *		boRequestBlock,
		                IOReturn					resultingStatus,
		                UInt32						bufferSizeRemaining );

	static void		BulkOnlyUSBCompletionAction (
		                void *			target,
		                void *			parameter,
		                IOReturn		status,
		                UInt32			bufferSizeRemaining );
	
public:

    bool				init( OSDictionary * 	propTable );
    virtual bool		start( IOService *	 	provider );
    virtual void 		stop( IOService * 		provider );
	virtual void		free( void );
	virtual	IOReturn	message( UInt32 type, IOService * provider, void * argument = 0 );
	
	virtual bool        willTerminate(  IOService *     provider, 
                                        IOOptionBits    options );
										
	virtual bool        didTerminate(	IOService *     provider, 
                                        IOOptionBits    options, 
										bool *			defer );
                                        
	virtual bool		handleOpen( IOService *		client,
									IOOptionBits	options,
									void *			arg );
	
	virtual void		handleClose( IOService *	client,
									 IOOptionBits	options );
	
	virtual bool		handleIsOpen(  const IOService * client ) const;
	
	virtual IOReturn	HandlePowerOn( void );
	
#ifndef EMBEDDED
	virtual void		systemWillShutdown ( IOOptionBits specifier );
#endif // EMBEDDED
	
protected:

	static IOReturn		sWaitForReset( void * refcon );
	IOReturn			GatedWaitForReset( void );
	
#ifndef EMBEDDED
	static IOReturn		sWaitForTaskAbort( void * refcon );			/* OBSOLETE */
	IOReturn			GatedWaitForTaskAbort( void );				/* OBSOLETE */
#endif // EMBEDDED
    
	static void			sResetDevice( void * refcon );

#ifndef EMBEDDED
	static void			sAbortCurrentSCSITask( void * refcon );		/* OBSOLETE */
	
    OSMetaClassDeclareReservedUsed( IOUSBMassStorageClass, 1 );
	virtual IOReturn	StartDeviceRecovery( void );				/* OBSOLETE */

    OSMetaClassDeclareReservedUsed( IOUSBMassStorageClass, 2 );
	virtual void		FinishDeviceRecovery( IOReturn	status );	/* OBSOLETE */

	static void			DeviceRecoveryCompletionAction(
		                	void *			target,
		                	void *			parameter,
		                	IOReturn		status,
		                	UInt32			bufferSizeRemaining );	/* OBSOLETE */
#endif // EMBEDDED
    
	IOReturn       ResetDeviceNow( bool waitForReset );
	
	void                AbortCurrentSCSITask( void );
	
	bool                IsPhysicalInterconnectLocationInternal ( void );
	    
	IOReturn            SuspendPort ( bool suspend );
	
private:
	
	void				ClearPipeStall ( void );
	
	IOReturn			AcceptSCSITask ( SCSITaskIdentifier scsiTask, bool * pAccepted );
	
	void				CheckDeferredTermination ( void );
	
	void				GatedCompleteSCSICommand ( SCSITaskIdentifier request, SCSIServiceResponse * serviceResponse, SCSITaskStatus * taskStatus );
	
	// Space reserved for future expansion.
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 3 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 4 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 5 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 6 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 7 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 8 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 9 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 10 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 11 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 12 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 13 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 14 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 15 );
    OSMetaClassDeclareReservedUnused( IOUSBMassStorageClass, 16 );
	
};


#endif //_IOKIT_IOUSBMASSSTORAGECLASS_H
                                                                                                                            IOUSBMassStorageUFISubclass.h                                                                       0100644 0001750 0001750 00000027232 12567471024 040071  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


#ifndef _IOKIT_IOUSBMASSSTORAGEUFISUBCLASS_H
#define _IOKIT_IOUSBMASSSTORAGEUFISUBCLASS_H

// This class' header file
#include <IOKit/usb/IOUSBMassStorageClass.h>
#include <IOKit/scsi/IOSCSIPrimaryCommandsDevice.h>


#pragma mark -
#pragma mark IOUSBMassStorageUFIDevice declaration

class IOUSBMassStorageUFIDevice : public IOSCSIPrimaryCommandsDevice
{
    OSDeclareDefaultStructors(IOUSBMassStorageUFIDevice)

private:
	static void			AsyncReadWriteComplete( SCSITaskIdentifier	completedTask );
	
protected:
    // Reserve space for future expansion.
    struct IOUSBMassStorageUFIDeviceExpansionData
	{
	};
    IOUSBMassStorageUFIDeviceExpansionData *fIOUSBMassStorageUFIDeviceReserved;

	// ---- Medium Characteristics ----
	bool				fMediumPresent;

	// The byte count of each physical block on the medium.
	UInt32				fMediumBlockSize;

	// The total number of blocks of fMediumBlockSize on the medium.
	UInt32				fMediumBlockCount;

	// Whether the installed medium is protected from writes
	bool				fMediumIsWriteProtected;

	// Polling thread variables
	thread_call_t		fPollingThread;
	UInt32				fPollingMode;
	enum
	{
		kPollingMode_Suspended		= 0,
		kPollingMode_NewMedia 		= 1,
		kPollingMode_MediaRemoval	= 2
	};
	
	// ---- Methods for controlling the current state of device support ----
	virtual bool		InitializeDeviceSupport( void );
	virtual void 		StartDeviceSupport ( void );
	virtual void		SuspendDeviceSupport( void );
	virtual void		ResumeDeviceSupport( void );
	virtual void 		StopDeviceSupport ( void );
	virtual void		TerminateDeviceSupport( void );

	// ---- Methods used for misc  ----
	virtual bool		ClearNotReadyStatus( void );
	virtual void 		CreateStorageServiceNub( void );
	virtual bool		DetermineDeviceCharacteristics( void );

	// ---- Methods used for controlling the polling thread ----
	virtual void		ProcessPoll( void );
	virtual void		EnablePolling( void );
	virtual void		DisablePolling( void );

	// ---- Main and support methods for polling for new Media ----
	virtual void		PollForNewMedia( void );
	virtual bool		DetermineMediaPresence( void );
	virtual bool		DetermineMediumCapacity( 
							UInt64 * 				blockSize, 
							UInt64 * 				blockCount );
	virtual bool		DetermineMediumWriteProtectState( void );

	// ---- Main and support methods for polling for Media removal ----
	virtual void		PollForMediaRemoval( void );
	
	// ---- Methods used for power managment ----
	virtual UInt32		GetInitialPowerState ( void );
	virtual void 		InitializePowerManagement ( IOService * provider );
	virtual void		HandlePowerChange ( void );
	virtual void		HandleCheckPowerState ( void );
	virtual void		TicklePowerManager ( void );
	virtual UInt32		GetNumberOfPowerStateTransitions ( void );

	// ---- Methods used for handling medium characteristics ----
    virtual void		SetMediumCharacteristics( 
    						UInt32 					blockSize, 
    						UInt32 					blockCount );
	
	virtual void		ResetMediumCharacteristics( void );

	virtual IOReturn	IssueRead( 	
							IOMemoryDescriptor *	buffer,
                         	UInt64					startBlock,
                     		UInt64					blockCount );
	
	virtual IOReturn	IssueRead(	
							IOMemoryDescriptor *	buffer,
                      		UInt64					startBlock,
                     		UInt64					blockCount,
                       		void * 					clientData );


	virtual IOReturn	IssueWrite( 
							IOMemoryDescriptor *	buffer,
                    		UInt64					startBlock,
                       		UInt64					blockCount );

	virtual IOReturn	IssueWrite(	
							IOMemoryDescriptor *	buffer,
                         	UInt64					startBlock,
                      		UInt64					blockCount,
							void * 					clientData );

public:
											
	static 	void		sProcessPoll( void * pdtDriver, void * refCon );

	// Interface to the UFI Storage Services Driver
	// ---- Methods for controlling the device ----
	virtual IOReturn	SyncReadWrite(
							IOMemoryDescriptor *	buffer,
							UInt64					startBlock,
							UInt64					blockCount,
							UInt64					blockSize );

	virtual IOReturn	AsyncReadWrite(
							IOMemoryDescriptor *	buffer,
							UInt64					startBlock,
							UInt64					blockCount,
							UInt64					blockSize,
							void * 					clientData );

	// ---- Methods for controlling medium state ----
	virtual IOReturn	EjectTheMedium( void );

	// ---- Methods for controlling media format ----
	virtual IOReturn	FormatMedium( 
							UInt64 					blockCount, 
							UInt64 					blockSize );
	virtual UInt32		GetFormatCapacities( 	
							UInt64 * 				capacities,
             				UInt32   				capacitiesMaxCount ) const;

	// ---- Query methods to report device characteristics ----
	// Report the maximum number of blocks that the device can handle per
	// read or write.  A value of 0 (zero) indicates there is no limit aside
	// from the size of the method's return parameter.
	virtual UInt64		ReportDeviceMaxBlocksReadTransfer( void );
	virtual UInt64		ReportDeviceMaxBlocksWriteTransfer( void );
	
	// ---- Query methods to report installed medium characteristics ----
	virtual UInt64		ReportMediumBlockSize( void );
	virtual UInt64		ReportMediumTotalBlockCount( void );
	virtual bool		ReportMediumWriteProtection( void );
        
	// Methods for getting device information strings
	virtual char *		GetVendorString( void );
	virtual char *		GetProductString( void );
	virtual char *		GetRevisionString( void );
	OSDictionary *		GetProtocolCharacteristicsDictionary ( void );
	OSDictionary *		GetDeviceCharacteristicsDictionary ( void );	
	
protected:
	// Utility methods used by all SCSI Command Set objects
	
	// isParameterValid methods are used to validate that the parameter passed into
	// the command methods are of the correct value.
	
	// Validate Parameter used for 1 bit to 1 byte paramaters
    bool		 	IsParameterValid( 
							SCSICmdField1Byte 			param,
							SCSICmdField1Byte 			mask );
	
	// Validate Parameter used for 9 bit to 2 byte paramaters
	bool		 	IsParameterValid( 
							SCSICmdField2Byte 			param,
							SCSICmdField2Byte 			mask );
	
	// Validate Parameter used for 17 bit to 4 byte paramaters
	bool		 	IsParameterValid( 
							SCSICmdField4Byte 			param,
							SCSICmdField4Byte 			mask );
	
	// UFI Required Commands
	virtual bool 	FORMAT_UNIT(
							SCSITaskIdentifier			request,
			    			IOMemoryDescriptor *		dataBuffer,
			    			IOByteCount					defectListSize,
			    			SCSICmdField1Byte 			TRACK_NUMBER, 
			    			SCSICmdField2Byte 			INTERLEAVE );

	virtual bool	INQUIRY(
							SCSITaskIdentifier			request,
    						IOMemoryDescriptor 			*dataBuffer,
    						SCSICmdField1Byte 			PAGE_OR_OPERATION_CODE,
    						SCSICmdField1Byte 			ALLOCATION_LENGTH );

   	virtual bool	MODE_SELECT_10(
							SCSITaskIdentifier			request,
    						IOMemoryDescriptor 			*dataBuffer,
    						SCSICmdField1Bit 			PF,
    						SCSICmdField1Bit 			SP,
    						SCSICmdField2Byte 			PARAMETER_LIST_LENGTH );  

   	virtual bool	MODE_SENSE_10(
							SCSITaskIdentifier			request,
    						IOMemoryDescriptor 			*dataBuffer,
    						SCSICmdField1Bit 			DBD,
	   						SCSICmdField2Bit 			PC,
	   						SCSICmdField6Bit 			PAGE_CODE,
	   						SCSICmdField2Byte 			PARAMETER_LIST_LENGTH );

    virtual bool	PREVENT_ALLOW_MEDIUM_REMOVAL( 
							SCSITaskIdentifier			request,
	     					SCSICmdField1Bit 			PREVENT );

	virtual bool 	READ_10(
							SCSITaskIdentifier			request,
			    			IOMemoryDescriptor *		dataBuffer, 
			    			UInt32						blockSize,
			    			SCSICmdField1Bit 			DPO, 
			    			SCSICmdField1Bit 			FUA,
							SCSICmdField1Bit 			RELADR, 
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
							SCSICmdField2Byte 			TRANSFER_LENGTH );

	virtual bool 	READ_12(
							SCSITaskIdentifier			request,
			    			IOMemoryDescriptor *		dataBuffer, 
			    			UInt32						blockSize,
			    			SCSICmdField1Bit 			DPO, 
			    			SCSICmdField1Bit 			FUA,
							SCSICmdField1Bit 			RELADR, 
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
							SCSICmdField4Byte 			TRANSFER_LENGTH );

	virtual bool 	READ_CAPACITY(
							SCSITaskIdentifier			request,
			    			IOMemoryDescriptor *		dataBuffer, 
			    			SCSICmdField1Bit 			RELADR,
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
							SCSICmdField1Bit 			PMI );

	virtual bool 	READ_FORMAT_CAPACITIES(
							SCSITaskIdentifier			request,
			    			IOMemoryDescriptor *		dataBuffer, 
			    			SCSICmdField2Byte 			ALLOCATION_LENGTH );

	virtual bool 	REQUEST_SENSE(
							SCSITaskIdentifier			request,
   							IOMemoryDescriptor 			*dataBuffer,
			    			SCSICmdField1Byte 			ALLOCATION_LENGTH );
 	
	virtual bool 	REZERO_UNIT( 
							SCSITaskIdentifier			request );

	virtual bool 	SEEK( 
							SCSITaskIdentifier			request,
			    			SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS );

	virtual bool 	SEND_DIAGNOSTICS( 
							SCSITaskIdentifier			request,
							SCSICmdField1Bit 			PF, 
							SCSICmdField1Bit 			SELF_TEST, 
							SCSICmdField1Bit 			DEF_OFL, 
							SCSICmdField1Bit 			UNIT_OFL );

	virtual bool 	START_STOP_UNIT( 
							SCSITaskIdentifier			request,
							SCSICmdField1Bit 			IMMED, 
							SCSICmdField1Bit 			LOEJ, 
							SCSICmdField1Bit 			START );

    virtual bool 	TEST_UNIT_READY(  
							SCSITaskIdentifier			request );
 
	virtual bool 	VERIFY( 
							SCSITaskIdentifier			request,
							SCSICmdField1Bit 			DPO, 
							SCSICmdField1Bit 			BYTCHK, 
							SCSICmdField1Bit 			RELADR,
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
							SCSICmdField2Byte 			VERIFICATION_LENGTH );

	virtual bool 	WRITE_10(
							SCSITaskIdentifier			request,
			    			IOMemoryDescriptor *		dataBuffer, 
			    			UInt32						blockSize,
			    			SCSICmdField1Bit 			DPO, 
			    			SCSICmdField1Bit 			FUA,
							SCSICmdField1Bit 			RELADR, 
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
							SCSICmdField2Byte 			TRANSFER_LENGTH );

	virtual bool 	WRITE_12(
							SCSITaskIdentifier			request,
							IOMemoryDescriptor *		dataBuffer, 
			    			UInt32						blockSize,
			    			SCSICmdField1Bit 			DPO, 
							SCSICmdField1Bit 			EBP, 
							SCSICmdField1Bit 			RELADR, 
							SCSICmdField4Byte 			LOGICAL_BLOCK_ADDRESS, 
							SCSICmdField4Byte 			TRANSFER_LENGTH );

	virtual bool 	WRITE_AND_VERIFY(
							SCSITaskIdentifier			request,
			    			IOMemoryDescriptor *		dataBuffer, 
			    			UInt32						blockSize,
			    			SCSICmdField1Bit 			DPO,
			    			SCSICmdField1Bit 			BYTCHK, 
			    			SCSICmdField1Bit 			RELADR, 
			    			SCSICmdField4Byte			LOGICAL_BLOCK_ADDRESS, 
			    			SCSICmdField2Byte 			TRANSFER_LENGTH );
};


#pragma mark -
#pragma mark IOUSBMassStorageUFISubclass declaration


class IOUSBMassStorageUFISubclass : public IOUSBMassStorageClass
{
    OSDeclareDefaultStructors(IOUSBMassStorageUFISubclass)

protected:
	virtual	bool		BeginProvidedServices( void );
	virtual	bool		EndProvidedServices( void );
};

#endif //_IOKIT_IOUSBMASSSTORAGEUFISUBCLASS_H
                                                                                                                                                                                                                                                                                                                                                                      IOUSBUserClient.h                                                                                   0100644 0001750 0001750 00000027753 12567452726 035672  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright  1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOUSBUSERCLIENT_H
#define _IOKIT_IOUSBUSERCLIENT_H

enum {
    kUSBDeviceUserClientOpen,
    kUSBDeviceUserClientClose,
    kUSBDeviceUserClientSetConfig,
    kUSBDeviceUserClientGetConfig,
    kUSBDeviceUserClientGetConfigDescriptor,
    kUSBDeviceUserClientGetFrameNumber,
    kUSBDeviceUserClientDeviceRequestOut,
    kUSBDeviceUserClientDeviceRequestIn,
    kUSBDeviceUserClientCreateInterfaceIterator,
    kUSBDeviceUserClientResetDevice,
    kUSBDeviceUserClientSuspend,
    kUSBDeviceUserClientAbortPipeZero,
    kUSBDeviceUserClientReEnumerateDevice,
    kUSBDeviceUserClientGetMicroFrameNumber,
    kUSBDeviceUserClientGetFrameNumberWithTime,
    kUSBDeviceUserClientSetAsyncPort,
    kUSBDeviceUserClientGetDeviceInformation,
    kUSBDeviceUserClientRequestExtraPower,
    kUSBDeviceUserClientReturnExtraPower,
    kUSBDeviceUserClientGetExtraPowerAllocated,
    kUSBDeviceUserClientGetBandwidthAvailableForDevice,
    kUSBDeviceUserClientSetConfigurationV2,
    kUSBDeviceUserClientRegisterForNotification,
    kUSBDeviceUserClientUnregisterNotification,
    kUSBDeviceUserClientAcknowledgeNotification,
    kIOUSBLibDeviceUserClientNumCommands
};

enum {
    kUSBInterfaceUserClientOpen,
    kUSBInterfaceUserClientClose,
    kUSBInterfaceUserClientGetDevice,
    kUSBInterfaceUserClientSetAlternateInterface,
    kUSBInterfaceUserClientGetFrameNumber,
    kUSBInterfaceUserClientGetPipeProperties,
    kUSBInterfaceUserClientReadPipe,
    kUSBInterfaceUserClientWritePipe,
    kUSBInterfaceUserClientGetPipeStatus,
    kUSBInterfaceUserClientAbortPipe,
    kUSBInterfaceUserClientResetPipe,
    kUSBInterfaceUserClientClearPipeStall,
    kUSBInterfaceUserClientControlRequestOut,
    kUSBInterfaceUserClientControlRequestIn,
    kUSBInterfaceUserClientSetPipePolicy,
    kUSBInterfaceUserClientGetBandwidthAvailable,
    kUSBInterfaceUserClientGetEndpointProperties,
    kUSBInterfaceUserClientLowLatencyPrepareBuffer,
    kUSBInterfaceUserClientLowLatencyReleaseBuffer,
    kUSBInterfaceUserClientGetMicroFrameNumber,
    kUSBInterfaceUserClientGetFrameListTime,
    kUSBInterfaceUserClientGetFrameNumberWithTime,
    kUSBInterfaceUserClientSetAsyncPort,
    kUSBInterfaceUserClientReadIsochPipe,
    kUSBInterfaceUserClientWriteIsochPipe,
    kUSBInterfaceUserClientLowLatencyReadIsochPipe,
    kUSBInterfaceUserClientLowLatencyWriteIsochPipe,
    kUSBInterfaceUserClientGetConfigDescriptor,
    kUSBInterfaceUserClientGetPipePropertiesV2,
    kUSBInterfaceUserClientGetPipePropertiesV3,
    kUSBInterfaceUserClientGetEndpointPropertiesV3,
    kUSBInterfaceUserClientSupportsStreams,
    kUSBInterfaceUserClientCreateStreams,
    kUSBInterfaceUserClientGetConfiguredStreams,
    kUSBInterfaceUserClientReadStreamsPipe,
    kUSBInterfaceUserClientWriteStreamsPipe,
    kUSBInterfaceUserClientAbortStreamsPipe,
    kUSBInterfaceUserClientRegisterForNotification,
    kUSBInterfaceUserClientUnregisterNotification,
    kUSBInterfaceUserClientAcknowledgeNotification,
    kUSBInterfaceUserClientRegisterDriver,
    kIOUSBLibInterfaceUserClientNumCommands
};

// this constant is used by both IOUSBDevice and IOUSBInterface to define the location of the IOUSBLib bundle
#define kIOUSBLibBundleName                 "IOUSBFamily.kext/Contents/PlugIns/IOUSBLib.bundle"

// this is a string representation of the UUID known as kIOUSBDeviceUserClientTypeID in IOUSBLib.h
// it should never have to change, even as we add new functions to the IOUSBDeviceInterface
#define kIOUSBDeviceUserClientTypeIDKey     "9dc7b780-9ec0-11d4-a54f-000a27052861"

// this is a string representation of the UUID known as kIOUSBInterfaceUserClientTypeID in IOUSBLib.h
// it should never have to change, even as we add new functions to the IOUSBInterfaceInterface
#define kIOUSBInterfaceUserClientTypeIDKey     "2d9786c6-9ef3-11d4-ad51-000a27052861"

// this is the class name of the IOUSBInterfaceUserClient in the kernel
// if we ever have to go to IOUSBInterfaceeUserClientV4, this will need to change
#define kIOUSBInterfaceUserClientClassNameStr     "IOUSBInterfaceUserClientV3"


// this is the class name of the IOUSBDeviceUserClient in the kernel
// if we ever have to go to IOUSBDeviceUserClientV3, this will need to change
#define kIOUSBDeviceUserClientClassNameStr     "IOUSBDeviceUserClientV2"

#define kNeedsDeviceAccessEntitlement   "NeedsDeviceAccessEntitlement"

#if KERNEL
#include <IOKit/IOService.h>
#include <IOKit/IOUserClient.h>
#include <IOKit/usb/USB.h>

//================================================================================================
//
//   Structure declarations
//
//================================================================================================
//
typedef struct IOUSBUserClientAsyncParamBlock IOUSBUserClientAsyncParamBlock;

struct IOUSBUserClientAsyncParamBlock
{
    OSAsyncReference64			fAsyncRef;
    uint32_t					fAsyncCount;
    uint32_t					fMax;
    IOMemoryDescriptor *		fMem;
    IOUSBDevRequestDesc			req;
};

typedef struct IOUSBInterfaceUserClientISOAsyncParamBlock IOUSBInterfaceUserClientISOAsyncParamBlock;
struct IOUSBInterfaceUserClientISOAsyncParamBlock
{
    OSAsyncReference64			fAsyncRef;
    uint32_t					fAsyncCount;
    mach_vm_size_t				frameLen;	// In bytes
    mach_vm_address_t           frameBase;	// In user task
    IOMemoryDescriptor *        dataMem;
    IOMemoryDescriptor *        countMem;
    uint64_t					numFrames;
    uint64_t					startFrame;
    uint64_t					options;
    IOUSBIsocFrame              frames[0];  // Must be the last one
};

class IOUSBDevice;
class IOUSBInterface;

// this class declaration may want to move to another header file (and maybe not)
class IOUSBNotification : public OSObject
{
    OSDeclareDefaultStructors(IOUSBNotification);
    
    IOUserClient *              fpIOUserClient;              // the IOUserClient object which created this IOUSBNotification
    IOUSBDevice *               fpIOUSBDevice;               // the device whose user client created this note (or the parent of the interface user client)
    IOUSBInterface *            fpIOUSBInterface;            // the interface whose user client create this note (could be NULL)
    UInt64                      fbmNotificationMask;         // a bitmask of the desired bits for this notification
    OSAsyncReference64          fAsyncRef;                   // this contains the callback routine and the refCon in user space
    UInt64                      fToken;                      // this token is unique for each user client
    
public:
    static IOUSBNotification*   withUserClient(IOUserClient *pIOUserClient);
    
    // Accessors
    inline IOUserClient *              GetIOUserClient(void)                                        {return fpIOUserClient;}
    inline IOUSBDevice *               GetIOUSBDevice(void)                                         {return fpIOUSBDevice;}
    inline IOUSBInterface *            GetIOUSBInterface(void)                                      {return fpIOUSBInterface;}
    inline UInt64                      GetNotificationMask(void)                                    {return fbmNotificationMask;}
    inline OSAsyncReference64 *        GetAsyncRefPtr(void)                                         {return &fAsyncRef;}
    inline UInt64                      GetToken(void)                                               {return fToken;}
    
    inline void                        SetIOUSBDevice(IOUSBDevice *iousbdevice)                     {fpIOUSBDevice = iousbdevice;}
    inline void                        SetIOUSBInterface(IOUSBInterface *iousbinterface)            {fpIOUSBInterface = iousbinterface;}
    inline void                        SetNotificationMask(UInt64 notificationmask)                 {fbmNotificationMask = notificationmask;}
    inline void                        SetAsyncRef(OSAsyncReference64 *pAsyncRef)                   {bcopy(pAsyncRef, &fAsyncRef, sizeof(OSAsyncReference64));}
    inline void                        SetToken(UInt64 token)                                       {fToken = token;}
    
    // public methods
    IOReturn                            SendNotification(UInt64 notificationmask, void* pToken);
};

enum {
    // values used to talk between the UserClient KEXT and a device or interface
    kUSBProcessNotificationRegisterNotification      = 1,
    kUSBProcessNotificationUnregisterNotification    = 2,
    kUSBProcessNotificationAcknowledgeNotification   = 3
};


class IOUSBUserClientLegacy : public IOUserClient
{
    OSDeclareAbstractStructors(IOUSBUserClientLegacy)
    
private:
    IOService* _provider;
    
protected:
    enum {
        kMaxExtendedDataEntriesSupported = 20
    };
    
    task_t          _task;
    void*           _securityToken;
    mach_port_t     _wakePort;
    IOCommandGate*  _commandGate;
    IOWorkLoop*     _workLoop;
    bool            _entitled;
    bool            _authorized;
    bool            _privileged;
    uint64_t        _pivilegedDeviceRequests[kMaxExtendedDataEntriesSupported];
    uint32_t		_numPrivilegedRequests;
    
    
public:
    virtual bool start(IOService* provider);
    virtual void stop(IOService* provider);
    virtual bool open(IOService* forClient, IOOptionBits options = 0, void* arg = 0);
    virtual void close(IOService* forClient, IOOptionBits options = 0);
    virtual bool terminate(IOOptionBits options = 0);
    virtual void free();
    
    virtual bool     initWithTask(task_t owningTask, void* security_id, UInt32 type, OSDictionary* properties);
    virtual IOReturn clientClose(void);
    
protected:
    static IOReturn _open(IOUSBUserClientLegacy* target, void* reference, IOExternalMethodArguments* arguments);
    virtual IOReturn openGated(IOService* forClient, IOOptionBits options, void* arg);
    
    static IOReturn _close(IOUSBUserClientLegacy* target, void* reference, IOExternalMethodArguments* arguments);
    virtual IOReturn closeGated(IOService* forClient, IOOptionBits options = 0);
    
    // TODO: is this superseded by registerNotificationPort?
    static IOReturn _setAsyncPort(IOUSBUserClientLegacy* target, void* reference, IOExternalMethodArguments* arguments);
    virtual IOReturn setAsyncPort(mach_port_t port);
    
    virtual IOReturn GetFrameNumber(IOUSBGetFrameStruct* data, UInt32* size);
    virtual IOReturn GetMicroFrameNumber(IOUSBGetFrameStruct* data, UInt32* size);
    virtual IOReturn GetFrameNumberWithTime(IOUSBGetFrameStruct* data, UInt32* size);
    
    virtual IOReturn GetConfigDescriptor(UInt8 configIndex, IOUSBConfigurationDescriptorPtr desc, UInt32* size);
    virtual IOReturn GetConfigDescriptor(UInt8 configIndex, IOMemoryDescriptor* mem, uint32_t* size);
    
    virtual IOService* GetController(void) = 0;
    virtual IOService* GetDevice(void)     = 0;
    
#pragma mark Miscellaneous
protected:
    enum tDebugLoggingMasks
    {
        kDebugLoggingAlways  = 0x0001,
        kDebugLoggingVerbose = 0x0002,
        kDebugLoggingSession = 0x0020,
        
        kDebugLoggingAssert  = 0x0100,
        kDebugLoggingKprintf = 0x10000
    };
    
    uint32_t _debugLoggingMask;
    
    virtual void requestCompletion(void* parameter, IOReturn status, uint32_t bytesTransferred);
    virtual bool isAuthorized(void);
};

#endif

#endif

                     StandardUSB.h                                                                                       0100644 0001750 0001750 00000067356 12567452451 035123  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            //
//  StandardUSB.h
//  IOUSBHostFamily
//
//  Created by Dan Wilson on 12/11/13.
//
//

#ifndef IOUSBHostFamily_StandardUSB_h
#define IOUSBHostFamily_StandardUSB_h

#include <IOKit/IOTypes.h>
#include <libkern/OSByteOrder.h>
#include <IOKit/IOReturn.h>

#pragma mark Platform endianness and bitmask macros

#define USBToHost16 OSSwapLittleToHostInt16
#define HostToUSB16 OSSwapHostToLittleInt16

#define USBToHost32 OSSwapLittleToHostInt32
#define HostToUSB32 OSSwapHostToLittleInt32

#define USBToHost64 OSSwapLittleToHostInt64
#define HostToUSB64 OSSwapHostToLittleInt64

#define StandardUSBBit(bit)                     ((uint32_t)(1) << bit)
#define StandardUSBBitRange(start, end)         (~(((uint32_t)(1) << start) - 1) & ((1 << end) | ((1 << end) - 1)))
#define StandardUSBBitRange64(start, end)       (~(((uint64_t)(1) << start) - 1) & ((1 << end) | ((1 << end) - 1)))
#define StandardUSBBitRangePhase(start, end)    (start)

#ifdef __cplusplus

#pragma mark StandardUSB namespace
namespace StandardUSB
{
    
#endif // __cplusplus
    
#pragma mark Descriptor definitions
    // USB 2.0 Table 9-5
    // USB 3.0 Table 9-6
    enum tDescriptorType
    {
        kDescriptorTypeDevice = 1,
        kDescriptorTypeConfiguration = 2,
        kDescriptorTypeString = 3,
        kDescriptorTypeInterface = 4,
        kDescriptorTypeEndpoint = 5,
        kDescriptorTypeDeviceQualifier = 6,
        kDescriptorTypeOtherSpeedConfiguration = 7,
        kDescriptorTypeInterfacePower = 8,
        kDescriptorTypeOTG = 9,
        kDescriptorTypeDebug = 10,
        kDescriptorTypeInterfaceAssociation = 11,
        kDescriptorTypeBOS = 15,
        kDescriptorTypeDeviceCapability = 16,
        kDescriptorTypeHub = 41,
        kDescriptorTypeSuperSpeedHub = 42,
        kDescriptorTypeSuperSpeedUSBEndpointCompanion = 48
    };
    
    typedef enum tDescriptorType tDescriptorType;
    
    enum tDescriptorSize
    {
        kDescriptorSize = 2,
        kDescriptorSizeDevice = 18,
        kDescriptorSizeConfiguration = 9,
        kDescriptorSizeInterface = 9,
        kDescriptorSizeEndpoint = 7,
        kDescriptorSizeDeviceQualifier = 10,
        kDescriptorSizeInterfaceAssociation = 8,
        kDescriptorSizeBOS = 5,
        kDescriptorSizeDeviceCapability = 3,
        kDescriptorSizeUSB20ExtensionCapability = 7,
        kDescriptorSizeSuperSpeedUSBDeviceCapability = 10,
        kDescriptorSizeContainerIDCapability = 20,
        kDescriptorSizeHubMinimum = 9,
        kDescriptorSizeHubMaximum = 21,
        kDescriptorSizeSuperSpeedHub = 12,
        kDescriptorSizeSuperSpeedUSBEndpointCompanion = 6,
        kDescriptorSizeLargestStandard = kDescriptorSizeHubMaximum
    };
    
    typedef enum tDescriptorSize tDescriptorSize;
    
    // USB 2.0 9.5: Descriptors
    struct Descriptor
    {
        uint8_t bLength;
        uint8_t bDescriptorType;
    } __attribute__((packed));
    
    typedef struct Descriptor Descriptor;
    
    
#ifdef __cplusplus
    // USB 2.0 9.6.1: Device
    struct DeviceDescriptor : public Descriptor
    {
#else
    struct DeviceDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint16_t    bcdUSB;
        uint8_t     bDeviceClass;
        uint8_t     bDeviceSubClass;
        uint8_t     bDeviceProtocol;
        uint8_t     bMaxPacketSize0;
        uint16_t    idVendor;
        uint16_t    idProduct;
        uint16_t    bcdDevice;
        uint8_t     iManufacturer;
        uint8_t     iProduct;
        uint8_t     iSerialNumber;
        uint8_t     bNumConfigurations;
    } __attribute__((packed));
        
    typedef struct DeviceDescriptor DeviceDescriptor;
        
    
#ifdef __cplusplus
    // USB 2.0 9.6.2: Device Qualifier
    struct DeviceQualifierDescriptor : public Descriptor
    {
#else
    struct DeviceQualifierDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint16_t    bcdUSB;
        uint8_t     bDeviceClass;
        uint8_t     bDeviceSubClass;
        uint8_t     bDeviceProtocol;
        uint8_t     bMaxPacketSize0;
        uint8_t     bNumConfigurations;
        uint8_t     bReserved;
    } __attribute__((packed));
    
    typedef struct DeviceQualifierDescriptor DeviceQualifierDescriptor;
        
        
#ifdef __cplusplus
    // USB 2.0 9.6.3: Configuration
    struct ConfigurationDescriptor : public Descriptor
    {
#else
    struct ConfigurationDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint16_t    wTotalLength;
        uint8_t     bNumInterfaces;
        uint8_t     bConfigurationValue;
        uint8_t     iConfiguration;
        uint8_t     bmAttributes;
        uint8_t     bMaxPower;
    } __attribute__((packed));
    
    typedef struct ConfigurationDescriptor ConfigurationDescriptor;
        
    
    enum
    {
        kConfigurationDescriptorAttributeRemoteWakeCapable  = StandardUSBBit(5),
        kConfigurationDescriptorAttributeSelfPowered        = StandardUSBBit(6)
    };
    
        
#ifdef __cplusplus
    // USB 2.0 9.6.5: Interface
    struct InterfaceDescriptor : public Descriptor
    {
#else
    struct InterfaceDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t     bInterfaceNumber;
        uint8_t     bAlternateSetting;
        uint8_t     bNumEndpoints;
        uint8_t     bInterfaceClass;
        uint8_t     bInterfaceSubClass;
        uint8_t     bInterfaceProtocol;
        uint8_t     iInterface;
    } __attribute__((packed));
    
    typedef struct InterfaceDescriptor InterfaceDescriptor;
        
    
#ifdef __cplusplus
    // USB 2.0 9.6.6: Endpoint
    struct EndpointDescriptor : public Descriptor
    {
#else
    struct EndpointDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t     bEndpointAddress;
        uint8_t     bmAttributes;
        uint16_t    wMaxPacketSize;
        uint8_t     bInterval;
    } __attribute__((packed));
        
    typedef struct EndpointDescriptor EndpointDescriptor;
    
    enum
    {
        kEndpointDescriptorNumber                  = StandardUSBBitRange(0, 3),
        kEndpointDescriptorEndpointAddressReserved = StandardUSBBitRange(4, 6),
        kEndpointDescriptorDirection               = StandardUSBBit(7),
        kEndpointDescriptorDirectionPhase          = StandardUSBBitRangePhase(7, 7),
        kEndpointDescriptorDirectionOut            = 0,
        kEndpointDescriptorDirectionIn             = StandardUSBBit(7),
        
        kEndpointDescriptorTransferType                    = StandardUSBBitRange(0, 1),
        kEndpointDescriptorTransferTypePhase               = StandardUSBBitRangePhase(0, 1),
        kEndpointDescriptorTransferTypeControl             = (0 << StandardUSBBitRangePhase(0, 1)),
        kEndpointDescriptorTransferTypeIsochronous         = (1 << StandardUSBBitRangePhase(0, 1)),
        kEndpointDescriptorTransferTypeBulk                = (2 << StandardUSBBitRangePhase(0, 1)),
        kEndpointDescriptorTransferTypeInterrupt           = (3 << StandardUSBBitRangePhase(0, 1)),
        kEndpointDescriptorSynchronizationType             = StandardUSBBitRange(2, 3),
        kEndpointDescriptorSynchronizationTypeNone         = (0 << StandardUSBBitRangePhase(2, 3)),
        kEndpointDescriptorSynchronizationTypeAsynchronous = (1 << StandardUSBBitRangePhase(2, 3)),
        kEndpointDescriptorSynchronizationTypeAdaptive     = (2 << StandardUSBBitRangePhase(2, 3)),
        kEndpointDescriptorSynchronizationTypeSynchronous  = (3 << StandardUSBBitRangePhase(2, 3)),
        kEndpointDescriptorUsageType                       = StandardUSBBitRange(4, 5),
        kEndpointDescriptorUsageTypeInterruptPeriodic      = (0 << StandardUSBBitRangePhase(4, 5)),
        kEndpointDescriptorUsageTypeInterruptNotification  = (1 << StandardUSBBitRangePhase(4, 5)),
        kEndpointDescriptorUsageTypeInterruptReserved1     = (2 << StandardUSBBitRangePhase(4, 5)),
        kEndpointDescriptorUsageTypeInterruptReserved2     = (3 << StandardUSBBitRangePhase(4, 5)),
        kEndpointDescriptorUsageTypeIsocData               = (0 << StandardUSBBitRangePhase(4, 5)),
        kEndpointDescriptorUsageTypeIsocFeedback           = (1 << StandardUSBBitRangePhase(4, 5)),
        kEndpointDescriptorUsageTypeIsocImplicit           = (2 << StandardUSBBitRangePhase(4, 5)),
        kEndpointDescriptorUsageTypeIsocReserved           = (3 << StandardUSBBitRangePhase(4, 5)),
        
        kEndpointDescriptorPacketSize          = StandardUSBBitRange(0, 10),
        kEndpointDescriptorPacketSizePhase     = StandardUSBBitRangePhase(0, 10),
        kEndpointDescriptorPacketSizeMult      = StandardUSBBitRange(11, 12),
        kEndpointDescriptorPacketSizeMultPhase = StandardUSBBitRangePhase(11, 12),
        kEndpointDescriptorReserved            = StandardUSBBitRange(13, 15),
        kEndpointDescriptorReservedPhase       = StandardUSBBitRangePhase(13, 15)
    };
    
    // USB Language Identifiers 1.0
    enum tLanguageID
    {
        kLanguageIDEnglishUS = 0x0409
    };
    
    typedef enum tLanguageID tLanguageID;
        
        
#ifdef __cplusplus
    // USB 2.0 9.6.7: String
    struct StringDescriptor : public Descriptor
    {
#else
    struct StringDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t     bString[1];
    } __attribute__((packed));
        
    typedef struct StringDescriptor StringDescriptor;
    
    
    // USB 3.0 Table 9-13
    enum tDeviceCapabilityType
    {
        kDeviceCapabilityTypeWireless       = 1,
        kDeviceCapabilityTypeUSB20Extension = 2,
        kDeviceCapabilityTypeSuperSpeed     = 3,
        kDeviceCapabilityTypeContainerID    = 4
    };
    
    typedef enum tDeviceCapabilityType tDeviceCapabilityType;
        
    
#ifdef __cplusplus
    // USB 3.0 9.6.2: Binary Device Object Store (BOS)
    struct BOSDescriptor : public Descriptor
    {
#else
    struct BOSDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint16_t    wTotalLength;
        uint8_t     bNumDeviceCaps;
    } __attribute__((packed));
        
    typedef struct BOSDescriptor BOSDescriptor;
        
        
#ifdef __cplusplus
    // USB 3.0 9.6.2: Binary Device Object Store (BOS)
    struct DeviceCapabilityDescriptor : public Descriptor
    {
#else
    struct DeviceCapabilityDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t     bDevCapabilityType;
    } __attribute__((packed));
        
    typedef struct DeviceCapabilityDescriptor DeviceCapabilityDescriptor;
        
    
#ifdef __cplusplus
    // USB 3.0 9.6.2.1: USB 2.0 Extension
    struct USB20ExtensionCapabilityDescriptor : public DeviceCapabilityDescriptor
    {
#else
    struct USB20ExtensionCapabilityDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint32_t    bmAttributes;
    } __attribute__((packed));
        
    typedef struct USB20ExtensionCapabilityDescriptor USB20ExtensionCapabilityDescriptor;
        
    
    enum
    {
        kUSB20ExtensionCapabilityLPM = StandardUSBBit(1)
    };
    
        
#ifdef __cplusplus
    // USB 3.0 9.6.2.2: SuperSpeed USB Device Capability
    struct SuperSpeedUSBDeviceCapabilityDescriptor : public DeviceCapabilityDescriptor
    {
#else
    struct SuperSpeedUSBDeviceCapabilityDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t     bmAttributes;
        uint16_t    wSpeedsSupported;
        uint8_t     bFunctionalitySupport;
        uint8_t     bU1DevExitLat;
        uint16_t    bU2DevExitLat;
    } __attribute__((packed));
        
    typedef struct SuperSpeedUSBDeviceCapabilityDescriptor SuperSpeedUSBDeviceCapabilityDescriptor;
        
    
    enum
    {
        kSuperSpeedDeviceCapabilityLTM = StandardUSBBit(1),
        
        kSuperSpeedDeviceCapabilityLowSpeed  = StandardUSBBit(0),
        kSuperSpeedDeviceCapabilityFullSpeed = StandardUSBBit(1),
        kSuperSpeedDeviceCapabilityHighSpeed = StandardUSBBit(2),
        kSuperSpeedDeviceCapability5Gb       = StandardUSBBit(3),
        
        kSuperSpeedDeviceCapabilitySupportLowSpeed  = 0,
        kSuperSpeedDeviceCapabilitySupportFullSpeed = 1,
        kSuperSpeedDeviceCapabilitySupportHighSpeed = 2,
        kSuperSpeedDeviceCapabilitySupport5Gb       = 3,
        
        kSuperSpeedDeviceCapabilityU1DevExitLatMax = 0xa,
        kSuperSpeedDeviceCapabilityU2DevExitLatMax = 0x7ff
    };
    
        
#ifdef __cplusplus
    // USB 3.0 9.6.2.3: Container ID
    struct ContainerIDCapabilityDescriptor : public DeviceCapabilityDescriptor
    {
#else
    struct ContainerIDCapabilityDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t  bReserved;
        uint32_t containerID[4];
    } __attribute__((packed));
        
    typedef struct ContainerIDCapabilityDescriptor ContainerIDCapabilityDescriptor;
        
    
#ifdef __cplusplus
    // USB 3.0 9.6.4: Interface Association
    struct InterfaceAssociationDescriptor: public Descriptor
    {
#else
    struct InterfaceAssociationDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t     bFirstInterface;
        uint8_t     bInterfaceCount;
        uint8_t     bFunctionClass;
        uint8_t     bFunctionSubClass;
        uint8_t     bFunctionProtocol;
        uint8_t     iFunction;
    } __attribute__((packed));
        
    typedef struct InterfaceAssociationDescriptor InterfaceAssociationDescriptor;
        
    
#ifdef __cplusplus
    // USB 3.0 9.6.7: SuperSpeed Endpoint Companion
    struct SuperSpeedEndpointCompanionDescriptor : public Descriptor
    {
#else
    struct SuperSpeedEndpointCompanionDescriptor
    {
        uint8_t     bLength;
        uint8_t     bDescriptorType;
#endif
        uint8_t  bMaxBurst;
        uint8_t  bmAttributes;
        uint16_t wBytesPerInterval;
    } __attribute__((packed));
        
    typedef struct SuperSpeedEndpointCompanionDescriptor SuperSpeedEndpointCompanionDescriptor;
        
    
    enum
    {
        kSuperSpeedEndpointCompanionDescriptorMaxBurst      = StandardUSBBitRange(0, 4),
        kSuperSpeedEndpointCompanionDescriptorMaxBurstPhase = StandardUSBBitRangePhase(0, 4),
        
        kSuperSpeedEndpointCompanionDescriptorBulkMaxStreams      = StandardUSBBitRange(0, 4),
        kSuperSpeedEndpointCompanionDescriptorBulkMaxStreamsPhase = StandardUSBBitRangePhase(0, 4),
        kSuperSpeedEndpointCompanionDescriptorBulkReserved        = StandardUSBBitRange(5, 7),
        kSuperSpeedEndpointCompanionDescriptorBulkReservedPhase   = StandardUSBBitRangePhase(5, 7),
        kSuperSpeedEndpointCompanionDescriptorIsocMult            = StandardUSBBitRange(0, 1),
        kSuperSpeedEndpointCompanionDescriptorIsocMultPhase       = StandardUSBBitRangePhase(0, 1),
        kSuperSpeedEndpointCompanionDescriptorIsocReserved        = StandardUSBBitRange(2, 7),
        kSuperSpeedEndpointCompanionDescriptorIsocReservedPhase   = StandardUSBBitRangePhase(2, 7)
    };
    
        
#ifdef __cplusplus
    // USB 2.0 11.23.2.1: Hub Descriptor
    struct HubDescriptor : public Descriptor
    {
#else
    struct HubDescriptor
    {
        uint8_t  bLength;
        uint8_t  bDescriptorType;
#endif
        uint8_t  bNumberPorts;
        uint16_t wHubCharacteristics;
        uint8_t  bPowerOnToPowerGood;
        uint8_t  bHubControllerCurrent;
        uint8_t  deviceRemovable[2];    // Technically variable size
        uint8_t  reserved[2];           // Unused
    } __attribute__((packed));
        
    typedef struct HubDescriptor HubDescriptor;
        
    
#ifdef __cplusplus
    // USB 3.0 10.13.2.1: SuperSpeed Hub Descriptor
    struct SuperSpeedHubDescriptor : public Descriptor
    {
#else
    struct SuperSpeedHubDescriptor
    {
        uint8_t  bLength;
        uint8_t  bDescriptorType;
#endif
        uint8_t  bNumberPorts;
        uint16_t wHubCharacteristics;
        uint8_t  bPowerOnToPowerGood;
        uint8_t  bHubControllerCurrent;
        uint8_t  bHubDecodeLatency;
        uint16_t wHubDelay;
        uint16_t deviceRemovable;
    } __attribute__((packed));
        
    typedef struct SuperSpeedHubDescriptor SuperSpeedHubDescriptor;
        
    
    enum
    {
        kSuperSpeedHubCharacteristicsPowerSwitchingMask       = StandardUSBBitRange(0, 1),
        kSuperSpeedHubCharacteristicsPowerSwitchingGanged     = (0 << StandardUSBBitRangePhase(0, 1)),
        kSuperSpeedHubCharacteristicsPowerSwitchingIndividual = (1 << StandardUSBBitRangePhase(0, 1)),
        kSuperSpeedHubCharacteristicsCompoundDevice           = StandardUSBBit(2),
        kSuperSpeedHubCharacteristicsOverCurrentMask          = StandardUSBBitRange(3, 4),
        kSuperSpeedHubCharacteristicsOverCurrentGlobal        = (0 << StandardUSBBitRangePhase(3, 4)),
        kSuperSpeedHubCharacteristicsOverCurrentIndividual    = (1 << StandardUSBBitRangePhase(3, 4)),
        kSuperSpeedHubCharacteristicsReserved                 = StandardUSBBitRange(5, 15),
        
        kSuperSpeedHubDecodeLatencyMax = 10,
        kSuperSpeedHubDelayMax         = 400
    };
    
#ifdef __cplusplus
#pragma mark Descriptor list parsing
    const Descriptor* getNextDescriptor(const ConfigurationDescriptor* configurationDescriptor, const Descriptor* currentDescriptor);
    const Descriptor* getNextDescriptorWithType(const ConfigurationDescriptor* configurationDescriptor, const Descriptor* currentDescriptor, const uint8_t type);
    const Descriptor* getNextAssociatedDescriptor(const ConfigurationDescriptor* configurationDescriptor, const Descriptor* parentDescriptor, const Descriptor* currentDescriptor);
    const Descriptor* getNextAssociatedDescriptorWithType(const ConfigurationDescriptor* configurationDescriptor, const Descriptor* parentDescriptor, const Descriptor* currentDescriptor, const uint8_t type);
    const InterfaceAssociationDescriptor* getNextInterfaceAssociationDescriptor(const ConfigurationDescriptor* configurationDescriptor, const Descriptor* currentDescriptor);
    const InterfaceDescriptor* getNextInterfaceDescriptor(const ConfigurationDescriptor* configurationDescriptor, const Descriptor* currentDescriptor);
    const EndpointDescriptor* getNextEndpointDescriptor(const ConfigurationDescriptor* configurationDescriptor, const InterfaceDescriptor* interfaceDescriptor, const Descriptor* currentDescriptor);
    
    const DeviceCapabilityDescriptor* getNextCapabilityDescriptor(const BOSDescriptor* bosDescriptor, const DeviceCapabilityDescriptor* currentDescriptor);
    const DeviceCapabilityDescriptor* getNextCapabilityDescriptorWithType(const BOSDescriptor* bosDescriptor, const DeviceCapabilityDescriptor* currentDescriptor, const uint8_t type);
    const USB20ExtensionCapabilityDescriptor* getUSB20ExtensionDeviceCapabilityDescriptor(const BOSDescriptor* bosDescriptor);
    const SuperSpeedUSBDeviceCapabilityDescriptor* getSuperSpeedDeviceCapabilityDescriptor(const BOSDescriptor* bosDescriptor);
    const ContainerIDCapabilityDescriptor* getContainerIDDescriptor(const BOSDescriptor* bosDescriptor);
    
#pragma mark Device descriptor parsing
    bool validateDeviceDescriptor(uint32_t usbDeviceSpeed, const DeviceDescriptor* descriptor);
    
#pragma mark Endpoint descriptor parsing
    uint8_t getEndpointDirection(const EndpointDescriptor* descriptor);
    uint8_t getEndpointAddress(const EndpointDescriptor* descriptor);
    uint8_t getEndpointNumber(const EndpointDescriptor* descriptor);
    uint8_t getEndpointType(const EndpointDescriptor* descriptor);
    bool validateEndpointMaxPacketSize(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor);
    uint16_t getEndpointMaxPacketSize(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor);
    bool validateEndpointBurstSize(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor, const SuperSpeedEndpointCompanionDescriptor* companionDescriptor);
    uint16_t getEndpointBurstSize(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor, const SuperSpeedEndpointCompanionDescriptor* companionDescriptor);
    bool validateEndpointInterval(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor);
    uint32_t getEndpointIntervalEncodedMicroframes(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor);
    uint32_t getEndpointIntervalMicroframes(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor);
    uint32_t getEndpointIntervalFrames(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor);
    uint32_t getEndpointMaxStreamsEncoded(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor, const SuperSpeedEndpointCompanionDescriptor* companionDescriptor);
    uint32_t getEndpointMaxStreams(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor, const SuperSpeedEndpointCompanionDescriptor* companionDescriptor);
    uint32_t getConfigurationMaxPowerMilliAmps(uint32_t usbDeviceSpeed, const ConfigurationDescriptor* descriptor);
    bool validateEndpointDescriptor(uint32_t usbDeviceSpeed, const EndpointDescriptor* descriptor, const SuperSpeedEndpointCompanionDescriptor* companionDescriptor);
    
#pragma mark String descriptor parsing
    /*!
     * @brief Convert a USB string descriptor to a UTF8 character string
     *
     * @discussion This method uses utf8_encodestr with appropriate options to convert a USB string descriptor to a UTF8 string.
     *
     * @param stringDescriptor Descriptor to convert
     *
     * @param stringBuffer Buffer to write the UTF8 string to
     *
     * @param length Reference to size_t.  As input it is the size stringBuffer.  As output it is the number of character written to stringBuffer.
     *
     * @return IOReturn result code.  kIOReturnSuccess if any portion of the string could be converted and placed in stringBuffer.  kIOReturnError if the
     * string descriptor contains characters that cannot be converted to UTF8
     */
    IOReturn stringDescriptorToUTF8(const StringDescriptor* stringDescriptor, char* stringBuffer, size_t& length);
    
#pragma mark Capability descriptor parsing
    bool validateDeviceCapabilityDescriptors(const BOSDescriptor* bosDescriptor);
        
#endif // __cplusplus
    
#pragma mark Device requests
    // USB 2.0 9.3: USB Device Requests
    struct DeviceRequest
    {
        uint8_t     bmRequestType;
        uint8_t     bRequest;
        uint16_t    wValue;
        uint16_t    wIndex;
        uint16_t    wLength;
    } __attribute__((packed));
        
    typedef struct DeviceRequest DeviceRequest;
    
    enum
    {
        kDeviceRequestSize              = 8,
        kDeviceRequestDirectionMask     = StandardUSBBit(7),
        kDeviceRequestDirectionPhase    = StandardUSBBitRangePhase(7, 7),
        kDeviceRequestDirectionOut      = (0 << kDeviceRequestDirectionPhase),
        kDeviceRequestDirectionIn       = (1 << kDeviceRequestDirectionPhase),
        kDeviceRequestTypeMask          = StandardUSBBitRange(5, 6),
        kDeviceRequestTypePhase         = StandardUSBBitRangePhase(5, 6),
        kDeviceRequestTypeStandard      = (0 << kDeviceRequestTypePhase),
        kDeviceRequestTypeClass         = (1 << kDeviceRequestTypePhase),
        kDeviceRequestTypeVendor        = (2 << kDeviceRequestTypePhase),
        kDeviceRequestRecipientMask     = StandardUSBBitRange(0, 4),
        kDeviceRequestRecipientPhase    = StandardUSBBitRangePhase(0, 4),
        kDeviceRequestRecipientDevice   = (0 << kDeviceRequestRecipientPhase),
        kDeviceRequestRecipientInterface= (1 << kDeviceRequestRecipientPhase),
        kDeviceRequestRecipientEndpoint = (2 << kDeviceRequestRecipientPhase),
        kDeviceRequestRecipientOther    = (3 << kDeviceRequestRecipientPhase),
    };
    
    // USB 2.0 9.4: Standard Device Requests
    // USB 3.0 9.4: Standard Device Requests
    enum
    {
        kDeviceRequestGetStatus             = 0,
        kDeviceRequestClearFeature          = 1,
        kDeviceRequestGetState              = 2,
        kDeviceRequestSetFeature            = 3,
        kDeviceRequestSetAddress            = 5,
        kDeviceRequestGetDescriptor         = 6,
        kDeviceRequestSetDescriptor         = 7,
        kDeviceRequestGetConfiguration      = 8,
        kDeviceRequestSetConfiguration      = 9,
        kDeviceRequestGetInterface          = 10,
        kDeviceRequestSetInterface          = 11,
        kDeviceRequestSynchFrame            = 12,
        kDeviceRequestSetSel                = 48,
        kDeviceRequestSetIsochronousDelay   = 49
    };
    
    // USB 2.0 9.4.5: Get Status
    // USB 3.0 9.4.5: Get Status
    enum
    {
        kDeviceStatusSelfPowered            = StandardUSBBit(0),
        kDeviceStatusRemoteWakeEnable       = StandardUSBBit(1),
        kDeviceStatusU1Enable               = StandardUSBBit(2),
        kDeviceStatusU2Enable               = StandardUSBBit(3),
        kDeviceStatusLTMEnable              = StandardUSBBit(4),
        
        kInterfaceStatusRemoteWakeCapable   = StandardUSBBit(0),
        kInterfaceStatusRemoteWakeEnable    = StandardUSBBit(1),
        
        kEndpointStatusHalt                 = StandardUSBBit(0)
    };
    
    // USB 2.0 Table 9-6: Standard Feature Selectors
    // USB 3.0 Table 9-7: Standard Feature Selectors
    enum
    {
        kDeviceFeatureSelectorRemoteWakeup  = 1,
        kDeviceFeatureSelectorTestMode      = 2,
        kDeviceFeatureSelectorU1Enable      = 48,
        kDeviceFeatureSelectorU2Enable      = 49,
        kDeviceFeatureSelectorLTMEnable     = 50,
        
        kInterfaceFeatureSelectorSuspend    = 0,
        
        kEndpointFeatureSelectorStall       = 0,
    };
    
    // USB 3.0 Table 9-8: Suspend Options
    enum
    {
        kInterfaceSuspendLowPower           = StandardUSBBit(0),
        kInterfaceSuspendRemoteWakeEnable   = StandardUSBBit(1)
    };
        
#ifdef __cplusplus
}


namespace StandardUSB20
{
    enum tBusCurrent
    {
        kBusCurrentMinimum = 100,
        kBusCurrentDefault = 500
    };
}

namespace StandardUSB30
{
    enum tBusCurrent
    {
        kBusCurrentMinimum = 150,
        kBusCurrentDefault = 900
    };

    // USB 3.0 Table 6-21
    enum tResetTimeout
    {
        kResetMinimumTimeout                    = 80,
        kResetTypicalTimeout                    = 100,
        kResetMaximumTimeout                    = 120,
        kResetMaximumWithMarginTimeout          = 150
    };

    // USB 3.0 Table 7-12
    enum tLinkStateTimeout
    {
        kLinkStateSSInactiveQuietTimeout        = 12,
        kLinkStateRxDetectQuietTimeout          = 12,
        kLinkStatePollingLFPSTimeout            = 360,
        kLinkStatePollingActiveTimeout          = 12,
        kLinkStatePollingConfigurationTimeout   = 12,
        kLinkStatePollingIdleTimeout            = 2,
        kLinkStateU0RecoveryTimeout             = 1,
        kLinkStateU0LTimeout                    = 0,        // 10 microseconds
        kLinkStateU1NoLFPSResponseTimeout       = 2,
        kLinkStateU1PingTimeout                 = 300,
        kLinkStateU2NoLFPSResponseTimeout       = 2,
        kLinKStateU2RxDetectDelay               = 100,
        kLinkStateU3NoLFPSResponseTimeout       = 10,
        kLinkStateU3WakeupRetryDelay            = 100,
        kLinkStateU3RxDetectDelay               = 100,
        kLinkStateRecoveryActiveTimeout         = 12,
        kLinkStateRecoveryConfigurationTimeout  = 6,
        kLinkStateRecoveryIdleTimeout           = 2,
        kLinkStateLoopbackExitTimeout           = 2,
        kLinkStateHotResetActiveTimeout         = 12,
        kLinkStateHotResetExistTimeout          = 2,

        // USB 3.0 7.5.4
        kLinkStatePollingDeadline               = (kLinkStatePollingLFPSTimeout + 1 + kLinkStatePollingActiveTimeout + kLinkStatePollingConfigurationTimeout + kLinkStatePollingIdleTimeout),

        // USB 3.0 7.5.9 and 7.5.10
        kLinkStateSSResumeDeadline              = (kLinkStateU3NoLFPSResponseTimeout + kLinkStateRecoveryActiveTimeout + kLinkStateRecoveryConfigurationTimeout + kLinkStateRecoveryIdleTimeout),
    };
}
#endif // __cplusplus

#endif
                                                                                                                                                                                                                                                                                  USB.h                                                                                               0100644 0001750 0001750 00000201521 12567452726 033427  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright  1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _USB_H
#define _USB_H

#if KERNEL
	#include <libkern/OSByteOrder.h>
	#include <IOKit/IOMemoryDescriptor.h>

#ifndef __IOUSBFAMILY__
#warning "Deprecated header file.  See IOUSBHostFamily for USB-Host KPI."
#endif

#else
	#include <libkern/OSByteOrder.h>
#endif

#include <IOKit/IOTypes.h>

#if !defined(__USB__)
#    include <IOKit/usb/USBSpec.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

    /*!
    @header		USB.h
     @abstract	Public Interfaces to the USB implementation in Mac OS X.
     @discussion	This header file contains definitions and structures that are used in the different USB API's in Mac OS X, both in the kernel and in the user space.
     */

    /*!
    @defineblock	Endian conversion definitions
     @discussion The USB API's use a convention of specifying parameters in the host order.  The USB spec specifies that multi-byte items should be
     formatted in little endian order.  The following macros allow one to translate multi-byte values from Host order to USB order and vice versa.  There are separate macros for
     in-kernel use and for user space use.
     */
#define USBToHostWord OSSwapLittleToHostInt16
#define HostToUSBWord OSSwapHostToLittleInt16
#define USBToHostLong OSSwapLittleToHostInt32
#define HostToUSBLong OSSwapHostToLittleInt32
    /*! @/defineblock */

#ifndef USBBitRange
#define USBBitRange(start, end)				\
(								\
((((UInt32) 0xFFFFFFFF) << (31 - (end))) >>		\
((31 - (end)) + (start))) <<				\
(start)							\
)
#endif
	
#ifndef USBBitRangePhase
#define USBBitRangePhase(start, end)				\
(start)
#endif
	
    /*!
    @enum Miscellaneous Constants
    @discussion 
    */
    enum {
		kUSBDeviceIDShift = 7,
		kUSBMaxDevices = 128,
		kUSBMaxDevice = kUSBMaxDevices-1,
		kUSBDeviceIDMask = 0x7f,
        kUSBTooManyDevicesAddress = 0xfffe,
		
		kUSBPipeIDMask = 0xf,
		kUSBMaxPipes = 32,	// In and Out pipes can have same pipe number.
		
		kUSBInterfaceIDShift = 8,
		kUSBMaxInterfaces = 1 << kUSBInterfaceIDShift,
		kUSBInterfaceIDMask = kUSBMaxInterfaces-1,
		
		kUSBEndPtShift = 7,
		kUSBDeviceMask = ((1 << kUSBEndPtShift) -1),
		
		kUSBNoPipeIdx = -1,
        
#ifndef __OPEN_SOURCE__
        // In order to ameliorate the effects of PCI Pause on drivers that do not subscribe to the USB Notifications for it, we have decided to sleep threads that come into the UIM
        // while we are in PCI Pause.  We will wake those threads up after the root hub drivers are back ON.  However, we needed a way to detect that an I/O was coming from user space.
        // One way to solve that would be to power manage the user client and do the sleep/wake there, but that was a big undertaking.  Another way is for the user client to somehow
        // let the UIM know through some APIs.  We decided on a quick way by using bits that are part of the API to communicate that the request is coming from user space.  For device
        // requests we use the wLenDone field, a 32-bit quantity, but whose maximum value is only 16 bits.  Same goes for the streamID of bulk requests.  Those bits are set by the user
        // client and cleared by the controller after checking them.  If they are set and PCI Pause is active, we will sleep that request.
#endif
		kUSBUCRequestWithoutUSBNotificationMask = (1 << 30),
		kUSBEndpointTransferTypeUCMask			= (1 << 7),
		
		// Constants for streams
		kUSBStream0 					= 0,
		kUSBMaxStream 					= 65533,
		kUSBPRimeStream 				= 0xfffe,
		kUSBNoStream 					= 0xffff,
		kUSBAllStreams 					= 0xffffffff, 		// Obsolete, use kUSBStreamIDAllStreamsMask
		kUSBStreamIDMask				= 0xffff,
		kUSBStreamIDAllStreamsMask		= (1 << 31)
	};

/*!
@enum bRequest Shifts and Masks
@discussion These are used to create the macro to encode the bRequest filed of a Device Request
*/
enum {
    kUSBRqDirnShift = 7,
    kUSBRqDirnMask = 1,

    kUSBRqTypeShift = 5,
    kUSBRqTypeMask = 3,

    kUSBRqRecipientMask = 0X1F
};

/*!
@defined USBmakebmRequestType 
@discussion Macro to encode the bRequest field of a Device Request.  It is used when constructing an IOUSBDevRequest.
*/
#define USBmakebmRequestType(direction, type, recipient)		\
    (((direction & kUSBRqDirnMask) << kUSBRqDirnShift) |			\
    ((type & kUSBRqTypeMask) << kUSBRqTypeShift) |			\
    (recipient & kUSBRqRecipientMask))

/*!
@enum kUSBMaxIsocFrameReqCount 
@discussion Maximum size in bytes allowed for one Isochronous frame
*/
enum {
    kUSBMaxFSIsocEndpointReqCount = 1023,	// max size (bytes) of any one Isoc frame for 1 FS endpoint
	kUSBMaxHSIsocEndpointReqCount = 3072,	// max size (bytes) of any one Isoc frame for 1 HS endpoint
	kUSBMaxHSIsocFrameCount = 7168			// max size (bytes) of all Isoc transfers in a HS frame
};

/*!
@defined EncodeRequest 
@discussion Macro that encodes the bRequest and bRequestType fields of a IOUSBDevRequest into a single value.  It is useful when one needs
to know what type of request the IOUSBDevRequest encodes and simplifies comparisons.
*/
#define EncodeRequest(request, direction, type, recipient)		\
    (((UInt16)request << 8) +	    					\
              ((UInt16)recipient +					\
                        ((UInt16)type << kUSBRqTypeShift) +		\
                        ((UInt16)direction << kUSBRqDirnShift)))


/*!
@enum Standard Device Requests
@discussion Encoding of the standard device requests.
<tt>
<pre><b>
bmRequestType bRequest          wValue        wIndex     wLength Data</b>
00000000B     CLEAR_FEATURE     Feature       Zero       Zero    None (device)
00000001B                       Feature       Interface  Zero    None (Interface)
00000010B                       Feature       Endpoint   Zero    None (Endpoint)

10000000B     GET_CONFIGURATION Zero          Zero       One     Configuration
10000000B     GET_DESCRIPTOR    Type          LangID     Length  Descriptor
10000001B     GET_INTERFACE     Zero          Interface  One     Alternate

10000000B     GET_STATUS        Zero          Zero       Two     status (device)
10000001B                       Zero          Interface  Two     status (Interface)
10000010B                       Zero          Endpoint   Two     status (Endpoint)

00000000B     SET_ADDRESS       Address       Zero       Zero    None
00000000B     SET_CONFIGURATION Configuration Zero       Zero    None
00000000B     SET_DESCRIPTOR    Type          LangID     Length  Descriptor

00000000B     SET_FEATURE       Feature       Zero       Zero    None (device)
00000001B                       Feature       Interface  Zero    None (Interface)
00000010B                       Feature       Endpoint   Zero    None (Endpoint)

00000001B     SET_INTERFACE     Alternate     Interface  Zero    None
10000010B     SYNCH_FRAME       Zero          Endpoint   Two     Frame Number
</pre>
</tt>
*/
enum {
    kClearDeviceFeature     = EncodeRequest(kUSBRqClearFeature,  kUSBOut, kUSBStandard, kUSBDevice),
    kClearInterfaceFeature  = EncodeRequest(kUSBRqClearFeature,  kUSBOut, kUSBStandard, kUSBInterface),
    kClearEndpointFeature   = EncodeRequest(kUSBRqClearFeature,  kUSBOut, kUSBStandard, kUSBEndpoint),
    kGetConfiguration       = EncodeRequest(kUSBRqGetConfig,     kUSBIn,  kUSBStandard, kUSBDevice),
    kGetDescriptor          = EncodeRequest(kUSBRqGetDescriptor, kUSBIn,  kUSBStandard, kUSBDevice),
    kGetInterface           = EncodeRequest(kUSBRqGetInterface,  kUSBIn,  kUSBStandard, kUSBInterface),
    kGetDeviceStatus        = EncodeRequest(kUSBRqGetStatus,     kUSBIn,  kUSBStandard, kUSBDevice),
    kGetInterfaceStatus     = EncodeRequest(kUSBRqGetStatus,     kUSBIn,  kUSBStandard, kUSBInterface),
    kGetEndpointStatus      = EncodeRequest(kUSBRqGetStatus,     kUSBIn,  kUSBStandard, kUSBEndpoint),
    kSetAddress             = EncodeRequest(kUSBRqSetAddress,    kUSBOut, kUSBStandard, kUSBDevice),
    kSetConfiguration       = EncodeRequest(kUSBRqSetConfig,     kUSBOut, kUSBStandard, kUSBDevice),
    kSetDescriptor          = EncodeRequest(kUSBRqSetDescriptor, kUSBOut, kUSBStandard, kUSBDevice),
    kSetDeviceFeature       = EncodeRequest(kUSBRqSetFeature,    kUSBOut, kUSBStandard, kUSBDevice),
    kSetInterfaceFeature    = EncodeRequest(kUSBRqSetFeature,    kUSBOut, kUSBStandard, kUSBInterface),
    kSetEndpointFeature     = EncodeRequest(kUSBRqSetFeature,    kUSBOut, kUSBStandard, kUSBEndpoint),
    kSetInterface           = EncodeRequest(kUSBRqSetInterface,  kUSBOut, kUSBStandard, kUSBInterface),
    kSyncFrame              = EncodeRequest(kUSBRqSyncFrame,     kUSBIn,  kUSBStandard, kUSBEndpoint),
};

/*!
@defined kCallInterfaceOpenWithGate
 @discussion If the USB Device has this property, drivers for any of its interfaces will have their handleOpen method called while holding the workloop gate.
 */
#define kCallInterfaceOpenWithGate	"kCallInterfaceOpenWithGate"

// TYPES

typedef UInt16 USBDeviceAddress;

typedef uint32_t USBPhysicalAddress32;

/*!
    @typedef IOUSBIsocFrame
    @discussion Structure used to encode information about each isoc frame.
    @param frStatus Returns status associated with the frame.
    @param frReqCount Input specifiying how many bytes to read or write.
    @param frActCount Actual # of bytes transferred.
*/
typedef struct IOUSBIsocFrame {
    IOReturn                        frStatus;
    UInt16                          frReqCount;
    UInt16                          frActCount;
} IOUSBIsocFrame;


/*!
    @typedef IOUSBLowLatencyIsocFrame
    @discussion    Structure used to encode information about each isoc frame that is processed
    at hardware interrupt time (low latency).
    @param frStatus Returns status associated with the frame.
    @param frReqCount Input specifiying how many bytes to read or write.
    @param frActCount Actual # of bytes transferred.
    @param frTimeStamp Time stamp that indicates time when frame was procesed.
*/
struct IOUSBLowLatencyIsocFrame {
    IOReturn                        frStatus;
    UInt16                          frReqCount;
    UInt16                          frActCount;
    AbsoluteTime		    frTimeStamp;
};
typedef struct IOUSBLowLatencyIsocFrame IOUSBLowLatencyIsocFrame;

/*!
@typedef IOUSBCompletionAction
 @discussion Function called when USB I/O completes.
 @param target The target specified in the IOUSBCompletion struct.
 @param parameter The parameter specified in the IOUSBCompletion struct.
 @param status Completion status.
 @param bufferSizeRemaining Bytes left to be transferred.
 */
typedef void (*IOUSBCompletionAction)(
                                      void *			target,
                                      void *			parameter,
                                      IOReturn		status,
                                      UInt32			bufferSizeRemaining);

/*!
@typedef IOUSBCompletionActionWithTimeStamp
 @discussion Function called when USB I/O completes.
 @param target The target specified in the IOUSBCompletion struct.
 @param parameter The parameter specified in the IOUSBCompletion struct.
 @param status Completion status.
 @param bufferSizeRemaining Bytes left to be transferred.
 @param timeStamp Time at which the transaction was processed.
 */
typedef void (*IOUSBCompletionActionWithTimeStamp)(
                                      void *		target,
                                      void *		parameter,
                                      IOReturn		status,
                                      UInt32		bufferSizeRemaining,
                                      AbsoluteTime	timeStamp);

/*!
    @typedef IOUSBIsocCompletionAction
    @discussion Function called when Isochronous USB I/O completes.
    @param target The target specified in the IOUSBIsocCompletionn struct.
    @param parameter The parameter specified in the IOUSBIsocCompletion struct.
    @param status Completion status.
    @param pFrames Pointer to the frame list containing the status for each frame transferred.
*/
typedef void (*IOUSBIsocCompletionAction)(
                void *			target,
                void *			parameter,
                IOReturn		status,
                IOUSBIsocFrame		*pFrames);

/*!
    @typedef IOUSBLowLatencyIsocCompletionAction
    @discussion Function called when Low Latency Isochronous USB I/O completes.
    @param target The target specified in the IOUSBLowLatencyIsocCompletion struct.
    @param parameter The parameter specified in the IOUSBLowLatencyIsocCompletion struct.
    @param status Completion status.
    @param pFrames Pointer to the low latency frame list containing the status for each frame transferred.
*/
typedef void (*IOUSBLowLatencyIsocCompletionAction)(
                void *				target,
                void *				parameter,
                IOReturn			status,
                IOUSBLowLatencyIsocFrame	*pFrames);

/*!
@typedef IOUSBCompletion
 @discussion Struct specifying action to perform when a USB I/O completes.
 @param target The target to pass to the action function.
 @param action The function to call.
 @param parameter The parameter to pass to the action function.
 */
typedef struct IOUSBCompletion {
    void * 			target;
    IOUSBCompletionAction	action;
    void *			parameter;
} IOUSBCompletion;

/*!
@typedef IOUSBCompletionWithTimeStamp
 @discussion Struct specifying action to perform when a USB I/O completes.
 @param target The target to pass to the action function.
 @param action The function to call.
 @param parameter The parameter to pass to the action function.
 */
typedef struct IOUSBCompletionWithTimeStamp {
    void * 				target;
    IOUSBCompletionActionWithTimeStamp	action;
    void *				parameter;
} IOUSBCompletionWithTimeStamp;

/*!
    @typedef IOUSBIsocCompletion
    @discussion Struct specifying action to perform when an Isochronous USB I/O completes.
    @param target The target to pass to the action function.
    @param action The function to call.
    @param parameter The parameter to pass to the action function.
*/
typedef struct IOUSBIsocCompletion {
    void * 			target;
    IOUSBIsocCompletionAction	action;
    void *			parameter;
} IOUSBIsocCompletion;

/*!
    @typedef IOUSBLowLatencyIsocCompletion
    @discussion Struct specifying action to perform when an Low Latency Isochronous USB I/O completes.
    @param target The target to pass to the action function.
    @param action The function to call.
    @param parameter The parameter to pass to the action function.
*/
typedef struct IOUSBLowLatencyIsocCompletion {
    void * 				target;
    IOUSBLowLatencyIsocCompletionAction	action;
    void *				parameter;
} IOUSBLowLatencyIsocCompletion;


/*!
@defineblock IOUSBFamily error codes
@discussion  Errors specific to the IOUSBFamily.  Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
*/

#define	iokit_usb_err(return)								(sys_iokit|sub_iokit_usb|return)
#define kIOUSBUnknownPipeErr								iokit_usb_err(0x61)									// 0xe0004061  Pipe ref not recognized
#define kIOUSBTooManyPipesErr								iokit_usb_err(0x60)									// 0xe0004060  Too many pipes
#define kIOUSBNoAsyncPortErr								iokit_usb_err(0x5f)									// 0xe000405f  no async port
#define kIOUSBNotEnoughPipesErr								iokit_usb_err(0x5e)									// 0xe000405e  not enough pipes in interface
#define kIOUSBNotEnoughPowerErr								iokit_usb_err(0x5d)									// 0xe000405d  not enough power for selected configuration
#define kIOUSBEndpointNotFound								iokit_usb_err(0x57)									// 0xe0004057  Endpoint Not found
#define kIOUSBConfigNotFound								iokit_usb_err(0x56)									// 0xe0004056  Configuration Not found
#define kIOUSBTransactionTimeout							iokit_usb_err(0x51)									// 0xe0004051  Transaction timed out
#define kIOUSBTransactionReturned							iokit_usb_err(0x50)									// 0xe0004050  The transaction has been returned to the caller
#define kIOUSBPipeStalled									iokit_usb_err(0x4f)									// 0xe000404f  Pipe has stalled, error needs to be cleared
#define kIOUSBInterfaceNotFound								iokit_usb_err(0x4e)									// 0xe000404e  Interface ref not recognized
#define kIOUSBLowLatencyBufferNotPreviouslyAllocated        iokit_usb_err(0x4d)									// 0xe000404d  Attempted to use user land low latency isoc calls w/out calling PrepareBuffer (on the data buffer) first 
#define kIOUSBLowLatencyFrameListNotPreviouslyAllocated     iokit_usb_err(0x4c)									// 0xe000404c  Attempted to use user land low latency isoc calls w/out calling PrepareBuffer (on the frame list) first
#define kIOUSBHighSpeedSplitError							iokit_usb_err(0x4b)									// 0xe000404b  Error to hub on high speed bus trying to do split transaction
#define kIOUSBSyncRequestOnWLThread							iokit_usb_err(0x4a)									// 0xe000404a  A synchronous USB request was made on the workloop thread (from a callback?).  Only async requests are permitted in that case
#define kIOUSBDeviceNotHighSpeed							iokit_usb_err(0x49)									// 0xe0004049  Name is deprecated, see below
#define kIOUSBDeviceTransferredToCompanion					iokit_usb_err(0x49)									// 0xe0004049  The device has been tranferred to another controller for enumeration
#define kIOUSBClearPipeStallNotRecursive 					iokit_usb_err(0x48)									// 0xe0004048  IOUSBPipe::ClearPipeStall should not be called recursively
#define kIOUSBDevicePortWasNotSuspended 					iokit_usb_err(0x47)									// 0xe0004047  Port was not suspended
#define kIOUSBEndpointCountExceeded							iokit_usb_err(0x46)									// 0xe0004046  The endpoint was not created because the controller cannot support more endpoints
#define kIOUSBDeviceCountExceeded							iokit_usb_err(0x45)									// 0xe0004045  The device cannot be enumerated because the controller cannot support more devices
#define kIOUSBStreamsNotSupported							iokit_usb_err(0x44)                                 // 0xe0004044  The request cannot be completed because the XHCI controller does not support streams
#define kIOUSBInvalidSSEndpoint								iokit_usb_err(0x43)									// 0xe0004043  An endpoint found in a SuperSpeed device is invalid (usually because there is no Endpoint Companion Descriptor)
#define kIOUSBTooManyTransactionsPending                    iokit_usb_err(0x42)                                 // 0xe0004042  The transaction cannot be submitted because it would exceed the allowed number of pending transactions
    
/*!
@definedblock IOUSBFamily hardware error codes
@discussion These errors are returned by the OHCI controller.  The # in parenthesis (xx) corresponds to the OHCI Completion Code.
For the following Completion codes, we return a generic IOKit error instead of a USB specific error.  
<tt>
<pre>
Completion Code         Error Returned              Description
9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
5                       kIOReturnNotResponding      Device Not responding
4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
</pre>
</tt>
*/
#define kIOUSBLinkErr           iokit_usb_err(0x10)		// 0xe0004010
#define kIOUSBNotSent2Err       iokit_usb_err(0x0f)		// 0xe000400f Transaction not sent
#define kIOUSBNotSent1Err       iokit_usb_err(0x0e)		// 0xe000400e Transaction not sent
#define kIOUSBBufferUnderrunErr iokit_usb_err(0x0d)		// 0xe000400d Buffer Underrun (Host hardware failure on data out, PCI busy?)
#define kIOUSBBufferOverrunErr  iokit_usb_err(0x0c)		// 0xe000400c Buffer Overrun (Host hardware failure on data out, PCI busy?)
#define kIOUSBReserved2Err      iokit_usb_err(0x0b)		// 0xe000400b Reserved
#define kIOUSBReserved1Err      iokit_usb_err(0x0a)		// 0xe000400a Reserved
#define kIOUSBWrongPIDErr       iokit_usb_err(0x07)		// 0xe0004007 Pipe stall, Bad or wrong PID
#define kIOUSBPIDCheckErr       iokit_usb_err(0x06)		// 0xe0004006 Pipe stall, PID CRC error
#define kIOUSBDataToggleErr     iokit_usb_err(0x03)		// 0xe0004003 Pipe stall, Bad data toggle
#define kIOUSBBitstufErr        iokit_usb_err(0x02)		// 0xe0004002 Pipe stall, bitstuffing
#define kIOUSBCRCErr            iokit_usb_err(0x01)		// 0xe0004001 Pipe stall, bad CRC
/*! @/definedblock */


/*!
@defineblock IOUSBFamily message codes
@discussion  Messages specific to the IOUSBFamily.  Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
*/
#define iokit_usb_msg(message)						(UInt32)(sys_iokit|sub_iokit_usb|message)
#define kIOUSBMessageHubResetPort					iokit_usb_msg(0x01)		// 0xe0004001  Message sent to a hub to reset a particular port
#define kIOUSBMessageHubSuspendPort					iokit_usb_msg(0x02)		// 0xe0004002  Message sent to a hub to suspend a particular port
#define kIOUSBMessageHubResumePort					iokit_usb_msg(0x03)		// 0xe0004003  Message sent to a hub to resume a particular port
#define kIOUSBMessageHubIsDeviceConnected			iokit_usb_msg(0x04)		// 0xe0004004  Message sent to a hub to inquire whether a particular port has a device connected or not
#define kIOUSBMessageHubIsPortEnabled				iokit_usb_msg(0x05)		// 0xe0004005  Message sent to a hub to inquire whether a particular port is enabled or not
#define kIOUSBMessageHubReEnumeratePort				iokit_usb_msg(0x06)		// 0xe0004006  Message sent to a hub to reenumerate the device attached to a particular port
#define kIOUSBMessagePortHasBeenReset				iokit_usb_msg(0x0a)		// 0xe000400a  Message sent to a device indicating that the port it is attached to has been reset
#define kIOUSBMessagePortHasBeenResumed				iokit_usb_msg(0x0b)		// 0xe000400b  Message sent to a device indicating that the port it is attached to has been resumed
#define kIOUSBMessageHubPortClearTT					iokit_usb_msg(0x0c)		// 0xe000400c  Message sent to a hub to clear the transaction translator
#define kIOUSBMessagePortHasBeenSuspended			iokit_usb_msg(0x0d)		// 0xe000400d  Message sent to a device indicating that the port it is attached to has been suspended
#define kIOUSBMessageFromThirdParty					iokit_usb_msg(0x0e)		// 0xe000400e  Message sent from a third party.  Uses IOUSBThirdPartyParam to encode the sender's ID
#define kIOUSBMessagePortWasNotSuspended			iokit_usb_msg(0x0f)		// 0xe000400f  Message indicating that the hub driver received a resume request for a port that was not suspended
#define kIOUSBMessageExpressCardCantWake			iokit_usb_msg(0x10)		// 0xe0004010  Message from a driver to a bus that an express card will disconnect on sleep and thus shouldn't wake
#define kIOUSBMessageCompositeDriverReconfigured    iokit_usb_msg(0x11)		// 0xe0004011  Message from the composite driver indicating that it has finished re-configuring the device after a reset
#define kIOUSBMessageHubSetPortRecoveryTime			iokit_usb_msg(0x12)		// 0xe0004012  Message sent to a hub to set the # of ms required when resuming a particular port
#define kIOUSBMessageOvercurrentCondition			iokit_usb_msg(0x13)     // 0xe0004013  Message sent to the clients of the device's hub parent, when a device causes an overcurrent condition.  The message argument contains the locationID of the device
#define kIOUSBMessageNotEnoughPower					iokit_usb_msg(0x14)     // 0xe0004014  Message sent to the clients of the device's hub parent, when a device causes an low power notice to be displayed.  The message argument contains the locationID of the device
#define kIOUSBMessageController						iokit_usb_msg(0x15)		// 0xe0004015  Generic message sent from controller user client to controllers 
#define	kIOUSBMessageRootHubWakeEvent				iokit_usb_msg(0x16)		// 0xe0004016  Message from the HC Wakeup code indicating that a Root Hub port has a wake event
#define kIOUSBMessageReleaseExtraCurrent			iokit_usb_msg(0x17)		// 0xe0004017  Message to ask any clients using extra current to release it if possible
#define kIOUSBMessageReallocateExtraCurrent			iokit_usb_msg(0x18)		// 0xe0004018  Message to ask any clients using extra current to attempt to allocate it some more
#define kIOUSBMessageEndpointCountExceeded			iokit_usb_msg(0x19)		// 0xe0004019  Message sent to a device when endpoints cannot be created because the USB controller ran out of resources
#define kIOUSBMessageDeviceCountExceeded			iokit_usb_msg(0x1a)		// 0xe000401a  Message sent by a hub when a device cannot be enumerated because the USB controller ran out of resources
#define kIOUSBMessageHubPortDeviceDisconnected      iokit_usb_msg(0x1b)		// 0xe000401b  Message sent by a built-in hub when a device was disconnected
#define kIOUSBMessageUnsupportedConfiguration		iokit_usb_msg(0x1c)     // 0xe000401c  Message sent to the clients of the device when a device is not supported in the current configuration.  The message argument contains the locationID of the device
#define kIOUSBMessageHubCountExceeded               iokit_usb_err(0x1d)     // 0xe000401d  Message sent when a 6th hub was plugged in and was not enumerated, as the USB spec only support 5 hubs in a chain
#define kIOUSBMessageTDMLowBattery                  iokit_usb_err(0x1e)     // 0xe000401e  Message sent when when an attached TDM system battery is running low.
#define kIOUSBMessageLegacySuspendDevice            iokit_usb_err(0x1f)     // 0xe000401f  Message sent to legacy interfaces when SuspedDevice() is called .
#define kIOUSBMessageLegacyResetDevice              iokit_usb_err(0x20)     // 0xe0004020  Message sent to legacy interfaces when ResetDevice() is called .
#define kIOUSBMessageLegacyReEnumerateDevice        iokit_usb_err(0x21)     // 0xe0004021  Message sent to legacy interfaces when ReEnumerateDevice() is called .
    
/*! @/defineblock */

    

// Obsolete
//
struct IOUSBMouseData {
    UInt16 				buttons;
    SInt16 				XDelta;
    SInt16 				YDelta;
};
typedef struct IOUSBMouseData		IOUSBMouseData;
typedef IOUSBMouseData *		IOUSBMouseDataPtr;

// Obsolete
//
struct IOUSBKeyboardData {
    UInt16 				keycount;
    UInt16 				usbkeycode[32];
};
typedef struct IOUSBKeyboardData	IOUSBKeyboardData;
typedef IOUSBKeyboardData *		IOUSBKeyboardDataPtr;

// Obsolete
//
union IOUSBHIDData {
    IOUSBKeyboardData 			kbd;
    IOUSBMouseData 			mouse;
};
typedef union IOUSBHIDData		IOUSBHIDData;
typedef IOUSBHIDData *			IOUSBHIDDataPtr;

/*!
    @typedef IOUSBDeviceDescriptor
    @discussion Descriptor for a USB Device.  See the USB Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.
*/
struct IOUSBDeviceDescriptor {
	UInt8 			bLength;
	UInt8 			bDescriptorType;
	UInt16 			bcdUSB;
	UInt8 			bDeviceClass;
	UInt8 			bDeviceSubClass;
	UInt8 			bDeviceProtocol;
	UInt8 			bMaxPacketSize0;
	UInt16 			idVendor;
	UInt16 			idProduct;
	UInt16 			bcdDevice;
	UInt8 			iManufacturer;
	UInt8 			iProduct;
	UInt8 			iSerialNumber;
	UInt8 			bNumConfigurations;
};
typedef struct IOUSBDeviceDescriptor		IOUSBDeviceDescriptor;
typedef IOUSBDeviceDescriptor *			IOUSBDeviceDescriptorPtr;

/*!
    @typedef IOUSBDescriptorHeader
    @discussion Standard header used for all USB descriptors.  Used to read the length of a descriptor so that we can allocate storage for the whole descriptor later on.
*/
struct IOUSBDescriptorHeader {
	UInt8 			bLength;
	UInt8 			bDescriptorType;
};
typedef struct IOUSBDescriptorHeader		IOUSBDescriptorHeader;
typedef IOUSBDescriptorHeader *			IOUSBDescriptorHeaderPtr;

#pragma pack(1)
	/*!
	 @typedef IOUSBBOSDescriptor
	 @discussion BOS Descriptor for a USB Device.  .
	 */
	struct IOUSBBOSDescriptor {
		UInt8 			bLength;
		UInt8 			bDescriptorType;
		UInt16 			wTotalLength;
		UInt8 			bNumDeviceCaps;
	};
	typedef struct IOUSBBOSDescriptor		IOUSBBOSDescriptor;
	typedef IOUSBBOSDescriptor *			IOUSBBOSDescriptorPtr;
	
	
	/*!
	 @typedef IOUSBDeviceCapabilityDescriptorHeader
	 @discussion Header for a Device Capability Descriptor for a USB Device.  .
	 */
	struct IOUSBDeviceCapabilityDescriptorHeader {
		UInt8 			bLength;
		UInt8 			bDescriptorType;
		UInt8 			bDevCapabilityType;
		UInt8 			bNumDeviceCaps;
	};
	typedef struct IOUSBDeviceCapabilityDescriptorHeader		IOUSBDeviceCapabilityDescriptorHeader;
	typedef IOUSBDeviceCapabilityDescriptorHeader *				IOUSBDeviceCapabilityDescriptorHeaderPtr;
	
	
	/*!
	 @typedef IOUSBDeviceCapabilityUSB2Extension
	 @discussion Device Capability USB 2.0 Extension
	 */
	struct IOUSBDeviceCapabilityUSB2Extension {
		UInt8 			bLength;
		UInt8 			bDescriptorType;
		UInt8 			bDevCapabilityType;
		UInt32 			bmAttributes;
	};
	typedef struct IOUSBDeviceCapabilityUSB2Extension		IOUSBDeviceCapabilityUSB2Extension;
	typedef IOUSBDeviceCapabilityUSB2Extension *			IOUSBDeviceCapabilityUSB2ExtensionPtr;
	

	/*!
	 @typedef IOUSBDeviceCapabilitySuperSpeedUSB
	 @discussion Device Capability SuperSpeed USB
	 */
	struct IOUSBDeviceCapabilitySuperSpeedUSB {
		UInt8 			bLength;
		UInt8 			bDescriptorType;
		UInt8 			bDevCapabilityType;
		UInt8 			bmAttributes;
		UInt16			wSpeedsSupported;
		UInt8			bFunctionalitySupport;
		UInt8			bU1DevExitLat;
		UInt16			wU2DevExitLat;
	};
	typedef struct IOUSBDeviceCapabilitySuperSpeedUSB		IOUSBDeviceCapabilitySuperSpeedUSB;
	typedef IOUSBDeviceCapabilitySuperSpeedUSB *			IOUSBDeviceCapabilitySuperSpeedUSBPtr;
	
	
	/*!
	 @typedef IOUSBDeviceCapabilityContainerID
	 @discussion Device Capability Container ID
	 */
	struct IOUSBDeviceCapabilityContainerID {
		UInt8 			bLength;
		UInt8 			bDescriptorType;
		UInt8 			bDevCapabilityType;
		UInt8			bReservedID;
		UInt8			containerID[16];

	};
	typedef struct IOUSBDeviceCapabilityContainerID		IOUSBDeviceCapabilityContainerID;
	typedef IOUSBDeviceCapabilityContainerID *			IOUSBDeviceCapabilityContainerIDPtr;
#pragma options align=reset
	
/*!
    @typedef IOUSBConfigurationDescriptor
    @discussion Standard USB Configuration Descriptor.  It is variable length, so this only specifies the known fields.  We use the wTotalLength field to read the whole descriptor.
    See the USB Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.
*/
struct IOUSBConfigurationDescriptor {
	UInt8 			bLength;
	UInt8 			bDescriptorType;
	UInt16 			wTotalLength;
	UInt8 			bNumInterfaces;
	UInt8 			bConfigurationValue;
	UInt8 			iConfiguration;
	UInt8 			bmAttributes;
	UInt8 			MaxPower;
};
typedef struct IOUSBConfigurationDescriptor 	IOUSBConfigurationDescriptor;
typedef IOUSBConfigurationDescriptor *		IOUSBConfigurationDescriptorPtr;

/*!
    @typedef IOUSBConfigurationDescHeader
    @discussion Header of a IOUSBConfigurationDescriptor.  Used to get the total length of the descriptor.
*/
struct IOUSBConfigurationDescHeader {
	UInt8 			bLength;
	UInt8 			bDescriptorType;
	UInt16 			wTotalLength;
};
typedef struct IOUSBConfigurationDescHeader 	IOUSBConfigurationDescHeader;
typedef IOUSBConfigurationDescHeader *		IOUSBConfigurationDescHeaderPtr;

/*!
    @typedef IOUSBInterfaceDescriptor
    @discussion Descriptor for a USB Interface.  See the USB Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.
*/
struct IOUSBInterfaceDescriptor {
	UInt8 			bLength;
	UInt8 			bDescriptorType;
	UInt8 			bInterfaceNumber;
	UInt8 			bAlternateSetting;
	UInt8 			bNumEndpoints;
	UInt8 			bInterfaceClass;
	UInt8 			bInterfaceSubClass;
	UInt8 			bInterfaceProtocol;
	UInt8 			iInterface;
};
typedef struct IOUSBInterfaceDescriptor	IOUSBInterfaceDescriptor;
typedef IOUSBInterfaceDescriptor *	IOUSBInterfaceDescriptorPtr;

/*!
    @typedef IOUSBEndpointDescriptor
    @discussion Descriptor for a USB Endpoint.  See the USB Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.
*/
struct IOUSBEndpointDescriptor {
	UInt8 			bLength;
	UInt8 			bDescriptorType;
	UInt8 			bEndpointAddress;
	UInt8 			bmAttributes;
	UInt16 			wMaxPacketSize;	
	UInt8 			bInterval;
};
typedef struct IOUSBEndpointDescriptor	IOUSBEndpointDescriptor;
typedef IOUSBEndpointDescriptor *	IOUSBEndpointDescriptorPtr;
    
enum {
    kUSB_EPDesc_bmAttributes_TranType_Mask      = USBBitRange(0,1),
    kUSB_EPDesc_bmAttributes_TranType_Shift     = USBBitRangePhase(0,1),
    kUSB_EPDesc_bmAttributes_SyncType_Mask      = USBBitRange(2, 3),
    kUSB_EPDesc_bmAttributes_SyncType_Shift     = USBBitRangePhase(2, 3),
    kUSB_EPDesc_bmAttributes_UsageType_Mask     = USBBitRange(4, 5),
    kUSB_EPDesc_bmAttributes_UsageType_Shift    = USBBitRangePhase(4, 5),
    
    kUSB_EPDesc_wMaxPacketSize_MPS_Mask			= USBBitRange(0, 10),
    kUSB_EPDesc_wMaxPacketSize_MPS_Shift		= USBBitRangePhase(0, 10),
    kUSB_EPDesc_MaxMPS                          = 1024,                                    // this is the maximum no matter what
	
    kUSB_HSFSEPDesc_wMaxPacketSize_Mult_Mask    = USBBitRange(11, 12),
    kUSB_HSFSEPDesc_wMaxPacketSize_Mult_Shift   = USBBitRangePhase(11, 12)
};

#pragma pack(1)
/*!
 @typedef IOUSBSuperSpeedEndpointCompanionDescriptor
 @discussion Descriptor for a SuperSpeed USB Endpoint Companion.  See the USB Specification at <a href="http://www.usb.org"TARGET="_blank">http://www.usb.org</a>.
 */
struct IOUSBSuperSpeedEndpointCompanionDescriptor {
    UInt8 			bLength;
    UInt8 			bDescriptorType;
    UInt8 			bMaxBurst;
    UInt8 			bmAttributes;
    UInt16 			wBytesPerInterval;	
};
typedef struct IOUSBSuperSpeedEndpointCompanionDescriptor	IOUSBSuperSpeedEndpointCompanionDescriptor;
typedef IOUSBSuperSpeedEndpointCompanionDescriptor *	IOUSBSuperSpeedEndpointCompanionDescriptorPtr;
enum {
    kUSB_SSCompDesc_Bulk_MaxStreams_Mask	= USBBitRange(0, 4),
    kUSB_SSCompDesc_Bulk_MaxStreams_Shift	= USBBitRangePhase(0, 4),
    kUSB_SSCompDesc_Isoc_Mult_Mask			= USBBitRange(0, 1),
    kUSB_SSCompDesc_Isoc_Mult_Shift			= USBBitRangePhase(0, 1)
};
    



#ifndef __OPEN_SOURCE__
// Leave this here because it has existed for many years, but it never really belonged here in the first place
#endif

// these following 2 lines are deprecated and should not be used. 
enum{addPacketShift = 11};  // Bits for additional packets in maxPacketField. (Table 9-13)
#define mungeMaxPacketSize(w) ((w>1024)?(((w>>(addPacketShift))+1)*(w&((1<<addPacketShift)-1))):w)

/*!
    @typedef IOUSBEndpointProperties
    @discussion  Structure used with the IOUSBLib GetEndpointPropertiesV3 and GetPipePropertiesV3 API. Most of the fields are taken directly from corresponding Standard Endpoint Descriptor and SuperSpeed Endpoint Companion Descriptor. wBytesPerInterval will be synthesized for  High Speed High Bandwidth Isochronous endpoints.
    @field bVersion  Version of the structure.  Currently kUSBEndpointPropertiesVersion3.  Need to set this when using this structure
    @field bAlternateSetting Used as an input for GetEndpointPropertiesV3.  Used as an output for GetPipePropertiesV3
    @field bDirection Used as an input for GetEndpointPropertiesV3.  Used as an output for GetPipePropertiesV3. One of kUSBIn or kUSBOut.
    @field bEndpointNumber Used as an input for GetEndpointPropertiesV3.  Used as an output for GetPipePropertiesV3
    @field bTransferType  One of kUSBControl, kUSBBulk, kUSBIsoc, or kUSBInterrupt
    @field bUsageType  For interrupt and isoc endpoints, the usage type.  For Bulk endpoints of the UAS Mass Storage Protocol, the pipe ID.
    @field bSyncType	For isoc endpoints only
    @field bInterval	The bInterval field from the Standard Endpoint descriptor.
    @field wMaxPacketSize  The meaning of this value depends on whether this is called with GetPipePropertiesV3 or GetEndpointPropertiesV3. See the documentation of those calls for more info.
    @field bMaxBurst  For SuperSpeed endpoints, maximum number of packets the endpoint can send or receive as part of a burst
    @field bMaxStreams  For SuperSpeed bulk endpoints, maximum number of streams this endpoint supports.
    @field bMult  For SuperSpeed isoc endpoints, this is the mult value from the SuperSpeed Endpoint Companion Descriptor. For High Speed isoc and interrupt endpoints, this is bits 11 and 12 of the Standard Endpoint Descriptor, which represents a similar value.
    @field wBytesPerInterval  For SuperSpeed interrupt and isoc endpoints, this is the wBytesPerInterval from the SuperSpeed Endpoint Companion Descriptor. For High Speed High Bandwidth isoc endpoints, this will be equal to wMaxPacketSize * (bMult+1).
 */
struct IOUSBEndpointProperties {
    UInt8 			bVersion;
    UInt8			bAlternateSetting;
    UInt8			bDirection;
    UInt8			bEndpointNumber;
    UInt8			bTransferType;
    UInt8			bUsageType;
    UInt8			bSyncType;
    UInt8			bInterval;
    UInt16			wMaxPacketSize;
    UInt8			bMaxBurst;
    UInt8			bMaxStreams;
    UInt8			bMult;
    UInt16			wBytesPerInterval;
};
typedef struct IOUSBEndpointProperties	IOUSBEndpointProperties;
typedef IOUSBEndpointProperties *	IOUSBEndpointPropertiesPtr;

/*!
    @enum USBGetEndpointVersion
    @discussion 	Version of the IOUSBEndpointProperties structure.
    @constant	kUSBEndpointPropertiesVersion3			Version that has support for USB3 SuperSpeed Endpoint Companion fields.
*/
enum {
    kUSBEndpointPropertiesVersion3	= 0x03
};

/*!
    @typedef UASPipeDescriptor
    @discussion  Structure used to specify the Mass Storage Specific UAS pipe usage descriptor
*/
struct UASPipeDescriptor {
    UInt8	bLength;
    UInt8	bDescriptorType;
    UInt8	bPipeID;
    UInt8   bReserved;
};
typedef struct 	UASPipeDescriptor	UASPipeDescriptor;
typedef 		UASPipeDescriptor * UASPipeDescriptorPtr;

#pragma options align=reset

/*!
    @typedef IOUSBHIDDescriptor
    @discussion USB HID Descriptor.  See the USB HID Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.  (This structure
    should have used the #pragma pack(1) compiler directive to get byte alignment.
*/
struct IOUSBHIDDescriptor {
	UInt8 			descLen;
	UInt8 			descType;
	UInt16 			descVersNum;
	UInt8 			hidCountryCode;
	UInt8 			hidNumDescriptors;
	UInt8 			hidDescriptorType;
	UInt8 			hidDescriptorLengthLo;
	UInt8 			hidDescriptorLengthHi;
};
typedef struct IOUSBHIDDescriptor	IOUSBHIDDescriptor;
typedef IOUSBHIDDescriptor *IOUSBHIDDescriptorPtr;

/*!
    @typedef IOUSBHIDReportDesc
    @discussion USB HID Report Descriptor header.  See the USB HID Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.  (This structure
    should have used the #pragma pack(1) compiler directive to get byte alignment.
*/
struct IOUSBHIDReportDesc {
	UInt8 			hidDescriptorType;
	UInt8 			hidDescriptorLengthLo;	
	UInt8 			hidDescriptorLengthHi;
};
typedef struct IOUSBHIDReportDesc	IOUSBHIDReportDesc;
typedef IOUSBHIDReportDesc *		IOUSBHIDReportDescPtr;

/*!
    @typedef IOUSBDeviceQualifierDescriptor
    @discussion USB Device Qualifier Descriptor.  See the USB Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.
*/
#pragma pack(1)
struct IOUSBDeviceQualifierDescriptor
{
	UInt8 			bLength;
	UInt8 			bDescriptorType;
	UInt16 			bcdUSB;
	UInt8 			bDeviceClass;
	UInt8 			bDeviceSubClass;
	UInt8 			bDeviceProtocol;
	UInt8 			bMaxPacketSize0;
	UInt8 			bNumConfigurations;
	UInt8 			bReserved;
};
typedef struct IOUSBDeviceQualifierDescriptor	IOUSBDeviceQualifierDescriptor;
typedef IOUSBDeviceQualifierDescriptor *	IOUSBDeviceQualifierDescriptorPtr;
#pragma options align=reset

/*!
    @typedef IOUSBDFUDescriptor
    @discussion USB Device Firmware Update Descriptor.  See the USB Device Firmware Update Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.
*/
#pragma pack(1)
struct IOUSBDFUDescriptor 
{
        UInt8 			bLength;
        UInt8 			bDescriptorType;
        UInt8 			bmAttributes;
        UInt16 			wDetachTimeout;
        UInt16 			wTransferSize;
};
typedef struct 	IOUSBDFUDescriptor 		IOUSBDFUDescriptor;
typedef 		IOUSBDFUDescriptor *	IOUSBDFUDescriptorPtr;

#pragma options align=reset

/*!
@typedef IOUSBInterfaceAssociationDescriptor
 @discussion USB Inerface Association Descriptor.  ECN to the USB 2.0 Spec.  See the USB Specification at <a href="http://www.usb.org" target="_blank">http://www.usb.org</a>.
 */
#pragma pack(1)
struct IOUSBInterfaceAssociationDescriptor
{
    UInt8 			bLength;
    UInt8 			bDescriptorType;
    UInt8 			bFirstInterface;
    UInt8 			bInterfaceCount;
    UInt8 			bFunctionClass;
    UInt8 			bFunctionSubClass;
    UInt8 			bFunctionProtocol;
    UInt8			iFunction;
};
typedef struct IOUSBInterfaceAssociationDescriptor	IOUSBInterfaceAssociationDescriptor;
typedef IOUSBInterfaceAssociationDescriptor *	IOUSBInterfaceAssociationDescriptorPtr;
#pragma options align=reset

/*!
    @typedef USBStatus
    @discussion Type used to get a DeviceStatus as a single quantity.
*/
typedef UInt16				USBStatus;
typedef USBStatus *			USBStatusPtr;

// These constants are obsolete
//
enum {
    kIOUSBAnyClass	= 0xFFFF,
    kIOUSBAnySubClass	= 0xFFFF,
    kIOUSBAnyProtocol	= 0xFFFF,
    kIOUSBAnyVendor	= 0xFFFF,
    kIOUSBAnyProduct	= 0xFFFF
};

// This structure are obsolete
//
typedef struct IOUSBMatch {
    UInt16	usbClass;
    UInt16	usbSubClass;
    UInt16	usbProtocol;
    UInt16	usbVendor;
    UInt16	usbProduct;
} IOUSBMatch;

/*!
    @typedef IOUSBFindEndpointRequest
    @discussion Struct used to find endpoints of an interface
    type and direction are used to match endpoints,
    type, direction, maxPacketSize and interval are updated
    with the properties of the found endpoint.
    @field type Type of endpoint: kUSBControl, kUSBIsoc, kUSBBulk, kUSBInterrupt, kUSBAnyType.  If kUSBAnyType is specified, this field is treated as a don't care.
    @field direction Direction of endpoint: kUSBOut, kUSBIn, kUSBAnyDirn.   If kUSBAnyDirn is specified, this field is treated as a don't care.
    @field maxPacketSize maximum packet size of endpoint.
    @field interval Polling interval in mSec for endpoint.
*/
typedef struct {
	UInt8 type;	
	UInt8 direction;
    UInt16 maxPacketSize;
    UInt8 interval;
} IOUSBFindEndpointRequest;

/*!
    @struct IOUSBDevRequest
    @discussion Parameter block for control requests, using a simple pointer
    for the data to be transferred.
    @field bmRequestType Request type: kUSBStandard, kUSBClass or kUSBVendor
    @field bRequest Request code
    @field wValue 16 bit parameter for request, host endianess
    @field wIndex 16 bit parameter for request, host endianess
    @field wLength Length of data part of request, 16 bits, host endianess
    @field pData Pointer to data for request - data returned in bus endianess
    @field wLenDone Set by standard completion routine to number of data bytes
	actually transferred
*/
typedef struct {
    UInt8       bmRequestType;
    UInt8       bRequest;
    UInt16      wValue;
    UInt16      wIndex;
    UInt16      wLength;
    void *      pData;
    UInt32      wLenDone;
} IOUSBDevRequest;
typedef IOUSBDevRequest * IOUSBDeviceRequestPtr;

/*!
    @struct IOUSBDevRequestTO
    @discussion Parameter block for control requests with timeouts, using a simple pointer
    for the data to be transferred.  Same as a IOUSBDevRequest except for the two extra timeout fields.
    @field bmRequestType Request type: kUSBStandard, kUSBClass or kUSBVendor
    @field bRequest Request code
    @field wValue 16 bit parameter for request, host endianess
    @field wIndex 16 bit parameter for request, host endianess
    @field wLength Length of data part of request, 16 bits, host endianess
    @field pData Pointer to data for request - data returned in bus endianess
    @field wLenDone Set by standard completion routine to number of data bytes
	actually transferred
    @field noDataTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if no data is transferred in this amount of time, the request will be aborted and returned.
    @field completionTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if the entire request is not completed in this amount of time, the request will be aborted and returned 
*/
typedef struct {
    UInt8       bmRequestType;
    UInt8       bRequest;
    UInt16      wValue;
    UInt16      wIndex;
    UInt16      wLength;
    void *      pData;
    UInt32      wLenDone;
    UInt32      noDataTimeout;
    UInt32      completionTimeout;
} IOUSBDevRequestTO;

/*!
    @enum Default timeout values
    @discussion default values used for data and completion timeouts.
*/
enum
{
    kUSBDefaultControlNoDataTimeoutMS = 5000,
    kUSBDefaultControlCompletionTimeoutMS = 0
};

// Internal structure to pass parameters between IOUSBLib and UserClient
//
typedef struct
{
    UInt32      pipeRef;
    void *      buf;
    UInt32      size;
    UInt32      noDataTimeout;
    UInt32      completionTimeout;
} IOUSBBulkPipeReq;


#if KERNEL
/*!
    @struct IOUSBDevRequestDesc
    @discussion Parameter block for control requests, using a memory descriptor
    for the data to be transferred.  Only available in the kernel.
    @field bmRequestType Request type: kUSBStandard, kUSBClass or kUSBVendor
    @field bRequest Request code
    @field wValue 16 bit parameter for request, host endianess
    @field wIndex 16 bit parameter for request, host endianess
    @field wLength Length of data part of request, 16 bits, host endianess
    @field pData Pointer to memory descriptor for data for request - data returned in bus endianess
    @field wLenDone Set by standard completion routine to number of data bytes
     actually transferred
*/
typedef struct {
    UInt8                   bmRequestType;
    UInt8                   bRequest;
    UInt16                  wValue;
    UInt16                  wIndex;
    UInt16                  wLength;
    IOMemoryDescriptor *    pData;
    UInt32                  wLenDone;
} IOUSBDevRequestDesc;


/*!
	@enum IOUSBFamilyIOOptionBit
	@discussion Options used exclusively by the USB Family when calling calling IOService APIs, such as open() and close(). 
    @constant kIOUSBInterfaceOpenAlt Open the alternate interface specified when creating the interface.
 @constant	kUSBOptionBitOpenExclusivelyBit	Used in open()'ing the IOUSBDevice or IOUSBInterface by the corresponding user client.  Only 1 user client can have exclusive access to those objects
*/
enum {
    kIOUSBInterfaceOpenAlt	= 0x00010000,
    kIOUSBInterfaceOpenAlternateInterfaceBit	= 16,
	kUSBOptionBitOpenExclusivelyBit				= 17,
	kIOUSBInterfaceOpenAlternateInterfaceMask	= ( 1 << kIOUSBInterfaceOpenAlternateInterfaceBit),
	kUSBOptionBitOpenExclusivelyMask			= ( 1 << kUSBOptionBitOpenExclusivelyBit)
};
#endif

// Internal structure to pass parameters between IOUSBLib and UserClient
//
// use a structure because there's a limit of 6 total arguments
// to a user client method.
typedef struct {
    UInt8   	bmRequestType;
    UInt8 	bRequest;
    UInt16 	wValue;
    UInt16 	wIndex;
    UInt16	wLength;
    void * 	pData;		// data pointer
    UInt32	wLenDone;	// # bytes transferred
    UInt8	pipeRef;
} IOUSBDevReqOOL;

// Internal structure to pass parameters between IOUSBLib and UserClient
//
typedef struct {
    UInt8   	bmRequestType;
    UInt8 	bRequest;
    UInt16 	wValue;
    UInt16 	wIndex;
    UInt16	wLength;
    void * 	pData;		// data pointer
    UInt32	wLenDone;	// # bytes transferred
    UInt8	pipeRef;
    UInt32	noDataTimeout;
    UInt32	completionTimeout;
} IOUSBDevReqOOLTO;

// Internal structure to pass parameters between IOUSBLib and UserClient
//
// Structure to request isochronous transfer
//
typedef struct {
    UInt32 		fPipe;
    void 		*fBuffer;
    UInt32 		fBufSize;
    UInt64 		fStartFrame;
    UInt32 		fNumFrames;
    IOUSBIsocFrame 	*fFrameCounts;
} IOUSBIsocStruct;

// Internal structure to pass parameters between IOUSBLib and UserClient
//
// Structure to request low latency isochronous transfer
//
struct IOUSBLowLatencyIsocStruct {
    UInt32 			fPipe;
    UInt32 			fBufSize;
    UInt64 			fStartFrame;
    UInt32 			fNumFrames;
    UInt32			fUpdateFrequency;
    UInt32			fDataBufferCookie;
    UInt32			fDataBufferOffset;
    UInt32			fFrameListBufferCookie;
    UInt32			fFrameListBufferOffset;
};

typedef struct IOUSBLowLatencyIsocStruct IOUSBLowLatencyIsocStruct;


/*!
    @struct IOUSBGetFrameStruct
    @discussion Structure used from user space to return the frame number and a timestamp on when the frame register was read.
    @field frame frame number
    @field timeStamp  AbsoluteTime when the frame was updated
*/
typedef struct {
    UInt64			frame;
    AbsoluteTime	timeStamp;
} IOUSBGetFrameStruct;


/*!
    @struct IOUSBFindInterfaceRequest
    @discussion Structure used with FindNextInterface.
*/
typedef struct {
    UInt16	bInterfaceClass;		// requested class
    UInt16 	bInterfaceSubClass;		// requested subclass
    UInt16 	bInterfaceProtocol;		// requested protocol
    UInt16	bAlternateSetting;		// requested alt setting
} IOUSBFindInterfaceRequest;

/*!
    @enum kIOUSBFindInterfaceDontCare
    @discussion Constant that can be used for the fields of IOUSBFindInterfaceRequest to specify that they should not be matched. 
*/
enum {
        kIOUSBFindInterfaceDontCare		= 0xFFFF
        };

/*!
    @enum kIOUSBVendorIDApple
    @discussion USB Vendor ID for Apple, Inc. 
*/
    enum {
        kIOUSBVendorIDAppleComputer		= 0x05AC,
        kIOUSBVendorIDApple             = 0x05AC
    };

	/*!
	 @enum USBDeviceSpeed
	 @discussion Returns the speed of a particular USB device. 
	 @constant	kUSBDeviceSpeedLow	The device is a low speed device.
	 @constant	kUSBDeviceSpeedFull	The device is a full speed device.
	 @constant	kUSBDeviceSpeedHigh	The device is a high speed device.
	 @constant	kUSBDeviceSpeedSuper  The device is a SuperSpeed device
	 */
enum {
        kUSBDeviceSpeedLow		= 0,
        kUSBDeviceSpeedFull		= 1,
		kUSBDeviceSpeedHigh		= 2,
		kUSBDeviceSpeedSuper	= 3
        };

/*!
    @enum MicrosecondsInFrame
    @discussion Returns the number of microseconds in a USB frame. 
    @constant	kUSBFullSpeedMicrosecondsInFrame	The device is attached to a bus running at full speed (1 ms / frame).
    @constant	kUSBHighSpeedMicrosecondsInFrame	The device is attached to a bus running at high speed (125 microseconds / frame).
*/
enum {
    kUSBFullSpeedMicrosecondsInFrame		= 1000,	
    kUSBHighSpeedMicrosecondsInFrame		= 125
};

//  During low latency transfers, the stack will set the frStatus for each frame to this value.  A client can check that to see if the transfer has completed.  We set the frStatus to a 
//  valid return code when the transfer completes.
//
enum {
        kUSBLowLatencyIsochTransferKey	= 'llit'	// Set frStatus field of first frame in isoch transfer to designate as low latency
    };
    
// This structure is DEPRECATED.  See the LowLatencyUserBufferInfoV2  
//
typedef struct LowLatencyUserBufferInfo LowLatencyUserBufferInfo;

struct LowLatencyUserBufferInfo {
    UInt32				cookie;
    void *				bufferAddress;
    IOByteCount			bufferSize;
    UInt32				bufferType;
    Boolean				isPrepared;
    LowLatencyUserBufferInfo *	nextBuffer;
};

// This structure is DEPRECATED.  See the LowLatencyUserBufferInfoV3  

typedef struct LowLatencyUserBufferInfoV2 LowLatencyUserBufferInfoV2;

struct LowLatencyUserBufferInfoV2 
{
	UInt32							cookie;
	void *							bufferAddress;
	IOByteCount						bufferSize;
	UInt32							bufferType;
	Boolean							isPrepared;
	void *							mappedUHCIAddress;
	LowLatencyUserBufferInfoV2 *	nextBuffer;
};

	
// This structure is used to pass information for the low latency calls between user space and the kernel.  
//
typedef struct LowLatencyUserBufferInfoV3 LowLatencyUserBufferInfoV3;

struct LowLatencyUserBufferInfoV3 
{
	uint64_t						cookie;
	mach_vm_address_t				bufferAddress;
	mach_vm_size_t					bufferSize;
	uint64_t						bufferType;
	uint64_t						isPrepared;
	mach_vm_address_t				mappedUHCIAddress;
	LowLatencyUserBufferInfoV3 *	nextBuffer;
};
	
	
	/*!
    @enum USBLowLatencyBufferType
    @discussion Used to specify what kind of buffer to create when calling LowLatencyCreateBuffer(). 
    @constant	kUSBLowLatencyWriteBuffer	The buffer will be used to write data out to a device.
    @constant	kUSBLowLatencyReadBuffer	The buffer will be used to read data from a device.
    @constant	kUSBLowLatencyFrameListBuffer	The buffer will be used for a low latency isoch frame list.
*/
typedef enum {
    kUSBLowLatencyWriteBuffer 		= 0,
    kUSBLowLatencyReadBuffer		= 1,
    kUSBLowLatencyFrameListBuffer	= 2
} USBLowLatencyBufferType;

// USB User Notification Types
//
enum {
    kUSBNoUserNotificationType                  = 0,
    kUSBNotEnoughPowerNotificationType          = 1,
    kUSBIndividualOverCurrentNotificationType	= 2,
    kUSBGangOverCurrentNotificationType         = 3,
    kUSBiOSDeviceNotEnoughPowerNotificationType = 4,
    kUSBNotEnoughPowerNoACNotificationType      = 5,
    kUSBDeviceCountExceededNotificationType     = 6,
    kUSBEndpointCountExceededNotificationType   = 7,
    kUSBUnsupportedNotificationType             = 8,
    kUSBHubCountExceededNotificationType        = 9,
    kUSBTDMLowBatteryType                       = 10
};

/*!
    @defineblock Property Definitions
    @discussion Useful property names in USB land. 
*/
#define kUSBDevicePropertySpeed                 "Device Speed"
#define kUSBDevicePropertyBusPowerAvailable     "Bus Power Available"
#define kUSBDevicePropertyAddress               "USB Address"
#define kUSBDevicePropertyLocationID            "locationID"
#define kUSBProductIDMask						"idProductMask"
#define kUSBProductIdsArrayName					"idProductArray"
#define kUSBPreferredConfiguration				"Preferred Configuration"
#define kUSBPreferredInterface                  "Preferred Interface"
#define kUSBPreferredInterfacePriority          "priority"
#define kUSBSuspendPort							"kSuspendPort"
#define kUSBExpressCardCantWake					"ExpressCardCantWake"
#define kUSBControllerNeedsContiguousMemoryForIsoch	"Need contiguous memory for isoch"
#define kUSBHubDontAllowLowPower				"kUSBHubDontAllowLowPower"
#define kUSBDeviceResumeRecoveryTime			"kUSBDeviceResumeRecoveryTime"
#define kUSBOutOfSpecMPSOK						"Out of spec MPS OK"
#define kConfigurationDescriptorOverride		"ConfigurationDescriptorOverride"
#define kOverrideIfAtLocationID					"OverrideIfAtLocationID"
#define kOverrideAllowLowPower                  "kOverrideAllowLowPower"
/*! @/defineblock */

/*!
@enum USBReEnumerateOptions
 @discussion Options used when calling ReEnumerateDevice. 
 @constant	kUSBAddExtraResetTimeBit	Setting this bit will cause the Hub driver to wait 100ms before addressing the device after the reset following the re-enumeration.
 @constant	kUSBReEnumerateCaptureDeviceBit	Setting this bit will terminate any drivers attached to an IOUSBInterface for the device and to the IOUSBDevice itself.  It will not terminate
 any drivers attached to a Mass Storage Class IOUSBInterface.  A client needs to have the appropriate permissions in order to specify this bit.  See IOUSBLib.h
 @constant	kUSBReEnumerateReleaseDeviceBit	Setting this bit will return return any device that was captured back to the OS.  The driver for the IOUSBDevice will be loaded.  A client needs to have the appropriate permissions in order to specify this bit.  See IOUSBLib.h
 */
typedef enum {
    kUSBAddExtraResetTimeBit            = 31,
    kUSBReEnumerateCaptureDeviceBit     = 30,
    kUSBReEnumerateReleaseDeviceBit     = 29,
    kUSBAddExtraResetTimeMask           = ( 1 << kUSBAddExtraResetTimeBit),
    kUSBReEnumerateCaptureDeviceMask    = ( 1 << kUSBReEnumerateCaptureDeviceBit),
    kUSBReEnumerateReleaseDeviceMask    = ( 1 << kUSBReEnumerateReleaseDeviceBit)
} USBReEnumerateOptions;

/*!
 @enum USBDeviceInformationBits
 @discussion 	GetUSBDeviceInformation will return a unit32_t value with bits set indicating that a particular state is present in the USB device.  These bits are described here 
 
 @constant	kUSBInformationDeviceIsCaptiveBit			The USB device is directly attached to its hub and cannot be removed.
 @constant	kUSBInformationDeviceIsAttachedToRootHubBit	The USB device is directly attached to the root hub
 @constant	kUSBInformationDeviceIsInternalBit			The USB device is internal to the enclosure (all the hubs it attaches to are captive)
 @constant	kUSBInformationDeviceIsConnectedBit			The USB device is connected to its hub
 @constant	kUSBInformationDeviceIsEnabledBit			The hub port to which the USB device is attached is enabled
 @constant	kUSBInformationDeviceIsSuspendedBit			The hub port to which the USB device is attached is suspended
 @constant	kUSBInformationDeviceIsInResetBit			The hub port to which the USB device is attached is being reset
 @constant	kUSBInformationDeviceOvercurrentBit			The USB device generated an overcurrent
 @constant	kUSBInformationDevicePortIsInTestModeBit	The hub port to which the USB device is attached is in test mode
 @constant  kUSBInformationDeviceIsRootHub				The device is the root hub simulation
 @constant  kUSBInformationRootHubisBuiltIn				If this is a root hub simulation and it's built into the enclosure, this bit is set.  If it's on an expansion card, it will be cleared
 @constant  kUSBInformationDeviceIsRemote				This device is "attached" to the controller through a remote connection
 @constant  kUSBInformationDeviceIsAttachedToEnclosure	The hub port to which the USB device is connected has a USB connector on the enclosure
 @constant  kUSBInformationDeviceIsOnThunderboltBit		The USB device is downstream of a controller that is attached through Thunderbolt
 
 */
	typedef enum {
		kUSBInformationDeviceIsCaptiveBit				= 0,
		kUSBInformationDeviceIsAttachedToRootHubBit		= 1,
		kUSBInformationDeviceIsInternalBit				= 2,
		kUSBInformationDeviceIsConnectedBit				= 3,
		kUSBInformationDeviceIsEnabledBit				= 4,
		kUSBInformationDeviceIsSuspendedBit				= 5,
		kUSBInformationDeviceIsInResetBit				= 6,
		kUSBInformationDeviceOvercurrentBit				= 7,
		kUSBInformationDevicePortIsInTestModeBit		= 8,
		kUSBInformationDeviceIsRootHub					= 9,
		kUSBInformationRootHubisBuiltIn					= 10,
		kUSBInformationRootHubIsBuiltInBit				= 10,
		kUSBInformationDeviceIsRemote					= 11,
		kUSBInformationDeviceIsAttachedToEnclosure		= 12,
		kUSBInformationDeviceIsOnThunderboltBit			= 13,
		kUSBInformationDeviceIsCaptiveMask				= (1 << kUSBInformationDeviceIsCaptiveBit),
		kUSBInformationDeviceIsAttachedToRootHubMask	= (1 << kUSBInformationDeviceIsAttachedToRootHubBit),
		kUSBInformationDeviceIsInternalMask				= (1 << kUSBInformationDeviceIsInternalBit),
		kUSBInformationDeviceIsConnectedMask			= (1 << kUSBInformationDeviceIsConnectedBit),
		kUSBInformationDeviceIsEnabledMask				= (1 << kUSBInformationDeviceIsEnabledBit),
		kUSBInformationDeviceIsSuspendedMask			= (1 << kUSBInformationDeviceIsSuspendedBit),
		kUSBInformationDeviceIsInResetMask				= (1 << kUSBInformationDeviceIsInResetBit),
		kUSBInformationDeviceOvercurrentMask			= (1 << kUSBInformationDeviceOvercurrentBit),
		kUSBInformationDevicePortIsInTestModeMask		= (1 << kUSBInformationDevicePortIsInTestModeBit),
		kUSBInformationDeviceIsRootHubMask				= (1 << kUSBInformationDeviceIsRootHub),
		kUSBInformationRootHubisBuiltInMask				= (1 << kUSBInformationRootHubisBuiltIn),
		kUSBInformationRootHubIsBuiltInMask				= (1 << kUSBInformationRootHubIsBuiltInBit),
		kUSBInformationDeviceIsRemoteMask				= (1 << kUSBInformationDeviceIsRemote),
		kUSBInformationDeviceIsAttachedToEnclosureMask	= (1 << kUSBInformationDeviceIsAttachedToEnclosure),
		kUSBInformationDeviceIsOnThunderboltMask		= (1 << kUSBInformationDeviceIsOnThunderboltBit)
	} USBDeviceInformationBits;
	
	/*!
	 @enum USBPowerRequestTypes
	 @discussion Used to specify what kind of power will be reserved using the IOUSBDevice RequestExtraPower and ReturnExtraPower APIs. 
	 @constant	kUSBPowerDuringSleep	The power is to be used during sleep.  
	 @constant	kUSBPowerDuringWake		The power is to be used while the system is awake (i.e not sleeping)
	 @constant	kUSBPowerRequestWakeRelease		When used with ReturnExtraPower(), it will send a message to all devices to return any extra wake power if possible.
	 @constant	kUSBPowerRequestSleepRelease	When used with ReturnExtraPower(), it will send a message to all devices to return any sleep power if possible.
	 @constant	kUSBPowerRequestWakeReallocate		When used with ReturnExtraPower(), it will send a message to all devices indicating that they can ask for more wake power, as some device has released it.
	 @constant	kUSBPowerRequestSleepReallocate		When used with ReturnExtraPower(), it will send a message to all devices indicating that they can ask for more sleep power, as some device has released it.
	 @constant	kUSBPowerDuringWakeRevocable		The power is to be used while the system is awake (i.e not sleeping), but can be taken away (via the kUSBPowerRequestWakeRelease message).  The system can then allocate that extra power to another device.
	 @constant	kUSBPowerDuringWakeUSB3				This is used by the USB stack to allocate the 400mA extra for USB3, above the 500ma allocated by USB2
	 */
	typedef enum {
		kUSBPowerDuringSleep 			= 0,
		kUSBPowerDuringWake				= 1,
		kUSBPowerRequestWakeRelease 	= 2,
		kUSBPowerRequestSleepRelease 	= 3,
		kUSBPowerRequestWakeReallocate 	= 4,
		kUSBPowerRequestSleepReallocate = 5,
		kUSBPowerDuringWakeRevocable	= 6,
		kUSBPowerDuringWakeUSB3			= 7
	} USBPowerRequestTypes;


	// these are not for a Public API, but are just the bits used below
	enum {
		kUSBNotificationPreForcedSuspendBit              =    0,
		kUSBNotificationPostForcedSuspendBit             =    1,
		kUSBNotificationPreForcedResumeBit               =    2,
		kUSBNotificationPostForcedResumeBit              =    3,
	};
	
		
	/*!
	 @enum USBNotificationTypes
	 @discussion Used to register for USB notifications. These types may be OR'd together if more than one notification is desired. These notification are expected to be acknowledged before the process (e.g. system sleep or system wake) can be continued. See RegisterForNotification and AcknowledgeNotification in IOUSBDeviceInterface and IOUSBInterfaceInterface.
	 @constant	kUSBNotificationPreForcedSuspend	A notification is sent prior to a forced suspend (e.g. system sleep).
	 @constant	kUSBNotificationPostForcedSuspend	A notification is sent after a forced suspend has been completed (e.g. system sleep).
	 @constant	kUSBNotificationPreForcedResume		A notification is sent before a resume which happens after a forced suspend (e.g. system wake).
	 @constant	kUSBNotificationPostForcedResume	A notification is sent after a resume which happens after a forced suspend (e.g. system wake).
	 */
	typedef enum {
		kUSBNotificationPreForcedSuspend             =    (1 << kUSBNotificationPreForcedSuspendBit),
		kUSBNotificationPostForcedSuspend            =    (1 << kUSBNotificationPostForcedSuspendBit),
		kUSBNotificationPreForcedResume              =    (1 << kUSBNotificationPreForcedResumeBit),
		kUSBNotificationPostForcedResume             =    (1 << kUSBNotificationPostForcedResumeBit),
	} USBNotificationTypes;
	
	

	// Apple specific properties
#define kAppleMaxPortCurrent				"AAPL,current-available"
#define kAppleCurrentExtra					"AAPL,current-extra"
#define kAppleMaxPortCurrentInSleep			"AAPL,max-port-current-in-sleep"
#define kAppleCurrentExtraInSleep			"AAPL,current-extra-in-sleep"
#define kAppleRevocableExtraCurrent			"AAPL,revocable-extra-current"
#define kAppleExternalSuperSpeedPorts		"AAPL,ExternalSSPorts"
#define kAppleUnconnectedSuperSpeedPorts	"AAPL,UnconnectedSSPorts"
#define kAppleAcpiRootHubDepth				"AAPL,root-hub-depth"

#define kAppleStandardPortCurrentInSleep	"AAPL,standard-port-current-in-sleep"

#define kAppleInternalUSBDevice				"AAPL,device-internal"
#define kAppleExternalConnectorBitmap       "AAPL,ExternalConnectorBitmap"
#define kUSBBusID							"AAPL,bus-id"
	
	// Deprecated Names and/or values
#define kAppleCurrentAvailable				"AAPL,current-available"
#define kAppleCurrentInSleep				"AAPL,current-in-sleep"
#define kApplePortCurrentInSleep			"AAPL,port-current-in-sleep"

#define kOverrideAttachedToCPU              "kOverrideAttachedToCPU"

// UPC definitions from ACPI Rev 4.0
typedef enum {
	kUSBPortNotConnectable 		= 0,	// Port is not connectable
	kUSBPortConnectable			= 1		// Port is connectable either user visible or invisible
} kUSBConnectable;

typedef enum {
	kUSBTypeAConnector				= 0x00,	// Type A connector
	kUSBTypeMiniABConnector	        = 0x01,	// Mini-AB connector
	kUSBTypeExpressCard				= 0x02,	// ExpressCard
	kUSB3TypeStdAConnector			= 0x03, // USB 3 Standard-A connector
	kUSB3TypeStdBConnector			= 0x04,	// USB 3 Standard-B connector
	kUSB3TypeMicroBConnector		= 0x05,	// USB 3 Micro-B connector
	kUSB3TypeMicroABConnector		= 0x06,	// USB 3 Micro-AB connector
	kUSB3TypePowerBConnector		= 0x07, // USB 3 Power-B connector
	kUSBProprietaryConnector		= 0xFF	// Proprietary connector
} kUSBHostConnectorType;

// Root hub definitions
enum {
	kUSBSpeed_Mask		= USBBitRange(0, 1),
	kUSBSpeed_Shift		= USBBitRangePhase(0, 1),
	
	kUSBAddress_Mask	= USBBitRange(8, 15),
	kUSBAddress_Shift	= USBBitRangePhase(8, 15)
};

enum {
	kXHCISSRootHubAddress	= kUSBMaxDevices,
	kXHCIUSB2RootHubAddress = kUSBMaxDevices+1,
    kSuperSpeedBusBitMask   = 0x01000000
};
    
#define ISROOTHUB(a) ((a == kXHCISSRootHubAddress) || (a == kXHCIUSB2RootHubAddress))

// values (in nanoseconds) which are sent to requireMaxBusStall as appropriate
#define kEHCIIsochMaxBusStall            25000
#define kXHCIIsochMaxBusStall            25000
#define kOHCIIsochMaxBusStall            25000
#define kUHCIIsochMaxBusStall            10000
#define kMaxBusStall10uS                 10000
#define kMaxBusStall25uS                 25000

#ifdef __cplusplus
}       
#endif

#endif
                                                                                                                                                                               USBHub.h                                                                                            0100644 0001750 0001750 00000031022 12567452726 034063  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright  1998-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _USBHUB_H
#define _USBHUB_H

#if KERNEL
#ifndef __IOUSBFAMILY__
#warning "Deprecated header file.  See IOUSBHostFamily for USB-Host KPI."
#endif
#endif

#include <IOKit/usb/USB.h>
#include <IOKit/usb/USBSpec.h>

    /*!
    @header     USBHub.h
     @abstract  Constants and definitions used with Hub devices.
     @discussion    
     */

    /*!
    @enum Hub Descriptor Type
    @discussion
    */
enum {
    kUSBHubDescriptorType       = 0x29,
    kUSB3HubDescriptorType       = 0x2A
};

    /*!
    @enum HubFeatures
    @discussion Used with SET_FEATURE to set hub and port features
    */
enum {
                            
    kUSBHubLocalPowerChangeFeature      = 0,    /* Hub features */
    kUSBHubOverCurrentChangeFeature     = 1,

    kUSBHubPortConnectionFeature        = 0,    /* port features */
    kUSBHubPortEnableFeature            = 1,
    kUSBHubPortSuspendFeature           = 2,
    kUSBHubPortOverCurrentFeature       = 3,
    kUSBHubPortResetFeature             = 4,
    kUSBHubPortPowerFeature             = 8,
    kUSBHubPortLowSpeedFeature          = 9,
    kUSBHubPortConnectionChangeFeature  = 16,
    kUSBHubPortEnableChangeFeature      = 17,
    kUSBHubPortSuspendChangeFeature     = 18,
    kUSBHubPortOverCurrentChangeFeature = 19,
    kUSBHubPortResetChangeFeature       = 20,
    kUSBHubPortTestFeature				= 21,
	kUSBHubPortIndicatorFeature			= 22,
	
	// USB 3.0
	kUSBHubPortLinkStateFeature				= 5,    /* port features */
	kUSBHubPortU1TimeoutFeature				= 23,
	kUSBHubPortU2TimeoutFeature				= 24,
	kUSBHubPortLinkStateChangeFeature		= 25,
	kUSBHubPortConfigErrorChangeFeature		= 26,
	kUSBHubPortRemoteWakeMaskFeature		= 27,
	kUSBHubPortBHPortResetFeature			= 28,
	kUSBHubPortBHResetChangeFeature			= 29,
	kUSBHubPortForceLinkPMAcceptFeature		= 30,
	
};

    /*!
    @enum HubPortStatus
    @discussion Used to decode the Port Status and Change 
    */
enum {
	kSSHubPortStatusConnectionBit	= 0,
	kSSHubPortStatusEnabledBit		= 1,
	kSSHubPortStatusOverCurrentBit	= 3,
	kSSHubPortStatusResetBit		= 4,
	
	// USB 3.0
	kSSHubPortStatusLinkStateShift		= 5,
	kSSHubPortStatusPowerBit			= 9,
	kSSHubPortStatusSpeedShift			= 10,
	kSSHubPortChangeBHResetBit			= 5,
	kSSHubPortChangePortLinkStateBit 	= 6,
	kSSHubPortChangePortConfigErrBit	= 7,

    kHubPortConnection		= 0x0001,
    kHubPortEnabled			= 0x0002,
    kHubPortSuspend			= 0x0004,
    kHubPortOverCurrent		= 0x0008,
    kHubPortBeingReset		= 0x0010,
    kHubPortPower			= 0x0100,
    kHubPortLowSpeed		= 0x0200,
    kHubPortHighSpeed		= 0x0400,
    kHubPortTestMode		= 0x0800,
    kHubPortIndicator		= 0x1000,
    kHubPortSuperSpeed		= 0x2000,					// This is a synthesized bit that is using a reserved bit from the Hub Port Status definition in USB 2.0.
	kHubPortBit14			= 0x4000,					// That bit is used by the hub driver to encode the USB3 link state into the USB2 PortStatus (using bits 5-7 as well, that are reserved in the USB 2 spec)
    kHubPortDebouncing		= 0x8000,					// This is a synthesized bit that is using a reserved bit from the Hub Port Status definition in USB 2.0.
	
	// USB 3.0
	kSSHubPortStatusConnectionMask	= ( 1 << kSSHubPortStatusConnectionBit ),
	kSSHubPortStatusEnabledMask		= ( 1 << kSSHubPortStatusEnabledBit ),
	kSSHubPortStatusOverCurrentMask	= ( 1 << kSSHubPortStatusOverCurrentBit ),
	kSSHubPortStatusBeingResetMask	= ( 1 << kSSHubPortStatusResetBit ),
    kSSHubPortStatusLinkStateMask	= 0x01E0,
    kSSHubPortStatusPowerMask		= ( 1 << kSSHubPortStatusPowerBit ),
	kSSHubPortStatusSpeedMask		= 0x1C00,
	kSSHubPortChangeBHResetMask		= ( 1 << kSSHubPortChangeBHResetBit ),
	kSSHubPortChangePortLinkStateMask = ( 1 << kSSHubPortChangePortLinkStateBit ),
	kSSHubPortChangePortConfigErrMask = ( 1 << kSSHubPortChangePortConfigErrBit ),

    // these are the bits which cause the hub port state machine to keep moving (USB 3.0)
    kHubPortSuperSpeedStateChangeMask		= (kHubPortConnection | kHubPortEnabled | kHubPortSuspend | kHubPortOverCurrent | kHubPortBeingReset | kSSHubPortStatusBeingResetMask | kSSHubPortChangePortLinkStateMask | kSSHubPortChangePortConfigErrMask),
    // these are the bits which cause the hub port state machine to keep moving (USB 2.0)
    kHubPortStateChangeMask                 = (kHubPortConnection | kHubPortEnabled | kHubPortSuspend | kHubPortOverCurrent | kHubPortBeingReset)
};


    /*!
    @enum HubStatus
    @discussion Used to decode the Hub Status and Change 
    */
enum {
    kHubLocalPowerStatus        = 1,
    kHubOverCurrentIndicator    = 2,
    kHubLocalPowerStatusChange  = 1,
    kHubOverCurrentIndicatorChange  = 2
};

    /*!
    @enum HubCharacteristics
    @discussion 
    */
enum {
    kPerPortSwitchingBit    = (1 << 0),
    kNoPowerSwitchingBit    = (1 << 1),
    kCompoundDeviceBit      = (1 << 2),
    kPerPortOverCurrentBit  = (1 << 3),
    kNoOverCurrentBit       = (1 << 4),
	
    kUSBHubOvercurrentMask  = 0x18,
    kUSBHubOvercurrentShift = 3,
    
	kHubTTThinkTimeMask		= 0x60,
	kHubTTThinkTimeShift	= 5,
	
	kHubPortIndicatorBit	= 7,
	kHubPortIndicatorMask	= 0x0080
};

/*!
@enum PowerSwitching
 @discussion 
 */
enum {
	kHubSupportsGangPower	= 0,
	kHubSupportsIndividualPortPower = 1,
	kHubPortSetPowerOff		= 0,
	kHubPortSetPowerOn		= 1
};

/*!
@enum PortIndicatorSelectors
 @discussion 
 */
enum {
	kHubPortIndicatorAutomatic	= 0,
	kHubPortIndicatorAmber,
	kHubPortIndicatorGreen,
	kHubPortIndicatorOff
};

/*!
 @enum Root Hub specific 
 @discussion 
 */
enum {
	kPrdRootHubApple			= 0x8005,	// ProductID for classic speed root hubs
	kPrdRootHubAppleE			= 0x8006,	// ProductID for high speed root hubs
	kPrdRootHubAppleSS			= 0x8007,	// ProductID for super speed root hubs
	kUSBRootHubPollingRate		= 32		// Enpoint polling rate interval for root hubs
};

/*!
 @enum Hub Class Request
 @discussion Specifies values for the bRequest field of a Device Request.
 */
enum USBHubClassRequest {
    kUSBHubRqGetStatus     = 0,
    kUSBHubRqClearFeature  = 1,
    kUSBHubRqGetState      = 2,
    kUSBHubRqSetFeature    = 3,
    kUSBHubRqReserved2     = 4,
    kUSBHubRqSetAddress    = 5,
    kUSBHubRqGetDescriptor = 6,
    kUSBHubRqSetDescriptor = 7,
    kUSBHubRqGetConfig     = 8,
    kUSBHubRqSetConfig     = 9,
    kUSBHubRqGetInterface  = 10,
    kUSBHubRqSetInterface  = 11,
};

/*!
@enum Hub Device Requests
@discussion  Encoding of the hub specific standard requests
<tt>
<pre><b>
Request          bmRequestType bRequest       wValue  wIndex wLength Data</b>
ClearHubFeature  0010 0000B    CLEAR_FEATURE  Feature Zero    Zero   None
ClearPortFeature 0010 0011B                   Feature Port    Zero   None

GetBusState      1010 0011B    GET_STATE      Zero    Port    One    Port Bus State

GetHubDescriptor 1010 0000B    GET_DESCRIPTOR Type    Zero    Length Descriptor

GetHubStatus     1010 0000B    GET_STATUS     Zero    Zero    Four   Hub Status
GetPortStatus    1010 0011B                   Zero    Port    Four   Port Status

SetHubDescriptor 0010 0000B    SET_DESCRIPTOR Type    Zero    Length Descriptor

SetHubFeature    0010 0000B    SET_FEATURE    Feature Zero    Zero   None
SetPortFeature   0010 0011B                   Feature Port    Zero   None
</pre>
</tt>
    */
enum {
    kClearHubFeature  = EncodeRequest(kUSBRqClearFeature,  kUSBOut, kUSBClass, kUSBDevice),
    kClearPortFeature = EncodeRequest(kUSBRqClearFeature,  kUSBOut, kUSBClass, kUSBOther),
    kGetPortState     = EncodeRequest(kUSBRqGetState,      kUSBIn,  kUSBClass, kUSBOther),
    kGetHubDescriptor = EncodeRequest(kUSBRqGetDescriptor, kUSBIn,  kUSBClass, kUSBDevice),
    kGetHub3Descriptor= EncodeRequest(kUSBRqGetDescriptor, kUSBIn,  kUSBClass, kUSBDevice),
    kGetHubStatus     = EncodeRequest(kUSBRqGetStatus,     kUSBIn,  kUSBClass, kUSBDevice),
    kGetPortStatus    = EncodeRequest(kUSBRqGetStatus,     kUSBIn,  kUSBClass, kUSBOther),
    kSetHubDescriptor = EncodeRequest(kUSBRqGetDescriptor, kUSBOut, kUSBClass, kUSBDevice),
    kSetHubFeature    = EncodeRequest(kUSBRqSetFeature,    kUSBOut, kUSBClass, kUSBDevice),
    kSetPortFeature   = EncodeRequest(kUSBRqSetFeature,    kUSBOut, kUSBClass, kUSBOther)
};


/*!
    @typedef IOUSBHubDescriptor
    @discussion USB Hub Descriptor.  See the USB HID Specification at <a href="http://www.usb.org"TARGET="_blank">http://www.usb.org</a>.
*/

enum{
	// Support a maximum of 64 ports, which will pack into 9 bytes
	kNumPortBytes = 9
};

struct IOUSBHubDescriptor {
    UInt8   length;
    UInt8   hubType;
    UInt8   numPorts;
    UInt16  characteristics __attribute__((packed));
    UInt8   powerOnToGood;								// Port settling time, in 2ms
    UInt8   hubCurrent;
    // These are received packed, will have to be unpacked
    UInt8   removablePortFlags[kNumPortBytes];
    UInt8   pwrCtlPortFlags[kNumPortBytes];
};

typedef struct IOUSBHubDescriptor IOUSBHubDescriptor;

enum
{
	// these are sent to the controller when configuring a HS hub
	
    kUSBHSHubCommandAddHub				= 1,
    kUSBHSHubCommandRemoveHub			= 2,
    
    kUSBHSHubFlagsMultiTTMask			= 0x01,
	kUSBHSHubFlagsMoreInfoMask			= 0x02,
	kUSBHSHubFlagsTTThinkTimeShift		= 2,
	kUSBHSHubFlagsTTThinkTimeMask		= 0x0C,
	kUSBHSHubFlagsNumPortsShift			= 4,
	kUSBHSHubFlagsNumPortsMask			= 0xF0
};

// To cope with the extra fields in a USB3 hub descriptor

struct IOUSB3HubDescriptor {
    UInt8   length;
    UInt8   hubType;
    UInt8   numPorts;
    UInt16  characteristics __attribute__((packed));
    UInt8   powerOnToGood;								// Port settling time, in 2ms
    UInt8   hubCurrent;
	UInt8   hubHdrDecLat;								// Header decode latency, new 3.0 field
    UInt16  hubDelay __attribute__((packed));			// new in 3.0
	
    // These are received packed, will have to be unpacked
    UInt8   removablePortFlags[kNumPortBytes];
    UInt8   pwrCtlPortFlags[kNumPortBytes];				// This field does not exist in the 3.0 descriptor
};

typedef struct IOUSB3HubDescriptor IOUSB3HubDescriptor;

/*!
    @typedef IOUSBHubStatus
    @discussion Used to get the port status and change flags using GetPortStatus()
*/
struct IOUSBHubStatus {
    UInt16          statusFlags;
    UInt16          changeFlags;
};
typedef struct IOUSBHubStatus   IOUSBHubStatus;
typedef IOUSBHubStatus *    IOUSBHubStatusPtr;

typedef struct IOUSBHubStatus   IOUSBHubPortStatus;


/*!
    @typedef IOUSBHubPortReEnumerateParam
    @discussion Used to specify the port that needs to be reenumerated
*/
typedef struct IOUSBHubPortReEnumerateParam IOUSBHubPortReEnumerateParam;

struct IOUSBHubPortReEnumerateParam {
    UInt32   portNumber;
    UInt32   options;
};

typedef struct IOUSBHubPortClearTTParam IOUSBHubPortClearTTParam;

struct IOUSBHubPortClearTTParam {
    UInt32	 portNumber;
    UInt32	 options;
#if 0
    UInt8 	 deviceAddress;  <<0
	UInt8	 endpointNum;    <<8
	UInt8 	 endpointType;	 <<16 // As split transaction. 00 Control, 10 Bulk
	UInt8 	 IN;		 <<24 // Direction, 1 = IN, 0 = OUT
#endif
};

#pragma mark USB 3 Additions

/*!
 @enum USB 3 Hub Class Request
 @discussion Specifies values for the bRequest field of a Device Request.
 */
enum {
	kUSBHubRqSetHubDepth	= 12,
	kUSBHubRqGetPortErrorCount	= 13
};

enum {
	kSetHubDepth		= EncodeRequest(kUSBHubRqSetHubDepth, kUSBOut, kUSBClass, kUSBDevice),
    kGetPortErrorCount	= EncodeRequest(kUSBHubRqGetPortErrorCount, kUSBIn, kUSBClass, kUSBOther)
};

/*!
 @enum Link State for USB 3.0
 @discussion Used to decode the Port Status and Change 
 */
enum {
	kSSHubPortLinkStateU0			= 0,
	kSSHubPortLinkStateU1			= 1,
	kSSHubPortLinkStateU2			= 2,
	kSSHubPortLinkStateU3			= 3,
	kSSHubPortLinkStateSSDisabled	= 4,
	kSSHubPortLinkStateRxDetect		= 5,
	kSSHubPortLinkStateSSInactive	= 6,
	kSSHubPortLinkStatePolling		= 7,
	kSSHubPortLinkStateRecovery		= 8,
	kSSHubPortLinkStateHotReset		= 9,
	kSSHubPortLinkStateComplianceMode	= 10,
	kSSHubPortLinkStateLoopBack		= 11,
	
	kSSHubPortSpeed5Gbps			= 0
};
	
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              USBSpec.h                                                                                           0100644 0001750 0001750 00000042727 12567452726 034255  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/usb                                                            /*
 * Copyright  1998-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


/*
 * Constants that both OS9 and OSX want to define, and whose values are
 * specified by the USB Standard.
 * Put in a seperate file so they can be included if the OS9 include file isn't already
 * included.
 */
#ifndef _USBSPEC_H
#define _USBSPEC_H

#if KERNEL
#ifndef __IOUSBFAMILY__
#warning "Deprecated header file.  See IOUSBHostFamily for USB-Host KPI."
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

    /*!
    @header     USBSpec.h
     @abstract  Constants and definitions of parameters that are used in communcating with USB devices and interfaces.
     @discussion    
     */

    /*!
    @enum Endpoint type
    @discussion Used in IOUSBFindEndpointRequest's type field
    */
enum {
    kUSBControl     = 0,
    kUSBIsoc        = 1,
    kUSBBulk        = 2,
    kUSBInterrupt   = 3,
    kUSBAnyType     = 0xFF
};

    /*!
    @enum Endpoint direction
    @discussion Used in IOUSBFindEndpointRequest's direction field
    */
enum {
    kUSBOut         = 0,
    kUSBIn          = 1,
    kUSBNone        = 2,
    kUSBAnyDirn     = 3
};

    /*!
    @enum Device Request Type
    @discussion This type is encoded in the bmRequestType field of a Device Request.  It specifies the type of request: standard, class or vendor specific.
    */
enum {
    kUSBStandard    = 0,
    kUSBClass       = 1,
    kUSBVendor      = 2
};

    /*!
    @enum Device Request Recipient
    @discussion This recipient is encoded in the bmRequestType field of a Device Request.  It specifies the type of recipient for a request:  the device, the interface, or an endpoint.
    */
enum {
    kUSBDevice      = 0,
    kUSBInterface   = 1,
    kUSBEndpoint    = 2,
    kUSBOther       = 3
};

    /*!
    @enum Device Request
    @discussion Specifies values for the bRequest field of a Device Request.
    */
enum {
    kUSBRqGetStatus     = 0,
    kUSBRqClearFeature  = 1,
    kUSBRqGetState      = 2,
    kUSBRqSetFeature    = 3,
    kUSBRqReserved2     = 4,
    kUSBRqSetAddress    = 5,
    kUSBRqGetDescriptor = 6,
    kUSBRqSetDescriptor = 7,
    kUSBRqGetConfig     = 8,
    kUSBRqSetConfig     = 9,
    kUSBRqGetInterface  = 10,
    kUSBRqSetInterface  = 11,
    kUSBRqSyncFrame     = 12,
	kUSBSetSel			= 48,
	kUSBSetIsochDelay	= 49
};

    /*!
    @enum USB Descriptors
    @discussion Specifies values for diffent descriptor types.
    */
enum {
    kUSBAnyDesc             = 0,    // Wildcard for searches
    kUSBDeviceDesc          = 1,
    kUSBConfDesc            = 2,
    kUSBStringDesc          = 3,
    kUSBInterfaceDesc       = 4,
    kUSBEndpointDesc        = 5,
    kUSBDeviceQualifierDesc = 6,
    kUSBOtherSpeedConfDesc  = 7,
    kUSBInterfacePowerDesc  = 8,
    kUSBOnTheGoDesc	    = 9,
    kUSDebugDesc	    = 10,
    kUSBInterfaceAssociationDesc 	= 11,
	kUSBBOSDescriptor				= 15,
	kUSBDeviceCapability			= 16,
	kUSBSuperSpeedEndpointCompanion = 48,
    kUSB3HUBDesc             		= 0x2A,
    kUSBHIDDesc             		= 0x21,
    kUSBReportDesc          		= 0x22,
    kUSBPhysicalDesc        		= 0x23,
    kUSBHUBDesc             		= 0x29,
};

	
    /*!
	 @enum Device Capability Types
	 @discussion Used with decoding the Device Capability descriptor
	 */
	enum {
		kUSBDeviceCapabilityWirelessUSB		= 1,
		kUSBDeviceCapabilityUSB20Extension	= 2,
		kUSBDeviceCapabilitySuperSpeedUSB	= 3,
		kUSBDeviceCapabilityContainerID		= 4
};

    /*!
    @enum Feature Selectors
    @discussion Used with SET/CLEAR_FEATURE requests.
    */
enum {
	kUSBFeatureEndpointStall 		= 0,		// Endpoint
	kUSBFeatureDeviceRemoteWakeup	= 1,		// Device
	kUSBFeatureTestMode				= 2,		// Device
	kUSBFeatureFunctionSuspend		= 0,		// Interface
	kUSBFeatureU1Enable				= 48,		// Device
	kUSBFeatureU2Enable				= 49,		// Device
	kUSBFeatureLTMEnable			= 50		// Device
};

    /*!
	 @enum Miscellaneous bits and masks
	 */
	enum {
		kUSBFunctionRemoteWakeCapableBit	=	0,		//  GET_STATUS
		kUSBFunctionRemoteWakeupBit			=	1,		//  GET_STATUS
		kUSBLowPowerSuspendStateBit			=	0,		//  SET_FEATURE(FUNCTION_SUSPEND)
		kUSBFunctionRemoteWakeEnableBit		=	1		//  SET_FEATURE(FUNCTION_SUSPEND)
		};
	
    /*!
    @enum USB Power constants
    @discussion Constants relating to USB Power.
    */
enum {
    kUSB100mAAvailable  = 50,
    kUSB500mAAvailable  = 250,
    kUSB100mA           = 50,
    kUSBAtrBusPowered   = 0x80,
    kUSBAtrSelfPowered  = 0x40,
    kUSBAtrRemoteWakeup = 0x20,
	kUSB2MaxPowerPerPort = kUSB500mAAvailable * 2,
    kUSB150mAAvailable  = 75,
    kUSB900mAAvailable  = 450,
    kUSB150mA           = 75,
	kUSB3MaxPowerPerPort = kUSB900mAAvailable * 2
};

    /*!
    @enum USB Release constants
    @discussion Constants relating to USB releases as found in the bcdUSB field of the Device Descriptor.
    */
enum {
    kUSBRel10       = 0x0100,
    kUSBRel11       = 0x0110,
    kUSBRel20       = 0x0200,
    kUSBRel30       = 0x0300
};


    /*!
    @enum HID requests
    @discussion Constants for HID requests.
    */
enum {
    kHIDRqGetReport     = 1,
    kHIDRqGetIdle       = 2,
    kHIDRqGetProtocol   = 3,
    kHIDRqSetReport     = 9,
    kHIDRqSetIdle       = 10,
    kHIDRqSetProtocol   = 11
};

    /*!
    @enum HID report types
    @discussion Constants for the three kinds of HID reports.
    */
enum {
    kHIDRtInputReport       = 1,
    kHIDRtOutputReport      = 2,
    kHIDRtFeatureReport     = 3
};


    /*!
    @enum HID Protocol
    @discussion  Used in the SET_PROTOCOL device request
    */
enum {
    kHIDBootProtocolValue   = 0,
    kHIDReportProtocolValue = 1
};



enum {
    kUSBCapsLockKey         = 0x39,
    kUSBNumLockKey          = 0x53,
    kUSBScrollLockKey       = 0x47
};

/*!
@enum Device Class Codes
 @discussion Constants for USB Device classes (bDeviceClass).
 */
enum {
    kUSBCompositeClass          	= 0,
    kUSBCommClass               	= 2,		// Deprecated
    kUSBCommunicationClass			= 2,	
    kUSBHubClass                	= 9,
    kUSBDataClass               	= 10,
	kUSBPersonalHealthcareClass		= 15,
    kUSBBillBoardClass              = 17,
    kUSBDiagnosticClass				= 220,
    kUSBWirelessControllerClass 	= 224,
    kUSBMiscellaneousClass			= 239,
    kUSBApplicationSpecificClass 	= 254,
    kUSBVendorSpecificClass     	= 255
};

/*!
@enum Interface Class
 @discussion Constants for Interface classes (bInterfaceClass).
 */
enum {
    kUSBAudioClass							= 1,		// Deprecated
    kUSBAudioInterfaceClass					= 1,

    kUSBCommunicationControlInterfaceClass	= 2,
    kUSBCommunicationDataInterfaceClass		= 10,

    kUSBHIDClass							= 3,
    kUSBHIDInterfaceClass					= 3,

    kUSBPhysicalInterfaceClass				= 5,

    kUSBImageInterfaceClass					= 6,

    kUSBPrintingClass						= 7,		// Deprecated
    kUSBPrintingInterfaceClass				= 7,

    kUSBMassStorageClass					= 8,		// Deprecated
    kUSBMassStorageInterfaceClass			= 8,

    kUSBChipSmartCardInterfaceClass			= 11,
    
    kUSBContentSecurityInterfaceClass 		= 13,
    
    kUSBVideoInterfaceClass					= 14,
	
	kUSBPersonalHealthcareInterfaceClass	= 15,
    
    kUSBDiagnosticDeviceInterfaceClass 		= 220,

    kUSBWirelessControllerInterfaceClass	= 224,

    kUSBApplicationSpecificInterfaceClass	= 254,
    
    kUSBVendorSpecificInterfaceClass     	= 255
};

// Obsolete
enum {
        
    kUSBDisplayClass            = 4,		// Obsolete
};

/*!
    @enum Interface SubClass
    @discussion Constants for USB Interface SubClasses (bInterfaceSubClass).
*/
enum {
    kUSBCompositeSubClass               = 0,
    
    kUSBHubSubClass                     = 0,

    // For the kUSBAudioInterfaceClass
    //
    kUSBAudioControlSubClass		= 0x01,
    kUSBAudioStreamingSubClass		= 0x02,
    kUSBMIDIStreamingSubClass		= 0x03,
    
    // For the kUSBApplicationSpecificInterfaceClass
    //
    kUSBDFUSubClass                     = 0x01,
    kUSBIrDABridgeSubClass              = 0x02,
    kUSBTestMeasurementSubClass		= 0x03,

    // For the kUSBMassStorageInterfaceClass
    //
    kUSBMassStorageRBCSubClass          = 0x01,
    kUSBMassStorageATAPISubClass        = 0x02,
    kUSBMassStorageQIC157SubClass       = 0x03,
    kUSBMassStorageUFISubClass          = 0x04,
    kUSBMassStorageSFF8070iSubClass     = 0x05,
    kUSBMassStorageSCSISubClass         = 0x06,

    // For the kUSBHIDInterfaceClass
    //
    kUSBHIDBootInterfaceSubClass        = 0x01,

    // For the kUSBCommunicationDataInterfaceClass
    //
    kUSBCommDirectLineSubClass          = 0x01,
    kUSBCommAbstractSubClass            = 0x02,
    kUSBCommTelephoneSubClass           = 0x03,
    kUSBCommMultiChannelSubClass        = 0x04,
    kUSBCommCAPISubClass                = 0x05,
    kUSBCommEthernetNetworkingSubClass  = 0x06,
    kUSBATMNetworkingSubClass           = 0x07,

    // For the kUSBDiagnosticDeviceInterfaceClass
    //
    kUSBReprogrammableDiagnosticSubClass	= 0x01,

    // For the kUSBWirelessControllerInterfaceClass
    //
    kUSBRFControllerSubClass		= 0x01,

    // For the kUSBMiscellaneousClass
    //
    kUSBCommonClassSubClass		= 0x02,

    // For the kUSBVideoInterfaceClass
    //
    kUSBVideoControlSubClass		= 0x01,
    kUSBVideoStreamingSubClass		= 0x02,
    kUSBVideoInterfaceCollectionSubClass = 0x03
    
};

	enum USBClassSpecificDesc {
		kUSBClassSpecificDescriptor		= 0x24
	};
	

/*!
@enum	Interface Protocol
 @discussion Reported in the bInterfaceProtocol field of the Interface Descriptor.
 */
enum {

	// For kUSBHubClass
	kHubSuperSpeedProtocol			= 3,
	
    // For kUSBHIDInterfaceClass
    //
    kHIDNoInterfaceProtocol		= 0,
    kHIDKeyboardInterfaceProtocol	= 1,
    kHIDMouseInterfaceProtocol		= 2,
    kUSBVendorSpecificProtocol		= 0xff,

    // For kUSBDiagnosticDeviceInterfaceClass
    //
    kUSB2ComplianceDeviceProtocol	= 0x01,

    // For kUSBWirelessControllerInterfaceClass
    //
    kUSBBluetoothProgrammingInterfaceProtocol	= 0x01,

    // For kUSBMiscellaneousClass
    //
    KUSBInterfaceAssociationDescriptorProtocol	= 0x01,
	
	// For Mass Storage
	//
	kMSCProtocolControlBulkInterrupt	= 0x00,
	kMSCProtocolControlBulk				= 0x01,
	kMSCProtocolBulkOnly				= 0x50,
	kMSCProtocolUSBAttachedSCSI			= 0x62
};


/*!
    @enum DFU Class Attributes
    @discussion 
*/
enum {
    kUSBDFUAttributesMask       = 0x07,
    kUSBDFUCanDownloadBit       = 0,
    kUSBDFUCanUploadBit         = 1,
    kUSBDFUManifestationTolerantBit     = 2
};

/*!
 @enum Printer Class Requests
 @discussion The bRequest parameter for Printing Class Sepcific Requests
 */
enum {
	kUSPrintingClassGetDeviceID		= 0,
	kUSPrintingClassGePortStatus	= 1,
	kUSPrintingClassSoftReset		= 2
};

	/*!
@enum Endpoint Descriptor bits
 @discussion Bit definitions for endpoint descriptor fields
 */
enum {
    kUSBbEndpointAddressMask				= 0x0f,
    kUSBbEndpointDirectionBit				= 7,
    kUSBbEndpointDirectionMask				= ( 1 << kUSBbEndpointDirectionBit ),
    kUSBEndpointDirectionOut				= 0x00,
    kUSBEndpointDirectionIn					= 0x80,
	
    kUSBEndpointbmAttributesTransferTypeMask			= 0x03,
    kUSBEndpointbmAttributesSynchronizationTypeMask		= 0x0c,
    kUSBEndpointbmAttributesSynchronizationTypeShift	= 2,
    kUSBEndpointbmAttributesUsageTypeMask				= 0x30,
    kUSBEndpointbmAttributesUsageTypeShift				= 4,
	
	kUSBPeriodicInterruptUsageType			= 0,
	kUSBNotificationInterruptUsageType 		= 1,
	kUSBNoSynchronizationIsocSyncType		= 0,
	kUSBAsynchronousIsocSyncType			= 1,
	kUSBAdaptiveIsocSyncType				= 2,
	kUSBSynchronousIsocSyncType				= 3,
	kUSBDataIsocUsageType					= 0,
	kUSBFeedbackIsocUsageType				= 1,
	kUSBImplicitFeedbackDataIsocUsageType 	= 2
};

	/*!
	 @enum USB Device Capability Type constants
	 @discussion Bit definitions and constants for different values of USB Device Capability types
	 */
	enum {
		kUSB20ExtensionLPMSupported	=	1,		// Bit 1 of bmAttributes of USB 2.0 Extension Device Capability
		kUSBSuperSpeedLTMCapable	=	1,		// Bit 1 of bmAttributes of SuperSpeed USB Device Capability
		kUSBSuperSpeedSupportsLS	=	0,		// Value of wSpeedSupported indicating that the device supports low speed
		kUSBSuperSpeedSupportsFS	=	1,		// Value of wSpeedSupported indicating that the device supports full speed
		kUSBSuperSpeedSupportsHS	=	2,		// Value of wSpeedSupported indicating that the device supports high speed
		kUSBSuperSpeedSupportsSS	=	3,		// Value of wSpeedSupported indicating that the device supports 5 Gbps
	};
		
	/*!
	 @defineblock USB Descriptor and IORegistry constants
	 @discussion 	Various constants used to describe the fields in the various USB Device Descriptors and IORegistry names used for some of those fields 
	 
	 @define	kUSBDeviceClass				The field in the USB Device Descriptor corresponding to the device class
	 @define	kUSBDeviceSubClass			The field in the USB Device Descriptor corresponding to the device sub class
	 @define	kUSBDeviceProtocol			The field in the USB Device Descriptor corresponding to the device protocol
	 @define	kUSBDeviceMaxPacketSize		The field in the USB Device Descriptor corresponding to the maximum packet size for endpoint 0
	 @define	kUSBVendorID				The field in the USB Device Descriptor corresponding to the device USB Vendor ID
	 @define	kUSBVendorName				Deprecated.  Use kUSBVendorID 
	 @define	kUSBProductID				The field in the USB Device Descriptor corresponding to the device USB Product ID
	 @define	kUSBProductName				Deprecated.  Use kUSBProductID
	 @define	kUSBDeviceReleaseNumber		The field in the USB Device Descriptor corresponding to the device release version
	 @define	kUSBManufacturerStringIndex	The field in the USB Device Descriptor corresponding to the index for the manufacturer's string
	 @define	kUSBProductStringIndex		The field in the USB Device Descriptor corresponding to the index for the product name's string
	 @define	kUSBSerialNumberStringIndex	The field in the USB Device Descriptor corresponding to the index for the serial number's string
	 @define	kUSBDeviceNumConfigs		The field in the USB Configuration Descriptor corresponding to the number of configurations
	 @define	kUSBInterfaceNumber			The field in the USB Configuration Descriptor corresponding to the number of configurations
	 @define	kUSBAlternateSetting		The field in the USB Configuration Descriptor corresponding to the number of configurations
	 @define	kUSBNumEndpoints			The field in the USB Configuration Descriptor corresponding to the number of configurations
	 @define	kUSBInterfaceClass			The field in the USB Interface Descriptor corresponding to the interface class
	 @define	kUSBInterfaceSubClass		The field in the USB Interface Descriptor corresponding to the interface sub class
	 @define	kUSBInterfaceProtocol		The field in the USB Interface Descriptor corresponding to the interface protocol
	 @define	kUSBInterfaceStringIndex	The field in the USB Interface Descriptor corresponding to the index for the interface name's string
	 @define	kUSBConfigurationValue		The field in the USB Interface Descriptor corresponding to the configuration
	 @define	kUSBProductString			IORegistry key for the device's USB Product string
	 @define	kUSBVendorString			IORegistry key for the device's USB manufacturer string
	 @define	kUSBSerialNumberString		IORegistry key for the device's USB serial number string
	 @define	kUSB1284DeviceID			IORegistry key for the 1284 Device ID of a printer
	 
	 */
#define kUSBDeviceClass             "bDeviceClass"
#define kUSBDeviceSubClass          "bDeviceSubClass"
#define kUSBDeviceProtocol          "bDeviceProtocol"
#define kUSBDeviceMaxPacketSize     "bMaxPacketSize0"
#define kUSBVendorID                "idVendor"          // good name
#define kUSBVendorName              kUSBVendorID        // bad name - keep for backward compatibility
#define kUSBProductID               "idProduct"         // good name
#define kUSBProductName             kUSBProductID       // bad name - keep for backward compatibility
#define kUSBDeviceReleaseNumber     "bcdDevice"
#define kUSBSpecReleaseNumber       "bcdUSB"
#define kUSBManufacturerStringIndex "iManufacturer"
#define kUSBProductStringIndex      "iProduct"
#define kUSBSerialNumberStringIndex "iSerialNumber"
#define kUSBDeviceNumConfigs        "bNumConfigurations"
#define kUSBInterfaceNumber         "bInterfaceNumber"
#define kUSBAlternateSetting        "bAlternateSetting"
#define kUSBNumEndpoints            "bNumEndpoints"
#define kUSBInterfaceClass          "bInterfaceClass"
#define kUSBInterfaceSubClass       "bInterfaceSubClass"
#define kUSBInterfaceProtocol       "bInterfaceProtocol"
#define kUSBInterfaceStringIndex    "iInterface"
#define kUSBConfigurationValue      "bConfigurationValue"
#define kUSBProductString			"USB Product Name"	
#define kUSBVendorString			"USB Vendor Name"
#define kUSBSerialNumberString		"USB Serial Number"
#define kUSB1284DeviceID			"1284 Device ID"
 /*! @/defineblock */
	
	/*!
    @enum Apple USB Vendor ID
    @discussion Apple's vendor ID, assigned by the USB-IF
*/
enum {
	kAppleVendorID      = 0x05AC
};
	
#ifdef __cplusplus
}       
#endif

#endif
                                         video/                                                                                              0040755 0001750 0001750 00000000000 12612224742 033126  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit                                                                IOVideoControlDictionary.h                                                                          0100644 0001750 0001750 00000005730 12567455331 040177  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoControlDictionary.h
	
	Contains:	

	Copyright:	 2006-2012 by Apple Inc., all rights reserved.
*/

#if !defined(__IOVideoControlDictionary_h__)
#define __IOVideoControlDictionary_h__

// System Includes
#include <IOKit/video/IOVideoTypes.h>

class	OSArray;
class	OSDictionary;
class	OSString;

class IOVideoControlDictionary
{
//	Construction/Destruction
public:
	static OSDictionary*	create(UInt32 controlID, UInt32 baseClass, UInt32 derivedClass, UInt32 scope, UInt32 element, bool isReadOnly = false, UInt32 variant = 0, OSString* name = NULL);
	static OSDictionary*	createBooleanControl(UInt32 controlID, UInt32 baseClass, UInt32 derivedClass, UInt32 scope, UInt32 element, bool value, bool isReadOnly = false, UInt32 variant = 0, OSString* name = NULL);
	static OSDictionary*	createSelectorControl(UInt32 controlID, UInt32 baseClass, UInt32 derivedClass, UInt32 scope, UInt32 element, UInt32 value, OSArray* selectorMap, bool isReadOnly = false, UInt32 variant = 0, OSString* name = NULL);

//	General Attributes
public:
	static OSDictionary*	getControlByID(OSArray* controlList, UInt32 controlID);

	static UInt32			getControlID(const OSDictionary* dictionary);
	static void				setControlID(OSDictionary* dictionary, UInt32 controlID);

	static UInt32			getBaseClass(const OSDictionary* dictionary);
	static void				setBaseClass(OSDictionary* dictionary, UInt32 baseClass);

	static UInt32			getClass(const OSDictionary* dictionary);
	static void				setClass(OSDictionary* dictionary, UInt32 derivedClass);

	static UInt32			getScope(const OSDictionary* dictionary);
	static void				setScope(OSDictionary* dictionary, UInt32 scope);

	static UInt32			getElement(const OSDictionary* dictionary);
	static void				setElement(OSDictionary* dictionary, UInt32 element);

	static bool				isReadOnly(const OSDictionary* dictionary);
	static void				setIsReadOnly(OSDictionary* dictionary, bool isReadOnly);

	static UInt32			getVariant(const OSDictionary* dictionary);
	static void				setVariant(OSDictionary* dictionary, UInt32 variant);

	static OSString*		copyName(const OSDictionary* dictionary);
	static void				setName(OSDictionary* dictionary, const OSString* name);

//	Boolean Control Attributes
public:
	static bool				getBooleanControlValue(const OSDictionary* dictionary);
	static void				setBooleanControlValue(OSDictionary* dictionary, bool value);

//	Selector Control Attributes
public:
	static UInt32			getSelectorControlValue(const OSDictionary* dictionary);
	static void				setSelectorControlValue(OSDictionary* dictionary, UInt32 value);

	static OSArray*			copySelectorControlSelectorMap(const OSDictionary* dictionary);
	static void				setSelectorControlSelectorMap(OSDictionary* dictionary, const OSArray* selectorMap);

//	Selector Control Selector Map Item Support
public:
	static OSDictionary*	createSelectorControlSelectorMapItem(UInt32 value, const OSString* name);
	static OSDictionary*	createSelectorControlSelectorMapItem(UInt32 value, const OSString* name, UInt32 kind);
};

#endif
                                        IOVideoDevice.h                                                                                     0100644 0001750 0001750 00000013255 12567455331 035731  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoDevice.h
	
	Contains:	

	Copyright:	 2006-2013 by Apple Inc., all rights reserved.
*/

#if !defined(__IOKIT_IOVIDEODEVICE_H)
#define __IOKIT_IOVIDEODEVICE_H

#include <IOKit/IOService.h>
#include <IOKit/video/IOVideoTypes.h>
#include <IOKit/stream/IOStreamShared.h>

class IOVideoStream;

/*!
    @class		IOVideoDevice
    @abstract	A class representing a video device.
    @discussion The IOVideoDevice class defines a mechanism for accessing the IOVideoStreams that a device presents.

    Although it is expected that the client of an IOVideoDevice will be in user space, this is not required.

 */
class IOVideoDevice : public IOService
{
// Construction/Destruction
										OSDeclareDefaultStructors(IOVideoDevice);
public:
	virtual bool						init(OSDictionary* properties);
    virtual void						free(void);

/*!
	@function newUserClient
	@abstract See the documentation for the IOService method newUserClient.
*/
	virtual IOReturn					newUserClient(task_t owningTask, void* securityID,  UInt32 type, OSDictionary* properties, IOUserClient** handler);

/*!
	@function	getStreamCount
	@result		Returns the number of streams of the device.
*/
    virtual int							getStreamCount(void);
	
/*!
	@function	getStream
	@param		streamIndex
					The index for which the underlying stream is desired.
	@result		Returns the number of streams of the device.
*/
    virtual IOVideoStream*				getStream(UInt32 streamIndex);
    
/*!
	@function	startStream
	@abstract	Start sending data on a stream.
	@result		Returns kIOReturnSuccess if the stream was successfully started.
	@discussion	This must be implemented by a subclass.
*/
    virtual IOReturn					startStream(IOVideoStream* stream);

/*!
	@function	stopStream
	@abstract	Stop sending data on a stream.
	@result		Returns kIOReturnSuccess if the stream was successfully started.
	@discussion	This must be implemented by a subclass.
*/
    virtual IOReturn					stopStream(IOVideoStream* stream);

/*!
	@function	suspendStream
	@abstract	Temporarily suspend data flow on the stream.
	@result		Returns kIOReturnSuccess if the stream was successfully suspended.
	@discussion	This must be implemented by a subclass.
*/
    virtual IOReturn					suspendStream(IOVideoStream* stream);
    
/*!
	@function	setStreamMode
	@abstract	Sets the mode of the stream, either input or output.
	@discussion	This must be implemented by a subclass.
*/
    virtual IOReturn					setStreamMode(IOVideoStream* stream, IOStreamMode mode);
    virtual IOReturn					openStream(UInt32 streamIndex);
	virtual IOReturn					closeStream(UInt32 streamIndex);
    virtual IOReturn					startStream(UInt32 streamIndex);
    virtual IOReturn					stopStream(UInt32 streamIndex);
    virtual IOReturn					suspendStream(UInt32 streamIndex);
    
	
    virtual IOReturn					releaseStreams(void);
	virtual void						inputCallback(UInt32 token);
	virtual void						inputSyncCallback(UInt32 token);
    
	virtual IOReturn					registerNotificationPort(mach_port_t port, UInt32 type, UInt32 clientData);

	virtual void						sendSingleNotification(UInt32 notificationID, UInt32 objectID, UInt32 notificationArgument1, UInt32 notificationArgument2, UInt64 notificationArgument3, UInt64 notificationArgument4);
	virtual void						sendMultiNotification(UInt32 numberNotifications, const IOVideoDeviceNotification* notifications);

	virtual	IOReturn					setStreamFormat(UInt32 streamID, const IOVideoStreamDescription* newStreamFormat);

// Control methods
	virtual IOReturn					setControlValue(UInt32 controlID, UInt32 value, UInt32* newValue);
    
protected:
    virtual IOReturn					addStream(IOVideoStream* stream);
    virtual IOReturn					removeStream(UInt32 streamIndex);

    OSArray*							mStreams;
	IOVideoDeviceNotificationMessage*	mNotificationMessage;
	UInt32								mMaxNumberNotifications;
	UInt32								mOutstandingConfigChangeRequests;

// Future Expansion
public:
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 0);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 1);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 2);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 3);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 4);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 5);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 6);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 7);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 8);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 9);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 10);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 11);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 12);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 13);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 14);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 15);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 16);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 17);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 18);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 19);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 20);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 21);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 22);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 23);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 24);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 25);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 26);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 27);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 28);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 29);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 30);
    OSMetaClassDeclareReservedUnused(IOVideoDevice, 31);

protected:
    struct ExpansionData {};
    ExpansionData						*mReserved;
};

#endif
                                                                                                                                                                                                                                                                                                                                                   IOVideoDeviceClientInit.h                                                                           0100644 0001750 0001750 00000001637 12567455331 037715  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoDeviceClientInit.h
	
	Contains:		This class is used to add an IOProviderMergeProperties dictionary entry to a provider's property list, thus providing a tie between hardware and a CFBundle at hardware
					load time. This property usually contains the user client class name and the CFPlugInTypes UUID's but it can contain other properties.


	Copyright:	 2006-2012 by Apple Inc., all rights reserved.
*/

#ifndef __IOVIDEODEVICECLIENTINIT_H
#define __IOVIDEODEVICECLIENTINIT_H

#include <IOKit/IOService.h>

class IOVideoDeviceUserClientInit : public IOService 
{
					OSDeclareDefaultStructors(IOVideoDeviceUserClientInit);
    
public:
    virtual bool	start(IOService* provider) ;
    virtual bool	MergeDictionaryIntoProvider(IOService* provider, OSDictionary* mergeDicttionary);
    virtual bool	MergeDictionaryIntoDictionary(OSDictionary* sourceDictionary, OSDictionary* targetDictionary);
};

#endif
                                                                                                 IOVideoDeviceLib.h                                                                                  0100644 0001750 0001750 00000020341 12567455331 036352  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
    File:       IOVideoDeviceLib.h
    
    Contains:   IOCFPlugin library for using IOVideoDevice objects.
                The IOVideoDevice plugin provides a convenient set of functions for accessing and manipulating IOVideoDevice objects from user programs.

    Copyright:   2006-2012 by Apple Inc., all rights reserved.
*/

#if !defined(__IOKIT_IOVIDEODEVICELIB_H)
#define __IOKIT_IOVIDEODEVICELIB_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOKitLib.h>
#include <IOKit/IOCFPlugIn.h>
#include <IOKit/stream/IOStreamLib.h>
#include <IOKit/stream/IOStreamShared.h>
#include <IOKit/video/IOVideoDeviceShared.h>
#include <IOKit/video/IOVideoTypes.h>

__BEGIN_DECLS    
    
#pragma mark IOVideo UUIDs

/*!
    @defined        kIOVideoDeviceLibTypeID
    @discussion     This is the UUID of the plug-in type (5339633C-F903-4212-9C90-9B18AF01862D).
*/
#define kIOVideoDeviceLibTypeID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault, 0x53, 0x39, 0x63, 0x3C, 0xF9, 0x03, 0x42, 0x12, 0x9C, 0x90, 0x9B, 0x18, 0xAF, 0x01, 0x86, 0x2D)
    
/*!
    @defined        kIOVideoDeviceInterfaceID_v1
    @discussion     This is the UUID of version 1 of the plug-in interface (080E3-5106-4D16-B70C-B3216F13CDB9A).
*/
#define kIOVideoDeviceInterfaceID_v1 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault, 0x0D, 0xE0, 0x80, 0xE3, 0x51, 0x06, 0x4D, 0x16, 0xB7, 0x0C, 0xB3, 0x21, 0x6F, 0x13, 0xCD, 0xB9)
#define kIOVideoDeviceInterfaceID kIOVideoDeviceInterfaceID_v1

typedef struct IOVideoDeviceInterface_v1_t IOVideoDeviceInterface_v1_t;

/*!
    @typedef    IOVideoDeviceRef
*/
typedef IOVideoDeviceInterface_v1_t** IOVideoDeviceRef;

/*!
    @typedef    IOVideoDeviceOutputCallback
*/
typedef void (*IOVideoDeviceOutputCallback)(    IOVideoDeviceRef    stream,
                                                void*               context);

/*!
    @typedef    IOVideoDeviceNotificationCallback
*/
typedef void (*IOVideoDeviceNotificationCallback)(  IOVideoDeviceRef    device,
                                                    void*               context,
                                                    void*               message);

/*!
    @interface IOVideoDeviceInterface
    @abstract Interface for accessing kernel-space video drivers from user space.
 */
typedef struct IOVideoDeviceInterface_v1_t
{
    IUNKNOWN_C_GUTS;
    UInt32 Version;
    UInt32 Revision;

    /*!
        @functiongroup  Opening and closing VideoDevices
    */
    
    /*!
        @function       Open
        @abstract       Open an IOVideoDevice from user space.
        @discussion     The Open function opens the device.
        @param          device
                            The IOVideoDeviceRef to the device returned by QueryInterface.
        @param          options
                            Open options.  Currently unused.
        @result         If the device could not be opened an error will be returned.
    */
    IOReturn
    (*Open)(IOVideoDeviceRef device, IOOptionBits options);

    /*!
        @function       Close
        @abstract       Closes an IOVideoDevice.
        @discussion     Calling Close frees all streams belonging to the device and frees all user resources used by the device.
        @param          device
                            The IOVideoDeviceRef of the device to close.
        @result         Returns kIOReturnSuccess if the device was successfully closed.
    */
    IOReturn
    (*Close)(IOVideoDeviceRef device);

    /*!
        @function       GetNotificationPort
        @abstract       Get the notification port for device state changes sent to user space.
        @param          device
                            The IOVideoDeviceRef of the stream to operate on.
        @result         A CFMachPortRef of the output notification port.
    */
    CFMachPortRef
    (*GetNotificationPort)(IOVideoDeviceRef device);

    /*!
        @function       SetNotificationCallback
        @abstract       Set the callback function to be called when certain device state changes happen.
        @param          device
                            The IOVideoDeviceRef of the device to operate on. Pass NULL to remove the callback.
        @result         Returns kIOReturnSuccess if the callback was successfully set or removed.
    */
    IOReturn
    (*SetNotificationCallback)( IOVideoDeviceRef                    device,
                                IOVideoDeviceNotificationCallback   callback,
                                void*                               context);

    /*!
        @function       SetControlValue
        @param          device
        @param          controlID
        @param          newValue
        @result         Returns kIOReturnSuccess if the call was successfully.
    */
    IOReturn
    (*SetControlValue)( IOVideoDeviceRef    device,
                        UInt32              controlID,
                        UInt32              value,
                        UInt32*             newValue);
 
    /*!
        @function       SetStreamFormat
        @param          device
        @param          streamID
        @param          streamFormat
        @result         Returns kIOReturnSuccess if the call was successfully.
    */
    IOReturn
    (*SetStreamFormat)( IOVideoDeviceRef            device,
                        UInt32                      streamID,
                        IOVideoStreamDescription*   streamFormat);
    
    /*!
        @function       GetRunLoopSource
        @abstract       Gets a CFRunLoopSource for the CFMachPort used for notifications from the kernel that data is ready.
        @param          device
                            The IOVideoDeviceRef of the stream to operate on.
        @result         The CFRunLoopSourceRef for the run loop source, or NULL if there was an error creating the source.
    */
    CFRunLoopSourceRef
    (*GetRunLoopSource)(IOVideoDeviceRef device);
    
    /*!
        @function       AddToRunLoop
        @abstract       Add the CFRunLoopSource for the notification port to a run loop.
        @param          device
                            The IOVideoDeviceRef of the device to operate on.
        @param          runLoop
                            The run loop to which to add the notification source.
        @result         Returns kIOReturnSuccess if the source was successfully added to the run loop.
    */
    
    IOReturn
    (*AddToRunLoop)(    IOVideoDeviceRef    device,
                        CFRunLoopRef        runLoop);
    
    /*!
        @function       RemoveFromRunLoop
        @abstract       Remove the CFRunLoopSource for the notification port from a run loop.
        @param          device
                            The IOVideoDeviceRef of the device to operate on.
        @param          runLoop
                            The run loop from which to remove the notification source.
        @result         Returns kIOReturnSuccess if the source was successfully removed from the run loop.
    */
    IOReturn
    (*RemoveFromRunLoop)(   IOVideoDeviceRef    device,
                            CFRunLoopRef        runLoop);

    /*!
        @function       CreateStreamInterface
        @param          device
                            The IOVideoDeviceRef of the device to operate on.
        @param          streamDictionary
        @param          streamIndex
        @param          isInput
        @result         Returns kIOReturnSuccess if the stream was successfully created.
    */
    IOReturn
    (*CreateStreamInterface)(   IOVideoDeviceRef    device,
                                CFDictionaryRef     streamDictionary,
                                UInt32              streamIndex,
                                bool                isInput,
                                IOStreamRef*        streamRef);

    /*!
        @function       ReleaseStreamInterface
        @param          device
                            The IOVideoDeviceRef of the device to operate on.
        @param          isInput
        @param          streamRef
        @result         Returns kIOReturnSuccess if the stream was successfully released.
    */
    IOReturn
    (*ReleaseStreamInterface)(  IOVideoDeviceRef    device,
                                bool                isInput,
                                IOStreamRef*        streamRef);
} IOVideoDeviceInterface;


__END_DECLS

#endif
                                                                                                                                                                                                                                                                                               IOVideoDeviceShared.h                                                                               0100644 0001750 0001750 00000001421 12567455331 037050  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoDeviceShared.h
	
	Contains:	

	Copyright:	 2006-2012 by Apple Inc., all rights reserved.
*/

#if !defined(__IOKIT_IOVIDEODEVICESHARED_H)
#define __IOKIT_IOVIDEODEVICESHARED_H

#include <sys/cdefs.h>
#include <IOKit/IOTypes.h>

/*!
    @header IOVideoDeviceShared.h
    IOVideoDevice definitions shared between kernel and user space.
 */

__BEGIN_DECLS    
   
/*!
    @enum Mach port types
    @constant kIOVideoDevicePortTypeNotification
    @constant kIOVideoDevicePortTypeOutput
	@constant kIOVideoDevicePortTypeInput
    @abstract Port types used with IOConnectSetNotificationPort().
 */
enum
{
	kIOVideoDevicePortTypeNotification,
    kIOVideoDevicePortTypeOutput,
    kIOVideoDevicePortTypeInput
};

__END_DECLS

#endif /* ! __IOKIT_IOVIDEODEVICESHARED_H */

                                                                                                                                                                                                                                               IOVideoDeviceUserClient.h                                                                           0100644 0001750 0001750 00000010766 12567455331 037733  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoDeviceUserClient.h
	
	Contains:	

	Copyright:	 2006-2012 by Apple Inc., all rights reserved.
*/

#if !defined(__IOKIT_IOVIDEODEVICEUSERCLIENT_H)
#define __IOKIT_IOVIDEODEVICEUSERCLIENT_H

/*!
 @enum User client methods
 @constant kIOVideoDeviceMethodOpen
 @constant kIOVideoDeviceMethodClose
 @constant kIOVideoDeviceMethodGetMode
 @constant kIOVideoDeviceMethodSetControlValue
 @constant kIOVideoDeviceMethodOpenStream
 @constant kIOVideoDeviceMethodCloseStream
 @constant kIOVideoDeviceMethodSetStreamFormat
 @constant kIOVideoDeviceMethodStartStream
 @constant kIOVideoDeviceMethodStopStream
 @constant kIOVideoDeviceMethodSuspendStream
 
 @abstract Client method numbers used with IOConnectMethod...() functions.
 */
enum
{
    kIOVideoDeviceMethodOpen = 0,
    kIOVideoDeviceMethodClose,
    kIOVideoDeviceMethodGetMode,
    kIOVideoDeviceMethodSetMode,
    kIOVideoDeviceMethodSetControlValue,
	kIOVideoDeviceMethodOpenStream,
	kIOVideoDeviceMethodCloseStream,
    kIOVideoDeviceMethodSetStreamFormat,
    kIOVideoDeviceMethodStartStream,
    kIOVideoDeviceMethodStopStream,
    kIOVideoDeviceMethodSuspendStream,
	
	kIOVideoDeviceMethodCount
};

#ifdef KERNEL
#ifdef __cplusplus

#include <IOKit/IOUserClient.h>
#include <IOKit/stream/IOStreamShared.h>
#include <IOKit/video/IOVideoTypes.h>

class IOVideoDevice;

class IOVideoDeviceUserClient : public IOUserClient
{
// Construction/Destruction
									OSDeclareDefaultStructors(IOVideoDeviceUserClient)

// Static versions of external methods
private:
    static IOReturn					sOpen(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sClose(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sGetMode(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sSetMode(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
	static IOReturn					sSetControlValue(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sOpenStream(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sCloseStream(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
	static IOReturn					sSetStreamFormat(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sStartStream(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sStopStream(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
    static IOReturn					sSuspendStream(IOVideoDeviceUserClient* target, void* reference, IOExternalMethodArguments* arguments);
	
protected:
	const IOExternalMethodDispatch*	mExternalMethods;
    IOVideoDevice*					mDevice;
    task_t							mTask;
    
// IOUserClient overriden methods
public:
    virtual bool					initWithTask(task_t owningTask, void* securityToken, UInt32 type);
	virtual bool					initWithTask(task_t owningTask, void* securityToken, UInt32 type, OSDictionary* properties);
    virtual IOReturn				clientClose(void);
    virtual IOReturn				clientDied(void);
    virtual IOService*				getService(void);
 	virtual	IOReturn				registerNotificationPort(mach_port_t port,  UInt32 portType, UInt32 refCon);
	virtual IOReturn				connectClient(IOUserClient* client);
	virtual IOReturn				externalMethod(uint32_t selector, IOExternalMethodArguments* arguments, IOExternalMethodDispatch* dispatch, OSObject* target, void* reference);

// IOService overriden methods
    virtual bool					start(IOService* provider);
    
// external methods
public:
    virtual IOReturn				open(IOOptionBits options);
    virtual IOReturn				close(void);
    virtual IOReturn				getMode(UInt32 streamIndex, IOStreamMode* mode);
    virtual IOReturn				setMode(UInt32 streamIndex, IOStreamMode mode);
	virtual	IOReturn				setControlValue(UInt32 controlID, UInt32 value, UInt32* newValue);
	virtual IOReturn				setStreamFormat(UInt32 streamID, const IOVideoStreamDescription* newStreamFormat);
    virtual IOReturn				openStream(UInt32 streamIndex);
    virtual IOReturn				closeStream(UInt32 streamIndex);
    virtual IOReturn				startStream(UInt32 streamIndex);
    virtual IOReturn				stopStream(UInt32 streamIndex);
    virtual IOReturn				suspendStream(UInt32 streamIndex);
};

#endif /* __cplusplus */
#endif /* KERNEL */

#endif
          IOVideoStream.h                                                                                     0100644 0001750 0001750 00000012517 12567455331 035765  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoStream.h

	Contains:	

	Copyright:	 2006-2012 by Apple Inc., all rights reserved.
*/

#ifndef __IOKIT_IOVIDEOSTREAM_H
#define __IOKIT_IOVIDEOSTREAM_H

#include <IOKit/stream/IOStream.h>

class IOVideoDevice;

/*!
    @class		IOVideoStream
    @abstract	A class representing a stream of video data buffers passed from kernel to user space and back again.
    @discussion	The IOVideoStream class defines a mechanism for moving buffers of data from kernel space to user space or vice-versa.  The policy for which direction the data flows and the
	nature of the data is left up the the implementer of the driver which uses IOStream.

    Although it is expected that the client of an IOVideoStream will be in user space, this is not required.
 
    References to "output" mean "from the IOVideoStream to the user client", and "input" means "from the user client to the IOVideoStream."

 */
class IOVideoStream : public IOStream
{
// Construction/Destruction
							OSDeclareDefaultStructors(IOVideoStream);

protected:
    IOStreamMode			mStreamMode;
    
public:

/*!
	@function	withBuffers
	@param		buffers
					An array of IOStreamBuffer objects which will be the buffers for this stream.
	@param		mode
					The initial mode of the video stream, either output, input, or input/output.
	@param		queueLength
					The nuber of queue entries to reserve in the input and output queue. Zero means to make the queues big enough to accommodate all the buffers at once.
	@param		properties
					A dictionary of properties which will be set on the video stream.
*/
    static IOVideoStream*	withBuffers(OSArray* buffers, IOStreamMode mode = kIOStreamModeOutput, IOItemCount queueLength = 0, OSDictionary* properties = 0);    


/*!
	@function	initWithBuffers
	@param		buffers
					An array of IOStreamBuffer objects which will be the buffers for this stream.
	@param		mode
					The initial mode of the video stream, either output, input, or input/output.
	@param		queueLength
					The nuber of queue entries to reserve in the input and output queue. Zero means to make the queues big enough to accommodate all the buffers at once.
	@param		properties
					A dictionary of properties which will be set on the video stream.
*/
    virtual bool			initWithBuffers(OSArray* buffers, IOStreamMode mode = kIOStreamModeOutput, IOItemCount queueLength = 0, OSDictionary* properties = 0);

    virtual IOVideoDevice*	getDevice(void);	// Returns provider cast to an IOVideoDevice
    
/*!
	@function	getStreamMode
	@abstract	Returns the mode of the stream, either input or output.
	@result		The mode of the stream, either kIOStreamModeInput (from user space to kernel space) or the default kIOStreamModeOutput (from kernel space to user space).
*/
    virtual IOStreamMode	getStreamMode(void);

/*!
	@function	setStreamMode
	@abstract	Sets the mode of the stream, either input or output.
*/
    virtual IOReturn		setStreamMode(IOStreamMode mode);

/*!
	@function	startStream
	@abstract	Start sending data on a stream.
	@result		Returns kIOReturnSuccess if the stream was successfully started.
*/
	virtual IOReturn		startStream(void);

/*!
	@function	stopStream
	@abstract	Stop sending data on a stream.
	@result		Returns kIOReturnSuccess if the stream was successfully started.
*/
    virtual IOReturn		stopStream(void);

/*!
	@function	suspendStream
	@abstract	Temporarily suspend data flow on the stream.
	@result		Returns kIOReturnSuccess if the stream was successfully suspended.
*/
    virtual IOReturn		suspendStream(void);

// Future Expansion
public:
    OSMetaClassDeclareReservedUnused(IOVideoStream, 0);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 1);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 2);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 3);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 4);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 5);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 6);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 7);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 8);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 9);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 10);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 11);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 12);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 13);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 14);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 15);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 16);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 17);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 18);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 19);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 20);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 21);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 22);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 23);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 24);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 25);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 26);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 27);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 28);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 29);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 30);
    OSMetaClassDeclareReservedUnused(IOVideoStream, 31);

protected:
    struct ExpansionData {};
    ExpansionData			*mReserved;
};

#endif
                                                                                                                                                                                 IOVideoStreamDictionary.h                                                                           0100644 0001750 0001750 00000003211 12567455331 040002  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoStreamDictionary.h
	
	Contains:	

	Copyright:	 2006-2012 by Apple Inc., all rights reserved.
*/

#if !defined(__IOVideoStreamDictionary_h__)
#define __IOVideoStreamDictionary_h__

// System Includes
#include <IOKit/video/IOVideoTypes.h>

class OSArray;
class OSDictionary;

class IOVideoStreamDictionary
{

// Construction/Destruction
public:
	static OSDictionary*	create(UInt32 streamID, UInt32 startingDeviceChannelNumber, const OSDictionary* currentFormat, OSArray* availableFormats = NULL);

// Attributes
public:
	static UInt32			getStreamID(const OSDictionary* dictionary);
	static void				setStreamID(OSDictionary* dictionary, UInt32 streamID);
	
	static UInt32			getStartingDeviceChannelNumber(const OSDictionary* dictionary);
	static void				setStartingDeviceChannelNumber(OSDictionary* dictionary, UInt32 startingDeviceChannelNumber);
	
	static IOOptionBits		getBufferMappingOptions(const OSDictionary* dictionary);
	static void				setBufferMappingOptions(OSDictionary* dictionary, IOOptionBits bufferMappingOptions);

	static bool				getCurrentFormat(const OSDictionary* dictionary, IOVideoStreamDescription& format);
	static void				setCurrentFormat(OSDictionary* dictionary, const IOVideoStreamDescription& format);
	static OSDictionary*	copyCurrentFormatDictionary(const OSDictionary* dictionary);
	static void				setCurrentFormatDictionary(OSDictionary* dictionary, const OSDictionary* format);
	
	static OSArray*			copyAvailableFormats(const OSDictionary* dictionary);
	static void				setAvailableFormats(OSDictionary* dictionary, OSArray* availableFormats);
	
	static void				printDictionary(const OSDictionary* dictionary);
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                       IOVideoStreamFormatDictionary.h                                                                     0100644 0001750 0001750 00000002613 12567455331 041160  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
	File:		IOVideoStreamFormat.h
	
	Contains:	

	Copyright:	 2006-2012 by Apple Inc., all rights reserved.
*/

#if !defined(__IOVideoStreamFormat_h__)
#define __IOVideoStreamFormat_h__

// System Includes
#include <IOKit/video/IOVideoTypes.h>

class OSDictionary;

class IOVideoStreamFormatDictionary
{
public:
	static OSDictionary*	create(UInt32 codecType, UInt32 codecFlags, UInt32 width, UInt32 height);
	static OSDictionary*	createWithDescription(const IOVideoStreamDescription& format);

// Attributes
public:
	static UInt32			getCodecType(const OSDictionary* dictionary);
	static void				setCodecType(OSDictionary* dictionary, UInt32 codecType);

	static UInt32			getCodecFlags(const OSDictionary* dictionary);
	static void				setCodecFlags(OSDictionary* dictionary, UInt32 codecFlags);

	static UInt32			getWidth(const OSDictionary* dictionary);
	static void				setWidth(OSDictionary* dictionary, UInt32 width);

	static UInt32			getHeight(const OSDictionary* dictionary);
	static void				setHeight(OSDictionary* dictionary, UInt32 height);

	static void				getDescription(const OSDictionary* dictionary, IOVideoStreamDescription& format);
	static void				printDescription(const IOVideoStreamDescription& format);
	static void				printDictionary(const OSDictionary* dictionary);
	
	static bool				isSameSampleFormat(const IOVideoStreamDescription& format1, const IOVideoStreamDescription& format2);
};

#endif
                                                                                                                     IOVideoTypes.h                                                                                      0100644 0001750 0001750 00000043551 12567455331 035640  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/IOKit/video                                                          /*
    File:       IOVideoTypes.h
    
    Contains:   

    Copyright:   2006-2014 by Apple Inc., all rights reserved.
*/

#if !defined(__IOVideoTypes_h__)
#define __IOVideoTypes_h__

//  System Includes
#include <IOKit/IOTypes.h>
#include <mach/message.h>

#if defined(__cplusplus)
extern "C"
{
#endif

/*!
    @struct         IOVideoDeviceNotification
    @abstract       This structure contains an individual notification from the driver.
    @field          mObjectID
                        The ID of the object to which the notification pertains.
    @field          mNotificationID
                        A UInt32 that identifies the kind of the notification.
    @field          mNotificationArgument1
                        A UInt32 whose usage depends on the the specific kind of notification.
    @field          mNotificationArgument2
                        A UInt32 whose usage depends on the the specific kind of notification.
    @field          mNotificationArgument3
                        A UInt64 whose usage depends on the the specific kind of notification.
    @field          mNotificationArgument4
                        A UInt64 whose usage depends on the the specific kind of notification.
*/
struct IOVideoDeviceNotification
{
    UInt32  mObjectID;
    UInt32  mNotificationID;
    UInt32  mNotificationArgument1;
    UInt32  mNotificationArgument2;
    UInt64  mNotificationArgument3;
    UInt64  mNotificationArgument4;
};
typedef struct IOVideoDeviceNotification IOVideoDeviceNotification;

/*!
    @struct         IOVideoDeviceNotificationMessage
    @abstract       This structure describes a notification from the driver. Note that the message can contain multiple notifications.
    @field          mMessageHeader
                        The mach message header.
    @field          mClientData
                        The client data that was registered with the mach port.
    @field          mNumberNotifications
                        The number of IOVideoDeviceNotifications in the mNotifications array.
    @field          mNotifications
                        A variable length array of IOVideoDeviceNotification structures that carry the actual notification data. The number of elements in this array is denoted by
                        mNumberNotifications, but can also be inferred from the message size in the mach message header.
*/
struct IOVideoDeviceNotificationMessage
{
    mach_msg_header_t           mMessageHeader;
    UInt32                      mClientData;
    UInt32                      mNumberNotifications;
    IOVideoDeviceNotification   mNotifications[1];
};
typedef struct IOVideoDeviceNotificationMessage IOVideoDeviceNotificationMessage;

#define CalculateIOVideoDeviceNotificationMessageSize(numberNotifications) (sizeof(IOVideoDeviceNotificationMessage) + (((numberNotifications) - 1) * sizeof(IOVideoDeviceNotification)))

#pragma mark Notification IDs
/*!
    @enum           Notification IDs
    @discussion
    @abstract       The four char codes used to identify the kind of the notification.
    @discussion     All device-level notifications will have an object ID of 0.
    @constant       kIOVideoDeviceNotificationID_ControlValueChanged
                        Indicates that the value of the control with the given ID has changed. The first argument is the new value.
    @constant       kIOVideoDeviceNotificationID_ControlRangeChanged
                        Indicates that the range of the control with the given ID has changed.
*/
enum
{
    kIOVideoDeviceNotificationID_ControlValueChanged = 'cval',
    kIOVideoDeviceNotificationID_ControlRangeChanged = 'crng'
};

struct IOVideoStreamDescription
{
    UInt32          mVideoCodecType;
    UInt32          mVideoCodecFlags;
    UInt32          mWidth;
    UInt32          mHeight;
    UInt32          mReserved1;
    UInt32          mReserved2;
};
typedef struct IOVideoStreamDescription  IOVideoStreamDescription;

//==================================================================================================
#pragma mark Control Constants

/*!
    @enum           Control Constants
    @discussion
    @abstract       Various constants related to controls.
    @constant       kIOVideoControlScopeGlobal
                        The scope for controls that apply to the device as a whole.
    @constant       kIOVideoControlScopeInput
                        The scope for controls that apply to the input section of the device.
    @constant       kIOVideoControlScopeOutput
                        The scope for controls that apply to the output section of the device.
    @constant       kIOVideoControlScopePlayThrough
                        The scope for controls that apply to the play through section of the device.
    @constant       kIOVideoControlElementMaster
                        The element value for controls that apply to the master element or to the entire scope. Note that other elements are numbered consecutively starting from 1.
*/
enum
{
    kIOVideoControlScopeGlobal      = 'glob',
    kIOVideoControlScopeInput       = 'inpt',
    kIOVideoControlScopeOutput      = 'outp',
    kIOVideoControlScopePlayThrough = 'ptru',
    kIOVideoControlElementMaster    = 0
};
    
/*!
    @enum           Control Base Class IDs
    @discussion
    @abstract       The class IDs that identify the various control base classes.
    @constant       kIOVideoControlBaseClassIDBoolean
                        The class ID that identifies the boolean control class which is a subclass of the base control class. Boolean controls manipulate on/off switches in the hardware.
    @constant       kIOVideoControlBaseClassIDSelector
                        The class ID that identifies the selector control class which is a subclass of the base control class. Selector controls manipulate controls that have
                        multiple, but discreet values.
    @constant       kIOVideoControlBaseClassIDFeature
                        The class ID that identifies the feature control class which is a subclass of the base control class. Feature controls manipulate various features that might be
                        present on a device, such as hue, saturation, zoom, etc.
*/
enum
{
    kIOVideoControlBaseClassIDBoolean   = 'togl',
    kIOVideoControlBaseClassIDSelector  = 'slct',   
    kIOVideoControlBaseClassIDFeature   = 'ftct'
    
};

/*!
    @enum           IOVideoBooleanControl Subclass IDs
    @discussion
    @abstract       The four char codes that identify the various standard subclasses of IOVideoBooleanControl.
    @constant       kIOVideoBooleanControlClassIDJack 
                        A IOVideoBooleanControl where a true value means something is plugged into that element.
    @constant       kIOVideoBooleanControlClassIDDirection
                        A IOVideoBooleanControl where a true value means the element is operating in input mode, and false means the element is operating in output mode.
                        This control is only needed for devices which can do input and output, but not at the same time.
*/
enum
{
    kIOVideoBooleanControlClassIDJack       = 'jack',
    kIOVideoBooleanControlClassIDDirection  = 'dire'
};

/*!
    @enum           IOVideoSelectorControl Subclass IDs
    @discussion
    @abstract       The four char codes that identify the various standard subclasses of IOVideoSelectorControl.
    @constant       kIOVideoSelectorControlClassIDDataSource
                        A IOVideoSelectorControl that identifies where the data for the element is coming from.
    @constant       kIOVideoSelectorControlClassIDDataDestination
                        A IOVideoSelectorControl that identifies where the data for the element is going.
*/
enum
{
    kIOVideoSelectorControlClassIDDataSource        = 'dsrc',
    kIOVideoSelectorControlClassIDDataDestination   = 'dest'
};

/*!
    @enum           IOVideoFeatureControl Subclass IDs
    @discussion
    @abstract       The four char codes that identify the various standard subclasses of IOVideoFeatureControl.
    @constant       kIOVideoFeatureControlClassIDBlackLevel
                        A IOVideoFeatureControl that controls the black level offset. The units for the control's absolute value are percetage (%).
    @constant       kIOVideoFeatureControlClassIDWhiteLevel
                        A IOVideoFeatureControl that controls the white level offset. The units for the control's absolute value are percentage (%).
    @constant       kIOVideoFeatureControlClassIDHue
                        A IOVideoFeatureControl that controls the hue offset. Positive values mean counterclockwise, negative values means clockwise on a vector scope. The units for the
                        control's absolute value are degrees ().
    @constant       kIOVideoFeatureControlClassIDSaturation
                        A IOVideoFeatureControl that controls color intensity. For example, at high saturation levels, red appears to be red; at low saturation, red appears as pink. The
                        unit for the control's absolute value is a percentage (%).
    @constant       kIOVideoFeatureControlClassIDContrast
                        A IOVideoFeatureControl that controls a the distance bewtween the whitest whites and blackest blacks. The units for the control's absolute value are percentage (%).
    @constant       kIOVideoFeatureControlClassIDSharpness
                        A IOVideoFeatureControl that controls the sharpness of the picture. The units for the control's absolute value are undefined.
    @constant       kIOVideoFeatureControlClassIDBrightness
                        A IOVideoFeatureControl that controls the intensity of the video level. The units for the control's absolute value are percetage (%).
    @constant       kIOVideoFeatureControlClassIDGain
                        A IOVideoFeatureControl that controls the amplification of the signal. The units for the control's absolute value are decibels (dB).
    @constant       kIOVideoFeatureControlClassIDIris
                        A IOVideoFeatureControl that controls a mechanical lens iris. The units for the control's absolute value are an F number (F).
    @constant       kIOVideoFeatureControlClassIDShutter
                        A IOVideoFeatureControl that controls the integration time of the incoming light. The units for the control's absolute value are seconds (s).
    @constant       kIOVideoFeatureControlClassIDExposure
                        A IOVideoFeatureControl that controls a the total amount of light accumulated. The units for the control's absolute value are exposure value (EV).
    @constant       kIOVideoFeatureControlClassIDWhiteBalanceU
                        A IOVideoFeatureControl that controls the adjustment of the white color of the picture. The units for the control's absolute value are kelvin (K).
    @constant       kIOVideoFeatureControlClassIDWhiteBalanceV
                        A IOVideoFeatureControl that controls a adjustment of the white color of the picture. The units for the control's absolute value are kelvin (K).
    @constant       kIOVideoFeatureControlClassIDGamma
                        A IOVideoFeatureControl that defines the function between incoming light level and output picture level. The units for the control's absolute value are undefined.
    @constant       kIOVideoFeatureControlClassIDTemperature
                        A IOVideoFeatureControl that controls the temperature inside of the device and/or controlling temperature. The units for the control's absolute value are undefined.
    @constant       kIOVideoFeatureControlClassIDZoom
                        A IOVideoFeatureControl that controls the zoom. The units for the control's absolute value are power where 1 is the wide end.
    @constant       kIOVideoFeatureControlClassIDFocus
                        A IOVideoFeatureControl that controls a focus mechanism. The units for the control's absolute value are meters (m).
    @constant       kIOVideoFeatureControlClassIDPan
                        A IOVideoFeatureControl that controls a panning mechanism. Positive values mean clockwise, negative values means counterclockwise. The units for the control's
                        absolute value are degrees ().
    @constant       kIOVideoFeatureControlClassIDTilt
                        A IOVideoFeatureControl that controls a tilt mechanism. Positive values mean updwards, negative values means downwards. The units for the control's absolute value are
                        degrees ().
    @constant       kIOVideoFeatureControlClassIDOpticalFilter
                        A IOVideoFeatureControl that controls changing the optical filter of camera lens function. The units for the control's absolute value are are undefined.
    @constant       kIOVideoFeatureControlClassIDBacklightCompensation
                        A IOVideoFeatureControl that controls the amount of backlight compensation to apply. A low number indicates the least amount of backlight compensation. The units for the
                        control's absolute value are are undefined.
    @constant       kIOVideoFeatureControlClassIDPowerLineFrequency
                        A IOVideoFeatureControl to specify the power line frequency to properly implement anti-flicker processing. The units for the contorl's absolute value are hertz (Hz).
*/
enum
{
    kIOVideoFeatureControlClassIDBlackLevel             = 'bklv',
    kIOVideoFeatureControlClassIDWhiteLevel             = 'whlv',
    kIOVideoFeatureControlClassIDHue                    = 'hue ',
    kIOVideoFeatureControlClassIDSaturation             = 'satu',
    kIOVideoFeatureControlClassIDContrast               = 'ctst',
    kIOVideoFeatureControlClassIDSharpness              = 'shrp',
    kIOVideoFeatureControlClassIDBrightness             = 'brit',
    kIOVideoFeatureControlClassIDGain                   = 'gain',
    kIOVideoFeatureControlClassIDIris                   = 'iris',
    kIOVideoFeatureControlClassIDShutter                = 'shtr',
    kIOVideoFeatureControlClassIDExposure               = 'xpsr',
    kIOVideoFeatureControlClassIDWhiteBalanceU          = 'whbu',
    kIOVideoFeatureControlClassIDWhiteBalanceV          = 'whbv',
    kIOVideoFeatureControlClassIDGamma                  = 'gmma',
    kIOVideoFeatureControlClassIDTemperature            = 'temp',
    kIOVideoFeatureControlClassIDZoom                   = 'zoom',
    kIOVideoFeatureControlClassIDFocus                  = 'fcus',
    kIOVideoFeatureControlClassIDPan                    = 'pan ',
    kIOVideoFeatureControlClassIDTilt                   = 'tilt',
    kIOVideoFeatureControlClassIDOpticalFilter          = 'opft',
    kIOVideoFeatureControlClassIDBacklightCompensation  = 'bklt',
    kIOVideoFeatureControlClassIDPowerLineFrequency     = 'pwfq'
};

//==================================================================================================
#pragma mark    IORegistry Keys

// IOVideo Class Names
#define kIOVideoDevice_ClassName                                "IOVideoDevice"

// IOVideoDevice IORegistry Keys
#pragma mark IOVideoDevice IORegistry Keys
#define kIOVideoDeviceKey_DeviceName                            "device name"
#define kIOVideoDeviceKey_DeviceManufacturer                    "device manufacturer"
#define kIOVideoDeviceKey_DeviceUID                             "device UID"
#define kIOVideoDeviceKey_IOEngineIsRunning                     "is running"
#define kIOVideoDeviceKey_InputLatency                          "input latency"
#define kIOVideoDeviceKey_OutputLatency                         "output latency"
#define kIOVideoDeviceKey_InputStreamList                       "input streams"
#define kIOVideoDeviceKey_OutputStreamList                      "output streams"
#define kIOVideoDeviceKey_ControlList                           "controls"

// IOVideoDevice Stream Dictionary Keys
#pragma mark IOVideoDevice Stream Dictionary Keys
#define kIOVideoStreamKey_StreamID                              "stream ID"
#define kIOVideoStreamKey_StartingDeviceChannelNumber           "starting channel"
#define kIOVideoStreamKey_BufferMappingOptions                  "buffer mapping options"
#define kIOVideoStreamKey_CurrentFormat                         "current format"
#define kIOVideoStreamKey_AvailableFormats                      "available formats"

// IOVideoDevice Control Dictionary Keys
#pragma mark IOVideoDevice Control Dictionary Keys
#define kIOVideoControlKey_ControlID                            "control ID"
#define kIOVideoControlKey_BaseClass                            "base class"
#define kIOVideoControlKey_Class                                "class"
#define kIOVideoControlKey_Scope                                "scope"
#define kIOVideoControlKey_Element                              "element"
#define kIOVideoControlKey_IsReadOnly                           "read only"
#define kIOVideoControlKey_Variant                              "variant"
#define kIOVideoControlKey_Name                                 "name"
#define kIOVideoControlKey_Value                                "value"

// IOVideoDevice Selector Control Dictionary Keys
#pragma mark IOVideoDevice Selector Control Dictionary Keys
#define kIOVideoSelectorControlKey_SelectorMap                  "selectors"

// IOVideoDevice Selector Control Selector Map Item Dictionary Keys
#pragma mark IOVideoDevice Selector Control Selector Map Item Dictionary Keys
#define kIOVideoSelectorControlSelectorMapItemKey_Value         "value"
#define kIOVideoSelectorControlSelectorMapItemKey_Name          "name"
#define kIOVideoSelectorControlSelectorMapItemKey_Kind          "kind"

// Stream Format Dictionary Keys
#pragma mark Stream Format Dictionary Keys
#define kIOVideoStreamFormatKey_CodecType                       "codec type"
#define kIOVideoStreamFormatKey_CodecFlags                      "codec flags"
#define kIOVideoStreamFormatKey_Width                           "width"
#define kIOVideoStreamFormatKey_Height                          "height"


//==================================================================================================

#if defined(__cplusplus)
}
#endif

#endif
                                                                                                                                                       TargetConditionals.h                                                                                0120777 0001750 0001750 00000000000 12620245063 045120  2../../../../../../../usr/include/TargetConditionals.h                                               ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      UserNotification/                                                                                   0040755 0001750 0001750 00000000000 12612224742 034326  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      KUNCUserNotifications.h                                                                             0100644 0001750 0001750 00000017177 12567450753 040656  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/UserNotification                                                     /*
 * Copyright (c) 2000-2004 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __USERNOTIFICATION_KUNCUSERNOTIFICATIONS_H
#define __USERNOTIFICATION_KUNCUSERNOTIFICATIONS_H

#include <sys/cdefs.h>


#include <mach/message.h>
#include <mach/kern_return.h>
#include <UserNotification/UNDTypes.h>

__BEGIN_DECLS

/*
 * non blocking notice call.
 */
kern_return_t
KUNCUserNotificationDisplayNotice(
	int		noticeTimeout,
	unsigned	flags,
	char		*iconPath,
	char		*soundPath,
	char		*localizationPath,
	char		*alertHeader,
	char		*alertMessage,
	char		*defaultButtonTitle) __attribute__((deprecated));

/*
 * ***BLOCKING*** alert call, returned int value corresponds to the
 * pressed button, spin this off in a thread only, or expect your kext to block.
 */
kern_return_t
KUNCUserNotificationDisplayAlert(
	int		alertTimeout,
	unsigned	flags,
	char		*iconPath,
	char		*soundPath,
	char		*localizationPath,
	char		*alertHeader,
	char		*alertMessage,
	char 		*defaultButtonTitle,
	char		*alternateButtonTitle,
	char		*otherButtonTitle,
	unsigned	*responseFlags) __attribute__((deprecated));


/*
 * Execute a userland executable with the given path, user and type
 */
 
#define kOpenApplicationPath 	0	/* essentially executes the path */
#define kOpenPreferencePanel    1	/* runs the preferences with the foo.preference opened.  foo.preference must exist in /System/Library/Preferences */
#define kOpenApplication	2	/* essentially runs /usr/bin/open on the passed in application name */
 
 
#define kOpenAppAsRoot		0
#define kOpenAppAsConsoleUser	1 
 
kern_return_t
KUNCExecute(
	char	*executionPath,
	int	openAsUser,
	int	pathExecutionType) __attribute__((deprecated));


/* KUNC User Notification XML Keys
 *
 * These are the keys used in the xml plist file passed in to the
 * KUNCUserNotitificationDisplayFrom* calls
 *
 * KUNC Notifications are completely dependent on CFUserNotifications in
 * user land.  The same restrictions apply, including the number of text fields,
 * types of information displayable, etc.
 *
 *  Key			Type
 * Header			string (header displayed on dialog)
 * 				corresponds to kCFUserNotificationAlertHeaderKey
 *
 * Icon URL			string (url of the icon to display)
 * 				corresponds to kCFUserNotificationIconURLKey
 *
 * Sound URL			string (url of the sound to play on display)
 * 				corresponds to kCFUserNotificationSoundURLKey
 *
 * Localization URL		string (url of bundle to retrieve localization
 *				info from, using Localizable.strings files)
 * 				corresponds to kCFUserNotificationLocalizationURLKey
 *
 * Message			string (text of the message, can contain %@'s
 *				which are filled from tokenString passed in) 
 * 				corresponds to kCFUserNotificationAlertMessageKey
 *
 * OK Button Title 		string (title of the "main" button)
 * 				corresponds to kCFUserNotificationDefaultButtonTitleKey
 *
 * Alternate Button Title 	string (title of the "alternate" button,  usually cancel)
 * 				corresponds to kCFUserNotificationAlternateButtonTitleKey
 *
 * Other Button Title	 	string (title of the "other" button)
 * 				corresponds to kCFUserNotificationOtherButtonTitleKey
 *
 * Timeout			string (numeric, int - seconds until the dialog
 *				goes away on it's own)
 *
 * Alert Level			string (Stop, Notice, Alert)
 *
 * Blocking Message		string (numeric, 1 or 0 - if 1, the dialog will
 *				have no buttons)
 *
 * Text Field Strings		array of strings (each becomes a text field)
 * 				corresponds to kCFUserNotificationTextFieldTitlesKey
 *
 * Password Fields		array of strings (numeric - each indicates a
 *				pwd field)
 *
 * Popup Button Strings		array of strings (each entry becomes a popup
 *				button string)
 *
 * Radio Button Strings		array of strings (each becomes a radio button)
 *
 * Check Box Strings		array of strings (each becomes a check box)
 * 				corresponds to kCFUserNotificationCheckBoxTitlesKey
 *
 * Selected Radio		string (numeric - which radio is selected)
 *
 * Checked Boxes		array of strings (numeric - each indicates a
 *				checked field)
 *
 * Selected Popup		string (numeric - which popup entry is selected)
 *
 */

/*
 * Bundle Calls
 *
 *	Arguments
 *
 *	bundleIdentifier
 *		path to the actual bundle (not inside of it)
 *	        (i.e. "/System/Library/Extensions/Foo.kext")
 *		***NOTE***
 *		This WILL change soon to expect the CFBundleIdentifier instead of a bundle path
 *	fileName
 *		filename in bundle to retrive the xml from (i.e. "Messages")
 *	fileExtension 
 *		if fileName has an extension, it goes here (i.e., "dict");
 *	messageKey
 *		name of the xml key in the dictionary in the file to retrieve
 *		the info from (i.e., "Error Message")
 *	tokenString
 *		a string in the form of "foo@bar" where each element is
 *		seperated by the @ character.  This string can be used to
 *		replace values of the form %@ in the message key in the provided
 *		dictionary in the xml plist
 *	specialKey
 *		user specified key for notification, use this to match return
 *		values with your requested notification, this value is passed
 *		back to the client in the callback pararmeter contextKey
 */

typedef uintptr_t KUNCUserNotificationID;

/*
 * Reponse value checking & default setting
 *
 * The reponse value returned in the response Flags of the
 * KUNCUserNotificationCallBack can be tested against the following
 * enum and 2 defines to determine the state.
 */

enum {
    kKUNCDefaultResponse	= 0,
    kKUNCAlternateResponse	= 1,
    kKUNCOtherResponse		= 2,
    kKUNCCancelResponse		= 3
};

#define KUNCCheckBoxChecked(i)	(1 << (8 + i))   /* can be used for radio's too */
#define KUNCPopUpSelection(n)	(n << 24)

/*
 * Callback function for KUNCNotifications
 */
typedef void
(*KUNCUserNotificationCallBack)(
	int		contextKey,
	int		responseFlags,
	const void	*xmlData);

/*
 * Get a notification ID
 */
KUNCUserNotificationID KUNCGetNotificationID(void) __attribute__((deprecated));

/* This function currently requires a bundle path, which kexts cannot currently get.  In the future, the CFBundleIdentiofier of the kext will be pass in in place of the bundlePath. */

kern_return_t
KUNCUserNotificationDisplayFromBundle(
	KUNCUserNotificationID		notificationID,
	char				*bundleIdentifier,
	char				*fileName,
	char				*fileExtension,
	char				*messageKey,
	char				*tokenString,
	KUNCUserNotificationCallBack	callback,
	int				contextKey) __attribute__((deprecated));


kern_return_t
KUNCUserNotificationCancel(
	KUNCUserNotificationID	notification) __attribute__((deprecated));


__END_DECLS

#endif  /* __USERNOTIFICATION_KUNCUSERNOTIFICATIONS_H */
                                                                                                                                                                                                                                                                                                                                                                                                 UNDReply.defs                                                                                       0100644 0001750 0001750 00000003313 12567450754 036645  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/UserNotification                                                     /*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

subsystem
#if KERNEL_SERVER
	KernelServer
#endif /* KERNEL_SERVER */
	UNDReply 6200;

#include <mach/std_types.defs>
#include <UserNotification/UNDTypes.defs>

simpleroutine UNDAlertCompletedWithResult_rpc(
				reply: UNDReplyRef;
			in	result: int;
			in	data: xmlData);

simpleroutine UNDNotificationCreated_rpc(
				reply: UNDReplyRef;
			in	userLandNotificationKey: int);

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                     UNDRequest.defs                                                                                     0100644 0001750 0001750 00000007571 12567450754 037214  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/UserNotification                                                     /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

subsystem
#if KERNEL_USER
	KernelUser
#endif /* KERNEL_USER */
	UNDRequest 6000;

#include <mach/std_types.defs>
#include <UserNotification/UNDTypes.defs>


/*
--	Messages sent by the UserNotification Client to the Server
*/

/* Execution information */
simpleroutine UNDExecute_rpc(
				server: UNDServerRef;
			in	executionPath: UNDPath;
			in	uid: int;
			in 	gid: int);

/* Bundle notice and bundle alert */

simpleroutine UNDDisplayNoticeFromBundle_rpc(
				server: UNDServerRef;
			in	reply: UNDReplyRef;
			in	bundlePath: UNDPath;
			in	fileName: UNDPath;
			in	fileExtension: UNDPath;
			in	messageKey: UNDKey);

simpleroutine UNDDisplayAlertFromBundle_rpc(
				server: UNDServerRef;
			in	reply: UNDReplyRef;
			in	bundlePath: UNDPath;
			in	fileName: UNDKey;
			in	fileExtension: UNDKey;
			in	messageKey: UNDKey);

simpleroutine UNDDisplayCustomFromBundle_rpc(
				server: UNDServerRef;
			in	reply: UNDReplyRef;
			in	bundlePath: UNDPath;
			in	fileName: UNDKey;
			in	fileExtension: UNDKey;
			in	messageKey: UNDKey;
			in	tokenKey: UNDPath);

skip; /* was UNDDisplayCustomFromDictionary_rpc */

simpleroutine UNDCancelNotification_rpc(
				server: UNDServerRef;
			in	userLandNotificationKey: int);

/*
 * Just pops up a notice with a single OK button and the label and message
 * specified below.  As such, there is no acknowledgement from the server.
 */
simpleroutine UNDDisplayNoticeSimple_rpc(
				server: UNDServerRef;
                        in	rpctimeout: int;
                        in	flags: unsigned;
                        in	iconPath:UNDLabel;
                        in	soundPath:UNDLabel;
                        in	localizationPath:UNDLabel;
			in	header: UNDLabel;
			in	message: UNDMessage;
                        in	defaultButtonTitle:UNDLabel);

/*
 * A synchronous routine to display an alert.  This will wait for the
 * result to come back.  As this can take an exceedingly long time to
 * complete (and will block the calling thread for the duration) great
 * care should be exercised before using this method.
 */
routine UNDDisplayAlertSimple_rpc(
				server: UNDServerRef;
                        in	rpctimeout: int;
                        in	flags: unsigned;
                        in	iconPath:UNDLabel;
                        in	soundPath:UNDLabel;
                        in	localizationPath:UNDLabel;
			in	header: UNDLabel;
			in	message: UNDMessage;
                        in	defaultButtonTitle:UNDLabel;
                        in	alternateButtonTitle:UNDLabel;
                        in	otherButtonTitle:UNDLabel;
			out	response: unsigned);

/* vim: set ft=c : */
                                                                                                                                       UNDTypes.defs                                                                                       0100644 0001750 0001750 00000004077 12567450753 036665  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/UserNotification                                                     /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _USERNOTIFICATION_UNDTYPES_DEFS_
#define _USERNOTIFICATION_UNDTYPES_DEFS_

#include <mach/std_types.defs>

/*
 * UserNotification message types
*/

type UNDMessage = c_string[*:1024];
type UNDLabel = c_string[*:128];

type UNDKey = c_string[*:128];
type UNDPath = c_string[*:1024];

type UNDXMLDict = c_string[*:2048];

/*
 * serialized XML data
 */
type xmlData    = ^ array [] of MACH_MSG_TYPE_BYTE
	ctype : xmlData_t;


type UNDServerRef = mach_port_t;

type UNDReplyRef = mach_port_t
#if	KERNEL_SERVER
		intran: UNDReplyRef convert_port_to_UNDReply(mach_port_t)
#endif	/* KERNEL_SERVER */
#if	KERNEL_USER
		ctype: mach_port_t
#endif /* KERNEL_USER */
		;

import <UserNotification/UNDTypes.h>;

#endif /* _USERNOTIFICATION_UNDTYPES_DEFS_ */

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 UNDTypes.h                                                                                          0100644 0001750 0001750 00000003577 12567450753 036177  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/UserNotification                                                     /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __USERNOTIFICATION_UNDTYPES_H
#define __USERNOTIFICATION_UNDTYPES_H

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE

#include <mach/mach_types.h>

typedef char *UNDMessage;
typedef char *UNDLabel;
typedef char *UNDKey;
typedef char *UNDPath;

/*
 * serialized key's, list delimiters, ...
 *	(sent as out-of-line data in a message)
 */
typedef const char * xmlData_t;


typedef mach_port_t UNDReplyRef;


#define UND_REPLY_NULL ((UNDReplyRef)0)
#define XML_DATA_NULL	((xmlData_t)0)

#endif  /* __APPLE_API_PRIVATE */

#endif	/* __USERNOTIFICATION_UNDTPES_H */

                                                                                                                                 architecture/                                                                                       0040755 0001750 0001750 00000000000 12612224742 033523  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      byte_order.h                                                                                        0100644 0001750 0001750 00000015536 12567450736 036056  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture                                                         /*
 * Copyright (c) 1999-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.0 (the 'License').  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License."
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Byte ordering conversion.
 *
 */

#ifndef	_ARCHITECTURE_BYTE_ORDER_H_
#define _ARCHITECTURE_BYTE_ORDER_H_
 
#include <libkern/OSByteOrder.h>

typedef unsigned long NXSwappedFloat;
typedef unsigned long long NXSwappedDouble;

static __inline__
unsigned short 
NXSwapShort(
    unsigned short inv
)
{
    return (unsigned short)OSSwapInt16((uint16_t)inv);
}

static __inline__
unsigned int
NXSwapInt(
    unsigned int inv
)
{
    return (unsigned int)OSSwapInt32((uint32_t)inv);
}

static __inline__
unsigned long
NXSwapLong(
    unsigned long inv
)
{
    return (unsigned long)OSSwapInt32((uint32_t)inv);
}

static __inline__
unsigned long long
NXSwapLongLong(
    unsigned long long inv
)
{
    return (unsigned long long)OSSwapInt64((uint64_t)inv);
}

static __inline__ NXSwappedFloat
NXConvertHostFloatToSwapped(float x)
{
    union fconv {
        float number;
        NXSwappedFloat sf;
    } u;
    u.number = x;
    return u.sf;
}

static __inline__ float
NXConvertSwappedFloatToHost(NXSwappedFloat x)
{
    union fconv {
        float number;
        NXSwappedFloat sf;
    } u;
    u.sf = x;
    return u.number;
}

static __inline__ NXSwappedDouble
NXConvertHostDoubleToSwapped(double x)
{
    union dconv {
        double number;
        NXSwappedDouble sd;
    } u;
    u.number = x;
    return u.sd;
}

static __inline__ double
NXConvertSwappedDoubleToHost(NXSwappedDouble x)
{
    union dconv {
        double number;
        NXSwappedDouble sd;
    } u;
    u.sd = x;
    return u.number;
}

static __inline__ NXSwappedFloat
NXSwapFloat(NXSwappedFloat x)
{ 
    return (NXSwappedFloat)OSSwapInt32((uint32_t)x);  
}

static __inline__ NXSwappedDouble   
NXSwapDouble(NXSwappedDouble x)
{  
    return (NXSwappedDouble)OSSwapInt64((uint64_t)x);
}

/*
 * Identify the byte order
 * of the current host.
 */

enum NXByteOrder {
    NX_UnknownByteOrder,
    NX_LittleEndian,
    NX_BigEndian
};

static __inline__
enum NXByteOrder
NXHostByteOrder(void)
{
#if defined(__LITTLE_ENDIAN__)
    return NX_LittleEndian;
#elif defined(__BIG_ENDIAN__)
    return NX_BigEndian;
#else
    return NX_UnknownByteOrder;
#endif
}

static __inline__
unsigned short
NXSwapBigShortToHost(
    unsigned short	x
)
{
    return (unsigned short)OSSwapBigToHostInt16((uint16_t)x);
}

static __inline__
unsigned int
NXSwapBigIntToHost(
    unsigned int	x
)
{
    return (unsigned int)OSSwapBigToHostInt32((uint32_t)x);
}

static __inline__
unsigned long
NXSwapBigLongToHost(
    unsigned long	x
)
{
    return (unsigned long)OSSwapBigToHostInt32((uint32_t)x);
}

static __inline__
unsigned long long
NXSwapBigLongLongToHost(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapBigToHostInt64((uint64_t)x);
}

static __inline__
double
NXSwapBigDoubleToHost(
    NXSwappedDouble	x
)
{
    return NXConvertSwappedDoubleToHost((NXSwappedDouble)OSSwapBigToHostInt64((uint64_t)x));
}

static __inline__
float
NXSwapBigFloatToHost(
    NXSwappedFloat	x
)
{
    return NXConvertSwappedFloatToHost((NXSwappedFloat)OSSwapBigToHostInt32((uint32_t)x));
}

static __inline__
unsigned short
NXSwapHostShortToBig(
    unsigned short	x
)
{
    return (unsigned short)OSSwapHostToBigInt16((uint16_t)x);
}

static __inline__
unsigned int
NXSwapHostIntToBig(
    unsigned int	x
)
{
    return (unsigned int)OSSwapHostToBigInt32((uint32_t)x);
}

static __inline__
unsigned long
NXSwapHostLongToBig(
    unsigned long	x
)
{
    return (unsigned long)OSSwapHostToBigInt32((uint32_t)x);
}

static __inline__
unsigned long long
NXSwapHostLongLongToBig(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapHostToBigInt64((uint64_t)x);
}

static __inline__
NXSwappedDouble
NXSwapHostDoubleToBig(
    double	x
)
{
    return (NXSwappedDouble)OSSwapHostToBigInt64((uint64_t)NXConvertHostDoubleToSwapped(x));
}

static __inline__
NXSwappedFloat
NXSwapHostFloatToBig(
    float	x
)
{
    return (NXSwappedFloat)OSSwapHostToBigInt32((uint32_t)NXConvertHostFloatToSwapped(x));
}

static __inline__
unsigned short
NXSwapLittleShortToHost(
    unsigned short	x
)
{
    return (unsigned short)OSSwapLittleToHostInt16((uint16_t)x);
}

static __inline__
unsigned int
NXSwapLittleIntToHost(
    unsigned int	x
)
{
    return (unsigned int)OSSwapLittleToHostInt32((uint32_t)x);
}

static __inline__
unsigned long
NXSwapLittleLongToHost(
    unsigned long	x
)
{
    return (unsigned long)OSSwapLittleToHostInt32((uint32_t)x);
}

static __inline__
unsigned long long
NXSwapLittleLongLongToHost(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapLittleToHostInt64((uint64_t)x);
}

static __inline__
double
NXSwapLittleDoubleToHost(
    NXSwappedDouble	x
)
{
    return NXConvertSwappedDoubleToHost((NXSwappedDouble)OSSwapLittleToHostInt64((uint64_t)x));
}

static __inline__
float
NXSwapLittleFloatToHost(
    NXSwappedFloat	x
)
{
    return NXConvertSwappedFloatToHost((NXSwappedFloat)OSSwapLittleToHostInt32((uint32_t)x));
}

static __inline__
unsigned short
NXSwapHostShortToLittle(
    unsigned short	x
)
{
    return (unsigned short)OSSwapHostToLittleInt16((uint16_t)x);
}

static __inline__
unsigned int
NXSwapHostIntToLittle(
    unsigned int	x
)
{
    return (unsigned int)OSSwapHostToLittleInt32((uint32_t)x);
}

static __inline__
unsigned long
NXSwapHostLongToLittle(
    unsigned long	x
)
{
    return (unsigned long)OSSwapHostToLittleInt32((uint32_t)x);
}

static __inline__
unsigned long long
NXSwapHostLongLongToLittle(
    unsigned long long	x
)
{
    return (unsigned long long)OSSwapHostToLittleInt64((uint64_t)x);
}

static __inline__
NXSwappedDouble
NXSwapHostDoubleToLittle(
    double	x
)
{
    return (NXSwappedDouble)OSSwapHostToLittleInt64((uint64_t)NXConvertHostDoubleToSwapped(x));
}

static __inline__
NXSwappedFloat
NXSwapHostFloatToLittle(
    float	x
)
{
    return (NXSwappedFloat)OSSwapHostToLittleInt32((uint32_t)NXConvertHostFloatToSwapped(x));
}

#endif	/* _ARCHITECTURE_BYTE_ORDER_H_ */
                                                                                                                                                                  i386/                                                                                               0040755 0001750 0001750 00000000000 12612224742 034214  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture                                                         asm_help.h                                                                                          0100644 0001750 0001750 00000017164 12567450734 036176  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	architecture/i386/asm_help.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *	Modified for i386 by: Bruce Martin, NeXT Computer, Inc.
 *
 *	This header file defines macros useful when writing assembly code
 *	for the Intel i386 family processors.
 *
 * HISTORY
 * 10-Mar-92  Bruce Martin (bmartin@next.com)
 *	Adapted to i386
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 */

#ifndef	_ARCH_I386_ASM_HELP_H_
#define	_ARCH_I386_ASM_HELP_H_

#include	<architecture/i386/reg_help.h>


#ifdef	__ASSEMBLER__

#define ALIGN						\
	.align	2, 0x90

/* Note that ROUND_TO_STACK rounds to Intel's stack alignment requirement,
 * but it is not sufficient for the Apple ABI which requires a 16-byte
 * aligned stack.  Various parts of the OS depend on this requirement,
 * including dyld.
 */
#define	ROUND_TO_STACK(len)				\
	(((len) + STACK_INCR - 1) / STACK_INCR * STACK_INCR)

#ifdef notdef
#define CALL_MCOUNT						\
	pushl	%ebp						;\
	movl	%esp, %ebp					;\
	.data							;\
	1: .long 0						;\
	.text							;\
	lea 9b,%edx						;\
	call mcount						;\
	popl	%ebp						;
#else
#define CALL_MCOUNT
#endif

/*
 * Prologue for functions that may call other functions.  Saves
 * registers and sets up a C frame.
 */
#define NESTED_FUNCTION_PROLOGUE(localvarsize)			\
	.set	__framesize,ROUND_TO_STACK(localvarsize)	;\
	.set	__nested_function, 1				;\
	CALL_MCOUNT						\
	.if __framesize						;\
	  pushl	%ebp						;\
	  movl	%esp, %ebp					;\
	  subl	$__framesize, %esp				;\
	.endif							;\
	pushl	%edi						;\
	pushl	%esi						;\
	pushl	%ebx

/*
 * Prologue for functions that do not call other functions.  Does not
 * save registers (this is the functions responsibility).  Does set
 * up a C frame.
 */
#define LEAF_FUNCTION_PROLOGUE(localvarsize)			\
	.set	__framesize,ROUND_TO_STACK(localvarsize)	;\
	.set	__nested_function, 0				;\
	CALL_MCOUNT						\
	.if __framesize						;\
	  pushl	%ebp						;\
	  movl	%esp, %ebp					;\
	  subl	$__framesize, %esp				;\
	.endif

/*
 * Prologue for any function.
 *
 * We assume that all Leaf functions will be responsible for saving any
 * local registers they clobber.
 */
#define FUNCTION_EPILOGUE					\
	.if __nested_function					;\
	  popl	%ebx						;\
	  popl	%esi						;\
	  popl	%edi						;\
	.endif							;\
	.if __framesize						;\
	  movl	%ebp, %esp					;\
	  popl	%ebp						;\
	.endif							;\
	ret


/*
 * Macros for declaring procedures
 *
 * Use of these macros allows ctags to have a predictable way
 * to find various types of declarations.  They also simplify
 * inserting appropriate symbol table information.
 *
 * NOTE: these simple stubs will be replaced with more
 * complicated versions once we know what the linker and gdb
 * will require as far as register use masks and frame declarations.
 * These macros may also be ifdef'ed in the future to contain profiling
 * code.
 *
 */

/*
 * TEXT -- declare start of text segment
 */
#define	TEXT						\
	.text

/*
 * DATA -- declare start of data segment
 */
#define DATA						\
	.data

/*
 * LEAF -- declare global leaf procedure
 * NOTE: Control SHOULD NOT FLOW into a LEAF!  A LEAF should only
 * be jumped to.  (A leaf may do an align.)  Use a LABEL() if you
 * need control to flow into the label.
 */
#define	LEAF(name, localvarsize)			\
	.globl	name					;\
	ALIGN						;\
name:							;\
	LEAF_FUNCTION_PROLOGUE(localvarsize)

/*
 * X_LEAF -- declare alternate global label for leaf
 */
#define	X_LEAF(name, value)				\
	.globl	name					;\
	.set	name,value

/*
 * P_LEAF -- declare private leaf procedure
 */
#define	P_LEAF(name, localvarsize)			\
	ALIGN						;\
name:							;\
	LEAF_FUNCTION_PROLOGUE(localvarsize)

/*
 * LABEL -- declare a global code label
 * MUST be used (rather than LEAF, NESTED, etc) if control
 * "flows into" the label.
 */
#define	LABEL(name)					\
	.globl	name					;\
name:

/*
 * NESTED -- declare procedure that invokes other procedures
 */
#define	NESTED(name, localvarsize)			\
	.globl	name					;\
	ALIGN						;\
name:							;\
	NESTED_FUNCTION_PROLOGUE(localvarsize)

/*
 * X_NESTED -- declare alternate global label for nested proc
 */
#define	X_NESTED(name, value)				\
	.globl	name					;\
	.set	name,value

/*
 * P_NESTED -- declare private nested procedure
 */
#define	P_NESTED(name, localvarsize)			\
	ALIGN						;\
name:							;\
	NESTED_FUNCTION_PROLOGUE(localvarsize)

/*
 * END -- mark end of procedure
 */
#define	END(name)					\
	FUNCTION_EPILOGUE


/*
 * Storage definition macros
 * The main purpose of these is to allow an easy handle for ctags
 */

/*
 * IMPORT -- import symbol
 */
#define	IMPORT(name)					\
	.reference	name

/*
 * ABS -- declare global absolute symbol
 */
#define	ABS(name, value)				\
	.globl	name					;\
	.set	name,value

/*
 * P_ABS -- declare private absolute symbol
 */
#define	P_ABS(name, value)				\
	.set	name,value

/*
 * EXPORT -- declare global label for data
 */
#define	EXPORT(name)					\
	.globl	name					;\
name:

/*
 * BSS -- declare global zero'ed storage
 */
#define	BSS(name,size)					\
	.comm	name,size


/*
 * P_BSS -- declare private zero'ed storage
 */
#define	P_BSS(name,size)				\
	.lcomm	name,size

/*
 * dynamic/PIC macros for routines which reference external symbols
 */

#if defined(__DYNAMIC__)
#define PICIFY(var)					\
	call	1f					; \
1:							; \
	popl	%edx					; \
	movl	L ## var ## $non_lazy_ptr-1b(%edx),%edx

#define CALL_EXTERN_AGAIN(func)	\
	PICIFY(func)		; \
	call	%edx

#define NON_LAZY_STUB(var)	\
.non_lazy_symbol_pointer	; \
L ## var ## $non_lazy_ptr:	; \
.indirect_symbol var		; \
.long 0				; \
.text

#define CALL_EXTERN(func)	\
	CALL_EXTERN_AGAIN(func)	; \
	NON_LAZY_STUB(func)

#define BRANCH_EXTERN(func)	\
	PICIFY(func)		; \
	jmp	%edx		; \
	NON_LAZY_STUB(func)

#define PUSH_EXTERN(var)	\
	PICIFY(var)		; \
	movl	(%edx),%edx	; \
	pushl	%edx		; \
	NON_LAZY_STUB(var)

#define REG_TO_EXTERN(reg, var)	\
	PICIFY(var)		; \
	movl	reg, (%edx)	; \
	NON_LAZY_STUB(var)

#define EXTERN_TO_REG(var, reg)				\
	call	1f					; \
1:							; \
	popl	%edx					; \
	movl	L ## var ##$non_lazy_ptr-1b(%edx),reg	; \
	NON_LAZY_STUB(var)


#else
#define BRANCH_EXTERN(func)	jmp	func
#define PUSH_EXTERN(var)	pushl	var
#define CALL_EXTERN(func)	call	func
#define CALL_EXTERN_AGAIN(func)	call	func
#define REG_TO_EXTERN(reg, var)	movl	reg, var
#define EXTERN_TO_REG(var, reg)	movl	$ ## var, reg
#endif

#endif	/* __ASSEMBLER__ */

#endif	/* _ARCH_I386_ASM_HELP_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                            cpu.h                                                                                               0100644 0001750 0001750 00000003256 12567450734 035172  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Special processor registers.
 *
 * HISTORY
 *
 * 5 April 1992 ? at NeXT
 *	Created.
 */

/*
 * Control register 0
 */
 
typedef struct _cr0 {
    unsigned int	pe	:1,
    			mp	:1,
			em	:1,
			ts	:1,
				:1,
			ne	:1,
				:10,
			wp	:1,
				:1,
			am	:1,
				:10,
			nw	:1,
			cd	:1,
			pg	:1;
} cr0_t;
                                                                                                                                                                                                                                                                                                                                                  desc.h                                                                                              0100644 0001750 0001750 00000006520 12567450734 035316  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Segment descriptors.
 *
 * HISTORY
 *
 * 29 March 1992 ? at NeXT
 *	Created.
 */
 
/*
 * Code segment descriptor.
 */

typedef struct code_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_CODE_EXEC	0x18
#define DESC_CODE_READ	0x1a
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:2,
			opsz	:1,
#define DESC_CODE_16B	0
#define DESC_CODE_32B	1
			granular:1;
#define DESC_GRAN_BYTE	0
#define DESC_GRAN_PAGE	1
    unsigned char	base24;
} code_desc_t;
 
/*
 * Data segment descriptor.
 */

typedef struct data_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_DATA_RONLY	0x10
#define DESC_DATA_WRITE	0x12
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:2,
			stksz	:1,
#define DESC_DATA_16B	0
#define DESC_DATA_32B	1
			granular:1;
    unsigned char	base24;
} data_desc_t;

/*
 * LDT segment descriptor.
 */

typedef struct ldt_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_LDT	0x02
				:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} ldt_desc_t;

#include <architecture/i386/sel.h>

/*
 * Call gate descriptor.
 */
 
typedef struct call_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int	argcnt	:5,
    				:3,
			type	:5,
#define DESC_CALL_GATE	0x0c
			dpl	:2,
			present	:1,
			offset16:16;
} call_gate_t;

/*
 * Trap gate descriptor.
 */
 
typedef struct trap_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
#define DESC_TRAP_GATE	0x0f
			dpl	:2,
			present	:1,
			offset16:16;
} trap_gate_t;


/*
 * Interrupt gate descriptor.
 */
 
typedef struct intr_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
#define DESC_INTR_GATE	0x0e
			dpl	:2,
			present	:1,
			offset16:16;
} intr_gate_t;
                                                                                                                                                                                io.h                                                                                                0100644 0001750 0001750 00000003020 12567450734 034777  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel 386 Family: IO space defines.
 *
 * HISTORY
 *
 * 11 August 1992 ? at NeXT
 *	Created.
 */

typedef unsigned short		io_addr_t;
typedef unsigned short		io_len_t;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                pio.h                                                                                               0100644 0001750 0001750 00000006706 12567450734 035175  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/* 
 */
#ifndef _ARCH_I386_PIO_H_
#define _ARCH_I386_PIO_H_

typedef unsigned short i386_ioport_t;

#if defined(__GNUC__)
static __inline__ unsigned int	inl(
				i386_ioport_t port)
{
	unsigned int datum;
	__asm__ volatile("inl %w1, %0" : "=a" (datum) : "Nd" (port));
	return(datum);
}

static __inline__ unsigned short inw(
				i386_ioport_t port)
{
	unsigned short datum;
	__asm__ volatile("inw %w1, %w0" : "=a" (datum) : "Nd" (port));
	return(datum);
}

static __inline__ unsigned char inb(
				i386_ioport_t port)
{
	unsigned char datum;
	__asm__ volatile("inb %w1, %b0" : "=a" (datum) : "Nd" (port));
	return(datum);
}

static __inline__ void outl(
				i386_ioport_t port,
				unsigned int datum)
{
	__asm__ volatile("outl %0, %w1" : : "a" (datum), "Nd" (port));
}

static __inline__ void outw(
				i386_ioport_t port,
				unsigned short datum)
{
	__asm__ volatile("outw %w0, %w1" : : "a" (datum), "Nd" (port));
}

static __inline__ void outb(
				i386_ioport_t port,
				unsigned char datum)
{
	__asm__ volatile("outb %b0, %w1" : : "a" (datum), "Nd" (port));
}
#endif /* defined(__GNUC__) */
#endif /* _ARCH_I386_PIO_H_ */
                                                          reg_help.h                                                                                          0100644 0001750 0001750 00000007077 12567450734 036175  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved.
 *
 *	File:	architecture/i386/reg_help.h
 *	Author:	Mike DeMoney, NeXT Computer, Inc.
 *      Modified for i386 by: Bruce Martin, NeXT Computer, Inc.
 *
 *	This header file defines cpp macros useful for defining
 *	machine register and doing machine-level operations.
 *
 * HISTORY
 * 10-Mar-92  Bruce Martin (bmartin@next.com)
 *	Adapted to i386
 * 23-Jan-91  Mike DeMoney (mike@next.com)
 *	Created.
 */

#ifndef	_ARCH_I386_REG_HELP_H_
#define	_ARCH_I386_REG_HELP_H_

/* Bitfield definition aid */
#define	BITS_WIDTH(msb, lsb)	((msb)-(lsb)+1)
#define	BIT_WIDTH(pos)		(1)	/* mostly to record the position */

/* Mask creation */
#define	MKMASK(width, offset)	(((unsigned)-1)>>(32-(width))<<(offset))
#define	BITSMASK(msb, lsb)	MKMASK(BITS_WIDTH(msb, lsb), lsb & 0x1f)
#define	BITMASK(pos)		MKMASK(BIT_WIDTH(pos), pos & 0x1f)

/* Register addresses */
#if	__ASSEMBLER__
# define	REG_ADDR(type, addr)	(addr)
#else	/* __ASSEMBLER__ */
# define	REG_ADDR(type, addr)	(*(volatile type *)(addr))
#endif	/* __ASSEMBLER__ */

/* Cast a register to be an unsigned */
#define	CONTENTS(foo)	(*(unsigned *) &(foo))

/* Stack pointer must always be a multiple of 4 */
#define	STACK_INCR	4
#define	ROUND_FRAME(x)	((((unsigned)(x)) + STACK_INCR - 1) & ~(STACK_INCR-1))

/* STRINGIFY -- perform all possible substitutions, then stringify */
#define	__STR(x)	#x		/* just a helper macro */
#define	STRINGIFY(x)	__STR(x)

/*
 * REG_PAIR_DEF -- define a register pair
 * Register pairs are appropriately aligned to allow access via
 * ld.d and st.d.
 *
 * Usage:
 *	struct foo {
 *		REG_PAIR_DEF(
 *			bar_t *,	barp,
 *			afu_t,		afu
 *		);
 *	};
 *
 * Access to individual entries of the pair is via the REG_PAIR
 * macro (below).
 */
#define	REG_PAIR_DEF(type0, name0, type1, name1)		\
	struct {						\
		type0	name0 __attribute__(( aligned(8) ));	\
		type1	name1;					\
	} name0##_##name1

/*
 * REG_PAIR -- Macro to define names for accessing individual registers
 * of register pairs.
 *
 * Usage:
 *	arg0 is first element of pair
 *	arg1 is second element of pair
 *	arg2 is desired element of pair
 * eg:
 *	#define	foo_barp	REG_PAIR(barp, afu, afu)
 */
#define	REG_PAIR(name0, name1, the_name)			\
	name0##_##name1.the_name

#endif	/* _ARCH_I386_REG_HELP_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 sel.h                                                                                               0100644 0001750 0001750 00000003417 12567450734 035165  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Segment selector.
 *
 * HISTORY
 *
 * 29 March 1992 ? at NeXT
 *	Created.
 */

/*
 * Segment selector.
 */

#ifndef __XNU_ARCH_I386_SEL_H
#define __XNU_ARCH_I386_SEL_H

typedef struct sel {
    unsigned short	rpl	:2,
#define KERN_PRIV	0
#define USER_PRIV	3
			ti	:1,
#define SEL_GDT		0
#define SEL_LDT		1
			index	:13;
} sel_t;

#define NULL_SEL	((sel_t) { 0, 0, 0 } )

#endif /* __XNU_ARCH_I386_SEL_H */
                                                                                                                                                                                                                                                 table.h                                                                                             0100644 0001750 0001750 00000004754 12567450734 035476  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Descriptor tables.
 *
 * HISTORY
 *
 * 30 March 1992 ? at NeXT
 *	Created.
 */

#include <architecture/i386/desc.h>
#include <architecture/i386/tss.h>

/*
 * A totally generic descriptor
 * table entry.
 */

typedef union dt_entry {
    code_desc_t		code;
    data_desc_t		data;
    ldt_desc_t		ldt;
    tss_desc_t		task_state;
    call_gate_t		call_gate;
    trap_gate_t		trap_gate;
    intr_gate_t		intr_gate;
    task_gate_t		task_gate;
} dt_entry_t;

#define DESC_TBL_MAX	8192

/*
 * Global descriptor table.
 */

typedef union gdt_entry {
    code_desc_t		code;
    data_desc_t		data;
    ldt_desc_t		ldt;
    call_gate_t		call_gate;
    task_gate_t		task_gate;
    tss_desc_t		task_state;
} gdt_entry_t;

typedef gdt_entry_t	gdt_t;

/*
 * Interrupt descriptor table.
 */

typedef union idt_entry {
    trap_gate_t		trap_gate;
    intr_gate_t		intr_gate;
    task_gate_t		task_gate;
} idt_entry_t;

typedef idt_entry_t	idt_t;

/*
 * Local descriptor table.
 */

typedef union ldt_entry {
    code_desc_t		code;
    data_desc_t		data;
    call_gate_t		call_gate;
    task_gate_t		task_gate;
} ldt_entry_t;

typedef ldt_entry_t	ldt_t;
                    tss.h                                                                                               0100644 0001750 0001750 00000005602 12567450734 035211  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/architecture/i386                                                    /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 * Intel386 Family:	Task State Segment.
 *
 * HISTORY
 *
 * 29 March 1992 ? at NeXT
 *	Created.
 */

#include <architecture/i386/sel.h>

/*
 * Task State segment.
 */

typedef struct tss {
    sel_t		oldtss;
    unsigned int		:0;
    unsigned int	esp0;
    sel_t		ss0;
    unsigned int		:0;
    unsigned int	esp1;
    sel_t		ss1;
    unsigned int		:0;
    unsigned int	esp2;
    sel_t		ss2;
    unsigned int		:0;
    unsigned int	cr3;
    unsigned int	eip;
    unsigned int	eflags;
    unsigned int	eax;
    unsigned int	ecx;
    unsigned int	edx;
    unsigned int	ebx;
    unsigned int	esp;
    unsigned int	ebp;
    unsigned int	esi;
    unsigned int	edi;
    sel_t		es;
    unsigned int		:0;
    sel_t		cs;
    unsigned int		:0;
    sel_t		ss;
    unsigned int		:0;
    sel_t		ds;
    unsigned int		:0;
    sel_t		fs;
    unsigned int		:0;
    sel_t		gs;
    unsigned int		:0;
    sel_t		ldt;
    unsigned int		:0;
    unsigned int	t	:1,
    				:15,
			io_bmap	:16;
} tss_t;

#define TSS_SIZE(n)	(sizeof (struct tss) + (n))

/*
 * Task State segment descriptor.
 */

typedef struct tss_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
#define DESC_TSS	0x09
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} tss_desc_t;

/*
 * Task gate descriptor.
 */
 
typedef struct task_gate {
    unsigned short		:16;
    sel_t		tss;
    unsigned int		:8,
    			type	:5,
#define DESC_TASK_GATE	0x05
			dpl	:2,
			present	:1,
				:0;
} task_gate_t;
                                                                                                                              atm/                                                                                                0040755 0001750 0001750 00000000000 12612224742 031622  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      atm_notification.defs                                                                               0100644 0001750 0001750 00000004157 12567450736 036035  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/atm                                                                  /*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 *  Interface definition for the Activity Trace Manager facility.
 */

subsystem
#if	KERNEL_USER
    KernelUser
#endif	/* KERNEL_USER */
    atm_notification 11500;

#include <mach/std_types.defs>
#include <mach/mach_types.defs>
#include <atm/atm_types.defs>

/*
 * Routine:
 */
simpleroutine atm_collect_trace_info(
		atm_port                : mach_port_move_send_t;
		activity_trace_id       : atm_aid_t;
		sub_activity_id         : mach_atm_subaid_t;
		flags                   : uint32_t;
		memory_buffers          : atm_memory_descriptor_array_t;
		buffer_sizes			: atm_memory_size_array_t
		);

simpleroutine atm_inspect_process_buffer(
		atm_port                : mach_port_move_send_t;
		proc_pid				: uint32_t;
		proc_uniqueid			: uint64_t;
		buffer_size 			: uint64_t;
		trace_buffer			: mach_port_t
);

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                                                                                                 atm_types.defs                                                                                      0100644 0001750 0001750 00000003352 12567450736 034507  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/atm                                                                  /*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 *	Activity Trace Manager interface type declarations
 */

#ifndef	_ATM_ATM_TYPES_DEFS_
#define _ATM_ATM_TYPES_DEFS_


#include <mach/std_types.defs>

type aid_t 	= uint64_t;
type atm_aid_t 	= uint64_t;
type mach_atm_subaid_t = uint64_t;

type atm_memory_descriptor_array_t = array[*:512] of mach_port_t;
type atm_memory_size_array_t = array[*:512] of uint64_t;

import <atm/atm_types.h>; 

#endif	/* _ATM_ATM_TYPES_DEFS_ */
/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                      atm_types.h                                                                                         0100644 0001750 0001750 00000005006 12567450736 034013  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/atm                                                                  /*
 * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _ATM_ATM_TYPES_H_
#define _ATM_ATM_TYPES_H_

#include <stdint.h>
#include <mach/mach_types.h>

#define MACH_VOUCHER_ATTR_ATM_NULL 		((mach_voucher_attr_recipe_command_t)501)
#define MACH_VOUCHER_ATTR_ATM_CREATE 		((mach_voucher_attr_recipe_command_t)510)
#define MACH_VOUCHER_ATTR_ATM_REGISTER 		((mach_voucher_attr_recipe_command_t)511)

typedef uint32_t atm_action_t;
#define ATM_ACTION_DISCARD	0x1
#define ATM_ACTION_COLLECT	0x2
#define ATM_ACTION_LOGFAIL	0x3
#define ATM_FIND_MIN_SUB_AID	0x4
#define ATM_ACTION_UNREGISTER	0x5
#define ATM_ACTION_REGISTER     0x6
#define ATM_ACTION_GETSUBAID    0x7

typedef uint64_t atm_guard_t;
typedef uint64_t aid_t;

/* Deprecated. will be removed soon */
typedef uint64_t subaid_t;
typedef uint64_t mailbox_offset_t;
#define SUB_AID_MAX (UINT64_MAX)

typedef uint64_t atm_aid_t;
typedef uint32_t atm_subaid32_t;
typedef uint64_t mach_atm_subaid_t;		/* Used for mach based apis. */
typedef uint64_t atm_mailbox_offset_t;


typedef mach_port_t atm_memory_descriptor_t;
typedef atm_memory_descriptor_t *atm_memory_descriptor_array_t;
typedef uint64_t *atm_memory_size_array_t;

#define ATM_SUBAID32_MAX 	(UINT32_MAX)
#define ATM_TRACE_DISABLE       (0x100)

#endif /* _ATM_ATM_TYPES_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          bank/                                                                                               0040755 0001750 0001750 00000000000 12612224742 031754  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      bank_types.h                                                                                        0100644 0001750 0001750 00000003320 12567450740 034267  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/bank                                                                 /*
 * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _BANK_BANK_TYPES_H_
#define _BANK_BANK_TYPES_H_

#include <stdint.h>
#include <mach/mach_types.h>

#define MACH_VOUCHER_ATTR_BANK_NULL 		((mach_voucher_attr_recipe_command_t)601)
#define MACH_VOUCHER_ATTR_BANK_CREATE 		((mach_voucher_attr_recipe_command_t)610)

#define MACH_VOUCHER_BANK_CONTENT_SIZE (500)

typedef uint32_t bank_action_t;
#define BANK_ORIGINATOR_PID	0x1

#endif /* _BANK_BANK_TYPES_H_ */
                                                                                                                                                                                                                                                                                                                bsm/                                                                                                0040755 0001750 0001750 00000000000 12612224742 031622  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      audit.h                                                                                             0100644 0001750 0001750 00000020504 12567450736 033114  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/bsm                                                                  /*-
 * Copyright (c) 2005-2009 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $P4: //depot/projects/trustedbsd/openbsm/sys/bsm/audit.h#10 $
 */

#ifndef	_BSM_AUDIT_H
#define	_BSM_AUDIT_H

#include <sys/param.h>
#include <sys/types.h>

#define	AUDIT_RECORD_MAGIC	0x828a0f1b
#define	MAX_AUDIT_RECORDS	20
#define	MAXAUDITDATA		(0x8000 - 1)
#define	MAX_AUDIT_RECORD_SIZE	MAXAUDITDATA
#define	MIN_AUDIT_FILE_SIZE	(512 * 1024)

/*
 * Minimum noumber of free blocks on the filesystem containing the audit
 * log necessary to avoid a hard log rotation. DO NOT SET THIS VALUE TO 0
 * as the kernel does an unsigned compare, plus we want to leave a few blocks
 * free so userspace can terminate the log, etc.
 */
#define	AUDIT_HARD_LIMIT_FREE_BLOCKS	4

/*
 * Triggers for the audit daemon.
 */
#define	AUDIT_TRIGGER_MIN		1
#define	AUDIT_TRIGGER_LOW_SPACE		1	/* Below low watermark. */
#define	AUDIT_TRIGGER_ROTATE_KERNEL	2	/* Kernel requests rotate. */
#define	AUDIT_TRIGGER_READ_FILE		3	/* Re-read config file. */
#define	AUDIT_TRIGGER_CLOSE_AND_DIE	4	/* Terminate audit. */
#define	AUDIT_TRIGGER_NO_SPACE		5	/* Below min free space. */
#define	AUDIT_TRIGGER_ROTATE_USER	6	/* User requests rotate. */
#define	AUDIT_TRIGGER_INITIALIZE	7	/* User initialize of auditd. */
#define	AUDIT_TRIGGER_EXPIRE_TRAILS	8	/* User expiration of trails. */
#define	AUDIT_TRIGGER_MAX		8

/*
 * The special device filename (FreeBSD).
 */
#define	AUDITDEV_FILENAME	"audit"
#define	AUDIT_TRIGGER_FILE	("/dev/" AUDITDEV_FILENAME)

/*
 * Pre-defined audit IDs
 */
#define	AU_DEFAUDITID	(uid_t)(-1)
#define	AU_DEFAUDITSID	 0
#define	AU_ASSIGN_ASID	-1

/*
 * IPC types.
 */
#define	AT_IPC_MSG	((u_char)1)	/* Message IPC id. */
#define	AT_IPC_SEM	((u_char)2)	/* Semaphore IPC id. */
#define	AT_IPC_SHM	((u_char)3)	/* Shared mem IPC id. */

/*
 * Audit conditions.
 */
#define	AUC_UNSET		0
#define	AUC_AUDITING		1
#define	AUC_NOAUDIT		2
#define	AUC_DISABLED		-1

/*
 * auditon(2) commands.
 */
#define	A_OLDGETPOLICY	2
#define	A_OLDSETPOLICY	3
#define	A_GETKMASK	4
#define	A_SETKMASK	5
#define	A_OLDGETQCTRL	6
#define	A_OLDSETQCTRL	7
#define	A_GETCWD	8
#define	A_GETCAR	9
#define	A_GETSTAT	12
#define	A_SETSTAT	13
#define	A_SETUMASK	14
#define	A_SETSMASK	15
#define	A_OLDGETCOND	20
#define	A_OLDSETCOND	21
#define	A_GETCLASS	22
#define	A_SETCLASS	23
#define	A_GETPINFO	24
#define	A_SETPMASK	25
#define	A_SETFSIZE	26
#define	A_GETFSIZE	27
#define	A_GETPINFO_ADDR	28
#define	A_GETKAUDIT	29
#define	A_SETKAUDIT	30
#define	A_SENDTRIGGER	31
#define	A_GETSINFO_ADDR	32
#define	A_GETPOLICY	33
#define	A_SETPOLICY	34
#define	A_GETQCTRL	35
#define	A_SETQCTRL	36
#define	A_GETCOND	37
#define	A_SETCOND	38
#define	A_GETSFLAGS	39
#define	A_SETSFLAGS	40

/*
 * Audit policy controls.
 */
#define	AUDIT_CNT	0x0001
#define	AUDIT_AHLT	0x0002
#define	AUDIT_ARGV	0x0004
#define	AUDIT_ARGE	0x0008
#define	AUDIT_SEQ	0x0010
#define	AUDIT_WINDATA	0x0020
#define	AUDIT_USER	0x0040
#define	AUDIT_GROUP	0x0080
#define	AUDIT_TRAIL	0x0100
#define	AUDIT_PATH	0x0200
#define	AUDIT_SCNT	0x0400
#define	AUDIT_PUBLIC	0x0800
#define	AUDIT_ZONENAME	0x1000
#define	AUDIT_PERZONE	0x2000

/*
 * Default audit queue control parameters.
 */
#define	AQ_HIWATER	100
#define	AQ_MAXHIGH	10000
#define	AQ_LOWATER	10
#define	AQ_BUFSZ	MAXAUDITDATA
#define	AQ_MAXBUFSZ	1048576

/*
 * Default minimum percentage free space on file system.
 */
#define	AU_FS_MINFREE	20

/*
 * Type definitions used indicating the length of variable length addresses
 * in tokens containing addresses, such as header fields.
 */
#define	AU_IPv4		4
#define	AU_IPv6		16

__BEGIN_DECLS

typedef	uid_t		au_id_t;
typedef	pid_t		au_asid_t;
typedef	u_int16_t	au_event_t;
typedef	u_int16_t	au_emod_t;
typedef	u_int32_t	au_class_t;
typedef	u_int64_t	au_asflgs_t __attribute__ ((aligned (8)));

struct au_tid {
	dev_t		port;
	u_int32_t	machine;
};
typedef	struct au_tid	au_tid_t;

struct au_tid_addr {
	dev_t		at_port;
	u_int32_t	at_type;
	u_int32_t	at_addr[4];
};
typedef	struct au_tid_addr	au_tid_addr_t;

struct au_mask {
	unsigned int    am_success;     /* Success bits. */
	unsigned int    am_failure;     /* Failure bits. */
};
typedef	struct au_mask	au_mask_t;

struct auditinfo {
	au_id_t		ai_auid;	/* Audit user ID. */
	au_mask_t	ai_mask;	/* Audit masks. */
	au_tid_t	ai_termid;	/* Terminal ID. */
	au_asid_t	ai_asid;	/* Audit session ID. */
};
typedef	struct auditinfo	auditinfo_t;

struct auditinfo_addr {
	au_id_t		ai_auid;	/* Audit user ID. */
	au_mask_t	ai_mask;	/* Audit masks. */
	au_tid_addr_t	ai_termid;	/* Terminal ID. */
	au_asid_t	ai_asid;	/* Audit session ID. */
	au_asflgs_t	ai_flags;	/* Audit session flags. */
};
typedef	struct auditinfo_addr	auditinfo_addr_t;

struct auditpinfo {
	pid_t		ap_pid;		/* ID of target process. */
	au_id_t		ap_auid;	/* Audit user ID. */
	au_mask_t	ap_mask;	/* Audit masks. */
	au_tid_t	ap_termid;	/* Terminal ID. */
	au_asid_t	ap_asid;	/* Audit session ID. */
};
typedef	struct auditpinfo	auditpinfo_t;

struct auditpinfo_addr {
	pid_t		ap_pid;		/* ID of target process. */
	au_id_t		ap_auid;	/* Audit user ID. */
	au_mask_t	ap_mask;	/* Audit masks. */
	au_tid_addr_t	ap_termid;	/* Terminal ID. */
	au_asid_t	ap_asid;	/* Audit session ID. */
	au_asflgs_t	ap_flags;	/* Audit session flags. */
};
typedef	struct auditpinfo_addr	auditpinfo_addr_t;

struct au_session {
	auditinfo_addr_t	*as_aia_p;	/* Ptr to full audit info. */
	au_mask_t		 as_mask;	/* Process Audit Masks. */
};
typedef struct au_session       au_session_t;

/*
 * Contents of token_t are opaque outside of libbsm.
 */
typedef	struct au_token	token_t;

/*
 * Kernel audit queue control parameters:
 * 			Default:		Maximum:
 * 	aq_hiwater:	AQ_HIWATER (100)	AQ_MAXHIGH (10000) 
 * 	aq_lowater:	AQ_LOWATER (10)		<aq_hiwater
 * 	aq_bufsz:	AQ_BUFSZ (32767)	AQ_MAXBUFSZ (1048576)
 * 	aq_delay:	20			20000 (not used) 
 */
struct au_qctrl {
	int	aq_hiwater;	/* Max # of audit recs in queue when */
				/* threads with new ARs get blocked. */ 

	int	aq_lowater;	/* # of audit recs in queue when */
				/* blocked threads get unblocked. */

	int	aq_bufsz;	/* Max size of audit record for audit(2). */
	int	aq_delay;	/* Queue delay (not used). */
	int	aq_minfree;	/* Minimum filesystem percent free space. */
};
typedef	struct au_qctrl	au_qctrl_t;

/*
 * Structure for the audit statistics.
 */
struct audit_stat {
	unsigned int	as_version;
	unsigned int	as_numevent;
	int		as_generated;
	int		as_nonattrib;
	int		as_kernel;
	int		as_audit;
	int		as_auditctl;
	int		as_enqueue;
	int		as_written;
	int		as_wblocked;
	int		as_rblocked;
	int		as_dropped;
	int		as_totalsize;
	unsigned int	as_memused;
};
typedef	struct audit_stat	au_stat_t;

/*
 * Structure for the audit file statistics.
 */
struct audit_fstat {
	u_int64_t	af_filesz;
	u_int64_t	af_currsz;
};
typedef	struct audit_fstat	au_fstat_t;

/*
 * Audit to event class mapping.
 */
struct au_evclass_map {
	au_event_t	ec_number;
	au_class_t	ec_class;
};
typedef	struct au_evclass_map	au_evclass_map_t;

/*
 * Audit system calls.
 */

__END_DECLS

#endif /* !_BSM_AUDIT_H */
                                                                                                                                                                                            corpses/                                                                                            0040755 0001750 0001750 00000000000 12612224742 032517  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      task_corpse.h                                                                                       0100644 0001750 0001750 00000007667 12567450740 035232  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/corpses                                                              /*
 * Copyright (c) 2012-2013, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _TASK_CORPSE_H_
#define _TASK_CORPSE_H_

#include <stdint.h>
#include <mach/mach_types.h>
#include <kern/kern_cdata.h>

typedef struct kcdata_item	*task_crashinfo_item_t;

/*
 * NOTE: Please update libkdd/kcdata/kcdtypes.c if you make any changes
 * in TASK_CRASHINFO_* types.
 */

#define TASK_CRASHINFO_BEGIN                KCDATA_BUFFER_BEGIN_CRASHINFO
#define TASK_CRASHINFO_STRING_DESC          KCDATA_TYPE_STRING_DESC
#define TASK_CRASHINFO_UINT32_DESC          KCDATA_TYPE_UINT32_DESC
#define TASK_CRASHINFO_UINT64_DESC          KCDATA_TYPE_UINT64_DESC

#define TASK_CRASHINFO_EXTMODINFO           0x801
#define TASK_CRASHINFO_BSDINFOWITHUNIQID    0x802 /* struct proc_uniqidentifierinfo */
#define TASK_CRASHINFO_TASKDYLD_INFO        0x803
#define TASK_CRASHINFO_UUID                 0x804
#define TASK_CRASHINFO_PID                  0x805
#define TASK_CRASHINFO_PPID                 0x806
#define TASK_CRASHINFO_RUSAGE               0x807  /* struct rusage */
#define TASK_CRASHINFO_RUSAGE_INFO          0x808  /* struct rusage_info_current */
#define TASK_CRASHINFO_PROC_NAME            0x809  /* char * */
#define TASK_CRASHINFO_PROC_STARTTIME       0x80B  /* struct timeval64 */
#define TASK_CRASHINFO_USERSTACK            0x80C  /* uint64_t */
#define TASK_CRASHINFO_ARGSLEN              0x80D
#define TASK_CRASHINFO_EXCEPTION_CODES      0x80E  /* mach_exception_data_t */
#define TASK_CRASHINFO_PROC_PATH            0x80F  /* string of len MAXPATHLEN */
#define TASK_CRASHINFO_PROC_CSFLAGS         0x810  /* uint32_t */
#define TASK_CRASHINFO_PROC_STATUS          0x811  /* char */
#define TASK_CRASHINFO_UID                  0x812  /* uid_t */
#define TASK_CRASHINFO_GID                  0x813  /* gid_t */
#define TASK_CRASHINFO_PROC_ARGC            0x814  /* int */
#define TASK_CRASHINFO_PROC_FLAGS           0x815  /* unsigned int */
#define TASK_CRASHINFO_CPUTYPE              0x816  /* cpu_type_t */
#define TASK_CRASHINFO_WORKQUEUEINFO        0x817  /* struct proc_workqueueinfo */
#define TASK_CRASHINFO_RESPONSIBLE_PID      0x818  /* pid_t */
#define TASK_CRASHINFO_DIRTY_FLAGS          0x819  /* int */
#define TASK_CRASHINFO_CRASHED_THREADID     0x81A  /* uint64_t */

#define TASK_CRASHINFO_END                  KCDATA_TYPE_BUFFER_END

/* Deprecated: use the KCDATA_* macros for all future use */
#define CRASHINFO_ITEM_TYPE(item)		  KCDATA_ITEM_TYPE(item)
#define CRASHINFO_ITEM_SIZE(item)		  KCDATA_ITEM_SIZE(item)
#define CRASHINFO_ITEM_DATA_PTR(item)	  KCDATA_ITEM_DATA_PTR(item)

#define CRASHINFO_ITEM_NEXT_HEADER(item)  KCDATA_ITEM_NEXT_HEADER(item)

#define CRASHINFO_ITEM_FOREACH(head)	  KCDATA_ITEM_FOREACH(head)




#endif /* _TASK_CORPSE_H_ */
                                                                         default_pager/                                                                                      0040755 0001750 0001750 00000000000 12612224742 033643  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      default_pager_alerts.defs                                                                           0100644 0001750 0001750 00000003275 12567450744 040702  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/default_pager                                                        /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * File:	default_pager/default_pager_alerts.defs
 *
 */

subsystem 
#if	KERNEL_USER
	KernelUser
#endif /* KERNEL_USER */
#if	KERNEL_SERVER
	KernelServer
#endif /* KERNEL_SERVER */
		default_pager_alerts 2295;

#include <mach/std_types.defs>
#include <mach/mach_types.defs>


simpleroutine	default_pager_space_alert(
		alert_port		: mach_port_t;
	in	flags			: int);

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                   default_pager_object.h                                                                              0100644 0001750 0001750 00000031774 12567450744 040171  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/default_pager                                                        #ifndef	_default_pager_object_user_
#define	_default_pager_object_user_

/* Module default_pager_object */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	default_pager_object_MSG_COUNT
#define	default_pager_object_MSG_COUNT	11
#endif	/* default_pager_object_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <default_pager/default_pager_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine default_pager_object_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_object_create
(
	mach_port_t default_pager,
	vm_size_t object_size,
	memory_object_t *memory_object
);

/* Routine default_pager_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_info
(
	mach_port_t default_pager,
	default_pager_info_t *info
);

/* Routine default_pager_objects */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_objects
(
	mach_port_t default_pager,
	default_pager_object_array_t *objects,
	mach_msg_type_number_t *objectsCnt,
	mach_port_array_t *ports,
	mach_msg_type_number_t *portsCnt
);

/* Routine default_pager_object_pages */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_object_pages
(
	mach_port_t default_pager,
	mach_port_t memory_object,
	default_pager_page_array_t *pages,
	mach_msg_type_number_t *pagesCnt
);

/* Routine default_pager_backing_store_create */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_backing_store_create
(
	mach_port_t default_pager,
	int priority,
	int clsize,
	mach_port_t *backing_store
);

/* Routine default_pager_backing_store_delete */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_backing_store_delete
(
	mach_port_t backing_store
);

/* Routine default_pager_backing_store_info */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_backing_store_info
(
	mach_port_t backing_store,
	backing_store_flavor_t flavor,
	backing_store_info_t info,
	mach_msg_type_number_t *infoCnt
);

/* Routine default_pager_add_file */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_add_file
(
	mach_port_t backing_store,
	vnode_ptr_t vnode,
	int record_size,
	vm_size_t size
);

/* Routine default_pager_triggers */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_triggers
(
	mach_port_t default_pager,
	int hi_wat,
	int lo_wat,
	int flags,
	mach_port_t trigger_port
);

/* Routine default_pager_info_64 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t default_pager_info_64
(
	mach_port_t default_pager,
	default_pager_info_64_t *info
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__default_pager_object_subsystem__defined
#define __Request__default_pager_object_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vm_size_t object_size;
	} __Request__default_pager_object_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__default_pager_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__default_pager_objects_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t memory_object;
		/* end of the kernel processed data */
	} __Request__default_pager_object_pages_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int priority;
		int clsize;
	} __Request__default_pager_backing_store_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__default_pager_backing_store_delete_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		backing_store_flavor_t flavor;
		mach_msg_type_number_t infoCnt;
	} __Request__default_pager_backing_store_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		vnode_ptr_t vnode;
		int record_size;
		vm_size_t size;
	} __Request__default_pager_add_file_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t trigger_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		int hi_wat;
		int lo_wat;
		int flags;
	} __Request__default_pager_triggers_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__default_pager_info_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__default_pager_object_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__default_pager_object_subsystem__defined
#define __RequestUnion__default_pager_object_subsystem__defined
union __RequestUnion__default_pager_object_subsystem {
	__Request__default_pager_object_create_t Request_default_pager_object_create;
	__Request__default_pager_info_t Request_default_pager_info;
	__Request__default_pager_objects_t Request_default_pager_objects;
	__Request__default_pager_object_pages_t Request_default_pager_object_pages;
	__Request__default_pager_backing_store_create_t Request_default_pager_backing_store_create;
	__Request__default_pager_backing_store_delete_t Request_default_pager_backing_store_delete;
	__Request__default_pager_backing_store_info_t Request_default_pager_backing_store_info;
	__Request__default_pager_add_file_t Request_default_pager_add_file;
	__Request__default_pager_triggers_t Request_default_pager_triggers;
	__Request__default_pager_info_64_t Request_default_pager_info_64;
};
#endif /* !__RequestUnion__default_pager_object_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__default_pager_object_subsystem__defined
#define __Reply__default_pager_object_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t memory_object;
		/* end of the kernel processed data */
	} __Reply__default_pager_object_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		default_pager_info_t info;
	} __Reply__default_pager_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t objects;
		mach_msg_ool_ports_descriptor_t ports;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t objectsCnt;
		mach_msg_type_number_t portsCnt;
	} __Reply__default_pager_objects_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t pages;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pagesCnt;
	} __Reply__default_pager_object_pages_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t backing_store;
		/* end of the kernel processed data */
	} __Reply__default_pager_backing_store_create_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__default_pager_backing_store_delete_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t infoCnt;
		integer_t info[20];
	} __Reply__default_pager_backing_store_info_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__default_pager_add_file_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__default_pager_triggers_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		default_pager_info_64_t info;
	} __Reply__default_pager_info_64_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__default_pager_object_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__default_pager_object_subsystem__defined
#define __ReplyUnion__default_pager_object_subsystem__defined
union __ReplyUnion__default_pager_object_subsystem {
	__Reply__default_pager_object_create_t Reply_default_pager_object_create;
	__Reply__default_pager_info_t Reply_default_pager_info;
	__Reply__default_pager_objects_t Reply_default_pager_objects;
	__Reply__default_pager_object_pages_t Reply_default_pager_object_pages;
	__Reply__default_pager_backing_store_create_t Reply_default_pager_backing_store_create;
	__Reply__default_pager_backing_store_delete_t Reply_default_pager_backing_store_delete;
	__Reply__default_pager_backing_store_info_t Reply_default_pager_backing_store_info;
	__Reply__default_pager_add_file_t Reply_default_pager_add_file;
	__Reply__default_pager_triggers_t Reply_default_pager_triggers;
	__Reply__default_pager_info_64_t Reply_default_pager_info_64;
};
#endif /* !__RequestUnion__default_pager_object_subsystem__defined */

#ifndef subsystem_to_name_map_default_pager_object
#define subsystem_to_name_map_default_pager_object \
    { "default_pager_object_create", 2275 },\
    { "default_pager_info", 2276 },\
    { "default_pager_objects", 2277 },\
    { "default_pager_object_pages", 2278 },\
    { "default_pager_backing_store_create", 2280 },\
    { "default_pager_backing_store_delete", 2281 },\
    { "default_pager_backing_store_info", 2282 },\
    { "default_pager_add_file", 2283 },\
    { "default_pager_triggers", 2284 },\
    { "default_pager_info_64", 2285 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _default_pager_object_user_ */
    default_pager_types.h                                                                               0100644 0001750 0001750 00000010256 12567450744 040057  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/default_pager                                                        /*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */


#ifndef	_MACH_DEFAULT_PAGER_TYPES_H_
#define _MACH_DEFAULT_PAGER_TYPES_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_UNSTABLE

#include <mach/mach_types.h>
#include <mach/machine/vm_types.h>
#include <mach/memory_object_types.h>

typedef	memory_object_default_t	default_pager_t;

/*
 *	Remember to update the mig type definitions
 *	in default_pager_types.defs when adding/removing fields.
 */

typedef struct default_pager_info {
	vm_size_t 	dpi_total_space; /* size of backing store */
	vm_size_t	dpi_free_space;	 /* how much of it is unused */
	vm_size_t	dpi_page_size;	 /* the pager's vm page size */
} default_pager_info_t;

typedef struct default_pager_info_64 {
	memory_object_size_t 	dpi_total_space; /* size of backing store */
	memory_object_size_t	dpi_free_space;	 /* how much of it is unused */
	vm_size_t		dpi_page_size;	 /* the pager's vm page size */
	int			dpi_flags;
#define DPI_ENCRYPTED	0x1	/* swap files are encrypted */
} default_pager_info_64_t;

typedef integer_t *backing_store_info_t;
typedef int	backing_store_flavor_t;
typedef int	*vnode_ptr_t;

#define BACKING_STORE_BASIC_INFO	1
#define BACKING_STORE_BASIC_INFO_COUNT \
		(sizeof(struct backing_store_basic_info)/sizeof(integer_t))
struct backing_store_basic_info {
	natural_t	pageout_calls;		/* # pageout calls */
	natural_t	pagein_calls;		/* # pagein calls */
	natural_t	pages_in;		/* # pages paged in (total) */
	natural_t	pages_out;		/* # pages paged out (total) */
	natural_t	pages_unavail;		/* # zero-fill pages */
	natural_t	pages_init;		/* # page init requests */
	natural_t	pages_init_writes;	/* # page init writes */

	natural_t	bs_pages_total;		/* # pages (total) */
	natural_t	bs_pages_free;		/* # unallocated pages */
	natural_t	bs_pages_in;		/* # page read requests */
	natural_t	bs_pages_in_fail;	/* # page read errors */
	natural_t	bs_pages_out;		/* # page write requests */
	natural_t	bs_pages_out_fail;	/* # page write errors */

	integer_t	bs_priority;
	integer_t	bs_clsize;
};
typedef struct backing_store_basic_info	*backing_store_basic_info_t;


typedef struct default_pager_object {
	vm_offset_t dpo_object;		/* object managed by the pager */
	vm_size_t dpo_size;		/* backing store used for the object */
} default_pager_object_t;

typedef default_pager_object_t *default_pager_object_array_t;

typedef struct default_pager_page {
	vm_offset_t dpp_offset;		/* offset of the page in its object */
} default_pager_page_t;

typedef default_pager_page_t *default_pager_page_array_t;

#define DEFAULT_PAGER_BACKING_STORE_MAXPRI	4

#define HI_WAT_ALERT		0x01
#define LO_WAT_ALERT		0x02
#define SWAP_ENCRYPT_ON		0x04
#define SWAP_ENCRYPT_OFF	0x08
#define SWAP_COMPACT_DISABLE	0x10
#define SWAP_COMPACT_ENABLE	0x20
#define PROC_RESUME		0x40
#define SWAP_FILE_CREATION_ERROR	0x80
#define USE_EMERGENCY_SWAP_FILE_FIRST	0x100

#endif /* __APPLE_API_UNSTABLE */

#endif	/* _MACH_DEFAULT_PAGER_TYPES_H_ */
                                                                                                                                                                                                                                                                                                                                                  device/                                                                                             0040755 0001750 0001750 00000000000 12612224742 032300  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      device.defs                                                                                         0100644 0001750 0001750 00000047263 12567450741 034424  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/device                                                               /*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * File:	device/device.defs
 * Author:	Douglas Orr
 *		Feb 10, 1988
 * Abstract:
 *	Mach device support.  Mach devices are accessed through
 *	block and character device interfaces to the kernel.
 */

subsystem
#if	KERNEL_SERVER
	  KernelServer
#endif	/* KERNEL_SERVER */
		       iokit 2800;

#if IOKITSIMD || KERNEL_SERVER
#define IOKIT_ALL_IPC 1
#endif

#include <mach/std_types.defs>
#include <mach/mach_types.defs>
#include <mach/clock_types.defs>
#include <mach/clock_types.defs>

#if !__LP64__
#    define __ILP32__ 1
#endif

import <device/device_types.h>;

serverprefix	is_;

type reply_port_t = MACH_MSG_TYPE_MAKE_SEND_ONCE | polymorphic
	ctype: mach_port_t;

#if	IOKIT

type io_name_t            = c_string[*:128];
type io_string_t          = c_string[*:512];
type io_string_inband_t   = c_string[*:4096];
type io_struct_inband_t   = array[*:4096] of char;
type io_buf_ptr_t	  = ^array[] of MACH_MSG_TYPE_INTEGER_8;
type NDR_record_t         = struct[8] of char;

type io_user_scalar_t     = uint64_t;
type io_user_reference_t  = uint64_t;
type io_scalar_inband_t   = array[*:16] of int;
// must be the same type as OSAsyncReference
type io_async_ref_t 	  = array[*:8]  of natural_t;
type io_scalar_inband64_t = array[*:16] of io_user_scalar_t;
type io_async_ref64_t 	  = array[*:8]  of io_user_reference_t;

type io_object_t = mach_port_t
		ctype: mach_port_t
#if	KERNEL_SERVER
		intran: io_object_t iokit_lookup_object_port(mach_port_t)
		outtran: mach_port_t iokit_make_object_port(io_object_t)
		destructor: iokit_remove_reference(io_object_t)
#endif	/* KERNEL_SERVER */
		;

type io_connect_t = mach_port_t
		ctype: mach_port_t
#if	KERNEL_SERVER
		intran: io_connect_t iokit_lookup_connect_port(mach_port_t)
		outtran: mach_port_t iokit_make_connect_port(io_connect_t)
		destructor: iokit_remove_reference(io_connect_t)
#endif	/* KERNEL_SERVER */
		;

routine io_object_get_class(
	    object		: io_object_t;
	out className		: io_name_t
	);

routine io_object_conforms_to(
	    object		: io_object_t;
	in  className		: io_name_t;
	out conforms		: boolean_t
	);

routine io_iterator_next(
	    iterator		: io_object_t;
	out object		: io_object_t
	);

routine io_iterator_reset(
	    iterator		: io_object_t
	);

routine io_service_get_matching_services(
	    master_port		: mach_port_t;
	in  matching		: io_string_t;
	out existing		: io_object_t
	);

routine io_registry_entry_get_property(
	    registry_entry	: io_object_t;
	in  property_name	: io_name_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_create_iterator(
	    master_port		: mach_port_t;
	in  plane		: io_name_t;
	in  options		: uint32_t;
	out iterator		: io_object_t
	);

routine io_registry_iterator_enter_entry(
	    iterator		: io_object_t
	);

routine io_registry_iterator_exit_entry(
	    iterator		: io_object_t
	);

routine io_registry_entry_from_path(
	    master_port		: mach_port_t;
	in  path		: io_string_t;
	out registry_entry	: io_object_t
	);

routine io_registry_entry_get_name(
	    registry_entry	: io_object_t;
	out name		: io_name_t
	);

routine io_registry_entry_get_properties(
	    registry_entry	: io_object_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_entry_get_property_bytes(
	    registry_entry	: io_object_t;
	in  property_name	: io_name_t;
	out data		: io_struct_inband_t, CountInOut
	);

routine io_registry_entry_get_child_iterator(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out iterator		: io_object_t
	);

routine io_registry_entry_get_parent_iterator(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out iterator		: io_object_t
	);

skip;
/* was routine io_service_open
	    service		: io_object_t;
	in  owningTask		: task_t;
	in  connect_type	: uint32_t;
	out connection		: io_connect_t
	);
*/

routine io_service_close(
	    connection		: io_connect_t
	);

routine io_connect_get_service(
	    connection		: io_connect_t;
	out service		: io_object_t
	);

#if  IOKIT_ALL_IPC || __ILP32__
routine io_connect_set_notification_port(
	    connection		: io_connect_t;
	in  notification_type	: uint32_t;
	in  port		: mach_port_make_send_t;
	in  reference		: uint32_t
	);

routine io_connect_map_memory(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  into_task		: task_t;
#if  IOKIT_ALL_IPC
	inout address		: uint32_t;
	inout size		: uint32_t;
#else
	inout address		: vm_address_t;
	inout size		: vm_size_t;
#endif
	in  flags		: uint32_t
	);
#else
skip;
skip;
#endif

routine io_connect_add_client(
	    connection		: io_connect_t;
	in  connect_to		: io_connect_t
	);

routine io_connect_set_properties(
	    connection		: io_connect_t;
	in  properties		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t
	);

#if  IOKIT_ALL_IPC || __ILP32__
routine io_connect_method_scalarI_scalarO(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_scalar_inband_t, CountInOut
	);

routine io_connect_method_scalarI_structureO(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);

routine io_connect_method_scalarI_structureI(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	in  inputStruct		: io_struct_inband_t
	);

routine io_connect_method_structureI_structureO(
	    connection		: io_connect_t;
	in  selector		: uint32_t;
	in  input		: io_struct_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);
#else
skip;
skip;
skip;
skip;
#endif

routine io_registry_entry_get_path(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out path		: io_string_t
	);

routine io_registry_get_root_entry(
	    master_port		: mach_port_t;
	out root		: io_object_t
	);

routine io_registry_entry_set_properties(
	    registry_entry	: io_object_t;
	in  properties		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t
	);

routine io_registry_entry_in_plane(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out inPlane		: boolean_t
	);

routine io_object_get_retain_count(
	    object		: io_object_t;
	out retainCount		: uint32_t
	);

routine io_service_get_busy_state(
	    service		: io_object_t;
	out busyState		: uint32_t
	);

routine io_service_wait_quiet(
	    service		: io_object_t;
	    wait_time		: mach_timespec_t
	);

routine io_registry_entry_create_iterator(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	in  options		: uint32_t;
	out iterator		: io_object_t
	);

routine io_iterator_is_valid(
	    iterator		: io_object_t;
	out is_valid		: boolean_t
	);

skip;
/* was routine io_make_matching(
	    master_port		: mach_port_t;
	in  of_type		: uint32_t;
	in  options		: uint32_t;
	in  input		: io_struct_inband_t;
	out matching		: io_string_t
	);
*/

routine io_catalog_send_data(
	    master_port		: mach_port_t;
        in  flag                : uint32_t;
	in  inData		: io_buf_ptr_t;
        out result		: kern_return_t
	);

routine io_catalog_terminate(
	    master_port		: mach_port_t;
        in  flag                : uint32_t;
	in  name		: io_name_t
	);

routine io_catalog_get_data(
	    master_port		: mach_port_t;
        in  flag                : uint32_t;
	out outData		: io_buf_ptr_t
	);

routine io_catalog_get_gen_count(
	    master_port		: mach_port_t;
        out genCount            : uint32_t
	);

routine io_catalog_module_loaded(
	    master_port		: mach_port_t;
	in  name		: io_name_t
	);

routine io_catalog_reset(
	    master_port		: mach_port_t;
	in  flag		: uint32_t
	);

routine io_service_request_probe(
	    service		: io_object_t;
	in  options		: uint32_t
	);

routine io_registry_entry_get_name_in_plane(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out name		: io_name_t
	);

routine io_service_match_property_table(
	    service		: io_object_t;
	in  matching		: io_string_t;
	out matches		: boolean_t
	);

#if  IOKIT_ALL_IPC || __ILP32__
routine io_async_method_scalarI_scalarO(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_scalar_inband_t, CountInOut
	);
routine io_async_method_scalarI_structureO(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);
routine io_async_method_scalarI_structureI(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_scalar_inband_t;
	in  inputStruct		: io_struct_inband_t
	);
routine io_async_method_structureI_structureO(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	in  selector		: uint32_t;
	in  input		: io_struct_inband_t;
	out output		: io_struct_inband_t, CountInOut
	);
#else
skip;
skip;
skip;
skip;
#endif

#if IOKIT_ALL_IPC || __ILP32__
routine io_service_add_notification(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_string_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	out notification	: io_object_t
	);
routine io_service_add_interest_notification(
	    service		: io_object_t;
	in  type_of_interest	: io_name_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	out notification	: io_object_t
        );
routine io_service_acknowledge_notification(
           service             : io_object_t;
       in  notify_ref          : natural_t;
       in  response            : natural_t
        );
#else
skip;
skip;
skip;
#endif

routine io_connect_get_notification_semaphore(
	    connection		: io_connect_t;
	in  notification_type	: natural_t;
	out semaphore		: semaphore_t
	);

#if IOKIT_ALL_IPC || __ILP32__
routine io_connect_unmap_memory(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  into_task		: task_t;
#if IOKIT_ALL_IPC
	in  address		: uint32_t
#else
	in  address		: vm_address_t
#endif
	);
#else
skip;
#endif

routine io_registry_entry_get_location_in_plane(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out location		: io_name_t
	);

routine io_registry_entry_get_property_recursively(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	in  property_name	: io_name_t;
	in  options		: uint32_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_service_get_state(
	    service		: io_object_t;
	out state		: uint64_t;
	out busy_state		: uint32_t;
	out accumulated_busy_time : uint64_t
	);

routine io_service_get_matching_services_ool(
	    master_port		: mach_port_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out existing		: io_object_t
	);

routine io_service_match_property_table_ool(
	    service		: io_object_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out matches		: boolean_t
	);

#if IOKIT_ALL_IPC || __ILP32__
routine io_service_add_notification_ool(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
        out result		: kern_return_t;
	out notification	: io_object_t
	);
#else
skip;
#endif

routine io_object_get_superclass(
	    master_port		: mach_port_t;
	in  obj_name			: io_name_t;
	out class_name          : io_name_t   
        );

routine io_object_get_bundle_identifier(
	    master_port		: mach_port_t;
	in  obj_name			: io_name_t;
	out class_name          : io_name_t   
        );

routine io_service_open_extended(
	    service		: io_object_t;
	in  owningTask		: task_t;
	in  connect_type	: uint32_t;
	in  ndr			: NDR_record_t;
	in  properties		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out connection		: io_connect_t
	);


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

routine io_connect_map_memory_into_task(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  into_task		: task_t;
	inout address		: mach_vm_address_t;
	inout size		: mach_vm_size_t;
	in  flags		: uint32_t
	);

routine io_connect_unmap_memory_from_task(
	    connection		: io_connect_t;
	in  memory_type		: uint32_t;
	in  from_task		: task_t;
	in  address		: mach_vm_address_t
	);

routine io_connect_method(
	    connection		: io_connect_t;
	in  selector		: uint32_t;

	in  scalar_input	: io_scalar_inband64_t;
	in  inband_input	: io_struct_inband_t;
	in  ool_input		: mach_vm_address_t;
	in  ool_input_size	: mach_vm_size_t;

	out inband_output	: io_struct_inband_t, CountInOut;
	out scalar_output	: io_scalar_inband64_t, CountInOut;
	in  ool_output		: mach_vm_address_t;
	inout ool_output_size	: mach_vm_size_t
	);

routine io_connect_async_method(
	    connection		: io_connect_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	in  selector		: uint32_t;

	in  scalar_input	: io_scalar_inband64_t;
	in  inband_input	: io_struct_inband_t;
	in  ool_input		: mach_vm_address_t;
	in  ool_input_size	: mach_vm_size_t;

	out inband_output	: io_struct_inband_t, CountInOut;
	out scalar_output	: io_scalar_inband64_t, CountInOut;
	in  ool_output		: mach_vm_address_t;
	inout  ool_output_size	: mach_vm_size_t
	);


#if IOKIT_ALL_IPC || __LP64__

#if IOKIT_ALL_IPC
#define FUNC_NAME(name) name ## _64
#else
#define FUNC_NAME(name) name
#endif

routine FUNC_NAME(io_connect_set_notification_port)(
	    connection		: io_connect_t;
	in  notification_type	: uint32_t;
	in  port		: mach_port_make_send_t;
	in  reference		: io_user_reference_t
	);

routine FUNC_NAME(io_service_add_notification)(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_string_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	out notification	: io_object_t
	);

routine FUNC_NAME(io_service_add_interest_notification)(
	    service		: io_object_t;
	in  type_of_interest	: io_name_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	out notification	: io_object_t
	);

routine FUNC_NAME(io_service_add_notification_ool)(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
        out result		: kern_return_t;
	out notification	: io_object_t
	);

#else

    skip;
    skip;
    skip;
    skip;

#endif /* IOKIT_ALL_IPC || __LP64__ */

routine io_registry_entry_get_registry_entry_id(
	    registry_entry	: io_object_t;
	out entry_id		: uint64_t
	);

routine io_connect_method_var_output(
	    connection		: io_connect_t;
	in  selector		: uint32_t;

	in  scalar_input	: io_scalar_inband64_t;
	in  inband_input	: io_struct_inband_t;
	in  ool_input		: mach_vm_address_t;
	in  ool_input_size	: mach_vm_size_t;

	out inband_output	: io_struct_inband_t, CountInOut;
	out scalar_output	: io_scalar_inband64_t, CountInOut;
	out var_output		: io_buf_ptr_t, physicalcopy
	);

routine io_service_get_matching_service(
	    master_port		: mach_port_t;
	in  matching		: io_string_t;
	out service		: io_object_t
	);

routine io_service_get_matching_service_ool(
	    master_port		: mach_port_t;
	in  matching		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out service		: io_object_t
	);

routine io_service_get_authorization_id(
	    service		: io_object_t;
	out authorization_id	: uint64_t
	);

routine io_service_set_authorization_id(
	    service		: io_object_t;
	in  authorization_id	: uint64_t
	);

/* */

routine io_server_version(
	    master_port		: mach_port_t;
	out version		: uint64_t
	);

routine io_registry_entry_get_properties_bin(
	    registry_entry	: io_object_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_entry_get_property_bin(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	in  property_name	: io_name_t;
	in  options		: uint32_t;
	out properties		: io_buf_ptr_t, physicalcopy
	);

routine io_service_get_matching_service_bin(
	    master_port		: mach_port_t;
	in  matching		: io_struct_inband_t;
	out service		: io_object_t
	);

routine io_service_get_matching_services_bin(
	    master_port		: mach_port_t;
	in  matching		: io_struct_inband_t;
	out existing		: io_object_t
	);

routine io_service_match_property_table_bin(
	    service		: io_object_t;
	in  matching		: io_struct_inband_t;
	out matches		: boolean_t
	);

#if IOKIT_ALL_IPC || __ILP32__
routine io_service_add_notification_bin(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_struct_inband_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref_t;
	out notification	: io_object_t
	);
#else
skip;
#endif

#if IOKIT_ALL_IPC || __LP64__
routine FUNC_NAME(io_service_add_notification_bin)(
	    master_port		: mach_port_t;
	in  notification_type	: io_name_t;
	in  matching		: io_struct_inband_t;
	in  wake_port		: mach_port_make_send_t;
	in  reference		: io_async_ref64_t;
	out notification	: io_object_t
	);
#else
skip;
#endif

#if !IOKITSIMD

routine io_registry_entry_get_path_ool(
	    registry_entry	: io_object_t;
	in  plane		: io_name_t;
	out path		: io_string_inband_t;
	out path_ool		: io_buf_ptr_t, physicalcopy
	);

routine io_registry_entry_from_path_ool(
	    master_port		: mach_port_t;
	in  path                : io_string_inband_t;
	in  path_ool		: io_buf_ptr_t, physicalcopy;
        out result		: kern_return_t;
	out registry_entry	: io_object_t
	);

#endif

#endif /* IOKIT */

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                             device_port.h                                                                                       0100644 0001750 0001750 00000005570 12567450741 034771  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/device                                                               /*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	Author: David B. Golub, Carnegie Mellon University
 *	Date: 	8/89
 */

#ifndef	_DEVICE_DEVICE_PORT_H_
#define	_DEVICE_DEVICE_PORT_H_

#include <device/device_types.h>

/*
 *	Master privileged I/O object for this host
 */
extern mach_port_t	master_device_port;

#define DEVICE_PAGER_GUARDED		0x1
#define DEVICE_PAGER_COHERENT		0x2
#define DEVICE_PAGER_CACHE_INHIB	0x4
#define DEVICE_PAGER_WRITE_THROUGH	0x8
#define DEVICE_PAGER_CONTIGUOUS		0x100
#define DEVICE_PAGER_NOPHYSCACHE	0x200

#endif	/* _DEVICE_DEVICE_PORT_H_ */
                                                                                                                                        device_types.defs                                                                                   0100644 0001750 0001750 00000007113 12567450741 035636  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/device                                                               /*
 * Copyright (c) 2002,2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	Author: David B. Golub, Carnegie Mellon University
 *	Date: 	3/89
 *	
 *	Common definitions for device interface types.
 */

#ifndef	_DEVICE_DEVICE_TYPES_DEFS_
#define	_DEVICE_DEVICE_TYPES_DEFS_

/*
 *	Basic types
 */

#include <mach/std_types.defs>
#include <mach/mach_types.defs>

type recnum_t		= uint32_t;
type dev_mode_t		= uint32_t;
type dev_flavor_t	= uint32_t;
type dev_name_t         = c_string[*:128];
type dev_status_t	= array[*:1024] of int;
type io_buf_len_t	= integer_t;
type io_buf_ptr_t	= ^array[] of MACH_MSG_TYPE_INTEGER_8;
type io_buf_ptr_inband_t= array[*:128] of char;
type filter_t		= short;
type filter_array_t	= array[*:64] of filter_t;

type device_t = mach_port_t
		ctype: mach_port_t
#if	KERNEL_SERVER
		intran: device_t dev_port_lookup(mach_port_t)
		outtran: mach_port_t convert_device_to_port(device_t)
		destructor: device_deallocate(device_t)
#endif	/* KERNEL_SERVER */
		;

type io_done_queue_t	= mach_port_t
		ctype: mach_port_t
#if	KERNEL_SERVER
		intran: io_done_queue_t io_done_queue_port_lookup(mach_port_t)
		outtran: mach_port_t convert_io_done_queue_to_port(io_done_queue_t)
#endif	/* KERNEL_SERVER */
		;

import <device/device_types.h>;

#endif	/* _DEVICE_DEVICE_TYPES_DEFS_ */

/* vim: set ft=c : */
                                                                                                                                                                                                                                                                                                                                                                                                                                                     device_types.h                                                                                      0100644 0001750 0001750 00000006631 12567450741 035150  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/device                                                               /*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	Author: David B. Golub, Carnegie Mellon University
 *	Date: 	3/89
 */

#ifndef	DEVICE_TYPES_H
#define	DEVICE_TYPES_H

/*
 * Types for device interface.
 */
#include <mach/std_types.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/port.h>



/*
 * IO buffer - out-of-line array of characters.
 */
typedef char *	io_buf_ptr_t;

/*
 * Some types for IOKit.
 */

#ifdef IOKIT

/* must match device_types.defs */
typedef	char			io_name_t[128];
typedef	char			io_string_t[512];	
typedef	char			io_string_inband_t[4096];
typedef char 			io_struct_inband_t[4096];

typedef uint64_t		io_user_scalar_t;
typedef uint64_t		io_user_reference_t;
typedef int 			io_scalar_inband_t[16];
// must be the same type as OSAsyncReference
typedef natural_t		io_async_ref_t[8];
typedef io_user_scalar_t	io_scalar_inband64_t[16];
typedef io_user_reference_t	io_async_ref64_t[8];


#ifndef	__IOKIT_PORTS_DEFINED__
#define __IOKIT_PORTS_DEFINED__
typedef mach_port_t	io_object_t;
#endif	/* __IOKIT_PORTS_DEFINED__ */


#endif  /* IOKIT */

#endif	/* DEVICE_TYPES_H */

                                                                                                       gssd/                                                                                               0040755 0001750 0001750 00000000000 12612224742 032001  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      gssd_mach.defs                                                                                      0100644 0001750 0001750 00000011571 12567450756 034615  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/gssd                                                                 /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#include <mach/std_types.defs>
#include <mach/mach_types.defs>

import <gssd/gssd_mach_types.h>;

type gssd_mechtype = int32_t;
type gssd_nametype = int32_t;
type gssd_string = c_string[*:1024]; /* MAX_PRINC_STR must be < 1024 */
type gssd_dstring = c_string[*:128]; /* MAX_DISPLAY_STR must be < 128 */
type gssd_byte_buffer = array [] of uint8_t;
type gssd_verifier =  uint64_t;
type gssd_gid_list = array [*:16] of uint32_t;
type gssd_ctx = uint64_t;
type gssd_cred = uint64_t;

subsystem
#if KERNEL_USER
KernelUser
#endif
gssd_mach  999;

serverprefix svc_;

Routine mach_gss_init_sec_context(
	server			: mach_port_t;
	in  mech		: gssd_mechtype;
	in  intoken		: gssd_byte_buffer;
	in  uid			: uint32_t;
	in  princ_namestr	: gssd_string;
	in  svc_namestr		: gssd_string;
	in  flags		: uint32_t;
	in  gssd_flags		: uint32_t;
	inout context		: gssd_ctx;
	inout cred_handle	: gssd_cred;
	ServerAuditToken atoken	: audit_token_t;
	out  ret_flags		: uint32_t;
	out  key		: gssd_byte_buffer, dealloc;
	out outtoken		: gssd_byte_buffer, dealloc;
	out major_stat		: uint32_t;
	out minor_stat		: uint32_t
);

routine mach_gss_accept_sec_context(
	server			: mach_port_t;
	in  intoken		: gssd_byte_buffer;
	in  svc_namestr		: gssd_string;
	in  gssd_flags		: uint32_t;
	inout context		: gssd_ctx;
	inout cred_handle	: gssd_cred;
	ServerAuditToken atoken	: audit_token_t;
	out flags		: uint32_t;
	out uid			: uint32_t;
	out gids		: gssd_gid_list;
	out key			: gssd_byte_buffer, dealloc;
	out outtoken		: gssd_byte_buffer, dealloc;
	out major_stat		: uint32_t;
	out minor_stat		: uint32_t
);

simpleroutine mach_gss_log_error(
	server			: mach_port_t;
	in  mnt			: gssd_string;
	in  uid			: uint32_t;
	in  source		: gssd_string;
	in  major_stat		: uint32_t;
	in  minor_stat		: uint32_t;
	ServerAuditToken atoken	: audit_token_t
);

routine mach_gss_init_sec_context_v2(
	server			: mach_port_t;
	in  mech		: gssd_mechtype;
	in  intoken		: gssd_byte_buffer;
	in  uid			: uint32_t;
	in  clnt_nt		: gssd_nametype;
	in  clnt_princ		: gssd_byte_buffer;
	in  svc_nt		: gssd_nametype;
	in  svc_princ		: gssd_byte_buffer;
	in  flags		: uint32_t;
	inout gssd_flags	: uint32_t;
	inout context		: gssd_ctx;
	inout cred_handle	: gssd_cred;
	ServerAuditToken atoken	: audit_token_t;
	out  ret_flags		: uint32_t;
	out  key		: gssd_byte_buffer, dealloc;
	out outtoken		: gssd_byte_buffer, dealloc;
	out displayname		: gssd_dstring;
	out major_stat		: uint32_t;
	out minor_stat		: uint32_t
);

routine mach_gss_accept_sec_context_v2(
	server			: mach_port_t;
	in  intoken		: gssd_byte_buffer;
	in  svc_nt		: gssd_nametype;
	in  svc_princ		: gssd_byte_buffer;
	inout gssd_flags	: uint32_t;
	inout context		: gssd_ctx;
	inout cred_handle	: gssd_cred;
	ServerAuditToken atoken	: audit_token_t;
	out flags		: uint32_t;
	out uid			: uint32_t;
	out gids		: gssd_gid_list;
	out key			: gssd_byte_buffer, dealloc;
	out outtoken		: gssd_byte_buffer, dealloc;
	out major_stat		: uint32_t;
	out minor_stat		: uint32_t
);

routine mach_gss_hold_cred(
	server			: mach_port_t;
	in  mech		: gssd_mechtype;
	in  nt			: gssd_nametype;
	in  princ		: gssd_byte_buffer;
	ServerAuditToken atoken	: audit_token_t;
	out major_stat		: uint32_t;
	out minor_stat		: uint32_t
);

routine mach_gss_unhold_cred(
	server			: mach_port_t;
	in  mech		: gssd_mechtype;
	in  nt			: gssd_nametype;
	in  princ		: gssd_byte_buffer;
	ServerAuditToken atoken	: audit_token_t;
	out major_stat		: uint32_t;
	out minor_stat		: uint32_t
);

routine mach_gss_lookup(
	server			: mach_port_t;
	in  uid			: uint32_t;
	in  asid		: int32_t;
	ServerAuditToken atoken	: audit_token_t;
	out gssd_session_port	: mach_port_t
);
                                                                                                                                       gssd_mach.h                                                                                         0100644 0001750 0001750 00000037613 12567450756 034130  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/gssd                                                                 #ifndef	_gssd_mach_user_
#define	_gssd_mach_user_

/* Module gssd_mach */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
#if	(__MigKernelSpecificCode) || (_MIG_KERNEL_SPECIFIC_CODE_)
#include <kern/ipc_mig.h>
#endif /* __MigKernelSpecificCode */

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	gssd_mach_MSG_COUNT
#define	gssd_mach_MSG_COUNT	8
#endif	/* gssd_mach_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <gssd/gssd_mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine mach_gss_init_sec_context */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_init_sec_context
(
	mach_port_t server,
	gssd_mechtype mech,
	gssd_byte_buffer intoken,
	mach_msg_type_number_t intokenCnt,
	uint32_t uid,
	gssd_string princ_namestr,
	gssd_string svc_namestr,
	uint32_t flags,
	uint32_t gssd_flags,
	gssd_ctx *context,
	gssd_cred *cred_handle,
	uint32_t *ret_flags,
	gssd_byte_buffer *key,
	mach_msg_type_number_t *keyCnt,
	gssd_byte_buffer *outtoken,
	mach_msg_type_number_t *outtokenCnt,
	uint32_t *major_stat,
	uint32_t *minor_stat
);

/* Routine mach_gss_accept_sec_context */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_accept_sec_context
(
	mach_port_t server,
	gssd_byte_buffer intoken,
	mach_msg_type_number_t intokenCnt,
	gssd_string svc_namestr,
	uint32_t gssd_flags,
	gssd_ctx *context,
	gssd_cred *cred_handle,
	uint32_t *flags,
	uint32_t *uid,
	gssd_gid_list gids,
	mach_msg_type_number_t *gidsCnt,
	gssd_byte_buffer *key,
	mach_msg_type_number_t *keyCnt,
	gssd_byte_buffer *outtoken,
	mach_msg_type_number_t *outtokenCnt,
	uint32_t *major_stat,
	uint32_t *minor_stat
);

/* SimpleRoutine mach_gss_log_error */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_log_error
(
	mach_port_t server,
	gssd_string mnt,
	uint32_t uid,
	gssd_string source,
	uint32_t major_stat,
	uint32_t minor_stat
);

/* Routine mach_gss_init_sec_context_v2 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_init_sec_context_v2
(
	mach_port_t server,
	gssd_mechtype mech,
	gssd_byte_buffer intoken,
	mach_msg_type_number_t intokenCnt,
	uint32_t uid,
	gssd_nametype clnt_nt,
	gssd_byte_buffer clnt_princ,
	mach_msg_type_number_t clnt_princCnt,
	gssd_nametype svc_nt,
	gssd_byte_buffer svc_princ,
	mach_msg_type_number_t svc_princCnt,
	uint32_t flags,
	uint32_t *gssd_flags,
	gssd_ctx *context,
	gssd_cred *cred_handle,
	uint32_t *ret_flags,
	gssd_byte_buffer *key,
	mach_msg_type_number_t *keyCnt,
	gssd_byte_buffer *outtoken,
	mach_msg_type_number_t *outtokenCnt,
	gssd_dstring displayname,
	uint32_t *major_stat,
	uint32_t *minor_stat
);

/* Routine mach_gss_accept_sec_context_v2 */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_accept_sec_context_v2
(
	mach_port_t server,
	gssd_byte_buffer intoken,
	mach_msg_type_number_t intokenCnt,
	gssd_nametype svc_nt,
	gssd_byte_buffer svc_princ,
	mach_msg_type_number_t svc_princCnt,
	uint32_t *gssd_flags,
	gssd_ctx *context,
	gssd_cred *cred_handle,
	uint32_t *flags,
	uint32_t *uid,
	gssd_gid_list gids,
	mach_msg_type_number_t *gidsCnt,
	gssd_byte_buffer *key,
	mach_msg_type_number_t *keyCnt,
	gssd_byte_buffer *outtoken,
	mach_msg_type_number_t *outtokenCnt,
	uint32_t *major_stat,
	uint32_t *minor_stat
);

/* Routine mach_gss_hold_cred */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_hold_cred
(
	mach_port_t server,
	gssd_mechtype mech,
	gssd_nametype nt,
	gssd_byte_buffer princ,
	mach_msg_type_number_t princCnt,
	uint32_t *major_stat,
	uint32_t *minor_stat
);

/* Routine mach_gss_unhold_cred */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_unhold_cred
(
	mach_port_t server,
	gssd_mechtype mech,
	gssd_nametype nt,
	gssd_byte_buffer princ,
	mach_msg_type_number_t princCnt,
	uint32_t *major_stat,
	uint32_t *minor_stat
);

/* Routine mach_gss_lookup */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_gss_lookup
(
	mach_port_t server,
	uint32_t uid,
	int32_t asid,
	mach_port_t *gssd_session_port
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__gssd_mach_subsystem__defined
#define __Request__gssd_mach_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t intoken;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		gssd_mechtype mech;
		mach_msg_type_number_t intokenCnt;
		uint32_t uid;
		mach_msg_type_number_t princ_namestrOffset; /* MiG doesn't use it */
		mach_msg_type_number_t princ_namestrCnt;
		char princ_namestr[1024];
		mach_msg_type_number_t svc_namestrOffset; /* MiG doesn't use it */
		mach_msg_type_number_t svc_namestrCnt;
		char svc_namestr[1024];
		uint32_t flags;
		uint32_t gssd_flags;
		gssd_ctx context;
		gssd_cred cred_handle;
	} __Request__mach_gss_init_sec_context_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t intoken;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t intokenCnt;
		mach_msg_type_number_t svc_namestrOffset; /* MiG doesn't use it */
		mach_msg_type_number_t svc_namestrCnt;
		char svc_namestr[1024];
		uint32_t gssd_flags;
		gssd_ctx context;
		gssd_cred cred_handle;
	} __Request__mach_gss_accept_sec_context_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t mntOffset; /* MiG doesn't use it */
		mach_msg_type_number_t mntCnt;
		char mnt[1024];
		uint32_t uid;
		mach_msg_type_number_t sourceOffset; /* MiG doesn't use it */
		mach_msg_type_number_t sourceCnt;
		char source[1024];
		uint32_t major_stat;
		uint32_t minor_stat;
	} __Request__mach_gss_log_error_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t intoken;
		mach_msg_ool_descriptor_t clnt_princ;
		mach_msg_ool_descriptor_t svc_princ;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		gssd_mechtype mech;
		mach_msg_type_number_t intokenCnt;
		uint32_t uid;
		gssd_nametype clnt_nt;
		mach_msg_type_number_t clnt_princCnt;
		gssd_nametype svc_nt;
		mach_msg_type_number_t svc_princCnt;
		uint32_t flags;
		uint32_t gssd_flags;
		gssd_ctx context;
		gssd_cred cred_handle;
	} __Request__mach_gss_init_sec_context_v2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t intoken;
		mach_msg_ool_descriptor_t svc_princ;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t intokenCnt;
		gssd_nametype svc_nt;
		mach_msg_type_number_t svc_princCnt;
		uint32_t gssd_flags;
		gssd_ctx context;
		gssd_cred cred_handle;
	} __Request__mach_gss_accept_sec_context_v2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t princ;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		gssd_mechtype mech;
		gssd_nametype nt;
		mach_msg_type_number_t princCnt;
	} __Request__mach_gss_hold_cred_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t princ;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		gssd_mechtype mech;
		gssd_nametype nt;
		mach_msg_type_number_t princCnt;
	} __Request__mach_gss_unhold_cred_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t uid;
		int32_t asid;
	} __Request__mach_gss_lookup_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__gssd_mach_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__gssd_mach_subsystem__defined
#define __RequestUnion__gssd_mach_subsystem__defined
union __RequestUnion__gssd_mach_subsystem {
	__Request__mach_gss_init_sec_context_t Request_mach_gss_init_sec_context;
	__Request__mach_gss_accept_sec_context_t Request_mach_gss_accept_sec_context;
	__Request__mach_gss_log_error_t Request_mach_gss_log_error;
	__Request__mach_gss_init_sec_context_v2_t Request_mach_gss_init_sec_context_v2;
	__Request__mach_gss_accept_sec_context_v2_t Request_mach_gss_accept_sec_context_v2;
	__Request__mach_gss_hold_cred_t Request_mach_gss_hold_cred;
	__Request__mach_gss_unhold_cred_t Request_mach_gss_unhold_cred;
	__Request__mach_gss_lookup_t Request_mach_gss_lookup;
};
#endif /* !__RequestUnion__gssd_mach_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__gssd_mach_subsystem__defined
#define __Reply__gssd_mach_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t key;
		mach_msg_ool_descriptor_t outtoken;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		gssd_ctx context;
		gssd_cred cred_handle;
		uint32_t ret_flags;
		mach_msg_type_number_t keyCnt;
		mach_msg_type_number_t outtokenCnt;
		uint32_t major_stat;
		uint32_t minor_stat;
	} __Reply__mach_gss_init_sec_context_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t key;
		mach_msg_ool_descriptor_t outtoken;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		gssd_ctx context;
		gssd_cred cred_handle;
		uint32_t flags;
		uint32_t uid;
		mach_msg_type_number_t gidsCnt;
		uint32_t gids[16];
		mach_msg_type_number_t keyCnt;
		mach_msg_type_number_t outtokenCnt;
		uint32_t major_stat;
		uint32_t minor_stat;
	} __Reply__mach_gss_accept_sec_context_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__mach_gss_log_error_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t key;
		mach_msg_ool_descriptor_t outtoken;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t gssd_flags;
		gssd_ctx context;
		gssd_cred cred_handle;
		uint32_t ret_flags;
		mach_msg_type_number_t keyCnt;
		mach_msg_type_number_t outtokenCnt;
		mach_msg_type_number_t displaynameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t displaynameCnt;
		char displayname[128];
		uint32_t major_stat;
		uint32_t minor_stat;
	} __Reply__mach_gss_init_sec_context_v2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t key;
		mach_msg_ool_descriptor_t outtoken;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t gssd_flags;
		gssd_ctx context;
		gssd_cred cred_handle;
		uint32_t flags;
		uint32_t uid;
		mach_msg_type_number_t gidsCnt;
		uint32_t gids[16];
		mach_msg_type_number_t keyCnt;
		mach_msg_type_number_t outtokenCnt;
		uint32_t major_stat;
		uint32_t minor_stat;
	} __Reply__mach_gss_accept_sec_context_v2_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t major_stat;
		uint32_t minor_stat;
	} __Reply__mach_gss_hold_cred_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t major_stat;
		uint32_t minor_stat;
	} __Reply__mach_gss_unhold_cred_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t gssd_session_port;
		/* end of the kernel processed data */
	} __Reply__mach_gss_lookup_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__gssd_mach_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__gssd_mach_subsystem__defined
#define __ReplyUnion__gssd_mach_subsystem__defined
union __ReplyUnion__gssd_mach_subsystem {
	__Reply__mach_gss_init_sec_context_t Reply_mach_gss_init_sec_context;
	__Reply__mach_gss_accept_sec_context_t Reply_mach_gss_accept_sec_context;
	__Reply__mach_gss_log_error_t Reply_mach_gss_log_error;
	__Reply__mach_gss_init_sec_context_v2_t Reply_mach_gss_init_sec_context_v2;
	__Reply__mach_gss_accept_sec_context_v2_t Reply_mach_gss_accept_sec_context_v2;
	__Reply__mach_gss_hold_cred_t Reply_mach_gss_hold_cred;
	__Reply__mach_gss_unhold_cred_t Reply_mach_gss_unhold_cred;
	__Reply__mach_gss_lookup_t Reply_mach_gss_lookup;
};
#endif /* !__RequestUnion__gssd_mach_subsystem__defined */

#ifndef subsystem_to_name_map_gssd_mach
#define subsystem_to_name_map_gssd_mach \
    { "mach_gss_init_sec_context", 999 },\
    { "mach_gss_accept_sec_context", 1000 },\
    { "mach_gss_log_error", 1001 },\
    { "mach_gss_init_sec_context_v2", 1002 },\
    { "mach_gss_accept_sec_context_v2", 1003 },\
    { "mach_gss_hold_cred", 1004 },\
    { "mach_gss_unhold_cred", 1005 },\
    { "mach_gss_lookup", 1006 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _gssd_mach_user_ */
                                                                                                                     gssd_mach_types.h                                                                                   0100644 0001750 0001750 00000005511 12567450755 035343  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/gssd                                                                 /*
 * Copyright (c) 2006, 2008, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _GSSD_MACH_TYPES_H_
#define _GSSD_MACH_TYPES_H_

#define MAX_DISPLAY_STR 128
#define MAX_PRINC_STR 1024

typedef enum gssd_mechtype {
	GSSD_NO_MECH = -1,
	GSSD_KRB5_MECH = 0,
	GSSD_SPNEGO_MECH,
	GSSD_NTLM_MECH,
	GSSD_IAKERB_MECH
} gssd_mechtype;

typedef enum gssd_nametype {
	GSSD_STRING_NAME = 0,
	GSSD_EXPORT, 
	GSSD_ANONYMOUS,
	GSSD_HOSTBASED,
	GSSD_USER,
	GSSD_MACHINE_UID,
	GSSD_STRING_UID,
	GSSD_KRB5_PRINCIPAL,
	GSSD_KRB5_REFERRAL, 
	GSSD_NTLM_PRINCIPAL,
	GSSD_NTLM_BLOB,
	GSSD_UUID
} gssd_nametype;

typedef char *gssd_string;
typedef char *gssd_dstring;
typedef uint8_t *gssd_byte_buffer;
typedef uint32_t *gssd_gid_list;
typedef uint64_t gssd_ctx;
typedef uint64_t gssd_cred;

/* The following need to correspond to GSS_C_*_FLAG in gssapi.h */
#define GSSD_DELEG_FLAG		1
#define GSSD_MUTUAL_FLAG	2
#define GSSD_REPLAY_FLAG	4
#define GSSD_SEQUENCE_FLAG	8
#define GSSD_CONF_FLAG		16
#define GSSD_INTEG_FLAG		32
#define GSSD_ANON_FLAG		64
#define GSSD_PROT_FLAG		128
#define GSSD_TRANS_FLAG		256
#define GSSD_DELEG_POLICY_FLAG	32768

#define GSSD_NO_DEFAULT		1  // Only use the supplied principal, do not fallback to the default.
#define GSSD_NO_CANON		2  // Don't canononicalize host names
#define GSSD_HOME_ACCESS_OK	4  // OK to access home directory
#define GSSD_GUEST_ONLY		8  // NTLM Server is forcing guest access
#define GSSD_RESTART		16 // Destroy the supplied context and start over
#define GSSD_NFS_1DES		64 // Only get single DES session keys
#define GSSD_WIN2K_HACK		128 // Hack for Win2K


#endif /* _GSSD_MACH_TYPES_H_ */
                                                                                                                                                                                       hfs/                                                                                                0040755 0001750 0001750 00000000000 12612224742 031621  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      hfs_encodings.h                                                                                     0100644 0001750 0001750 00000004612 12567450740 034613  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/hfs                                                                  /*
 * Copyright (c) 2000-2002, 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1997-2000 Apple Computer, Inc. All Rights Reserved
 */

#ifndef _HFS_ENCODINGS_H_
#define _HFS_ENCODINGS_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_UNSTABLE

#define CTL_HFS_NAMES { \
	{ 0, 0 }, \
	{ "encodingbias", CTLTYPE_INT }, \
}

/*
 * HFS Filename Encoding Converters Interface
 *
 * Private Interface for adding hfs filename
 * encoding converters. These are not needed
 * for HFS Plus volumes (since they already
 * have Unicode filenames).
 *
 * Used by HFS Encoding Converter Kernel Modules
 * (like HFS_Japanese.kmod) to register their
 * encoding conversion routines.
 */

typedef int (* hfs_to_unicode_func_t)(const Str31 hfs_str, UniChar *uni_str,
		u_int32_t maxCharLen, u_int32_t *usedCharLen);

typedef int (* unicode_to_hfs_func_t)(UniChar *uni_str, u_int32_t unicodeChars,
		Str31 hfs_str);

int hfs_addconverter(int kmod_id, u_int32_t encoding,
		hfs_to_unicode_func_t get_unicode,
		unicode_to_hfs_func_t get_hfsname);

int hfs_remconverter(int kmod_id, u_int32_t encoding);

#endif /* __APPLE_API_UNSTABLE */

#endif /* ! _HFS_ENCODINGS_H_ */
                                                                                                                      hfs_format.h                                                                                        0100644 0001750 0001750 00000076444 12567450740 034146  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/hfs                                                                  /*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef __HFS_FORMAT__
#define __HFS_FORMAT__

#include <sys/types.h>
#include <sys/appleapiopts.h>
#include <hfs/hfs_unistr.h>

/*
 * hfs_format.h
 *
 * This file describes the on-disk format for HFS and HFS Plus volumes.
 * The HFS Plus volume format is desciibed in detail in Apple Technote 1150.
 *
 * http://developer.apple.com/technotes/tn/tn1150.html
 *
 * Note: Starting 10.9, definition of struct HFSUniStr255 exists in hfs_unitstr.h
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

/* some on-disk hfs structures have 68K alignment (misaligned) */

/* Signatures used to differentiate between HFS and HFS Plus volumes */
enum {
	kHFSSigWord		= 0x4244,	/* 'BD' in ASCII */
	kHFSPlusSigWord		= 0x482B,	/* 'H+' in ASCII */
	kHFSXSigWord		= 0x4858,	/* 'HX' in ASCII */

	kHFSPlusVersion		= 0x0004,	/* 'H+' volumes are version 4 only */
	kHFSXVersion		= 0x0005,	/* 'HX' volumes start with version 5 */

	kHFSPlusMountVersion	= 0x31302E30,	/* '10.0' for Mac OS X */
	kHFSJMountVersion	= 0x4846534a,	/* 'HFSJ' for journaled HFS+ on OS X */
	kFSKMountVersion	= 0x46534b21	/* 'FSK!' for failed journal replay */
};


#ifdef __APPLE_API_PRIVATE
/*
 * Mac OS X has two special directories on HFS+ volumes for hardlinked files
 * and hardlinked directories as well as for open-unlinked files.
 *
 * These directories and their contents are not exported from the filesystem
 * under Mac OS X.
 */
#define HFSPLUSMETADATAFOLDER       "\xE2\x90\x80\xE2\x90\x80\xE2\x90\x80\xE2\x90\x80HFS+ Private Data"
#define HFSPLUS_DIR_METADATA_FOLDER ".HFS+ Private Directory Data\xd"

/*
 * Files in the "HFS+ Private Data" folder have one of the following prefixes
 * followed by a decimal number (no leading zeros) for the file ID.
 *
 * Note: Earlier version of Mac OS X used a 32 bit random number for the link
 * ref number instead of the file id.
 *
 * e.g.  iNode7182000 and temp3296
 */
#define HFS_INODE_PREFIX	"iNode"
#define HFS_DELETE_PREFIX	"temp"

/*
 * Files in the ".HFS+ Private Directory Data" folder have the following 
 * prefix followed by a decimal number (no leading zeros) for the file ID.
 *
 * e.g. dir_555
 */
#define HFS_DIRINODE_PREFIX	"dir_"

/*
 * Hardlink inodes save the head of the link chain in
 * an extended attribute named FIRST_LINK_XATTR_NAME.
 * The attribute data is the decimal value in ASCII
 * of the cnid for the first link in the chain.
 *
 * This extended attribute is private (i.e. its not
 * exported in the getxattr/listxattr POSIX APIs).
 */
#define FIRST_LINK_XATTR_NAME	"com.apple.system.hfs.firstlink"
#define FIRST_LINK_XATTR_REC_SIZE (sizeof(HFSPlusAttrData) - 2 + 12)

/*
 * The name space ID for generating an HFS volume UUID
 *
 * B3E20F39-F292-11D6-97A4-00306543ECAC
 */
#define HFS_UUID_NAMESPACE_ID  "\xB3\xE2\x0F\x39\xF2\x92\x11\xD6\x97\xA4\x00\x30\x65\x43\xEC\xAC"

#endif /* __APPLE_API_PRIVATE */

/*
 * Indirect link files (hard links) have the following type/creator.
 */
enum {
	kHardLinkFileType = 0x686C6E6B,  /* 'hlnk' */
	kHFSPlusCreator   = 0x6866732B   /* 'hfs+' */
};


/*
 *	File type and creator for symbolic links
 */
enum {
      kSymLinkFileType  = 0x736C6E6B, /* 'slnk' */
      kSymLinkCreator   = 0x72686170  /* 'rhap' */
};


enum {
	kHFSMaxVolumeNameChars		= 27,
	kHFSMaxFileNameChars		= 31,
	kHFSPlusMaxFileNameChars	= 255
};


/* Extent overflow file data structures */

/* HFS Extent key */
struct HFSExtentKey {
	u_int8_t 	keyLength;	/* length of key, excluding this field */
	u_int8_t 	forkType;	/* 0 = data fork, FF = resource fork */
	u_int32_t 	fileID;		/* file ID */
	u_int16_t 	startBlock;	/* first file allocation block number in this extent */
} __attribute__((aligned(2), packed));
typedef struct HFSExtentKey HFSExtentKey;

/* HFS Plus Extent key */
struct HFSPlusExtentKey {
	u_int16_t 	keyLength;		/* length of key, excluding this field */
	u_int8_t 	forkType;		/* 0 = data fork, FF = resource fork */
	u_int8_t 	pad;			/* make the other fields align on 32-bit boundary */
	u_int32_t 	fileID;			/* file ID */
	u_int32_t 	startBlock;		/* first file allocation block number in this extent */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusExtentKey HFSPlusExtentKey;

/* Number of extent descriptors per extent record */
enum {
	kHFSExtentDensity	= 3,
	kHFSPlusExtentDensity	= 8
};

/* HFS extent descriptor */
struct HFSExtentDescriptor {
	u_int16_t 	startBlock;		/* first allocation block */
	u_int16_t 	blockCount;		/* number of allocation blocks */
} __attribute__((aligned(2), packed));
typedef struct HFSExtentDescriptor HFSExtentDescriptor;

/* HFS Plus extent descriptor */
struct HFSPlusExtentDescriptor {
	u_int32_t 	startBlock;		/* first allocation block */
	u_int32_t 	blockCount;		/* number of allocation blocks */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusExtentDescriptor HFSPlusExtentDescriptor;

/* HFS extent record */
typedef HFSExtentDescriptor HFSExtentRecord[3];

/* HFS Plus extent record */
typedef HFSPlusExtentDescriptor HFSPlusExtentRecord[8];


/* Finder information */
struct FndrFileInfo {
	u_int32_t 	fdType;		/* file type */
	u_int32_t 	fdCreator;	/* file creator */
	u_int16_t 	fdFlags;	/* Finder flags */
	struct {
	    int16_t	v;		/* file's location */
	    int16_t	h;
	} fdLocation;
	int16_t 	opaque;
} __attribute__((aligned(2), packed));
typedef struct FndrFileInfo FndrFileInfo;

struct FndrDirInfo {
	struct {			/* folder's window rectangle */
	    int16_t	top;
	    int16_t	left;
	    int16_t	bottom;
	    int16_t	right;
	} frRect;
	unsigned short 	frFlags;	/* Finder flags */
	struct {
	    u_int16_t	v;		/* folder's location */
	    u_int16_t	h;
	} frLocation;
	int16_t 	opaque;
} __attribute__((aligned(2), packed));
typedef struct FndrDirInfo FndrDirInfo;

struct FndrOpaqueInfo {
	int8_t opaque[16];
} __attribute__((aligned(2), packed));
typedef struct FndrOpaqueInfo FndrOpaqueInfo;

struct FndrExtendedDirInfo {
	u_int32_t document_id;
	u_int32_t date_added;
	u_int16_t extended_flags;
	u_int16_t reserved3;
	u_int32_t write_gen_counter;
} __attribute__((aligned(2), packed));

struct FndrExtendedFileInfo {
	u_int32_t document_id;
	u_int32_t date_added;
	u_int16_t extended_flags;
	u_int16_t reserved2;
	u_int32_t write_gen_counter;
} __attribute__((aligned(2), packed));

/* HFS Plus Fork data info - 80 bytes */
struct HFSPlusForkData {
	u_int64_t 		logicalSize;	/* fork's logical size in bytes */
	u_int32_t 		clumpSize;	/* fork's clump size in bytes */
	u_int32_t 		totalBlocks;	/* total blocks used by this fork */
	HFSPlusExtentRecord 	extents;	/* initial set of extents */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusForkData HFSPlusForkData;


/* Mac OS X has 16 bytes worth of "BSD" info.
 *
 * Note:  Mac OS 9 implementations and applications
 * should preserve, but not change, this information.
 */
struct HFSPlusBSDInfo {
	u_int32_t 	ownerID;	/* user-id of owner or hard link chain previous link */
	u_int32_t 	groupID;	/* group-id of owner or hard link chain next link */
	u_int8_t 	adminFlags;	/* super-user changeable flags */
	u_int8_t 	ownerFlags;	/* owner changeable flags */
	u_int16_t 	fileMode;	/* file type and permission bits */
	union {
	    u_int32_t	iNodeNum;	/* indirect node number (hard links only) */
	    u_int32_t	linkCount;	/* links that refer to this indirect node */
	    u_int32_t	rawDevice;	/* special file device (FBLK and FCHR only) */
	} special;
} __attribute__((aligned(2), packed));
typedef struct HFSPlusBSDInfo HFSPlusBSDInfo;

/*
 * Hardlink "links" resolve to an inode
 * and the actual uid/gid comes from that
 * inode.
 *
 * We repurpose the links's uid/gid fields
 * for the hardlink link chain. The chain
 * consists of a doubly linked list of file
 * ids.
 */
 
#define hl_firstLinkID     reserved1         /* Valid only if HasLinkChain flag is set (indirect nodes only) */

#define hl_prevLinkID      bsdInfo.ownerID   /* Valid only if HasLinkChain flag is set */
#define hl_nextLinkID      bsdInfo.groupID   /* Valid only if HasLinkChain flag is set */

#define hl_linkReference   bsdInfo.special.iNodeNum
#define hl_linkCount       bsdInfo.special.linkCount


/* Catalog file data structures */

enum {
	kHFSRootParentID		= 1,	/* Parent ID of the root folder */
	kHFSRootFolderID		= 2,	/* Folder ID of the root folder */
	kHFSExtentsFileID		= 3,	/* File ID of the extents file */
	kHFSCatalogFileID		= 4,	/* File ID of the catalog file */
	kHFSBadBlockFileID		= 5,	/* File ID of the bad allocation block file */
	kHFSAllocationFileID		= 6,	/* File ID of the allocation file (HFS Plus only) */
	kHFSStartupFileID		= 7,	/* File ID of the startup file (HFS Plus only) */
	kHFSAttributesFileID		= 8,	/* File ID of the attribute file (HFS Plus only) */
	kHFSAttributeDataFileID         = 13,	/* Used in Mac OS X runtime for extent based attributes */
	                                        /* kHFSAttributeDataFileID is never stored on disk. */
	kHFSRepairCatalogFileID		= 14,	/* Used when rebuilding Catalog B-tree */
	kHFSBogusExtentFileID		= 15,	/* Used for exchanging extents in extents file */
	kHFSFirstUserCatalogNodeID	= 16
};

/* HFS catalog key */
struct HFSCatalogKey {
	u_int8_t 	keyLength;		/* key length (in bytes) */
	u_int8_t 	reserved;		/* reserved (set to zero) */
	u_int32_t 	parentID;		/* parent folder ID */
	u_int8_t 	nodeName[kHFSMaxFileNameChars + 1]; /* catalog node name */
} __attribute__((aligned(2), packed));
typedef struct HFSCatalogKey HFSCatalogKey;

/* HFS Plus catalog key */
struct HFSPlusCatalogKey {
	u_int16_t 		keyLength;	/* key length (in bytes) */
	u_int32_t 		parentID;	/* parent folder ID */
	HFSUniStr255 		nodeName;	/* catalog node name */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusCatalogKey HFSPlusCatalogKey;

/* Catalog record types */
enum {
	/* HFS Catalog Records */
	kHFSFolderRecord		= 0x0100,	/* Folder record */
	kHFSFileRecord			= 0x0200,	/* File record */
	kHFSFolderThreadRecord		= 0x0300,	/* Folder thread record */
	kHFSFileThreadRecord		= 0x0400,	/* File thread record */

	/* HFS Plus Catalog Records */
	kHFSPlusFolderRecord		= 1,		/* Folder record */
	kHFSPlusFileRecord		= 2,		/* File record */
	kHFSPlusFolderThreadRecord	= 3,		/* Folder thread record */
	kHFSPlusFileThreadRecord	= 4		/* File thread record */
};


/* Catalog file record flags */
enum {
	kHFSFileLockedBit	= 0x0000,	/* file is locked and cannot be written to */
	kHFSFileLockedMask	= 0x0001,

	kHFSThreadExistsBit	= 0x0001,	/* a file thread record exists for this file */
	kHFSThreadExistsMask	= 0x0002,

	kHFSHasAttributesBit	= 0x0002,	/* object has extended attributes */
	kHFSHasAttributesMask	= 0x0004,

	kHFSHasSecurityBit	= 0x0003,	/* object has security data (ACLs) */
	kHFSHasSecurityMask	= 0x0008,

	kHFSHasFolderCountBit	= 0x0004,	/* only for HFSX, folder maintains a separate sub-folder count */
	kHFSHasFolderCountMask	= 0x0010,	/* (sum of folder records and directory hard links) */

	kHFSHasLinkChainBit	= 0x0005,	/* has hardlink chain (inode or link) */
	kHFSHasLinkChainMask	= 0x0020,

	kHFSHasChildLinkBit	= 0x0006,	/* folder has a child that's a dir link */
	kHFSHasChildLinkMask	= 0x0040,

	kHFSHasDateAddedBit     = 0x0007,	/* File/Folder has the date-added stored in the finder info. */
	kHFSHasDateAddedMask    = 0x0080, 

	kHFSFastDevPinnedBit    = 0x0008,       /* this file has been pinned to the fast-device by the hot-file code on cooperative fusion */
	kHFSFastDevPinnedMask   = 0x0100,

	kHFSDoNotFastDevPinBit  = 0x0009,       /* this file can not be pinned to the fast-device */
	kHFSDoNotFastDevPinMask = 0x0200,

	kHFSFastDevCandidateBit  = 0x000a,      /* this item is a potential candidate for fast-dev pinning (as are any of its descendents */
	kHFSFastDevCandidateMask = 0x0400,

	kHFSAutoCandidateBit     = 0x000b,      /* this item was automatically marked as a fast-dev candidate by the kernel */
	kHFSAutoCandidateMask    = 0x0800

	// There are only 4 flag bits remaining: 0x1000, 0x2000, 0x4000, 0x8000

};


/* HFS catalog folder record - 70 bytes */
struct HFSCatalogFolder {
	int16_t 		recordType;		/* == kHFSFolderRecord */
	u_int16_t 		flags;			/* folder flags */
	u_int16_t 		valence;		/* folder valence */
	u_int32_t		folderID;		/* folder ID */
	u_int32_t 		createDate;		/* date and time of creation */
	u_int32_t 		modifyDate;		/* date and time of last modification */
	u_int32_t 		backupDate;		/* date and time of last backup */
	FndrDirInfo 		userInfo;		/* Finder information */
	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
	u_int32_t 		reserved[4];		/* reserved - initialized as zero */
} __attribute__((aligned(2), packed));
typedef struct HFSCatalogFolder HFSCatalogFolder;

/* HFS Plus catalog folder record - 88 bytes */
struct HFSPlusCatalogFolder {
	int16_t 		recordType;		/* == kHFSPlusFolderRecord */
	u_int16_t 		flags;			/* file flags */
	u_int32_t 		valence;		/* folder's item count */
	u_int32_t 		folderID;		/* folder ID */
	u_int32_t 		createDate;		/* date and time of creation */
	u_int32_t 		contentModDate;		/* date and time of last content modification */
	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
	u_int32_t 		backupDate;		/* date and time of last backup */
	HFSPlusBSDInfo		bsdInfo;		/* permissions (for MacOS X) */
	FndrDirInfo 		userInfo;		/* Finder information */
	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
	u_int32_t 		textEncoding;		/* hint for name conversions */
	u_int32_t 		folderCount;		/* number of enclosed folders, active when HasFolderCount is set */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusCatalogFolder HFSPlusCatalogFolder;

/* HFS catalog file record - 102 bytes */
struct HFSCatalogFile {
	int16_t 		recordType;		/* == kHFSFileRecord */
	u_int8_t 		flags;			/* file flags */
	int8_t 			fileType;		/* file type (unused ?) */
	FndrFileInfo 		userInfo;		/* Finder information */
	u_int32_t 		fileID;			/* file ID */
	u_int16_t 		dataStartBlock;		/* not used - set to zero */
	int32_t 		dataLogicalSize;	/* logical EOF of data fork */
	int32_t 		dataPhysicalSize;	/* physical EOF of data fork */
	u_int16_t		rsrcStartBlock;		/* not used - set to zero */
	int32_t			rsrcLogicalSize;	/* logical EOF of resource fork */
	int32_t			rsrcPhysicalSize;	/* physical EOF of resource fork */
	u_int32_t		createDate;		/* date and time of creation */
	u_int32_t		modifyDate;		/* date and time of last modification */
	u_int32_t		backupDate;		/* date and time of last backup */
	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
	u_int16_t		clumpSize;		/* file clump size (not used) */
	HFSExtentRecord		dataExtents;		/* first data fork extent record */
	HFSExtentRecord		rsrcExtents;		/* first resource fork extent record */
	u_int32_t		reserved;		/* reserved - initialized as zero */
} __attribute__((aligned(2), packed));
typedef struct HFSCatalogFile HFSCatalogFile;

/* HFS Plus catalog file record - 248 bytes */
struct HFSPlusCatalogFile {
	int16_t 		recordType;		/* == kHFSPlusFileRecord */
	u_int16_t 		flags;			/* file flags */
	u_int32_t 		reserved1;		/* reserved - initialized as zero */
	u_int32_t 		fileID;			/* file ID */
	u_int32_t 		createDate;		/* date and time of creation */
	u_int32_t 		contentModDate;		/* date and time of last content modification */
	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
	u_int32_t 		backupDate;		/* date and time of last backup */
	HFSPlusBSDInfo 		bsdInfo;		/* permissions (for MacOS X) */
	FndrFileInfo 		userInfo;		/* Finder information */
	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
	u_int32_t 		textEncoding;		/* hint for name conversions */
	u_int32_t 		reserved2;		/* reserved - initialized as zero */

	/* Note: these start on double long (64 bit) boundary */
	HFSPlusForkData 	dataFork;		/* size and block data for data fork */
	HFSPlusForkData 	resourceFork;		/* size and block data for resource fork */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusCatalogFile HFSPlusCatalogFile;

/* HFS catalog thread record - 46 bytes */
struct HFSCatalogThread {
	int16_t 	recordType;		/* == kHFSFolderThreadRecord or kHFSFileThreadRecord */
	int32_t 	reserved[2];		/* reserved - initialized as zero */
	u_int32_t 	parentID;		/* parent ID for this catalog node */
	u_int8_t 	nodeName[kHFSMaxFileNameChars + 1]; /* name of this catalog node */
} __attribute__((aligned(2), packed));
typedef struct HFSCatalogThread HFSCatalogThread;

/* HFS Plus catalog thread record -- 264 bytes */
struct HFSPlusCatalogThread {
	int16_t 	recordType;		/* == kHFSPlusFolderThreadRecord or kHFSPlusFileThreadRecord */
	int16_t 	reserved;		/* reserved - initialized as zero */
	u_int32_t 	parentID;		/* parent ID for this catalog node */
	HFSUniStr255 	nodeName;		/* name of this catalog node (variable length) */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusCatalogThread HFSPlusCatalogThread;

#ifdef __APPLE_API_UNSTABLE
/*
 * 	These are the types of records in the attribute B-tree.  The values were
 * 	chosen so that they wouldn't conflict with the catalog record types.
 */
enum {
	kHFSPlusAttrInlineData	= 0x10,   /* attributes whose data fits in a b-tree node */
	kHFSPlusAttrForkData	= 0x20,   /* extent based attributes (data lives in extents) */
	kHFSPlusAttrExtents	= 0x30    /* overflow extents for large attributes */
};


/*
 *  	HFSPlusAttrForkData
 * 	For larger attributes, whose value is stored in allocation blocks.
 * 	If the attribute has more than 8 extents, there will be additional
 * 	records (of type HFSPlusAttrExtents) for this attribute.
 */
struct HFSPlusAttrForkData {
	u_int32_t 	recordType;		/* == kHFSPlusAttrForkData*/
	u_int32_t 	reserved;
	HFSPlusForkData theFork;		/* size and first extents of value*/
} __attribute__((aligned(2), packed));
typedef struct HFSPlusAttrForkData HFSPlusAttrForkData;

/*
 * 	HFSPlusAttrExtents
 * 	This record contains information about overflow extents for large,
 * 	fragmented attributes.
 */
struct HFSPlusAttrExtents {
	u_int32_t 		recordType;	/* == kHFSPlusAttrExtents*/
	u_int32_t 		reserved;
	HFSPlusExtentRecord	extents;	/* additional extents*/
} __attribute__((aligned(2), packed));
typedef struct HFSPlusAttrExtents HFSPlusAttrExtents;

/*
 * Atrributes B-tree Data Record
 *
 * For small attributes, whose entire value is stored
 * within a single B-tree record.
 */
struct HFSPlusAttrData {
	u_int32_t    recordType;   /* == kHFSPlusAttrInlineData */
	u_int32_t    reserved[2];
	u_int32_t    attrSize;     /* size of attribute data in bytes */
	u_int8_t     attrData[2];  /* variable length */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusAttrData HFSPlusAttrData;


/* HFSPlusAttrInlineData is obsolete use HFSPlusAttrData instead */
struct HFSPlusAttrInlineData {
	u_int32_t 	recordType;
	u_int32_t 	reserved;
	u_int32_t 	logicalSize;
	u_int8_t 	userData[2];
} __attribute__((aligned(2), packed));
typedef struct HFSPlusAttrInlineData HFSPlusAttrInlineData;


/* A generic Attribute Record */
union HFSPlusAttrRecord {
	u_int32_t 		recordType;
	HFSPlusAttrInlineData 	inlineData;   /* NOT USED */
	HFSPlusAttrData 	attrData;
	HFSPlusAttrForkData 	forkData;
	HFSPlusAttrExtents 	overflowExtents;
};
typedef union HFSPlusAttrRecord HFSPlusAttrRecord;

/* Attribute key */
enum { kHFSMaxAttrNameLen = 127 };
struct HFSPlusAttrKey {
	u_int16_t     keyLength;       /* key length (in bytes) */
	u_int16_t     pad;	       /* set to zero */
	u_int32_t     fileID;          /* file associated with attribute */
	u_int32_t     startBlock;      /* first allocation block number for extents */
	u_int16_t     attrNameLen;     /* number of unicode characters */
	u_int16_t     attrName[kHFSMaxAttrNameLen];   /* attribute name (Unicode) */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusAttrKey HFSPlusAttrKey;

#define kHFSPlusAttrKeyMaximumLength   (sizeof(HFSPlusAttrKey) - sizeof(u_int16_t))
#define kHFSPlusAttrKeyMinimumLength   (kHFSPlusAttrKeyMaximumLength - kHFSMaxAttrNameLen*sizeof(u_int16_t))

#endif /* __APPLE_API_UNSTABLE */


/* Key and node lengths */
enum {
	kHFSPlusExtentKeyMaximumLength = sizeof(HFSPlusExtentKey) - sizeof(u_int16_t),
	kHFSExtentKeyMaximumLength	= sizeof(HFSExtentKey) - sizeof(u_int8_t),
	kHFSPlusCatalogKeyMaximumLength = sizeof(HFSPlusCatalogKey) - sizeof(u_int16_t),
	kHFSPlusCatalogKeyMinimumLength = kHFSPlusCatalogKeyMaximumLength - sizeof(HFSUniStr255) + sizeof(u_int16_t),
	kHFSCatalogKeyMaximumLength	= sizeof(HFSCatalogKey) - sizeof(u_int8_t),
	kHFSCatalogKeyMinimumLength	= kHFSCatalogKeyMaximumLength - (kHFSMaxFileNameChars + 1) + sizeof(u_int8_t),
	kHFSPlusCatalogMinNodeSize	= 4096,
	kHFSPlusExtentMinNodeSize	= 512,
	kHFSPlusAttrMinNodeSize		= 4096
};

/* HFS and HFS Plus volume attribute bits */
enum {
	/* Bits 0-6 are reserved (always cleared by MountVol call) */
	kHFSVolumeHardwareLockBit	= 7,		/* volume is locked by hardware */
	kHFSVolumeUnmountedBit		= 8,		/* volume was successfully unmounted */
	kHFSVolumeSparedBlocksBit	= 9,		/* volume has bad blocks spared */
	kHFSVolumeNoCacheRequiredBit = 10,		/* don't cache volume blocks (i.e. RAM or ROM disk) */
	kHFSBootVolumeInconsistentBit = 11,		/* boot volume is inconsistent (System 7.6 and later) */
	kHFSCatalogNodeIDsReusedBit = 12,
	kHFSVolumeJournaledBit = 13,			/* this volume has a journal on it */
	kHFSVolumeInconsistentBit = 14,			/* serious inconsistencies detected at runtime */
	kHFSVolumeSoftwareLockBit	= 15,		/* volume is locked by software */
	/*
	 * HFS only has 16 bits of attributes in the MDB, but HFS Plus has 32 bits.
	 * Therefore, bits 16-31 can only be used on HFS Plus.
	 */
	kHFSUnusedNodeFixBit = 31,				/* Unused nodes in the Catalog B-tree have been zero-filled.  See Radar #6947811. */
	kHFSContentProtectionBit = 30,			/* Volume has per-file content protection */

	/***  Keep these in sync with the bits above ! ****/
	kHFSVolumeHardwareLockMask		= 0x00000080,
	kHFSVolumeUnmountedMask			= 0x00000100,
	kHFSVolumeSparedBlocksMask		= 0x00000200,
	kHFSVolumeNoCacheRequiredMask 	= 0x00000400,
	kHFSBootVolumeInconsistentMask	= 0x00000800,
	kHFSCatalogNodeIDsReusedMask 	= 0x00001000,
	kHFSVolumeJournaledMask			= 0x00002000,
	kHFSVolumeInconsistentMask 		= 0x00004000,
	kHFSVolumeSoftwareLockMask		= 0x00008000,
	
	/* Bits 16-31 are allocated from high to low */

	kHFSContentProtectionMask 		= 0x40000000,
	kHFSUnusedNodeFixMask 			= 0x80000000,
	
	kHFSMDBAttributesMask			= 0x8380
};

enum {
	kHFSUnusedNodesFixDate = 0xc5ef2480		/* March 25, 2009 */
};

/* HFS Master Directory Block - 162 bytes */
/* Stored at sector #2 (3rd sector) and second-to-last sector. */
struct HFSMasterDirectoryBlock {
	u_int16_t 		drSigWord;	/* == kHFSSigWord */
	u_int32_t 		drCrDate;	/* date and time of volume creation */
	u_int32_t 		drLsMod;	/* date and time of last modification */
	u_int16_t 		drAtrb;		/* volume attributes */
	u_int16_t 		drNmFls;	/* number of files in root folder */
	u_int16_t 		drVBMSt;	/* first block of volume bitmap */
	u_int16_t 		drAllocPtr;	/* start of next allocation search */
	u_int16_t 		drNmAlBlks;	/* number of allocation blocks in volume */
	u_int32_t 		drAlBlkSiz;	/* size (in bytes) of allocation blocks */
	u_int32_t 		drClpSiz;	/* default clump size */
	u_int16_t 		drAlBlSt;	/* first allocation block in volume */
	u_int32_t 		drNxtCNID;	/* next unused catalog node ID */
	u_int16_t 		drFreeBks;	/* number of unused allocation blocks */
	u_int8_t 		drVN[kHFSMaxVolumeNameChars + 1];  /* volume name */
	u_int32_t 		drVolBkUp;	/* date and time of last backup */
	u_int16_t 		drVSeqNum;	/* volume backup sequence number */
	u_int32_t 		drWrCnt;	/* volume write count */
	u_int32_t 		drXTClpSiz;	/* clump size for extents overflow file */
	u_int32_t 		drCTClpSiz;	/* clump size for catalog file */
	u_int16_t 		drNmRtDirs;	/* number of directories in root folder */
	u_int32_t 		drFilCnt;	/* number of files in volume */
	u_int32_t 		drDirCnt;	/* number of directories in volume */
	u_int32_t 		drFndrInfo[8];	/* information used by the Finder */
	u_int16_t 		drEmbedSigWord;	/* embedded volume signature (formerly drVCSize) */
	HFSExtentDescriptor	drEmbedExtent;	/* embedded volume location and size (formerly drVBMCSize and drCtlCSize) */
	u_int32_t		drXTFlSize;	/* size of extents overflow file */
	HFSExtentRecord		drXTExtRec;	/* extent record for extents overflow file */
	u_int32_t 		drCTFlSize;	/* size of catalog file */
	HFSExtentRecord 	drCTExtRec;	/* extent record for catalog file */
} __attribute__((aligned(2), packed));
typedef struct HFSMasterDirectoryBlock	HFSMasterDirectoryBlock;


#ifdef __APPLE_API_UNSTABLE
#define SET_HFS_TEXT_ENCODING(hint)  \
	(0x656e6300 | ((hint) & 0xff))
#define GET_HFS_TEXT_ENCODING(hint)  \
	(((hint) & 0xffffff00) == 0x656e6300 ? (hint) & 0x000000ff : 0xffffffffU)
#endif /* __APPLE_API_UNSTABLE */


/* HFS Plus Volume Header - 512 bytes */
/* Stored at sector #2 (3rd sector) and second-to-last sector. */
struct HFSPlusVolumeHeader {
	u_int16_t 	signature;		/* == kHFSPlusSigWord */
	u_int16_t 	version;		/* == kHFSPlusVersion */
	u_int32_t 	attributes;		/* volume attributes */
	u_int32_t 	lastMountedVersion;	/* implementation version which last mounted volume */
	u_int32_t 	journalInfoBlock;	/* block addr of journal info (if volume is journaled, zero otherwise) */

	u_int32_t 	createDate;		/* date and time of volume creation */
	u_int32_t 	modifyDate;		/* date and time of last modification */
	u_int32_t 	backupDate;		/* date and time of last backup */
	u_int32_t 	checkedDate;		/* date and time of last disk check */

	u_int32_t 	fileCount;		/* number of files in volume */
	u_int32_t 	folderCount;		/* number of directories in volume */

	u_int32_t 	blockSize;		/* size (in bytes) of allocation blocks */
	u_int32_t 	totalBlocks;		/* number of allocation blocks in volume (includes this header and VBM*/
	u_int32_t 	freeBlocks;		/* number of unused allocation blocks */

	u_int32_t 	nextAllocation;		/* start of next allocation search */
	u_int32_t 	rsrcClumpSize;		/* default resource fork clump size */
	u_int32_t 	dataClumpSize;		/* default data fork clump size */
	u_int32_t 	nextCatalogID;		/* next unused catalog node ID */

	u_int32_t 	writeCount;		/* volume write count */
	u_int64_t 	encodingsBitmap;	/* which encodings have been use  on this volume */

	u_int8_t 	finderInfo[32];		/* information used by the Finder */

	HFSPlusForkData	 allocationFile;	/* allocation bitmap file */
	HFSPlusForkData  extentsFile;		/* extents B-tree file */
	HFSPlusForkData  catalogFile;		/* catalog B-tree file */
	HFSPlusForkData  attributesFile;	/* extended attributes B-tree file */
	HFSPlusForkData	 startupFile;		/* boot file (secondary loader) */
} __attribute__((aligned(2), packed));
typedef struct HFSPlusVolumeHeader HFSPlusVolumeHeader;


/* B-tree structures */

enum BTreeKeyLimits{
	kMaxKeyLength	= 520
};

union BTreeKey{
	u_int8_t	length8;
	u_int16_t	length16;
	u_int8_t	rawData [kMaxKeyLength+2];
};
typedef union BTreeKey BTreeKey;

/* BTNodeDescriptor -- Every B-tree node starts with these fields. */
struct BTNodeDescriptor {
	u_int32_t	fLink;			/* next node at this level*/
	u_int32_t 	bLink;			/* previous node at this level*/
	int8_t 		kind;			/* kind of node (leaf, index, header, map)*/
	u_int8_t 	height;			/* zero for header, map; child is one more than parent*/
	u_int16_t 	numRecords;		/* number of records in this node*/
	u_int16_t 	reserved;		/* reserved - initialized as zero */
} __attribute__((aligned(2), packed));
typedef struct BTNodeDescriptor BTNodeDescriptor;

/* Constants for BTNodeDescriptor kind */
enum {
	kBTLeafNode	= -1,
	kBTIndexNode	= 0,
	kBTHeaderNode	= 1,
	kBTMapNode	= 2
};

/* BTHeaderRec -- The first record of a B-tree header node */
struct BTHeaderRec {
	u_int16_t	treeDepth;		/* maximum height (usually leaf nodes) */
	u_int32_t 	rootNode;		/* node number of root node */
	u_int32_t 	leafRecords;		/* number of leaf records in all leaf nodes */
	u_int32_t 	firstLeafNode;		/* node number of first leaf node */
	u_int32_t 	lastLeafNode;		/* node number of last leaf node */
	u_int16_t 	nodeSize;		/* size of a node, in bytes */
	u_int16_t 	maxKeyLength;		/* reserved */
	u_int32_t 	totalNodes;		/* total number of nodes in tree */
	u_int32_t 	freeNodes;		/* number of unused (free) nodes in tree */
	u_int16_t 	reserved1;		/* unused */
	u_int32_t 	clumpSize;		/* reserved */
	u_int8_t 	btreeType;		/* reserved */
	u_int8_t 	keyCompareType;		/* Key string Comparison Type */
	u_int32_t 	attributes;		/* persistent attributes about the tree */
	u_int32_t 	reserved3[16];		/* reserved */
} __attribute__((aligned(2), packed));
typedef struct BTHeaderRec BTHeaderRec;

/* Constants for BTHeaderRec attributes */
enum {
	kBTBadCloseMask		 = 0x00000001,	/* reserved */
	kBTBigKeysMask		 = 0x00000002,	/* key length field is 16 bits */
	kBTVariableIndexKeysMask = 0x00000004	/* keys in index nodes are variable length */
};


/* Catalog Key Name Comparison Type */
enum {
	kHFSCaseFolding   = 0xCF,  /* case folding (case-insensitive) */
	kHFSBinaryCompare = 0xBC  /* binary compare (case-sensitive) */
};

#include <uuid/uuid.h>

/* JournalInfoBlock - Structure that describes where our journal lives */

// the original size of the reserved field in the JournalInfoBlock was
// 32*sizeof(u_int32_t).  To keep the total size of the structure the 
// same we subtract the size of new fields (currently: ext_jnl_uuid and
// machine_uuid).  If you add additional fields, place them before the
// reserved field and subtract their size in this macro.
//
#define JIB_RESERVED_SIZE  ((32*sizeof(u_int32_t)) - sizeof(uuid_string_t) - 48)

struct JournalInfoBlock {
	u_int32_t	flags;
    	u_int32_t       device_signature[8];  // signature used to locate our device.
	u_int64_t       offset;               // byte offset to the journal on the device
	u_int64_t       size;                 // size in bytes of the journal
	uuid_string_t   ext_jnl_uuid;
	char            machine_serial_num[48];
	char    	reserved[JIB_RESERVED_SIZE];
} __attribute__((aligned(2), packed));
typedef struct JournalInfoBlock JournalInfoBlock;

enum {
    kJIJournalInFSMask          = 0x00000001,
    kJIJournalOnOtherDeviceMask = 0x00000002,
    kJIJournalNeedInitMask      = 0x00000004
};

//
// This the content type uuid for "external journal" GPT 
// partitions.  Each instance of a partition also has a
// uuid that uniquely identifies that instance.
//
#define EXTJNL_CONTENT_TYPE_UUID "4A6F7572-6E61-11AA-AA11-00306543ECAC"


#ifdef __cplusplus
}
#endif

#endif /* __HFS_FORMAT__ */
                                                                                                                                                                                                                            hfs_mount.h                                                                                         0100644 0001750 0001750 00000006236 12567450740 034010  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/hfs                                                                  /*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1997-2002 Apple Computer, Inc. All Rights Reserved
 *
 */

#ifndef _HFS_MOUNT_H_
#define _HFS_MOUNT_H_

#include <sys/appleapiopts.h>

#include <sys/mount.h>
#include <sys/time.h>

/*
 * Arguments to mount HFS-based filesystems
 */

#define OVERRIDE_UNKNOWN_PERMISSIONS 0

#define UNKNOWNUID ((uid_t)99)
#define UNKNOWNGID ((gid_t)99)
#define UNKNOWNPERMISSIONS (S_IRWXU | S_IROTH | S_IXOTH)		/* 705 */

#ifdef __APPLE_API_UNSTABLE
struct hfs_mount_args {
	uid_t	hfs_uid;		/* uid that owns hfs files (standard HFS only) */
	gid_t	hfs_gid;		/* gid that owns hfs files (standard HFS only) */
	mode_t	hfs_mask;		/* mask to be applied for hfs perms  (standard HFS only) */
	u_int32_t hfs_encoding;	/* encoding for this volume (standard HFS only) */
	struct	timezone hfs_timezone;	/* user time zone info (standard HFS only) */
	int		flags;			/* mounting flags, see below */
	int     journal_tbuffer_size;   /* size in bytes of the journal transaction buffer */
	int		journal_flags;          /* flags to pass to journal_open/create */
	int		journal_disable;        /* don't use journaling (potentially dangerous) */
};

#define HFSFSMNT_NOXONFILES	0x1	/* disable execute permissions for files */
#define HFSFSMNT_WRAPPER	0x2	/* mount HFS wrapper (if it exists) */
#define HFSFSMNT_EXTENDED_ARGS  0x4     /* indicates new fields after "flags" are valid */

/*
 * Sysctl values for HFS
 */
#define HFS_ENCODINGBIAS	1	    /* encoding matching CJK bias */
#define HFS_EXTEND_FS		2
#define HFS_ENCODINGHINT	3	    /* guess encoding for string */
#define HFS_ENABLE_JOURNALING   0x082969
#define HFS_DISABLE_JOURNALING  0x031272
#define HFS_GET_JOURNAL_INFO    0x6a6e6c69
#define HFS_SET_PKG_EXTENSIONS  0x121031
#define HFS_REPLAY_JOURNAL	0x6a6e6c72
#define HFS_ENABLE_RESIZE_DEBUG 4	/* enable debug code for volume resizing */

#endif /* __APPLE_API_UNSTABLE */

#endif /* ! _HFS_MOUNT_H_ */
                                                                                                                                                                                                                                                                                                                                                                  hfs_unistr.h                                                                                        0100644 0001750 0001750 00000004052 12567450740 034164  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/hfs                                                                  /*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __HFS_UNISTR__
#define __HFS_UNISTR__

#include <sys/types.h>

/* 
 * hfs_unitstr.h
 *
 * This file contains definition of the unicode string used for HFS Plus 
 * files and folder names, as described by the on-disk format.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif


#ifndef _HFSUNISTR255_DEFINED_
#define _HFSUNISTR255_DEFINED_
/* Unicode strings are used for HFS Plus file and folder names */
struct HFSUniStr255 {
	u_int16_t	length;		/* number of unicode characters */
	u_int16_t	unicode[255];	/* unicode characters */
} __attribute__((aligned(2), packed));
typedef struct HFSUniStr255 HFSUniStr255;
typedef const HFSUniStr255 *ConstHFSUniStr255Param;
#endif /* _HFSUNISTR255_DEFINED_ */


#ifdef __cplusplus
}
#endif


#endif /* __HFS_UNISTR__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      i386/                                                                                               0040755 0001750 0001750 00000000000 12612224742 031532  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      _limits.h                                                                                           0100644 0001750 0001750 00000002055 12567450734 033355  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef	_I386__LIMITS_H_
#define	_I386__LIMITS_H_

#define	__DARWIN_CLK_TCK		100	/* ticks per second */

#endif	/* _I386__LIMITS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   _mcontext.h                                                                                         0100644 0001750 0001750 00000006622 12567450734 033721  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __I386_MCONTEXT_H_
#define __I386_MCONTEXT_H_

#include <sys/appleapiopts.h>
#include <mach/i386/_structs.h>

#ifndef _STRUCT_MCONTEXT32
#if __DARWIN_UNIX03
#define	_STRUCT_MCONTEXT32	struct __darwin_mcontext32
_STRUCT_MCONTEXT32
{
	_STRUCT_X86_EXCEPTION_STATE32	__es;
	_STRUCT_X86_THREAD_STATE32	__ss;
	_STRUCT_X86_FLOAT_STATE32	__fs;
};

#define	_STRUCT_MCONTEXT_AVX32	struct __darwin_mcontext_avx32
_STRUCT_MCONTEXT_AVX32
{
	_STRUCT_X86_EXCEPTION_STATE32	__es;
	_STRUCT_X86_THREAD_STATE32	__ss;
	_STRUCT_X86_AVX_STATE32		__fs;
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_MCONTEXT32	struct mcontext32
_STRUCT_MCONTEXT32
{
	_STRUCT_X86_EXCEPTION_STATE32	es;
	_STRUCT_X86_THREAD_STATE32	ss;
	_STRUCT_X86_FLOAT_STATE32	fs;
};

#define	_STRUCT_MCONTEXT_AVX32	struct mcontext_avx32
_STRUCT_MCONTEXT_AVX32
{
	_STRUCT_X86_EXCEPTION_STATE32	es;
	_STRUCT_X86_THREAD_STATE32	ss;
	_STRUCT_X86_AVX_STATE32		fs;
};

#endif /* __DARWIN_UNIX03 */
#endif /* _STRUCT_MCONTEXT32 */

#ifndef _STRUCT_MCONTEXT64
#if __DARWIN_UNIX03
#define	_STRUCT_MCONTEXT64	struct __darwin_mcontext64
_STRUCT_MCONTEXT64
{
	_STRUCT_X86_EXCEPTION_STATE64	__es;
	_STRUCT_X86_THREAD_STATE64	__ss;
	_STRUCT_X86_FLOAT_STATE64	__fs;
};

#define	_STRUCT_MCONTEXT_AVX64	struct __darwin_mcontext_avx64
_STRUCT_MCONTEXT_AVX64
{
	_STRUCT_X86_EXCEPTION_STATE64	__es;
	_STRUCT_X86_THREAD_STATE64	__ss;
	_STRUCT_X86_AVX_STATE64		__fs;
};

#else /* !__DARWIN_UNIX03 */
#define	_STRUCT_MCONTEXT64	struct mcontext64
_STRUCT_MCONTEXT64
{
	_STRUCT_X86_EXCEPTION_STATE64	es;
	_STRUCT_X86_THREAD_STATE64	ss;
	_STRUCT_X86_FLOAT_STATE64	fs;
};

#define	_STRUCT_MCONTEXT_AVX64	struct mcontext_avx64
_STRUCT_MCONTEXT_AVX64
{
	_STRUCT_X86_EXCEPTION_STATE64	es;
	_STRUCT_X86_THREAD_STATE64	ss;
	_STRUCT_X86_AVX_STATE64		fs;
};

#endif /* __DARWIN_UNIX03 */
#endif /* _STRUCT_MCONTEXT64 */


#ifndef _MCONTEXT_T
#define _MCONTEXT_T
#if defined(__LP64__)
typedef _STRUCT_MCONTEXT64	*mcontext_t;
#define _STRUCT_MCONTEXT _STRUCT_MCONTEXT64
#else
typedef _STRUCT_MCONTEXT32	*mcontext_t;
#define _STRUCT_MCONTEXT	_STRUCT_MCONTEXT32
#endif
#endif /* _MCONTEXT_T */

#endif /* __I386_MCONTEXT_H_ */
                                                                                                              _param.h                                                                                            0100644 0001750 0001750 00000003740 12567450734 033156  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2008 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _I386__PARAM_H_
#define _I386__PARAM_H_

#include <i386/_types.h>

/*
 * Round p (pointer or byte index) up to a correctly-aligned value for all
 * data types (int, long, ...).   The result is unsigned int and must be
 * cast to any desired pointer type.
 */
#define	__DARWIN_ALIGNBYTES	(sizeof(__darwin_size_t) - 1)
#define	__DARWIN_ALIGN(p)	((__darwin_size_t)((char *)(__darwin_size_t)(p) + __DARWIN_ALIGNBYTES) &~ __DARWIN_ALIGNBYTES)

#define      __DARWIN_ALIGNBYTES32     (sizeof(__uint32_t) - 1)
#define       __DARWIN_ALIGN32(p)       ((__darwin_size_t)((char *)(__darwin_size_t)(p) + __DARWIN_ALIGNBYTES32) &~ __DARWIN_ALIGNBYTES32)


#endif /* _I386__PARAM_H_ */
                                _types.h                                                                                            0100644 0001750 0001750 00000010620 12567450734 033215  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef	_BSD_I386__TYPES_H_
#define	_BSD_I386__TYPES_H_

/*
 * This header file contains integer types.  It's intended to also contain
 * flotaing point and other arithmetic types, as needed, later.
 */

#ifdef __GNUC__
typedef __signed char		__int8_t;
#else	/* !__GNUC__ */
typedef char			__int8_t;
#endif	/* !__GNUC__ */
typedef unsigned char		__uint8_t;
typedef	short			__int16_t;
typedef	unsigned short		__uint16_t;
typedef int			__int32_t;
typedef unsigned int		__uint32_t;
typedef long long		__int64_t;
typedef unsigned long long	__uint64_t;

typedef long			__darwin_intptr_t;
typedef unsigned int		__darwin_natural_t;

/*
 * The rune type below is declared to be an ``int'' instead of the more natural
 * ``unsigned long'' or ``long''.  Two things are happening here.  It is not
 * unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
 * it looks like 10646 will be a 31 bit standard.  This means that if your
 * ints cannot hold 32 bits, you will be in trouble.  The reason an int was
 * chosen over a long is that the is*() and to*() routines take ints (says
 * ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
 * here, you lose a bit of ANSI conformance, but your programs will still
 * work.
 *
 * NOTE: rune_t is not covered by ANSI nor other standards, and should not
 * be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
 * rune_t must be the same type.  Also wint_t must be no narrower than
 * wchar_t, and should also be able to hold all members of the largest
 * character set plus one extra value (WEOF). wint_t must be at least 16 bits.
 */

typedef int			__darwin_ct_rune_t;	/* ct_rune_t */

/*
 * mbstate_t is an opaque object to keep conversion state, during multibyte
 * stream conversions.  The content must not be referenced by user programs.
 */
typedef union {
	char		__mbstate8[128];
	long long	_mbstateL;			/* for alignment */
} __mbstate_t;

typedef __mbstate_t		__darwin_mbstate_t;	/* mbstate_t */

#if defined(__PTRDIFF_TYPE__)
typedef __PTRDIFF_TYPE__	__darwin_ptrdiff_t;	/* ptr1 - ptr2 */
#elif defined(__LP64__)
typedef long			__darwin_ptrdiff_t;	/* ptr1 - ptr2 */
#else
typedef int			__darwin_ptrdiff_t;	/* ptr1 - ptr2 */
#endif /* __GNUC__ */

#if defined(__SIZE_TYPE__)
typedef __SIZE_TYPE__		__darwin_size_t;	/* sizeof() */
#else
typedef unsigned long		__darwin_size_t;	/* sizeof() */
#endif

#if (__GNUC__ > 2)
typedef __builtin_va_list	__darwin_va_list;	/* va_list */
#else
typedef void *			__darwin_va_list;	/* va_list */
#endif

#if defined(__WCHAR_TYPE__)
typedef __WCHAR_TYPE__		__darwin_wchar_t;	/* wchar_t */
#else
typedef __darwin_ct_rune_t	__darwin_wchar_t;	/* wchar_t */
#endif

typedef __darwin_wchar_t	__darwin_rune_t;	/* rune_t */

#if defined(__WINT_TYPE__)
typedef __WINT_TYPE__		__darwin_wint_t;	/* wint_t */
#else
typedef __darwin_ct_rune_t	__darwin_wint_t;	/* wint_t */
#endif

typedef unsigned long		__darwin_clock_t;	/* clock() */
typedef __uint32_t		__darwin_socklen_t;	/* socklen_t (duh) */
typedef long			__darwin_ssize_t;	/* byte count or error */
typedef long			__darwin_time_t;	/* time() */

#endif	/* _BSD_I386__TYPES_H_ */
                                                                                                                asm.h                                                                                               0100644 0001750 0001750 00000025210 12567450733 032472  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#ifndef	_I386_ASM_H_
#define	_I386_ASM_H_

#ifdef _KERNEL
#include <gprof.h>
#endif	/* _KERNEL */

#if	defined(MACH_KERNEL) || defined(_KERNEL)
#include <gprof.h>
#endif	/* MACH_KERNEL || _KERNEL */

#if defined(__i386__)

#define S_PC	 (%esp)
#define S_ARG0	 4(%esp)
#define S_ARG1	 8(%esp)
#define S_ARG2	12(%esp)
#define S_ARG3	16(%esp)
#define S_ARG4	20(%esp)

#define FRAME	pushl %ebp; movl %esp, %ebp
#define EMARF	leave

#define B_LINK	 (%ebp)
#define B_PC	 4(%ebp)
#define B_ARG0	 8(%ebp)
#define B_ARG1	12(%ebp)
#define B_ARG2	16(%ebp)
#define B_ARG3	20(%ebp)

#elif defined(__x86_64__)

#define S_PC	 (%rsp)

#define FRAME	pushq %rbp; movq %rsp, %rbp
#define EMARF	leave

#define B_LINK	 (%rbp)
#define B_PC	 8(%rbp)

#else
#error unsupported architecture
#endif

/* There is another definition of ALIGN for .c sources */
#ifdef ASSEMBLER
#define ALIGN 4,0x90
#endif /* ASSEMBLER */

#ifndef FALIGN
#define FALIGN ALIGN
#endif

#define LB(x,n) n
#if	__STDC__
#ifndef __NO_UNDERSCORES__
#define	LCL(x)	L ## x
#define EXT(x) _ ## x
#define LEXT(x) _ ## x ## :
#else
#define	LCL(x)	.L ## x
#define EXT(x) x
#define LEXT(x) x ## :
#endif
#define LBc(x,n) n ## :
#define LBb(x,n) n ## b
#define LBf(x,n) n ## f
#else /* __STDC__ */
#ifndef __NO_UNDERSCORES__
#define LCL(x) L/**/x
#define EXT(x) _/**/x
#define LEXT(x) _/**/x/**/:
#else /* __NO_UNDERSCORES__ */
#define	LCL(x)	.L/**/x
#define EXT(x) x
#define LEXT(x) x/**/:
#endif /* __NO_UNDERSCORES__ */
#define LBc(x,n) n/**/:
#define LBb(x,n) n/**/b
#define LBf(x,n) n/**/f
#endif /* __STDC__ */

#define SVC .byte 0x9a; .long 0; .word 0x7

#define RPC_SVC .byte 0x9a; .long 0; .word 0xf

#define String	.asciz
#define Value	.word
#define Times(a,b) (a*b)
#define Divide(a,b) (a/b)

#define INB	inb	%dx, %al
#define OUTB	outb	%al, %dx
#define INL	inl	%dx, %eax
#define OUTL	outl	%eax, %dx

#define data16	.byte 0x66
#define addr16	.byte 0x67

#if !GPROF
#define MCOUNT

#elif defined(__SHARED__)
#define MCOUNT		; .data;\
			.align ALIGN;\
			LBc(x, 8) .long 0;\
			.text;\
			Gpush;\
			Gload;\
			leal Gotoff(LBb(x,8)),%edx;\
			Egaddr(%eax,_mcount_ptr);\
			Gpop;\
			call *(%eax);

#else	/* !GPROF, !__SHARED__ */
#define MCOUNT		; call mcount;
#endif /* GPROF */

#ifdef __ELF__
#define ELF_FUNC(x)	.type x,@function
#define ELF_DATA(x)	.type x,@object
#define ELF_SIZE(x,s)	.size x,s
#else
#define ELF_FUNC(x)
#define ELF_DATA(x)
#define ELF_SIZE(x,s)
#endif

#define	Entry(x)	.globl EXT(x); ELF_FUNC(EXT(x)); .align FALIGN; LEXT(x)
#define	ENTRY(x)	Entry(x) MCOUNT
#define	ENTRY2(x,y)	.globl EXT(x); .globl EXT(y); \
			ELF_FUNC(EXT(x)); ELF_FUNC(EXT(y)); \
			.align FALIGN; LEXT(x); LEXT(y) \
			MCOUNT
#if __STDC__
#define	ASENTRY(x) 	.globl x; .align FALIGN; x ## : ELF_FUNC(x) MCOUNT
#else
#define	ASENTRY(x) 	.globl x; .align FALIGN; x: ELF_FUNC(x) MCOUNT
#endif /* __STDC__ */

#define	DATA(x)		.globl EXT(x); ELF_DATA(EXT(x)); .align ALIGN; LEXT(x)

#define End(x)		ELF_SIZE(x,.-x)
#define END(x)		End(EXT(x))
#define ENDDATA(x)	END(x)
#define Enddata(x)	End(x)

/*
 * ELF shared library accessor macros.
 * Gpush saves the %ebx register used for the GOT address
 * Gpop pops %ebx if we need a GOT
 * Gload loads %ebx with the GOT address if shared libraries are used
 * Gcall calls an external function.
 * Gotoff allows you to reference local labels.
 * Gotoff2 allows you to reference local labels with an index reg.
 * Gotoff3 allows you to reference local labels with an index reg & size.
 * Gaddr loads up a register with an address of an external item.
 * Gstack is the number of bytes that Gpush pushes on the stack.
 *
 * Varients of the above with E or L prefixes do EXT(name) or LCL(name)
 * respectively.
 */

#ifndef __SHARED__
#define Gpush
#define Gpop
#define Gload
#define Gcall(func)		call func
#define Gotoff(lab)		lab
#define Gotoff2(l,r)		l(r)
#define Gotoff3(l,r,s)		l(,r,s)
#define Gaddr(to,lab)		movl $lab,to
#define Gcmp(lab,reg)		cmpl $lab,reg
#define Gmemload(lab,reg)	movl lab,reg
#define Gmemstore(reg,lab,tmp)	movl reg,lab
#define Gstack			0

#else
#ifdef __ELF__			/* ELF shared libraries */
#define Gpush			pushl %ebx
#define Gpop			popl %ebx
#define Gload			call 9f; 9: popl %ebx; addl $_GLOBAL_OFFSET_TABLE_+[.-9b],%ebx
#define Gcall(func)		call EXT(func)@PLT
#define Gotoff(lab)		lab@GOTOFF(%ebx)
#define Gotoff2(l,r)		l@GOTOFF(%ebx,r)
#define Gotoff3(l,r,s)		l@GOTOFF(%ebx,r,s)
#define Gaddr(to,lab)		movl lab@GOT(%ebx),to
#define Gcmp(lab,reg)		cmpl reg,lab@GOT(%ebx)
#define Gmemload(lab,reg)	movl lab@GOT(%ebx),reg; movl (reg),reg
#define Gmemstore(reg,lab,tmp)	movl lab@GOT(%ebx),tmp; movl reg,(tmp)
#define Gstack			4

#else				/* ROSE shared libraries */
#define Gpush
#define Gpop
#define Gload
#define Gcall(func)		call *9f; .data; .align ALIGN; 9: .long func; .text
#define Gotoff(lab)		lab
#define Gotoff2(l,r)		l(r)
#define Gotoff3(l,r,s)		l(,r,s)
#define Gaddr(to,lab)		movl 9f,to; .data; .align ALIGN; 9: .long lab; .text
#define Gcmp(lab,reg)		cmpl reg,9f; .data; .align ALIGN; 9: .long lab; .text
#define Gmemload(lab,reg)	movl 9f,reg; movl (reg),reg; .data; .align ALIGN; 9: .long lab; .text
#define Gmemstore(reg,lab,tmp)	movl 9f,tmp; movl reg,(tmp); .data; .align ALIGN; 9: .long lab; .text
#define Gstack			0
#endif	/* __ELF__ */
#endif	/* __SHARED__ */

/* Egotoff is not provided, since external symbols should not use @GOTOFF
   relocations.  */
#define Egcall(func)		Gcall(EXT(func))
#define Egaddr(to,lab)		Gaddr(to,EXT(lab))
#define Egcmp(lab,reg)		Gcmp(EXT(lab),reg)
#define Egmemload(lab,reg)	Gmemload(EXT(lab),reg)
#define Egmemstore(reg,lab,tmp)	Gmemstore(reg,EXT(lab),tmp)

#define Lgotoff(lab)		Gotoff(LCL(lab))
#define Lgotoff2(l,r)		Gotoff2(LCL(l),r)
#define Lgotoff3(l,r,s)		Gotoff3(LCL(l),r,s)
#define Lgcmp(lab,reg)		Gcmp(LCL(lab),reg)
#define Lgmemload(lab,reg)	movl Lgotoff(lab),reg
#define Lgmemstore(reg,lab,tmp)	movl reg,Lgotoff(lab)

#ifndef ASSEMBLER
/* These defines are here for .c files that wish to reference global symbols
 * within __asm__ statements. 
 */
#ifndef __NO_UNDERSCORES__
#define CC_SYM_PREFIX "_"
#else
#define CC_SYM_PREFIX ""
#endif /* __NO_UNDERSCORES__ */
#endif /* ASSEMBLER */

/*
 * The following macros make calls into C code.
 * They dynamically align the stack to 16 bytes.
 */
#if defined(__i386__)
/*
 * Arguments are moved (not pushed) onto the correctly aligned stack.
 * NOTE: ESI is destroyed in the process, and hence cannot
 * be directly used as a parameter. Users of this macro must
 * independently preserve ESI (a non-volatile) if the routine is
 * intended to be called from C, for instance.
 */

#define CCALL(fn)			\
	movl	%esp, %esi		;\
	andl	$0xFFFFFFF0, %esp	;\
	call	EXT(fn)			;\
	movl	%esi, %esp

#define CCALL1(fn, arg1)		\
	movl	%esp, %esi		;\
	subl	$4, %esp		;\
	andl	$0xFFFFFFF0, %esp	;\
	movl	arg1, (%esp)		;\
	call	EXT(fn)			;\
	movl	%esi, %esp

#define CCALL2(fn, arg1, arg2)		\
	movl	%esp, %esi		;\
	subl	$8, %esp		;\
	andl	$0xFFFFFFF0, %esp	;\
	movl	arg2, 4(%esp)		;\
	movl	arg1, (%esp)		;\
	call	EXT(fn)			;\
	movl	%esi, %esp

/* This variant exists to permit adjustment of the stack by "dtrace" */
#define CCALL1WITHSP(fn, arg1)		\
	movl	%esp, %esi		;\
	subl	$12, %esp		;\
	andl	$0xFFFFFFF0, %esp	;\
	movl	%esi, 8(%esp)		;\
	leal	8(%esp), %esi		;\
	movl	%esi, 4(%esp)		;\
	movl	arg1, (%esp)		;\
	call	EXT(fn)			;\
	movl	8(%esp), %esp

/*
 * CCALL5 is used for callee functions with 3 arguments but
 * where arg2 (a3:a2) and arg3 (a5:a4) are 64-bit values.
 */
#define CCALL5(fn, a1, a2, a3, a4, a5)	\
	movl	%esp, %esi		;\
	subl	$20, %esp		;\
	andl	$0xFFFFFFF0, %esp	;\
	movl	a5, 16(%esp)		;\
	movl	a4, 12(%esp)		;\
	movl	a3,  8(%esp)		;\
	movl	a2,  4(%esp)		;\
	movl	a1,  (%esp)		;\
	call	EXT(fn)			;\
	movl	%esi, %esp

#elif defined(__x86_64__)

/* This variant exists to permit adjustment of the stack by "dtrace" */
#define CCALLWITHSP(fn)				 \
	mov	%rsp, %r12			;\
	sub	$8, %rsp			;\
	and	$0xFFFFFFFFFFFFFFF0, %rsp	;\
	mov	%r12, (%rsp)			;\
	leaq	(%rsp), %rsi			;\
	call	EXT(fn)				;\
	mov	(%rsp), %rsp
	
#define CCALL(fn)				 \
	mov	%rsp, %r12			;\
	and	$0xFFFFFFFFFFFFFFF0, %rsp	;\
	call	EXT(fn)				;\
	mov	%r12, %rsp

#define CCALL1(fn, arg1) 			 \
	mov	arg1, %rdi 			;\
	CCALL(fn)

#define CCALL2(fn, arg1, arg2)		 	 \
	mov	arg1, %rdi 			;\
	mov	arg2, %rsi 			;\
	CCALL(fn)

#define CCALL3(fn, arg1, arg2, arg3) 		 \
	mov	arg1, %rdi 			;\
	mov	arg2, %rsi 			;\
	mov	arg3, %rdx 			;\
	CCALL(fn)

#else
#error unsupported architecture
#endif

#endif /* _I386_ASM_H_ */
                                                                                                                                                                                                                                                                                                                                                                                        cpuid.h                                                                                             0100644 0001750 0001750 00000036401 12567450733 033022  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

/*
 * x86 CPU identification
 *
 */

#ifndef _MACHINE_CPUID_H_
#define _MACHINE_CPUID_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_PRIVATE

#define	CPUID_VID_INTEL		"GenuineIntel"
#define	CPUID_VID_AMD		"AuthenticAMD"

#define CPUID_VMM_ID_VMWARE		"VMwareVMware"
#define CPUID_VMM_ID_PARALLELS	"Parallels\0\0\0"

#define CPUID_STRING_UNKNOWN    "Unknown CPU Typ"

#define _Bit(n)			(1ULL << n)
#define _HBit(n)		(1ULL << ((n)+32))

/*
 * The CPUID_FEATURE_XXX values define 64-bit values
 * returned in %ecx:%edx to a CPUID request with %eax of 1: 
 */
#define CPUID_FEATURE_FPU       _Bit(0)   /* Floating point unit on-chip */
#define CPUID_FEATURE_VME       _Bit(1)   /* Virtual Mode Extension */
#define CPUID_FEATURE_DE        _Bit(2)   /* Debugging Extension */
#define CPUID_FEATURE_PSE       _Bit(3)   /* Page Size Extension */
#define CPUID_FEATURE_TSC       _Bit(4)   /* Time Stamp Counter */
#define CPUID_FEATURE_MSR       _Bit(5)   /* Model Specific Registers */
#define CPUID_FEATURE_PAE       _Bit(6)   /* Physical Address Extension */
#define CPUID_FEATURE_MCE       _Bit(7)   /* Machine Check Exception */
#define CPUID_FEATURE_CX8       _Bit(8)   /* CMPXCHG8B */
#define CPUID_FEATURE_APIC      _Bit(9)   /* On-chip APIC */
#define CPUID_FEATURE_SEP       _Bit(11)  /* Fast System Call */
#define CPUID_FEATURE_MTRR      _Bit(12)  /* Memory Type Range Register */
#define CPUID_FEATURE_PGE       _Bit(13)  /* Page Global Enable */
#define CPUID_FEATURE_MCA       _Bit(14)  /* Machine Check Architecture */
#define CPUID_FEATURE_CMOV      _Bit(15)  /* Conditional Move Instruction */
#define CPUID_FEATURE_PAT       _Bit(16)  /* Page Attribute Table */
#define CPUID_FEATURE_PSE36     _Bit(17)  /* 36-bit Page Size Extension */
#define CPUID_FEATURE_PSN       _Bit(18)  /* Processor Serial Number */
#define CPUID_FEATURE_CLFSH     _Bit(19)  /* CLFLUSH Instruction supported */
#define CPUID_FEATURE_DS        _Bit(21)  /* Debug Store */
#define CPUID_FEATURE_ACPI      _Bit(22)  /* Thermal monitor and Clock Ctrl */
#define CPUID_FEATURE_MMX       _Bit(23)  /* MMX supported */
#define CPUID_FEATURE_FXSR      _Bit(24)  /* Fast floating pt save/restore */
#define CPUID_FEATURE_SSE       _Bit(25)  /* Streaming SIMD extensions */
#define CPUID_FEATURE_SSE2      _Bit(26)  /* Streaming SIMD extensions 2 */
#define CPUID_FEATURE_SS        _Bit(27)  /* Self-Snoop */
#define CPUID_FEATURE_HTT       _Bit(28)  /* Hyper-Threading Technology */
#define CPUID_FEATURE_TM        _Bit(29)  /* Thermal Monitor (TM1) */
#define CPUID_FEATURE_PBE       _Bit(31)  /* Pend Break Enable */
 
#define CPUID_FEATURE_SSE3      _HBit(0)  /* Streaming SIMD extensions 3 */
#define CPUID_FEATURE_PCLMULQDQ _HBit(1)  /* PCLMULQDQ instruction */
#define CPUID_FEATURE_DTES64    _HBit(2)  /* 64-bit DS layout */
#define CPUID_FEATURE_MONITOR   _HBit(3)  /* Monitor/mwait */
#define CPUID_FEATURE_DSCPL     _HBit(4)  /* Debug Store CPL */
#define CPUID_FEATURE_VMX       _HBit(5)  /* VMX */
#define CPUID_FEATURE_SMX       _HBit(6)  /* SMX */
#define CPUID_FEATURE_EST       _HBit(7)  /* Enhanced SpeedsTep (GV3) */
#define CPUID_FEATURE_TM2       _HBit(8)  /* Thermal Monitor 2 */
#define CPUID_FEATURE_SSSE3     _HBit(9)  /* Supplemental SSE3 instructions */
#define CPUID_FEATURE_CID       _HBit(10) /* L1 Context ID */
#define CPUID_FEATURE_SEGLIM64  _HBit(11) /* 64-bit segment limit checking */
#define CPUID_FEATURE_FMA       _HBit(12) /* Fused-Multiply-Add support */
#define CPUID_FEATURE_CX16      _HBit(13) /* CmpXchg16b instruction */
#define CPUID_FEATURE_xTPR      _HBit(14) /* Send Task PRiority msgs */
#define CPUID_FEATURE_PDCM      _HBit(15) /* Perf/Debug Capability MSR */

#define CPUID_FEATURE_PCID      _HBit(17) /* ASID-PCID support */
#define CPUID_FEATURE_DCA       _HBit(18) /* Direct Cache Access */
#define CPUID_FEATURE_SSE4_1    _HBit(19) /* Streaming SIMD extensions 4.1 */
#define CPUID_FEATURE_SSE4_2    _HBit(20) /* Streaming SIMD extensions 4.2 */
#define CPUID_FEATURE_x2APIC    _HBit(21) /* Extended APIC Mode */
#define CPUID_FEATURE_MOVBE     _HBit(22) /* MOVBE instruction */
#define CPUID_FEATURE_POPCNT    _HBit(23) /* POPCNT instruction */
#define CPUID_FEATURE_TSCTMR    _HBit(24) /* TSC deadline timer */
#define CPUID_FEATURE_AES       _HBit(25) /* AES instructions */
#define CPUID_FEATURE_XSAVE     _HBit(26) /* XSAVE instructions */
#define CPUID_FEATURE_OSXSAVE   _HBit(27) /* XGETBV/XSETBV instructions */
#define CPUID_FEATURE_AVX1_0	_HBit(28) /* AVX 1.0 instructions */
#define CPUID_FEATURE_F16C	_HBit(29) /* Float16 convert instructions */
#define CPUID_FEATURE_RDRAND	_HBit(30) /* RDRAND instruction */
#define CPUID_FEATURE_VMM       _HBit(31) /* VMM (Hypervisor) present */

/*
 * Leaf 7, subleaf 0 additional features.
 * Bits returned in %ebx:%ecx to a CPUID request with {%eax,%ecx} of (0x7,0x0}:
 */
#define CPUID_LEAF7_FEATURE_RDWRFSGS _Bit(0)	/* FS/GS base read/write */
#define CPUID_LEAF7_FEATURE_TSCOFF   _Bit(1)	/* TSC thread offset */
#define CPUID_LEAF7_FEATURE_BMI1     _Bit(3)	/* Bit Manipulation Instrs, set 1 */
#define CPUID_LEAF7_FEATURE_HLE      _Bit(4)	/* Hardware Lock Elision*/
#define CPUID_LEAF7_FEATURE_AVX2     _Bit(5)	/* AVX2 Instructions */
#define CPUID_LEAF7_FEATURE_SMEP     _Bit(7)	/* Supervisor Mode Execute Protect */
#define CPUID_LEAF7_FEATURE_BMI2     _Bit(8)	/* Bit Manipulation Instrs, set 2 */
#define CPUID_LEAF7_FEATURE_ERMS     _Bit(9)	/* Enhanced Rep Movsb/Stosb */
#define CPUID_LEAF7_FEATURE_INVPCID  _Bit(10)	/* INVPCID intruction, TDB */
#define CPUID_LEAF7_FEATURE_RTM      _Bit(11)	/* RTM */
#define CPUID_LEAF7_FEATURE_RDSEED   _Bit(18)	/* RDSEED Instruction */
#define CPUID_LEAF7_FEATURE_ADX      _Bit(19)	/* ADX Instructions */
#define CPUID_LEAF7_FEATURE_SMAP     _Bit(20)	/* Supervisor Mode Access Protect */

/*
 * The CPUID_EXTFEATURE_XXX values define 64-bit values
 * returned in %ecx:%edx to a CPUID request with %eax of 0x80000001: 
 */
#define CPUID_EXTFEATURE_SYSCALL   _Bit(11)	/* SYSCALL/sysret */
#define CPUID_EXTFEATURE_XD	   _Bit(20)	/* eXecute Disable */

#define CPUID_EXTFEATURE_1GBPAGE   _Bit(26)	/* 1GB pages */
#define CPUID_EXTFEATURE_RDTSCP	   _Bit(27)	/* RDTSCP */
#define CPUID_EXTFEATURE_EM64T	   _Bit(29)	/* Extended Mem 64 Technology */

#define CPUID_EXTFEATURE_LAHF	   _HBit(0)	/* LAFH/SAHF instructions */
#define CPUID_EXTFEATURE_LZCNT     _HBit(5)	/* LZCNT instruction */
#define CPUID_EXTFEATURE_PREFETCHW _HBit(8)	/* PREFETCHW instruction */

/*
 * The CPUID_EXTFEATURE_XXX values define 64-bit values
 * returned in %ecx:%edx to a CPUID request with %eax of 0x80000007: 
 */
#define CPUID_EXTFEATURE_TSCI      _Bit(8)	/* TSC Invariant */

/*
 * CPUID_X86_64_H_FEATURE_SUBSET and CPUID_X86_64_H_LEAF7_FEATURE_SUBSET
 * indicate the bitmask of features that must be present before the system
 * is eligible to run the "x86_64h" "Haswell feature subset" slice.
 */
#define CPUID_X86_64_H_FEATURE_SUBSET ( CPUID_FEATURE_FMA    | \
                                        CPUID_FEATURE_SSE4_2 | \
                                        CPUID_FEATURE_MOVBE  | \
                                        CPUID_FEATURE_POPCNT | \
                                        CPUID_FEATURE_AVX1_0   \
                                      )

#define CPUID_X86_64_H_EXTFEATURE_SUBSET ( CPUID_EXTFEATURE_LZCNT \
                                         )

#define CPUID_X86_64_H_LEAF7_FEATURE_SUBSET ( CPUID_LEAF7_FEATURE_BMI1 | \
                                              CPUID_LEAF7_FEATURE_AVX2 | \
                                              CPUID_LEAF7_FEATURE_BMI2   \
                                            )

#define	CPUID_CACHE_SIZE	16	/* Number of descriptor values */

#define CPUID_MWAIT_EXTENSION	_Bit(0)	/* enumeration of WMAIT extensions */
#define CPUID_MWAIT_BREAK	_Bit(1)	/* interrupts are break events	   */

#define CPUID_MODEL_YONAH		0x0E
#define CPUID_MODEL_MEROM		0x0F
#define CPUID_MODEL_PENRYN		0x17
#define CPUID_MODEL_NEHALEM		0x1A
#define CPUID_MODEL_FIELDS		0x1E	/* Lynnfield, Clarksfield */
#define CPUID_MODEL_DALES		0x1F	/* Havendale, Auburndale */
#define CPUID_MODEL_NEHALEM_EX		0x2E
#define CPUID_MODEL_DALES_32NM		0x25	/* Clarkdale, Arrandale */
#define CPUID_MODEL_WESTMERE		0x2C	/* Gulftown, Westmere-EP/-WS */
#define CPUID_MODEL_WESTMERE_EX		0x2F
#define CPUID_MODEL_SANDYBRIDGE		0x2A
#define CPUID_MODEL_JAKETOWN		0x2D
#define CPUID_MODEL_IVYBRIDGE		0x3A
#define CPUID_MODEL_IVYBRIDGE_EP	0x3E
#define CPUID_MODEL_CRYSTALWELL		0x46
#define CPUID_MODEL_HASWELL		0x3C
#define CPUID_MODEL_HASWELL_EP		0x3F
#define CPUID_MODEL_HASWELL_ULT		0x45
#define CPUID_MODEL_BROADWELL		0x3D
#define CPUID_MODEL_BROADWELL_ULX	0x3D
#define CPUID_MODEL_BROADWELL_ULT	0x3D
#define CPUID_MODEL_BRYSTALWELL		0x47

#define CPUID_VMM_FAMILY_UNKNOWN	0x0
#define CPUID_VMM_FAMILY_VMWARE		0x1
#define CPUID_VMM_FAMILY_PARALLELS	0x2

#ifndef ASSEMBLER
#include <stdint.h>
#include <mach/mach_types.h>
#include <kern/kern_types.h>
#include <mach/machine.h>


typedef enum { eax, ebx, ecx, edx } cpuid_register_t;
static inline void
cpuid(uint32_t *data)
{
	__asm__ volatile ("cpuid"
		: "=a" (data[eax]),
		  "=b" (data[ebx]),
		  "=c" (data[ecx]),
		  "=d" (data[edx])
		: "a"  (data[eax]),
		  "b"  (data[ebx]),
		  "c"  (data[ecx]),
		  "d"  (data[edx]));
}

static inline void
do_cpuid(uint32_t selector, uint32_t *data)
{
	__asm__ volatile ("cpuid"
		: "=a" (data[0]),
		  "=b" (data[1]),
		  "=c" (data[2]),
		  "=d" (data[3])
		: "a"(selector),
		  "b" (0),
		  "c" (0),
		  "d" (0));
}

/*
 * Cache ID descriptor structure, used to parse CPUID leaf 2.
 * Note: not used in kernel.
 */
typedef enum { Lnone, L1I, L1D, L2U, L3U, LCACHE_MAX } cache_type_t ; 
typedef struct {
	unsigned char	value;          /* Descriptor value */
	cache_type_t 	type;           /* Cache type */
	unsigned int 	size;           /* Cache size */
	unsigned int 	linesize;       /* Cache line size */
	const char	*description;   /* Cache description */
} cpuid_cache_desc_t;  

#define CACHE_DESC(value,type,size,linesize,text) \
	{ value, type, size, linesize, text }

/* Monitor/mwait Leaf: */
typedef struct {
	uint32_t	linesize_min;
	uint32_t	linesize_max;
	uint32_t	extensions;
	uint32_t	sub_Cstates;
} cpuid_mwait_leaf_t;

/* Thermal and Power Management Leaf: */
typedef struct {
	boolean_t	sensor;
	boolean_t	dynamic_acceleration;
	boolean_t	invariant_APIC_timer;
	boolean_t	core_power_limits;
	boolean_t	fine_grain_clock_mod;
	boolean_t	package_thermal_intr;
	uint32_t	thresholds;
	boolean_t	ACNT_MCNT;
	boolean_t	hardware_feedback;
	boolean_t	energy_policy;
} cpuid_thermal_leaf_t;


/* XSAVE Feature Leaf: */
typedef struct {
	uint32_t	extended_state[4];	/* eax .. edx */
} cpuid_xsave_leaf_t;


/* Architectural Performance Monitoring Leaf: */
typedef struct {
	uint8_t		version;
	uint8_t		number;
	uint8_t		width;
	uint8_t		events_number;
	uint32_t	events;
	uint8_t		fixed_number;
	uint8_t		fixed_width;
} cpuid_arch_perf_leaf_t;

/* Physical CPU info - this is exported out of the kernel (kexts), so be wary of changes */
typedef struct {
	char		cpuid_vendor[16];
	char		cpuid_brand_string[48];
	const char	*cpuid_model_string;

	cpu_type_t	cpuid_type;	/* this is *not* a cpu_type_t in our <mach/machine.h> */
	uint8_t		cpuid_family;
	uint8_t		cpuid_model;
	uint8_t		cpuid_extmodel;
	uint8_t		cpuid_extfamily;
	uint8_t		cpuid_stepping;
	uint64_t	cpuid_features;
	uint64_t	cpuid_extfeatures;
	uint32_t	cpuid_signature;
	uint8_t   	cpuid_brand; 
	uint8_t		cpuid_processor_flag;
	
	uint32_t	cache_size[LCACHE_MAX];
	uint32_t	cache_linesize;

	uint8_t		cache_info[64];    /* list of cache descriptors */

	uint32_t	cpuid_cores_per_package;
	uint32_t	cpuid_logical_per_package;
	uint32_t	cache_sharing[LCACHE_MAX];
	uint32_t	cache_partitions[LCACHE_MAX];

	cpu_type_t	cpuid_cpu_type;			/* <mach/machine.h> */
	cpu_subtype_t	cpuid_cpu_subtype;		/* <mach/machine.h> */	

	/* Per-vendor info */
	cpuid_mwait_leaf_t	cpuid_mwait_leaf;	
#define cpuid_mwait_linesize_max	cpuid_mwait_leaf.linesize_max
#define cpuid_mwait_linesize_min	cpuid_mwait_leaf.linesize_min
#define cpuid_mwait_extensions		cpuid_mwait_leaf.extensions
#define cpuid_mwait_sub_Cstates		cpuid_mwait_leaf.sub_Cstates
	cpuid_thermal_leaf_t	cpuid_thermal_leaf;
	cpuid_arch_perf_leaf_t	cpuid_arch_perf_leaf;
	uint32_t	unused[4];			/* cpuid_xsave_leaf */

	/* Cache details: */
	uint32_t	cpuid_cache_linesize;
	uint32_t	cpuid_cache_L2_associativity;
	uint32_t	cpuid_cache_size;

	/* Virtual and physical address aize: */
	uint32_t	cpuid_address_bits_physical;
	uint32_t	cpuid_address_bits_virtual;

	uint32_t	cpuid_microcode_version;

	/* Numbers of tlbs per processor [i|d, small|large, level0|level1] */
	uint32_t	cpuid_tlb[2][2][2];
			#define	TLB_INST	0
			#define	TLB_DATA	1
			#define	TLB_SMALL	0
			#define	TLB_LARGE	1
	uint32_t	cpuid_stlb;

	uint32_t	core_count;
	uint32_t	thread_count;

	/* Max leaf ids available from CPUID */
	uint32_t	cpuid_max_basic;
	uint32_t	cpuid_max_ext;

	/* Family-specific info links */
	uint32_t		cpuid_cpufamily;
	cpuid_mwait_leaf_t	*cpuid_mwait_leafp;	
	cpuid_thermal_leaf_t	*cpuid_thermal_leafp;
	cpuid_arch_perf_leaf_t	*cpuid_arch_perf_leafp;
	cpuid_xsave_leaf_t	*cpuid_xsave_leafp;
	uint64_t		cpuid_leaf7_features;
	cpuid_xsave_leaf_t	cpuid_xsave_leaf[2];
} i386_cpu_info_t;


#ifdef __cplusplus
extern "C" {
#endif

/*
 * External declarations
 */
extern cpu_type_t	cpuid_cputype(void);
extern cpu_subtype_t	cpuid_cpusubtype(void);
extern void		cpuid_cpu_display(const char *);
extern void		cpuid_feature_display(const char *);
extern void		cpuid_extfeature_display(const char *);
extern char *		cpuid_get_feature_names(uint64_t, char *, unsigned);
extern char *		cpuid_get_extfeature_names(uint64_t, char *, unsigned);
extern char *		cpuid_get_leaf7_feature_names(uint64_t, char *, unsigned);

extern uint64_t		cpuid_features(void);
extern uint64_t		cpuid_extfeatures(void);
extern uint64_t		cpuid_leaf7_features(void);
extern uint32_t		cpuid_family(void);
extern uint32_t		cpuid_cpufamily(void);
	
extern i386_cpu_info_t	*cpuid_info(void);
extern void		cpuid_set_info(void);


#ifdef __cplusplus
}
#endif

#endif /* ASSEMBLER */

#endif /* __APPLE_API_PRIVATE */
#endif /* _MACHINE_CPUID_H_ */
                                                                                                                                                                                                                                                               eflags.h                                                                                            0100644 0001750 0001750 00000007036 12567450734 033162  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

#ifndef	_I386_EFLAGS_H_
#define	_I386_EFLAGS_H_

/*
 *	i386 flags register
 */

#ifndef EFL_CF
#define	EFL_CF		0x00000001		/* carry */
#define	EFL_PF		0x00000004		/* parity of low 8 bits */
#define	EFL_AF		0x00000010		/* carry out of bit 3 */
#define	EFL_ZF		0x00000040		/* zero */
#define	EFL_SF		0x00000080		/* sign */
#define	EFL_TF		0x00000100		/* trace trap */
#define	EFL_IF		0x00000200		/* interrupt enable */
#define	EFL_DF		0x00000400		/* direction */
#define	EFL_OF		0x00000800		/* overflow */
#define	EFL_IOPL	0x00003000		/* IO privilege level: */
#define	EFL_IOPL_KERNEL	0x00000000			/* kernel */
#define	EFL_IOPL_USER	0x00003000			/* user */
#define	EFL_NT		0x00004000		/* nested task */
#define	EFL_RF		0x00010000		/* resume without tracing */
#define	EFL_VM		0x00020000		/* virtual 8086 mode */
#define EFL_AC		0x00040000		/* alignment check */
#define EFL_VIF		0x00080000		/* virtual interrupt flag */
#define EFL_VIP		0x00100000		/* virtual interrupt pending */
#define EFL_ID		0x00200000		/* cpuID instruction */
#endif

#define EFL_CLR		0xfff88028
#define EFL_SET		0x00000002

#define	EFL_USER_SET	(EFL_IF)
#define	EFL_USER_CLEAR	(EFL_IOPL|EFL_NT|EFL_RF)

#endif	/* _I386_EFLAGS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  endian.h                                                                                            0100644 0001750 0001750 00000010061 12567450734 033147  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1987, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)endian.h	8.1 (Berkeley) 6/11/93
 */

#ifndef _I386__ENDIAN_H_
#define	_I386__ENDIAN_H_

#include <sys/cdefs.h>
/*
 * Define _NOQUAD if the compiler does NOT support 64-bit integers.
 */
/* #define _NOQUAD */

/*
 * Define the order of 32-bit words in 64-bit words.
 */
#define _QUAD_HIGHWORD 1
#define _QUAD_LOWWORD 0

/*
 * Definitions for byte order, according to byte significance from low
 * address to high.
 */
#define	__DARWIN_LITTLE_ENDIAN	1234	/* LSB first: i386, vax */
#define	__DARWIN_BIG_ENDIAN	4321	/* MSB first: 68000, ibm, net */
#define	__DARWIN_PDP_ENDIAN	3412	/* LSB first in word, MSW first in long */

#define	__DARWIN_BYTE_ORDER	__DARWIN_LITTLE_ENDIAN


#define	LITTLE_ENDIAN	__DARWIN_LITTLE_ENDIAN
#define	BIG_ENDIAN	__DARWIN_BIG_ENDIAN
#define	PDP_ENDIAN	__DARWIN_PDP_ENDIAN

#define	BYTE_ORDER	__DARWIN_BYTE_ORDER

#include <sys/_endian.h>

#endif /* !_I386__ENDIAN_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               limits.h                                                                                            0100644 0001750 0001750 00000011146 12567450734 033217  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)limits.h	8.3 (Berkeley) 1/4/94
 */

#ifndef _I386_LIMITS_H_
#define _I386_LIMITS_H_

#include <sys/cdefs.h>
#include <i386/_limits.h>

#define	CHAR_BIT	8		/* number of bits in a char */
#define	MB_LEN_MAX	6		/* Allow 31 bit UTF2 */

#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
#define	CLK_TCK		__DARWIN_CLK_TCK	/* ticks per second */
#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * According to ANSI (section 2.2.4.2), the values below must be usable by
 * #if preprocessing directives.  Additionally, the expression must have the
 * same type as would an expression that is an object of the corresponding
 * type converted according to the integral promotions.  The subtraction for
 * INT_MIN and LONG_MIN is so the value is not unsigned; 2147483648 is an
 * unsigned int for 32-bit two's complement ANSI compilers (section 3.1.3.2).
 * These numbers work for pcc as well.  The UINT_MAX and ULONG_MAX values
 * are written as hex so that GCC will be quiet about large integer constants.
 */
#define	SCHAR_MAX	127		/* min value for a signed char */
#define	SCHAR_MIN	(-128)		/* max value for a signed char */

#define	UCHAR_MAX	255		/* max value for an unsigned char */
#define	CHAR_MAX	127		/* max value for a char */
#define	CHAR_MIN	(-128)		/* min value for a char */

#define	USHRT_MAX	65535		/* max value for an unsigned short */
#define	SHRT_MAX	32767		/* max value for a short */
#define	SHRT_MIN	(-32768)	/* min value for a short */

#define	UINT_MAX	0xffffffff	/* max value for an unsigned int */
#define	INT_MAX		2147483647	/* max value for an int */
#define	INT_MIN		(-2147483647-1)	/* min value for an int */

#ifdef __LP64__
#define	ULONG_MAX	0xffffffffffffffffUL	/* max unsigned long */
#define	LONG_MAX	0x7fffffffffffffffL	/* max signed long */
#define	LONG_MIN	(-0x7fffffffffffffffL-1) /* min signed long */
#else /* !__LP64__ */
#define	ULONG_MAX	0xffffffffUL	/* max unsigned long */
#define	LONG_MAX	2147483647L	/* max signed long */
#define	LONG_MIN	(-2147483647L-1) /* min signed long */
#endif /* __LP64__ */

#define	ULLONG_MAX	0xffffffffffffffffULL	/* max unsigned long long */
#define	LLONG_MAX	0x7fffffffffffffffLL	/* max signed long long */
#define	LLONG_MIN	(-0x7fffffffffffffffLL-1) /* min signed long long */

#if !defined(_ANSI_SOURCE)
#ifdef __LP64__
#define LONG_BIT	64
#else /* !__LP64__ */
#define LONG_BIT	32
#endif /* __LP64__ */
#define	SSIZE_MAX	LONG_MAX	/* max value for a ssize_t */
#define WORD_BIT	32

#if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)
#define	SIZE_T_MAX	ULONG_MAX	/* max value for a size_t */

#define	UQUAD_MAX	ULLONG_MAX
#define	QUAD_MAX	LLONG_MAX
#define	QUAD_MIN	LLONG_MIN

#endif /* (!_POSIX_C_SOURCE && !_XOPEN_SOURCE) || _DARWIN_C_SOURCE */
#endif /* !_ANSI_SOURCE */

#endif /* _I386_LIMITS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                          locks.h                                                                                             0100644 0001750 0001750 00000003147 12567450734 033033  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2004-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef	_I386_LOCKS_H_
#define	_I386_LOCKS_H_

#include <sys/appleapiopts.h>
#include <kern/kern_types.h>


typedef	struct __lck_spin_t__	lck_spin_t;

typedef struct __lck_mtx_t__		lck_mtx_t;
typedef struct __lck_mtx_ext_t__	lck_mtx_ext_t;

typedef struct __lck_rw_t__	lck_rw_t;


#endif	/* _I386_LOCKS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                         machine_routines.h                                                                                  0100644 0001750 0001750 00000004055 12567450734 035253  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_I386_MACHINE_ROUTINES_H_
#define	_I386_MACHINE_ROUTINES_H_

#include <mach/mach_types.h>
#include <mach/boolean.h>
#include <kern/kern_types.h>
#include <pexpert/pexpert.h>

#include <sys/cdefs.h>
#include <sys/appleapiopts.h>

__BEGIN_DECLS



/* Get Interrupts Enabled */
boolean_t ml_get_interrupts_enabled(void);

/* Set Interrupts Enabled */
boolean_t ml_set_interrupts_enabled(boolean_t enable);

/* Check if running at interrupt context */
boolean_t ml_at_interrupt_context(void);

/* Zero bytes starting at a physical address */
void bzero_phys(
	addr64_t phys_address,
	uint32_t length);

/* Bytes available on current stack */
vm_offset_t ml_stack_remaining(void);

__END_DECLS

#endif /* _I386_MACHINE_ROUTINES_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   param.h                                                                                             0100644 0001750 0001750 00000014424 12567450734 033020  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)param.h	8.1 (Berkeley) 4/4/95
 */

/*
 * Machine dependent constants for Intel 386.
 */

#ifndef _I386_PARAM_H_
#define _I386_PARAM_H_

#include <i386/_param.h>

/*
 * Round p (pointer or byte index) up to a correctly-aligned value for all
 * data types (int, long, ...).   The result is unsigned int and must be
 * cast to any desired pointer type.
 */
#define	ALIGNBYTES	__DARWIN_ALIGNBYTES
#define	ALIGN(p)	__DARWIN_ALIGN(p)

#define	NBPG		4096		/* bytes/page */
#define	PGOFSET		(NBPG-1)	/* byte offset into page */
#define	PGSHIFT		12		/* LOG2(NBPG) */

#define	DEV_BSIZE	512
#define	DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
#define BLKDEV_IOSIZE	2048
#define	MAXPHYS		(128 * 1024)	/* max raw I/O transfer size */

#define	CLSIZE		1
#define	CLSIZELOG2	0

/*
 * Constants related to network buffer management.
 * MCLBYTES must be no larger than CLBYTES (the software page size), and,
 * on machines that exchange pages of input or output buffers with mbuf
 * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
 * of the hardware page size.
 */
#define	MSIZESHIFT	8			/* 256 */
#define	MSIZE		(1 << MSIZESHIFT)	/* size of an mbuf */
#define	MCLSHIFT	11			/* 2048 */
#define	MCLBYTES	(1 << MCLSHIFT)		/* size of an mbuf cluster */
#define	MBIGCLSHIFT	12			/* 4096 */
#define	MBIGCLBYTES	(1 << MBIGCLSHIFT)	/* size of a big cluster */
#define	M16KCLSHIFT	14			/* 16384 */
#define	M16KCLBYTES	(1 << M16KCLSHIFT)	/* size of a jumbo cluster */

#define	MCLOFSET	(MCLBYTES - 1)
#ifndef NMBCLUSTERS
#define	NMBCLUSTERS	((1024 * 1024) / MCLBYTES)	/* cl map size: 1MB */
#endif

/*
 * Some macros for units conversion
 */
/* Core clicks (NeXT_page_size bytes) to segments and vice versa */
#define	ctos(x)	(x)
#define	stoc(x)	(x)

/* Core clicks (4096 bytes) to disk blocks */
#define	ctod(x)	((x)<<(PGSHIFT-DEV_BSHIFT))
#define	dtoc(x)	((x)>>(PGSHIFT-DEV_BSHIFT))
#define	dtob(x)	((x)<<DEV_BSHIFT)

/* clicks to bytes */
#define	ctob(x)	((x)<<PGSHIFT)

/* bytes to clicks */
#define	btoc(x)	(((unsigned)(x)+(NBPG-1))>>PGSHIFT)

#ifdef __APPLE__
#define  btodb(bytes, devBlockSize)         \
        ((unsigned)(bytes) / devBlockSize)
#define  dbtob(db, devBlockSize)            \
        ((unsigned)(db) * devBlockSize)
#else
#define	btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
	((unsigned)(bytes) >> DEV_BSHIFT)
#define	dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
	((unsigned)(db) << DEV_BSHIFT)
#endif

/*
 * Map a ``block device block'' to a file system block.
 * This should be device dependent, and will be if we
 * add an entry to cdevsw/bdevsw for that purpose.
 * For now though just use DEV_BSIZE.
 */
#define	bdbtofsb(bn)	((bn) / (BLKDEV_IOSIZE/DEV_BSIZE))

/*
 * Macros to decode (and encode) processor status word.
 */
#define STATUS_WORD(rpl, ipl)	(((ipl) << 8) | (rpl))
#define	USERMODE(x)		(((x) & 3) == 3)
#define	BASEPRI(x)		(((x) & (255 << 8)) == 0)


#define	DELAY(n) delay(n)


#endif /* _I386_PARAM_H_ */
                                                                                                                                                                                                                                            proc_reg.h                                                                                          0100644 0001750 0001750 00000045174 12567450734 033526  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* CMU_ENDHIST */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
 */

/*
 * Processor registers for i386 and i486.
 */
#ifndef	_I386_PROC_REG_H_
#define	_I386_PROC_REG_H_

/*
 * Model Specific Registers
 */
#define	MSR_P5_TSC		0x10	/* Time Stamp Register */
#define	MSR_P5_CESR		0x11	/* Control and Event Select Register */
#define	MSR_P5_CTR0		0x12	/* Counter #0 */
#define	MSR_P5_CTR1		0x13	/* Counter #1 */

#define	MSR_P5_CESR_PC		0x0200	/* Pin Control */
#define	MSR_P5_CESR_CC		0x01C0	/* Counter Control mask */
#define	MSR_P5_CESR_ES		0x003F	/* Event Control mask */

#define	MSR_P5_CESR_SHIFT	16		/* Shift to get Counter 1 */
#define	MSR_P5_CESR_MASK	(MSR_P5_CESR_PC|\
				 MSR_P5_CESR_CC|\
				 MSR_P5_CESR_ES) /* Mask Counter */

#define	MSR_P5_CESR_CC_CLOCK	0x0100	/* Clock Counting (otherwise Event) */
#define	MSR_P5_CESR_CC_DISABLE	0x0000	/* Disable counter */
#define	MSR_P5_CESR_CC_CPL012	0x0040	/* Count if the CPL == 0, 1, 2 */
#define	MSR_P5_CESR_CC_CPL3	0x0080	/* Count if the CPL == 3 */
#define	MSR_P5_CESR_CC_CPL	0x00C0	/* Count regardless of the CPL */

#define	MSR_P5_CESR_ES_DATA_READ       0x000000	/* Data Read */
#define	MSR_P5_CESR_ES_DATA_WRITE      0x000001	/* Data Write */
#define	MSR_P5_CESR_ES_DATA_RW	       0x101000	/* Data Read or Write */
#define	MSR_P5_CESR_ES_DATA_TLB_MISS   0x000010	/* Data TLB Miss */
#define	MSR_P5_CESR_ES_DATA_READ_MISS  0x000011	/* Data Read Miss */
#define	MSR_P5_CESR_ES_DATA_WRITE_MISS 0x000100	/* Data Write Miss */
#define	MSR_P5_CESR_ES_DATA_RW_MISS    0x101001	/* Data Read or Write Miss */
#define	MSR_P5_CESR_ES_HIT_EM	       0x000101	/* Write (hit) to M|E state */
#define	MSR_P5_CESR_ES_DATA_CACHE_WB   0x000110	/* Cache lines written back */
#define	MSR_P5_CESR_ES_EXTERNAL_SNOOP  0x000111	/* External Snoop */
#define	MSR_P5_CESR_ES_CACHE_SNOOP_HIT 0x001000	/* Data cache snoop hits */
#define	MSR_P5_CESR_ES_MEM_ACCESS_PIPE 0x001001	/* Mem. access in both pipes */
#define	MSR_P5_CESR_ES_BANK_CONFLICTS  0x001010	/* Bank conflicts */
#define	MSR_P5_CESR_ES_MISALIGNED      0x001011	/* Misaligned Memory or I/O */
#define	MSR_P5_CESR_ES_CODE_READ       0x001100	/* Code Read */
#define	MSR_P5_CESR_ES_CODE_TLB_MISS   0x001101	/* Code TLB miss */
#define	MSR_P5_CESR_ES_CODE_CACHE_MISS 0x001110	/* Code Cache miss */
#define	MSR_P5_CESR_ES_SEGMENT_LOADED  0x001111	/* Any segment reg. loaded */
#define	MSR_P5_CESR_ES_BRANCHE	       0x010010	/* Branches */
#define	MSR_P5_CESR_ES_BTB_HIT	       0x010011	/* BTB Hits */
#define	MSR_P5_CESR_ES_BRANCHE_BTB     0x010100	/* Taken branch or BTB Hit */
#define	MSR_P5_CESR_ES_PIPELINE_FLUSH  0x010101	/* Pipeline Flushes */
#define	MSR_P5_CESR_ES_INSTRUCTION     0x010110	/* Instruction executed */
#define	MSR_P5_CESR_ES_INSTRUCTION_V   0x010111	/* Inst. executed (v-pipe) */
#define	MSR_P5_CESR_ES_BUS_CYCLE       0x011000	/* Clocks while bus cycle */
#define	MSR_P5_CESR_ES_FULL_WRITE_BUF  0x011001	/* Clocks while full wrt buf. */
#define	MSR_P5_CESR_ES_DATA_MEM_READ   0x011010	/* Pipeline waiting for read */
#define	MSR_P5_CESR_ES_WRITE_EM        0x011011	/* Stall on write E|M state */
#define	MSR_P5_CESR_ES_LOCKED_CYCLE    0x011100	/* Locked bus cycles */
#define	MSR_P5_CESR_ES_IO_CYCLE	       0x011101	/* I/O Read or Write cycles */
#define	MSR_P5_CESR_ES_NON_CACHEABLE   0x011110	/* Non-cacheable Mem. read */
#define	MSR_P5_CESR_ES_AGI	       0x011111	/* Stall because of AGI */
#define	MSR_P5_CESR_ES_FLOP	       0x100010	/* Floating Point operations */
#define	MSR_P5_CESR_ES_BREAK_DR0       0x100011	/* Breakpoint matches on DR0 */
#define	MSR_P5_CESR_ES_BREAK_DR1       0x100100	/* Breakpoint matches on DR1 */
#define	MSR_P5_CESR_ES_BREAK_DR2       0x100101	/* Breakpoint matches on DR2 */
#define	MSR_P5_CESR_ES_BREAK_DR3       0x100110	/* Breakpoint matches on DR3 */
#define	MSR_P5_CESR_ES_HARDWARE_IT     0x100111	/* Hardware interrupts */

/*
 * CR0
 */
#define	CR0_PG	0x80000000	/*	 Enable paging */
#define	CR0_CD	0x40000000	/* i486: Cache disable */
#define	CR0_NW	0x20000000	/* i486: No write-through */
#define	CR0_AM	0x00040000	/* i486: Alignment check mask */
#define	CR0_WP	0x00010000	/* i486: Write-protect kernel access */
#define	CR0_NE	0x00000020	/* i486: Handle numeric exceptions */
#define	CR0_ET	0x00000010	/*	 Extension type is 80387 */
				/*	 (not official) */
#define	CR0_TS	0x00000008	/*	 Task switch */
#define	CR0_EM	0x00000004	/*	 Emulate coprocessor */
#define	CR0_MP	0x00000002	/*	 Monitor coprocessor */
#define	CR0_PE	0x00000001	/*	 Enable protected mode */

/*
 * CR4
 */
#define CR4_SMAP	0x00200000	/* Supervisor-Mode Access Protect */
#define CR4_SMEP	0x00100000	/* Supervisor-Mode Execute Protect */
#define CR4_OSXSAVE	0x00040000	/* OS supports XSAVE */
#define CR4_PCIDE	0x00020000	/* PCID Enable */
#define CR4_RDWRFSGS	0x00010000	/* RDWRFSGS Enable */
#define CR4_SMXE	0x00004000	/* Enable SMX operation */
#define CR4_VMXE	0x00002000	/* Enable VMX operation */
#define CR4_OSXMM	0x00000400	/* SSE/SSE2 exception support in OS */
#define CR4_OSFXS	0x00000200	/* SSE/SSE2 OS supports FXSave */
#define CR4_PCE		0x00000100	/* Performance-Monitor Count Enable */
#define CR4_PGE		0x00000080	/* Page Global Enable */
#define	CR4_MCE		0x00000040	/* Machine Check Exceptions */
#define CR4_PAE		0x00000020	/* Physical Address Extensions */
#define	CR4_PSE		0x00000010	/* Page Size Extensions */
#define	CR4_DE		0x00000008	/* Debugging Extensions */
#define	CR4_TSD		0x00000004	/* Time Stamp Disable */
#define	CR4_PVI		0x00000002	/* Protected-mode Virtual Interrupts */
#define	CR4_VME		0x00000001	/* Virtual-8086 Mode Extensions */

/*
 * XCR0 - XFEATURE_ENABLED_MASK (a.k.a. XFEM) register
 */
#define XCR0_X87 	(1ULL << 0)	/* x87, FPU/MMX (always set) */
#define XCR0_SSE	(1ULL << 1)	/* SSE supported by XSAVE/XRESTORE */
#define	XCR0_YMM	(1ULL << 2)	/* YMM state available */
#define XFEM_X87	XCR0_X87
#define XFEM_SSE	XCR0_SSE
#define	XFEM_YMM	XCR0_YMM
#define XCR0 (0)

#define	PMAP_PCID_PRESERVE (1ULL << 63)
#define	PMAP_PCID_MASK (0xFFF)

#ifndef	ASSEMBLER

#include <sys/cdefs.h>
#include <stdint.h>

__BEGIN_DECLS

#define	set_ts() set_cr0(get_cr0() | CR0_TS)

static inline uint16_t get_es(void)
{
	uint16_t es;
	__asm__ volatile("mov %%es, %0" : "=r" (es));
	return es;
}

static inline void set_es(uint16_t es)
{
	__asm__ volatile("mov %0, %%es" : : "r" (es));
}

static inline uint16_t get_ds(void)
{
	uint16_t ds;
	__asm__ volatile("mov %%ds, %0" : "=r" (ds));
	return ds;
}

static inline void set_ds(uint16_t ds)
{
	__asm__ volatile("mov %0, %%ds" : : "r" (ds));
}

static inline uint16_t get_fs(void)
{
	uint16_t fs;
	__asm__ volatile("mov %%fs, %0" : "=r" (fs));
	return fs;
}

static inline void set_fs(uint16_t fs)
{
	__asm__ volatile("mov %0, %%fs" : : "r" (fs));
}

static inline uint16_t get_gs(void)
{
	uint16_t gs;
	__asm__ volatile("mov %%gs, %0" : "=r" (gs));
	return gs;
}

static inline void set_gs(uint16_t gs)
{
	__asm__ volatile("mov %0, %%gs" : : "r" (gs));
}

static inline uint16_t get_ss(void)
{
	uint16_t ss;
	__asm__ volatile("mov %%ss, %0" : "=r" (ss));
	return ss;
}

static inline void set_ss(uint16_t ss)
{
	__asm__ volatile("mov %0, %%ss" : : "r" (ss));
}

static inline uintptr_t get_cr0(void)
{
	uintptr_t cr0; 
	__asm__ volatile("mov %%cr0, %0" : "=r" (cr0));
	return(cr0);
}

static inline void set_cr0(uintptr_t value)
{
	__asm__ volatile("mov %0, %%cr0" : : "r" (value));
}

static inline uintptr_t get_cr2(void)
{
	uintptr_t cr2;
	__asm__ volatile("mov %%cr2, %0" : "=r" (cr2));
	return(cr2);
}

static inline uintptr_t get_cr3_raw(void)
{
	uintptr_t cr3;
	__asm__ volatile("mov %%cr3, %0" : "=r" (cr3));
	return(cr3);
}

static inline void set_cr3_raw(uintptr_t value)
{
	__asm__ volatile("mov %0, %%cr3" : : "r" (value));
}

static inline uintptr_t get_cr3_base(void)
{
	uintptr_t cr3;
	__asm__ volatile("mov %%cr3, %0" : "=r" (cr3));
	return(cr3 & ~(0xFFFULL));
}

static inline void set_cr3_composed(uintptr_t base, uint16_t pcid, uint32_t preserve)
{
	__asm__ volatile("mov %0, %%cr3" : : "r" (base | pcid | ( ( (uint64_t)preserve) << 63) ) );
}

static inline uintptr_t get_cr4(void)
{
	uintptr_t cr4;
	__asm__ volatile("mov %%cr4, %0" : "=r" (cr4));
	return(cr4);
}

static inline void set_cr4(uintptr_t value)
{
	__asm__ volatile("mov %0, %%cr4" : : "r" (value));
}

static inline uintptr_t x86_get_flags(void)
{
	uintptr_t erflags;
	__asm__ volatile("pushf; pop	%0" :  "=r" (erflags));
	return erflags;
}

static inline void clear_ts(void)
{
	__asm__ volatile("clts");
}

static inline unsigned short get_tr(void)
{
	unsigned short seg; 
	__asm__ volatile("str %0" : "=rm" (seg));
	return(seg);
}

static inline void set_tr(unsigned int seg)
{
	__asm__ volatile("ltr %0" : : "rm" ((unsigned short)(seg)));
}

static inline unsigned short sldt(void)
{
	unsigned short seg;
	__asm__ volatile("sldt %0" : "=rm" (seg));
	return(seg);
}

static inline void lldt(unsigned int seg)
{
	__asm__ volatile("lldt %0" : : "rm" ((unsigned short)(seg)));
}

static inline void lgdt(uintptr_t *desc)
{
	__asm__ volatile("lgdt %0" : : "m" (*desc));
}

static inline void lidt(uintptr_t *desc)
{
	__asm__ volatile("lidt %0" : : "m" (*desc));
}

static inline void swapgs(void)
{
	__asm__ volatile("swapgs");
}


static inline void wbinvd(void)
{
	__asm__ volatile("wbinvd");
}

static inline void invlpg(uintptr_t addr)
{
	__asm__  volatile("invlpg (%0)" :: "r" (addr) : "memory");
}

static inline void clac(void)
{
	__asm__  volatile("clac");
}

static inline void stac(void)
{
	__asm__  volatile("stac");
}

/*
 * Access to machine-specific registers (available on 586 and better only)
 * Note: the rd* operations modify the parameters directly (without using
 * pointer indirection), this allows gcc to optimize better
 */

#define rdmsr(msr,lo,hi) \
	__asm__ volatile("rdmsr" : "=a" (lo), "=d" (hi) : "c" (msr))

#define wrmsr(msr,lo,hi) \
	__asm__ volatile("wrmsr" : : "c" (msr), "a" (lo), "d" (hi))

#define rdtsc(lo,hi) \
	__asm__ volatile("lfence; rdtsc; lfence" : "=a" (lo), "=d" (hi))

#define rdtsc_nofence(lo,hi) \
	__asm__ volatile("rdtsc" : "=a" (lo), "=d" (hi))

#define write_tsc(lo,hi) wrmsr(0x10, lo, hi)

#define rdpmc(counter,lo,hi) \
	__asm__ volatile("rdpmc" : "=a" (lo), "=d" (hi) : "c" (counter))


static inline uint64_t rdpmc64(uint32_t pmc)
{
	uint32_t lo=0, hi=0;
	rdpmc(pmc, lo, hi);
	return (((uint64_t)hi) << 32) | ((uint64_t)lo);
}

static inline uint64_t rdmsr64(uint32_t msr)
{
	uint32_t lo=0, hi=0;
	rdmsr(msr, lo, hi);
	return (((uint64_t)hi) << 32) | ((uint64_t)lo);
}

static inline void wrmsr64(uint32_t msr, uint64_t val)
{
	wrmsr(msr, (val & 0xFFFFFFFFUL), ((val >> 32) & 0xFFFFFFFFUL));
}

static inline uint64_t rdtsc64(void)
{
	uint64_t lo, hi;
	rdtsc(lo, hi);
	return ((hi) << 32) | (lo);
}

static inline uint64_t rdtscp64(uint32_t *aux)
{
	uint64_t lo, hi;
	__asm__ volatile("rdtscp; mov %%ecx, %1"
					 : "=a" (lo), "=d" (hi), "=m" (*aux)
					 :
					 : "ecx");
	return ((hi) << 32) | (lo);
}


/*
 * rdmsr_carefully() returns 0 when the MSR has been read successfully,
 * or non-zero (1) if the MSR does not exist.
 * The implementation is in locore.s.
 */
extern int rdmsr_carefully(uint32_t msr, uint32_t *lo, uint32_t *hi);
__END_DECLS

#endif	/* ASSEMBLER */

#define MSR_IA32_P5_MC_ADDR			0
#define MSR_IA32_P5_MC_TYPE			1
#define MSR_IA32_PLATFORM_ID			0x17
#define MSR_IA32_EBL_CR_POWERON			0x2a

#define MSR_IA32_APIC_BASE			0x1b
#define     MSR_IA32_APIC_BASE_BSP		    (1<<8)
#define     MSR_IA32_APIC_BASE_EXTENDED		    (1<<10)
#define     MSR_IA32_APIC_BASE_ENABLE		    (1<<11)
#define     MSR_IA32_APIC_BASE_BASE		    (0xfffff<<12)

#define MSR_CORE_THREAD_COUNT			0x35

#define MSR_IA32_FEATURE_CONTROL		0x3a
#define     MSR_IA32_FEATCTL_LOCK		    (1<<0)
#define     MSR_IA32_FEATCTL_VMXON_SMX		    (1<<1)
#define     MSR_IA32_FEATCTL_VMXON		    (1<<2)
#define     MSR_IA32_FEATCTL_CSTATE_SMI		    (1<<16)

#define MSR_IA32_UPDT_TRIG			0x79
#define MSR_IA32_BIOS_SIGN_ID			0x8b
#define MSR_IA32_UCODE_WRITE			MSR_IA32_UPDT_TRIG
#define MSR_IA32_UCODE_REV			MSR_IA32_BIOS_SIGN_ID

#define MSR_IA32_PERFCTR0			0xc1
#define MSR_IA32_PERFCTR1			0xc2
#define MSR_IA32_PERFCTR3			0xc3
#define MSR_IA32_PERFCTR4			0xc4

#define MSR_PLATFORM_INFO			0xce

#define MSR_IA32_MPERF				0xE7
#define MSR_IA32_APERF				0xE8

#define MSR_IA32_BBL_CR_CTL			0x119

#define MSR_IA32_SYSENTER_CS			0x174
#define MSR_IA32_SYSENTER_ESP			0x175
#define MSR_IA32_SYSENTER_EIP			0x176

#define MSR_IA32_MCG_CAP			0x179
#define MSR_IA32_MCG_STATUS			0x17a
#define MSR_IA32_MCG_CTL			0x17b

#define MSR_IA32_EVNTSEL0			0x186
#define MSR_IA32_EVNTSEL1			0x187
#define MSR_IA32_EVNTSEL2			0x188
#define MSR_IA32_EVNTSEL3			0x189

#define MSR_FLEX_RATIO				0x194
#define MSR_IA32_PERF_STS			0x198
#define MSR_IA32_PERF_CTL			0x199
#define MSR_IA32_CLOCK_MODULATION		0x19a

#define MSR_IA32_MISC_ENABLE			0x1a0


#define MSR_IA32_PACKAGE_THERM_STATUS		0x1b1
#define MSR_IA32_PACKAGE_THERM_INTERRUPT	0x1b2

#define MSR_IA32_DEBUGCTLMSR			0x1d9
#define MSR_IA32_LASTBRANCHFROMIP		0x1db
#define MSR_IA32_LASTBRANCHTOIP			0x1dc
#define MSR_IA32_LASTINTFROMIP			0x1dd
#define MSR_IA32_LASTINTTOIP			0x1de

#define MSR_IA32_CR_PAT 			0x277	

#define MSR_IA32_MTRRCAP			0xfe
#define MSR_IA32_MTRR_DEF_TYPE			0x2ff
#define MSR_IA32_MTRR_PHYSBASE(n)		(0x200 + 2*(n))
#define MSR_IA32_MTRR_PHYSMASK(n)		(0x200 + 2*(n) + 1)
#define MSR_IA32_MTRR_FIX64K_00000		0x250
#define MSR_IA32_MTRR_FIX16K_80000		0x258
#define MSR_IA32_MTRR_FIX16K_A0000		0x259
#define MSR_IA32_MTRR_FIX4K_C0000		0x268
#define MSR_IA32_MTRR_FIX4K_C8000		0x269
#define MSR_IA32_MTRR_FIX4K_D0000		0x26a
#define MSR_IA32_MTRR_FIX4K_D8000		0x26b
#define MSR_IA32_MTRR_FIX4K_E0000		0x26c
#define MSR_IA32_MTRR_FIX4K_E8000		0x26d
#define MSR_IA32_MTRR_FIX4K_F0000		0x26e
#define MSR_IA32_MTRR_FIX4K_F8000		0x26f

#define MSR_IA32_PERF_FIXED_CTR0		0x309

#define MSR_IA32_PERF_FIXED_CTR_CTRL		0x38D
#define MSR_IA32_PERF_GLOBAL_STATUS		0x38E
#define MSR_IA32_PERF_GLOBAL_CTRL		0x38F
#define MSR_IA32_PERF_GLOBAL_OVF_CTRL	0x390

#define MSR_IA32_PKG_C3_RESIDENCY		0x3F8
#define MSR_IA32_PKG_C6_RESIDENCY		0x3F9
#define MSR_IA32_PKG_C7_RESIDENCY		0x3FA

#define MSR_IA32_CORE_C3_RESIDENCY 		0x3FC
#define MSR_IA32_CORE_C6_RESIDENCY 		0x3FD
#define MSR_IA32_CORE_C7_RESIDENCY 		0x3FE

#define MSR_IA32_MC0_CTL			0x400
#define MSR_IA32_MC0_STATUS			0x401
#define MSR_IA32_MC0_ADDR			0x402
#define MSR_IA32_MC0_MISC			0x403

#define MSR_IA32_VMX_BASE					0x480
#define MSR_IA32_VMX_BASIC					MSR_IA32_VMX_BASE
#define MSR_IA32_VMX_PINBASED_CTLS			MSR_IA32_VMX_BASE+1
#define MSR_IA32_VMX_PROCBASED_CTLS			MSR_IA32_VMX_BASE+2
#define MSR_IA32_VMX_EXIT_CTLS				MSR_IA32_VMX_BASE+3
#define MSR_IA32_VMX_ENTRY_CTLS				MSR_IA32_VMX_BASE+4
#define MSR_IA32_VMX_MISC					MSR_IA32_VMX_BASE+5
#define MSR_IA32_VMX_CR0_FIXED0				MSR_IA32_VMX_BASE+6
#define MSR_IA32_VMX_CR0_FIXED1				MSR_IA32_VMX_BASE+7
#define MSR_IA32_VMX_CR4_FIXED0				MSR_IA32_VMX_BASE+8
#define MSR_IA32_VMX_CR4_FIXED1				MSR_IA32_VMX_BASE+9
#define MSR_IA32_VMX_VMCS_ENUM				MSR_IA32_VMX_BASE+10
#define MSR_IA32_VMX_PROCBASED_CTLS2		MSR_IA32_VMX_BASE+11
#define MSR_IA32_VMX_EPT_VPID_CAP			MSR_IA32_VMX_BASE+12
#define		MSR_IA32_VMX_EPT_VPID_CAP_AD_SHIFT	21
#define MSR_IA32_VMX_TRUE_PINBASED_CTLS		MSR_IA32_VMX_BASE+13
#define MSR_IA32_VMX_TRUE_PROCBASED_CTLS	MSR_IA32_VMX_BASE+14
#define MSR_IA32_VMX_TRUE_VMEXIT_CTLS		MSR_IA32_VMX_BASE+15
#define MSR_IA32_VMX_TRUE_VMENTRY_CTLS		MSR_IA32_VMX_BASE+16
#define MSR_IA32_VMX_VMFUNC					MSR_IA32_VMX_BASE+17

#define MSR_IA32_DS_AREA			0x600

#define MSR_IA32_PKG_POWER_SKU_UNIT		0x606
#define MSR_IA32_PKG_C2_RESIDENCY		0x60D
#define MSR_IA32_PKG_ENERGY_STATUS		0x611
#define MSR_IA32_DDR_ENERGY_STATUS		0x619
#define MSR_IA32_LLC_FLUSHED_RESIDENCY_TIMER	0x61D
#define MSR_IA32_RING_PERF_STATUS		0x621

#define MSR_IA32_PKG_C8_RESIDENCY		0x630
#define MSR_IA32_PKG_C9_RESIDENCY		0x631
#define MSR_IA32_PKG_C10_RESIDENCY		0x632

#define MSR_IA32_PP0_ENERGY_STATUS		0x639
#define MSR_IA32_PP1_ENERGY_STATUS		0x641

#define MSR_IA32_IA_PERF_LIMIT_REASONS		0x690
#define MSR_IA32_GT_PERF_LIMIT_REASONS		0x6B0

#define MSR_IA32_TSC_DEADLINE			0x6e0

#define	MSR_IA32_EFER				0xC0000080
#define	    MSR_IA32_EFER_SCE			    0x00000001
#define	    MSR_IA32_EFER_LME			    0x00000100
#define	    MSR_IA32_EFER_LMA			    0x00000400
#define     MSR_IA32_EFER_NXE			    0x00000800

#define	MSR_IA32_STAR				0xC0000081
#define	MSR_IA32_LSTAR				0xC0000082
#define	MSR_IA32_CSTAR				0xC0000083
#define	MSR_IA32_FMASK				0xC0000084

#define MSR_IA32_FS_BASE			0xC0000100
#define MSR_IA32_GS_BASE			0xC0000101
#define MSR_IA32_KERNEL_GS_BASE			0xC0000102
#define MSR_IA32_TSC_AUX			0xC0000103

#endif	/* _I386_PROC_REG_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                    profile.h                                                                                           0100644 0001750 0001750 00000003754 12567450734 033364  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1997, Apple Computer, Inc. All rights reserved.
 *
 */

#ifndef _BSD_I386_PROFILE_H_
#define _BSD_I386_PROFILE_H_

#include <sys/appleapiopts.h>

#ifdef __APPLE_API_UNSTABLE

/*
 * Block interrupts during mcount so that those interrupts can also be
 * counted (as soon as we get done with the current counting).  On the
 * i386 platfom, can't do splhigh/splx as those are C routines and can
 * recursively invoke mcount.
 */
#warning MCOUNT_* not implemented yet.

#define MCOUNT_INIT
#define	MCOUNT_ENTER	/* s = splhigh(); */ /* XXX TODO */
#define	MCOUNT_EXIT	/* (void) splx(s); */ /* XXX TODO */

#endif /* __APPLE_API_UNSTABLE */

#endif /* _BSD_I386_PROFILE_H_ */
                    signal.h                                                                                            0100644 0001750 0001750 00000003047 12567450734 033174  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1992 NeXT Computer, Inc.
 *
 */

#ifndef	_I386_SIGNAL_H_
#define	_I386_SIGNAL_H_ 1

#include <sys/cdefs.h>

#ifndef _ANSI_SOURCE
typedef int sig_atomic_t; 

#endif /* ! _ANSI_SOURCE */

#endif	/* _I386_SIGNAL_H_ */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         types.h                                                                                             0100644 0001750 0001750 00000013600 12567450734 033057  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.3 (Berkeley) 1/5/94
 */

#ifndef	_MACHTYPES_H_
#define	_MACHTYPES_H_

#ifndef __ASSEMBLER__
#include <i386/_types.h>
#include <sys/cdefs.h>
/*
 * Basic integral types.  Omit the typedef if
 * not possible for a machine/compiler combination.
 */
#include <sys/_types/_int8_t.h>
#include <sys/_types/_int16_t.h>
#include <sys/_types/_int32_t.h>
#include <sys/_types/_int64_t.h>

typedef	unsigned char		u_int8_t;
typedef	unsigned short		u_int16_t;
typedef	unsigned int		u_int32_t;
typedef	unsigned long long	u_int64_t;

#if __LP64__
typedef int64_t			register_t;
#else
typedef int32_t			register_t;
#endif

#include <sys/_types/_intptr_t.h>
#include <sys/_types/_uintptr_t.h>

#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
/* These types are used for reserving the largest possible size. */
typedef u_int64_t		user_addr_t;	
typedef u_int64_t		user_size_t;	
typedef int64_t			user_ssize_t;
typedef int64_t			user_long_t;
typedef u_int64_t		user_ulong_t;
typedef int64_t			user_time_t;
typedef int64_t			user_off_t;
#define USER_ADDR_NULL	((user_addr_t) 0)
#define CAST_USER_ADDR_T(a_ptr)   ((user_addr_t)((uintptr_t)(a_ptr)))


/*
 * These types are used when you know the word size of the target
 * user process. They can be used to create struct layouts independent
 * of the types and alignment requirements of the current running
 * kernel.
 */

/*
 * The default ABI for the 32-bit Intel userspace aligns fundamental
 * integral data types to their natural boundaries, with a maximum alignment
 * of 4, even for 8-byte quantites. The default ABI for 64-bit Intel
 * userspace aligns fundamental integral data types for their natural
 * boundaries, including those in composite data types. PowerPC applications
 * running under translation must conform to the 32-bit Intel ABI.
 */

typedef __uint64_t		user64_addr_t __attribute__((aligned(8)));
typedef __uint64_t		user64_size_t __attribute__((aligned(8)));
typedef __int64_t		user64_ssize_t __attribute__((aligned(8)));
typedef __int64_t		user64_long_t __attribute__((aligned(8)));
typedef __uint64_t		user64_ulong_t __attribute__((aligned(8)));
typedef __int64_t		user64_time_t __attribute__((aligned(8)));
typedef __int64_t		user64_off_t __attribute__((aligned(8)));

typedef __uint32_t		user32_addr_t;
typedef __uint32_t		user32_size_t;
typedef __int32_t		user32_ssize_t;
typedef __int32_t		user32_long_t;
typedef __uint32_t		user32_ulong_t;
typedef __int32_t		user32_time_t;
typedef __int64_t		user32_off_t __attribute__((aligned(4)));


#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* This defines the size of syscall arguments after copying into the kernel: */
typedef u_int64_t		syscall_arg_t;

#endif /* __ASSEMBLER__ */
#endif	/* _MACHTYPES_H_ */
                                                                                                                                vmparam.h                                                                                           0100644 0001750 0001750 00000004040 12567450734 033354  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef	_BSD_I386_VMPARAM_H_
#define	_BSD_I386_VMPARAM_H_ 1

#include <sys/resource.h>

#define	USRSTACK	VM_USRSTACK32
#define	USRSTACK64	VM_USRSTACK64


/*
 * Virtual memory related constants, all in bytes
 */
#ifndef DFLDSIZ
#define	DFLDSIZ		(RLIM_INFINITY)		/* initial data size limit */
#endif
#ifndef MAXDSIZ
#define	MAXDSIZ		(RLIM_INFINITY)		/* max data size */
#endif
#ifndef	DFLSSIZ
#define	DFLSSIZ		(8*1024*1024)		/* initial stack size limit */
#endif
#ifndef	MAXSSIZ
#define	MAXSSIZ		(64*1024*1024)		/* max stack size */
#endif
#ifndef	DFLCSIZ
#define DFLCSIZ		(0)			/* initial core size limit */
#endif
#ifndef	MAXCSIZ
#define MAXCSIZ		(RLIM_INFINITY)		/* max core size */
#endif	/* MAXCSIZ */

#endif	/* _BSD_I386_VMPARAM_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                vmx.h                                                                                               0100644 0001750 0001750 00000003334 12567450734 032530  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/i386                                                                 /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
 
#ifndef _I386_VMX_H_
#define _I386_VMX_H_

#if defined(__cplusplus)
extern "C" {
#endif

#include <mach/boolean.h>

/*
 * Error codes
 */
#define VMX_OK			0 /* all ok */
#define VMX_UNSUPPORTED	1 /* VT unsupported or disabled on 1+ cores */
#define VMX_INUSE		2 /* VT is being exclusively used already */

/* SPI */
int host_vmxon(boolean_t exclusive);
void host_vmxoff(void);

#if defined(__cplusplus)
}
#endif

#endif
                                                                                                                                                                                                                                                                                                    ipc/                                                                                                0040755 0001750 0001750 00000000000 12612224742 031614  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      ipc_types.h                                                                                         0100644 0001750 0001750 00000003702 12567450746 034001  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/ipc                                                                  /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

/*
 * Define Basic IPC types available to callers.
 * These are not intended to be used directly, but
 * are used to define other types available through
 * port.h and mach_types.h for in-kernel entities.
 */

#ifndef	_IPC_IPC_TYPES_H_
#define	_IPC_IPC_TYPES_H_

#include <mach/port.h>
#include <mach/message.h>
#include <mach/mach_types.h>


struct ipc_object ;


typedef struct ipc_object	*ipc_object_t;

#define IPC_OBJECT_NULL		((ipc_object_t) 0)
#define IPC_OBJECT_DEAD		((ipc_object_t)~0)
#define IPC_OBJECT_VALID(io)	(((io) != IPC_OBJECT_NULL) && \
				 ((io) != IPC_OBJECT_DEAD))

#endif	/* _IPC_IPC_TYPES_H_ */
                                                              kdp/                                                                                                0040755 0001750 0001750 00000000000 12612224742 031617  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      kdp_callout.h                                                                                       0100644 0001750 0001750 00000003625 12567450761 034307  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kdp                                                                  /*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

typedef enum {
	KDP_EVENT_ENTER,
	KDP_EVENT_EXIT,
	KDP_EVENT_PANICLOG
} kdp_event_t;

typedef void (*kdp_callout_fn_t)(void *arg, kdp_event_t event);

/*
 * Register fn(arg, event) to be called at kdp entry/exit.
 * The callouts are made in a single-threaded environment, interrupts are
 * disabled and processors other than the callout processor quiesced.
 * N.B. callouts are strictly limited in what they can do: they must execute
 * with interrupts disabled and they can't call back into the kernel for any
 * non-trivial service.
 */
extern void kdp_register_callout(kdp_callout_fn_t fn, void *arg);

                                                                                                           kdp_en_debugger.h                                                                                   0100644 0001750 0001750 00000003225 12567450761 035106  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kdp                                                                  /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * Ethernet debugger header file
 */

typedef void (*kdp_send_t)(void * pkt, unsigned int pkt_len);
typedef void (*kdp_receive_t)(void * pkt, unsigned int * pkt_len, 
	      unsigned int timeout);

void 
kdp_register_send_receive(kdp_send_t send, kdp_receive_t receive);

void
kdp_unregister_send_receive(kdp_send_t send, kdp_receive_t receive);

                                                                                                                                                                                                                                                                                                                                                                           kern/                                                                                               0040755 0001750 0001750 00000000000 12612224742 032000  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers                                                                      assert.h                                                                                            0100644 0001750 0001750 00000006150 12567450746 033467  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

#ifndef	_KERN_ASSERT_H_
#define	_KERN_ASSERT_H_

/*	assert.h	4.2	85/01/21	*/

#include <kern/macro_help.h>
#include <sys/cdefs.h>


__BEGIN_DECLS
/* Assert error */
extern void	Assert(
	const char	*file,
	int		line,
	const char	*expression) __attribute__((noinline));

#if CONFIG_NO_PANIC_STRINGS
#define Assert(file, line, ex) (Assert)("", line, "")
#endif

__END_DECLS

#if	MACH_ASSERT

#define assert(ex)  \
	(__builtin_expect(!!((long)(ex)), 1L) ? (void)0 : Assert(__FILE__, __LINE__, # ex))
#define assert_static(ex) _Static_assert((ex), #ex)

#define __assert_only

#else	/* MACH_ASSERT */

#define assert(ex) ((void)0)
#define assert_static(ex) _Static_assert((ex), #ex)

#define __assert_only __unused

#endif	/* MACH_ASSERT */

#endif	/* _KERN_ASSERT_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                        call_entry.h                                                                                        0100644 0001750 0001750 00000002706 12567450746 034325  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 1993-1995, 1999-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Declarations for generic call outs.
 */

#ifndef _KERN_CALL_ENTRY_H_
#define _KERN_CALL_ENTRY_H_


#endif /* _KERN_CALL_ENTRY_H_ */
                                                          clock.h                                                                                             0100644 0001750 0001750 00000006371 12567450746 033266  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/*
 */

#ifndef	_KERN_CLOCK_H_
#define	_KERN_CLOCK_H_

#include <stdint.h>
#include <mach/mach_types.h>
#include <mach/clock_types.h>
#include <mach/message.h>
#include <mach/mach_time.h>

#include <kern/kern_types.h>

#include <sys/cdefs.h>

#ifdef	__LP64__

typedef unsigned long		clock_sec_t;
typedef unsigned int		clock_usec_t, clock_nsec_t;

#else	/* __LP64__ */

typedef uint32_t			clock_sec_t;
typedef uint32_t			clock_usec_t, clock_nsec_t;

#endif	/* __LP64__ */


__BEGIN_DECLS


extern void			clock_get_calendar_microtime(
						clock_sec_t			*secs,
						clock_usec_t		*microsecs);

extern void			clock_get_calendar_absolute_and_microtime(
						clock_sec_t			*secs,
						clock_usec_t		*microsecs,
						uint64_t    		*abstime);

extern void			clock_get_calendar_nanotime(
						clock_sec_t			*secs,
						clock_nsec_t		*nanosecs);

extern void			clock_get_system_microtime(
						clock_sec_t			*secs,
						clock_usec_t		*microsecs);

extern void			clock_get_system_nanotime(
						clock_sec_t			*secs,
						clock_nsec_t		*nanosecs);

extern void				clock_timebase_info(
							mach_timebase_info_t	info);

extern void				clock_get_uptime(
							uint64_t		*result);

extern void				clock_interval_to_deadline(
							uint32_t		interval,
							uint32_t		scale_factor,
							uint64_t		*result);

extern void				clock_interval_to_absolutetime_interval(
							uint32_t		interval,
							uint32_t		scale_factor,
							uint64_t		*result);

extern void				clock_absolutetime_interval_to_deadline(
							uint64_t		abstime,
							uint64_t		*result);

extern void				clock_delay_until(
							uint64_t		deadline);

extern void				absolutetime_to_nanoseconds(
							uint64_t		abstime,
							uint64_t		*result);

extern void             nanoseconds_to_absolutetime(
							uint64_t		nanoseconds,
							uint64_t		*result);

extern uint64_t mach_absolutetime_asleep;
extern uint64_t mach_absolutetime_last_sleep;


__END_DECLS

#endif	/* _KERN_CLOCK_H_ */
                                                                                                                                                                                                                                                                       coalition.h                                                                                         0100644 0001750 0001750 00000002662 12567450746 034153  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2013 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _KERN_COALITION_H_
#define _KERN_COALITION_H_

/* only kernel-private interfaces */
#endif /* _KERN_COALITION_H */
                                                                              debug.h                                                                                             0100644 0001750 0001750 00000032456 12567450746 033264  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef	_KERN_DEBUG_H_
#define _KERN_DEBUG_H_

#include <sys/cdefs.h>
#include <stdint.h>
#include <uuid/uuid.h>
#include <mach/boolean.h>

#include <TargetConditionals.h>

#ifdef __APPLE_API_PRIVATE
#ifdef __APPLE_API_UNSTABLE

/* This value must always match IO_NUM_PRIORITIES defined in thread_info.h */
#define STACKSHOT_IO_NUM_PRIORITIES 	4
/* This value must always match MAXTHREADNAMESIZE used in bsd */
#define STACKSHOT_MAX_THREAD_NAME_SIZE	64

struct thread_snapshot {
	uint32_t 		snapshot_magic;
	uint32_t 		nkern_frames;
	uint32_t 		nuser_frames;
	uint64_t 		wait_event;
	uint64_t 	 	continuation;
	uint64_t 		thread_id;
	uint64_t 		user_time;
	uint64_t 		system_time;
	int32_t  		state;
	int32_t			priority;    /*	static priority */
	int32_t			sched_pri;   /* scheduled (current) priority */
	int32_t			sched_flags; /* scheduler flags */
	char			ss_flags;
	char			ts_qos;      /* effective qos */
	char			ts_rqos;     /* requested qos */
	char			ts_rqos_override; /* requested qos override */
	char			io_tier;
	char			_reserved[3]; /* pad for 4 byte alignement packing */

	/*
	 * I/O Statistics
	 * XXX: These fields must be together
	 */
	uint64_t 		disk_reads_count;
	uint64_t 		disk_reads_size;
	uint64_t 		disk_writes_count;
	uint64_t 		disk_writes_size;
	uint64_t 		io_priority_count[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t 		io_priority_size[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t 		paging_count;
	uint64_t 		paging_size;
	uint64_t 		non_paging_count;
	uint64_t 		non_paging_size;
	uint64_t 		data_count;
	uint64_t 		data_size;
	uint64_t 		metadata_count;
	uint64_t 		metadata_size;
	/* XXX: I/O Statistics end */

	uint64_t		voucher_identifier; /* obfuscated voucher identifier */
	uint64_t		total_syscalls;
	char			pth_name[STACKSHOT_MAX_THREAD_NAME_SIZE];

} __attribute__ ((packed));

struct thread_snapshot_v2 {
	uint64_t  ths_thread_id;
	uint64_t  ths_wait_event;
	uint64_t  ths_continuation;
	uint64_t  ths_total_syscalls;
	uint64_t  ths_voucher_identifier;
	uint64_t  ths_dqserialnum;
	uint64_t  ths_user_time;
	uint64_t  ths_sys_time;
	uint64_t  ths_ss_flags;
	uint64_t  ths_last_run_time;
	uint64_t  ths_last_made_runnable_time;
	uint32_t  ths_state;
	uint32_t  ths_sched_flags;
	int16_t   ths_base_priority;
	int16_t   ths_sched_priority;
	uint8_t   ths_eqos;
	uint8_t   ths_rqos;
	uint8_t   ths_rqos_override;
	uint8_t   ths_io_tier;
} __attribute__ ((packed));

struct task_snapshot {
	uint32_t		snapshot_magic;
	int32_t			pid;
	uint64_t		uniqueid;
	uint64_t		user_time_in_terminated_threads;
	uint64_t		system_time_in_terminated_threads;
	uint8_t			shared_cache_identifier[16];
	uint64_t		shared_cache_slide;
	uint32_t		nloadinfos;
	int			suspend_count; 
	int			task_size;	/* pages */
	int			faults;		/* number of page faults */
	int			pageins;	/* number of actual pageins */
	int			cow_faults;	/* number of copy-on-write faults */
	uint32_t		ss_flags;
	uint64_t		p_start_sec;	/* from the bsd proc struct */
	uint64_t		p_start_usec;	/* from the bsd proc struct */

	/* 
	 * We restrict ourselves to a statically defined
	 * (current as of 2009) length for the
	 * p_comm string, due to scoping issues (osfmk/bsd and user/kernel
	 * binary compatibility).
	 */
	char			p_comm[17];
	uint32_t 		was_throttled;
	uint32_t 		did_throttle;
	uint32_t		latency_qos;
	/*
	 * I/O Statistics
	 * XXX: These fields must be together.
	 */
	uint64_t 		disk_reads_count;
	uint64_t 		disk_reads_size;
	uint64_t 		disk_writes_count;
	uint64_t 		disk_writes_size;
	uint64_t 		io_priority_count[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t 		io_priority_size[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t 		paging_count;
	uint64_t 		paging_size;
	uint64_t 		non_paging_count;
	uint64_t 		non_paging_size;
	uint64_t 		data_count;
	uint64_t 		data_size;
	uint64_t 		metadata_count;
	uint64_t 		metadata_size;
	/* XXX: I/O Statistics end */

	uint32_t		donating_pid_count;

} __attribute__ ((packed));

struct io_stats_snapshot
{
	/*
	 * I/O Statistics
	 * XXX: These fields must be together.
	 */
	uint64_t         ss_disk_reads_count;
	uint64_t         ss_disk_reads_size;
	uint64_t         ss_disk_writes_count;
	uint64_t         ss_disk_writes_size;
	uint64_t         ss_io_priority_count[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_io_priority_size[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_paging_count;
	uint64_t         ss_paging_size;
	uint64_t         ss_non_paging_count;
	uint64_t         ss_non_paging_size;
	uint64_t         ss_data_count;
	uint64_t         ss_data_size;
	uint64_t         ss_metadata_count;
	uint64_t         ss_metadata_size;
	/* XXX: I/O Statistics end */

} __attribute__ ((packed));

struct task_snapshot_v2 {
	uint64_t  ts_unique_pid;
	uint64_t  ts_ss_flags;
	uint64_t  ts_user_time_in_terminated_threads;
	uint64_t  ts_system_time_in_terminated_threads;
	uint64_t  ts_p_start_sec;
	uint64_t  ts_task_size;
	uint64_t  ts_max_resident_size;
	uint32_t  ts_suspend_count;
	uint32_t  ts_faults;
	uint32_t  ts_pageins;
	uint32_t  ts_cow_faults;
	uint32_t  ts_was_throttled;
	uint32_t  ts_did_throttle;
	uint32_t  ts_latency_qos;
	int32_t   ts_pid;
	char      ts_p_comm[32];
} __attribute__ ((packed));

struct micro_snapshot {
	uint32_t		snapshot_magic;
	uint32_t		ms_cpu;	 /* cpu number this snapshot was recorded on */
	uint64_t		ms_time; /* time at sample (seconds) */
	uint64_t		ms_time_microsecs;
	uint8_t			ms_flags;
	uint16_t		ms_opaque_flags;	/* managed by external entity, e.g. fdrmicrod */
} __attribute__ ((packed));

struct mem_and_io_snapshot {
	uint32_t	snapshot_magic;
	uint32_t	free_pages;
	uint32_t	active_pages;
	uint32_t	inactive_pages;
	uint32_t	purgeable_pages;
	uint32_t	wired_pages;
	uint32_t	speculative_pages;
	uint32_t	throttled_pages;
	uint32_t	filebacked_pages;
	uint32_t 	compressions;
	uint32_t	decompressions;
	uint32_t	compressor_size;
	int     	busy_buffer_count;
	uint32_t	pages_wanted;
	uint32_t	pages_reclaimed;
	uint8_t		pages_wanted_reclaimed_valid; // did mach_vm_pressure_monitor succeed?
} __attribute__((packed));

struct stack_snapshot_frame32 {
	uint32_t lr;
    uint32_t sp;
};

struct stack_snapshot_frame64 {
    uint64_t lr;
    uint64_t sp;
};

struct _dyld_cache_header
{
    char    	magic[16];				// e.g. "dyld_v0    i386"
    uint32_t	mappingOffset;          // file offset to first dyld_cache_mapping_info
    uint32_t    mappingCount;           // number of dyld_cache_mapping_info entries
    uint32_t    imagesOffset;           // file offset to first dyld_cache_image_info
    uint32_t    imagesCount;            // number of dyld_cache_image_info entries
    uint64_t    dyldBaseAddress;        // base address of dyld when cache was built
    uint64_t    codeSignatureOffset;    // file offset of code signature blob
    uint64_t    codeSignatureSize;     	// size of code signature blob (zero means to end of file)
    uint64_t    slideInfoOffset;        // file offset of kernel slid info
    uint64_t    slideInfoSize;          // size of kernel slid info
    uint64_t    localSymbolsOffset;     // file offset of where local symbols are stored
    uint64_t    localSymbolsSize;       // size of local symbols information
    uint8_t     uuid[16];               // unique value for each shared cache file
};

struct dyld_uuid_info_32 {
    uint32_t imageLoadAddress; /* base address image is mapped at */
	uuid_t	 imageUUID;
};

struct dyld_uuid_info_64 {
    uint64_t imageLoadAddress; /* base address image is mapped at */
    uuid_t   imageUUID;
};

enum micro_snapshot_flags {
	kInterruptRecord	= 0x1,
	kTimerArmingRecord	= 0x2,
	kUserMode 			= 0x4, /* interrupted usermode, or armed by usermode */
};

/*
 * Flags used in the following assortment of snapshots.
 */
enum generic_snapshot_flags {
	kUser64_p 			= 0x1,
	kKernel64_p 		= 0x2
};

enum task_snapshot_flags {
	kTaskRsrcFlagged      = 0x4, // In the EXC_RESOURCE danger zone?
	kTerminatedSnapshot   = 0x8,
	kPidSuspended         = 0x10, // true for suspended task
	kFrozen               = 0x20, // true for hibernated task (along with pidsuspended)
	kTaskDarwinBG         = 0x40,
	kTaskExtDarwinBG      = 0x80,
	kTaskVisVisible       = 0x100,
	kTaskVisNonvisible    = 0x200,
	kTaskIsForeground     = 0x400,
	kTaskIsBoosted        = 0x800,
	kTaskIsSuppressed     = 0x1000,
	kTaskIsTimerThrottled = 0x2000, /* deprecated */
	kTaskIsImpDonor       = 0x4000,
	kTaskIsLiveImpDonor   = 0x8000
};

enum thread_snapshot_flags {
	kHasDispatchSerial = 0x4,
	kStacksPCOnly      = 0x8,  /* Stack traces have no frame pointers. */
	kThreadDarwinBG    = 0x10, /* Thread is darwinbg */
	kThreadIOPassive   = 0x20, /* Thread uses passive IO */
	kThreadSuspended   = 0x40, /* Thread is suspended */
	kThreadTruncatedBT = 0x80, /* Unmapped pages caused truncated backtrace */
	kGlobalForcedIdle  = 0x100, /* Thread performs global forced idle */
	kThreadDecompressedBT = 0x200,   /* Some thread stack pages were decompressed as part of BT */
	kThreadFaultedBT = 0x400   /* Some thread stack pages were faulted in as part of BT */
};

#define VM_PRESSURE_TIME_WINDOW 5 /* seconds */

enum {
	STACKSHOT_GET_DQ							= 0x01,
	STACKSHOT_SAVE_LOADINFO						= 0x02,
	STACKSHOT_GET_GLOBAL_MEM_STATS				= 0x04,
	STACKSHOT_SAVE_KEXT_LOADINFO				= 0x08,
	STACKSHOT_GET_MICROSTACKSHOT				= 0x10,
	STACKSHOT_GLOBAL_MICROSTACKSHOT_ENABLE		= 0x20,
	STACKSHOT_GLOBAL_MICROSTACKSHOT_DISABLE		= 0x40,
	STACKSHOT_SET_MICROSTACKSHOT_MARK			= 0x80,
	STACKSHOT_SAVE_KERNEL_FRAMES_ONLY			= 0x100,
	STACKSHOT_GET_BOOT_PROFILE					= 0x200,
	STACKSHOT_GET_WINDOWED_MICROSTACKSHOTS		= 0x400,
	STACKSHOT_WINDOWED_MICROSTACKSHOTS_ENABLE	= 0x800,
	STACKSHOT_WINDOWED_MICROSTACKSHOTS_DISABLE	= 0x1000,
	STACKSHOT_SAVE_IMP_DONATION_PIDS		= 0x2000,
	STACKSHOT_SAVE_IN_KERNEL_BUFFER			= 0x4000,
	STACKSHOT_RETRIEVE_EXISTING_BUFFER		= 0x8000,
	STACKSHOT_KCDATA_FORMAT				= 0x10000,
	STACKSHOT_ENABLE_FAULTING			= 0x20000
};

/*
 * NOTE: Please update libkdd/kcdata/kcdtypes.c if you make any changes
 * in STACKSHOT_KCTYPE_* types.
 */
#define STACKSHOT_KCTYPE_IOSTATS                0x901  /* io_stats_snapshot */
#define STACKSHOT_KCTYPE_GLOBAL_MEM_STATS       0x902  /* struct mem_and_io_snapshot */
#define STACKSHOT_KCCONTAINER_TASK              0x903
#define STACKSHOT_KCCONTAINER_THREAD            0x904
#define STACKSHOT_KCTYPE_TASK_SNAPSHOT          0x905  /* task_snapshot_v2 */
#define STACKSHOT_KCTYPE_THREAD_SNAPSHOT        0x906  /* thread_snapshot_v2 */
#define STASKSHOT_KCTYPE_DONATING_PIDS          0x907  /* int[] */
#define STACKSHOT_KCTYPE_SHAREDCACHE_LOADINFO   0x908  /* same as KCDATA_TYPE_LIBRARY_LOADINFO64 */
#define STACKSHOT_KCTYPE_THREAD_NAME            0x909  /* char[] */
#define STACKSHOT_KCTYPE_KERN_STACKFRAME        0x90A  /* struct stack_snapshot_frame32 */
#define STACKSHOT_KCTYPE_KERN_STACKFRAME64      0x90B  /* struct stack_snapshot_frame64 */
#define STACKSHOT_KCTYPE_USER_STACKFRAME        0x90C  /* struct stack_snapshot_frame32 */
#define STACKSHOT_KCTYPE_USER_STACKFRAME64      0x90D  /* struct stack_snapshot_frame64 */
#define STACKSHOT_KCTYPE_BOOTARGS               0x90E  /* boot args string */
#define STACKSHOT_KCTYPE_OSVERSION              0x90F  /* os version string */
#define STACKSHOT_KCTYPE_KERN_PAGE_SIZE         0x910  /* kernel page size in uint32_t */
#define STACKSHOT_KCTYPE_JETSAM_LEVEL           0x911  /* jetsam level in uint32_t */


#define STACKSHOT_THREAD_SNAPSHOT_MAGIC 	0xfeedface
#define STACKSHOT_TASK_SNAPSHOT_MAGIC   	0xdecafbad
#define STACKSHOT_MEM_AND_IO_SNAPSHOT_MAGIC	0xbfcabcde
#define STACKSHOT_MICRO_SNAPSHOT_MAGIC		0x31c54011

#endif /* __APPLE_API_UNSTABLE */
#endif /* __APPLE_API_PRIVATE */



__BEGIN_DECLS

extern void panic(const char *string, ...) __printflike(1,2);


#if CONFIG_NO_PANIC_STRINGS
#define panic_plain(...) (panic)((char *)0)
#define panic(...)  (panic)((char *)0)
#else /* CONFIGS_NO_PANIC_STRINGS */
#define panic_plain(ex, ...) \
	(panic)(ex, ## __VA_ARGS__)
#define __STRINGIFY(x) #x
#define LINE_NUMBER(x) __STRINGIFY(x)
#define PANIC_LOCATION __FILE__ ":" LINE_NUMBER(__LINE__)
#if CONFIG_EMBEDDED || TARGET_OS_EMBEDDED
#define panic(ex, ...) \
	(panic)(# ex, ## __VA_ARGS__)
#else
#define panic(ex, ...) \
	(panic)(# ex "@" PANIC_LOCATION, ## __VA_ARGS__)
#endif
#endif /* CONFIGS_NO_PANIC_STRINGS */


__END_DECLS


#endif	/* _KERN_DEBUG_H_ */
                                                                                                                                                                                                                  ecc.h                                                                                               0100644 0001750 0001750 00000003314 12567450746 032717  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 #if !defined(_KERN_ECC_H)
#define _KERN_ECC_H

#include <sys/cdefs.h>

__BEGIN_DECLS

/*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#define ECC_EVENT_INFO_DATA_ENTRIES	8
struct ecc_event {
	uint8_t 	id;	// ID of memory (e.g. L2C), platform-specific
	uint8_t		count;	// Of uint64_t's used, starting at index 0
	uint64_t	data[ECC_EVENT_INFO_DATA_ENTRIES] __attribute__((aligned(8))); // Event-specific data 
};




__END_DECLS

#endif /* !defined(_KERN_ECC_H) */
                                                                                                                                                                                                                                                                                                                    energy_perf.h                                                                                       0100644 0001750 0001750 00000007755 12567450747 034510  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * Interfaces for non-kernel managed devices to inform the kernel of their
 * energy and performance relevant activity and resource utilisation, typically
 * on a per-thread or task basis.
 */

#ifndef _KERN_ENERGY_PERF_H_
#define _KERN_ENERGY_PERF_H_

#include <stdint.h>

__BEGIN_DECLS

typedef struct {
	uint32_t gpu_id;
	uint32_t gpu_max_domains;
} gpu_descriptor;

typedef gpu_descriptor *gpu_descriptor_t;
/* The GPU is expected to describe itself with this interface prior to reporting
 * resource usage.
 */
void gpu_describe(gpu_descriptor_t);

#define GPU_SCOPE_CURRENT_THREAD (0x1)
#define GPU_SCOPE_MISC (0x2)

/* GPU utilisation update for the current thread. */
uint64_t gpu_accumulate_time(uint32_t scope, uint32_t gpu_id, uint32_t gpu_domain, uint64_t gpu_accumulated_ns, uint64_t gpu_tstamp_ns);

/* Interfaces for the block storage driver to advise the perf. controller of
 * recent IOs
 */

/* Target medium for this set of IOs. Updates can occur in parallel if
 * multiple devices exist, hence consumers must synchronize internally, ideally
 * in a low-overhead fashion such as per-CPU counters, as this may be invoked
 * within the IO path.
 */

#define IO_MEDIUM_ROTATING (0x0ULL)
#define IO_MEDIUM_SOLID_STATE (0x1ULL)

/* As there are several priority bands whose nature is evolving, we rely on the
 * block storage driver to classify non-performance-critical IOs as "low"
 * priority. Separate updates are expected for low/high priority IOs.
 */

#define IO_PRIORITY_LOW (0x1ULL << 8)

/* Reserved for estimates of bursts of future IOs; could possibly benefit from
 * a time horizon, but it's unclear if it will be specifiable by any layer with
 * reasonable accuracy
 */
#define IO_PRIORITY_PREDICTIVE (0x1ULL << 16)

uint64_t io_rate_update(
	uint64_t io_rate_flags, /* Rotating/NAND, IO priority level */
	uint64_t read_ops_delta,
	uint64_t write_ops_delta,
	uint64_t read_bytes_delta,
	uint64_t write_bytes_delta);

typedef uint64_t (*io_rate_update_callback_t) (uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

void io_rate_update_register(io_rate_update_callback_t);

/* Interfaces for integrated GPUs to supply command submission telemetry.
 */

#define GPU_NCMDS_VALID (0x1)
#define GPU_NOUTSTANDING_VALID (0x2)
#define GPU_BUSY_VALID (0x4)
#define GPU_CYCLE_COUNT_VALID (0x8)
#define GPU_MISC_VALID (0x10)

void gpu_submission_telemetry(
	uint64_t gpu_ncmds_total,
	uint64_t gpu_noutstanding,
	uint64_t gpu_busy_ns_total,
	uint64_t gpu_cycles,
	uint64_t gpu_telemetry_valid_flags,
	uint64_t gpu_telemetry_misc);

typedef uint64_t (*gpu_set_fceiling_t) (uint32_t gpu_fceiling_ratio, uint64_t gpu_fceiling_param);

void gpu_fceiling_cb_register(gpu_set_fceiling_t);

__END_DECLS

#endif /* _KERN_ENERGY_PERF_H_ */
                   exc_resource.h                                                                                      0100644 0001750 0001750 00000014733 12567450746 034662  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2011-2012 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1989 Carnegie-Mellon University
 * Copyright (c) 1988 Carnegie-Mellon University
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */

/*
 *        EXC_RESOURCE related macros, namespace etc.
 */

#ifndef _EXC_RESOURCE_H_
#define _EXC_RESOURCE_H_

/*
 * Generic exception code format:
 *
 * code:
 * +----------------------------------------------------------+
 * |[63:61] type | [60:58] flavor | [57:0] type-specific data |
 * +----------------------------------------------------------+
 */


/* EXC_RESOURCE type and flavor decoding routines */
#define EXC_RESOURCE_DECODE_RESOURCE_TYPE(code) \
	(((code) >> 61) & 0x7ULL)
#define EXC_RESOURCE_DECODE_FLAVOR(code) \
	(((code) >> 58) & 0x7ULL)

/* EXC_RESOURCE Types */
#define RESOURCE_TYPE_CPU	1
#define RESOURCE_TYPE_WAKEUPS	2
#define	RESOURCE_TYPE_MEMORY	3

/* RESOURCE_TYPE_CPU flavors */
#define FLAVOR_CPU_MONITOR		1
#define FLAVOR_CPU_MONITOR_FATAL	2

/*
 * RESOURCE_TYPE_CPU exception code & subcode.
 *
 * This is sent by the kernel when the CPU usage monitor
 * is tripped. [See proc_set_cpumon_params()]
 *
 * code:
 * +-----------------------------------------------+
 * |[63:61] RESOURCE |[60:58] FLAVOR_CPU_ |[57:32] |
 * |_TYPE_CPU        |MONITOR[_FATAL]     |Unused  |
 * +-----------------------------------------------+
 * |[31:7]  Interval (sec)    | [6:0] CPU limit (%)|
 * +-----------------------------------------------+
 *
 * subcode:
 * +-----------------------------------------------+
 * |                          | [6:0] % of CPU     |
 * |                          | actually consumed  |
 * +-----------------------------------------------+
 *
 */

/* RESOURCE_TYPE_CPU decoding macros */
#define EXC_RESOURCE_CPUMONITOR_DECODE_INTERVAL(code) \
	(((code) >> 7) & 0x1FFFFFFULL)
#define EXC_RESOURCE_CPUMONITOR_DECODE_PERCENTAGE(code) \
	((code) & 0x7FULL)
#define EXC_RESOURCE_CPUMONITOR_DECODE_PERCENTAGE_OBSERVED(subcode) \
	((subcode) & 0x7FULL)


/* RESOURCE_TYPE_WAKEUPS flavors */
#define FLAVOR_WAKEUPS_MONITOR	1

/*
 * RESOURCE_TYPE_WAKEUPS exception code & subcode.
 *
 * This is sent by the kernel when the platform idle
 * wakeups monitor is tripped.
 * [See proc_set_wakeupsmon_params()]
 *
 * code:
 * +-----------------------------------------------+
 * |[63:61] RESOURCE |[60:58] FLAVOR_     |[57:32] |
 * |_TYPE_WAKEUPS    |WAKEUPS_MONITOR     |Unused  |
 * +-----------------------------------------------+
 * | [31:20] Observation     | [19:0] # of wakeups |
 * |         interval (sec)  | permitted (per sec) |
 * +-----------------------------------------------+
 *
 * subcode:
 * +-----------------------------------------------+
 * |                         | [19:0] # of wakeups |
 * |                         | observed (per sec)  |
 * +-----------------------------------------------+
 *
 */

#define EXC_RESOURCE_CPUMONITOR_DECODE_WAKEUPS_PERMITTED(code) \
	((code) & 0xFFFULL)
#define EXC_RESOURCE_CPUMONITOR_DECODE_OBSERVATION_INTERVAL(code) \
	(((code) >> 20) & 0xFFFFFULL)
#define EXC_RESOURCE_CPUMONITOR_DECODE_WAKEUPS_OBSERVED(subcode) \
	((subcode) & 0xFFFFFULL)

/* RESOURCE_TYPE_MEMORY flavors */
#define	FLAVOR_HIGH_WATERMARK	1

/*
 * RESOURCE_TYPE_MEMORY / FLAVOR_HIGH_WATERMARK
 * exception code & subcode.
 *
 * This is sent by the kernel when a task crosses its high
 * watermark memory limit.
 *
 * code:
 * +------------------------------------------------+
 * |[63:61] RESOURCE |[60:58] FLAVOR_HIGH_ |[57:32] |
 * |_TYPE_MEMORY     |WATERMARK            |Unused  |
 * +------------------------------------------------+
 * |                         | [12:0] HWM limit (MB)|
 * +------------------------------------------------+
 *
 * subcode:
 * +------------------------------------------------+
 * |                                         unused |
 * +------------------------------------------------+
 *
 */

#define EXC_RESOURCE_HWM_DECODE_LIMIT(code) \
	((code) & 0x1FFFULL)



/* EXC_RESOURCE type and flavor encoding macros */
#define EXC_RESOURCE_ENCODE_TYPE(code, type) \
	((code) |= (((uint64_t)(type) & 0x7ULL) << 61))
#define EXC_RESOURCE_ENCODE_FLAVOR(code, flavor) \
	((code) |= (((uint64_t)(flavor) & 0x7ULL) << 58))

/* RESOURCE_TYPE_CPU::FLAVOR_CPU_MONITOR specific encoding macros */
#define EXC_RESOURCE_CPUMONITOR_ENCODE_INTERVAL(code, interval) \
	((code) |= (((uint64_t)(interval) & 0x1FFFFFFULL) << 7))
#define EXC_RESOURCE_CPUMONITOR_ENCODE_PERCENTAGE(code, percentage) \
	((code) |= (((uint64_t)(percentage) & 0x7FULL)))

/* RESOURCE_TYPE_WAKEUPS::FLAVOR_WAKEUPS_MONITOR specific encoding macros */
#define EXC_RESOURCE_CPUMONITOR_ENCODE_WAKEUPS_PERMITTED(code, num) \
	((code) |= ((uint64_t)(num) & 0xFFFFFULL))
#define EXC_RESOURCE_CPUMONITOR_ENCODE_OBSERVATION_INTERVAL(code, num) \
	((code) |= (((uint64_t)(num) & 0xFFFULL) << 20))
#define EXC_RESOURCE_CPUMONITOR_ENCODE_WAKEUPS_OBSERVED(subcode, num) \
	((subcode) |= ((uint64_t)(num) & 0xFFFFFULL))

/* RESOURCE_TYPE_MEMORY::FLAVOR_HIGH_WATERMARK specific encoding macros */
#define EXC_RESOURCE_HWM_ENCODE_LIMIT(code, num) \
	((code) |= ((uint64_t)(num) & 0x1FFFULL))



#endif /* _EXC_RESOURCE_H_ */
                                     extmod_statistics.h                                                                                 0100644 0001750 0001750 00000003455 12567450747 035746  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 *	kern/extmod_statistics.h
 *
 *	Definitions for statistics related to external
 *  modification of a task by another agent on the system.
 *
 */

#ifndef	_KERN_EXTMOD_STATISTICS_H_
#define _KERN_EXTMOD_STATISTICS_H_

#include <kern/task.h>
#include <mach/vm_types.h>

extern void extmod_statistics_incr_task_for_pid(task_t target);
extern void extmod_statistics_incr_thread_set_state(thread_t target);
extern void extmod_statistics_incr_thread_create(task_t target);

#endif	/* _KERN_EXTMOD_STATISTICS_H_ */
                                                                                                                                                                                                                   host.h                                                                                              0100644 0001750 0001750 00000005367 12567450747 033155  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
 *	kern/host.h
 *
 *	Definitions for host data structures.
 *
 */

#ifndef	_KERN_HOST_H_
#define _KERN_HOST_H_

#include <mach/mach_types.h>
#include <sys/cdefs.h>


/*
 * Access routines for inside the kernel.
 */

__BEGIN_DECLS

extern host_t			host_self(void);
extern host_priv_t		host_priv_self(void);
extern host_security_t	host_security_self(void);

__END_DECLS

#endif	/* _KERN_HOST_H_ */
                                                                                                                                                                                                                                                                         hv_support.h                                                                                        0100644 0001750 0001750 00000005525 12567450747 034405  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _KERN_HV_SUPPORT_H_
#define _KERN_HV_SUPPORT_H_

#if defined(__cplusplus)
extern "C" {
#endif

#include <stdint.h>
#include <mach/kern_return.h>

typedef enum {
	HV_DEBUG_STATE
} hv_volatile_state_t;

typedef enum {
	HV_TASK_TRAP = 0,
	HV_THREAD_TRAP = 1
} hv_trap_type_t;

typedef kern_return_t (*hv_trap_t) (void *target, uint64_t arg);

typedef struct  {
	const hv_trap_t *traps;
	unsigned trap_count;
} hv_trap_table_t;

typedef struct {
	void (*dispatch)(void *vcpu);
	void (*preempt)(void *vcpu);
	void (*suspend)(void);
	void (*thread_destroy)(void *vcpu);
	void (*task_destroy)(void *vm);
	void (*volatile_state)(void *vcpu, int state);
	void (*memory_pressure)(void);
} hv_callbacks_t;

extern hv_callbacks_t hv_callbacks;
extern int hv_support_available;

extern void hv_support_init(void);
extern int hv_get_support(void);
extern void hv_set_task_target(void *target);
extern void hv_set_thread_target(void *target);
extern void *hv_get_task_target(void);
extern void *hv_get_thread_target(void);
extern int hv_get_volatile_state(hv_volatile_state_t state);
extern kern_return_t hv_set_traps(hv_trap_type_t trap_type,
	const hv_trap_t *traps, unsigned trap_count);
extern void hv_release_traps(hv_trap_type_t trap_type);
extern kern_return_t hv_set_callbacks(hv_callbacks_t callbacks);
extern void hv_release_callbacks(void);
extern void hv_suspend(void);
extern kern_return_t hv_task_trap(uint64_t index, uint64_t arg);
extern kern_return_t hv_thread_trap(uint64_t index, uint64_t arg);

#if defined(__cplusplus)
}
#endif

#endif /* _KERN_HV_SUPPORT_H_ */
                                                                                                                                                                           ipc_mig.h                                                                                           0100644 0001750 0001750 00000004253 12567450747 033600  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_KERN_IPC_MIG_H_
#define	_KERN_IPC_MIG_H_

#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <kern/kern_types.h>

#include <sys/cdefs.h>


__BEGIN_DECLS

/* Send a message from the kernel */

extern mach_msg_return_t mach_msg_send_from_kernel_proper(
	mach_msg_header_t	*msg,
	mach_msg_size_t		send_size);

#define mach_msg_send_from_kernel mach_msg_send_from_kernel_proper

extern mach_msg_return_t
mach_msg_rpc_from_kernel_proper(
	mach_msg_header_t	*msg,
	mach_msg_size_t		send_size,
	mach_msg_size_t		rcv_size);

#define mach_msg_rpc_from_kernel mach_msg_rpc_from_kernel_proper


extern mach_msg_return_t mach_msg_send_from_kernel_with_options(
	mach_msg_header_t	*msg,
	mach_msg_size_t		send_size,
	mach_msg_option_t	option,
	mach_msg_timeout_t	timeout_val);

__END_DECLS


#endif	/* _KERN_IPC_MIG_H_ */
                                                                                                                                                                                                                                                                                                                                                     kern_cdata.h                                                                                        0100644 0001750 0001750 00000016467 12567450746 034275  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _KERN_CDATA_H_
#define _KERN_CDATA_H_

#include <stdint.h>
#include <mach/mach_types.h>

#define KCDATA_DESC_MAXLEN          32      /* including NULL byte at end */

struct kcdata_item {
	uint32_t type;
	uint32_t size; /* len(data)  */
	uint64_t flags;
};

typedef struct kcdata_item * kcdata_item_t;

enum KCDATA_SUBTYPE_TYPES { KC_ST_CHAR = 1, KC_ST_INT8, KC_ST_UINT8, KC_ST_INT16, KC_ST_UINT16, KC_ST_INT32, KC_ST_UINT32, KC_ST_INT64, KC_ST_UINT64 };
typedef enum KCDATA_SUBTYPE_TYPES kctype_subtype_t;

/*
 * A subtype description structure that defines
 * how a compound data is laid out in memory. This
 * provides on the fly definition of types and consumption
 * by the parser.
 */
struct kcdata_subtype_descriptor {
	uint8_t              kcs_flags;
#define KCS_SUBTYPE_FLAGS_NONE    0x0
#define KCS_SUBTYPE_FLAGS_ARRAY   0x1
	uint8_t              kcs_elem_type;                 /* restricted to kctype_subtype_t */
	uint16_t             kcs_elem_offset;               /* offset in struct where data is found */
	uint32_t             kcs_elem_size;                 /* size of element (or) packed state for array type */
	char                 kcs_name[KCDATA_DESC_MAXLEN];  /* max 31 bytes for name of field */
};

typedef struct kcdata_subtype_descriptor * kcdata_subtype_descriptor_t;

/*
 * In case of array of basic c types in kctype_subtype_t,
 * size is packed in lower 16 bits and
 * count is packed in upper 16 bits of kcs_elem_size field.
 */
#define KCS_SUBTYPE_PACK_SIZE(e_count,e_size)      (((e_count) & 0xffff) << 16 | ((e_size) & 0xffff))

static inline uint32_t
kcs_get_elem_size(kcdata_subtype_descriptor_t d)
{
	if (d->kcs_flags & KCS_SUBTYPE_FLAGS_ARRAY) {
		/* size is composed as ((count &0xffff)<<16 | (elem_size & 0xffff)) */
		return (uint32_t)((d->kcs_elem_size & 0xffff) * ((d->kcs_elem_size & 0xffff0000)>>16));
	}
	return d->kcs_elem_size;
}

static inline uint32_t
kcs_get_elem_count(kcdata_subtype_descriptor_t d)
{
	if (d->kcs_flags & KCS_SUBTYPE_FLAGS_ARRAY)
		return (d->kcs_elem_size >> 16) & 0xffff;
	return 1;
}

static inline kern_return_t
kcs_set_elem_size(kcdata_subtype_descriptor_t d, uint32_t size, uint32_t count)
{
	if (count > 1) {
		/* means we are setting up an array */
		if (size > 0xffff || count > 0xffff)
			return KERN_INVALID_ARGUMENT;
		d->kcs_elem_size = ((count & 0xffff) << 16 | (size & 0xffff));
	}
	else
	{
		d->kcs_elem_size = size;
	}
	return KERN_SUCCESS;
}

struct kcdata_type_definition {
	uint32_t kct_type_identifier;
	uint32_t kct_num_elements;
	char kct_name[KCDATA_DESC_MAXLEN];
};

/* chunk type definitions. 0 - 0x7ff are reserved  and defined here
 * NOTE: Please update libkdd/kcdata/kcdtypes.c if you make any changes
 * in STACKSHOT_KCTYPE_* types.
 */

/*
 * Types with description value.
 * these will have KCDATA_DESC_MAXLEN-1 length string description
 * and rest of KCDATA_ITEM_SIZE() - KCDATA_DESC_MAXLEN bytes as data
 */
#define KCDATA_TYPE_INVALID              0x0
#define KCDATA_TYPE_STRING_DESC          0x1
#define KCDATA_TYPE_UINT32_DESC          0x2
#define KCDATA_TYPE_UINT64_DESC          0x3
#define KCDATA_TYPE_INT32_DESC           0x4
#define KCDATA_TYPE_INT64_DESC           0x5
#define KCDATA_TYPE_BINDATA_DESC         0x6

/*
 * Compound type definitions
 */
#define KCDATA_TYPE_ARRAY                0x11       /* Array of data */
#define KCDATA_TYPE_TYPEDEFINTION        0x12       /* Meta type that describes a type on the fly. */
#define KCDATA_TYPE_CONTAINER_BEGIN      0x13       /* Container type which has corresponding CONTAINER_END header.
                                                     * KCDATA_TYPE_CONTAINER_BEGIN has type in the data segment.
                                                     * Both headers have (uint64_t) ID for matching up nested data.
                                                     */
#define KCDATA_TYPE_CONTAINER_END        0x14


/*
 * Generic data types that are most commonly used
 */
#define KCDATA_TYPE_LIBRARY_LOADINFO     0x30       /* struct dyld_uuid_info_32 */
#define KCDATA_TYPE_LIBRARY_LOADINFO64   0x31       /* struct dyld_uuid_info_64 */
#define KCDATA_TYPE_TIMEBASE             0x32       /* struct mach_timebase_info */
#define KCDATA_TYPE_MACH_ABSOLUTE_TIME   0x33       /* uint64_t */
#define KCDATA_TYPE_TIMEVAL              0x34       /* struct timeval64 */
#define KCDATA_TYPE_USECS_SINCE_EPOCH    0x35       /* time in usecs uint64_t */

#define KCDATA_TYPE_BUFFER_END      0xF19158ED

/* MAGIC numbers defined for each class of chunked data */
#define KCDATA_BUFFER_BEGIN_CRASHINFO  0xDEADF157   /* owner: corpses/task_corpse.h */
						    /* type-range: 0x800 - 0x8ff */
#define KCDATA_BUFFER_BEGIN_STACKSHOT  0x59a25807   /* owner: sys/stackshot.h */
						    /* type-range: 0x900 - 0x9ff */

/* next type range number available 0x1000 */

/* Common MACROS and library functions */
/* make header = sizeof(type, flags, size) */
#define KCDATA_ITEM_HEADER_SIZE         (sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t))
#define KCDATA_ITEM_TYPE(item)          (((kcdata_item_t)(item))->type)
#define KCDATA_ITEM_SIZE(item)          (((kcdata_item_t)(item))->size)
#define KCDATA_ITEM_FLAGS(item)          (((kcdata_item_t)(item))->flags)

#define KCDATA_ITEM_ARRAY_GET_EL_TYPE(item)   ((KCDATA_ITEM_FLAGS(item) >> 32) & UINT32_MAX)
#define KCDATA_ITEM_ARRAY_GET_EL_COUNT(item)  (KCDATA_ITEM_FLAGS(item) & UINT32_MAX)
#define KCDATA_ITEM_ARRAY_GET_EL_SIZE(item)   (KCDATA_ITEM_SIZE(item) / KCDATA_ITEM_ARRAY_GET_EL_COUNT(item))

#define KCDATA_CONTAINER_ID(item)             ((uint64_t)KCDATA_ITEM_FLAGS(item))

#define KCDATA_ITEM_NEXT_HEADER(item)   ((kcdata_item_t)((uint64_t)((uintptr_t)(item)) + KCDATA_ITEM_HEADER_SIZE + KCDATA_ITEM_SIZE(item)))

#define KCDATA_ITEM_FOREACH(head) for (; KCDATA_ITEM_TYPE(head) != KCDATA_TYPE_BUFFER_END; (head) = KCDATA_ITEM_NEXT_HEADER(head))

static inline kcdata_item_t
KCDATA_ITEM_FIND_TYPE(kcdata_item_t head, uint32_t type)
{
	KCDATA_ITEM_FOREACH(head)
	{
		if (KCDATA_ITEM_TYPE(head) == type) {
			break;
		}
	}
	return (KCDATA_ITEM_TYPE(head) == type) ? (kcdata_item_t)head : 0;
}



#endif /* _KERN_CDATA_H_ */
                                                                                                                                                                                                         kern_types.h                                                                                        0100644 0001750 0001750 00000015465 12567450747 034363  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef	_KERN_KERN_TYPES_H_
#define	_KERN_KERN_TYPES_H_

#include <stdint.h>
#include <mach/mach_types.h>
#include <mach/machine/vm_types.h>


typedef	void *event_t;		/* wait event */
#define		NO_EVENT			((event_t) 0)

typedef uint64_t event64_t;		/* 64 bit wait event */
#define		NO_EVENT64		((event64_t) 0)
#define		CAST_EVENT64_T(a_ptr)	((event64_t)((uintptr_t)(a_ptr)))

/*
 *	Possible wait_result_t values.
 */
typedef int wait_result_t;
#define THREAD_WAITING		-1		/* thread is waiting */
#define THREAD_AWAKENED		0		/* normal wakeup */
#define THREAD_TIMED_OUT	1		/* timeout expired */
#define THREAD_INTERRUPTED	2		/* aborted/interrupted */
#define THREAD_RESTART		3		/* restart operation entirely */
#define THREAD_NOT_WAITING      10              /* thread didn't need to wait */

typedef	void (*thread_continue_t)(void *, wait_result_t);
#define	THREAD_CONTINUE_NULL	((thread_continue_t) 0)

/*
 * Interruptible flag for waits.
 *
 * THREAD_UNINT: Uninterruptible wait
 *   Wait will only end when someone explicitly wakes up the thread, or if the
 *   wait timeout expires.
 *
 *   Use this state if the system as a whole cannot recover from a thread being
 *   interrupted out of the wait.
 *
 * THREAD_INTERRUPTIBLE:
 *    Wait will end if someone explicitly wakes up the thread, the wait timeout
 *    expires,  or the current thread is being terminated.
 *
 *    This value can be used when your operation may not be cleanly restartable
 *    for the current process or thread (i.e. the loss of state would be only visible
 *    to the current client).  Since the thread is exiting anyways, you're willing
 *    to cut the operation short.  The system as a whole must be able to cleanly
 *    deal with the interruption (i.e. remain in a consistent and recoverable state).
 *
 * THREAD_ABORTSAFE:
 *    Wait will end if someone explicitly wakes up the thread, the wait timeout
 *    expires, the current thread is being terminated, if any signal arrives for
 *    the task, or thread_abort_safely() is called on the thread.
 *
 *    Using this value means that you are willing to be interrupted in the face
 *    of any user signal, and safely rewind the thread back to the user/kernel
 *    boundary.  Many syscalls will try to restart the operation they were performing
 *    after the signal has been handled.
 *
 *    You must provide this value for any unbounded wait - otherwise you will
 *    pend user signals forever.
 *
 * Thread interrupt mask:
 *
 *   The current maximum interruptible state for the thread, as set by
 *   thread_interrupt_level(), will limit the conditions that will cause a wake.
 *   This is useful for code that can't be interrupted to set before calling code
 *   that doesn't know that.
 *
 * Thread termination vs safe abort:
 *
 *    Termination abort: thread_abort(), thread_terminate()
 *
 *    A termination abort is sticky.  Once a thread is marked for termination, every
 *    THREAD_INTERRUPTIBLE wait will return immediately with THREAD_INTERRUPTED
 *    until the thread successfully exits.
 *
 *    Safe abort: thread_abort_safely()
 *
 *    A safe abort is not sticky.  The current wait, (or the next wait if the thread
 *    is not currently waiting) will be interrupted, but then the abort condition is cleared.
 *    The next wait will sleep as normal. Safe aborts only have a single effect.
 *
 *    The path back to the user/kernel boundary must not make any further unbounded
 *    wait calls. The waiter should detect the THREAD_INTERRUPTED return code
 *    from an ABORTSAFE wait and return an error code that causes its caller
 *    to understand that the current operation has been interrupted, and its
 *    caller should return a similar error code, and so on until the
 *    user/kernel boundary is reached.  For Mach, the error code is usually KERN_ABORTED,
 *    for BSD it is EINTR.
 *
 *    Debuggers rely on the safe abort mechanism - a signaled thread must return to
 *    the AST at the user/kernel boundary for the debugger to finish attaching.
 *
 *    No wait/block will ever disappear a thread out from under the waiter. The block
 *    call will always either return or call the passed in continuation.
 */
typedef int wait_interrupt_t;
#define THREAD_UNINT			0		/* not interruptible      */
#define THREAD_INTERRUPTIBLE	1		/* may not be restartable */
#define THREAD_ABORTSAFE		2		/* abortable safely       */

typedef int wait_timeout_urgency_t;
#define TIMEOUT_URGENCY_SYS_NORMAL	0x00		/* use default leeway thresholds for system */
#define TIMEOUT_URGENCY_SYS_CRITICAL	0x01		/* use critical leeway thresholds for system */
#define TIMEOUT_URGENCY_SYS_BACKGROUND	0x02		/* use background leeway thresholds for system */

#define TIMEOUT_URGENCY_USER_MASK	0x10		/* mask to identify user timeout urgency classes */
#define TIMEOUT_URGENCY_USER_NORMAL	0x10		/* use default leeway thresholds for user */
#define TIMEOUT_URGENCY_USER_CRITICAL	0x11		/* use critical leeway thresholds for user */
#define TIMEOUT_URGENCY_USER_BACKGROUND	0x12		/* use background leeway thresholds for user */

#define TIMEOUT_URGENCY_MASK		0x13		/* mask to identify timeout urgency */

#define TIMEOUT_URGENCY_LEEWAY		0x20		/* don't ignore provided leeway value */

#define TIMEOUT_URGENCY_FIRST_AVAIL	0x40		/* first available bit outside of urgency mask/leeway */
#define	TIMEOUT_URGENCY_RATELIMITED	0x80

/*
 * Timeout and deadline tokens for waits.
 * The following tokens define common values for leeway and deadline parameters.
 */
#define TIMEOUT_NO_LEEWAY		(0ULL)
#define TIMEOUT_WAIT_FOREVER		(0ULL)


#endif	/* _KERN_KERN_TYPES_H_ */
                                                                                                                                                                                                           kext_alloc.h                                                                                        0100644 0001750 0001750 00000003155 12567450747 034316  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef _KEXT_ALLOC_H_
#define _KEXT_ALLOC_H_

#include <mach/kern_return.h>
#include <mach/vm_types.h>

__BEGIN_DECLS

void kext_alloc_init(void);

kern_return_t kext_alloc(vm_offset_t *addr, vm_size_t size, boolean_t fixed);

void kext_free(vm_offset_t addr, vm_size_t size);

__END_DECLS

#endif /* _KEXT_ALLOC_H_ */

                                                                                                                                                                                                                                                                                                                                                                                                                   kpc.h                                                                                               0100644 0001750 0001750 00000026470 12567450747 032753  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __KERN_KPC_H__
#define __KERN_KPC_H__

/* Kernel interfaces to KPC PMC infrastructure. */

#include <machine/machine_kpc.h>
#include <kern/thread.h> /* thread_* */

/* cross-platform class constants */
#define KPC_CLASS_FIXED         (0)
#define KPC_CLASS_CONFIGURABLE  (1)
#define KPC_CLASS_POWER         (2)
#define KPC_CLASS_RAWPMU        (3)

#define KPC_CLASS_FIXED_MASK         (1u << KPC_CLASS_FIXED)
#define KPC_CLASS_CONFIGURABLE_MASK  (1u << KPC_CLASS_CONFIGURABLE)
#define KPC_CLASS_POWER_MASK         (1u << KPC_CLASS_POWER)
#define KPC_CLASS_RAWPMU_MASK        (1u << KPC_CLASS_RAWPMU)

#define KPC_PMU_ERROR     (0)
#define KPC_PMU_INTEL_V3  (1)
#define KPC_PMU_ARM_APPLE (2)
#define KPC_PMU_INTEL_V2  (3)
#define KPC_PMU_ARM_V2    (4)

#define KPC_ALL_CPUS (1u << 31)

/* action id setters/getters */
#define FIXED_ACTIONID(ctr)			(kpc_actionid[(ctr)])
#define CONFIGURABLE_ACTIONID(ctr)		(kpc_actionid[(ctr) + kpc_fixed_count()])

/* reload counter setters/getters */
#define FIXED_RELOAD(ctr)			(current_cpu_datap()->cpu_kpc_reload[(ctr)])
#define FIXED_RELOAD_CPU(cpu, ctr)		(cpu_datap(cpu)->cpu_kpc_reload[(ctr)])
#define CONFIGURABLE_RELOAD(ctr)		(current_cpu_datap()->cpu_kpc_reload[(ctr) + kpc_fixed_count()])
#define CONFIGURABLE_RELOAD_CPU(cpu, ctr)	(cpu_datap(cpu)->cpu_kpc_reload[(ctr) + kpc_fixed_count()])

/* shadow counter setters/getters */
#define FIXED_SHADOW(ctr)			(current_cpu_datap()->cpu_kpc_shadow[(ctr)])
#define FIXED_SHADOW_CPU(cpu, ctr)		(cpu_datap(cpu)->cpu_kpc_shadow[(ctr)])
#define CONFIGURABLE_SHADOW(ctr) 		(current_cpu_datap()->cpu_kpc_shadow[(ctr) + kpc_fixed_count()])
#define CONFIGURABLE_SHADOW_CPU(cpu, ctr) 	(cpu_datap(cpu)->cpu_kpc_shadow[(ctr) + kpc_fixed_count()])

/**
 * Callback for notification when PMCs are acquired/released by a task. The
 * argument is equal to TRUE if the Power Manager (PM) can use its reserved PMCs.
 * Otherwise, the argument is equal to FALSE.
 */
typedef void (*kpc_pm_handler_t)(boolean_t);

/*
 * Register a CPU to kpc and allocate its buffers.
 *
 * @param cpu_data
 * CPU data associated to the CPU being registered.
 *
 * @return
 * TRUE if buffers are correctly allocated, FALSE otherwise.
 */
struct cpu_data;
extern boolean_t kpc_register_cpu(struct cpu_data *cpu_data);

/* bootstrap */
extern void kpc_init(void);

/* common initialization */
extern void kpc_common_init(void);

/* Architecture specific initialisation */
extern void kpc_arch_init(void);

/* Thread counting initialization */
extern void kpc_thread_init(void);

/* Get the bitmask of available classes */
extern uint32_t kpc_get_classes(void);

/* Get the bitmask of currently running counter classes  */
extern uint32_t kpc_get_running(void);

/* Get the version of KPC that's being run */
extern int kpc_get_pmu_version(void);

/* Set the bitmask of currently running counter classes. Specify
 * classes = 0 to stop counters
 */
extern int kpc_set_running(uint32_t classes);

/* Read CPU counters */
extern int kpc_get_cpu_counters(boolean_t all_cpus, uint32_t classes, 
                                int *curcpu, uint64_t *buf);

/* Read shadow counters */
extern int kpc_get_shadow_counters( boolean_t all_cpus, uint32_t classes,
                                    int *curcpu, uint64_t *buf );

/* Read current thread's counter accumulations */
extern int kpc_get_curthread_counters(uint32_t *inoutcount, uint64_t *buf);

/* Given a config, how many counters and config registers there are */
extern uint32_t kpc_get_counter_count(uint32_t classes);
extern uint32_t kpc_get_config_count(uint32_t classes);

/* enable/disable thread counting */
extern uint32_t kpc_get_thread_counting(void);
extern int      kpc_set_thread_counting(uint32_t classes);

/* get and set config registers */
extern int kpc_get_config(uint32_t classes, kpc_config_t *current_config);
extern int kpc_set_config(uint32_t classes, kpc_config_t *new_config);

/* get and set PMI period */
extern int kpc_get_period(uint32_t classes, uint64_t *period);
extern int kpc_set_period(uint32_t classes, uint64_t *period);

/* get and set kperf actionid */
extern int kpc_get_actionid(uint32_t classes, uint32_t *actionid);
extern int kpc_set_actionid(uint32_t classes, uint32_t *actionid);

/* hooks on thread create and delete */
extern void kpc_thread_create(thread_t thread);
extern void kpc_thread_destroy(thread_t thread);

/* allocate a buffer big enough for all counters */
extern uint64_t *kpc_counterbuf_alloc(void);
extern void      kpc_counterbuf_free(uint64_t*);

/* whether we're currently accounting into threads */
extern int kpc_threads_counting;

/* AST callback for KPC */
extern void kpc_thread_ast_handler( thread_t thread );

/* context switch accounting between two threads */
extern void kpc_switch_context( thread_t old_thread, thread_t new_thread );

/* acquire/release the counters used by the Power Manager */
extern int kpc_force_all_ctrs( task_t task, int val );
extern int kpc_get_force_all_ctrs( void );

/* arch-specific routine for acquire/release the counters used by the Power Manager */
extern int kpc_force_all_ctrs_arch( task_t task, int val );

extern int kpc_set_sw_inc( uint32_t mask );

/* disable/enable whitelist of allowed events */
extern int kpc_get_whitelist_disabled( void );
extern int kpc_disable_whitelist( int val );

/*
 * Register the Power Manager as a PMCs user.
 *
 * This is a deprecated function used by old Power Managers, new Power Managers
 * should use the @em kpc_reserve_pm_counters() function. This function actually
 * calls @em kpc_reserve_pm_counters() with the following arguments:
 * 	- handler	= handler
 * 	- pmc_mask	= 0x83
 * 	- custom_config	= TRUE
 *
 * See @em kpc_reserve_pm_counters() for more details about the return value.
 */
extern boolean_t kpc_register_pm_handler(void (*handler)(boolean_t));

/*
 * Register the Power Manager as a PMCs user.
 *
 * @param handler
 * Notification callback to use when PMCs are acquired/released by a task.
 *
 * @param pmc_mask
 * Bitmask of the configurable PMCs used by the Power Manager. The number of bits
 * set must less or equal than the number of configurable counters
 * available on the SoC.
 *
 * @param custom_config
 * If custom_config=TRUE, the legacy sharing mode is enabled, otherwise the
 * Modern Sharing mode is enabled. These modes are explained in more details in
 * the kperf documentation.
 *
 * @return
 * FALSE if a task has acquired all the PMCs, otherwise TRUE and the Power
 * Manager can start using the reserved PMCs.
 */
extern boolean_t kpc_reserve_pm_counters(uint64_t pmc_mask, kpc_pm_handler_t handler,
                                         boolean_t custom_config);

/*
 * Unregister the Power Manager as a PMCs user, and release the previously
 * reserved counters.
 */
extern void kpc_release_pm_counters(void);

/*
 * Is the PMU used by both the power manager and userspace?
 *
 * This is true when the power manager has been registered. It disables certain
 * counter configurations (like RAWPMU) that are incompatible with sharing
 * counters.
 */
extern boolean_t kpc_multiple_clients(void);

/*
 * Is kpc controlling the fixed counters?
 *
 * This returns false when the power manager has requested custom configuration
 * control.
 */
extern boolean_t kpc_controls_fixed_counters(void);

/*
 * Is kpc controlling a specific PMC ?
 */
extern boolean_t kpc_controls_counter(uint32_t ctr);


extern void kpc_idle(void);
extern void kpc_idle_exit(void);


/*
 * KPC PRIVATE
 */

extern uint32_t kpc_actionid[KPC_MAX_COUNTERS];

/* handler for mp operations */
struct kpc_config_remote {
	uint32_t classes;
	kpc_config_t *configv;
	uint64_t pmc_mask;
};

/* handler for mp operations */
struct kpc_running_remote {
	uint32_t	classes;		/* classes to run */
	uint64_t	cfg_target_mask;	/* configurable counters selected */
	uint64_t	cfg_state_mask;		/* configurable counters new state */
};

/* handler for mp operations */
struct kpc_get_counters_remote {
	uint32_t classes;
	uint32_t nb_counters;
	uint32_t buf_stride;
	uint64_t *buf;
};

extern int kpc_get_all_cpus_counters(uint32_t classes, int *curcpu, uint64_t *buf);
extern int kpc_get_curcpu_counters(uint32_t classes, int *curcpu, uint64_t *buf);
extern int kpc_get_fixed_counters(uint64_t *counterv);
extern int kpc_get_configurable_counters(uint64_t *counterv, uint64_t pmc_mask);
extern boolean_t kpc_is_running_fixed(void);
extern boolean_t kpc_is_running_configurable(uint64_t pmc_mask);
extern uint32_t kpc_fixed_count(void);
extern uint32_t kpc_configurable_count(void);
extern uint32_t kpc_fixed_config_count(void);
extern uint32_t kpc_configurable_config_count(uint64_t pmc_mask);
extern uint32_t kpc_rawpmu_config_count(void);
extern int kpc_get_fixed_config(kpc_config_t *configv);
extern int kpc_get_configurable_config(kpc_config_t *configv, uint64_t pmc_mask);
extern int kpc_get_rawpmu_config(kpc_config_t *configv);
extern uint64_t kpc_fixed_max(void);
extern uint64_t kpc_configurable_max(void);
extern int kpc_set_config_arch(struct kpc_config_remote *mp_config);
extern int kpc_set_period_arch(struct kpc_config_remote *mp_config);
extern void kpc_sample_kperf(uint32_t actionid);
extern int kpc_set_running_arch(struct kpc_running_remote *mp_config);


/*
 * Helpers
 */

/* count the number of bits set */
extern uint8_t kpc_popcount(uint64_t value);

/* for a set of classes, retrieve the configurable PMCs mask */
extern uint64_t kpc_get_configurable_pmc_mask(uint32_t classes);


/* Interface for kexts to publish a kpc interface */
struct kpc_driver
{
	uint32_t (*get_classes)(void);
	uint32_t (*get_running)(void);
	int      (*set_running)(uint32_t classes);
	int      (*get_cpu_counters)(boolean_t all_cpus, uint32_t classes, 
	                             int *curcpu, uint64_t *buf);
	int      (*get_curthread_counters)(uint32_t *inoutcount, uint64_t *buf);
	uint32_t (*get_counter_count)(uint32_t classes);
	uint32_t (*get_config_count)(uint32_t classes);
	int      (*get_config)(uint32_t classes, kpc_config_t *current_config);
	int      (*set_config)(uint32_t classes, kpc_config_t *new_config);
	int      (*get_period)(uint32_t classes, uint64_t *period);
	int      (*set_period)(uint32_t classes, uint64_t *period);
};

#endif /* __KERN_KPC_H__ */
                                                                                                                                                                                                        ledger.h                                                                                            0100644 0001750 0001750 00000004215 12567450747 033431  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2010 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */

#ifndef _KERN_LEDGER_H_
#define _KERN_LEDGER_H_

#define	LEDGER_INFO		0
#define	LEDGER_ENTRY_INFO	1
#define	LEDGER_TEMPLATE_INFO	2
#define	LEDGER_LIMIT		3

#define	LEDGER_NAME_MAX	32

struct ledger_info {
	char	li_name[LEDGER_NAME_MAX];
	int64_t	li_id;
	int64_t	li_entries;
};

struct ledger_template_info {
	char		lti_name[LEDGER_NAME_MAX];
	char		lti_group[LEDGER_NAME_MAX];
	char		lti_units[LEDGER_NAME_MAX];
};

struct ledger_entry_info {
        int64_t		lei_balance;
        int64_t		lei_credit;
        int64_t		lei_debit;
        uint64_t	lei_limit;
	uint64_t	lei_refill_period;	/* In milliseconds */
	uint64_t	lei_last_refill;	/* Time since last refill */
};

struct ledger_limit_args {
	char		lla_name[LEDGER_NAME_MAX];
        uint64_t	lla_limit;
        uint64_t	lla_refill_period;
};


#endif	/* _KERN_LEDGER_H_ */
                                                                                                                                                                                                                                                                                                                                                                                   locks.h                                                                                             0100644 0001750 0001750 00000015515 12567450747 033307  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _KERN_LOCKS_H_
#define _KERN_LOCKS_H_

#include	<sys/cdefs.h>
#include	<sys/appleapiopts.h>
#include	<mach/boolean.h>
#include	<mach/mach_types.h>
#include	<kern/kern_types.h>
#include	<machine/locks.h>


typedef	unsigned int		lck_sleep_action_t;

#define	LCK_SLEEP_DEFAULT	0x00	/* Release the lock while waiting for the event, then reclaim */
									/* RW locks are returned in the same mode */
#define	LCK_SLEEP_UNLOCK	0x01	/* Release the lock and return unheld */
#define	LCK_SLEEP_SHARED	0x02	/* Reclaim the lock in shared mode (RW only) */
#define	LCK_SLEEP_EXCLUSIVE	0x04	/* Reclaim the lock in exclusive mode (RW only) */
#define	LCK_SLEEP_SPIN		0x08	/* Reclaim the lock in spin mode (mutex only) */
#define	LCK_SLEEP_PROMOTED_PRI	0x10	/* Sleep at a promoted priority */

#define	LCK_SLEEP_MASK		0x1f	/* Valid actions */

typedef struct __lck_grp__ lck_grp_t;

typedef struct __lck_grp_attr__ lck_grp_attr_t;

#define LCK_GRP_ATTR_NULL	(lck_grp_attr_t *)0

__BEGIN_DECLS

extern	lck_grp_attr_t	*lck_grp_attr_alloc_init(
									void);

extern	void			lck_grp_attr_setdefault(
									lck_grp_attr_t	*attr);

extern	void			lck_grp_attr_setstat(
									lck_grp_attr_t  *attr);

extern	void			lck_grp_attr_free(
									lck_grp_attr_t	*attr);

extern	lck_grp_t		*lck_grp_alloc_init(
									const char*		grp_name,
									lck_grp_attr_t	*attr);

__END_DECLS


__BEGIN_DECLS

extern void				lck_grp_free(
									lck_grp_t		*grp);

__END_DECLS

typedef struct __lck_attr__ lck_attr_t;

#define LCK_ATTR_NULL (lck_attr_t *)0

__BEGIN_DECLS

extern	lck_attr_t		*lck_attr_alloc_init(
									void);

extern	void			lck_attr_setdefault(
									lck_attr_t		*attr);

extern	void			lck_attr_setdebug(
									lck_attr_t		*attr);

extern	void			lck_attr_cleardebug(
									lck_attr_t		*attr);


extern	void			lck_attr_free(
									lck_attr_t		*attr);

#define decl_lck_spin_data(class,name)     class lck_spin_t name;

extern lck_spin_t		*lck_spin_alloc_init(
									lck_grp_t		*grp,
									lck_attr_t		*attr);

extern void				lck_spin_init(
									lck_spin_t		*lck, 
									lck_grp_t		*grp,
									lck_attr_t		*attr);

extern void				lck_spin_lock(
									lck_spin_t		*lck);

extern void				lck_spin_unlock(
									lck_spin_t		*lck);

extern void				lck_spin_destroy(
									lck_spin_t		*lck,
									lck_grp_t		*grp);

extern void				lck_spin_free(
									lck_spin_t		*lck,
									lck_grp_t		*grp);

extern wait_result_t	lck_spin_sleep(
									lck_spin_t			*lck,
									lck_sleep_action_t	lck_sleep_action,
									event_t				event,
									wait_interrupt_t	interruptible);

extern wait_result_t	lck_spin_sleep_deadline(
									lck_spin_t			*lck,
									lck_sleep_action_t	lck_sleep_action,
									event_t				event,
									wait_interrupt_t	interruptible,
									uint64_t			deadline);



#define decl_lck_mtx_data(class,name)     class lck_mtx_t name;

extern lck_mtx_t		*lck_mtx_alloc_init(
									lck_grp_t		*grp,
									lck_attr_t		*attr);

extern void				lck_mtx_init(
									lck_mtx_t		*lck, 
									lck_grp_t		*grp,
									lck_attr_t		*attr);
extern void				lck_mtx_lock(
									lck_mtx_t		*lck);

extern void				lck_mtx_unlock(
									lck_mtx_t		*lck);

extern void				lck_mtx_destroy(
									lck_mtx_t		*lck,
									lck_grp_t		*grp);

extern void				lck_mtx_free(
									lck_mtx_t		*lck,
									lck_grp_t		*grp);

extern wait_result_t	lck_mtx_sleep(
									lck_mtx_t			*lck,
									lck_sleep_action_t	lck_sleep_action,
									event_t				event,
									wait_interrupt_t	interruptible);

extern wait_result_t	lck_mtx_sleep_deadline(
									lck_mtx_t			*lck,
									lck_sleep_action_t	lck_sleep_action,
									event_t				event,
									wait_interrupt_t	interruptible,
									uint64_t			deadline);


extern void				lck_mtx_assert(
									lck_mtx_t		*lck,
									unsigned int	type);

__END_DECLS

#define	LCK_MTX_ASSERT_OWNED	0x01
#define	LCK_MTX_ASSERT_NOTOWNED	0x02


#define decl_lck_rw_data(class,name)     class lck_rw_t name;

typedef unsigned int	 lck_rw_type_t;

#define	LCK_RW_TYPE_SHARED			0x01
#define	LCK_RW_TYPE_EXCLUSIVE		0x02


__BEGIN_DECLS

extern lck_rw_t			*lck_rw_alloc_init(
									lck_grp_t		*grp,
									lck_attr_t		*attr);

extern void				lck_rw_init(
									lck_rw_t		*lck, 
									lck_grp_t		*grp,
									lck_attr_t		*attr);

extern void				lck_rw_lock(
									lck_rw_t		*lck,
									lck_rw_type_t	lck_rw_type);

extern void				lck_rw_unlock(
									lck_rw_t		*lck,
									lck_rw_type_t	lck_rw_type);

extern void				lck_rw_lock_shared(
									lck_rw_t		*lck);

extern void				lck_rw_unlock_shared(
									lck_rw_t		*lck);

extern void				lck_rw_lock_exclusive(
									lck_rw_t		*lck);

extern void				lck_rw_unlock_exclusive(
									lck_rw_t		*lck);



extern void				lck_rw_destroy(
									lck_rw_t		*lck,
									lck_grp_t		*grp);

extern void				lck_rw_free(
									lck_rw_t		*lck,
									lck_grp_t		*grp);

extern wait_result_t	lck_rw_sleep(
									lck_rw_t			*lck,
									lck_sleep_action_t	lck_sleep_action,
									event_t				event,
									wait_interrupt_t	interruptible);

extern wait_result_t	lck_rw_sleep_deadline(
									lck_rw_t			*lck,
									lck_sleep_action_t	lck_sleep_action,
									event_t				event,
									wait_interrupt_t	interruptible,
									uint64_t			deadline);

extern boolean_t		lck_rw_lock_shared_to_exclusive(
									lck_rw_t		*lck);

extern void				lck_rw_lock_exclusive_to_shared(
									lck_rw_t		*lck);

extern boolean_t		lck_rw_try_lock(
									lck_rw_t		*lck,
									lck_rw_type_t	lck_rw_type);


__END_DECLS

#endif /* _KERN_LOCKS_H_ */
                                                                                                                                                                                   macro_help.h                                                                                        0100644 0001750 0001750 00000005443 12567450750 034276  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	File:	kern/macro_help.h
 *
 *	Provide help in making lint-free macro routines
 *
 */  

#ifndef	_KERN_MACRO_HELP_H_
#define	_KERN_MACRO_HELP_H_

#include <mach/boolean.h>

#ifdef	lint
boolean_t	NEVER;
boolean_t	ALWAYS;
#else	/* lint */
#define		NEVER		FALSE
#define		ALWAYS		TRUE
#endif	/* lint */

#define		MACRO_BEGIN	do {
#define		MACRO_END	} while (NEVER)

#define		MACRO_RETURN	if (ALWAYS) return

#endif	/* _KERN_MACRO_HELP_H_ */
                                                                                                                                                                                                                             processor.h                                                                                         0100644 0001750 0001750 00000005376 12567450750 034211  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */

/*
 *	processor.h:	Processor and processor-related definitions.
 */

#ifndef	_KERN_PROCESSOR_H_
#define	_KERN_PROCESSOR_H_

#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <kern/kern_types.h>

#include <sys/cdefs.h>


__BEGIN_DECLS

extern void		pset_deallocate(
					processor_set_t	pset);

extern void		pset_reference(
					processor_set_t	pset);

__END_DECLS



#endif	/* _KERN_PROCESSOR_H_ */
                                                                                                                                                                                                                                                                  queue.h                                                                                             0100644 0001750 0001750 00000063431 12567450750 033312  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon rights
 * to redistribute these changes.
 */
/*
 */
/*
 *	File:	queue.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1985
 *
 *	Type definitions for generic queues.
 *
 */

#ifndef	_KERN_QUEUE_H_
#define	_KERN_QUEUE_H_

#include <mach/mach_types.h>
#include <kern/macro_help.h>

#include <sys/cdefs.h>

__BEGIN_DECLS

/*
 * Queue Management APIs
 *
 * There are currently two subtly different methods of maintining
 * a queue of objects. Both APIs are contained in this file, and
 * unfortunately overlap.
 * (there is also a third way maintained in bsd/sys/queue.h)
 *
 * Both methods use a common queue head and linkage pattern:
 * 	The head of a queue is declared as:
 * 		queue_head_t q_head;
 *
 * 	Elements in this queue are chained together using
 * 	struct queue_entry objects embedded within a structure:
 * 		struct some_data {
 * 			int field1;
 * 			int field2;
 * 			...
 * 			queue_chain_t link;
 * 			...
 * 			int last_field;
 * 		};
 * 	struct some_data is referred to as the queue "element."
 * 	(note that queue_chain_t is typedef'd to struct queue_entry)
 *
 * IMPORTANT: The two queue iteration methods described below are not
 *            compatible with one another. You must choose one and be careful
 *            to use only the supported APIs for that method.
 *
 * Method 1: chaining of queue_chain_t (linkage chains)
 * 	This method uses the next and prev pointers of the struct queue_entry
 * 	linkage object embedded in a queue element to point to the next or
 * 	previous queue_entry structure in the chain. The head of the queue
 * 	(the queue_head_t object) will point to the first and last
 * 	struct queue_entry object, and both the next and prev pointer will
 * 	point back to the head if the queue is empty.
 *
 * 	This method is the most flexible method of chaining objects together
 * 	as it allows multiple chains through a given object, by embedding
 * 	multiple queue_chain_t objects in the structure, while simultaneously
 * 	providing fast removal and insertion into the queue using only
 * 	struct queue_entry object pointers.
 *
 * 	++ Valid APIs for this style queue ++
 * 	-------------------------------------
 * 		[C] queue_init
 * 		[C] queue_first
 * 		[C] queue_next
 * 		[C] queue_last
 * 		[C] queue_prev
 * 		[C] queue_end
 * 		[C] queue_empty
 *
 * 		[1] enqueue
 * 		[1] dequeue
 * 		[1] enqueue_head
 * 		[1] enqueue_tail
 * 		[1] dequeue_head
 * 		[1] dequeue_tail
 * 		[1] remqueue
 * 		[1] insque
 * 		[1] remque
 * 		[1] re_queue
 * 		[1] re_queue_tail
 * 		[1] movqueue
 * 		[1] qe_element
 * 		[1] qe_foreach
 * 		[1] qe_foreach_safe
 * 		[1] qe_foreach_element
 * 		[1] qe_foreach_element_safe
 *
 * Method 2: chaining of elements (element chains)
 * 	This method uses the next and prev pointers of the struct queue_entry
 * 	linkage object embedded in a queue element to point to the next or
 * 	previous queue element (not another queue_entry). The head of the
 * 	queue will point to the first and last queue element (struct some_data
 * 	from the above example) NOT the embedded queue_entry structure. The
 * 	first queue element will have a prev pointer that points to the
 * 	queue_head_t, and the last queue element will have a next pointer
 * 	that points to the queue_head_t.
 *
 * 	This method requires knowledge of the queue_head_t of the queue on
 * 	which an element resides in order to remove the element. Iterating
 * 	through the elements of the queue is also more cumbersome because
 * 	a check against the head pointer plus a cast then offset operation
 * 	must be performed at each step of the iteration.
 *
 * 	++ Valid APIs for this style queue ++
 * 	-------------------------------------
 * 		[C] queue_init
 * 		[C] queue_first
 * 		[C] queue_next
 * 		[C] queue_last
 * 		[C] queue_prev
 * 		[C] queue_end
 * 		[C] queue_empty
 *
 * 		[2] queue_enter
 * 		[2] queue_enter_first
 * 		[2] queue_insert_before
 * 		[2] queue_insert_after
 * 		[2] queue_field
 * 		[2] queue_remove
 * 		[2] queue_remove_first
 * 		[2] queue_remove_last
 * 		[2] queue_assign
 * 		[2] queue_new_head
 * 		[2] queue_iterate
 *
 * Legend:
 * 	[C] -> API common to both methods
 * 	[1] -> API used only in method 1 (linkage chains)
 * 	[2] -> API used only in method 2 (element chains)
 */

/*
 *	A generic doubly-linked list (queue).
 */

struct queue_entry {
	struct queue_entry	*next;		/* next element */
	struct queue_entry	*prev;		/* previous element */

};

typedef struct queue_entry	*queue_t;
typedef	struct queue_entry	queue_head_t;
typedef	struct queue_entry	queue_chain_t;
typedef	struct queue_entry	*queue_entry_t;

/*
 *	enqueue puts "elt" on the "queue".
 *	dequeue returns the first element in the "queue".
 *	remqueue removes the specified "elt" from its queue.
 */

#define enqueue(queue,elt)	enqueue_tail(queue, elt)
#define	dequeue(queue)		dequeue_head(queue)

#define __QUEUE_ELT_VALIDATE(elt) do { } while (0)
#define __DEQUEUE_ELT_CLEANUP(elt) do { } while(0)

static __inline__ void
enqueue_head(
	queue_t		que,
	queue_entry_t	elt)
{
	queue_entry_t	old_head;

	__QUEUE_ELT_VALIDATE((queue_entry_t)que);
	old_head = que->next;
	elt->next = old_head;
	elt->prev = que;
	old_head->prev = elt;
	que->next = elt;
}

static __inline__ void
enqueue_tail(
		queue_t		que,
		queue_entry_t	elt)
{
	queue_entry_t	old_tail;

	__QUEUE_ELT_VALIDATE((queue_entry_t)que);
	old_tail = que->prev;
	elt->next = que;
	elt->prev = old_tail;
	old_tail->next = elt;
	que->prev = elt;
}

static __inline__ queue_entry_t
dequeue_head(
	queue_t	que)
{
	queue_entry_t	elt = (queue_entry_t) 0;
	queue_entry_t	new_head;

	if (que->next != que) {
		elt = que->next;
		__QUEUE_ELT_VALIDATE(elt);
		new_head = elt->next; /* new_head may point to que if elt was the only element */
		new_head->prev = que;
		que->next = new_head;
		__DEQUEUE_ELT_CLEANUP(elt);
	}

	return (elt);
}

static __inline__ queue_entry_t
dequeue_tail(
	queue_t	que)
{
	queue_entry_t	elt = (queue_entry_t) 0;
	queue_entry_t	new_tail;

	if (que->prev != que) {
		elt = que->prev;
		__QUEUE_ELT_VALIDATE(elt);
		new_tail = elt->prev; /* new_tail may point to queue if elt was the only element */
		new_tail->next = que;
		que->prev = new_tail;
		__DEQUEUE_ELT_CLEANUP(elt);
	}

	return (elt);
}

static __inline__ void
remqueue(
	queue_entry_t	elt)
{
	queue_entry_t	next_elt, prev_elt;

	__QUEUE_ELT_VALIDATE(elt);
	next_elt = elt->next;
	prev_elt = elt->prev; /* next_elt may equal prev_elt (and the queue head) if elt was the only element */
	next_elt->prev = prev_elt;
	prev_elt->next = next_elt;
	__DEQUEUE_ELT_CLEANUP(elt);
}

static __inline__ void
insque(
	queue_entry_t	entry,
	queue_entry_t	pred)
{
	queue_entry_t	successor;

	__QUEUE_ELT_VALIDATE(pred);
	successor = pred->next;
	entry->next = successor;
	entry->prev = pred;
	successor->prev = entry;
	pred->next = entry;
}

static __inline__ void
remque(
	queue_entry_t elt)
{
	queue_entry_t	next_elt, prev_elt;

	__QUEUE_ELT_VALIDATE(elt);
	next_elt = elt->next;
	prev_elt = elt->prev; /* next_elt may equal prev_elt (and the queue head) if elt was the only element */
	next_elt->prev = prev_elt;
	prev_elt->next = next_elt;
	__DEQUEUE_ELT_CLEANUP(elt);
}

/*
 *	Function:	re_queue_head
 *	Parameters:
 *		queue_t que       : queue onto which elt will be pre-pended
 *		queue_entry_t elt : element to re-queue
 *	Description:
 *		Remove elt from its current queue and put it onto the
 *		head of a new queue
 *	Note:
 *		This should only be used with Method 1 queue iteration (linkage chains)
 */
static __inline__ void
re_queue_head(queue_t que, queue_entry_t elt)
{
	queue_entry_t	n_elt, p_elt;

	__QUEUE_ELT_VALIDATE(elt);
	__QUEUE_ELT_VALIDATE((queue_entry_t)que);

	/* remqueue */
	n_elt = elt->next;
	p_elt = elt->prev; /* next_elt may equal prev_elt (and the queue head) if elt was the only element */
	n_elt->prev = p_elt;
	p_elt->next = n_elt;

	/* enqueue_head */
	n_elt = que->next;
	elt->next = n_elt;
	elt->prev = que;
	n_elt->prev = elt;
	que->next = elt;
}

/*
 *	Function:	re_queue_tail
 *	Parameters:
 *		queue_t que       : queue onto which elt will be appended
 *		queue_entry_t elt : element to re-queue
 *	Description:
 *		Remove elt from its current queue and put it onto the
 *		end of a new queue
 *	Note:
 *		This should only be used with Method 1 queue iteration (linkage chains)
 */
static __inline__ void
re_queue_tail(queue_t que, queue_entry_t elt)
{
	queue_entry_t	n_elt, p_elt;

	__QUEUE_ELT_VALIDATE(elt);
	__QUEUE_ELT_VALIDATE((queue_entry_t)que);

	/* remqueue */
	n_elt = elt->next;
	p_elt = elt->prev; /* next_elt may equal prev_elt (and the queue head) if elt was the only element */
	n_elt->prev = p_elt;
	p_elt->next = n_elt;

	/* enqueue_tail */
	p_elt = que->prev;
	elt->next = que;
	elt->prev = p_elt;
	p_elt->next = elt;
	que->prev = elt;
}

/*
 *	Macro:		qe_element
 *	Function:
 *		Convert a queue_entry_t to a queue element pointer.
 *		Get a pointer to the user-defined element containing
 *		a given queue_entry_t
 *	Header:
 *		<type> * qe_element(queue_entry_t qe, <type>, field)
 *			qe      - queue entry to convert
 *			<type>  - what's in the queue (e.g., struct some_data)
 *			<field> - is the chain field in <type>
 *	Note:
 *		Do not use pointer types for <type>
 */
#define	qe_element(qe, type, field) \
	((type *)((void *)((char *)(qe) - __offsetof(type, field))))

/*
 *	Macro:		qe_foreach
 *	Function:
 *		Iterate over each queue_entry_t structure.
 *		Generates a 'for' loop, setting 'qe' to
 *		each queue_entry_t in the queue.
 *	Header:
 *		qe_foreach(queue_entry_t qe, queue_t head)
 *			qe   - iteration variable
 *			head - pointer to queue_head_t (head of queue)
 *	Note:
 *		This should only be used with Method 1 queue iteration (linkage chains)
 */
#define qe_foreach(qe, head) \
	for (qe = (head)->next; qe != (head); qe = (qe)->next)

/*
 *	Macro:		qe_foreach_safe
 *	Function:
 *		Safely iterate over each queue_entry_t structure.
 *
 *		Use this iterator macro if you plan to remove the
 *		queue_entry_t, qe, from the queue during the
 *		iteration.
 *	Header:
 *		qe_foreach_safe(queue_entry_t qe, queue_t head)
 *			qe   - iteration variable
 *			head - pointer to queue_head_t (head of queue)
 *	Note:
 *		This should only be used with Method 1 queue iteration (linkage chains)
 */
#define qe_foreach_safe(qe, head) \
	for (queue_entry_t _ne = ((head)->next)->next, \
	         __ ## qe ## _unused_shadow __unused = (qe = (head)->next); \
	     qe != (head); \
	     qe = _ne, _ne = (qe)->next)

/*
 *	Macro:		qe_foreach_element
 *	Function:
 *		Iterate over each _element_ in a queue
 *		where each queue_entry_t points to another
 *		queue_entry_t, i.e., managed by the [de|en]queue_head/
 *		[de|en]queue_tail / remqueue / etc. function.
 *	Header:
 *		qe_foreach_element(<type> *elt, queue_t head, <field>)
 *			elt     - iteration variable
 *			<type>  - what's in the queue (e.g., struct some_data)
 *			<field> - is the chain field in <type>
 *	Note:
 *		This should only be used with Method 1 queue iteration (linkage chains)
 */
#define qe_foreach_element(elt, head, field) \
	for (elt = qe_element((head)->next, typeof(*(elt)), field); \
	     &((elt)->field) != (head); \
	     elt = qe_element((elt)->field.next, typeof(*(elt)), field))

/*
 *	Macro:		qe_foreach_element_safe
 *	Function:
 *		Safely iterate over each _element_ in a queue
 *		where each queue_entry_t points to another
 *		queue_entry_t, i.e., managed by the [de|en]queue_head/
 *		[de|en]queue_tail / remqueue / etc. function.
 *
 *		Use this iterator macro if you plan to remove the
 *		element, elt, from the queue during the iteration.
 *	Header:
 *		qe_foreach_element_safe(<type> *elt, queue_t head, <field>)
 *			elt     - iteration variable
 *			<type>  - what's in the queue (e.g., struct some_data)
 *			<field> - is the chain field in <type>
 *	Note:
 *		This should only be used with Method 1 queue iteration (linkage chains)
 */
#define qe_foreach_element_safe(elt, head, field) \
	for (typeof(*(elt)) *_nelt = qe_element(((head)->next)->next, typeof(*(elt)), field), \
	     *__ ## elt ## _unused_shadow __unused = \
	         (elt = qe_element((head)->next, typeof(*(elt)), field)); \
	     &((elt)->field) != (head); \
	     elt = _nelt, _nelt = qe_element((elt)->field.next, typeof(*(elt)), field)) \

/*
 *	Macro:		queue_init
 *	Function:
 *		Initialize the given queue.
 *	Header:
 *		void queue_init(q)
 *			queue_t		q;	\* MODIFIED *\
 */
#define queue_init(q)	\
MACRO_BEGIN		\
	(q)->next = (q);\
	(q)->prev = (q);\
MACRO_END

/*
 *	Macro:		queue_head_init
 *	Function:
 *		Initialize the given queue head
 *	Header:
 *		void queue_head_init(q)
 *			queue_head_t	q;	\* MODIFIED *\
 */
#define queue_head_init(q) \
	queue_init(&(q))

/*
 *	Macro:		queue_chain_init
 *	Function:
 *		Initialize the given queue chain element
 *	Header:
 *		void queue_chain_init(q)
 *			queue_chain_t	q;	\* MODIFIED *\
 */
#define queue_chain_init(q) \
	queue_init(&(q))

/*
 *	Macro:		queue_first
 *	Function:
 *		Returns the first entry in the queue,
 *	Header:
 *		queue_entry_t queue_first(q)
 *			queue_t	q;		\* IN *\
 */
#define	queue_first(q)	((q)->next)

/*
 *	Macro:		queue_next
 *	Function:
 *		Returns the entry after an item in the queue.
 *	Header:
 *		queue_entry_t queue_next(qc)
 *			queue_t qc;
 */
#define	queue_next(qc)	((qc)->next)

/*
 *	Macro:		queue_last
 *	Function:
 *		Returns the last entry in the queue.
 *	Header:
 *		queue_entry_t queue_last(q)
 *			queue_t	q;		\* IN *\
 */
#define	queue_last(q)	((q)->prev)

/*
 *	Macro:		queue_prev
 *	Function:
 *		Returns the entry before an item in the queue.
 *	Header:
 *		queue_entry_t queue_prev(qc)
 *			queue_t qc;
 */
#define	queue_prev(qc)	((qc)->prev)

/*
 *	Macro:		queue_end
 *	Function:
 *		Tests whether a new entry is really the end of
 *		the queue.
 *	Header:
 *		boolean_t queue_end(q, qe)
 *			queue_t q;
 *			queue_entry_t qe;
 */
#define	queue_end(q, qe)	((q) == (qe))

/*
 *	Macro:		queue_empty
 *	Function:
 *		Tests whether a queue is empty.
 *	Header:
 *		boolean_t queue_empty(q)
 *			queue_t q;
 */
#define	queue_empty(q)		queue_end((q), queue_first(q))

/*
 *	Function:	movqueue
 *	Parameters:
 *		queue_t _old : head of a queue whose items will be moved
 *		queue_t _new : new queue head onto which items will be moved
 *	Description:
 *		Rebase queue items in _old onto _new then re-initialize
 *		the _old object to an empty queue.
 *		Equivalent to the queue_new_head Method 2 macro
 *	Note:
 *		Similar to the queue_new_head macro, this macros is intented
 *		to function as an initializer method for '_new' and thus may
 *		leak any list items that happen to be on the '_new' list.
 *		This should only be used with Method 1 queue iteration (linkage chains)
 */
static __inline__ void
movqueue(queue_t _old, queue_t _new)
{
	queue_entry_t	next_elt, prev_elt;

	__QUEUE_ELT_VALIDATE((queue_entry_t)_old);

	if (queue_empty(_old)) {
		queue_init(_new);
		return;
	}

	/*
	 * move the queue at _old to _new
	 * and re-initialize _old
	 */
	next_elt = _old->next;
	prev_elt = _old->prev;

	_new->next = next_elt;
	_new->prev = prev_elt;
	next_elt->prev = _new;
	prev_elt->next = _new;

	queue_init(_old);
}

/*----------------------------------------------------------------*/
/*
 * Macros that operate on generic structures.  The queue
 * chain may be at any location within the structure, and there
 * may be more than one chain.
 */

/*
 *	Macro:		queue_enter
 *	Function:
 *		Insert a new element at the tail of the queue.
 *	Header:
 *		void queue_enter(q, elt, type, field)
 *			queue_t q;
 *			<type> elt;
 *			<type> is what's in our queue
 *			<field> is the chain field in (*<type>)
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define queue_enter(head, elt, type, field)			\
MACRO_BEGIN							\
	queue_entry_t __prev;					\
								\
	__prev = (head)->prev;					\
	if ((head) == __prev) {					\
		(head)->next = (queue_entry_t) (elt);		\
	}							\
	else {							\
		((type)(void *)__prev)->field.next =		\
			(queue_entry_t)(elt);			\
	}							\
	(elt)->field.prev = __prev;				\
	(elt)->field.next = head;				\
	(head)->prev = (queue_entry_t) elt;			\
MACRO_END

/*
 *	Macro:		queue_enter_first
 *	Function:
 *		Insert a new element at the head of the queue.
 *	Header:
 *		void queue_enter_first(q, elt, type, field)
 *			queue_t q;
 *			<type> elt;
 *			<type> is what's in our queue
 *			<field> is the chain field in (*<type>)
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define queue_enter_first(head, elt, type, field)		\
MACRO_BEGIN							\
	queue_entry_t __next;					\
								\
	__next = (head)->next;					\
	if ((head) == __next) {					\
		(head)->prev = (queue_entry_t) (elt);		\
	}							\
	else {							\
		((type)(void *)__next)->field.prev =		\
			(queue_entry_t)(elt);			\
	}							\
	(elt)->field.next = __next;				\
	(elt)->field.prev = head;				\
	(head)->next = (queue_entry_t) elt;			\
MACRO_END

/*
 *	Macro:		queue_insert_before
 *	Function:
 *		Insert a new element before a given element.
 *	Header:
 *		void queue_insert_before(q, elt, cur, type, field)
 *			queue_t q;
 *			<type> elt;
 *			<type> cur;
 *			<type> is what's in our queue
 *			<field> is the chain field in (*<type>)
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define queue_insert_before(head, elt, cur, type, field)		\
MACRO_BEGIN								\
	queue_entry_t __prev;						\
									\
	if ((head) == (queue_entry_t)(cur)) {				\
		(elt)->field.next = (head);				\
		if ((head)->next == (head)) {	/* only element */	\
			(elt)->field.prev = (head);			\
			(head)->next = (queue_entry_t)(elt);		\
		} else {			/* last element */	\
			__prev = (elt)->field.prev = (head)->prev;	\
			((type)(void *)__prev)->field.next =		\
				(queue_entry_t)(elt);			\
		}							\
		(head)->prev = (queue_entry_t)(elt);			\
	} else {							\
		(elt)->field.next = (queue_entry_t)(cur);		\
		if ((head)->next == (queue_entry_t)(cur)) {		\
						/* first element */	\
			(elt)->field.prev = (head);			\
			(head)->next = (queue_entry_t)(elt);		\
		} else {			/* middle element */	\
			__prev = (elt)->field.prev = (cur)->field.prev;	\
			((type)(void *)__prev)->field.next =		\
				(queue_entry_t)(elt);			\
		}							\
		(cur)->field.prev = (queue_entry_t)(elt);		\
	}								\
MACRO_END

/*
 *	Macro:		queue_insert_after
 *	Function:
 *		Insert a new element after a given element.
 *	Header:
 *		void queue_insert_after(q, elt, cur, type, field)
 *			queue_t q;
 *			<type> elt;
 *			<type> cur;
 *			<type> is what's in our queue
 *			<field> is the chain field in (*<type>)
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define queue_insert_after(head, elt, cur, type, field)			\
MACRO_BEGIN								\
	queue_entry_t __next;						\
									\
	if ((head) == (queue_entry_t)(cur)) {				\
		(elt)->field.prev = (head);				\
		if ((head)->next == (head)) {	/* only element */	\
			(elt)->field.next = (head);			\
			(head)->prev = (queue_entry_t)(elt);		\
		} else {			/* first element */	\
			__next = (elt)->field.next = (head)->next;	\
			((type)(void *)__next)->field.prev =		\
				(queue_entry_t)(elt);			\
		}							\
		(head)->next = (queue_entry_t)(elt);			\
	} else {							\
		(elt)->field.prev = (queue_entry_t)(cur);		\
		if ((head)->prev == (queue_entry_t)(cur)) {		\
						/* last element */	\
			(elt)->field.next = (head);			\
			(head)->prev = (queue_entry_t)(elt);		\
		} else {			/* middle element */	\
			__next = (elt)->field.next = (cur)->field.next;	\
			((type)(void *)__next)->field.prev =		\
				(queue_entry_t)(elt);			\
		}							\
		(cur)->field.next = (queue_entry_t)(elt);		\
	}								\
MACRO_END

/*
 *	Macro:		queue_field [internal use only]
 *	Function:
 *		Find the queue_chain_t (or queue_t) for the
 *		given element (thing) in the given queue (head)
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define	queue_field(head, thing, type, field)			\
		(((head) == (thing)) ? (head) : &((type)(void *)(thing))->field)

/*
 *	Macro:		queue_remove
 *	Function:
 *		Remove an arbitrary item from the queue.
 *	Header:
 *		void queue_remove(q, qe, type, field)
 *			arguments as in queue_enter
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define	queue_remove(head, elt, type, field)			\
MACRO_BEGIN							\
	queue_entry_t	__next, __prev;				\
								\
	__next = (elt)->field.next;				\
	__prev = (elt)->field.prev;				\
								\
	if ((head) == __next)					\
		(head)->prev = __prev;				\
	else							\
		((type)(void *)__next)->field.prev = __prev;	\
								\
	if ((head) == __prev)					\
		(head)->next = __next;				\
	else							\
		((type)(void *)__prev)->field.next = __next;	\
								\
	(elt)->field.next = NULL;				\
	(elt)->field.prev = NULL;				\
MACRO_END

/*
 *	Macro:		queue_remove_first
 *	Function:
 *		Remove and return the entry at the head of
 *		the queue.
 *	Header:
 *		queue_remove_first(head, entry, type, field)
 *		entry is returned by reference
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define	queue_remove_first(head, entry, type, field)		\
MACRO_BEGIN							\
	queue_entry_t	__next;					\
								\
	(entry) = (type)(void *) ((head)->next);		\
	__next = (entry)->field.next;				\
								\
	if ((head) == __next)					\
		(head)->prev = (head);				\
	else							\
		((type)(void *)(__next))->field.prev = (head);	\
	(head)->next = __next;					\
								\
	(entry)->field.next = NULL;				\
	(entry)->field.prev = NULL;				\
MACRO_END

/*
 *	Macro:		queue_remove_last
 *	Function:
 *		Remove and return the entry at the tail of
 *		the queue.
 *	Header:
 *		queue_remove_last(head, entry, type, field)
 *		entry is returned by reference
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define	queue_remove_last(head, entry, type, field)		\
MACRO_BEGIN							\
	queue_entry_t	__prev;					\
								\
	(entry) = (type)(void *) ((head)->prev);		\
	__prev = (entry)->field.prev;				\
								\
	if ((head) == __prev)					\
		(head)->next = (head);				\
	else							\
		((type)(void *)(__prev))->field.next = (head);	\
	(head)->prev = __prev;					\
								\
	(entry)->field.next = NULL;				\
	(entry)->field.prev = NULL;				\
MACRO_END

/*
 *	Macro:		queue_assign
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define	queue_assign(to, from, type, field)			\
MACRO_BEGIN							\
	((type)(void *)((from)->prev))->field.next = (to);	\
	((type)(void *)((from)->next))->field.prev = (to);	\
	*to = *from;						\
MACRO_END

/*
 *	Macro:		queue_new_head
 *	Function:
 *		rebase old queue to new queue head
 *	Header:
 *		queue_new_head(old, new, type, field)
 *			queue_t old;
 *			queue_t new;
 *			<type> is what's in our queue
 *                      <field> is the chain field in (*<type>)
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define queue_new_head(old, new, type, field)			\
MACRO_BEGIN							\
	if (!queue_empty(old)) {				\
		*(new) = *(old);				\
		((type)(void *)((new)->next))->field.prev =	\
			(new);					\
		((type)(void *)((new)->prev))->field.next =	\
			(new);					\
	} else {						\
		queue_init(new);				\
	}							\
MACRO_END

/*
 *	Macro:		queue_iterate
 *	Function:
 *		iterate over each item in the queue.
 *		Generates a 'for' loop, setting elt to
 *		each item in turn (by reference).
 *	Header:
 *		queue_iterate(q, elt, type, field)
 *			queue_t q;
 *			<type> elt;
 *			<type> is what's in our queue
 *			<field> is the chain field in (*<type>)
 *	Note:
 *		This should only be used with Method 2 queue iteration (element chains)
 */
#define queue_iterate(head, elt, type, field)			\
	for ((elt) = (type)(void *) queue_first(head);		\
	     !queue_end((head), (queue_entry_t)(elt));		\
	     (elt) = (type)(void *) queue_next(&(elt)->field))


__END_DECLS

#endif	/* _KERN_QUEUE_H_ */
                                                                                                                                                                                                                                       sched_prim.h                                                                                        0100644 0001750 0001750 00000011410 12567450750 034271  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * @OSF_COPYRIGHT@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 */
/*
 *	File:	sched_prim.h
 *	Author:	David Golub
 *
 *	Scheduling primitive definitions file
 *
 */

#ifndef	_KERN_SCHED_PRIM_H_
#define _KERN_SCHED_PRIM_H_

#include <mach/boolean.h>
#include <mach/machine/vm_types.h>
#include <mach/kern_return.h>
#include <kern/clock.h>
#include <kern/kern_types.h>
#include <kern/thread.h>
#include <sys/cdefs.h>


__BEGIN_DECLS


/* Context switch */
extern wait_result_t	thread_block(
							thread_continue_t	continuation);

extern wait_result_t	thread_block_parameter(
							thread_continue_t	continuation,
							void				*parameter);

/* Declare thread will wait on a particular event */
extern wait_result_t	assert_wait(
							event_t				event,
							wait_interrupt_t	interruptible);

/* Assert that the thread intends to wait with a timeout */
extern wait_result_t	assert_wait_timeout(
							event_t				event,
							wait_interrupt_t	interruptible,
							uint32_t			interval,
							uint32_t			scale_factor);

/* Assert that the thread intends to wait with an urgency, timeout and leeway */
extern wait_result_t	assert_wait_timeout_with_leeway(
							event_t				event,
							wait_interrupt_t	interruptible,
							wait_timeout_urgency_t	urgency,
							uint32_t			interval,
							uint32_t			leeway,
							uint32_t			scale_factor);

extern wait_result_t	assert_wait_deadline(
							event_t				event,
							wait_interrupt_t	interruptible,
							uint64_t			deadline);

/* Assert that the thread intends to wait with an urgency, deadline, and leeway */
extern wait_result_t	assert_wait_deadline_with_leeway(
							event_t				event,
							wait_interrupt_t	interruptible,
							wait_timeout_urgency_t	urgency,
							uint64_t			deadline,
							uint64_t			leeway);

/* Wake up thread (or threads) waiting on a particular event */
extern kern_return_t	thread_wakeup_prim(
							event_t				event,
							boolean_t			one_thread,
							wait_result_t			result);

extern kern_return_t    thread_wakeup_prim_internal(
	                                                event_t				event,
							boolean_t			one_thread,
							wait_result_t			result,
							int				priority);


#define thread_wakeup(x)					\
			thread_wakeup_prim((x), FALSE, THREAD_AWAKENED)
#define thread_wakeup_with_result(x, z)		\
			thread_wakeup_prim((x), FALSE, (z))
#define thread_wakeup_one(x)				\
			thread_wakeup_prim((x), TRUE, THREAD_AWAKENED)


extern boolean_t		preemption_enabled(void);


__END_DECLS

#endif	/* _KERN_SCHED_PRIM_H_ */
                                                                                                                                                                                                                                                        sfi.h                                                                                               0100644 0001750 0001750 00000004221 12567450750 032737  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _KERN_SFI_H_
#define _KERN_SFI_H_

#include <stdint.h>
#include <mach/mach_types.h>
#include <mach/kern_return.h>
#include <mach/sfi_class.h>
#include <kern/ast.h>
#include <kern/kern_types.h>
#include <kern/ledger.h>

extern void sfi_init(void);
extern void sfi_early_init(void);
extern sfi_class_id_t sfi_get_ledger_alias_for_class(sfi_class_id_t class_id);
extern int sfi_ledger_entry_add(ledger_template_t template, sfi_class_id_t class_id);

kern_return_t sfi_set_window(uint64_t window_usecs);
kern_return_t sfi_window_cancel(void);
kern_return_t sfi_get_window(uint64_t *window_usecs);

kern_return_t sfi_set_class_offtime(sfi_class_id_t class_id, uint64_t offtime_usecs);
kern_return_t sfi_class_offtime_cancel(sfi_class_id_t class_id);
kern_return_t sfi_get_class_offtime(sfi_class_id_t class_id, uint64_t *offtime_usecs);


#endif /* _KERN_SFI_H_ */
                                                                                                                                                                                                                                                                                                                                                                               task.h                                                                                              0100644 0001750 0001750 00000010142 12567450750 033117  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern                                                                 /*
 * Copyright (c) 2000-2010, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH 