  This is
because \f(CW\*(C`islc\*(C'\fR is a Perl extension which is short for
\&\f(CW\*(C`General_Category=Cased Letter\*(C'\fR.  The lists returned for the Perl extensions
will not include the \f(CW"Is_"\fR prefix (whether or not the input had it) unless
needed to resolve ambiguities, as shown in the \f(CW"islc"\fR example, where the
returned list had one element containing \f(CW"Is_"\fR, and the other without.
.PP
It is also possible for the reverse to happen:  \f(CW\*(C`prop_aliases(\*(Aqisc\*(Aq)\*(C'\fR returns
the list \f(CW\*(C`(isc, ISO_Comment)\*(C'\fR; whereas \f(CW\*(C`prop_aliases(\*(Aqc\*(Aq)\*(C'\fR returns
\&\f(CW\*(C`(C, Other)\*(C'\fR (the latter being a Perl extension meaning
\&\f(CW\*(C`General_Category=Other\*(C'\fR.
\&\*(L"Properties accessible through Unicode::UCD\*(R" in perluniprops lists the available
forms, including which ones are discouraged from use.
.PP
Those discouraged forms are accepted as input to \f(CW\*(C`prop_aliases\*(C'\fR, but are not
returned in the lists.  \f(CW\*(C`prop_aliases(\*(AqisL&\*(Aq)\*(C'\fR and \f(CW\*(C`prop_aliases(\*(AqisL_\*(Aq)\*(C'\fR,
which are old synonyms for \f(CW"Is_LC"\fR and should not be used in new code, are
examples of this.  These both return \f(CW\*(C`(Is_LC, Cased_Letter)\*(C'\fR.  Thus this
function allows you to take a discourarged form, and find its acceptable
alternatives.  The same goes with single-form Block property equivalences.
Only the forms that begin with \f(CW"In_"\fR are not discouraged; if you pass
\&\f(CW\*(C`prop_aliases\*(C'\fR a discouraged form, you will get back the equivalent ones that
begin with \f(CW"In_"\fR.  It will otherwise look like a new-style block name (see.
\&\*(L"Old-style versus new-style block names\*(R").
.PP
\&\f(CW\*(C`prop_aliases\*(C'\fR does not know about any user-defined properties, and will
return \f(CW\*(C`undef\*(C'\fR if called with one of those.  Likewise for Perl internal
properties, with the exception of \*(L"Perl_Decimal_Digit\*(R" which it does know
about (and which is documented below in \*(L"\fIprop_invmap()\fR\*(R").
.SS "\fB\fP\f(BIprop_value_aliases()\fP\fB\fP"
.IX Subsection "prop_value_aliases()"
.Vb 1
\&    use Unicode::UCD \*(Aqprop_value_aliases\*(Aq;
\&
\&    my ($short_name, $full_name, @other_names)
\&                                   = prop_value_aliases("Gc", "Punct");
\&    my $same_full_name = prop_value_aliases("Gc", "P");   # Scalar cntxt
\&    my ($same_short_name) = prop_value_aliases("Gc", "P"); # gets 0th
\&                                                           # element
\&    print "The full name is $full_name\en";
\&    print "The short name is $short_name\en";
\&    print "The other aliases are: ", join(", ", @other_names), "\en";
\&
\&    prints:
\&    The full name is Punctuation
\&    The short name is P
\&    The other aliases are: Punct
.Ve
.PP
Some Unicode properties have a restricted set of legal values.  For example,
all binary properties are restricted to just \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR; and there
are only a few dozen possible General Categories.
.PP
For such properties, there are usually several synonyms for each possible
value.  For example, in binary properties, \fItruth\fR can be represented by any of
the strings \*(L"Y\*(R", \*(L"Yes\*(R", \*(L"T\*(R", or \*(L"True\*(R"; and the General Category
\&\*(L"Punctuation\*(R" by that string, or \*(L"Punct\*(R", or simply \*(L"P\*(R".
.PP
Like property names, there is typically at least a short name for each such
property-value, and a long name.  If you know any name of the property-value,
you can use \f(CW\*(C`prop_value_aliases\*(C'\fR() to get the long name (when called in
scalar context), or a list of all the names, with the short name in the 0th
element, the long name in the next element, and any other synonyms in the
remaining elements, in no particular order, except that any all-numeric
synonyms will be last.
.PP
The long name is returned in a form nicely capitalized, suitable for printing.
.PP
Case, white space, hyphens, and underscores are ignored in the input parameters
(except for the trailing underscore in the old-form grandfathered-in general
category property value \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR).
.PP
If either name is unknown, \f(CW\*(C`undef\*(C'\fR is returned.  Note that Perl typically
recognizes property names in regular expressions with an optional \f(CW\*(C`"Is_\*(C'\fR"
(with or without the underscore) prefixed to them, such as \f(CW\*(C`\ep{isgc=punct}\*(C'\fR.
This function does not recognize those in the property parameter, returning
\&\f(CW\*(C`undef\*(C'\fR.
.PP
If called with a property that doesn't have synonyms for its values, it
returns the input value, possibly normalized with capitalization and
underscores.
.PP
For the block property, new-style block names are returned (see
\&\*(L"Old-style versus new-style block names\*(R").
.PP
To find the synonyms for single-forms, such as \f(CW\*(C`\ep{Any}\*(C'\fR, use
\&\*(L"\fIprop_aliases()\fR\*(R" instead.
.PP
\&\f(CW\*(C`prop_value_aliases\*(C'\fR does not know about any user-defined properties, and
will return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "\fB\fP\f(BIprop_invlist()\fP\fB\fP"
.IX Subsection "prop_invlist()"
\&\f(CW\*(C`prop_invlist\*(C'\fR returns an inversion list (described below) that defines all the
code points for the binary Unicode property (or \*(L"property=value\*(R" pair) given
by the input parameter string:
.PP
.Vb 3
\& use feature \*(Aqsay\*(Aq;
\& use Unicode::UCD \*(Aqprop_invlist\*(Aq;
\& say join ", ", prop_invlist("Any");
\&
\& prints:
\& 0, 1114112
.Ve
.PP
If the input is unknown \f(CW\*(C`undef\*(C'\fR is returned in scalar context; an empty-list
in list context.  If the input is known, the number of elements in
the list is returned if called in scalar context.
.PP
perluniprops gives
the list of properties that this function accepts, as well as all the possible
forms for them (including with the optional \*(L"Is_\*(R" prefixes).  (Except this
function doesn't accept any Perl-internal properties, some of which are listed
there.) This function uses the same loose or tighter matching rules for
resolving the input property's name as is done for regular expressions.  These
are also specified in perluniprops.  Examples of using the \*(L"property=value\*(R" form are:
.PP
.Vb 1
\& say join ", ", prop_invlist("Script=Shavian");
\&
\& prints:
\& 66640, 66688
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=No");
\&
\& prints:
\& 0, 48, 58, 65, 71, 97, 103
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=Yes");
\&
\& prints:
\& 48, 58, 65, 71, 97, 103
.Ve
.PP
Inversion lists are a compact way of specifying Unicode property-value
definitions.  The 0th item in the list is the lowest code point that has the
property-value.  The next item (item [1]) is the lowest code point beyond that
one that does \s-1NOT\s0 have the property-value.  And the next item beyond that
([2]) is the lowest code point beyond that one that does have the
property-value, and so on.  Put another way, each element in the list gives
the beginning of a range that has the property-value (for even numbered
elements), or doesn't have the property-value (for odd numbered elements).
The name for this data structure stems from the fact that each element in the
list toggles (or inverts) whether the corresponding range is or isn't on the
list.
.PP
In the final example above, the first \s-1ASCII\s0 Hex digit is code point 48, the
character \*(L"0\*(R", and all code points from it through 57 (a \*(L"9\*(R") are \s-1ASCII\s0 hex
digits.  Code points 58 through 64 aren't, but 65 (an \*(L"A\*(R") through 70 (an \*(L"F\*(R")
are, as are 97 (\*(L"a\*(R") through 102 (\*(L"f\*(R").  103 starts a range of code points
that aren't \s-1ASCII\s0 hex digits.  That range extends to infinity, which on your
computer can be found in the variable \f(CW$Unicode::UCD::MAX_CP\fR.  (This
variable is as close to infinity as Perl can get on your platform, and may be
too high for some operations to work; you may wish to use a smaller number for
your purposes.)
.PP
Note that the inversion lists returned by this function can possibly include
non-Unicode code points, that is anything above 0x10FFFF.  This is in
contrast to Perl regular expression matches on those code points, in which a
non-Unicode code point always fails to match.  For example, both of these have
the same result:
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Fails!
.Ve
.PP
And both raise a warning that a Unicode property is being used on a
non-Unicode code point.  It is arguable as to which is the correct thing to do
here.  This function has chosen the way opposite to the Perl regular
expression behavior.  This allows you to easily flip to to the Perl regular
expression way (for you to go in the other direction would be far harder).
Simply add 0x110000 at the end of the non-empty returned list if it isn't
already that value; and pop that value if it is; like:
.PP
.Vb 9
\& my @list = prop_invlist("foo");
\& if (@list) {
\&     if ($list[\-1] == 0x110000) {
\&         pop @list;  # Defeat the turning on for above Unicode
\&     }
\&     else {
\&         push @list, 0x110000; # Turn off for above Unicode
\&     }
\& }
.Ve
.PP
It is a simple matter to expand out an inversion list to a full list of all
code points that have the property-value:
.PP
.Vb 10
\& my @invlist = prop_invlist($property_name);
\& die "empty" unless @invlist;
\& my @full_list;
\& for (my $i = 0; $i < @invlist; $i += 2) {
\&    my $upper = ($i + 1) < @invlist
\&                ? $invlist[$i+1] \- 1      # In range
\&                : $Unicode::UCD::MAX_CP;  # To infinity.  You may want
\&                                          # to stop much much earlier;
\&                                          # going this high may expose
\&                                          # perl deficiencies with very
\&                                          # large numbers.
\&    for my $j ($invlist[$i] .. $upper) {
\&        push @full_list, $j;
\&    }
\& }
.Ve
.PP
\&\f(CW\*(C`prop_invlist\*(C'\fR does not know about any user-defined nor Perl internal-only
properties, and will return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "\fB\fP\f(BIprop_invmap()\fP\fB\fP"
.IX Subsection "prop_invmap()"
.Vb 3
\& use Unicode::UCD \*(Aqprop_invmap\*(Aq;
\& my ($list_ref, $map_ref, $format, $missing)
\&                                      = prop_invmap("General Category");
.Ve
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is used to get the complete mapping definition for a property,
in the form of an inversion map.  An inversion map consists of two parallel
arrays.  One is an ordered list of code points that mark range beginnings, and
the other gives the value (or mapping) that all code points in the
corresponding range have.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is called with the name of the desired property.  The name is
loosely matched, meaning that differences in case, white-space, hyphens, and
underscores are not meaningful (except for the trailing underscore in the
old-form grandfathered-in property \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR,
or even better, \f(CW"Gc=LC"\fR).
.PP
Many Unicode properties have more than one name (or alias).  \f(CW\*(C`prop_invmap\*(C'\fR
understands all of these, including Perl extensions to them.  Ambiguities are
resolved as described above for \*(L"\fIprop_aliases()\fR\*(R".  The Perl internal
property "Perl_Decimal_Digit, described below, is also accepted.  \f(CW\*(C`undef\*(C'\fR is
returned if the property name is unknown.
See \*(L"Properties accessible through Unicode::UCD\*(R" in perluniprops for the
properties acceptable as inputs to this function.
.PP
It is a fatal error to call this function except in list context.
.PP
In addition to the the two arrays that form the inversion map, \f(CW\*(C`prop_invmap\*(C'\fR
returns two other values; one is a scalar that gives some details as to the
format of the entries of the map array; the other is used for specialized
purposes, described at the end of this section.
.PP
This means that \f(CW\*(C`prop_invmap\*(C'\fR returns a 4 element list.  For example,
.PP
.Vb 2
\& my ($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
\&                                                 = prop_invmap("Block");
.Ve
.PP
In this call, the two arrays will be populated as shown below (for Unicode
6.0):
.PP
.Vb 10
\& Index  @blocks_ranges  @blocks_maps
\&   0        0x0000      Basic Latin
\&   1        0x0080      Latin\-1 Supplement
\&   2        0x0100      Latin Extended\-A
\&   3        0x0180      Latin Extended\-B
\&   4        0x0250      IPA Extensions
\&   5        0x02B0      Spacing Modifier Letters
\&   6        0x0300      Combining Diacritical Marks
\&   7        0x0370      Greek and Coptic
\&   8        0x0400      Cyrillic
\&  ...
\& 233        0x2B820     No_Block
\& 234        0x2F800     CJK Compatibility Ideographs Supplement
\& 235        0x2FA20     No_Block
\& 236        0xE0000     Tags
\& 237        0xE0080     No_Block
\& 238        0xE0100     Variation Selectors Supplement
\& 239        0xE01F0     No_Block
\& 240        0xF0000     Supplementary Private Use Area\-A
\& 241        0x100000    Supplementary Private Use Area\-B
\& 242        0x110000    No_Block
.Ve
.PP
The first line (with Index [0]) means that the value for code point 0 is \*(L"Basic
Latin\*(R".  The entry \*(L"0x0080\*(R" in the \f(CW@blocks_ranges\fR column in the second line
means that the value from the first line, \*(L"Basic Latin\*(R", extends to all code
points in the range from 0 up to but not including 0x0080, that is, through
127.  In other words, the code points from 0 to 127 are all in the \*(L"Basic
Latin\*(R" block.  Similarly, all code points in the range from 0x0080 up to (but
not including) 0x0100 are in the block named \*(L"Latin\-1 Supplement\*(R", etc.
(Notice that the return is the old-style block names; see \*(L"Old-style versus
new-style block names\*(R").
.PP
The final line (with Index [242]) means that the value for all code points above
the legal Unicode maximum code point have the value \*(L"No_Block\*(R", which is the
term Unicode uses for a non-existing block.
.PP
The arrays completely specify the mappings for all possible code points.
The final element in an inversion map returned by this function will always be
for the range that consists of all the code points that aren't legal Unicode,
but that are expressible on the platform.  (That is, it starts with code point
0x110000, the first code point above the legal Unicode maximum, and extends to
infinity.) The value for that range will be the same that any typical
unassigned code point has for the specified property.  (Certain unassigned
code points are not \*(L"typical\*(R"; for example the non-character code points, or
those in blocks that are to be written right-to-left.  The above-Unicode
range's value is not based on these atypical code points.)  It could be argued
that, instead of treating these as unassigned Unicode code points, the value
for this range should be \f(CW\*(C`undef\*(C'\fR.  If you wish, you can change the returned
arrays accordingly.
.PP
The maps are almost always simple scalars that should be interpreted as-is.
These values are those given in the Unicode-supplied data files, which may be
inconsistent as to capitalization and as to which synonym for a property-value
is given.  The results may be normalized by using the \*(L"\fIprop_value_aliases()\fR\*(R"
function.
.PP
There are exceptions to the simple scalar maps.  Some properties have some
elements in their map list that are themselves lists of scalars; and some
special strings are returned that are not to be interpreted as-is.  Element
[2] (placed into \f(CW$format\fR in the example above) of the returned four element
list tells you if the map has any of these special elements or not, as follows:
.ie n .IP "\fB\fB""s""\fB\fR" 4
.el .IP "\fB\f(CBs\fB\fR" 4
.IX Item "s"
means all the elements of the map array are simple scalars, with no special
elements.  Almost all properties are like this, like the \f(CW\*(C`block\*(C'\fR example
above.
.ie n .IP "\fB\fB""sl""\fB\fR" 4
.el .IP "\fB\f(CBsl\fB\fR" 4
.IX Item "sl"
means that some of the map array elements have the form given by \f(CW"s"\fR, and
the rest are lists of scalars.  For example, here is a portion of the output
of calling \f(CW\*(C`prop_invmap\*(C'\fR() with the \*(L"Script Extensions\*(R" property:
.Sp
.Vb 6
\& @scripts_ranges  @scripts_maps
\&      ...
\&      0x0953      Devanagari
\&      0x0964      [ Bengali, Devanagari, Gurumukhi, Oriya ]
\&      0x0966      Devanagari
\&      0x0970      Common
.Ve
.Sp
Here, the code points 0x964 and 0x965 are both used in Bengali,
Devanagari, Gurmukhi, and Oriya, but no other scripts.
.Sp
The Name_Alias property is also of this form.  But each scalar consists of two
components:  1) the name, and 2) the type of alias this is.  They are
separated by a colon and a space.  In Unicode 6.1, there are several alias types:
.RS 4
.ie n .IP """correction""" 4
.el .IP "\f(CWcorrection\fR" 4
.IX Item "correction"
indicates that the name is a corrected form for the
original name (which remains valid) for the same code point.
.ie n .IP """control""" 4
.el .IP "\f(CWcontrol\fR" 4
.IX Item "control"
adds a new name for a control character.
.ie n .IP """alternate""" 4
.el .IP "\f(CWalternate\fR" 4
.IX Item "alternate"
is an alternate name for a character
.ie n .IP """figment""" 4
.el .IP "\f(CWfigment\fR" 4
.IX Item "figment"
is a name for a character that has been documented but was never in any
actual standard.
.ie n .IP """abbreviation""" 4
.el .IP "\f(CWabbreviation\fR" 4
.IX Item "abbreviation"
is a common abbreviation for a character
.RE
.RS 4
.Sp
The lists are ordered (roughly) so the most preferred names come before less
preferred ones.
.Sp
For example,
.Sp
.Vb 10
\& @aliases_ranges        @alias_maps
\&    ...
\&    0x009E        [ \*(AqPRIVACY MESSAGE: control\*(Aq, \*(AqPM: abbreviation\*(Aq ]
\&    0x009F        [ \*(AqAPPLICATION PROGRAM COMMAND: control\*(Aq,
\&                    \*(AqAPC: abbreviation\*(Aq
\&                  ]
\&    0x00A0        \*(AqNBSP: abbreviation\*(Aq
\&    0x00A1        ""
\&    0x00AD        \*(AqSHY: abbreviation\*(Aq
\&    0x00AE        ""
\&    0x01A2        \*(AqLATIN CAPITAL LETTER GHA: correction\*(Aq
\&    0x01A3        \*(AqLATIN SMALL LETTER GHA: correction\*(Aq
\&    0x01A4        ""
\&    ...
.Ve
.Sp
A map to the empty string means that there is no alias defined for the code
point.
.RE
.ie n .IP "\fB\fB""a""\fB\fR" 4
.el .IP "\fB\f(CBa\fB\fR" 4
.IX Item "a"
is like \f(CW"s"\fR in that all the map array elements are scalars, but here they are
restricted to all being integers, and some have to be adjusted (hence the name
\&\f(CW"a"\fR) to get the correct result.  For example, in:
.Sp
.Vb 2
\& my ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                          = prop_invmap("Simple_Uppercase_Mapping");
.Ve
.Sp
the returned arrays look like this:
.Sp
.Vb 7
\& @$uppers_ranges_ref    @$uppers_maps_ref   Note
\&       0                      0
\&      97                     65          \*(Aqa\*(Aq maps to \*(AqA\*(Aq, b => B ...
\&     123                      0
\&     181                    924          MICRO SIGN => Greek Cap MU
\&     182                      0
\&     ...
.Ve
.Sp
Let's start with the second line.  It says that the uppercase of code point 97
is 65; or \f(CW\*(C`uc("a")\*(C'\fR == \*(L"A\*(R".  But the line is for the entire range of code
points 97 through 122.  To get the mapping for any code point in a range, you
take the offset it has from the beginning code point of the range, and add
that to the mapping for that first code point.  So, the mapping for 122 (\*(L"z\*(R")
is derived by taking the offset of 122 from 97 (=25) and adding that to 65,
yielding 90 (\*(L"z\*(R").  Likewise for everything in between.
.Sp
The first line works the same way.  The first map in a range is always the
correct value for its code point (because the adjustment is 0).  Thus the
\&\f(CW\*(C`uc(chr(0))\*(C'\fR is just itself.  Also, \f(CW\*(C`uc(chr(1))\*(C'\fR is also itself, as the
adjustment is 0+1\-0 .. \f(CW\*(C`uc(chr(96))\*(C'\fR is 96.
.Sp
Requiring this simple adjustment allows the returned arrays to be
significantly smaller than otherwise, up to a factor of 10, speeding up
searching through them.
.ie n .IP "\fB\fB""al""\fB\fR" 4
.el .IP "\fB\f(CBal\fB\fR" 4
.IX Item "al"
means that some of the map array elements have the form given by \f(CW"a"\fR, and
the rest are ordered lists of code points.
For example, in:
.Sp
.Vb 2
\& my ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                                 = prop_invmap("Uppercase_Mapping");
.Ve
.Sp
the returned arrays look like this:
.Sp
.Vb 11
\& @$uppers_ranges_ref    @$uppers_maps_ref
\&       0                      0
\&      97                     65
\&     123                      0
\&     181                    924
\&     182                      0
\&     ...
\&    0x0149              [ 0x02BC 0x004E ]
\&    0x014A                    0
\&    0x014B                  330
\&     ...
.Ve
.Sp
This is the full Uppercase_Mapping property (as opposed to the
Simple_Uppercase_Mapping given in the example for format \f(CW"a"\fR).  The only
difference between the two in the ranges shown is that the code point at
0x0149 (\s-1LATIN SMALL LETTER N PRECEDED BY APOSTROPHE\s0) maps to a string of two
characters, 0x02BC (\s-1MODIFIER LETTER APOSTROPHE\s0) followed by 0x004E (\s-1LATIN
CAPITAL LETTER N\s0).
.Sp
No adjustments are needed to entries that are references to arrays; each such
entry will have exactly one element in its range, so the offset is always 0.
.ie n .IP "\fB\fB""ae""\fB\fR" 4
.el .IP "\fB\f(CBae\fB\fR" 4
.IX Item "ae"
This is like \f(CW"a"\fR, but some elements are the empty string, and should not be
adjusted.
The one internal Perl property accessible by \f(CW\*(C`prop_invmap\*(C'\fR is of this type:
\&\*(L"Perl_Decimal_Digit\*(R" returns an inversion map which gives the numeric values
that are represented by the Unicode decimal digit characters.  Characters that
don't represent decimal digits map to the empty string, like so:
.Sp
.Vb 12
\& @digits    @values
\& 0x0000       ""
\& 0x0030        0
\& 0x003A:      ""
\& 0x0660:       0
\& 0x066A:      ""
\& 0x06F0:       0
\& 0x06FA:      ""
\& 0x07C0:       0
\& 0x07CA:      ""
\& 0x0966:       0
\& ...
.Ve
.Sp
This means that the code points from 0 to 0x2F do not represent decimal digits;
the code point 0x30 (\s-1DIGIT ZERO\s0) represents 0;  code point 0x31, (\s-1DIGIT ONE\s0),
represents 0+1\-0 = 1; ... code point 0x39, (\s-1DIGIT NINE\s0), represents 0+9\-0 = 9;
\&... code points 0x3A through 0x65F do not represent decimal digits; 0x660
(ARABIC-INDIC \s-1DIGIT ZERO\s0), represents 0; ... 0x07C1 (\s-1NKO DIGIT ONE\s0),
represents 0+1\-0 = 1 ...
.ie n .IP "\fB\fB""ale""\fB\fR" 4
.el .IP "\fB\f(CBale\fB\fR" 4
.IX Item "ale"
is a combination of the \f(CW"al"\fR type and the \f(CW"ae"\fR type.  Some of
the map array elements have the forms given by \f(CW"al"\fR, and
the rest are the empty string.  The property \f(CW\*(C`NFKC_Casefold\*(C'\fR has this form.
An example slice is:
.Sp
.Vb 9
\& @$ranges_ref  @$maps_ref         Note
\&    ...
\&   0x00AA       97                FEMININE ORDINAL INDICATOR => \*(Aqa\*(Aq
\&   0x00AB        0
\&   0x00AD                         SOFT HYPHEN => ""
\&   0x00AE        0
\&   0x00AF     [ 0x0020, 0x0304 ]  MACRON => SPACE . COMBINING MACRON
\&   0x00B0        0
\&   ...
.Ve
.ie n .IP "\fB\fB""ar""\fB\fR" 4
.el .IP "\fB\f(CBar\fB\fR" 4
.IX Item "ar"
means that all the elements of the map array are either rational numbers or
the string \f(CW"NaN"\fR, meaning \*(L"Not a Number\*(R".  A rational number is either an
integer, or two integers separated by a solidus (\f(CW"/"\fR).  The second integer
represents the denominator of the division implied by the solidus, and is
actually always positive, so it is guaranteed not to be 0 and to not be
signed.  When the element is a plain integer (without the
solidus), it may need to be adjusted to get the correct value by adding the
offset, just as other \f(CW"a"\fR properties.  No adjustment is needed for
fractions, as the range is guaranteed to have just a single element, and so
the offset is always 0.
.Sp
If you want to convert the returned map to entirely scalar numbers, you
can use something like this:
.Sp
.Vb 4
\& my ($invlist_ref, $invmap_ref, $format) = prop_invmap($property);
\& if ($format && $format eq "ar") {
\&     map { $_ = eval $_ if $_ ne \*(AqNaN\*(Aq } @$map_ref;
\& }
.Ve
.Sp
Here's some entries from the output of the property \*(L"Nv\*(R", which has format
\&\f(CW"ar"\fR.
.Sp
.Vb 10
\& @numerics_ranges  @numerics_maps       Note
\&        0x00           "NaN"
\&        0x30             0           DIGIT 0 .. DIGIT 9
\&        0x3A           "NaN"
\&        0xB2             2           SUPERSCRIPTs 2 and 3
\&        0xB4           "NaN"
\&        0xB9             1           SUPERSCRIPT 1
\&        0xBA           "NaN"
\&        0xBC            1/4          VULGAR FRACTION 1/4
\&        0xBD            1/2          VULGAR FRACTION 1/2
\&        0xBE            3/4          VULGAR FRACTION 3/4
\&        0xBF           "NaN"
\&        0x660            0           ARABIC\-INDIC DIGIT ZERO .. NINE
\&        0x66A          "NaN"
.Ve
.ie n .IP "\fB\fB""n""\fB\fR" 4
.el .IP "\fB\f(CBn\fB\fR" 4
.IX Item "n"
means the Name property.  All the elements of the map array are simple
scalars, but some of them contain special strings that require more work to
get the actual name.
.Sp
Entries such as:
.Sp
.Vb 1
\& CJK UNIFIED IDEOGRAPH\-<code point>
.Ve
.Sp
mean that the name for the code point is \*(L"\s-1CJK UNIFIED IDEOGRAPH\-\*(R"\s0
with the code point (expressed in hexadecimal) appended to it, like \*(L"\s-1CJK
UNIFIED IDEOGRAPH\-3403\*(R" \s0(similarly for \f(CW\*(C`CJK\ COMPATIBILITY\ IDEOGRAPH\-<code\ point>\*(C'\fR).
.Sp
Also, entries like
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
means that the name is algorithmically calculated.  This is easily done by
the function \*(L"charnames::viacode(code)\*(R" in charnames.
.Sp
Note that for control characters (\f(CW\*(C`Gc=cc\*(C'\fR), Unicode's data files have the
string "\f(CW\*(C`<control>\*(C'\fR", but the real name of each of these characters is the empty
string.  This function returns that real name, the empty string.  (There are
names for these characters, but they are considered aliases, not the Name
property name, and are contained in the \f(CW\*(C`Name_Alias\*(C'\fR property.)
.ie n .IP "\fB\fB""ad""\fB\fR" 4
.el .IP "\fB\f(CBad\fB\fR" 4
.IX Item "ad"
means the Decomposition_Mapping property.  This property is like \f(CW"al"\fR
properties, except that one of the scalar elements is of the form:
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
This signifies that this entry should be replaced by the decompositions for
all the code points whose decomposition is algorithmically calculated.  (All
of them are currently in one range and no others outisde the range are likely
to ever be added to Unicode; the \f(CW"n"\fR format
has this same entry.)  These can be generated via the function
\&\fIUnicode::Normalize::NFD()\fR.
.Sp
Note that the mapping is the one that is specified in the Unicode data files,
and to get the final decomposition, it may need to be applied recursively.
.PP
Note that a format begins with the letter \*(L"a\*(R" if and only the property it is
for requires adjustments by adding the offsets in multi-element ranges.  For
all these properties, an entry should be adjusted only if the map is a scalar
which is an integer.  That is, it must match the regular expression:
.PP
.Vb 1
\&    / ^ \-? \ed+ $ /xa
.Ve
.PP
Further, the first element in a range never needs adjustment, as the
adjustment would be just adding 0.
.PP
A binary search can be used to quickly find a code point in the inversion
list, and hence its corresponding mapping.
.PP
The final element (index [3], assigned to \f(CW$default\fR in the \*(L"block\*(R" example) in
the four element list returned by this function may be useful for applications
that wish to convert the returned inversion map data structure into some
other, such as a hash.  It gives the mapping that most code points map to
under the property.  If you establish the convention that any code point not
explicitly listed in your data structure maps to this value, you can
potentially make your data structure much smaller.  As you construct your data
structure from the one returned by this function, simply ignore those ranges
that map to this value, generally called the \*(L"default\*(R" value.  For example, to
convert to the data structure searchable by \*(L"\fIcharinrange()\fR\*(R", you can follow
this recipe for properties that don't require adjustments:
.PP
.Vb 2
\& my ($list_ref, $map_ref, $format, $missing) = prop_invmap($property);
\& my @range_list;
\&
\& # Look at each element in the list, but the \-2 is needed because we
\& # look at $i+1 in the loop, and the final element is guaranteed to map
\& # to $missing by prop_invmap(), so we would skip it anyway.
\& for my $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&    push @range_list, [ $list_ref\->[$i],
\&                        $list_ref\->[$i+1],
\&                        $map_ref\->[$i]
\&                      ];
\& }
\&
\& print charinrange(\e@range_list, $code_point), "\en";
.Ve
.PP
With this, \f(CW\*(C`charinrange()\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR if its input code point maps
to \f(CW$missing\fR.  You can avoid this by omitting the \f(CW\*(C`next\*(C'\fR statement, and adding
a line after the loop to handle the final element of the inversion map.
.PP
Similarly, this recipe can be used for properties that do require adjustments:
.PP
.Vb 2
\& for my $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&
\&    # prop_invmap() guarantees that if the mapping is to an array, the
\&    # range has just one element, so no need to worry about adjustments.
\&    if (ref $map_ref\->[$i]) {
\&        push @range_list,
\&                   [ $list_ref\->[$i], $list_ref\->[$i], $map_ref\->[$i] ];
\&    }
\&    else {  # Otherwise each element is actually mapped to a separate
\&            # value, so the range has to be split into single code point
\&            # ranges.
\&
\&        my $adjustment = 0;
\&
\&        # For each code point that gets mapped to something...
\&        for my $j ($list_ref\->[$i] .. $list_ref\->[$i+1] \-1 ) {
\&
\&            # ... add a range consisting of just it mapping to the
\&            # original plus the adjustment, which is incremented for the
\&            # next time through the loop, as the offset increases by 1
\&            # for each element in the range
\&            push @range_list,
\&                             [ $j, $j, $map_ref\->[$i] + $adjustment++ ];
\&        }
\&    }
\& }
.Ve
.PP
Note that the inversion maps returned for the \f(CW\*(C`Case_Folding\*(C'\fR and
\&\f(CW\*(C`Simple_Case_Folding\*(C'\fR properties do not include the Turkic-locale mappings.
Use \*(L"\fIcasefold()\fR\*(R" for these.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR does not know about any user-defined properties, and will
return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "Unicode::UCD::UnicodeVersion"
.IX Subsection "Unicode::UCD::UnicodeVersion"
This returns the version of the Unicode Character Database, in other words, the
version of the Unicode standard the database implements.  The version is a
string of numbers delimited by dots (\f(CW\*(Aq.\*(Aq\fR).
.SS "\fBBlocks versus Scripts\fP"
.IX Subsection "Blocks versus Scripts"
The difference between a block and a script is that scripts are closer
to the linguistic notion of a set of code points required to present
languages, while block is more of an artifact of the Unicode code point
numbering and separation into blocks of consecutive code points (so far the
size of a block is some multiple of 16, like 128 or 256).
.PP
For example the Latin \fBscript\fR is spread over several \fBblocks\fR, such
as \f(CW\*(C`Basic Latin\*(C'\fR, \f(CW\*(C`Latin 1 Supplement\*(C'\fR, \f(CW\*(C`Latin Extended\-A\*(C'\fR, and
\&\f(CW\*(C`Latin Extended\-B\*(C'\fR.  On the other hand, the Latin script does not
contain all the characters of the \f(CW\*(C`Basic Latin\*(C'\fR block (also known as
\&\s-1ASCII\s0): it includes only the letters, and not, for example, the digits
or the punctuation.
.PP
For blocks see <http://www.unicode.org/Public/UNIDATA/Blocks.txt>
.PP
For scripts see \s-1UTR\s0 #24: <http://www.unicode.org/unicode/reports/tr24/>
.SS "\fBMatching Scripts and Blocks\fP"
.IX Subsection "Matching Scripts and Blocks"
Scripts are matched with the regular-expression construct
\&\f(CW\*(C`\ep{...}\*(C'\fR (e.g. \f(CW\*(C`\ep{Tibetan}\*(C'\fR matches characters of the Tibetan script),
while \f(CW\*(C`\ep{Blk=...}\*(C'\fR is used for blocks (e.g. \f(CW\*(C`\ep{Blk=Tibetan}\*(C'\fR matches
any of the 256 code points in the Tibetan block).
.SS "Old-style versus new-style block names"
.IX Subsection "Old-style versus new-style block names"
Unicode publishes the names of blocks in two different styles, though the two
are equivalent under Unicode's loose matching rules.
.PP
The original style uses blanks and hyphens in the block names (except for
\&\f(CW\*(C`No_Block\*(C'\fR), like so:
.PP
.Vb 1
\& Miscellaneous Mathematical Symbols\-B
.Ve
.PP
The newer style replaces these with underscores, like this:
.PP
.Vb 1
\& Miscellaneous_Mathematical_Symbols_B
.Ve
.PP
This newer style is consistent with the values of other Unicode properties.
To preserve backward compatibility, all the functions in Unicode::UCD that
return block names (except one) return the old-style ones.  That one function,
\&\*(L"\fIprop_value_aliases()\fR\*(R" can be used to convert from old-style to new-style:
.PP
.Vb 1
\& my $new_style = prop_values_aliases("block", $old_style);
.Ve
.PP
Perl also has single-form extensions that refer to blocks, \f(CW\*(C`In_Cyrillic\*(C'\fR,
meaning \f(CW\*(C`Block=Cyrillic\*(C'\fR.  These have always been written in the new style.
.PP
To convert from new-style to old-style, follow this recipe:
.PP
.Vb 1
\& $old_style = charblock((prop_invlist("block=$new_style"))[0]);
.Ve
.PP
(which finds the range of code points in the block using \f(CW\*(C`prop_invlist\*(C'\fR,
gets the lower end of the range (0th element) and then looks up the old name
for its block using \f(CW\*(C`charblock\*(C'\fR).
.PP
Note that starting in Unicode 6.1, many of the block names have shorter
synonyms.  These are always given in the new style.
.SH "BUGS"
.IX Header "BUGS"
Does not yet support \s-1EBCDIC\s0 platforms.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi.  Now maintained by perl5 porters.
                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Unicode::UCD5.16.3pm                         0100644 0001750 0001750 00000211522 12566207442 023724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Unicode::UCD 3pm"
.TH Unicode::UCD 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unicode::UCD \- Unicode character database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Unicode::UCD \*(Aqcharinfo\*(Aq;
\&    my $charinfo   = charinfo($codepoint);
\&
\&    use Unicode::UCD \*(Aqcasefold\*(Aq;
\&    my $casefold = casefold(0xFB00);
\&
\&    use Unicode::UCD \*(Aqcasespec\*(Aq;
\&    my $casespec = casespec(0xFB00);
\&
\&    use Unicode::UCD \*(Aqcharblock\*(Aq;
\&    my $charblock  = charblock($codepoint);
\&
\&    use Unicode::UCD \*(Aqcharscript\*(Aq;
\&    my $charscript = charscript($codepoint);
\&
\&    use Unicode::UCD \*(Aqcharblocks\*(Aq;
\&    my $charblocks = charblocks();
\&
\&    use Unicode::UCD \*(Aqcharscripts\*(Aq;
\&    my $charscripts = charscripts();
\&
\&    use Unicode::UCD qw(charscript charinrange);
\&    my $range = charscript($script);
\&    print "looks like $script\en" if charinrange($range, $codepoint);
\&
\&    use Unicode::UCD qw(general_categories bidi_types);
\&    my $categories = general_categories();
\&    my $types = bidi_types();
\&
\&    use Unicode::UCD \*(Aqprop_aliases\*(Aq;
\&    my @space_names = prop_aliases("space");
\&
\&    use Unicode::UCD \*(Aqprop_value_aliases\*(Aq;
\&    my @gc_punct_names = prop_value_aliases("Gc", "Punct");
\&
\&    use Unicode::UCD \*(Aqprop_invlist\*(Aq;
\&    my @puncts = prop_invlist("gc=punctuation");
\&
\&    use Unicode::UCD \*(Aqprop_invmap\*(Aq;
\&    my ($list_ref, $map_ref, $format, $missing)
\&                                      = prop_invmap("General Category");
\&
\&    use Unicode::UCD \*(Aqcompexcl\*(Aq;
\&    my $compexcl = compexcl($codepoint);
\&
\&    use Unicode::UCD \*(Aqnamedseq\*(Aq;
\&    my $namedseq = namedseq($named_sequence_name);
\&
\&    my $unicode_version = Unicode::UCD::UnicodeVersion();
\&
\&    my $convert_to_numeric =
\&              Unicode::UCD::num("\eN{RUMI DIGIT ONE}\eN{RUMI DIGIT TWO}");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Unicode::UCD module offers a series of functions that
provide a simple interface to the Unicode
Character Database.
.SS "code point argument"
.IX Subsection "code point argument"
Some of the functions are called with a \fIcode point argument\fR, which is either
a decimal or a hexadecimal scalar designating a Unicode code point, or \f(CW\*(C`U+\*(C'\fR
followed by hexadecimals designating a Unicode code point.  In other words, if
you want a code point to be interpreted as a hexadecimal number, you must
prefix it with either \f(CW\*(C`0x\*(C'\fR or \f(CW\*(C`U+\*(C'\fR, because a string like e.g. \f(CW123\fR will be
interpreted as a decimal code point.  Note that the largest code point in
Unicode is U+10FFFF.
.SS "\fB\fP\f(BIcharinfo()\fP\fB\fP"
.IX Subsection "charinfo()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharinfo\*(Aq;
\&
\&    my $charinfo = charinfo(0x41);
.Ve
.PP
This returns information about the input \*(L"code point argument\*(R"
as a reference to a hash of fields as defined by the Unicode
standard.  If the \*(L"code point argument\*(R" is not assigned in the standard
(i.e., has the general category \f(CW\*(C`Cn\*(C'\fR meaning \f(CW\*(C`Unassigned\*(C'\fR)
or is a non-character (meaning it is guaranteed to never be assigned in
the standard),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.PP
Fields that aren't applicable to the particular code point argument exist in the
returned hash, and are empty.
.PP
The keys in the hash with the meanings of their values are:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four hexdigits
.IP "\fBname\fR" 4
.IX Item "name"
name of \fIcode\fR, all \s-1IN\s0 \s-1UPPER\s0 \s-1CASE\s0.
Some control-type code points do not have names.
This field will be empty for \f(CW\*(C`Surrogate\*(C'\fR and \f(CW\*(C`Private Use\*(C'\fR code points,
and for the others without a name,
it will contain a description enclosed in angle brackets, like
\&\f(CW\*(C`<control>\*(C'\fR.
.IP "\fBcategory\fR" 4
.IX Item "category"
The short name of the general category of \fIcode\fR.
This will match one of the keys in the hash returned by \*(L"\fIgeneral_categories()\fR\*(R".
.Sp
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms
of the category name.
.IP "\fBcombining\fR" 4
.IX Item "combining"
the combining class number for \fIcode\fR used in the Canonical Ordering Algorithm.
For Unicode 5.1, this is described in Section 3.11 \f(CW\*(C`Canonical Ordering Behavior\*(C'\fR
available at
<http://www.unicode.org/versions/Unicode5.1.0/>
.Sp
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms
of the combining class number.
.IP "\fBbidi\fR" 4
.IX Item "bidi"
bidirectional type of \fIcode\fR.
This will match one of the keys in the hash returned by \*(L"\fIbidi_types()\fR\*(R".
.Sp
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms
of the bidi type name.
.IP "\fBdecomposition\fR" 4
.IX Item "decomposition"
is empty if \fIcode\fR has no decomposition; or is one or more codes
(separated by spaces) that, taken in order, represent a decomposition for
\&\fIcode\fR.  Each has at least four hexdigits.
The codes may be preceded by a word enclosed in angle brackets then a space,
like \f(CW\*(C`<compat> \*(C'\fR, giving the type of decomposition
.Sp
This decomposition may be an intermediate one whose components are also
decomposable.  Use Unicode::Normalize to get the final decomposition.
.IP "\fBdecimal\fR" 4
.IX Item "decimal"
if \fIcode\fR is a decimal digit this is its integer numeric value
.IP "\fBdigit\fR" 4
.IX Item "digit"
if \fIcode\fR represents some other digit-like number, this is its integer
numeric value
.IP "\fBnumeric\fR" 4
.IX Item "numeric"
if \fIcode\fR represents a whole or rational number, this is its numeric value.
Rational values are expressed as a string like \f(CW\*(C`1/4\*(C'\fR.
.IP "\fBmirrored\fR" 4
.IX Item "mirrored"
\&\f(CW\*(C`Y\*(C'\fR or \f(CW\*(C`N\*(C'\fR designating if \fIcode\fR is mirrored in bidirectional text
.IP "\fBunicode10\fR" 4
.IX Item "unicode10"
name of \fIcode\fR in the Unicode 1.0 standard if one
existed for this code point and is different from the current name
.IP "\fBcomment\fR" 4
.IX Item "comment"
As of Unicode 6.0, this is always empty.
.IP "\fBupper\fR" 4
.IX Item "upper"
is empty if there is no single code point uppercase mapping for \fIcode\fR
(its uppercase mapping is itself);
otherwise it is that mapping expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used in addition to \fB\f(BIcharinfo()\fB\fR
for case mappings when the calling program can cope with multiple code point
mappings.)
.IP "\fBlower\fR" 4
.IX Item "lower"
is empty if there is no single code point lowercase mapping for \fIcode\fR
(its lowercase mapping is itself);
otherwise it is that mapping expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used in addition to \fB\f(BIcharinfo()\fB\fR
for case mappings when the calling program can cope with multiple code point
mappings.)
.IP "\fBtitle\fR" 4
.IX Item "title"
is empty if there is no single code point titlecase mapping for \fIcode\fR
(its titlecase mapping is itself);
otherwise it is that mapping expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used in addition to \fB\f(BIcharinfo()\fB\fR
for case mappings when the calling program can cope with multiple code point
mappings.)
.IP "\fBblock\fR" 4
.IX Item "block"
the block \fIcode\fR belongs to (used in \f(CW\*(C`\ep{Blk=...}\*(C'\fR).
See \*(L"Blocks versus Scripts\*(R".
.IP "\fBscript\fR" 4
.IX Item "script"
the script \fIcode\fR belongs to.
See \*(L"Blocks versus Scripts\*(R".
.PP
Note that you cannot do (de)composition and casing based solely on the
\&\fIdecomposition\fR, \fIcombining\fR, \fIlower\fR, \fIupper\fR, and \fItitle\fR fields;
you will need also the \*(L"\fIcompexcl()\fR\*(R", and \*(L"\fIcasespec()\fR\*(R" functions.
.SS "\fB\fP\f(BIcharblock()\fP\fB\fP"
.IX Subsection "charblock()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharblock\*(Aq;
\&
\&    my $charblock = charblock(0x41);
\&    my $charblock = charblock(1234);
\&    my $charblock = charblock(0x263a);
\&    my $charblock = charblock("U+263a");
\&
\&    my $range     = charblock(\*(AqArmenian\*(Aq);
.Ve
.PP
With a \*(L"code point argument\*(R" \fIcharblock()\fR returns the \fIblock\fR the code point
belongs to, e.g.  \f(CW\*(C`Basic Latin\*(C'\fR.  The old-style block name is returned (see
\&\*(L"Old-style versus new-style block names\*(R").
If the code point is unassigned, this returns the block it would belong to if
it were assigned.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.PP
If supplied with an argument that can't be a code point, \fIcharblock()\fR tries to
do the opposite and interpret the argument as an old-style block name. The
return value
is a \fIrange set\fR with one range: an anonymous list with a single element that
consists of another anonymous list whose first element is the first code point
in the block, and whose second (and final) element is the final code point in
the block.  (The extra list consisting of just one element is so that the same
program logic can be used to handle both this return, and the return from
\&\*(L"\fIcharscript()\fR\*(R" which can have multiple ranges.) You can test whether a code
point is in a range using the \*(L"\fIcharinrange()\fR\*(R" function.  If the argument is
not a known block, \f(CW\*(C`undef\*(C'\fR is returned.
.SS "\fB\fP\f(BIcharscript()\fP\fB\fP"
.IX Subsection "charscript()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharscript\*(Aq;
\&
\&    my $charscript = charscript(0x41);
\&    my $charscript = charscript(1234);
\&    my $charscript = charscript("U+263a");
\&
\&    my $range      = charscript(\*(AqThai\*(Aq);
.Ve
.PP
With a \*(L"code point argument\*(R" \fIcharscript()\fR returns the \fIscript\fR the
code point belongs to, e.g.  \f(CW\*(C`Latin\*(C'\fR, \f(CW\*(C`Greek\*(C'\fR, \f(CW\*(C`Han\*(C'\fR.
If the code point is unassigned, it returns \f(CW"Unknown"\fR.
.PP
If supplied with an argument that can't be a code point, \fIcharscript()\fR tries
to do the opposite and interpret the argument as a script name. The
return value is a \fIrange set\fR: an anonymous list of lists that contain
\&\fIstart-of-range\fR, \fIend-of-range\fR code point pairs. You can test whether a
code point is in a range set using the \*(L"\fIcharinrange()\fR\*(R" function. If the
argument is not a known script, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharblocks()\fP\fB\fP"
.IX Subsection "charblocks()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharblocks\*(Aq;
\&
\&    my $charblocks = charblocks();
.Ve
.PP
\&\fIcharblocks()\fR returns a reference to a hash with the known block names
as the keys, and the code point ranges (see \*(L"\fIcharblock()\fR\*(R") as the values.
.PP
The names are in the old-style (see \*(L"Old-style versus new-style block
names\*(R").
.PP
prop_invmap(\*(L"block\*(R") can be used to get this same data in a
different type of data structure.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharscripts()\fP\fB\fP"
.IX Subsection "charscripts()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharscripts\*(Aq;
\&
\&    my $charscripts = charscripts();
.Ve
.PP
\&\fIcharscripts()\fR returns a reference to a hash with the known script
names as the keys, and the code point ranges (see \*(L"\fIcharscript()\fR\*(R") as
the values.
.PP
prop_invmap(\*(L"script\*(R") can be used to get this same data in a
different type of data structure.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharinrange()\fP\fB\fP"
.IX Subsection "charinrange()"
In addition to using the \f(CW\*(C`\ep{Blk=...}\*(C'\fR and \f(CW\*(C`\eP{Blk=...}\*(C'\fR constructs, you
can also test whether a code point is in the \fIrange\fR as returned by
\&\*(L"\fIcharblock()\fR\*(R" and \*(L"\fIcharscript()\fR\*(R" or as the values of the hash returned
by \*(L"\fIcharblocks()\fR\*(R" and \*(L"\fIcharscripts()\fR\*(R" by using \fIcharinrange()\fR:
.PP
.Vb 1
\&    use Unicode::UCD qw(charscript charinrange);
\&
\&    $range = charscript(\*(AqHiragana\*(Aq);
\&    print "looks like hiragana\en" if charinrange($range, $codepoint);
.Ve
.SS "\fB\fP\f(BIgeneral_categories()\fP\fB\fP"
.IX Subsection "general_categories()"
.Vb 1
\&    use Unicode::UCD \*(Aqgeneral_categories\*(Aq;
\&
\&    my $categories = general_categories();
.Ve
.PP
This returns a reference to a hash which has short
general category names (such as \f(CW\*(C`Lu\*(C'\fR, \f(CW\*(C`Nd\*(C'\fR, \f(CW\*(C`Zs\*(C'\fR, \f(CW\*(C`S\*(C'\fR) as keys and long
names (such as \f(CW\*(C`UppercaseLetter\*(C'\fR, \f(CW\*(C`DecimalNumber\*(C'\fR, \f(CW\*(C`SpaceSeparator\*(C'\fR,
\&\f(CW\*(C`Symbol\*(C'\fR) as values.  The hash is reversible in case you need to go
from the long names to the short names.  The general category is the
one returned from
\&\*(L"\fIcharinfo()\fR\*(R" under the \f(CW\*(C`category\*(C'\fR key.
.PP
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms of
the category name.
.SS "\fB\fP\f(BIbidi_types()\fP\fB\fP"
.IX Subsection "bidi_types()"
.Vb 1
\&    use Unicode::UCD \*(Aqbidi_types\*(Aq;
\&
\&    my $categories = bidi_types();
.Ve
.PP
This returns a reference to a hash which has the short
bidi (bidirectional) type names (such as \f(CW\*(C`L\*(C'\fR, \f(CW\*(C`R\*(C'\fR) as keys and long
names (such as \f(CW\*(C`Left\-to\-Right\*(C'\fR, \f(CW\*(C`Right\-to\-Left\*(C'\fR) as values.  The
hash is reversible in case you need to go from the long names to the
short names.  The bidi type is the one returned from
\&\*(L"\fIcharinfo()\fR\*(R"
under the \f(CW\*(C`bidi\*(C'\fR key.  For the exact meaning of the various bidi classes
the Unicode \s-1TR9\s0 is recommended reading:
<http://www.unicode.org/reports/tr9/>
(as of Unicode 5.0.0)
.PP
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms of
the bidi type name.
.SS "\fB\fP\f(BIcompexcl()\fP\fB\fP"
.IX Subsection "compexcl()"
.Vb 1
\&    use Unicode::UCD \*(Aqcompexcl\*(Aq;
\&
\&    my $compexcl = compexcl(0x09dc);
.Ve
.PP
This routine is included for backwards compatibility, but as of Perl 5.12, for
most purposes it is probably more convenient to use one of the following
instead:
.PP
.Vb 2
\&    my $compexcl = chr(0x09dc) =~ /\ep{Comp_Ex};
\&    my $compexcl = chr(0x09dc) =~ /\ep{Full_Composition_Exclusion};
.Ve
.PP
or even
.PP
.Vb 2
\&    my $compexcl = chr(0x09dc) =~ /\ep{CE};
\&    my $compexcl = chr(0x09dc) =~ /\ep{Composition_Exclusion};
.Ve
.PP
The first two forms return \fBtrue\fR if the \*(L"code point argument\*(R" should not
be produced by composition normalization.  For the final two forms to return
\&\fBtrue\fR, it is additionally required that this fact not otherwise be
determinable from the Unicode data base.
.PP
This routine behaves identically to the final two forms.  That is,
it does not return \fBtrue\fR if the code point has a decomposition
consisting of another single code point, nor if its decomposition starts
with a code point whose combining class is non-zero.  Code points that meet
either of these conditions should also not be produced by composition
normalization, which is probably why you should use the
\&\f(CW\*(C`Full_Composition_Exclusion\*(C'\fR property instead, as shown above.
.PP
The routine returns \fBfalse\fR otherwise.
.SS "\fB\fP\f(BIcasefold()\fP\fB\fP"
.IX Subsection "casefold()"
.Vb 1
\&    use Unicode::UCD \*(Aqcasefold\*(Aq;
\&
\&    my $casefold = casefold(0xDF);
\&    if (defined $casefold) {
\&        my @full_fold_hex = split / /, $casefold\->{\*(Aqfull\*(Aq};
\&        my $full_fold_string =
\&                    join "", map {chr(hex($_))} @full_fold_hex;
\&        my @turkic_fold_hex =
\&                        split / /, ($casefold\->{\*(Aqturkic\*(Aq} ne "")
\&                                        ? $casefold\->{\*(Aqturkic\*(Aq}
\&                                        : $casefold\->{\*(Aqfull\*(Aq};
\&        my $turkic_fold_string =
\&                        join "", map {chr(hex($_))} @turkic_fold_hex;
\&    }
\&    if (defined $casefold && $casefold\->{\*(Aqsimple\*(Aq} ne "") {
\&        my $simple_fold_hex = $casefold\->{\*(Aqsimple\*(Aq};
\&        my $simple_fold_string = chr(hex($simple_fold_hex));
\&    }
.Ve
.PP
This returns the (almost) locale-independent case folding of the
character specified by the \*(L"code point argument\*(R".  (Starting in Perl v5.16,
the core function \f(CW\*(C`fc()\*(C'\fR returns the \f(CW\*(C`full\*(C'\fR mapping (described below)
faster than this does, and for entire strings.)
.PP
If there is no case folding for the input code point, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
If there is a case folding for that code point, a reference to a hash
with the following fields is returned:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four hexdigits
.IP "\fBfull\fR" 4
.IX Item "full"
one or more codes (separated by spaces) that, taken in order, give the
code points for the case folding for \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBsimple\fR" 4
.IX Item "simple"
is empty, or is exactly one code with at least four hexdigits which can be used
as an alternative case folding when the calling program cannot cope with the
fold being a sequence of multiple code points.  If \fIfull\fR is just one code
point, then \fIsimple\fR equals \fIfull\fR.  If there is no single code point folding
defined for \fIcode\fR, then \fIsimple\fR is the empty string.  Otherwise, it is an
inferior, but still better-than-nothing alternative folding to \fIfull\fR.
.IP "\fBmapping\fR" 4
.IX Item "mapping"
is the same as \fIsimple\fR if \fIsimple\fR is not empty, and it is the same as \fIfull\fR
otherwise.  It can be considered to be the simplest possible folding for
\&\fIcode\fR.  It is defined primarily for backwards compatibility.
.IP "\fBstatus\fR" 4
.IX Item "status"
is \f(CW\*(C`C\*(C'\fR (for \f(CW\*(C`common\*(C'\fR) if the best possible fold is a single code point
(\fIsimple\fR equals \fIfull\fR equals \fImapping\fR).  It is \f(CW\*(C`S\*(C'\fR if there are distinct
folds, \fIsimple\fR and \fIfull\fR (\fImapping\fR equals \fIsimple\fR).  And it is \f(CW\*(C`F\*(C'\fR if
there is only a \fIfull\fR fold (\fImapping\fR equals \fIfull\fR; \fIsimple\fR is empty).
Note that this
describes the contents of \fImapping\fR.  It is defined primarily for backwards
compatibility.
.Sp
For Unicode versions between 3.1 and 3.1.1 inclusive, \fIstatus\fR can also be
\&\f(CW\*(C`I\*(C'\fR which is the same as \f(CW\*(C`C\*(C'\fR but is a special case for dotted uppercase I and
dotless lowercase i:
.RS 4
.ie n .IP "\fB*\fR If you use this ""I"" mapping" 4
.el .IP "\fB*\fR If you use this \f(CWI\fR mapping" 4
.IX Item "* If you use this I mapping"
the result is case-insensitive,
but dotless and dotted I's are not distinguished
.ie n .IP "\fB*\fR If you exclude this ""I"" mapping" 4
.el .IP "\fB*\fR If you exclude this \f(CWI\fR mapping" 4
.IX Item "* If you exclude this I mapping"
the result is not fully case-insensitive, but
dotless and dotted I's are distinguished
.RE
.RS 4
.RE
.IP "\fBturkic\fR" 4
.IX Item "turkic"
contains any special folding for Turkic languages.  For versions of Unicode
starting with 3.2, this field is empty unless \fIcode\fR has a different folding
in Turkic languages, in which case it is one or more codes (separated by
spaces) that, taken in order, give the code points for the case folding for
\&\fIcode\fR in those languages.
Each code has at least four hexdigits.
Note that this folding does not maintain canonical equivalence without
additional processing.
.Sp
For Unicode versions between 3.1 and 3.1.1 inclusive, this field is empty unless
there is a
special folding for Turkic languages, in which case \fIstatus\fR is \f(CW\*(C`I\*(C'\fR, and
\&\fImapping\fR, \fIfull\fR, \fIsimple\fR, and \fIturkic\fR are all equal.
.PP
Programs that want complete generality and the best folding results should use
the folding contained in the \fIfull\fR field.  But note that the fold for some
code points will be a sequence of multiple code points.
.PP
Programs that can't cope with the fold mapping being multiple code points can
use the folding contained in the \fIsimple\fR field, with the loss of some
generality.  In Unicode 5.1, about 7% of the defined foldings have no single
code point folding.
.PP
The \fImapping\fR and \fIstatus\fR fields are provided for backwards compatibility for
existing programs.  They contain the same values as in previous versions of
this function.
.PP
Locale is not completely independent.  The \fIturkic\fR field contains results to
use when the locale is a Turkic language.
.PP
For more information about case mappings see
<http://www.unicode.org/unicode/reports/tr21>
.SS "\fB\fP\f(BIcasespec()\fP\fB\fP"
.IX Subsection "casespec()"
.Vb 1
\&    use Unicode::UCD \*(Aqcasespec\*(Aq;
\&
\&    my $casespec = casespec(0xFB00);
.Ve
.PP
This returns the potentially locale-dependent case mappings of the \*(L"code point
argument\*(R".  The mappings may be longer than a single code point (which the basic
Unicode case mappings as returned by \*(L"\fIcharinfo()\fR\*(R" never are).
.PP
If there are no case mappings for the \*(L"code point argument\*(R", or if all three
possible mappings (\fIlower\fR, \fItitle\fR and \fIupper\fR) result in single code
points and are locale independent and unconditional, \f(CW\*(C`undef\*(C'\fR is returned
(which means that the case mappings, if any, for the code point are those
returned by \*(L"\fIcharinfo()\fR\*(R").
.PP
Otherwise, a reference to a hash giving the mappings (or a reference to a hash
of such hashes, explained below) is returned with the following keys and their
meanings:
.PP
The keys in the bottom layer hash with the meanings of their values are:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four hexdigits
.IP "\fBlower\fR" 4
.IX Item "lower"
one or more codes (separated by spaces) that, taken in order, give the
code points for the lower case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBtitle\fR" 4
.IX Item "title"
one or more codes (separated by spaces) that, taken in order, give the
code points for the title case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBupper\fR" 4
.IX Item "upper"
one or more codes (separated by spaces) that, taken in order, give the
code points for the upper case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBcondition\fR" 4
.IX Item "condition"
the conditions for the mappings to be valid.
If \f(CW\*(C`undef\*(C'\fR, the mappings are always valid.
When defined, this field is a list of conditions,
all of which must be true for the mappings to be valid.
The list consists of one or more
\&\fIlocales\fR (see below)
and/or \fIcontexts\fR (explained in the next paragraph),
separated by spaces.
(Other than as used to separate elements, spaces are to be ignored.)
Case distinctions in the condition list are not significant.
Conditions preceded by \*(L"\s-1NON_\s0\*(R" represent the negation of the condition.
.Sp
A \fIcontext\fR is one of those defined in the Unicode standard.
For Unicode 5.1, they are defined in Section 3.13 \f(CW\*(C`Default Case Operations\*(C'\fR
available at
<http://www.unicode.org/versions/Unicode5.1.0/>.
These are for context-sensitive casing.
.PP
The hash described above is returned for locale-independent casing, where
at least one of the mappings has length longer than one.  If \f(CW\*(C`undef\*(C'\fR is
returned, the code point may have mappings, but if so, all are length one,
and are returned by \*(L"\fIcharinfo()\fR\*(R".
Note that when this function does return a value, it will be for the complete
set of mappings for a code point, even those whose length is one.
.PP
If there are additional casing rules that apply only in certain locales,
an additional key for each will be defined in the returned hash.  Each such key
will be its locale name, defined as a 2\-letter \s-1ISO\s0 3166 country code, possibly
followed by a \*(L"_\*(R" and a 2\-letter \s-1ISO\s0 language code (possibly followed by a \*(L"_\*(R"
and a variant code).  You can find the lists of all possible locales, see
Locale::Country and Locale::Language.
(In Unicode 6.0, the only locales returned by this function
are \f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, and \f(CW\*(C`az\*(C'\fR.)
.PP
Each locale key is a reference to a hash that has the form above, and gives
the casing rules for that particular locale, which take precedence over the
locale-independent ones when in that locale.
.PP
If the only casing for a code point is locale-dependent, then the returned
hash will not have any of the base keys, like \f(CW\*(C`code\*(C'\fR, \f(CW\*(C`upper\*(C'\fR, etc., but
will contain only locale keys.
.PP
For more information about case mappings see
<http://www.unicode.org/unicode/reports/tr21/>
.SS "\fB\fP\f(BInamedseq()\fP\fB\fP"
.IX Subsection "namedseq()"
.Vb 1
\&    use Unicode::UCD \*(Aqnamedseq\*(Aq;
\&
\&    my $namedseq = namedseq("KATAKANA LETTER AINU P");
\&    my @namedseq = namedseq("KATAKANA LETTER AINU P");
\&    my %namedseq = namedseq();
.Ve
.PP
If used with a single argument in a scalar context, returns the string
consisting of the code points of the named sequence, or \f(CW\*(C`undef\*(C'\fR if no
named sequence by that name exists.  If used with a single argument in
a list context, it returns the list of the ordinals of the code points.  If used
with no
arguments in a list context, returns a hash with the names of the
named sequences as the keys and the named sequences as strings as
the values.  Otherwise, it returns \f(CW\*(C`undef\*(C'\fR or an empty list depending
on the context.
.PP
This function only operates on officially approved (not provisional) named
sequences.
.PP
Note that as of Perl 5.14, \f(CW\*(C`\eN{KATAKANA LETTER AINU P}\*(C'\fR will insert the named
sequence into double-quoted strings, and \f(CW\*(C`charnames::string_vianame("KATAKANA
LETTER AINU P")\*(C'\fR will return the same string this function does, but will also
operate on character names that aren't named sequences, without you having to
know which are which.  See charnames.
.SS "\fB\fP\f(BInum()\fP\fB\fP"
.IX Subsection "num()"
.Vb 1
\&    use Unicode::UCD \*(Aqnum\*(Aq;
\&
\&    my $val = num("123");
\&    my $one_quarter = num("\eN{VULGAR FRACTION 1/4}");
.Ve
.PP
\&\f(CW\*(C`num\*(C'\fR returns the numeric value of the input Unicode string; or \f(CW\*(C`undef\*(C'\fR if it
doesn't think the entire string has a completely valid, safe numeric value.
.PP
If the string is just one character in length, the Unicode numeric value
is returned if it has one, or \f(CW\*(C`undef\*(C'\fR otherwise.  Note that this need
not be a whole number.  \f(CW\*(C`num("\eN{TIBETAN DIGIT HALF ZERO}")\*(C'\fR, for
example returns \-0.5.
.PP
If the string is more than one character, \f(CW\*(C`undef\*(C'\fR is returned unless
all its characters are decimal digits (that is, they would match \f(CW\*(C`\ed+\*(C'\fR),
from the same script.  For example if you have an \s-1ASCII\s0 '0' and a Bengali
\&'3', mixed together, they aren't considered a valid number, and \f(CW\*(C`undef\*(C'\fR
is returned.  A further restriction is that the digits all have to be of
the same form.  A half-width digit mixed with a full-width one will
return \f(CW\*(C`undef\*(C'\fR.  The Arabic script has two sets of digits;  \f(CW\*(C`num\*(C'\fR will
return \f(CW\*(C`undef\*(C'\fR unless all the digits in the string come from the same
set.
.PP
\&\f(CW\*(C`num\*(C'\fR errs on the side of safety, and there may be valid strings of
decimal digits that it doesn't recognize.  Note that Unicode defines
a number of \*(L"digit\*(R" characters that aren't \*(L"decimal digit\*(R" characters.
\&\*(L"Decimal digits\*(R" have the property that they have a positional value, i.e.,
there is a units position, a 10's position, a 100's, etc, \s-1AND\s0 they are
arranged in Unicode in blocks of 10 contiguous code points.  The Chinese
digits, for example, are not in such a contiguous block, and so Unicode
doesn't view them as decimal digits, but merely digits, and so \f(CW\*(C`\ed\*(C'\fR will not
match them.  A single-character string containing one of these digits will
have its decimal value returned by \f(CW\*(C`num\*(C'\fR, but any longer string containing
only these digits will return \f(CW\*(C`undef\*(C'\fR.
.PP
Strings of multiple sub\- and superscripts are not recognized as numbers.  You
can use either of the compatibility decompositions in Unicode::Normalize to
change these into digits, and then call \f(CW\*(C`num\*(C'\fR on the result.
.SS "\fB\fP\f(BIprop_aliases()\fP\fB\fP"
.IX Subsection "prop_aliases()"
.Vb 1
\&    use Unicode::UCD \*(Aqprop_aliases\*(Aq;
\&
\&    my ($short_name, $full_name, @other_names) = prop_aliases("space");
\&    my $same_full_name = prop_aliases("Space");     # Scalar context
\&    my ($same_short_name) = prop_aliases("Space");  # gets 0th element
\&    print "The full name is $full_name\en";
\&    print "The short name is $short_name\en";
\&    print "The other aliases are: ", join(", ", @other_names), "\en";
\&
\&    prints:
\&    The full name is White_Space
\&    The short name is WSpace
\&    The other aliases are: Space
.Ve
.PP
Most Unicode properties have several synonymous names.  Typically, there is at
least a short name, convenient to type, and a long name that more fully
describes the property, and hence is more easily understood.
.PP
If you know one name for a Unicode property, you can use \f(CW\*(C`prop_aliases\*(C'\fR to find
either the long name (when called in scalar context), or a list of all of the
names, somewhat ordered so that the short name is in the 0th element, the long
name in the next element, and any other synonyms are in the remaining
elements, in no particular order.
.PP
The long name is returned in a form nicely capitalized, suitable for printing.
.PP
The input parameter name is loosely matched, which means that white space,
hyphens, and underscores are ignored (except for the trailing underscore in
the old_form grandfathered-in \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR, and
both of which mean \f(CW\*(C`General_Category=Cased Letter\*(C'\fR).
.PP
If the name is unknown, \f(CW\*(C`undef\*(C'\fR is returned (or an empty list in list
context).  Note that Perl typically recognizes property names in regular
expressions with an optional \f(CW\*(C`"Is_\*(C'\fR" (with or without the underscore)
prefixed to them, such as \f(CW\*(C`\ep{isgc=punct}\*(C'\fR.  This function does not recognize
those in the input, returning \f(CW\*(C`undef\*(C'\fR.  Nor are they included in the output
as possible synonyms.
.PP
\&\f(CW\*(C`prop_aliases\*(C'\fR does know about the Perl extensions to Unicode properties,
such as \f(CW\*(C`Any\*(C'\fR and \f(CW\*(C`XPosixAlpha\*(C'\fR, and the single form equivalents to Unicode
properties such as \f(CW\*(C`XDigit\*(C'\fR, \f(CW\*(C`Greek\*(C'\fR, \f(CW\*(C`In_Greek\*(C'\fR, and \f(CW\*(C`Is_Greek\*(C'\fR.  The
final example demonstrates that the \f(CW"Is_"\fR prefix is recognized for these
extensions; it is needed to resolve ambiguities.  For example,
\&\f(CW\*(C`prop_aliases(\*(Aqlc\*(Aq)\*(C'\fR returns the list \f(CW\*(C`(lc, Lowercase_Mapping)\*(C'\fR, but
\&\f(CW\*(C`prop_aliases(\*(Aqislc\*(Aq)\*(C'\fR returns \f(CW\*(C`(Is_LC, Cased_Letter)\*(C'\fR.  This is
because \f(CW\*(C`islc\*(C'\fR is a Perl extension which is short for
\&\f(CW\*(C`General_Category=Cased Letter\*(C'\fR.  The lists returned for the Perl extensions
will not include the \f(CW"Is_"\fR prefix (whether or not the input had it) unless
needed to resolve ambiguities, as shown in the \f(CW"islc"\fR example, where the
returned list had one element containing \f(CW"Is_"\fR, and the other without.
.PP
It is also possible for the reverse to happen:  \f(CW\*(C`prop_aliases(\*(Aqisc\*(Aq)\*(C'\fR returns
the list \f(CW\*(C`(isc, ISO_Comment)\*(C'\fR; whereas \f(CW\*(C`prop_aliases(\*(Aqc\*(Aq)\*(C'\fR returns
\&\f(CW\*(C`(C, Other)\*(C'\fR (the latter being a Perl extension meaning
\&\f(CW\*(C`General_Category=Other\*(C'\fR.
\&\*(L"Properties accessible through Unicode::UCD\*(R" in perluniprops lists the available
forms, including which ones are discouraged from use.
.PP
Those discouraged forms are accepted as input to \f(CW\*(C`prop_aliases\*(C'\fR, but are not
returned in the lists.  \f(CW\*(C`prop_aliases(\*(AqisL&\*(Aq)\*(C'\fR and \f(CW\*(C`prop_aliases(\*(AqisL_\*(Aq)\*(C'\fR,
which are old synonyms for \f(CW"Is_LC"\fR and should not be used in new code, are
examples of this.  These both return \f(CW\*(C`(Is_LC, Cased_Letter)\*(C'\fR.  Thus this
function allows you to take a discourarged form, and find its acceptable
alternatives.  The same goes with single-form Block property equivalences.
Only the forms that begin with \f(CW"In_"\fR are not discouraged; if you pass
\&\f(CW\*(C`prop_aliases\*(C'\fR a discouraged form, you will get back the equivalent ones that
begin with \f(CW"In_"\fR.  It will otherwise look like a new-style block name (see.
\&\*(L"Old-style versus new-style block names\*(R").
.PP
\&\f(CW\*(C`prop_aliases\*(C'\fR does not know about any user-defined properties, and will
return \f(CW\*(C`undef\*(C'\fR if called with one of those.  Likewise for Perl internal
properties, with the exception of \*(L"Perl_Decimal_Digit\*(R" which it does know
about (and which is documented below in \*(L"\fIprop_invmap()\fR\*(R").
.SS "\fB\fP\f(BIprop_value_aliases()\fP\fB\fP"
.IX Subsection "prop_value_aliases()"
.Vb 1
\&    use Unicode::UCD \*(Aqprop_value_aliases\*(Aq;
\&
\&    my ($short_name, $full_name, @other_names)
\&                                   = prop_value_aliases("Gc", "Punct");
\&    my $same_full_name = prop_value_aliases("Gc", "P");   # Scalar cntxt
\&    my ($same_short_name) = prop_value_aliases("Gc", "P"); # gets 0th
\&                                                           # element
\&    print "The full name is $full_name\en";
\&    print "The short name is $short_name\en";
\&    print "The other aliases are: ", join(", ", @other_names), "\en";
\&
\&    prints:
\&    The full name is Punctuation
\&    The short name is P
\&    The other aliases are: Punct
.Ve
.PP
Some Unicode properties have a restricted set of legal values.  For example,
all binary properties are restricted to just \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR; and there
are only a few dozen possible General Categories.
.PP
For such properties, there are usually several synonyms for each possible
value.  For example, in binary properties, \fItruth\fR can be represented by any of
the strings \*(L"Y\*(R", \*(L"Yes\*(R", \*(L"T\*(R", or \*(L"True\*(R"; and the General Category
\&\*(L"Punctuation\*(R" by that string, or \*(L"Punct\*(R", or simply \*(L"P\*(R".
.PP
Like property names, there is typically at least a short name for each such
property-value, and a long name.  If you know any name of the property-value,
you can use \f(CW\*(C`prop_value_aliases\*(C'\fR() to get the long name (when called in
scalar context), or a list of all the names, with the short name in the 0th
element, the long name in the next element, and any other synonyms in the
remaining elements, in no particular order, except that any all-numeric
synonyms will be last.
.PP
The long name is returned in a form nicely capitalized, suitable for printing.
.PP
Case, white space, hyphens, and underscores are ignored in the input parameters
(except for the trailing underscore in the old-form grandfathered-in general
category property value \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR).
.PP
If either name is unknown, \f(CW\*(C`undef\*(C'\fR is returned.  Note that Perl typically
recognizes property names in regular expressions with an optional \f(CW\*(C`"Is_\*(C'\fR"
(with or without the underscore) prefixed to them, such as \f(CW\*(C`\ep{isgc=punct}\*(C'\fR.
This function does not recognize those in the property parameter, returning
\&\f(CW\*(C`undef\*(C'\fR.
.PP
If called with a property that doesn't have synonyms for its values, it
returns the input value, possibly normalized with capitalization and
underscores.
.PP
For the block property, new-style block names are returned (see
\&\*(L"Old-style versus new-style block names\*(R").
.PP
To find the synonyms for single-forms, such as \f(CW\*(C`\ep{Any}\*(C'\fR, use
\&\*(L"\fIprop_aliases()\fR\*(R" instead.
.PP
\&\f(CW\*(C`prop_value_aliases\*(C'\fR does not know about any user-defined properties, and
will return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "\fB\fP\f(BIprop_invlist()\fP\fB\fP"
.IX Subsection "prop_invlist()"
\&\f(CW\*(C`prop_invlist\*(C'\fR returns an inversion list (described below) that defines all the
code points for the binary Unicode property (or \*(L"property=value\*(R" pair) given
by the input parameter string:
.PP
.Vb 3
\& use feature \*(Aqsay\*(Aq;
\& use Unicode::UCD \*(Aqprop_invlist\*(Aq;
\& say join ", ", prop_invlist("Any");
\&
\& prints:
\& 0, 1114112
.Ve
.PP
An empty list is returned if the input is unknown; the number of elements in
the list is returned if called in scalar context.
.PP
perluniprops gives
the list of properties that this function accepts, as well as all the possible
forms for them (including with the optional \*(L"Is_\*(R" prefixes).  (Except this
function doesn't accept any Perl-internal properties, some of which are listed
there.) This function uses the same loose or tighter matching rules for
resolving the input property's name as is done for regular expressions.  These
are also specified in perluniprops.  Examples of using the \*(L"property=value\*(R" form are:
.PP
.Vb 1
\& say join ", ", prop_invlist("Script=Shavian");
\&
\& prints:
\& 66640, 66688
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=No");
\&
\& prints:
\& 0, 48, 58, 65, 71, 97, 103
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=Yes");
\&
\& prints:
\& 48, 58, 65, 71, 97, 103
.Ve
.PP
Inversion lists are a compact way of specifying Unicode property-value
definitions.  The 0th item in the list is the lowest code point that has the
property-value.  The next item (item [1]) is the lowest code point beyond that
one that does \s-1NOT\s0 have the property-value.  And the next item beyond that
([2]) is the lowest code point beyond that one that does have the
property-value, and so on.  Put another way, each element in the list gives
the beginning of a range that has the property-value (for even numbered
elements), or doesn't have the property-value (for odd numbered elements).
The name for this data structure stems from the fact that each element in the
list toggles (or inverts) whether the corresponding range is or isn't on the
list.
.PP
In the final example above, the first \s-1ASCII\s0 Hex digit is code point 48, the
character \*(L"0\*(R", and all code points from it through 57 (a \*(L"9\*(R") are \s-1ASCII\s0 hex
digits.  Code points 58 through 64 aren't, but 65 (an \*(L"A\*(R") through 70 (an \*(L"F\*(R")
are, as are 97 (\*(L"a\*(R") through 102 (\*(L"f\*(R").  103 starts a range of code points
that aren't \s-1ASCII\s0 hex digits.  That range extends to infinity, which on your
computer can be found in the variable \f(CW$Unicode::UCD::MAX_CP\fR.  (This
variable is as close to infinity as Perl can get on your platform, and may be
too high for some operations to work; you may wish to use a smaller number for
your purposes.)
.PP
Note that the inversion lists returned by this function can possibly include
non-Unicode code points, that is anything above 0x10FFFF.  This is in
contrast to Perl regular expression matches on those code points, in which a
non-Unicode code point always fails to match.  For example, both of these have
the same result:
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Fails!
.Ve
.PP
And both raise a warning that a Unicode property is being used on a
non-Unicode code point.  It is arguable as to which is the correct thing to do
here.  This function has chosen the way opposite to the Perl regular
expression behavior.  This allows you to easily flip to to the Perl regular
expression way (for you to go in the other direction would be far harder).
Simply add 0x110000 at the end of the non-empty returned list if it isn't
already that value; and pop that value if it is; like:
.PP
.Vb 9
\& my @list = prop_invlist("foo");
\& if (@list) {
\&     if ($list[\-1] == 0x110000) {
\&         pop @list;  # Defeat the turning on for above Unicode
\&     }
\&     else {
\&         push @list, 0x110000; # Turn off for above Unicode
\&     }
\& }
.Ve
.PP
It is a simple matter to expand out an inversion list to a full list of all
code points that have the property-value:
.PP
.Vb 10
\& my @invlist = prop_invlist($property_name);
\& die "empty" unless @invlist;
\& my @full_list;
\& for (my $i = 0; $i < @invlist; $i += 2) {
\&    my $upper = ($i + 1) < @invlist
\&                ? $invlist[$i+1] \- 1      # In range
\&                : $Unicode::UCD::MAX_CP;  # To infinity.  You may want
\&                                          # to stop much much earlier;
\&                                          # going this high may expose
\&                                          # perl deficiencies with very
\&                                          # large numbers.
\&    for my $j ($invlist[$i] .. $upper) {
\&        push @full_list, $j;
\&    }
\& }
.Ve
.PP
\&\f(CW\*(C`prop_invlist\*(C'\fR does not know about any user-defined nor Perl internal-only
properties, and will return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "\fB\fP\f(BIprop_invmap()\fP\fB\fP"
.IX Subsection "prop_invmap()"
.Vb 3
\& use Unicode::UCD \*(Aqprop_invmap\*(Aq;
\& my ($list_ref, $map_ref, $format, $missing)
\&                                      = prop_invmap("General Category");
.Ve
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is used to get the complete mapping definition for a property,
in the form of an inversion map.  An inversion map consists of two parallel
arrays.  One is an ordered list of code points that mark range beginnings, and
the other gives the value (or mapping) that all code points in the
corresponding range have.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is called with the name of the desired property.  The name is
loosely matched, meaning that differences in case, white-space, hyphens, and
underscores are not meaningful (except for the trailing underscore in the
old-form grandfathered-in property \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR,
or even better, \f(CW"Gc=LC"\fR).
.PP
Many Unicode properties have more than one name (or alias).  \f(CW\*(C`prop_invmap\*(C'\fR
understands all of these, including Perl extensions to them.  Ambiguities are
resolved as described above for \*(L"\fIprop_aliases()\fR\*(R".  The Perl internal
property "Perl_Decimal_Digit, described below, is also accepted.  \f(CW\*(C`undef\*(C'\fR is
returned if the property name is unknown.
See \*(L"Properties accessible through Unicode::UCD\*(R" in perluniprops for the
properties acceptable as inputs to this function.
.PP
It is a fatal error to call this function except in list context.
.PP
In addition to the the two arrays that form the inversion map, \f(CW\*(C`prop_invmap\*(C'\fR
returns two other values; one is a scalar that gives some details as to the
format of the entries of the map array; the other is used for specialized
purposes, described at the end of this section.
.PP
This means that \f(CW\*(C`prop_invmap\*(C'\fR returns a 4 element list.  For example,
.PP
.Vb 2
\& my ($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
\&                                                 = prop_invmap("Block");
.Ve
.PP
In this call, the two arrays will be populated as shown below (for Unicode
6.0):
.PP
.Vb 10
\& Index  @blocks_ranges  @blocks_maps
\&   0        0x0000      Basic Latin
\&   1        0x0080      Latin\-1 Supplement
\&   2        0x0100      Latin Extended\-A
\&   3        0x0180      Latin Extended\-B
\&   4        0x0250      IPA Extensions
\&   5        0x02B0      Spacing Modifier Letters
\&   6        0x0300      Combining Diacritical Marks
\&   7        0x0370      Greek and Coptic
\&   8        0x0400      Cyrillic
\&  ...
\& 233        0x2B820     No_Block
\& 234        0x2F800     CJK Compatibility Ideographs Supplement
\& 235        0x2FA20     No_Block
\& 236        0xE0000     Tags
\& 237        0xE0080     No_Block
\& 238        0xE0100     Variation Selectors Supplement
\& 239        0xE01F0     No_Block
\& 240        0xF0000     Supplementary Private Use Area\-A
\& 241        0x100000    Supplementary Private Use Area\-B
\& 242        0x110000    No_Block
.Ve
.PP
The first line (with Index [0]) means that the value for code point 0 is \*(L"Basic
Latin\*(R".  The entry \*(L"0x0080\*(R" in the \f(CW@blocks_ranges\fR column in the second line
means that the value from the first line, \*(L"Basic Latin\*(R", extends to all code
points in the range from 0 up to but not including 0x0080, that is, through
127.  In other words, the code points from 0 to 127 are all in the \*(L"Basic
Latin\*(R" block.  Similarly, all code points in the range from 0x0080 up to (but
not including) 0x0100 are in the block named \*(L"Latin\-1 Supplement\*(R", etc.
(Notice that the return is the old-style block names; see \*(L"Old-style versus
new-style block names\*(R").
.PP
The final line (with Index [242]) means that the value for all code points above
the legal Unicode maximum code point have the value \*(L"No_Block\*(R", which is the
term Unicode uses for a non-existing block.
.PP
The arrays completely specify the mappings for all possible code points.
The final element in an inversion map returned by this function will always be
for the range that consists of all the code points that aren't legal Unicode,
but that are expressible on the platform.  (That is, it starts with code point
0x110000, the first code point above the legal Unicode maximum, and extends to
infinity.) The value for that range will be the same that any typical
unassigned code point has for the specified property.  (Certain unassigned
code points are not \*(L"typical\*(R"; for example the non-character code points, or
those in blocks that are to be written right-to-left.  The above-Unicode
range's value is not based on these atypical code points.)  It could be argued
that, instead of treating these as unassigned Unicode code points, the value
for this range should be \f(CW\*(C`undef\*(C'\fR.  If you wish, you can change the returned
arrays accordingly.
.PP
The maps are almost always simple scalars that should be interpreted as-is.
These values are those given in the Unicode-supplied data files, which may be
inconsistent as to capitalization and as to which synonym for a property-value
is given.  The results may be normalized by using the \*(L"\fIprop_value_aliases()\fR\*(R"
function.
.PP
There are exceptions to the simple scalar maps.  Some properties have some
elements in their map list that are themselves lists of scalars; and some
special strings are returned that are not to be interpreted as-is.  Element
[2] (placed into \f(CW$format\fR in the example above) of the returned four element
list tells you if the map has any of these special elements or not, as follows:
.ie n .IP "\fB\fB""s""\fB\fR" 4
.el .IP "\fB\f(CBs\fB\fR" 4
.IX Item "s"
means all the elements of the map array are simple scalars, with no special
elements.  Almost all properties are like this, like the \f(CW\*(C`block\*(C'\fR example
above.
.ie n .IP "\fB\fB""sl""\fB\fR" 4
.el .IP "\fB\f(CBsl\fB\fR" 4
.IX Item "sl"
means that some of the map array elements have the form given by \f(CW"s"\fR, and
the rest are lists of scalars.  For example, here is a portion of the output
of calling \f(CW\*(C`prop_invmap\*(C'\fR() with the \*(L"Script Extensions\*(R" property:
.Sp
.Vb 6
\& @scripts_ranges  @scripts_maps
\&      ...
\&      0x0953      Devanagari
\&      0x0964      [ Bengali, Devanagari, Gurumukhi, Oriya ]
\&      0x0966      Devanagari
\&      0x0970      Common
.Ve
.Sp
Here, the code points 0x964 and 0x965 are both used in Bengali,
Devanagari, Gurmukhi, and Oriya, but no other scripts.
.Sp
The Name_Alias property is also of this form.  But each scalar consists of two
components:  1) the name, and 2) the type of alias this is.  They are
separated by a colon and a space.  In Unicode 6.1, there are several alias types:
.RS 4
.ie n .IP """correction""" 4
.el .IP "\f(CWcorrection\fR" 4
.IX Item "correction"
indicates that the name is a corrected form for the
original name (which remains valid) for the same code point.
.ie n .IP """control""" 4
.el .IP "\f(CWcontrol\fR" 4
.IX Item "control"
adds a new name for a control character.
.ie n .IP """alternate""" 4
.el .IP "\f(CWalternate\fR" 4
.IX Item "alternate"
is an alternate name for a character
.ie n .IP """figment""" 4
.el .IP "\f(CWfigment\fR" 4
.IX Item "figment"
is a name for a character that has been documented but was never in any
actual standard.
.ie n .IP """abbreviation""" 4
.el .IP "\f(CWabbreviation\fR" 4
.IX Item "abbreviation"
is a common abbreviation for a character
.RE
.RS 4
.Sp
The lists are ordered (roughly) so the most preferred names come before less
preferred ones.
.Sp
For example,
.Sp
.Vb 10
\& @aliases_ranges        @alias_maps
\&    ...
\&    0x009E        [ \*(AqPRIVACY MESSAGE: control\*(Aq, \*(AqPM: abbreviation\*(Aq ]
\&    0x009F        [ \*(AqAPPLICATION PROGRAM COMMAND: control\*(Aq,
\&                    \*(AqAPC: abbreviation\*(Aq
\&                  ]
\&    0x00A0        \*(AqNBSP: abbreviation\*(Aq
\&    0x00A1        ""
\&    0x00AD        \*(AqSHY: abbreviation\*(Aq
\&    0x00AE        ""
\&    0x01A2        \*(AqLATIN CAPITAL LETTER GHA: correction\*(Aq
\&    0x01A3        \*(AqLATIN SMALL LETTER GHA: correction\*(Aq
\&    0x01A4        ""
\&    ...
.Ve
.Sp
A map to the empty string means that there is no alias defined for the code
point.
.RE
.ie n .IP "\fB\fB""a""\fB\fR" 4
.el .IP "\fB\f(CBa\fB\fR" 4
.IX Item "a"
is like \f(CW"s"\fR in that all the map array elements are scalars, but here they are
restricted to all being integers, and some have to be adjusted (hence the name
\&\f(CW"a"\fR) to get the correct result.  For example, in:
.Sp
.Vb 2
\& my ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                          = prop_invmap("Simple_Uppercase_Mapping");
.Ve
.Sp
the returned arrays look like this:
.Sp
.Vb 7
\& @$uppers_ranges_ref    @$uppers_maps_ref   Note
\&       0                      0
\&      97                     65          \*(Aqa\*(Aq maps to \*(AqA\*(Aq, b => B ...
\&     123                      0
\&     181                    924          MICRO SIGN => Greek Cap MU
\&     182                      0
\&     ...
.Ve
.Sp
Let's start with the second line.  It says that the uppercase of code point 97
is 65; or \f(CW\*(C`uc("a")\*(C'\fR == \*(L"A\*(R".  But the line is for the entire range of code
points 97 through 122.  To get the mapping for any code point in a range, you
take the offset it has from the beginning code point of the range, and add
that to the mapping for that first code point.  So, the mapping for 122 (\*(L"z\*(R")
is derived by taking the offset of 122 from 97 (=25) and adding that to 65,
yielding 90 (\*(L"z\*(R").  Likewise for everything in between.
.Sp
The first line works the same way.  The first map in a range is always the
correct value for its code point (because the adjustment is 0).  Thus the
\&\f(CW\*(C`uc(chr(0))\*(C'\fR is just itself.  Also, \f(CW\*(C`uc(chr(1))\*(C'\fR is also itself, as the
adjustment is 0+1\-0 .. \f(CW\*(C`uc(chr(96))\*(C'\fR is 96.
.Sp
Requiring this simple adjustment allows the returned arrays to be
significantly smaller than otherwise, up to a factor of 10, speeding up
searching through them.
.ie n .IP "\fB\fB""al""\fB\fR" 4
.el .IP "\fB\f(CBal\fB\fR" 4
.IX Item "al"
means that some of the map array elements have the form given by \f(CW"a"\fR, and
the rest are ordered lists of code points.
For example, in:
.Sp
.Vb 2
\& my ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                                 = prop_invmap("Uppercase_Mapping");
.Ve
.Sp
the returned arrays look like this:
.Sp
.Vb 11
\& @$uppers_ranges_ref    @$uppers_maps_ref
\&       0                      0
\&      97                     65
\&     123                      0
\&     181                    924
\&     182                      0
\&     ...
\&    0x0149              [ 0x02BC 0x004E ]
\&    0x014A                    0
\&    0x014B                  330
\&     ...
.Ve
.Sp
This is the full Uppercase_Mapping property (as opposed to the
Simple_Uppercase_Mapping given in the example for format \f(CW"a"\fR).  The only
difference between the two in the ranges shown is that the code point at
0x0149 (\s-1LATIN\s0 \s-1SMALL\s0 \s-1LETTER\s0 N \s-1PRECEDED\s0 \s-1BY\s0 \s-1APOSTROPHE\s0) maps to a string of two
characters, 0x02BC (\s-1MODIFIER\s0 \s-1LETTER\s0 \s-1APOSTROPHE\s0) followed by 0x004E (\s-1LATIN\s0
\&\s-1CAPITAL\s0 \s-1LETTER\s0 N).
.Sp
No adjustments are needed to entries that are references to arrays; each such
entry will have exactly one element in its range, so the offset is always 0.
.ie n .IP "\fB\fB""ae""\fB\fR" 4
.el .IP "\fB\f(CBae\fB\fR" 4
.IX Item "ae"
This is like \f(CW"a"\fR, but some elements are the empty string, and should not be
adjusted.
The one internal Perl property accessible by \f(CW\*(C`prop_invmap\*(C'\fR is of this type:
\&\*(L"Perl_Decimal_Digit\*(R" returns an inversion map which gives the numeric values
that are represented by the Unicode decimal digit characters.  Characters that
don't represent decimal digits map to the empty string, like so:
.Sp
.Vb 12
\& @digits    @values
\& 0x0000       ""
\& 0x0030        0
\& 0x003A:      ""
\& 0x0660:       0
\& 0x066A:      ""
\& 0x06F0:       0
\& 0x06FA:      ""
\& 0x07C0:       0
\& 0x07CA:      ""
\& 0x0966:       0
\& ...
.Ve
.Sp
This means that the code points from 0 to 0x2F do not represent decimal digits;
the code point 0x30 (\s-1DIGIT\s0 \s-1ZERO\s0) represents 0;  code point 0x31, (\s-1DIGIT\s0 \s-1ONE\s0),
represents 0+1\-0 = 1; ... code point 0x39, (\s-1DIGIT\s0 \s-1NINE\s0), represents 0+9\-0 = 9;
\&... code points 0x3A through 0x65F do not represent decimal digits; 0x660
(ARABIC-INDIC \s-1DIGIT\s0 \s-1ZERO\s0), represents 0; ... 0x07C1 (\s-1NKO\s0 \s-1DIGIT\s0 \s-1ONE\s0),
represents 0+1\-0 = 1 ...
.ie n .IP "\fB\fB""ale""\fB\fR" 4
.el .IP "\fB\f(CBale\fB\fR" 4
.IX Item "ale"
is a combination of the \f(CW"al"\fR type and the \f(CW"ae"\fR type.  Some of
the map array elements have the forms given by \f(CW"al"\fR, and
the rest are the empty string.  The property \f(CW\*(C`NFKC_Casefold\*(C'\fR has this form.
An example slice is:
.Sp
.Vb 9
\& @$ranges_ref  @$maps_ref         Note
\&    ...
\&   0x00AA       97                FEMININE ORDINAL INDICATOR => \*(Aqa\*(Aq
\&   0x00AB        0
\&   0x00AD                         SOFT HYPHEN => ""
\&   0x00AE        0
\&   0x00AF     [ 0x0020, 0x0304 ]  MACRON => SPACE . COMBINING MACRON
\&   0x00B0        0
\&   ...
.Ve
.ie n .IP "\fB\fB""ar""\fB\fR" 4
.el .IP "\fB\f(CBar\fB\fR" 4
.IX Item "ar"
means that all the elements of the map array are either rational numbers or
the string \f(CW"NaN"\fR, meaning \*(L"Not a Number\*(R".  A rational number is either an
integer, or two integers separated by a solidus (\f(CW"/"\fR).  The second integer
represents the denominator of the division implied by the solidus, and is
actually always positive, so it is guaranteed not to be 0 and to not to be
signed.  When the element is a plain integer (without the
solidus), it may need to be adjusted to get the correct value by adding the
offset, just as other \f(CW"a"\fR properties.  No adjustment is needed for
fractions, as the range is guaranteed to have just a single element, and so
the offset is always 0.
.Sp
If you want to convert the returned map to entirely scalar numbers, you
can use something like this:
.Sp
.Vb 4
\& my ($invlist_ref, $invmap_ref, $format) = prop_invmap($property);
\& if ($format && $format eq "ar") {
\&     map { $_ = eval $_ } @$invmap_ref;
\& }
.Ve
.Sp
Here's some entries from the output of the property \*(L"Nv\*(R", which has format
\&\f(CW"ar"\fR.
.Sp
.Vb 10
\& @numerics_ranges  @numerics_maps       Note
\&        0x00           "NaN"
\&        0x30             0           DIGIT 0 .. DIGIT 9
\&        0x3A           "NaN"
\&        0xB2             2           SUPERSCRIPTs 2 and 3
\&        0xB4           "NaN"
\&        0xB9             1           SUPERSCRIPT 1
\&        0xBA           "NaN"
\&        0xBC            1/4          VULGAR FRACTION 1/4
\&        0xBD            1/2          VULGAR FRACTION 1/2
\&        0xBE            3/4          VULGAR FRACTION 3/4
\&        0xBF           "NaN"
\&        0x660            0           ARABIC\-INDIC DIGIT ZERO .. NINE
\&        0x66A          "NaN"
.Ve
.ie n .IP "\fB\fB""n""\fB\fR" 4
.el .IP "\fB\f(CBn\fB\fR" 4
.IX Item "n"
means the Name property.  All the elements of the map array are simple
scalars, but some of them contain special strings that require more work to
get the actual name.
.Sp
Entries such as:
.Sp
.Vb 1
\& CJK UNIFIED IDEOGRAPH\-<code point>
.Ve
.Sp
mean that the name for the code point is \*(L"\s-1CJK\s0 \s-1UNIFIED\s0 \s-1IDEOGRAPH\-\s0\*(R"
with the code point (expressed in hexadecimal) appended to it, like \*(L"\s-1CJK\s0
\&\s-1UNIFIED\s0 \s-1IDEOGRAPH\-3403\s0\*(R" (similarly for \f(CW\*(C`CJK\ COMPATIBILITY\ IDEOGRAPH\-<code\ point>\*(C'\fR).
.Sp
Also, entries like
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
means that the name is algorithmically calculated.  This is easily done by
the function \*(L"charnames::viacode(code)\*(R" in charnames.
.Sp
Note that for control characters (\f(CW\*(C`Gc=cc\*(C'\fR), Unicode's data files have the
string "\f(CW\*(C`<control>\*(C'\fR", but the real name of each of these characters is the empty
string.  This function returns that real name, the empty string.  (There are
names for these characters, but they are considered aliases, not the Name
property name, and are contained in the \f(CW\*(C`Name_Alias\*(C'\fR property.)
.ie n .IP "\fB\fB""ad""\fB\fR" 4
.el .IP "\fB\f(CBad\fB\fR" 4
.IX Item "ad"
means the Decomposition_Mapping property.  This property is like \f(CW"al"\fR
properties, except that one of the scalar elements is of the form:
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
This signifies that this entry should be replaced by the decompositions for
all the code points whose decomposition is algorithmically calculated.  (All
of them are currently in one range and no others outisde the range are likely
to ever be added to Unicode; the \f(CW"n"\fR format
has this same entry.)  These can be generated via the function
\&\fIUnicode::Normalize::NFD()\fR.
.Sp
Note that the mapping is the one that is specified in the Unicode data files,
and to get the final decomposition, it may need to be applied recursively.
.PP
Note that a format begins with the letter \*(L"a\*(R" if and only the property it is
for requires adjustments by adding the offsets in multi-element ranges.  For
all these properties, an entry should be adjusted only if the map is a scalar
which is an integer.  That is, it must match the regular expression:
.PP
.Vb 1
\&    / ^ \-? \ed+ $ /xa
.Ve
.PP
Further, the first element in a range never needs adjustment, as the
adjustment would be just adding 0.
.PP
A binary search can be used to quickly find a code point in the inversion
list, and hence its corresponding mapping.
.PP
The final element (index [3], assigned to \f(CW$default\fR in the \*(L"block\*(R" example) in
the four element list returned by this function may be useful for applications
that wish to convert the returned inversion map data structure into some
other, such as a hash.  It gives the mapping that most code points map to
under the property.  If you establish the convention that any code point not
explicitly listed in your data structure maps to this value, you can
potentially make your data structure much smaller.  As you construct your data
structure from the one returned by this function, simply ignore those ranges
that map to this value, generally called the \*(L"default\*(R" value.  For example, to
convert to the data structure searchable by \*(L"\fIcharinrange()\fR\*(R", you can follow
this recipe for properties that don't require adjustments:
.PP
.Vb 2
\& my ($list_ref, $map_ref, $format, $missing) = prop_invmap($property);
\& my @range_list;
\&
\& # Look at each element in the list, but the \-2 is needed because we
\& # look at $i+1 in the loop, and the final element is guaranteed to map
\& # to $missing by prop_invmap(), so we would skip it anyway.
\& for my $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&    push @range_list, [ $list_ref\->[$i],
\&                        $list_ref\->[$i+1],
\&                        $map_ref\->[$i]
\&                      ];
\& }
\&
\& print charinrange(\e@range_list, $code_point), "\en";
.Ve
.PP
With this, \f(CW\*(C`charinrange()\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR if its input code point maps
to \f(CW$missing\fR.  You can avoid this by omitting the \f(CW\*(C`next\*(C'\fR statement, and adding
a line after the loop to handle the final element of the inversion map.
.PP
Similarly, this recipe can be used for properties that do require adjustments:
.PP
.Vb 2
\& for my $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&
\&    # prop_invmap() guarantees that if the mapping is to an array, the
\&    # range has just one element, so no need to worry about adjustments.
\&    if (ref $map_ref\->[$i]) {
\&        push @range_list,
\&                   [ $list_ref\->[$i], $list_ref\->[$i], $map_ref\->[$i] ];
\&    }
\&    else {  # Otherwise each element is actually mapped to a separate
\&            # value, so the range has to be split into single code point
\&            # ranges.
\&
\&        my $adjustment = 0;
\&
\&        # For each code point that gets mapped to something...
\&        for my $j ($list_ref\->[$i] .. $list_ref\->[$i+1] \-1 ) {
\&
\&            # ... add a range consisting of just it mapping to the
\&            # original plus the adjustment, which is incremented for the
\&            # next time through the loop, as the offset increases by 1
\&            # for each element in the range
\&            push @range_list,
\&                             [ $j, $j, $map_ref\->[$i] + $adjustment++ ];
\&        }
\&    }
\& }
.Ve
.PP
Note that the inversion maps returned for the \f(CW\*(C`Case_Folding\*(C'\fR and
\&\f(CW\*(C`Simple_Case_Folding\*(C'\fR properties do not include the Turkic-locale mappings.
Use \*(L"\fIcasefold()\fR\*(R" for these.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR does not know about any user-defined properties, and will
return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "Unicode::UCD::UnicodeVersion"
.IX Subsection "Unicode::UCD::UnicodeVersion"
This returns the version of the Unicode Character Database, in other words, the
version of the Unicode standard the database implements.  The version is a
string of numbers delimited by dots (\f(CW\*(Aq.\*(Aq\fR).
.SS "\fBBlocks versus Scripts\fP"
.IX Subsection "Blocks versus Scripts"
The difference between a block and a script is that scripts are closer
to the linguistic notion of a set of code points required to present
languages, while block is more of an artifact of the Unicode code point
numbering and separation into blocks of (mostly) 256 code points.
.PP
For example the Latin \fBscript\fR is spread over several \fBblocks\fR, such
as \f(CW\*(C`Basic Latin\*(C'\fR, \f(CW\*(C`Latin 1 Supplement\*(C'\fR, \f(CW\*(C`Latin Extended\-A\*(C'\fR, and
\&\f(CW\*(C`Latin Extended\-B\*(C'\fR.  On the other hand, the Latin script does not
contain all the characters of the \f(CW\*(C`Basic Latin\*(C'\fR block (also known as
\&\s-1ASCII\s0): it includes only the letters, and not, for example, the digits
or the punctuation.
.PP
For blocks see <http://www.unicode.org/Public/UNIDATA/Blocks.txt>
.PP
For scripts see \s-1UTR\s0 #24: <http://www.unicode.org/unicode/reports/tr24/>
.SS "\fBMatching Scripts and Blocks\fP"
.IX Subsection "Matching Scripts and Blocks"
Scripts are matched with the regular-expression construct
\&\f(CW\*(C`\ep{...}\*(C'\fR (e.g. \f(CW\*(C`\ep{Tibetan}\*(C'\fR matches characters of the Tibetan script),
while \f(CW\*(C`\ep{Blk=...}\*(C'\fR is used for blocks (e.g. \f(CW\*(C`\ep{Blk=Tibetan}\*(C'\fR matches
any of the 256 code points in the Tibetan block).
.SS "Old-style versus new-style block names"
.IX Subsection "Old-style versus new-style block names"
Unicode publishes the names of blocks in two different styles, though the two
are equivalent under Unicode's loose matching rules.
.PP
The original style uses blanks and hyphens in the block names (except for
\&\f(CW\*(C`No_Block\*(C'\fR), like so:
.PP
.Vb 1
\& Miscellaneous Mathematical Symbols\-B
.Ve
.PP
The newer style replaces these with underscores, like this:
.PP
.Vb 1
\& Miscellaneous_Mathematical_Symbols_B
.Ve
.PP
This newer style is consistent with the values of other Unicode properties.
To preserve backward compatibility, all the functions in Unicode::UCD that
return block names (except one) return the old-style ones.  That one function,
\&\*(L"\fIprop_value_aliases()\fR\*(R" can be used to convert from old-style to new-style:
.PP
.Vb 1
\& my $new_style = prop_values_aliases("block", $old_style);
.Ve
.PP
Perl also has single-form extensions that refer to blocks, \f(CW\*(C`In_Cyrillic\*(C'\fR,
meaning \f(CW\*(C`Block=Cyrillic\*(C'\fR.  These have always been written in the new style.
.PP
To convert from new-style to old-style, follow this recipe:
.PP
.Vb 1
\& $old_style = charblock((prop_invlist("block=$new_style"))[0]);
.Ve
.PP
(which finds the range of code points in the block using \f(CW\*(C`prop_invlist\*(C'\fR,
gets the lower end of the range (0th element) and then looks up the old name
for its block using \f(CW\*(C`charblock\*(C'\fR).
.PP
Note that starting in Unicode 6.1, many of the block names have shorter
synonyms.  These are always given in the new style.
.SH "BUGS"
.IX Header "BUGS"
Does not yet support \s-1EBCDIC\s0 platforms.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi.  Now maintained by perl5 porters.
                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Unicode::UCD5.18.3pm                         0100644 0001750 0001750 00000217340 12566207464 023736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Unicode::UCD 3pm"
.TH Unicode::UCD 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unicode::UCD \- Unicode character database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Unicode::UCD \*(Aqcharinfo\*(Aq;
\&    my $charinfo   = charinfo($codepoint);
\&
\&    use Unicode::UCD \*(Aqcasefold\*(Aq;
\&    my $casefold = casefold(0xFB00);
\&
\&    use Unicode::UCD \*(Aqall_casefolds\*(Aq;
\&    my $all_casefolds_ref = all_casefolds();
\&
\&    use Unicode::UCD \*(Aqcasespec\*(Aq;
\&    my $casespec = casespec(0xFB00);
\&
\&    use Unicode::UCD \*(Aqcharblock\*(Aq;
\&    my $charblock  = charblock($codepoint);
\&
\&    use Unicode::UCD \*(Aqcharscript\*(Aq;
\&    my $charscript = charscript($codepoint);
\&
\&    use Unicode::UCD \*(Aqcharblocks\*(Aq;
\&    my $charblocks = charblocks();
\&
\&    use Unicode::UCD \*(Aqcharscripts\*(Aq;
\&    my $charscripts = charscripts();
\&
\&    use Unicode::UCD qw(charscript charinrange);
\&    my $range = charscript($script);
\&    print "looks like $script\en" if charinrange($range, $codepoint);
\&
\&    use Unicode::UCD qw(general_categories bidi_types);
\&    my $categories = general_categories();
\&    my $types = bidi_types();
\&
\&    use Unicode::UCD \*(Aqprop_aliases\*(Aq;
\&    my @space_names = prop_aliases("space");
\&
\&    use Unicode::UCD \*(Aqprop_value_aliases\*(Aq;
\&    my @gc_punct_names = prop_value_aliases("Gc", "Punct");
\&
\&    use Unicode::UCD \*(Aqprop_invlist\*(Aq;
\&    my @puncts = prop_invlist("gc=punctuation");
\&
\&    use Unicode::UCD \*(Aqprop_invmap\*(Aq;
\&    my ($list_ref, $map_ref, $format, $missing)
\&                                      = prop_invmap("General Category");
\&
\&    use Unicode::UCD \*(Aqcompexcl\*(Aq;
\&    my $compexcl = compexcl($codepoint);
\&
\&    use Unicode::UCD \*(Aqnamedseq\*(Aq;
\&    my $namedseq = namedseq($named_sequence_name);
\&
\&    my $unicode_version = Unicode::UCD::UnicodeVersion();
\&
\&    my $convert_to_numeric =
\&              Unicode::UCD::num("\eN{RUMI DIGIT ONE}\eN{RUMI DIGIT TWO}");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Unicode::UCD module offers a series of functions that
provide a simple interface to the Unicode
Character Database.
.SS "code point argument"
.IX Subsection "code point argument"
Some of the functions are called with a \fIcode point argument\fR, which is either
a decimal or a hexadecimal scalar designating a Unicode code point, or \f(CW\*(C`U+\*(C'\fR
followed by hexadecimals designating a Unicode code point.  In other words, if
you want a code point to be interpreted as a hexadecimal number, you must
prefix it with either \f(CW\*(C`0x\*(C'\fR or \f(CW\*(C`U+\*(C'\fR, because a string like e.g. \f(CW123\fR will be
interpreted as a decimal code point.
.PP
Examples:
.PP
.Vb 4
\&    223     # Decimal 223
\&    0223    # Hexadecimal 223 (= 547 decimal)
\&    0xDF    # Hexadecimal DF (= 223 decimal
\&    U+DF    # Hexadecimal DF
.Ve
.PP
Note that the largest code point in Unicode is U+10FFFF.
.SS "\fB\fP\f(BIcharinfo()\fP\fB\fP"
.IX Subsection "charinfo()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharinfo\*(Aq;
\&
\&    my $charinfo = charinfo(0x41);
.Ve
.PP
This returns information about the input \*(L"code point argument\*(R"
as a reference to a hash of fields as defined by the Unicode
standard.  If the \*(L"code point argument\*(R" is not assigned in the standard
(i.e., has the general category \f(CW\*(C`Cn\*(C'\fR meaning \f(CW\*(C`Unassigned\*(C'\fR)
or is a non-character (meaning it is guaranteed to never be assigned in
the standard),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.PP
Fields that aren't applicable to the particular code point argument exist in the
returned hash, and are empty.
.PP
The keys in the hash with the meanings of their values are:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four hexdigits
.IP "\fBname\fR" 4
.IX Item "name"
name of \fIcode\fR, all \s-1IN UPPER CASE.\s0
Some control-type code points do not have names.
This field will be empty for \f(CW\*(C`Surrogate\*(C'\fR and \f(CW\*(C`Private Use\*(C'\fR code points,
and for the others without a name,
it will contain a description enclosed in angle brackets, like
\&\f(CW\*(C`<control>\*(C'\fR.
.IP "\fBcategory\fR" 4
.IX Item "category"
The short name of the general category of \fIcode\fR.
This will match one of the keys in the hash returned by \*(L"\fIgeneral_categories()\fR\*(R".
.Sp
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms
of the category name.
.IP "\fBcombining\fR" 4
.IX Item "combining"
the combining class number for \fIcode\fR used in the Canonical Ordering Algorithm.
For Unicode 5.1, this is described in Section 3.11 \f(CW\*(C`Canonical Ordering Behavior\*(C'\fR
available at
<http://www.unicode.org/versions/Unicode5.1.0/>
.Sp
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms
of the combining class number.
.IP "\fBbidi\fR" 4
.IX Item "bidi"
bidirectional type of \fIcode\fR.
This will match one of the keys in the hash returned by \*(L"\fIbidi_types()\fR\*(R".
.Sp
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms
of the bidi type name.
.IP "\fBdecomposition\fR" 4
.IX Item "decomposition"
is empty if \fIcode\fR has no decomposition; or is one or more codes
(separated by spaces) that, taken in order, represent a decomposition for
\&\fIcode\fR.  Each has at least four hexdigits.
The codes may be preceded by a word enclosed in angle brackets then a space,
like \f(CW\*(C`<compat> \*(C'\fR, giving the type of decomposition
.Sp
This decomposition may be an intermediate one whose components are also
decomposable.  Use Unicode::Normalize to get the final decomposition.
.IP "\fBdecimal\fR" 4
.IX Item "decimal"
if \fIcode\fR is a decimal digit this is its integer numeric value
.IP "\fBdigit\fR" 4
.IX Item "digit"
if \fIcode\fR represents some other digit-like number, this is its integer
numeric value
.IP "\fBnumeric\fR" 4
.IX Item "numeric"
if \fIcode\fR represents a whole or rational number, this is its numeric value.
Rational values are expressed as a string like \f(CW\*(C`1/4\*(C'\fR.
.IP "\fBmirrored\fR" 4
.IX Item "mirrored"
\&\f(CW\*(C`Y\*(C'\fR or \f(CW\*(C`N\*(C'\fR designating if \fIcode\fR is mirrored in bidirectional text
.IP "\fBunicode10\fR" 4
.IX Item "unicode10"
name of \fIcode\fR in the Unicode 1.0 standard if one
existed for this code point and is different from the current name
.IP "\fBcomment\fR" 4
.IX Item "comment"
As of Unicode 6.0, this is always empty.
.IP "\fBupper\fR" 4
.IX Item "upper"
is empty if there is no single code point uppercase mapping for \fIcode\fR
(its uppercase mapping is itself);
otherwise it is that mapping expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used in addition to \fB\f(BIcharinfo()\fB\fR
for case mappings when the calling program can cope with multiple code point
mappings.)
.IP "\fBlower\fR" 4
.IX Item "lower"
is empty if there is no single code point lowercase mapping for \fIcode\fR
(its lowercase mapping is itself);
otherwise it is that mapping expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used in addition to \fB\f(BIcharinfo()\fB\fR
for case mappings when the calling program can cope with multiple code point
mappings.)
.IP "\fBtitle\fR" 4
.IX Item "title"
is empty if there is no single code point titlecase mapping for \fIcode\fR
(its titlecase mapping is itself);
otherwise it is that mapping expressed as at least four hexdigits.
(\*(L"\fIcasespec()\fR\*(R" should be used in addition to \fB\f(BIcharinfo()\fB\fR
for case mappings when the calling program can cope with multiple code point
mappings.)
.IP "\fBblock\fR" 4
.IX Item "block"
the block \fIcode\fR belongs to (used in \f(CW\*(C`\ep{Blk=...}\*(C'\fR).
See \*(L"Blocks versus Scripts\*(R".
.IP "\fBscript\fR" 4
.IX Item "script"
the script \fIcode\fR belongs to.
See \*(L"Blocks versus Scripts\*(R".
.PP
Note that you cannot do (de)composition and casing based solely on the
\&\fIdecomposition\fR, \fIcombining\fR, \fIlower\fR, \fIupper\fR, and \fItitle\fR fields;
you will need also the \*(L"\fIcompexcl()\fR\*(R", and \*(L"\fIcasespec()\fR\*(R" functions.
.SS "\fB\fP\f(BIcharblock()\fP\fB\fP"
.IX Subsection "charblock()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharblock\*(Aq;
\&
\&    my $charblock = charblock(0x41);
\&    my $charblock = charblock(1234);
\&    my $charblock = charblock(0x263a);
\&    my $charblock = charblock("U+263a");
\&
\&    my $range     = charblock(\*(AqArmenian\*(Aq);
.Ve
.PP
With a \*(L"code point argument\*(R" \fIcharblock()\fR returns the \fIblock\fR the code point
belongs to, e.g.  \f(CW\*(C`Basic Latin\*(C'\fR.  The old-style block name is returned (see
\&\*(L"Old-style versus new-style block names\*(R").
If the code point is unassigned, this returns the block it would belong to if
it were assigned.  (If the Unicode version being used is so early as to not
have blocks, all code points are considered to be in \f(CW\*(C`No_Block\*(C'\fR.)
.PP
See also \*(L"Blocks versus Scripts\*(R".
.PP
If supplied with an argument that can't be a code point, \fIcharblock()\fR tries to
do the opposite and interpret the argument as an old-style block name. The
return value
is a \fIrange set\fR with one range: an anonymous list with a single element that
consists of another anonymous list whose first element is the first code point
in the block, and whose second (and final) element is the final code point in
the block.  (The extra list consisting of just one element is so that the same
program logic can be used to handle both this return, and the return from
\&\*(L"\fIcharscript()\fR\*(R" which can have multiple ranges.) You can test whether a code
point is in a range using the \*(L"\fIcharinrange()\fR\*(R" function.  If the argument is
not a known block, \f(CW\*(C`undef\*(C'\fR is returned.
.SS "\fB\fP\f(BIcharscript()\fP\fB\fP"
.IX Subsection "charscript()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharscript\*(Aq;
\&
\&    my $charscript = charscript(0x41);
\&    my $charscript = charscript(1234);
\&    my $charscript = charscript("U+263a");
\&
\&    my $range      = charscript(\*(AqThai\*(Aq);
.Ve
.PP
With a \*(L"code point argument\*(R" \fIcharscript()\fR returns the \fIscript\fR the
code point belongs to, e.g.  \f(CW\*(C`Latin\*(C'\fR, \f(CW\*(C`Greek\*(C'\fR, \f(CW\*(C`Han\*(C'\fR.
If the code point is unassigned or the Unicode version being used is so early
that it doesn't have scripts, this function returns \f(CW"Unknown"\fR.
.PP
If supplied with an argument that can't be a code point, \fIcharscript()\fR tries
to do the opposite and interpret the argument as a script name. The
return value is a \fIrange set\fR: an anonymous list of lists that contain
\&\fIstart-of-range\fR, \fIend-of-range\fR code point pairs. You can test whether a
code point is in a range set using the \*(L"\fIcharinrange()\fR\*(R" function. If the
argument is not a known script, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharblocks()\fP\fB\fP"
.IX Subsection "charblocks()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharblocks\*(Aq;
\&
\&    my $charblocks = charblocks();
.Ve
.PP
\&\fIcharblocks()\fR returns a reference to a hash with the known block names
as the keys, and the code point ranges (see \*(L"\fIcharblock()\fR\*(R") as the values.
.PP
The names are in the old-style (see \*(L"Old-style versus new-style block
names\*(R").
.PP
prop_invmap(\*(L"block\*(R") can be used to get this same data in a
different type of data structure.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharscripts()\fP\fB\fP"
.IX Subsection "charscripts()"
.Vb 1
\&    use Unicode::UCD \*(Aqcharscripts\*(Aq;
\&
\&    my $charscripts = charscripts();
.Ve
.PP
\&\fIcharscripts()\fR returns a reference to a hash with the known script
names as the keys, and the code point ranges (see \*(L"\fIcharscript()\fR\*(R") as
the values.
.PP
prop_invmap(\*(L"script\*(R") can be used to get this same data in a
different type of data structure.
.PP
See also \*(L"Blocks versus Scripts\*(R".
.SS "\fB\fP\f(BIcharinrange()\fP\fB\fP"
.IX Subsection "charinrange()"
In addition to using the \f(CW\*(C`\ep{Blk=...}\*(C'\fR and \f(CW\*(C`\eP{Blk=...}\*(C'\fR constructs, you
can also test whether a code point is in the \fIrange\fR as returned by
\&\*(L"\fIcharblock()\fR\*(R" and \*(L"\fIcharscript()\fR\*(R" or as the values of the hash returned
by \*(L"\fIcharblocks()\fR\*(R" and \*(L"\fIcharscripts()\fR\*(R" by using \fIcharinrange()\fR:
.PP
.Vb 1
\&    use Unicode::UCD qw(charscript charinrange);
\&
\&    $range = charscript(\*(AqHiragana\*(Aq);
\&    print "looks like hiragana\en" if charinrange($range, $codepoint);
.Ve
.SS "\fB\fP\f(BIgeneral_categories()\fP\fB\fP"
.IX Subsection "general_categories()"
.Vb 1
\&    use Unicode::UCD \*(Aqgeneral_categories\*(Aq;
\&
\&    my $categories = general_categories();
.Ve
.PP
This returns a reference to a hash which has short
general category names (such as \f(CW\*(C`Lu\*(C'\fR, \f(CW\*(C`Nd\*(C'\fR, \f(CW\*(C`Zs\*(C'\fR, \f(CW\*(C`S\*(C'\fR) as keys and long
names (such as \f(CW\*(C`UppercaseLetter\*(C'\fR, \f(CW\*(C`DecimalNumber\*(C'\fR, \f(CW\*(C`SpaceSeparator\*(C'\fR,
\&\f(CW\*(C`Symbol\*(C'\fR) as values.  The hash is reversible in case you need to go
from the long names to the short names.  The general category is the
one returned from
\&\*(L"\fIcharinfo()\fR\*(R" under the \f(CW\*(C`category\*(C'\fR key.
.PP
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms of
the category name.
.SS "\fB\fP\f(BIbidi_types()\fP\fB\fP"
.IX Subsection "bidi_types()"
.Vb 1
\&    use Unicode::UCD \*(Aqbidi_types\*(Aq;
\&
\&    my $categories = bidi_types();
.Ve
.PP
This returns a reference to a hash which has the short
bidi (bidirectional) type names (such as \f(CW\*(C`L\*(C'\fR, \f(CW\*(C`R\*(C'\fR) as keys and long
names (such as \f(CW\*(C`Left\-to\-Right\*(C'\fR, \f(CW\*(C`Right\-to\-Left\*(C'\fR) as values.  The
hash is reversible in case you need to go from the long names to the
short names.  The bidi type is the one returned from
\&\*(L"\fIcharinfo()\fR\*(R"
under the \f(CW\*(C`bidi\*(C'\fR key.  For the exact meaning of the various bidi classes
the Unicode \s-1TR9\s0 is recommended reading:
<http://www.unicode.org/reports/tr9/>
(as of Unicode 5.0.0)
.PP
The \*(L"\fIprop_value_aliases()\fR\*(R" function can be used to get all the synonyms of
the bidi type name.
.SS "\fB\fP\f(BIcompexcl()\fP\fB\fP"
.IX Subsection "compexcl()"
.Vb 1
\&    use Unicode::UCD \*(Aqcompexcl\*(Aq;
\&
\&    my $compexcl = compexcl(0x09dc);
.Ve
.PP
This routine returns \f(CW\*(C`undef\*(C'\fR if the Unicode version being used is so early
that it doesn't have this property.  It is included for backwards
compatibility, but as of Perl 5.12 and more modern Unicode versions, for
most purposes it is probably more convenient to use one of the following
instead:
.PP
.Vb 2
\&    my $compexcl = chr(0x09dc) =~ /\ep{Comp_Ex};
\&    my $compexcl = chr(0x09dc) =~ /\ep{Full_Composition_Exclusion};
.Ve
.PP
or even
.PP
.Vb 2
\&    my $compexcl = chr(0x09dc) =~ /\ep{CE};
\&    my $compexcl = chr(0x09dc) =~ /\ep{Composition_Exclusion};
.Ve
.PP
The first two forms return \fBtrue\fR if the \*(L"code point argument\*(R" should not
be produced by composition normalization.  For the final two forms to return
\&\fBtrue\fR, it is additionally required that this fact not otherwise be
determinable from the Unicode data base.
.PP
This routine behaves identically to the final two forms.  That is,
it does not return \fBtrue\fR if the code point has a decomposition
consisting of another single code point, nor if its decomposition starts
with a code point whose combining class is non-zero.  Code points that meet
either of these conditions should also not be produced by composition
normalization, which is probably why you should use the
\&\f(CW\*(C`Full_Composition_Exclusion\*(C'\fR property instead, as shown above.
.PP
The routine returns \fBfalse\fR otherwise.
.SS "\fB\fP\f(BIcasefold()\fP\fB\fP"
.IX Subsection "casefold()"
.Vb 1
\&    use Unicode::UCD \*(Aqcasefold\*(Aq;
\&
\&    my $casefold = casefold(0xDF);
\&    if (defined $casefold) {
\&        my @full_fold_hex = split / /, $casefold\->{\*(Aqfull\*(Aq};
\&        my $full_fold_string =
\&                    join "", map {chr(hex($_))} @full_fold_hex;
\&        my @turkic_fold_hex =
\&                        split / /, ($casefold\->{\*(Aqturkic\*(Aq} ne "")
\&                                        ? $casefold\->{\*(Aqturkic\*(Aq}
\&                                        : $casefold\->{\*(Aqfull\*(Aq};
\&        my $turkic_fold_string =
\&                        join "", map {chr(hex($_))} @turkic_fold_hex;
\&    }
\&    if (defined $casefold && $casefold\->{\*(Aqsimple\*(Aq} ne "") {
\&        my $simple_fold_hex = $casefold\->{\*(Aqsimple\*(Aq};
\&        my $simple_fold_string = chr(hex($simple_fold_hex));
\&    }
.Ve
.PP
This returns the (almost) locale-independent case folding of the
character specified by the \*(L"code point argument\*(R".  (Starting in Perl v5.16,
the core function \f(CW\*(C`fc()\*(C'\fR returns the \f(CW\*(C`full\*(C'\fR mapping (described below)
faster than this does, and for entire strings.)
.PP
If there is no case folding for the input code point, \f(CW\*(C`undef\*(C'\fR is returned.
.PP
If there is a case folding for that code point, a reference to a hash
with the following fields is returned:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four hexdigits
.IP "\fBfull\fR" 4
.IX Item "full"
one or more codes (separated by spaces) that, taken in order, give the
code points for the case folding for \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBsimple\fR" 4
.IX Item "simple"
is empty, or is exactly one code with at least four hexdigits which can be used
as an alternative case folding when the calling program cannot cope with the
fold being a sequence of multiple code points.  If \fIfull\fR is just one code
point, then \fIsimple\fR equals \fIfull\fR.  If there is no single code point folding
defined for \fIcode\fR, then \fIsimple\fR is the empty string.  Otherwise, it is an
inferior, but still better-than-nothing alternative folding to \fIfull\fR.
.IP "\fBmapping\fR" 4
.IX Item "mapping"
is the same as \fIsimple\fR if \fIsimple\fR is not empty, and it is the same as \fIfull\fR
otherwise.  It can be considered to be the simplest possible folding for
\&\fIcode\fR.  It is defined primarily for backwards compatibility.
.IP "\fBstatus\fR" 4
.IX Item "status"
is \f(CW\*(C`C\*(C'\fR (for \f(CW\*(C`common\*(C'\fR) if the best possible fold is a single code point
(\fIsimple\fR equals \fIfull\fR equals \fImapping\fR).  It is \f(CW\*(C`S\*(C'\fR if there are distinct
folds, \fIsimple\fR and \fIfull\fR (\fImapping\fR equals \fIsimple\fR).  And it is \f(CW\*(C`F\*(C'\fR if
there is only a \fIfull\fR fold (\fImapping\fR equals \fIfull\fR; \fIsimple\fR is empty).
Note that this
describes the contents of \fImapping\fR.  It is defined primarily for backwards
compatibility.
.Sp
For Unicode versions between 3.1 and 3.1.1 inclusive, \fIstatus\fR can also be
\&\f(CW\*(C`I\*(C'\fR which is the same as \f(CW\*(C`C\*(C'\fR but is a special case for dotted uppercase I and
dotless lowercase i:
.RS 4
.ie n .IP "\fB*\fR If you use this ""I"" mapping" 4
.el .IP "\fB*\fR If you use this \f(CWI\fR mapping" 4
.IX Item "* If you use this I mapping"
the result is case-insensitive,
but dotless and dotted I's are not distinguished
.ie n .IP "\fB*\fR If you exclude this ""I"" mapping" 4
.el .IP "\fB*\fR If you exclude this \f(CWI\fR mapping" 4
.IX Item "* If you exclude this I mapping"
the result is not fully case-insensitive, but
dotless and dotted I's are distinguished
.RE
.RS 4
.RE
.IP "\fBturkic\fR" 4
.IX Item "turkic"
contains any special folding for Turkic languages.  For versions of Unicode
starting with 3.2, this field is empty unless \fIcode\fR has a different folding
in Turkic languages, in which case it is one or more codes (separated by
spaces) that, taken in order, give the code points for the case folding for
\&\fIcode\fR in those languages.
Each code has at least four hexdigits.
Note that this folding does not maintain canonical equivalence without
additional processing.
.Sp
For Unicode versions between 3.1 and 3.1.1 inclusive, this field is empty unless
there is a
special folding for Turkic languages, in which case \fIstatus\fR is \f(CW\*(C`I\*(C'\fR, and
\&\fImapping\fR, \fIfull\fR, \fIsimple\fR, and \fIturkic\fR are all equal.
.PP
Programs that want complete generality and the best folding results should use
the folding contained in the \fIfull\fR field.  But note that the fold for some
code points will be a sequence of multiple code points.
.PP
Programs that can't cope with the fold mapping being multiple code points can
use the folding contained in the \fIsimple\fR field, with the loss of some
generality.  In Unicode 5.1, about 7% of the defined foldings have no single
code point folding.
.PP
The \fImapping\fR and \fIstatus\fR fields are provided for backwards compatibility for
existing programs.  They contain the same values as in previous versions of
this function.
.PP
Locale is not completely independent.  The \fIturkic\fR field contains results to
use when the locale is a Turkic language.
.PP
For more information about case mappings see
<http://www.unicode.org/unicode/reports/tr21>
.SS "\fB\fP\f(BIall_casefolds()\fP\fB\fP"
.IX Subsection "all_casefolds()"
.Vb 1
\&    use Unicode::UCD \*(Aqall_casefolds\*(Aq;
\&
\&    my $all_folds_ref = all_casefolds();
\&    foreach my $char_with_casefold (sort { $a <=> $b }
\&                                    keys %$all_folds_ref)
\&    {
\&        printf "%04X:", $char_with_casefold;
\&        my $casefold = $all_folds_ref\->{$char_with_casefold};
\&
\&        # Get folds for $char_with_casefold
\&
\&        my @full_fold_hex = split / /, $casefold\->{\*(Aqfull\*(Aq};
\&        my $full_fold_string =
\&                    join "", map {chr(hex($_))} @full_fold_hex;
\&        print " full=", join " ", @full_fold_hex;
\&        my @turkic_fold_hex =
\&                        split / /, ($casefold\->{\*(Aqturkic\*(Aq} ne "")
\&                                        ? $casefold\->{\*(Aqturkic\*(Aq}
\&                                        : $casefold\->{\*(Aqfull\*(Aq};
\&        my $turkic_fold_string =
\&                        join "", map {chr(hex($_))} @turkic_fold_hex;
\&        print "; turkic=", join " ", @turkic_fold_hex;
\&        if (defined $casefold && $casefold\->{\*(Aqsimple\*(Aq} ne "") {
\&            my $simple_fold_hex = $casefold\->{\*(Aqsimple\*(Aq};
\&            my $simple_fold_string = chr(hex($simple_fold_hex));
\&            print "; simple=$simple_fold_hex";
\&        }
\&        print "\en";
\&    }
.Ve
.PP
This returns all the case foldings in the current version of Unicode in the
form of a reference to a hash.  Each key to the hash is the decimal
representation of a Unicode character that has a casefold to other than
itself.  The casefold of a semi-colon is itself, so it isn't in the hash;
likewise for a lowercase \*(L"a\*(R", but there is an entry for a capital \*(L"A\*(R".  The
hash value for each key is another hash, identical to what is returned by
\&\*(L"\fIcasefold()\fR\*(R" if called with that code point as its argument.  So the value
\&\f(CW\*(C`all_casefolds()\->{ord("A")}\*(Aq\*(C'\fR is equivalent to \f(CW\*(C`casefold(ord("A"))\*(C'\fR;
.SS "\fB\fP\f(BIcasespec()\fP\fB\fP"
.IX Subsection "casespec()"
.Vb 1
\&    use Unicode::UCD \*(Aqcasespec\*(Aq;
\&
\&    my $casespec = casespec(0xFB00);
.Ve
.PP
This returns the potentially locale-dependent case mappings of the \*(L"code point
argument\*(R".  The mappings may be longer than a single code point (which the basic
Unicode case mappings as returned by \*(L"\fIcharinfo()\fR\*(R" never are).
.PP
If there are no case mappings for the \*(L"code point argument\*(R", or if all three
possible mappings (\fIlower\fR, \fItitle\fR and \fIupper\fR) result in single code
points and are locale independent and unconditional, \f(CW\*(C`undef\*(C'\fR is returned
(which means that the case mappings, if any, for the code point are those
returned by \*(L"\fIcharinfo()\fR\*(R").
.PP
Otherwise, a reference to a hash giving the mappings (or a reference to a hash
of such hashes, explained below) is returned with the following keys and their
meanings:
.PP
The keys in the bottom layer hash with the meanings of their values are:
.IP "\fBcode\fR" 4
.IX Item "code"
the input \*(L"code point argument\*(R" expressed in hexadecimal, with leading zeros
added if necessary to make it contain at least four hexdigits
.IP "\fBlower\fR" 4
.IX Item "lower"
one or more codes (separated by spaces) that, taken in order, give the
code points for the lower case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBtitle\fR" 4
.IX Item "title"
one or more codes (separated by spaces) that, taken in order, give the
code points for the title case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBupper\fR" 4
.IX Item "upper"
one or more codes (separated by spaces) that, taken in order, give the
code points for the upper case of \fIcode\fR.
Each has at least four hexdigits.
.IP "\fBcondition\fR" 4
.IX Item "condition"
the conditions for the mappings to be valid.
If \f(CW\*(C`undef\*(C'\fR, the mappings are always valid.
When defined, this field is a list of conditions,
all of which must be true for the mappings to be valid.
The list consists of one or more
\&\fIlocales\fR (see below)
and/or \fIcontexts\fR (explained in the next paragraph),
separated by spaces.
(Other than as used to separate elements, spaces are to be ignored.)
Case distinctions in the condition list are not significant.
Conditions preceded by \*(L"\s-1NON_\*(R"\s0 represent the negation of the condition.
.Sp
A \fIcontext\fR is one of those defined in the Unicode standard.
For Unicode 5.1, they are defined in Section 3.13 \f(CW\*(C`Default Case Operations\*(C'\fR
available at
<http://www.unicode.org/versions/Unicode5.1.0/>.
These are for context-sensitive casing.
.PP
The hash described above is returned for locale-independent casing, where
at least one of the mappings has length longer than one.  If \f(CW\*(C`undef\*(C'\fR is
returned, the code point may have mappings, but if so, all are length one,
and are returned by \*(L"\fIcharinfo()\fR\*(R".
Note that when this function does return a value, it will be for the complete
set of mappings for a code point, even those whose length is one.
.PP
If there are additional casing rules that apply only in certain locales,
an additional key for each will be defined in the returned hash.  Each such key
will be its locale name, defined as a 2\-letter \s-1ISO 3166\s0 country code, possibly
followed by a \*(L"_\*(R" and a 2\-letter \s-1ISO\s0 language code (possibly followed by a \*(L"_\*(R"
and a variant code).  You can find the lists of all possible locales, see
Locale::Country and Locale::Language.
(In Unicode 6.0, the only locales returned by this function
are \f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, and \f(CW\*(C`az\*(C'\fR.)
.PP
Each locale key is a reference to a hash that has the form above, and gives
the casing rules for that particular locale, which take precedence over the
locale-independent ones when in that locale.
.PP
If the only casing for a code point is locale-dependent, then the returned
hash will not have any of the base keys, like \f(CW\*(C`code\*(C'\fR, \f(CW\*(C`upper\*(C'\fR, etc., but
will contain only locale keys.
.PP
For more information about case mappings see
<http://www.unicode.org/unicode/reports/tr21/>
.SS "\fB\fP\f(BInamedseq()\fP\fB\fP"
.IX Subsection "namedseq()"
.Vb 1
\&    use Unicode::UCD \*(Aqnamedseq\*(Aq;
\&
\&    my $namedseq = namedseq("KATAKANA LETTER AINU P");
\&    my @namedseq = namedseq("KATAKANA LETTER AINU P");
\&    my %namedseq = namedseq();
.Ve
.PP
If used with a single argument in a scalar context, returns the string
consisting of the code points of the named sequence, or \f(CW\*(C`undef\*(C'\fR if no
named sequence by that name exists.  If used with a single argument in
a list context, it returns the list of the ordinals of the code points.  If used
with no
arguments in a list context, returns a hash with the names of the
named sequences as the keys and the named sequences as strings as
the values.  Otherwise, it returns \f(CW\*(C`undef\*(C'\fR or an empty list depending
on the context.
.PP
This function only operates on officially approved (not provisional) named
sequences.
.PP
Note that as of Perl 5.14, \f(CW\*(C`\eN{KATAKANA LETTER AINU P}\*(C'\fR will insert the named
sequence into double-quoted strings, and \f(CW\*(C`charnames::string_vianame("KATAKANA
LETTER AINU P")\*(C'\fR will return the same string this function does, but will also
operate on character names that aren't named sequences, without you having to
know which are which.  See charnames.
.SS "\fB\fP\f(BInum()\fP\fB\fP"
.IX Subsection "num()"
.Vb 1
\&    use Unicode::UCD \*(Aqnum\*(Aq;
\&
\&    my $val = num("123");
\&    my $one_quarter = num("\eN{VULGAR FRACTION 1/4}");
.Ve
.PP
\&\f(CW\*(C`num\*(C'\fR returns the numeric value of the input Unicode string; or \f(CW\*(C`undef\*(C'\fR if it
doesn't think the entire string has a completely valid, safe numeric value.
.PP
If the string is just one character in length, the Unicode numeric value
is returned if it has one, or \f(CW\*(C`undef\*(C'\fR otherwise.  Note that this need
not be a whole number.  \f(CW\*(C`num("\eN{TIBETAN DIGIT HALF ZERO}")\*(C'\fR, for
example returns \-0.5.
.PP
If the string is more than one character, \f(CW\*(C`undef\*(C'\fR is returned unless
all its characters are decimal digits (that is, they would match \f(CW\*(C`\ed+\*(C'\fR),
from the same script.  For example if you have an \s-1ASCII \s0'0' and a Bengali
\&'3', mixed together, they aren't considered a valid number, and \f(CW\*(C`undef\*(C'\fR
is returned.  A further restriction is that the digits all have to be of
the same form.  A half-width digit mixed with a full-width one will
return \f(CW\*(C`undef\*(C'\fR.  The Arabic script has two sets of digits;  \f(CW\*(C`num\*(C'\fR will
return \f(CW\*(C`undef\*(C'\fR unless all the digits in the string come from the same
set.
.PP
\&\f(CW\*(C`num\*(C'\fR errs on the side of safety, and there may be valid strings of
decimal digits that it doesn't recognize.  Note that Unicode defines
a number of \*(L"digit\*(R" characters that aren't \*(L"decimal digit\*(R" characters.
\&\*(L"Decimal digits\*(R" have the property that they have a positional value, i.e.,
there is a units position, a 10's position, a 100's, etc, \s-1AND\s0 they are
arranged in Unicode in blocks of 10 contiguous code points.  The Chinese
digits, for example, are not in such a contiguous block, and so Unicode
doesn't view them as decimal digits, but merely digits, and so \f(CW\*(C`\ed\*(C'\fR will not
match them.  A single-character string containing one of these digits will
have its decimal value returned by \f(CW\*(C`num\*(C'\fR, but any longer string containing
only these digits will return \f(CW\*(C`undef\*(C'\fR.
.PP
Strings of multiple sub\- and superscripts are not recognized as numbers.  You
can use either of the compatibility decompositions in Unicode::Normalize to
change these into digits, and then call \f(CW\*(C`num\*(C'\fR on the result.
.SS "\fB\fP\f(BIprop_aliases()\fP\fB\fP"
.IX Subsection "prop_aliases()"
.Vb 1
\&    use Unicode::UCD \*(Aqprop_aliases\*(Aq;
\&
\&    my ($short_name, $full_name, @other_names) = prop_aliases("space");
\&    my $same_full_name = prop_aliases("Space");     # Scalar context
\&    my ($same_short_name) = prop_aliases("Space");  # gets 0th element
\&    print "The full name is $full_name\en";
\&    print "The short name is $short_name\en";
\&    print "The other aliases are: ", join(", ", @other_names), "\en";
\&
\&    prints:
\&    The full name is White_Space
\&    The short name is WSpace
\&    The other aliases are: Space
.Ve
.PP
Most Unicode properties have several synonymous names.  Typically, there is at
least a short name, convenient to type, and a long name that more fully
describes the property, and hence is more easily understood.
.PP
If you know one name for a Unicode property, you can use \f(CW\*(C`prop_aliases\*(C'\fR to find
either the long name (when called in scalar context), or a list of all of the
names, somewhat ordered so that the short name is in the 0th element, the long
name in the next element, and any other synonyms are in the remaining
elements, in no particular order.
.PP
The long name is returned in a form nicely capitalized, suitable for printing.
.PP
The input parameter name is loosely matched, which means that white space,
hyphens, and underscores are ignored (except for the trailing underscore in
the old_form grandfathered-in \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR, and
both of which mean \f(CW\*(C`General_Category=Cased Letter\*(C'\fR).
.PP
If the name is unknown, \f(CW\*(C`undef\*(C'\fR is returned (or an empty list in list
context).  Note that Perl typically recognizes property names in regular
expressions with an optional \f(CW\*(C`"Is_\*(C'\fR" (with or without the underscore)
prefixed to them, such as \f(CW\*(C`\ep{isgc=punct}\*(C'\fR.  This function does not recognize
those in the input, returning \f(CW\*(C`undef\*(C'\fR.  Nor are they included in the output
as possible synonyms.
.PP
\&\f(CW\*(C`prop_aliases\*(C'\fR does know about the Perl extensions to Unicode properties,
such as \f(CW\*(C`Any\*(C'\fR and \f(CW\*(C`XPosixAlpha\*(C'\fR, and the single form equivalents to Unicode
properties such as \f(CW\*(C`XDigit\*(C'\fR, \f(CW\*(C`Greek\*(C'\fR, \f(CW\*(C`In_Greek\*(C'\fR, and \f(CW\*(C`Is_Greek\*(C'\fR.  The
final example demonstrates that the \f(CW"Is_"\fR prefix is recognized for these
extensions; it is needed to resolve ambiguities.  For example,
\&\f(CW\*(C`prop_aliases(\*(Aqlc\*(Aq)\*(C'\fR returns the list \f(CW\*(C`(lc, Lowercase_Mapping)\*(C'\fR, but
\&\f(CW\*(C`prop_aliases(\*(Aqislc\*(Aq)\*(C'\fR returns \f(CW\*(C`(Is_LC, Cased_Letter)\*(C'\fR.  This is
because \f(CW\*(C`islc\*(C'\fR is a Perl extension which is short for
\&\f(CW\*(C`General_Category=Cased Letter\*(C'\fR.  The lists returned for the Perl extensions
will not include the \f(CW"Is_"\fR prefix (whether or not the input had it) unless
needed to resolve ambiguities, as shown in the \f(CW"islc"\fR example, where the
returned list had one element containing \f(CW"Is_"\fR, and the other without.
.PP
It is also possible for the reverse to happen:  \f(CW\*(C`prop_aliases(\*(Aqisc\*(Aq)\*(C'\fR returns
the list \f(CW\*(C`(isc, ISO_Comment)\*(C'\fR; whereas \f(CW\*(C`prop_aliases(\*(Aqc\*(Aq)\*(C'\fR returns
\&\f(CW\*(C`(C, Other)\*(C'\fR (the latter being a Perl extension meaning
\&\f(CW\*(C`General_Category=Other\*(C'\fR.
\&\*(L"Properties accessible through Unicode::UCD\*(R" in perluniprops lists the available
forms, including which ones are discouraged from use.
.PP
Those discouraged forms are accepted as input to \f(CW\*(C`prop_aliases\*(C'\fR, but are not
returned in the lists.  \f(CW\*(C`prop_aliases(\*(AqisL&\*(Aq)\*(C'\fR and \f(CW\*(C`prop_aliases(\*(AqisL_\*(Aq)\*(C'\fR,
which are old synonyms for \f(CW"Is_LC"\fR and should not be used in new code, are
examples of this.  These both return \f(CW\*(C`(Is_LC, Cased_Letter)\*(C'\fR.  Thus this
function allows you to take a discourarged form, and find its acceptable
alternatives.  The same goes with single-form Block property equivalences.
Only the forms that begin with \f(CW"In_"\fR are not discouraged; if you pass
\&\f(CW\*(C`prop_aliases\*(C'\fR a discouraged form, you will get back the equivalent ones that
begin with \f(CW"In_"\fR.  It will otherwise look like a new-style block name (see.
\&\*(L"Old-style versus new-style block names\*(R").
.PP
\&\f(CW\*(C`prop_aliases\*(C'\fR does not know about any user-defined properties, and will
return \f(CW\*(C`undef\*(C'\fR if called with one of those.  Likewise for Perl internal
properties, with the exception of \*(L"Perl_Decimal_Digit\*(R" which it does know
about (and which is documented below in \*(L"\fIprop_invmap()\fR\*(R").
.SS "\fB\fP\f(BIprop_value_aliases()\fP\fB\fP"
.IX Subsection "prop_value_aliases()"
.Vb 1
\&    use Unicode::UCD \*(Aqprop_value_aliases\*(Aq;
\&
\&    my ($short_name, $full_name, @other_names)
\&                                   = prop_value_aliases("Gc", "Punct");
\&    my $same_full_name = prop_value_aliases("Gc", "P");   # Scalar cntxt
\&    my ($same_short_name) = prop_value_aliases("Gc", "P"); # gets 0th
\&                                                           # element
\&    print "The full name is $full_name\en";
\&    print "The short name is $short_name\en";
\&    print "The other aliases are: ", join(", ", @other_names), "\en";
\&
\&    prints:
\&    The full name is Punctuation
\&    The short name is P
\&    The other aliases are: Punct
.Ve
.PP
Some Unicode properties have a restricted set of legal values.  For example,
all binary properties are restricted to just \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR; and there
are only a few dozen possible General Categories.
.PP
For such properties, there are usually several synonyms for each possible
value.  For example, in binary properties, \fItruth\fR can be represented by any of
the strings \*(L"Y\*(R", \*(L"Yes\*(R", \*(L"T\*(R", or \*(L"True\*(R"; and the General Category
\&\*(L"Punctuation\*(R" by that string, or \*(L"Punct\*(R", or simply \*(L"P\*(R".
.PP
Like property names, there is typically at least a short name for each such
property-value, and a long name.  If you know any name of the property-value,
you can use \f(CW\*(C`prop_value_aliases\*(C'\fR() to get the long name (when called in
scalar context), or a list of all the names, with the short name in the 0th
element, the long name in the next element, and any other synonyms in the
remaining elements, in no particular order, except that any all-numeric
synonyms will be last.
.PP
The long name is returned in a form nicely capitalized, suitable for printing.
.PP
Case, white space, hyphens, and underscores are ignored in the input parameters
(except for the trailing underscore in the old-form grandfathered-in general
category property value \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR).
.PP
If either name is unknown, \f(CW\*(C`undef\*(C'\fR is returned.  Note that Perl typically
recognizes property names in regular expressions with an optional \f(CW\*(C`"Is_\*(C'\fR"
(with or without the underscore) prefixed to them, such as \f(CW\*(C`\ep{isgc=punct}\*(C'\fR.
This function does not recognize those in the property parameter, returning
\&\f(CW\*(C`undef\*(C'\fR.
.PP
If called with a property that doesn't have synonyms for its values, it
returns the input value, possibly normalized with capitalization and
underscores.
.PP
For the block property, new-style block names are returned (see
\&\*(L"Old-style versus new-style block names\*(R").
.PP
To find the synonyms for single-forms, such as \f(CW\*(C`\ep{Any}\*(C'\fR, use
\&\*(L"\fIprop_aliases()\fR\*(R" instead.
.PP
\&\f(CW\*(C`prop_value_aliases\*(C'\fR does not know about any user-defined properties, and
will return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "\fB\fP\f(BIprop_invlist()\fP\fB\fP"
.IX Subsection "prop_invlist()"
\&\f(CW\*(C`prop_invlist\*(C'\fR returns an inversion list (described below) that defines all the
code points for the binary Unicode property (or \*(L"property=value\*(R" pair) given
by the input parameter string:
.PP
.Vb 3
\& use feature \*(Aqsay\*(Aq;
\& use Unicode::UCD \*(Aqprop_invlist\*(Aq;
\& say join ", ", prop_invlist("Any");
\&
\& prints:
\& 0, 1114112
.Ve
.PP
If the input is unknown \f(CW\*(C`undef\*(C'\fR is returned in scalar context; an empty-list
in list context.  If the input is known, the number of elements in
the list is returned if called in scalar context.
.PP
perluniprops gives
the list of properties that this function accepts, as well as all the possible
forms for them (including with the optional \*(L"Is_\*(R" prefixes).  (Except this
function doesn't accept any Perl-internal properties, some of which are listed
there.) This function uses the same loose or tighter matching rules for
resolving the input property's name as is done for regular expressions.  These
are also specified in perluniprops.  Examples of using the \*(L"property=value\*(R" form are:
.PP
.Vb 1
\& say join ", ", prop_invlist("Script=Shavian");
\&
\& prints:
\& 66640, 66688
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=No");
\&
\& prints:
\& 0, 48, 58, 65, 71, 97, 103
\&
\& say join ", ", prop_invlist("ASCII_Hex_Digit=Yes");
\&
\& prints:
\& 48, 58, 65, 71, 97, 103
.Ve
.PP
Inversion lists are a compact way of specifying Unicode property-value
definitions.  The 0th item in the list is the lowest code point that has the
property-value.  The next item (item [1]) is the lowest code point beyond that
one that does \s-1NOT\s0 have the property-value.  And the next item beyond that
([2]) is the lowest code point beyond that one that does have the
property-value, and so on.  Put another way, each element in the list gives
the beginning of a range that has the property-value (for even numbered
elements), or doesn't have the property-value (for odd numbered elements).
The name for this data structure stems from the fact that each element in the
list toggles (or inverts) whether the corresponding range is or isn't on the
list.
.PP
In the final example above, the first \s-1ASCII\s0 Hex digit is code point 48, the
character \*(L"0\*(R", and all code points from it through 57 (a \*(L"9\*(R") are \s-1ASCII\s0 hex
digits.  Code points 58 through 64 aren't, but 65 (an \*(L"A\*(R") through 70 (an \*(L"F\*(R")
are, as are 97 (\*(L"a\*(R") through 102 (\*(L"f\*(R").  103 starts a range of code points
that aren't \s-1ASCII\s0 hex digits.  That range extends to infinity, which on your
computer can be found in the variable \f(CW$Unicode::UCD::MAX_CP\fR.  (This
variable is as close to infinity as Perl can get on your platform, and may be
too high for some operations to work; you may wish to use a smaller number for
your purposes.)
.PP
Note that the inversion lists returned by this function can possibly include
non-Unicode code points, that is anything above 0x10FFFF.  This is in
contrast to Perl regular expression matches on those code points, in which a
non-Unicode code point always fails to match.  For example, both of these have
the same result:
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Fails!
.Ve
.PP
And both raise a warning that a Unicode property is being used on a
non-Unicode code point.  It is arguable as to which is the correct thing to do
here.  This function has chosen the way opposite to the Perl regular
expression behavior.  This allows you to easily flip to to the Perl regular
expression way (for you to go in the other direction would be far harder).
Simply add 0x110000 at the end of the non-empty returned list if it isn't
already that value; and pop that value if it is; like:
.PP
.Vb 9
\& my @list = prop_invlist("foo");
\& if (@list) {
\&     if ($list[\-1] == 0x110000) {
\&         pop @list;  # Defeat the turning on for above Unicode
\&     }
\&     else {
\&         push @list, 0x110000; # Turn off for above Unicode
\&     }
\& }
.Ve
.PP
It is a simple matter to expand out an inversion list to a full list of all
code points that have the property-value:
.PP
.Vb 10
\& my @invlist = prop_invlist($property_name);
\& die "empty" unless @invlist;
\& my @full_list;
\& for (my $i = 0; $i < @invlist; $i += 2) {
\&    my $upper = ($i + 1) < @invlist
\&                ? $invlist[$i+1] \- 1      # In range
\&                : $Unicode::UCD::MAX_CP;  # To infinity.  You may want
\&                                          # to stop much much earlier;
\&                                          # going this high may expose
\&                                          # perl deficiencies with very
\&                                          # large numbers.
\&    for my $j ($invlist[$i] .. $upper) {
\&        push @full_list, $j;
\&    }
\& }
.Ve
.PP
\&\f(CW\*(C`prop_invlist\*(C'\fR does not know about any user-defined nor Perl internal-only
properties, and will return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "\fB\fP\f(BIprop_invmap()\fP\fB\fP"
.IX Subsection "prop_invmap()"
.Vb 3
\& use Unicode::UCD \*(Aqprop_invmap\*(Aq;
\& my ($list_ref, $map_ref, $format, $missing)
\&                                      = prop_invmap("General Category");
.Ve
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is used to get the complete mapping definition for a property,
in the form of an inversion map.  An inversion map consists of two parallel
arrays.  One is an ordered list of code points that mark range beginnings, and
the other gives the value (or mapping) that all code points in the
corresponding range have.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR is called with the name of the desired property.  The name is
loosely matched, meaning that differences in case, white-space, hyphens, and
underscores are not meaningful (except for the trailing underscore in the
old-form grandfathered-in property \f(CW"L_"\fR, which is better written as \f(CW"LC"\fR,
or even better, \f(CW"Gc=LC"\fR).
.PP
Many Unicode properties have more than one name (or alias).  \f(CW\*(C`prop_invmap\*(C'\fR
understands all of these, including Perl extensions to them.  Ambiguities are
resolved as described above for \*(L"\fIprop_aliases()\fR\*(R".  The Perl internal
property "Perl_Decimal_Digit, described below, is also accepted.  \f(CW\*(C`undef\*(C'\fR is
returned if the property name is unknown.
See \*(L"Properties accessible through Unicode::UCD\*(R" in perluniprops for the
properties acceptable as inputs to this function.
.PP
It is a fatal error to call this function except in list context.
.PP
In addition to the the two arrays that form the inversion map, \f(CW\*(C`prop_invmap\*(C'\fR
returns two other values; one is a scalar that gives some details as to the
format of the entries of the map array; the other is used for specialized
purposes, described at the end of this section.
.PP
This means that \f(CW\*(C`prop_invmap\*(C'\fR returns a 4 element list.  For example,
.PP
.Vb 2
\& my ($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
\&                                                 = prop_invmap("Block");
.Ve
.PP
In this call, the two arrays will be populated as shown below (for Unicode
6.0):
.PP
.Vb 10
\& Index  @blocks_ranges  @blocks_maps
\&   0        0x0000      Basic Latin
\&   1        0x0080      Latin\-1 Supplement
\&   2        0x0100      Latin Extended\-A
\&   3        0x0180      Latin Extended\-B
\&   4        0x0250      IPA Extensions
\&   5        0x02B0      Spacing Modifier Letters
\&   6        0x0300      Combining Diacritical Marks
\&   7        0x0370      Greek and Coptic
\&   8        0x0400      Cyrillic
\&  ...
\& 233        0x2B820     No_Block
\& 234        0x2F800     CJK Compatibility Ideographs Supplement
\& 235        0x2FA20     No_Block
\& 236        0xE0000     Tags
\& 237        0xE0080     No_Block
\& 238        0xE0100     Variation Selectors Supplement
\& 239        0xE01F0     No_Block
\& 240        0xF0000     Supplementary Private Use Area\-A
\& 241        0x100000    Supplementary Private Use Area\-B
\& 242        0x110000    No_Block
.Ve
.PP
The first line (with Index [0]) means that the value for code point 0 is \*(L"Basic
Latin\*(R".  The entry \*(L"0x0080\*(R" in the \f(CW@blocks_ranges\fR column in the second line
means that the value from the first line, \*(L"Basic Latin\*(R", extends to all code
points in the range from 0 up to but not including 0x0080, that is, through
127.  In other words, the code points from 0 to 127 are all in the \*(L"Basic
Latin\*(R" block.  Similarly, all code points in the range from 0x0080 up to (but
not including) 0x0100 are in the block named \*(L"Latin\-1 Supplement\*(R", etc.
(Notice that the return is the old-style block names; see \*(L"Old-style versus
new-style block names\*(R").
.PP
The final line (with Index [242]) means that the value for all code points above
the legal Unicode maximum code point have the value \*(L"No_Block\*(R", which is the
term Unicode uses for a non-existing block.
.PP
The arrays completely specify the mappings for all possible code points.
The final element in an inversion map returned by this function will always be
for the range that consists of all the code points that aren't legal Unicode,
but that are expressible on the platform.  (That is, it starts with code point
0x110000, the first code point above the legal Unicode maximum, and extends to
infinity.) The value for that range will be the same that any typical
unassigned code point has for the specified property.  (Certain unassigned
code points are not \*(L"typical\*(R"; for example the non-character code points, or
those in blocks that are to be written right-to-left.  The above-Unicode
range's value is not based on these atypical code points.)  It could be argued
that, instead of treating these as unassigned Unicode code points, the value
for this range should be \f(CW\*(C`undef\*(C'\fR.  If you wish, you can change the returned
arrays accordingly.
.PP
The maps are almost always simple scalars that should be interpreted as-is.
These values are those given in the Unicode-supplied data files, which may be
inconsistent as to capitalization and as to which synonym for a property-value
is given.  The results may be normalized by using the \*(L"\fIprop_value_aliases()\fR\*(R"
function.
.PP
There are exceptions to the simple scalar maps.  Some properties have some
elements in their map list that are themselves lists of scalars; and some
special strings are returned that are not to be interpreted as-is.  Element
[2] (placed into \f(CW$format\fR in the example above) of the returned four element
list tells you if the map has any of these special elements or not, as follows:
.ie n .IP "\fB\fB""s""\fB\fR" 4
.el .IP "\fB\f(CBs\fB\fR" 4
.IX Item "s"
means all the elements of the map array are simple scalars, with no special
elements.  Almost all properties are like this, like the \f(CW\*(C`block\*(C'\fR example
above.
.ie n .IP "\fB\fB""sl""\fB\fR" 4
.el .IP "\fB\f(CBsl\fB\fR" 4
.IX Item "sl"
means that some of the map array elements have the form given by \f(CW"s"\fR, and
the rest are lists of scalars.  For example, here is a portion of the output
of calling \f(CW\*(C`prop_invmap\*(C'\fR() with the \*(L"Script Extensions\*(R" property:
.Sp
.Vb 6
\& @scripts_ranges  @scripts_maps
\&      ...
\&      0x0953      Devanagari
\&      0x0964      [ Bengali, Devanagari, Gurumukhi, Oriya ]
\&      0x0966      Devanagari
\&      0x0970      Common
.Ve
.Sp
Here, the code points 0x964 and 0x965 are both used in Bengali,
Devanagari, Gurmukhi, and Oriya, but no other scripts.
.Sp
The Name_Alias property is also of this form.  But each scalar consists of two
components:  1) the name, and 2) the type of alias this is.  They are
separated by a colon and a space.  In Unicode 6.1, there are several alias types:
.RS 4
.ie n .IP """correction""" 4
.el .IP "\f(CWcorrection\fR" 4
.IX Item "correction"
indicates that the name is a corrected form for the
original name (which remains valid) for the same code point.
.ie n .IP """control""" 4
.el .IP "\f(CWcontrol\fR" 4
.IX Item "control"
adds a new name for a control character.
.ie n .IP """alternate""" 4
.el .IP "\f(CWalternate\fR" 4
.IX Item "alternate"
is an alternate name for a character
.ie n .IP """figment""" 4
.el .IP "\f(CWfigment\fR" 4
.IX Item "figment"
is a name for a character that has been documented but was never in any
actual standard.
.ie n .IP """abbreviation""" 4
.el .IP "\f(CWabbreviation\fR" 4
.IX Item "abbreviation"
is a common abbreviation for a character
.RE
.RS 4
.Sp
The lists are ordered (roughly) so the most preferred names come before less
preferred ones.
.Sp
For example,
.Sp
.Vb 10
\& @aliases_ranges        @alias_maps
\&    ...
\&    0x009E        [ \*(AqPRIVACY MESSAGE: control\*(Aq, \*(AqPM: abbreviation\*(Aq ]
\&    0x009F        [ \*(AqAPPLICATION PROGRAM COMMAND: control\*(Aq,
\&                    \*(AqAPC: abbreviation\*(Aq
\&                  ]
\&    0x00A0        \*(AqNBSP: abbreviation\*(Aq
\&    0x00A1        ""
\&    0x00AD        \*(AqSHY: abbreviation\*(Aq
\&    0x00AE        ""
\&    0x01A2        \*(AqLATIN CAPITAL LETTER GHA: correction\*(Aq
\&    0x01A3        \*(AqLATIN SMALL LETTER GHA: correction\*(Aq
\&    0x01A4        ""
\&    ...
.Ve
.Sp
A map to the empty string means that there is no alias defined for the code
point.
.RE
.ie n .IP "\fB\fB""a""\fB\fR" 4
.el .IP "\fB\f(CBa\fB\fR" 4
.IX Item "a"
is like \f(CW"s"\fR in that all the map array elements are scalars, but here they are
restricted to all being integers, and some have to be adjusted (hence the name
\&\f(CW"a"\fR) to get the correct result.  For example, in:
.Sp
.Vb 2
\& my ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                          = prop_invmap("Simple_Uppercase_Mapping");
.Ve
.Sp
the returned arrays look like this:
.Sp
.Vb 7
\& @$uppers_ranges_ref    @$uppers_maps_ref   Note
\&       0                      0
\&      97                     65          \*(Aqa\*(Aq maps to \*(AqA\*(Aq, b => B ...
\&     123                      0
\&     181                    924          MICRO SIGN => Greek Cap MU
\&     182                      0
\&     ...
.Ve
.Sp
Let's start with the second line.  It says that the uppercase of code point 97
is 65; or \f(CW\*(C`uc("a")\*(C'\fR == \*(L"A\*(R".  But the line is for the entire range of code
points 97 through 122.  To get the mapping for any code point in a range, you
take the offset it has from the beginning code point of the range, and add
that to the mapping for that first code point.  So, the mapping for 122 (\*(L"z\*(R")
is derived by taking the offset of 122 from 97 (=25) and adding that to 65,
yielding 90 (\*(L"z\*(R").  Likewise for everything in between.
.Sp
The first line works the same way.  The first map in a range is always the
correct value for its code point (because the adjustment is 0).  Thus the
\&\f(CW\*(C`uc(chr(0))\*(C'\fR is just itself.  Also, \f(CW\*(C`uc(chr(1))\*(C'\fR is also itself, as the
adjustment is 0+1\-0 .. \f(CW\*(C`uc(chr(96))\*(C'\fR is 96.
.Sp
Requiring this simple adjustment allows the returned arrays to be
significantly smaller than otherwise, up to a factor of 10, speeding up
searching through them.
.ie n .IP "\fB\fB""al""\fB\fR" 4
.el .IP "\fB\f(CBal\fB\fR" 4
.IX Item "al"
means that some of the map array elements have the form given by \f(CW"a"\fR, and
the rest are ordered lists of code points.
For example, in:
.Sp
.Vb 2
\& my ($uppers_ranges_ref, $uppers_maps_ref, $format)
\&                                 = prop_invmap("Uppercase_Mapping");
.Ve
.Sp
the returned arrays look like this:
.Sp
.Vb 11
\& @$uppers_ranges_ref    @$uppers_maps_ref
\&       0                      0
\&      97                     65
\&     123                      0
\&     181                    924
\&     182                      0
\&     ...
\&    0x0149              [ 0x02BC 0x004E ]
\&    0x014A                    0
\&    0x014B                  330
\&     ...
.Ve
.Sp
This is the full Uppercase_Mapping property (as opposed to the
Simple_Uppercase_Mapping given in the example for format \f(CW"a"\fR).  The only
difference between the two in the ranges shown is that the code point at
0x0149 (\s-1LATIN SMALL LETTER N PRECEDED BY APOSTROPHE\s0) maps to a string of two
characters, 0x02BC (\s-1MODIFIER LETTER APOSTROPHE\s0) followed by 0x004E (\s-1LATIN
CAPITAL LETTER N\s0).
.Sp
No adjustments are needed to entries that are references to arrays; each such
entry will have exactly one element in its range, so the offset is always 0.
.ie n .IP "\fB\fB""ae""\fB\fR" 4
.el .IP "\fB\f(CBae\fB\fR" 4
.IX Item "ae"
This is like \f(CW"a"\fR, but some elements are the empty string, and should not be
adjusted.
The one internal Perl property accessible by \f(CW\*(C`prop_invmap\*(C'\fR is of this type:
\&\*(L"Perl_Decimal_Digit\*(R" returns an inversion map which gives the numeric values
that are represented by the Unicode decimal digit characters.  Characters that
don't represent decimal digits map to the empty string, like so:
.Sp
.Vb 12
\& @digits    @values
\& 0x0000       ""
\& 0x0030        0
\& 0x003A:      ""
\& 0x0660:       0
\& 0x066A:      ""
\& 0x06F0:       0
\& 0x06FA:      ""
\& 0x07C0:       0
\& 0x07CA:      ""
\& 0x0966:       0
\& ...
.Ve
.Sp
This means that the code points from 0 to 0x2F do not represent decimal digits;
the code point 0x30 (\s-1DIGIT ZERO\s0) represents 0;  code point 0x31, (\s-1DIGIT ONE\s0),
represents 0+1\-0 = 1; ... code point 0x39, (\s-1DIGIT NINE\s0), represents 0+9\-0 = 9;
\&... code points 0x3A through 0x65F do not represent decimal digits; 0x660
(ARABIC-INDIC \s-1DIGIT ZERO\s0), represents 0; ... 0x07C1 (\s-1NKO DIGIT ONE\s0),
represents 0+1\-0 = 1 ...
.ie n .IP "\fB\fB""ale""\fB\fR" 4
.el .IP "\fB\f(CBale\fB\fR" 4
.IX Item "ale"
is a combination of the \f(CW"al"\fR type and the \f(CW"ae"\fR type.  Some of
the map array elements have the forms given by \f(CW"al"\fR, and
the rest are the empty string.  The property \f(CW\*(C`NFKC_Casefold\*(C'\fR has this form.
An example slice is:
.Sp
.Vb 9
\& @$ranges_ref  @$maps_ref         Note
\&    ...
\&   0x00AA       97                FEMININE ORDINAL INDICATOR => \*(Aqa\*(Aq
\&   0x00AB        0
\&   0x00AD                         SOFT HYPHEN => ""
\&   0x00AE        0
\&   0x00AF     [ 0x0020, 0x0304 ]  MACRON => SPACE . COMBINING MACRON
\&   0x00B0        0
\&   ...
.Ve
.ie n .IP "\fB\fB""ar""\fB\fR" 4
.el .IP "\fB\f(CBar\fB\fR" 4
.IX Item "ar"
means that all the elements of the map array are either rational numbers or
the string \f(CW"NaN"\fR, meaning \*(L"Not a Number\*(R".  A rational number is either an
integer, or two integers separated by a solidus (\f(CW"/"\fR).  The second integer
represents the denominator of the division implied by the solidus, and is
actually always positive, so it is guaranteed not to be 0 and to not be
signed.  When the element is a plain integer (without the
solidus), it may need to be adjusted to get the correct value by adding the
offset, just as other \f(CW"a"\fR properties.  No adjustment is needed for
fractions, as the range is guaranteed to have just a single element, and so
the offset is always 0.
.Sp
If you want to convert the returned map to entirely scalar numbers, you
can use something like this:
.Sp
.Vb 4
\& my ($invlist_ref, $invmap_ref, $format) = prop_invmap($property);
\& if ($format && $format eq "ar") {
\&     map { $_ = eval $_ if $_ ne \*(AqNaN\*(Aq } @$map_ref;
\& }
.Ve
.Sp
Here's some entries from the output of the property \*(L"Nv\*(R", which has format
\&\f(CW"ar"\fR.
.Sp
.Vb 10
\& @numerics_ranges  @numerics_maps       Note
\&        0x00           "NaN"
\&        0x30             0           DIGIT 0 .. DIGIT 9
\&        0x3A           "NaN"
\&        0xB2             2           SUPERSCRIPTs 2 and 3
\&        0xB4           "NaN"
\&        0xB9             1           SUPERSCRIPT 1
\&        0xBA           "NaN"
\&        0xBC            1/4          VULGAR FRACTION 1/4
\&        0xBD            1/2          VULGAR FRACTION 1/2
\&        0xBE            3/4          VULGAR FRACTION 3/4
\&        0xBF           "NaN"
\&        0x660            0           ARABIC\-INDIC DIGIT ZERO .. NINE
\&        0x66A          "NaN"
.Ve
.ie n .IP "\fB\fB""n""\fB\fR" 4
.el .IP "\fB\f(CBn\fB\fR" 4
.IX Item "n"
means the Name property.  All the elements of the map array are simple
scalars, but some of them contain special strings that require more work to
get the actual name.
.Sp
Entries such as:
.Sp
.Vb 1
\& CJK UNIFIED IDEOGRAPH\-<code point>
.Ve
.Sp
mean that the name for the code point is \*(L"\s-1CJK UNIFIED IDEOGRAPH\-\*(R"\s0
with the code point (expressed in hexadecimal) appended to it, like \*(L"\s-1CJK
UNIFIED IDEOGRAPH\-3403\*(R" \s0(similarly for \f(CW\*(C`CJK\ COMPATIBILITY\ IDEOGRAPH\-<code\ point>\*(C'\fR).
.Sp
Also, entries like
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
means that the name is algorithmically calculated.  This is easily done by
the function \*(L"charnames::viacode(code)\*(R" in charnames.
.Sp
Note that for control characters (\f(CW\*(C`Gc=cc\*(C'\fR), Unicode's data files have the
string "\f(CW\*(C`<control>\*(C'\fR", but the real name of each of these characters is the empty
string.  This function returns that real name, the empty string.  (There are
names for these characters, but they are considered aliases, not the Name
property name, and are contained in the \f(CW\*(C`Name_Alias\*(C'\fR property.)
.ie n .IP "\fB\fB""ad""\fB\fR" 4
.el .IP "\fB\f(CBad\fB\fR" 4
.IX Item "ad"
means the Decomposition_Mapping property.  This property is like \f(CW"al"\fR
properties, except that one of the scalar elements is of the form:
.Sp
.Vb 1
\& <hangul syllable>
.Ve
.Sp
This signifies that this entry should be replaced by the decompositions for
all the code points whose decomposition is algorithmically calculated.  (All
of them are currently in one range and no others outisde the range are likely
to ever be added to Unicode; the \f(CW"n"\fR format
has this same entry.)  These can be generated via the function
\&\fIUnicode::Normalize::NFD()\fR.
.Sp
Note that the mapping is the one that is specified in the Unicode data files,
and to get the final decomposition, it may need to be applied recursively.
.PP
Note that a format begins with the letter \*(L"a\*(R" if and only the property it is
for requires adjustments by adding the offsets in multi-element ranges.  For
all these properties, an entry should be adjusted only if the map is a scalar
which is an integer.  That is, it must match the regular expression:
.PP
.Vb 1
\&    / ^ \-? \ed+ $ /xa
.Ve
.PP
Further, the first element in a range never needs adjustment, as the
adjustment would be just adding 0.
.PP
A binary search can be used to quickly find a code point in the inversion
list, and hence its corresponding mapping.
.PP
The final element (index [3], assigned to \f(CW$default\fR in the \*(L"block\*(R" example) in
the four element list returned by this function may be useful for applications
that wish to convert the returned inversion map data structure into some
other, such as a hash.  It gives the mapping that most code points map to
under the property.  If you establish the convention that any code point not
explicitly listed in your data structure maps to this value, you can
potentially make your data structure much smaller.  As you construct your data
structure from the one returned by this function, simply ignore those ranges
that map to this value, generally called the \*(L"default\*(R" value.  For example, to
convert to the data structure searchable by \*(L"\fIcharinrange()\fR\*(R", you can follow
this recipe for properties that don't require adjustments:
.PP
.Vb 2
\& my ($list_ref, $map_ref, $format, $missing) = prop_invmap($property);
\& my @range_list;
\&
\& # Look at each element in the list, but the \-2 is needed because we
\& # look at $i+1 in the loop, and the final element is guaranteed to map
\& # to $missing by prop_invmap(), so we would skip it anyway.
\& for my $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&    push @range_list, [ $list_ref\->[$i],
\&                        $list_ref\->[$i+1],
\&                        $map_ref\->[$i]
\&                      ];
\& }
\&
\& print charinrange(\e@range_list, $code_point), "\en";
.Ve
.PP
With this, \f(CW\*(C`charinrange()\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR if its input code point maps
to \f(CW$missing\fR.  You can avoid this by omitting the \f(CW\*(C`next\*(C'\fR statement, and adding
a line after the loop to handle the final element of the inversion map.
.PP
Similarly, this recipe can be used for properties that do require adjustments:
.PP
.Vb 2
\& for my $i (0 .. @$list_ref \- 2) {
\&    next if $map_ref\->[$i] eq $missing;
\&
\&    # prop_invmap() guarantees that if the mapping is to an array, the
\&    # range has just one element, so no need to worry about adjustments.
\&    if (ref $map_ref\->[$i]) {
\&        push @range_list,
\&                   [ $list_ref\->[$i], $list_ref\->[$i], $map_ref\->[$i] ];
\&    }
\&    else {  # Otherwise each element is actually mapped to a separate
\&            # value, so the range has to be split into single code point
\&            # ranges.
\&
\&        my $adjustment = 0;
\&
\&        # For each code point that gets mapped to something...
\&        for my $j ($list_ref\->[$i] .. $list_ref\->[$i+1] \-1 ) {
\&
\&            # ... add a range consisting of just it mapping to the
\&            # original plus the adjustment, which is incremented for the
\&            # next time through the loop, as the offset increases by 1
\&            # for each element in the range
\&            push @range_list,
\&                             [ $j, $j, $map_ref\->[$i] + $adjustment++ ];
\&        }
\&    }
\& }
.Ve
.PP
Note that the inversion maps returned for the \f(CW\*(C`Case_Folding\*(C'\fR and
\&\f(CW\*(C`Simple_Case_Folding\*(C'\fR properties do not include the Turkic-locale mappings.
Use \*(L"\fIcasefold()\fR\*(R" for these.
.PP
\&\f(CW\*(C`prop_invmap\*(C'\fR does not know about any user-defined properties, and will
return \f(CW\*(C`undef\*(C'\fR if called with one of those.
.SS "Unicode::UCD::UnicodeVersion"
.IX Subsection "Unicode::UCD::UnicodeVersion"
This returns the version of the Unicode Character Database, in other words, the
version of the Unicode standard the database implements.  The version is a
string of numbers delimited by dots (\f(CW\*(Aq.\*(Aq\fR).
.SS "\fBBlocks versus Scripts\fP"
.IX Subsection "Blocks versus Scripts"
The difference between a block and a script is that scripts are closer
to the linguistic notion of a set of code points required to present
languages, while block is more of an artifact of the Unicode code point
numbering and separation into blocks of consecutive code points (so far the
size of a block is some multiple of 16, like 128 or 256).
.PP
For example the Latin \fBscript\fR is spread over several \fBblocks\fR, such
as \f(CW\*(C`Basic Latin\*(C'\fR, \f(CW\*(C`Latin 1 Supplement\*(C'\fR, \f(CW\*(C`Latin Extended\-A\*(C'\fR, and
\&\f(CW\*(C`Latin Extended\-B\*(C'\fR.  On the other hand, the Latin script does not
contain all the characters of the \f(CW\*(C`Basic Latin\*(C'\fR block (also known as
\&\s-1ASCII\s0): it includes only the letters, and not, for example, the digits
or the punctuation.
.PP
For blocks see <http://www.unicode.org/Public/UNIDATA/Blocks.txt>
.PP
For scripts see \s-1UTR\s0 #24: <http://www.unicode.org/unicode/reports/tr24/>
.SS "\fBMatching Scripts and Blocks\fP"
.IX Subsection "Matching Scripts and Blocks"
Scripts are matched with the regular-expression construct
\&\f(CW\*(C`\ep{...}\*(C'\fR (e.g. \f(CW\*(C`\ep{Tibetan}\*(C'\fR matches characters of the Tibetan script),
while \f(CW\*(C`\ep{Blk=...}\*(C'\fR is used for blocks (e.g. \f(CW\*(C`\ep{Blk=Tibetan}\*(C'\fR matches
any of the 256 code points in the Tibetan block).
.SS "Old-style versus new-style block names"
.IX Subsection "Old-style versus new-style block names"
Unicode publishes the names of blocks in two different styles, though the two
are equivalent under Unicode's loose matching rules.
.PP
The original style uses blanks and hyphens in the block names (except for
\&\f(CW\*(C`No_Block\*(C'\fR), like so:
.PP
.Vb 1
\& Miscellaneous Mathematical Symbols\-B
.Ve
.PP
The newer style replaces these with underscores, like this:
.PP
.Vb 1
\& Miscellaneous_Mathematical_Symbols_B
.Ve
.PP
This newer style is consistent with the values of other Unicode properties.
To preserve backward compatibility, all the functions in Unicode::UCD that
return block names (except one) return the old-style ones.  That one function,
\&\*(L"\fIprop_value_aliases()\fR\*(R" can be used to convert from old-style to new-style:
.PP
.Vb 1
\& my $new_style = prop_values_aliases("block", $old_style);
.Ve
.PP
Perl also has single-form extensions that refer to blocks, \f(CW\*(C`In_Cyrillic\*(C'\fR,
meaning \f(CW\*(C`Block=Cyrillic\*(C'\fR.  These have always been written in the new style.
.PP
To convert from new-style to old-style, follow this recipe:
.PP
.Vb 1
\& $old_style = charblock((prop_invlist("block=$new_style"))[0]);
.Ve
.PP
(which finds the range of code points in the block using \f(CW\*(C`prop_invlist\*(C'\fR,
gets the lower end of the range (0th element) and then looks up the old name
for its block using \f(CW\*(C`charblock\*(C'\fR).
.PP
Note that starting in Unicode 6.1, many of the block names have shorter
synonyms.  These are always given in the new style.
.SH "BUGS"
.IX Header "BUGS"
Does not yet support \s-1EBCDIC\s0 platforms.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi.  Now maintained by perl5 porters.
                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Unix::Syslog.3pm                             0100644 0001750 0001750 00000027745 12566241467 023635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Syslog 3"
.TH Syslog 3 "2008-05-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unix::Syslog \- Perl interface to the UNIX syslog(3) calls
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Unix::Syslog qw(:macros);  # Syslog macros
\& use Unix::Syslog qw(:subs);    # Syslog functions
\&
\& openlog $ident, $option, $facility;
\& syslog $priority, $format, @formatargs;
\& closelog;
\& $oldmask = setlogmask $mask_priority;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface to the system logger \fBsyslogd\fR(8) via
Perl's XSUBs. The implementation attempts to resemble the native
libc-functions of your system, so that anyone being familiar with
\&\fIsyslog.h\fR should be able to use this module right away.
.PP
In contrary to \fISys::Syslog\fR\|(3), this modules does not open a network
connection to send the messages. This can help you to avoid opening
security holes in your computer (see \*(L"\s-1FAQ\*(R"\s0).
.PP
The subs imported by the tag \f(CW\*(C`macros\*(C'\fR are simply wrappers around the
most important \f(CW\*(C`#defines\*(C'\fR in your system's C header file
\&\fIsyslog.h\fR. The macros return integer values that are used to specify
options, facilities and priorities in a more or less portable
way. They also provide general information about your local syslog
mechanism. Check \fIsyslog\fR\|(3) and your local \fIsyslog.h\fR for information
about the macros, options and facilities available on your system.
.PP
The following functions are provided:
.ie n .IP "openlog $ident, $option, $facility" 4
.el .IP "openlog \f(CW$ident\fR, \f(CW$option\fR, \f(CW$facility\fR" 4
.IX Item "openlog $ident, $option, $facility"
opens a connection to the system logger.  \fI\f(CI$ident\fI\fR is an identifier
string that \fBsyslogd\fR(8) prints into every message. It usually equals
the process name. \fI\f(CI$option\fI\fR is an integer value that is the result of
ORed options. \fI\f(CI$facility\fI\fR is an integer value that specifies the part
of the system the message should be associated with (e.g. kernel
message, mail subsystem).
.ie n .IP "syslog $priority, $format, @formatargs" 4
.el .IP "syslog \f(CW$priority\fR, \f(CW$format\fR, \f(CW@formatargs\fR" 4
.IX Item "syslog $priority, $format, @formatargs"
Generates a log message and passes it to the system logger. If
\&\f(CW\*(C`syslog()\*(C'\fR is called without calling \f(CW\*(C`openlog()\*(C'\fR first, probably
system dependent default values will be used as arguments for an
implicit call to \f(CW\*(C`openlog()\*(C'\fR.
.Sp
\&\fI\f(CI$priority\fI\fR is an integer value that specifies the priority of the
message. Alternatively \fI\f(CI$priority\fI\fR can be the ORed value of a
priority and a facility. In that case a previously selected facility
will be overridden.
.Sp
In the case that \f(CW\*(C`syslog()\*(C'\fR is called without calling \f(CW\*(C`openlog()\*(C'\fR
first and \fIpriority\fR does not specify both a priority \fIand\fR a
facility, a default facility will be used. This behaviour is most
likely system dependent and the user should not rely on any particular
value in that case.
.Sp
\&\fI\f(CI$format\fI\fR is a format string in the style of \fIprintf\fR\|(3). Additionally
to the usual printf directives \f(CW%m\fR can be specified in the
string. It will be replaced implicitly by the contents of the Perl
variable \f(CW$!\fR (\f(CW$ERRNO\fR). \fI\f(CI@formatargs\fI\fR is a list of values that
the format directives will be replaced with subsequently.
.IP "closelog" 4
.IX Item "closelog"
closes the connection to the system logger.
.ie n .IP "setlogmask $mask_priority" 4
.el .IP "setlogmask \f(CW$mask_priority\fR" 4
.IX Item "setlogmask $mask_priority"
sets the priority mask and returns the old mask. Logging is enabled
for the priorities indicated by the bits in the mask that are set and
is disabled where the bits are not set. Macros are provided to specify
valid and portable arguments to \f(CW\*(C`setlogmask()\*(C'\fR. Usually the default
log mask allows all messages to be logged.
.ie n .IP "priorityname $priority" 4
.el .IP "priorityname \f(CW$priority\fR" 4
.IX Item "priorityname $priority"
returns a string containing the name of \fI\f(CI$priority\fI\fR as string. If
this functionality has not been enabled at installation, the function
returns \fIundef\fR.
.ie n .IP "facilityname $facility" 4
.el .IP "facilityname \f(CW$facility\fR" 4
.IX Item "facilityname $facility"
returns a string containing the name of \fI\f(CI$facility\fI\fR as string. If
this functionality has not been enabled at installation, the function
returns \fIundef\fR.
.PP
\&\fB\s-1NOTE\s0\fR: The behaviour of this module is system dependent. It is highly
recommended to consult your system manual for available macros and the
behaviour of the provided functions.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The functions \fIopenlog()\fR, \fIsyslog()\fR and \fIcloselog()\fR return the undefined
value. The function setlogmask returns the previous mask value.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Open a channel to syslogd specifying an identifier (usually the
process name) some options and the facility:
  \f(CW\*(C`openlog "test.pl", LOG_PID | LOG_PERROR, LOG_LOCAL7;\*(C'\fR
.PP
Generate log message of specified priority using a printf-type formatted
string:
  \f(CW\*(C`syslog LOG_INFO, "This is message number %d", 42;\*(C'\fR
.PP
Set log priority mask to block all messages but those of priority
\&\f(CW\*(C`LOG_DEBUG\*(C'\fR:
  \f(CW\*(C`$oldmask = setlogmask(LOG_MASK(LOG_DEBUG))\*(C'\fR
.PP
Set log priority mask to block all messages with a higher priority than
\&\f(CW\*(C`LOG_ERR\*(C'\fR:
  \f(CW\*(C`$oldmask = setlogmask(LOG_UPTO(LOG_ERR))\*(C'\fR
.PP
Close channel to syslogd:
  \f(CW\*(C`closelog;\*(C'\fR
.SH "FAQ"
.IX Header "FAQ"
.IP "1." 4
What is the benefit of using this module instead of Sys::Syslog?
.Sp
Sys::Syslog always opens a network connection to the syslog
service. At least on Linux systems this may lead to some trouble,
because
.RS 4
.IP "\(bu" 4
Linux syslogd (from package sysklogd) does not listen to the network
by default. Most people working on stand-alone machines (including me)
didn't see any reason why to enable this option. Others didn't enable
it for security reasons.
.Sp
OS-independent, some sysadmins may run a firewall on their network
that blocks connections to port 514/udp.
.IP "\(bu" 4
By default Linux syslogd doesn't forward messages which have already
already received from the network to other log hosts. There are
reasons not to enable this option unless it is really
necessary. Looping messages resulting from a misconfiguration may
break down your (log\-)system.
.RE
.RS 4
.Sp
Peter Stamfest <peter.stamfest@eunet.at> pointed out some other
advantages of Unix::Syslog, I didn't came across my self.
.IP "\(bu" 4
\&\s-1LOG_PERROR\s0 works.
.IP "\(bu" 4
works with perl \-Tw without warnings and problems due to tainted data
as it is the case for Sys::Syslog in some special
applications. [Especially when running a script as root]
.RE
.RS 4
.RE
.IP "2." 4
Well, is there any reason to use Sys::Syslog any longer?
.Sp
Yes! In contrary to Unix::Syslog, Sys::Syslog works even if you don't
have a syslog daemon running on your system as long as you are
connected to a log host via a network and have access to the
\&\fIsyslog.h\fR header file of your log host to generate the initial files
for Sys::Syslog (see \fISys::Syslog\fR\|(3) for details). Unix::Syslog only logs
to your local syslog daemon which in turn may be configured to
distribute the message over the network.
.IP "3." 4
Are calls to the functions provided by Unix::Syslog compatible to those
of Sys::Syslog?
.Sp
Currently not. Sys::Syslog requires strings to specify many of the
arguments to the functions, while Unix::Syslog uses numeric constants
accessed via macros as defined in \fIsyslog.h\fR. Although the strings
used by Sys::Syslog are also defined in \fIsyslog.h\fR, it seems that most
people got used to the numeric arguments. I will implement the string
based calls if there are enough people (\fI\f(CI$min_people\fI\fR > 10**40)
complaining about the lack of compatibility.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIsyslog\fR\|(3), \fISys::Syslog\fR\|(3), \fIsyslogd\fR\|(8), \fIperl\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Marcus Harnisch <marcus.harnisch@gmx.net>
                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Unix::Syslog5.16.3pm                         0100644 0001750 0001750 00000027424 12566241467 024141  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Syslog 3"
.TH Syslog 3 "2008-05-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unix::Syslog \- Perl interface to the UNIX syslog(3) calls
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Unix::Syslog qw(:macros);  # Syslog macros
\& use Unix::Syslog qw(:subs);    # Syslog functions
\&
\& openlog $ident, $option, $facility;
\& syslog $priority, $format, @formatargs;
\& closelog;
\& $oldmask = setlogmask $mask_priority;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface to the system logger \fBsyslogd\fR(8) via
Perl's XSUBs. The implementation attempts to resemble the native
libc-functions of your system, so that anyone being familiar with
\&\fIsyslog.h\fR should be able to use this module right away.
.PP
In contrary to \fISys::Syslog\fR\|(3), this modules does not open a network
connection to send the messages. This can help you to avoid opening
security holes in your computer (see \*(L"\s-1FAQ\s0\*(R").
.PP
The subs imported by the tag \f(CW\*(C`macros\*(C'\fR are simply wrappers around the
most important \f(CW\*(C`#defines\*(C'\fR in your system's C header file
\&\fIsyslog.h\fR. The macros return integer values that are used to specify
options, facilities and priorities in a more or less portable
way. They also provide general information about your local syslog
mechanism. Check \fIsyslog\fR\|(3) and your local \fIsyslog.h\fR for information
about the macros, options and facilities available on your system.
.PP
The following functions are provided:
.ie n .IP "openlog $ident, $option, $facility" 4
.el .IP "openlog \f(CW$ident\fR, \f(CW$option\fR, \f(CW$facility\fR" 4
.IX Item "openlog $ident, $option, $facility"
opens a connection to the system logger.  \fI\f(CI$ident\fI\fR is an identifier
string that \fBsyslogd\fR(8) prints into every message. It usually equals
the process name. \fI\f(CI$option\fI\fR is an integer value that is the result of
ORed options. \fI\f(CI$facility\fI\fR is an integer value that specifies the part
of the system the message should be associated with (e.g. kernel
message, mail subsystem).
.ie n .IP "syslog $priority, $format, @formatargs" 4
.el .IP "syslog \f(CW$priority\fR, \f(CW$format\fR, \f(CW@formatargs\fR" 4
.IX Item "syslog $priority, $format, @formatargs"
Generates a log message and passes it to the system logger. If
\&\f(CW\*(C`syslog()\*(C'\fR is called without calling \f(CW\*(C`openlog()\*(C'\fR first, probably
system dependent default values will be used as arguments for an
implicit call to \f(CW\*(C`openlog()\*(C'\fR.
.Sp
\&\fI\f(CI$priority\fI\fR is an integer value that specifies the priority of the
message. Alternatively \fI\f(CI$priority\fI\fR can be the ORed value of a
priority and a facility. In that case a previously selected facility
will be overridden.
.Sp
In the case that \f(CW\*(C`syslog()\*(C'\fR is called without calling \f(CW\*(C`openlog()\*(C'\fR
first and \fIpriority\fR does not specify both a priority \fIand\fR a
facility, a default facility will be used. This behaviour is most
likely system dependent and the user should not rely on any particular
value in that case.
.Sp
\&\fI\f(CI$format\fI\fR is a format string in the style of \fIprintf\fR\|(3). Additionally
to the usual printf directives \f(CW%m\fR can be specified in the
string. It will be replaced implicitly by the contents of the Perl
variable \f(CW$!\fR (\f(CW$ERRNO\fR). \fI\f(CI@formatargs\fI\fR is a list of values that
the format directives will be replaced with subsequently.
.IP "closelog" 4
.IX Item "closelog"
closes the connection to the system logger.
.ie n .IP "setlogmask $mask_priority" 4
.el .IP "setlogmask \f(CW$mask_priority\fR" 4
.IX Item "setlogmask $mask_priority"
sets the priority mask and returns the old mask. Logging is enabled
for the priorities indicated by the bits in the mask that are set and
is disabled where the bits are not set. Macros are provided to specify
valid and portable arguments to \f(CW\*(C`setlogmask()\*(C'\fR. Usually the default
log mask allows all messages to be logged.
.ie n .IP "priorityname $priority" 4
.el .IP "priorityname \f(CW$priority\fR" 4
.IX Item "priorityname $priority"
returns a string containing the name of \fI\f(CI$priority\fI\fR as string. If
this functionality has not been enabled at installation, the function
returns \fIundef\fR.
.ie n .IP "facilityname $facility" 4
.el .IP "facilityname \f(CW$facility\fR" 4
.IX Item "facilityname $facility"
returns a string containing the name of \fI\f(CI$facility\fI\fR as string. If
this functionality has not been enabled at installation, the function
returns \fIundef\fR.
.PP
\&\fB\s-1NOTE\s0\fR: The behaviour of this module is system dependent. It is highly
recommended to consult your system manual for available macros and the
behaviour of the provided functions.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The functions \fIopenlog()\fR, \fIsyslog()\fR and \fIcloselog()\fR return the undefined
value. The function setlogmask returns the previous mask value.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Open a channel to syslogd specifying an identifier (usually the
process name) some options and the facility:
  \f(CW\*(C`openlog "test.pl", LOG_PID | LOG_PERROR, LOG_LOCAL7;\*(C'\fR
.PP
Generate log message of specified priority using a printf-type formatted
string:
  \f(CW\*(C`syslog LOG_INFO, "This is message number %d", 42;\*(C'\fR
.PP
Set log priority mask to block all messages but those of priority
\&\f(CW\*(C`LOG_DEBUG\*(C'\fR:
  \f(CW\*(C`$oldmask = setlogmask(LOG_MASK(LOG_DEBUG))\*(C'\fR
.PP
Set log priority mask to block all messages with a higher priority than
\&\f(CW\*(C`LOG_ERR\*(C'\fR:
  \f(CW\*(C`$oldmask = setlogmask(LOG_UPTO(LOG_ERR))\*(C'\fR
.PP
Close channel to syslogd:
  \f(CW\*(C`closelog;\*(C'\fR
.SH "FAQ"
.IX Header "FAQ"
.IP "1." 4
What is the benefit of using this module instead of Sys::Syslog?
.Sp
Sys::Syslog always opens a network connection to the syslog
service. At least on Linux systems this may lead to some trouble,
because
.RS 4
.IP "\(bu" 4
Linux syslogd (from package sysklogd) does not listen to the network
by default. Most people working on stand-alone machines (including me)
didn't see any reason why to enable this option. Others didn't enable
it for security reasons.
.Sp
OS-independent, some sysadmins may run a firewall on their network
that blocks connections to port 514/udp.
.IP "\(bu" 4
By default Linux syslogd doesn't forward messages which have already
already received from the network to other log hosts. There are
reasons not to enable this option unless it is really
necessary. Looping messages resulting from a misconfiguration may
break down your (log\-)system.
.RE
.RS 4
.Sp
Peter Stamfest <peter.stamfest@eunet.at> pointed out some other
advantages of Unix::Syslog, I didn't came across my self.
.IP "\(bu" 4
\&\s-1LOG_PERROR\s0 works.
.IP "\(bu" 4
works with perl \-Tw without warnings and problems due to tainted data
as it is the case for Sys::Syslog in some special
applications. [Especially when running a script as root]
.RE
.RS 4
.RE
.IP "2." 4
Well, is there any reason to use Sys::Syslog any longer?
.Sp
Yes! In contrary to Unix::Syslog, Sys::Syslog works even if you don't
have a syslog daemon running on your system as long as you are
connected to a log host via a network and have access to the
\&\fIsyslog.h\fR header file of your log host to generate the initial files
for Sys::Syslog (see \fISys::Syslog\fR\|(3) for details). Unix::Syslog only logs
to your local syslog daemon which in turn may be configured to
distribute the message over the network.
.IP "3." 4
Are calls to the functions provided by Unix::Syslog compatible to those
of Sys::Syslog?
.Sp
Currently not. Sys::Syslog requires strings to specify many of the
arguments to the functions, while Unix::Syslog uses numeric constants
accessed via macros as defined in \fIsyslog.h\fR. Although the strings
used by Sys::Syslog are also defined in \fIsyslog.h\fR, it seems that most
people got used to the numeric arguments. I will implement the string
based calls if there are enough people (\fI\f(CI$min_people\fI\fR > 10**40)
complaining about the lack of compatibility.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIsyslog\fR\|(3), \fISys::Syslog\fR\|(3), \fIsyslogd\fR\|(8), \fIperl\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Marcus Harnisch <marcus.harnisch@gmx.net>
                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Unix::Syslog5.18.3pm                         0100644 0001750 0001750 00000027745 12566241467 024151  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Syslog 3"
.TH Syslog 3 "2008-05-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Unix::Syslog \- Perl interface to the UNIX syslog(3) calls
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Unix::Syslog qw(:macros);  # Syslog macros
\& use Unix::Syslog qw(:subs);    # Syslog functions
\&
\& openlog $ident, $option, $facility;
\& syslog $priority, $format, @formatargs;
\& closelog;
\& $oldmask = setlogmask $mask_priority;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface to the system logger \fBsyslogd\fR(8) via
Perl's XSUBs. The implementation attempts to resemble the native
libc-functions of your system, so that anyone being familiar with
\&\fIsyslog.h\fR should be able to use this module right away.
.PP
In contrary to \fISys::Syslog\fR\|(3), this modules does not open a network
connection to send the messages. This can help you to avoid opening
security holes in your computer (see \*(L"\s-1FAQ\*(R"\s0).
.PP
The subs imported by the tag \f(CW\*(C`macros\*(C'\fR are simply wrappers around the
most important \f(CW\*(C`#defines\*(C'\fR in your system's C header file
\&\fIsyslog.h\fR. The macros return integer values that are used to specify
options, facilities and priorities in a more or less portable
way. They also provide general information about your local syslog
mechanism. Check \fIsyslog\fR\|(3) and your local \fIsyslog.h\fR for information
about the macros, options and facilities available on your system.
.PP
The following functions are provided:
.ie n .IP "openlog $ident, $option, $facility" 4
.el .IP "openlog \f(CW$ident\fR, \f(CW$option\fR, \f(CW$facility\fR" 4
.IX Item "openlog $ident, $option, $facility"
opens a connection to the system logger.  \fI\f(CI$ident\fI\fR is an identifier
string that \fBsyslogd\fR(8) prints into every message. It usually equals
the process name. \fI\f(CI$option\fI\fR is an integer value that is the result of
ORed options. \fI\f(CI$facility\fI\fR is an integer value that specifies the part
of the system the message should be associated with (e.g. kernel
message, mail subsystem).
.ie n .IP "syslog $priority, $format, @formatargs" 4
.el .IP "syslog \f(CW$priority\fR, \f(CW$format\fR, \f(CW@formatargs\fR" 4
.IX Item "syslog $priority, $format, @formatargs"
Generates a log message and passes it to the system logger. If
\&\f(CW\*(C`syslog()\*(C'\fR is called without calling \f(CW\*(C`openlog()\*(C'\fR first, probably
system dependent default values will be used as arguments for an
implicit call to \f(CW\*(C`openlog()\*(C'\fR.
.Sp
\&\fI\f(CI$priority\fI\fR is an integer value that specifies the priority of the
message. Alternatively \fI\f(CI$priority\fI\fR can be the ORed value of a
priority and a facility. In that case a previously selected facility
will be overridden.
.Sp
In the case that \f(CW\*(C`syslog()\*(C'\fR is called without calling \f(CW\*(C`openlog()\*(C'\fR
first and \fIpriority\fR does not specify both a priority \fIand\fR a
facility, a default facility will be used. This behaviour is most
likely system dependent and the user should not rely on any particular
value in that case.
.Sp
\&\fI\f(CI$format\fI\fR is a format string in the style of \fIprintf\fR\|(3). Additionally
to the usual printf directives \f(CW%m\fR can be specified in the
string. It will be replaced implicitly by the contents of the Perl
variable \f(CW$!\fR (\f(CW$ERRNO\fR). \fI\f(CI@formatargs\fI\fR is a list of values that
the format directives will be replaced with subsequently.
.IP "closelog" 4
.IX Item "closelog"
closes the connection to the system logger.
.ie n .IP "setlogmask $mask_priority" 4
.el .IP "setlogmask \f(CW$mask_priority\fR" 4
.IX Item "setlogmask $mask_priority"
sets the priority mask and returns the old mask. Logging is enabled
for the priorities indicated by the bits in the mask that are set and
is disabled where the bits are not set. Macros are provided to specify
valid and portable arguments to \f(CW\*(C`setlogmask()\*(C'\fR. Usually the default
log mask allows all messages to be logged.
.ie n .IP "priorityname $priority" 4
.el .IP "priorityname \f(CW$priority\fR" 4
.IX Item "priorityname $priority"
returns a string containing the name of \fI\f(CI$priority\fI\fR as string. If
this functionality has not been enabled at installation, the function
returns \fIundef\fR.
.ie n .IP "facilityname $facility" 4
.el .IP "facilityname \f(CW$facility\fR" 4
.IX Item "facilityname $facility"
returns a string containing the name of \fI\f(CI$facility\fI\fR as string. If
this functionality has not been enabled at installation, the function
returns \fIundef\fR.
.PP
\&\fB\s-1NOTE\s0\fR: The behaviour of this module is system dependent. It is highly
recommended to consult your system manual for available macros and the
behaviour of the provided functions.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The functions \fIopenlog()\fR, \fIsyslog()\fR and \fIcloselog()\fR return the undefined
value. The function setlogmask returns the previous mask value.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Open a channel to syslogd specifying an identifier (usually the
process name) some options and the facility:
  \f(CW\*(C`openlog "test.pl", LOG_PID | LOG_PERROR, LOG_LOCAL7;\*(C'\fR
.PP
Generate log message of specified priority using a printf-type formatted
string:
  \f(CW\*(C`syslog LOG_INFO, "This is message number %d", 42;\*(C'\fR
.PP
Set log priority mask to block all messages but those of priority
\&\f(CW\*(C`LOG_DEBUG\*(C'\fR:
  \f(CW\*(C`$oldmask = setlogmask(LOG_MASK(LOG_DEBUG))\*(C'\fR
.PP
Set log priority mask to block all messages with a higher priority than
\&\f(CW\*(C`LOG_ERR\*(C'\fR:
  \f(CW\*(C`$oldmask = setlogmask(LOG_UPTO(LOG_ERR))\*(C'\fR
.PP
Close channel to syslogd:
  \f(CW\*(C`closelog;\*(C'\fR
.SH "FAQ"
.IX Header "FAQ"
.IP "1." 4
What is the benefit of using this module instead of Sys::Syslog?
.Sp
Sys::Syslog always opens a network connection to the syslog
service. At least on Linux systems this may lead to some trouble,
because
.RS 4
.IP "\(bu" 4
Linux syslogd (from package sysklogd) does not listen to the network
by default. Most people working on stand-alone machines (including me)
didn't see any reason why to enable this option. Others didn't enable
it for security reasons.
.Sp
OS-independent, some sysadmins may run a firewall on their network
that blocks connections to port 514/udp.
.IP "\(bu" 4
By default Linux syslogd doesn't forward messages which have already
already received from the network to other log hosts. There are
reasons not to enable this option unless it is really
necessary. Looping messages resulting from a misconfiguration may
break down your (log\-)system.
.RE
.RS 4
.Sp
Peter Stamfest <peter.stamfest@eunet.at> pointed out some other
advantages of Unix::Syslog, I didn't came across my self.
.IP "\(bu" 4
\&\s-1LOG_PERROR\s0 works.
.IP "\(bu" 4
works with perl \-Tw without warnings and problems due to tainted data
as it is the case for Sys::Syslog in some special
applications. [Especially when running a script as root]
.RE
.RS 4
.RE
.IP "2." 4
Well, is there any reason to use Sys::Syslog any longer?
.Sp
Yes! In contrary to Unix::Syslog, Sys::Syslog works even if you don't
have a syslog daemon running on your system as long as you are
connected to a log host via a network and have access to the
\&\fIsyslog.h\fR header file of your log host to generate the initial files
for Sys::Syslog (see \fISys::Syslog\fR\|(3) for details). Unix::Syslog only logs
to your local syslog daemon which in turn may be configured to
distribute the message over the network.
.IP "3." 4
Are calls to the functions provided by Unix::Syslog compatible to those
of Sys::Syslog?
.Sp
Currently not. Sys::Syslog requires strings to specify many of the
arguments to the functions, while Unix::Syslog uses numeric constants
accessed via macros as defined in \fIsyslog.h\fR. Although the strings
used by Sys::Syslog are also defined in \fIsyslog.h\fR, it seems that most
people got used to the numeric arguments. I will implement the string
based calls if there are enough people (\fI\f(CI$min_people\fI\fR > 10**40)
complaining about the lack of compatibility.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIsyslog\fR\|(3), \fISys::Syslog\fR\|(3), \fIsyslogd\fR\|(8), \fIperl\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Marcus Harnisch <marcus.harnisch@gmx.net>
                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/User::grent.3pm                              0100644 0001750 0001750 00000014040 12566207464 023446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::grent 3pm"
.TH User::grent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::grent \- by\-name interface to Perl's built\-in getgr*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use User::grent;
\& $gr = getgrgid(0) or die "No group zero";
\& if ( $gr\->name eq \*(Aqwheel\*(Aq && @{$gr\->members} > 1 ) {
\&     print "gid zero name wheel, with other members";
\& } 
\&
\& use User::grent qw(:FIELDS);
\& getgrgid(0) or die "No group zero";
\& if ( $gr_name eq \*(Aqwheel\*(Aq && @gr_members > 1 ) {
\&     print "gid zero name wheel, with other members";
\& } 
\&
\& $gr = getgr($whoever);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetgrent()\fR, \fIgetgruid()\fR,
and \fIgetgrnam()\fR functions, replacing them with versions that return
\&\*(L"User::grent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's passwd structure from \fIgrp.h\fR; 
namely name, passwd, gid, and members (not mem).  The first three
return scalars, the last an array reference.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`gr_\*(C'\fR.  Thus, \f(CW\*(C`$group_obj\->gid()\*(C'\fR corresponds
to \f(CW$gr_gid\fR if you import the fields.  Array references are available as
regular array variables, so \f(CW\*(C`@{ $group_obj\->members() }\*(C'\fR would be
simply \f(CW@gr_members\fR.
.PP
The \fIgetpw()\fR function is a simple front-end that forwards
a numeric argument to \fIgetpwuid()\fR and the rest to \fIgetpwnam()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/User::grent5.16.3pm                          0100644 0001750 0001750 00000013517 12566207442 023764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::grent 3pm"
.TH User::grent 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::grent \- by\-name interface to Perl's built\-in getgr*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use User::grent;
\& $gr = getgrgid(0) or die "No group zero";
\& if ( $gr\->name eq \*(Aqwheel\*(Aq && @{$gr\->members} > 1 ) {
\&     print "gid zero name wheel, with other members";
\& } 
\&
\& use User::grent qw(:FIELDS);
\& getgrgid(0) or die "No group zero";
\& if ( $gr_name eq \*(Aqwheel\*(Aq && @gr_members > 1 ) {
\&     print "gid zero name wheel, with other members";
\& } 
\&
\& $gr = getgr($whoever);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetgrent()\fR, \fIgetgruid()\fR,
and \fIgetgrnam()\fR functions, replacing them with versions that return
\&\*(L"User::grent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's passwd structure from \fIgrp.h\fR; 
namely name, passwd, gid, and members (not mem).  The first three
return scalars, the last an array reference.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`gr_\*(C'\fR.  Thus, \f(CW\*(C`$group_obj\->gid()\*(C'\fR corresponds
to \f(CW$gr_gid\fR if you import the fields.  Array references are available as
regular array variables, so \f(CW\*(C`@{ $group_obj\->members() }\*(C'\fR would be
simply \f(CW@gr_members\fR.
.PP
The \fIgetpw()\fR function is a simple front-end that forwards
a numeric argument to \fIgetpwuid()\fR and the rest to \fIgetpwnam()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/User::grent5.18.3pm                          0100644 0001750 0001750 00000014040 12566207464 023762  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::grent 3pm"
.TH User::grent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::grent \- by\-name interface to Perl's built\-in getgr*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use User::grent;
\& $gr = getgrgid(0) or die "No group zero";
\& if ( $gr\->name eq \*(Aqwheel\*(Aq && @{$gr\->members} > 1 ) {
\&     print "gid zero name wheel, with other members";
\& } 
\&
\& use User::grent qw(:FIELDS);
\& getgrgid(0) or die "No group zero";
\& if ( $gr_name eq \*(Aqwheel\*(Aq && @gr_members > 1 ) {
\&     print "gid zero name wheel, with other members";
\& } 
\&
\& $gr = getgr($whoever);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetgrent()\fR, \fIgetgruid()\fR,
and \fIgetgrnam()\fR functions, replacing them with versions that return
\&\*(L"User::grent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's passwd structure from \fIgrp.h\fR; 
namely name, passwd, gid, and members (not mem).  The first three
return scalars, the last an array reference.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`gr_\*(C'\fR.  Thus, \f(CW\*(C`$group_obj\->gid()\*(C'\fR corresponds
to \f(CW$gr_gid\fR if you import the fields.  Array references are available as
regular array variables, so \f(CW\*(C`@{ $group_obj\->members() }\*(C'\fR would be
simply \f(CW@gr_members\fR.
.PP
The \fIgetpw()\fR function is a simple front-end that forwards
a numeric argument to \fIgetpwuid()\fR and the rest to \fIgetpwnam()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/User::pwent.3pm                              0100644 0001750 0001750 00000022237 12566207464 023473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::pwent 3pm"
.TH User::pwent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::pwent \- by\-name interface to Perl's built\-in getpw*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use User::pwent;
\& $pw = getpwnam(\*(Aqdaemon\*(Aq)       || die "No daemon user";
\& if ( $pw\->uid == 1 && $pw\->dir =~ m#^/(bin|tmp)?\ez#s ) {
\&     print "gid 1 on root dir";
\& }
\&
\& $real_shell = $pw\->shell || \*(Aq/bin/sh\*(Aq;
\&
\& for (($fullname, $office, $workphone, $homephone) =
\&        split /\es*,\es*/, $pw\->gecos)
\& {
\&    s/&/ucfirst(lc($pw\->name))/ge;
\& }
\&
\& use User::pwent qw(:FIELDS);
\& getpwnam(\*(Aqdaemon\*(Aq)             || die "No daemon user";
\& if ( $pw_uid == 1 && $pw_dir =~ m#^/(bin|tmp)?\ez#s ) {
\&     print "gid 1 on root dir";
\& }
\&
\& $pw = getpw($whoever);
\&
\& use User::pwent qw/:DEFAULT pw_has/;
\& if (pw_has(qw[gecos expire quota])) { .... }
\& if (pw_has("name uid gid passwd"))  { .... }
\& print "Your struct pwd has: ", scalar pw_has(), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetpwent()\fR, \fIgetpwuid()\fR,
and \fIgetpwnam()\fR functions, replacing them with versions that return
\&\f(CW\*(C`User::pwent\*(C'\fR objects.  This object has methods that return the
similarly named structure field name from the C's passwd structure
from \fIpwd.h\fR, stripped of their leading \*(L"pw_\*(R" parts, namely \f(CW\*(C`name\*(C'\fR,
\&\f(CW\*(C`passwd\*(C'\fR, \f(CW\*(C`uid\*(C'\fR, \f(CW\*(C`gid\*(C'\fR, \f(CW\*(C`change\*(C'\fR, \f(CW\*(C`age\*(C'\fR, \f(CW\*(C`quota\*(C'\fR, \f(CW\*(C`comment\*(C'\fR,
\&\f(CW\*(C`class\*(C'\fR, \f(CW\*(C`gecos\*(C'\fR, \f(CW\*(C`dir\*(C'\fR, \f(CW\*(C`shell\*(C'\fR, and \f(CW\*(C`expire\*(C'\fR.  The \f(CW\*(C`passwd\*(C'\fR,
\&\f(CW\*(C`gecos\*(C'\fR, and \f(CW\*(C`shell\*(C'\fR fields are tainted when running in taint mode.
.PP
You may also import all the structure fields directly into your
namespace as regular variables using the :FIELDS import tag.  (Note
that this still overrides your core functions.)  Access these fields
as variables named with a preceding \f(CW\*(C`pw_\*(C'\fR in front their method
names.  Thus, \f(CW\*(C`$passwd_obj\->shell\*(C'\fR corresponds to \f(CW$pw_shell\fR
if you import the fields.
.PP
The \fIgetpw()\fR function is a simple front-end that forwards
a numeric argument to \fIgetpwuid()\fR and the rest to \fIgetpwnam()\fR.
.PP
To access this functionality without the core overrides, pass the
\&\f(CW\*(C`use\*(C'\fR an empty import list, and then access function functions
with their full qualified names.  The built-ins are always still
available via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SS "System Specifics"
.IX Subsection "System Specifics"
Perl believes that no machine ever has more than one of \f(CW\*(C`change\*(C'\fR,
\&\f(CW\*(C`age\*(C'\fR, or \f(CW\*(C`quota\*(C'\fR implemented, nor more than one of either
\&\f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`class\*(C'\fR.  Some machines do not support \f(CW\*(C`expire\*(C'\fR,
\&\f(CW\*(C`gecos\*(C'\fR, or allegedly, \f(CW\*(C`passwd\*(C'\fR.  You may call these methods
no matter what machine you're on, but they return \f(CW\*(C`undef\*(C'\fR if
unimplemented.
.PP
You may ask whether one of these was implemented on the system Perl
was built on by asking the importable \f(CW\*(C`pw_has\*(C'\fR function about them.
This function returns true if all parameters are supported fields
on the build platform, false if one or more were not, and raises
an exception if you asked about a field that Perl never knows how
to provide.  Parameters may be in a space-separated string, or as
separate arguments.  If you pass no parameters, the function returns
the list of \f(CW\*(C`struct pwd\*(C'\fR fields supported by your build platform's
C library, as a list in list context, or a space-separated string
in scalar context.  Note that just because your C library had
a field doesn't necessarily mean that it's fully implemented on
that system.
.PP
Interpretation of the \f(CW\*(C`gecos\*(C'\fR field varies between systems, but
traditionally holds 4 comma-separated fields containing the user's
full name, office location, work phone number, and home phone number.
An \f(CW\*(C`&\*(C'\fR in the gecos field should be replaced by the user's properly
capitalized login \f(CW\*(C`name\*(C'\fR.  The \f(CW\*(C`shell\*(C'\fR field, if blank, must be
assumed to be \fI/bin/sh\fR.  Perl does not do this for you.  The
\&\f(CW\*(C`passwd\*(C'\fR is one-way hashed garble, not clear text, and may not be
unhashed save by brute-force guessing.  Secure systems use more a
more secure hashing than \s-1DES. \s0 On systems supporting shadow password
systems, Perl automatically returns the shadow password entry when
called by a suitably empowered user, even if your underlying
vendor-provided C library was too short-sighted to realize it should
do this.
.PP
See \fIpasswd\fR\|(5) and \fIgetpwent\fR\|(3) for details.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
.SH "HISTORY"
.IX Header "HISTORY"
.IP "March 18th, 2000" 4
.IX Item "March 18th, 2000"
Reworked internals to support better interface to dodgey fields
than normal Perl function provides.  Added \fIpw_has()\fR field.  Improved
documentation.
                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/User::pwent5.16.3pm                          0100644 0001750 0001750 00000021716 12566207442 024002  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::pwent 3pm"
.TH User::pwent 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::pwent \- by\-name interface to Perl's built\-in getpw*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use User::pwent;
\& $pw = getpwnam(\*(Aqdaemon\*(Aq)       || die "No daemon user";
\& if ( $pw\->uid == 1 && $pw\->dir =~ m#^/(bin|tmp)?\ez#s ) {
\&     print "gid 1 on root dir";
\& }
\&
\& $real_shell = $pw\->shell || \*(Aq/bin/sh\*(Aq;
\&
\& for (($fullname, $office, $workphone, $homephone) =
\&        split /\es*,\es*/, $pw\->gecos)
\& {
\&    s/&/ucfirst(lc($pw\->name))/ge;
\& }
\&
\& use User::pwent qw(:FIELDS);
\& getpwnam(\*(Aqdaemon\*(Aq)             || die "No daemon user";
\& if ( $pw_uid == 1 && $pw_dir =~ m#^/(bin|tmp)?\ez#s ) {
\&     print "gid 1 on root dir";
\& }
\&
\& $pw = getpw($whoever);
\&
\& use User::pwent qw/:DEFAULT pw_has/;
\& if (pw_has(qw[gecos expire quota])) { .... }
\& if (pw_has("name uid gid passwd"))  { .... }
\& print "Your struct pwd has: ", scalar pw_has(), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetpwent()\fR, \fIgetpwuid()\fR,
and \fIgetpwnam()\fR functions, replacing them with versions that return
\&\f(CW\*(C`User::pwent\*(C'\fR objects.  This object has methods that return the
similarly named structure field name from the C's passwd structure
from \fIpwd.h\fR, stripped of their leading \*(L"pw_\*(R" parts, namely \f(CW\*(C`name\*(C'\fR,
\&\f(CW\*(C`passwd\*(C'\fR, \f(CW\*(C`uid\*(C'\fR, \f(CW\*(C`gid\*(C'\fR, \f(CW\*(C`change\*(C'\fR, \f(CW\*(C`age\*(C'\fR, \f(CW\*(C`quota\*(C'\fR, \f(CW\*(C`comment\*(C'\fR,
\&\f(CW\*(C`class\*(C'\fR, \f(CW\*(C`gecos\*(C'\fR, \f(CW\*(C`dir\*(C'\fR, \f(CW\*(C`shell\*(C'\fR, and \f(CW\*(C`expire\*(C'\fR.  The \f(CW\*(C`passwd\*(C'\fR,
\&\f(CW\*(C`gecos\*(C'\fR, and \f(CW\*(C`shell\*(C'\fR fields are tainted when running in taint mode.
.PP
You may also import all the structure fields directly into your
namespace as regular variables using the :FIELDS import tag.  (Note
that this still overrides your core functions.)  Access these fields
as variables named with a preceding \f(CW\*(C`pw_\*(C'\fR in front their method
names.  Thus, \f(CW\*(C`$passwd_obj\->shell\*(C'\fR corresponds to \f(CW$pw_shell\fR
if you import the fields.
.PP
The \fIgetpw()\fR function is a simple front-end that forwards
a numeric argument to \fIgetpwuid()\fR and the rest to \fIgetpwnam()\fR.
.PP
To access this functionality without the core overrides, pass the
\&\f(CW\*(C`use\*(C'\fR an empty import list, and then access function functions
with their full qualified names.  The built-ins are always still
available via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SS "System Specifics"
.IX Subsection "System Specifics"
Perl believes that no machine ever has more than one of \f(CW\*(C`change\*(C'\fR,
\&\f(CW\*(C`age\*(C'\fR, or \f(CW\*(C`quota\*(C'\fR implemented, nor more than one of either
\&\f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`class\*(C'\fR.  Some machines do not support \f(CW\*(C`expire\*(C'\fR,
\&\f(CW\*(C`gecos\*(C'\fR, or allegedly, \f(CW\*(C`passwd\*(C'\fR.  You may call these methods
no matter what machine you're on, but they return \f(CW\*(C`undef\*(C'\fR if
unimplemented.
.PP
You may ask whether one of these was implemented on the system Perl
was built on by asking the importable \f(CW\*(C`pw_has\*(C'\fR function about them.
This function returns true if all parameters are supported fields
on the build platform, false if one or more were not, and raises
an exception if you asked about a field that Perl never knows how
to provide.  Parameters may be in a space-separated string, or as
separate arguments.  If you pass no parameters, the function returns
the list of \f(CW\*(C`struct pwd\*(C'\fR fields supported by your build platform's
C library, as a list in list context, or a space-separated string
in scalar context.  Note that just because your C library had
a field doesn't necessarily mean that it's fully implemented on
that system.
.PP
Interpretation of the \f(CW\*(C`gecos\*(C'\fR field varies between systems, but
traditionally holds 4 comma-separated fields containing the user's
full name, office location, work phone number, and home phone number.
An \f(CW\*(C`&\*(C'\fR in the gecos field should be replaced by the user's properly
capitalized login \f(CW\*(C`name\*(C'\fR.  The \f(CW\*(C`shell\*(C'\fR field, if blank, must be
assumed to be \fI/bin/sh\fR.  Perl does not do this for you.  The
\&\f(CW\*(C`passwd\*(C'\fR is one-way hashed garble, not clear text, and may not be
unhashed save by brute-force guessing.  Secure systems use more a
more secure hashing than \s-1DES\s0.  On systems supporting shadow password
systems, Perl automatically returns the shadow password entry when
called by a suitably empowered user, even if your underlying
vendor-provided C library was too short-sighted to realize it should
do this.
.PP
See \fIpasswd\fR\|(5) and \fIgetpwent\fR\|(3) for details.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
.SH "HISTORY"
.IX Header "HISTORY"
.IP "March 18th, 2000" 4
.IX Item "March 18th, 2000"
Reworked internals to support better interface to dodgey fields
than normal Perl function provides.  Added \fIpw_has()\fR field.  Improved
documentation.
                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/User::pwent5.18.3pm                          0100644 0001750 0001750 00000022237 12566207464 024007  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "User::pwent 3pm"
.TH User::pwent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::pwent \- by\-name interface to Perl's built\-in getpw*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use User::pwent;
\& $pw = getpwnam(\*(Aqdaemon\*(Aq)       || die "No daemon user";
\& if ( $pw\->uid == 1 && $pw\->dir =~ m#^/(bin|tmp)?\ez#s ) {
\&     print "gid 1 on root dir";
\& }
\&
\& $real_shell = $pw\->shell || \*(Aq/bin/sh\*(Aq;
\&
\& for (($fullname, $office, $workphone, $homephone) =
\&        split /\es*,\es*/, $pw\->gecos)
\& {
\&    s/&/ucfirst(lc($pw\->name))/ge;
\& }
\&
\& use User::pwent qw(:FIELDS);
\& getpwnam(\*(Aqdaemon\*(Aq)             || die "No daemon user";
\& if ( $pw_uid == 1 && $pw_dir =~ m#^/(bin|tmp)?\ez#s ) {
\&     print "gid 1 on root dir";
\& }
\&
\& $pw = getpw($whoever);
\&
\& use User::pwent qw/:DEFAULT pw_has/;
\& if (pw_has(qw[gecos expire quota])) { .... }
\& if (pw_has("name uid gid passwd"))  { .... }
\& print "Your struct pwd has: ", scalar pw_has(), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetpwent()\fR, \fIgetpwuid()\fR,
and \fIgetpwnam()\fR functions, replacing them with versions that return
\&\f(CW\*(C`User::pwent\*(C'\fR objects.  This object has methods that return the
similarly named structure field name from the C's passwd structure
from \fIpwd.h\fR, stripped of their leading \*(L"pw_\*(R" parts, namely \f(CW\*(C`name\*(C'\fR,
\&\f(CW\*(C`passwd\*(C'\fR, \f(CW\*(C`uid\*(C'\fR, \f(CW\*(C`gid\*(C'\fR, \f(CW\*(C`change\*(C'\fR, \f(CW\*(C`age\*(C'\fR, \f(CW\*(C`quota\*(C'\fR, \f(CW\*(C`comment\*(C'\fR,
\&\f(CW\*(C`class\*(C'\fR, \f(CW\*(C`gecos\*(C'\fR, \f(CW\*(C`dir\*(C'\fR, \f(CW\*(C`shell\*(C'\fR, and \f(CW\*(C`expire\*(C'\fR.  The \f(CW\*(C`passwd\*(C'\fR,
\&\f(CW\*(C`gecos\*(C'\fR, and \f(CW\*(C`shell\*(C'\fR fields are tainted when running in taint mode.
.PP
You may also import all the structure fields directly into your
namespace as regular variables using the :FIELDS import tag.  (Note
that this still overrides your core functions.)  Access these fields
as variables named with a preceding \f(CW\*(C`pw_\*(C'\fR in front their method
names.  Thus, \f(CW\*(C`$passwd_obj\->shell\*(C'\fR corresponds to \f(CW$pw_shell\fR
if you import the fields.
.PP
The \fIgetpw()\fR function is a simple front-end that forwards
a numeric argument to \fIgetpwuid()\fR and the rest to \fIgetpwnam()\fR.
.PP
To access this functionality without the core overrides, pass the
\&\f(CW\*(C`use\*(C'\fR an empty import list, and then access function functions
with their full qualified names.  The built-ins are always still
available via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SS "System Specifics"
.IX Subsection "System Specifics"
Perl believes that no machine ever has more than one of \f(CW\*(C`change\*(C'\fR,
\&\f(CW\*(C`age\*(C'\fR, or \f(CW\*(C`quota\*(C'\fR implemented, nor more than one of either
\&\f(CW\*(C`comment\*(C'\fR or \f(CW\*(C`class\*(C'\fR.  Some machines do not support \f(CW\*(C`expire\*(C'\fR,
\&\f(CW\*(C`gecos\*(C'\fR, or allegedly, \f(CW\*(C`passwd\*(C'\fR.  You may call these methods
no matter what machine you're on, but they return \f(CW\*(C`undef\*(C'\fR if
unimplemented.
.PP
You may ask whether one of these was implemented on the system Perl
was built on by asking the importable \f(CW\*(C`pw_has\*(C'\fR function about them.
This function returns true if all parameters are supported fields
on the build platform, false if one or more were not, and raises
an exception if you asked about a field that Perl never knows how
to provide.  Parameters may be in a space-separated string, or as
separate arguments.  If you pass no parameters, the function returns
the list of \f(CW\*(C`struct pwd\*(C'\fR fields supported by your build platform's
C library, as a list in list context, or a space-separated string
in scalar context.  Note that just because your C library had
a field doesn't necessarily mean that it's fully implemented on
that system.
.PP
Interpretation of the \f(CW\*(C`gecos\*(C'\fR field varies between systems, but
traditionally holds 4 comma-separated fields containing the user's
full name, office location, work phone number, and home phone number.
An \f(CW\*(C`&\*(C'\fR in the gecos field should be replaced by the user's properly
capitalized login \f(CW\*(C`name\*(C'\fR.  The \f(CW\*(C`shell\*(C'\fR field, if blank, must be
assumed to be \fI/bin/sh\fR.  Perl does not do this for you.  The
\&\f(CW\*(C`passwd\*(C'\fR is one-way hashed garble, not clear text, and may not be
unhashed save by brute-force guessing.  Secure systems use more a
more secure hashing than \s-1DES. \s0 On systems supporting shadow password
systems, Perl automatically returns the shadow password entry when
called by a suitably empowered user, even if your underlying
vendor-provided C library was too short-sighted to realize it should
do this.
.PP
See \fIpasswd\fR\|(5) and \fIgetpwent\fR\|(3) for details.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
.SH "HISTORY"
.IX Header "HISTORY"
.IP "March 18th, 2000" 4
.IX Item "March 18th, 2000"
Reworked internals to support better interface to dodgey fields
than normal Perl function provides.  Added \fIpw_has()\fR field.  Improved
documentation.
                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Variable::Magic.3pm                          0100644 0001750 0001750 00000070166 12566242326 024165  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Variable::Magic 3"
.TH Variable::Magic 3 "2013-09-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Variable::Magic \- Associate user\-defined magic to variables from Perl.
.SH "VERSION"
.IX Header "VERSION"
Version 0.53
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Variable::Magic qw<wizard cast VMG_OP_INFO_NAME>;
\&
\&    { # A variable tracer
\&     my $wiz = wizard(
\&      set  => sub { print "now set to ${$_[0]}!\en" },
\&      free => sub { print "destroyed!\en" },
\&     );
\&
\&     my $a = 1;
\&     cast $a, $wiz;
\&     $a = 2;        # "now set to 2!"
\&    }               # "destroyed!"
\&
\&    { # A hash with a default value
\&     my $wiz = wizard(
\&      data     => sub { $_[1] },
\&      fetch    => sub { $_[2] = $_[1] unless exists $_[0]\->{$_[2]}; () },
\&      store    => sub { print "key $_[2] stored in $_[\-1]\en" },
\&      copy_key => 1,
\&      op_info  => VMG_OP_INFO_NAME,
\&     );
\&
\&     my %h = (_default => 0, apple => 2);
\&     cast %h, $wiz, \*(Aq_default\*(Aq;
\&     print $h{banana}, "\en"; # "0" (there is no \*(Aqbanana\*(Aq key in %h)
\&     $h{pear} = 1;           # "key pear stored in helem"
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Magic is Perl's way of enhancing variables.
This mechanism lets the user add extra data to any variable and hook syntactical operations (such as access, assignment or destruction) that can be applied to it.
With this module, you can add your own magic to any variable without having to write a single line of \s-1XS.\s0
.PP
You'll realize that these magic variables look a lot like tied variables.
It is not surprising, as tied variables are implemented as a special kind of magic, just like any 'irregular' Perl variable : scalars like \f(CW$!\fR, \f(CW$(\fR or \f(CW$^W\fR, the \f(CW%ENV\fR and \f(CW%SIG\fR hashes, the \f(CW@ISA\fR array,  \f(CW\*(C`vec()\*(C'\fR and \f(CW\*(C`substr()\*(C'\fR lvalues, threads::shared variables...
They all share the same underlying C \s-1API,\s0 and this module gives you direct access to it.
.PP
Still, the magic made available by this module differs from tieing and overloading in several ways :
.IP "\(bu" 4
Magic is not copied on assignment.
.Sp
You attach it to variables, not values (as for blessed references).
.IP "\(bu" 4
Magic does not replace the original semantics.
.Sp
Magic callbacks usually get triggered before the original action takes place, and cannot prevent it from happening.
This also makes catching individual events easier than with \f(CW\*(C`tie\*(C'\fR, where you have to provide fallbacks methods for all actions by usually inheriting from the correct \f(CW\*(C`Tie::Std*\*(C'\fR class and overriding individual methods in your own class.
.IP "\(bu" 4
Magic is multivalued.
.Sp
You can safely apply different kinds of magics to the same variable, and each of them will be invoked successively.
.IP "\(bu" 4
Magic is type-agnostic.
.Sp
The same magic can be applied on scalars, arrays, hashes, subs or globs.
But the same hook (see below for a list) may trigger differently depending on the type of the variable.
.IP "\(bu" 4
Magic is invisible at Perl level.
.Sp
Magical and non-magical variables cannot be distinguished with \f(CW\*(C`ref\*(C'\fR, \f(CW\*(C`tied\*(C'\fR or another trick.
.IP "\(bu" 4
Magic is notably faster.
.Sp
Mainly because perl's way of handling magic is lighter by nature, and because there is no need for any method resolution.
Also, since you don't have to reimplement all the variable semantics, you only pay for what you actually use.
.PP
The operations that can be overloaded are :
.IP "\(bu" 4
\&\fIget\fR
.Sp
This magic is invoked when the variable is evaluated.
It is never called for arrays and hashes.
.IP "\(bu" 4
\&\fIset\fR
.Sp
This magic is called each time the value of the variable changes.
It is called for array subscripts and slices, but never for hashes.
.IP "\(bu" 4
\&\fIlen\fR
.Sp
This magic only applies to arrays (though it used to also apply to scalars), and is triggered when the 'size' or the 'length' of the variable has to be known by Perl.
This is typically the magic involved when an array is evaluated in scalar context, but also on array assignment and loops (\f(CW\*(C`for\*(C'\fR, \f(CW\*(C`map\*(C'\fR or \f(CW\*(C`grep\*(C'\fR).
The length is returned from the callback as an integer.
.Sp
Starting from perl 5.12, this magic is no longer called by the \f(CW\*(C`length\*(C'\fR keyword, and starting from perl 5.17.4 it is also no longer called for scalars in any situation, making this magic only meaningful on arrays.
You can use the constants \*(L"\s-1VMG_COMPAT_SCALAR_LENGTH_NOLEN\*(R"\s0 and \*(L"\s-1VMG_COMPAT_SCALAR_NOLEN\*(R"\s0 to see if this magic is available for scalars or not.
.IP "\(bu" 4
\&\fIclear\fR
.Sp
This magic is invoked when the variable is reset, such as when an array is emptied.
Please note that this is different from undefining the variable, even though the magic is called when the clearing is a result of the undefine (e.g. for an array, but actually a bug prevent it to work before perl 5.9.5 \- see the history).
.IP "\(bu" 4
\&\fIfree\fR
.Sp
This magic is called when a variable is destroyed as the result of going out of scope (but not when it is undefined).
It behaves roughly like Perl object destructors (i.e. \f(CW\*(C`DESTROY\*(C'\fR methods), except that exceptions thrown from inside a \fIfree\fR callback will always be propagated to the surrounding code.
.IP "\(bu" 4
\&\fIcopy\fR
.Sp
This magic only applies to tied arrays and hashes, and fires when you try to access or change their elements.
.IP "\(bu" 4
\&\fIdup\fR
.Sp
This magic is invoked when the variable is cloned across threads.
It is currently not available.
.IP "\(bu" 4
\&\fIlocal\fR
.Sp
When this magic is set on a variable, all subsequent localizations of the variable will trigger the callback.
It is available on your perl if and only if \f(CW\*(C`MGf_LOCAL\*(C'\fR is true.
.PP
The following actions only apply to hashes and are available if and only if \*(L"\s-1VMG_UVAR\*(R"\s0 is true.
They are referred to as \fIuvar\fR magics.
.IP "\(bu" 4
\&\fIfetch\fR
.Sp
This magic is invoked each time an element is fetched from the hash.
.IP "\(bu" 4
\&\fIstore\fR
.Sp
This one is called when an element is stored into the hash.
.IP "\(bu" 4
\&\fIexists\fR
.Sp
This magic fires when a key is tested for existence in the hash.
.IP "\(bu" 4
\&\fIdelete\fR
.Sp
This magic is triggered when a key is deleted in the hash, regardless of whether the key actually exists in it.
.PP
You can refer to the tests to have more insight of where the different magics are invoked.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS """wizard"""
.el .SS "\f(CWwizard\fP"
.IX Subsection "wizard"
.Vb 10
\&    wizard(
\&     data     => sub { ... },
\&     get      => sub { my ($ref, $data [, $op]) = @_; ... },
\&     set      => sub { my ($ref, $data [, $op]) = @_; ... },
\&     len      => sub {
\&      my ($ref, $data, $len [, $op]) = @_; ... ; return $newlen
\&     },
\&     clear    => sub { my ($ref, $data [, $op]) = @_; ... },
\&     free     => sub { my ($ref, $data [, $op]) = @_, ... },
\&     copy     => sub { my ($ref, $data, $key, $elt [, $op]) = @_; ... },
\&     local    => sub { my ($ref, $data [, $op]) = @_; ... },
\&     fetch    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     store    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     exists   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     delete   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     copy_key => $bool,
\&     op_info  => [ 0 | VMG_OP_INFO_NAME | VMG_OP_INFO_OBJECT ],
\&    )
.Ve
.PP
This function creates a 'wizard', an opaque object that holds the magic information.
It takes a list of keys / values as argument, whose keys can be :
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR
.Sp
A code (or string) reference to a private data constructor.
It is called in scalar context each time the magic is cast onto a variable, with \f(CW$_[0]\fR being a reference to this variable and \f(CW@_[1 .. @_\-1]\fR being all extra arguments that were passed to \*(L"cast\*(R".
The scalar returned from this call is then attached to the variable and can be retrieved later with \*(L"getdata\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`get\*(C'\fR, \f(CW\*(C`set\*(C'\fR, \f(CW\*(C`len\*(C'\fR, \f(CW\*(C`clear\*(C'\fR, \f(CW\*(C`free\*(C'\fR, \f(CW\*(C`copy\*(C'\fR, \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`fetch\*(C'\fR, \f(CW\*(C`store\*(C'\fR, \f(CW\*(C`exists\*(C'\fR and \f(CW\*(C`delete\*(C'\fR
.Sp
Code (or string) references to the respective magic callbacks.
You don't have to specify all of them : the magic corresponding to undefined entries will simply not be hooked.
.Sp
When those callbacks are executed, \f(CW$_[0]\fR is a reference to the magic variable and \f(CW$_[1]\fR is the associated private data (or \f(CW\*(C`undef\*(C'\fR when no private data constructor is supplied with the wizard).
Other arguments depend on which kind of magic is involved :
.RS 4
.IP "\(bu" 8
\&\fIlen\fR
.Sp
\&\f(CW$_[2]\fR contains the natural, non-magical length of the variable (which can only be a scalar or an array as \fIlen\fR magic is only relevant for these types).
The callback is expected to return the new scalar or array length to use, or \f(CW\*(C`undef\*(C'\fR to default to the normal length.
.IP "\(bu" 8
\&\fIcopy\fR
.Sp
\&\f(CW$_[2]\fR is a either an alias or a copy of the current key, and \f(CW$_[3]\fR is an alias to the current element (i.e. the value).
Because \f(CW$_[2]\fR might be a copy, it is useless to try to change it or cast magic on it.
.IP "\(bu" 8
\&\fIfetch\fR, \fIstore\fR, \fIexists\fR and \fIdelete\fR
.Sp
\&\f(CW$_[2]\fR is an alias to the current key.
Note that \f(CW$_[2]\fR may rightfully be readonly if the key comes from a bareword, and as such it is unsafe to assign to it.
You can ask for a copy instead by passing \f(CW\*(C`copy_key => 1\*(C'\fR to \*(L"wizard\*(R" which, at the price of a small performance hit, allows you to safely assign to \f(CW$_[2]\fR in order to e.g. redirect the action to another key.
.RE
.RS 4
.Sp
Finally, if \f(CW\*(C`op_info => $num\*(C'\fR is also passed to \f(CW\*(C`wizard\*(C'\fR, then one extra element is appended to \f(CW@_\fR.
Its nature depends on the value of \f(CW$num\fR :
.IP "\(bu" 8
\&\f(CW\*(C`VMG_OP_INFO_NAME\*(C'\fR
.Sp
\&\f(CW$_[\-1]\fR is the current op name.
.IP "\(bu" 8
\&\f(CW\*(C`VMG_OP_INFO_OBJECT\*(C'\fR
.Sp
\&\f(CW$_[\-1]\fR is the \f(CW\*(C`B::OP\*(C'\fR object for the current op.
.RE
.RS 4
.Sp
Both result in a small performance hit, but just getting the name is lighter than getting the op object.
.Sp
These callbacks are executed in scalar context and are expected to return an integer, which is then passed straight to the perl magic \s-1API.\s0
However, only the return value of the \fIlen\fR magic callback currently holds a meaning.
.RE
.PP
Each callback can be specified as :
.IP "\(bu" 4
a code reference, which will be called as a subroutine.
.IP "\(bu" 4
a string reference, where the string denotes which subroutine is to be called when magic is triggered.
If the subroutine name is not fully qualified, then the current package at the time the magic is invoked will be used instead.
.IP "\(bu" 4
a reference to \f(CW\*(C`undef\*(C'\fR, in which case a no-op magic callback is installed instead of the default one.
This may especially be helpful for \fIlocal\fR magic, where an empty callback prevents magic from being copied during localization.
.PP
Note that \fIfree\fR magic is never called during global destruction, as there is no way to ensure that the wizard object and the callback were not destroyed before the variable.
.PP
Here is a simple usage example :
.PP
.Vb 6
\&    # A simple scalar tracer
\&    my $wiz = wizard(
\&     get  => sub { print STDERR "got ${$_[0]}\en" },
\&     set  => sub { print STDERR "set to ${$_[0]}\en" },
\&     free => sub { print STDERR "${$_[0]} was deleted\en" },
\&    );
.Ve
.ie n .SS """cast"""
.el .SS "\f(CWcast\fP"
.IX Subsection "cast"
.Vb 1
\&    cast [$@%&*]var, $wiz, @args
.Ve
.PP
This function associates \f(CW$wiz\fR magic to the supplied variable, without overwriting any other kind of magic.
It returns true on success or when \f(CW$wiz\fR magic is already attached, and croaks on error.
When \f(CW$wiz\fR provides a data constructor, it is called just before magic is cast onto the variable, and it receives a reference to the target variable in \f(CW$_[0]\fR and the content of \f(CW@args\fR in \f(CW@_[1 .. @args]\fR.
Otherwise, \f(CW@args\fR is ignored.
.PP
.Vb 3
\&    # Casts $wiz onto $x, passing (\e$x, \*(Aq1\*(Aq) to the data constructor.
\&    my $x;
\&    cast $x, $wiz, 1;
.Ve
.PP
The \f(CW\*(C`var\*(C'\fR argument can be an array or hash value.
Magic for these scalars behaves like for any other, except that it is dispelled when the entry is deleted from the container.
For example, if you want to call \f(CW\*(C`POSIX::tzset\*(C'\fR each time the \f(CW\*(AqTZ\*(Aq\fR environment variable is changed in \f(CW%ENV\fR, you can use :
.PP
.Vb 2
\&    use POSIX;
\&    cast $ENV{TZ}, wizard set => sub { POSIX::tzset(); () };
.Ve
.PP
If you want to handle the possible deletion of the \f(CW\*(AqTZ\*(Aq\fR entry, you must also specify \fIstore\fR magic.
.ie n .SS """getdata"""
.el .SS "\f(CWgetdata\fP"
.IX Subsection "getdata"
.Vb 1
\&    getdata [$@%&*]var, $wiz
.Ve
.PP
This accessor fetches the private data associated with the magic \f(CW$wiz\fR in the variable.
It croaks when \f(CW$wiz\fR does not represent a valid magic object, and returns an empty list if no such magic is attached to the variable or when the wizard has no data constructor.
.PP
.Vb 3
\&    # Get the data attached to $wiz in $x, or undef if $wiz
\&    # did not attach any.
\&    my $data = getdata $x, $wiz;
.Ve
.ie n .SS """dispell"""
.el .SS "\f(CWdispell\fP"
.IX Subsection "dispell"
.Vb 1
\&    dispell [$@%&*]variable, $wiz
.Ve
.PP
The exact opposite of \*(L"cast\*(R" : it dissociates \f(CW$wiz\fR magic from the variable.
This function returns true on success, \f(CW0\fR when no magic represented by \f(CW$wiz\fR could be found in the variable, and croaks if the supplied wizard is invalid.
.PP
.Vb 2
\&    # Dispell now.
\&    die \*(Aqno such magic in $x\*(Aq unless dispell $x, $wiz;
.Ve
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.ie n .SS """MGf_COPY"""
.el .SS "\f(CWMGf_COPY\fP"
.IX Subsection "MGf_COPY"
Evaluates to true if and only if the \fIcopy\fR magic is available.
This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
.ie n .SS """MGf_DUP"""
.el .SS "\f(CWMGf_DUP\fP"
.IX Subsection "MGf_DUP"
Evaluates to true if and only if the \fIdup\fR magic is available.
This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
.ie n .SS """MGf_LOCAL"""
.el .SS "\f(CWMGf_LOCAL\fP"
.IX Subsection "MGf_LOCAL"
Evaluates to true if and only if the \fIlocal\fR magic is available.
This is the case for perl 5.9.3 and greater.
.ie n .SS """VMG_UVAR"""
.el .SS "\f(CWVMG_UVAR\fP"
.IX Subsection "VMG_UVAR"
When this constant is true, you can use the \fIfetch\fR, \fIstore\fR, \fIexists\fR and \fIdelete\fR magics on hashes.
Initial \*(L"\s-1VMG_UVAR\*(R"\s0 capability was introduced in perl 5.9.5, with a fully functional implementation shipped with perl 5.10.0.
.ie n .SS """VMG_COMPAT_SCALAR_LENGTH_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_SCALAR_LENGTH_NOLEN\fP"
.IX Subsection "VMG_COMPAT_SCALAR_LENGTH_NOLEN"
True for perls that don't call \fIlen\fR magic when taking the \f(CW\*(C`length\*(C'\fR of a magical scalar.
.ie n .SS """VMG_COMPAT_SCALAR_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_SCALAR_NOLEN\fP"
.IX Subsection "VMG_COMPAT_SCALAR_NOLEN"
True for perls that don't call \fIlen\fR magic on scalars.
Implies \*(L"\s-1VMG_COMPAT_SCALAR_LENGTH_NOLEN\*(R"\s0.
.ie n .SS """VMG_COMPAT_ARRAY_PUSH_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_PUSH_NOLEN\fP"
.IX Subsection "VMG_COMPAT_ARRAY_PUSH_NOLEN"
True for perls that don't call \fIlen\fR magic when you push an element in a magical array.
Starting from perl 5.11.0, this only refers to pushes in non-void context and hence is false.
.ie n .SS """VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_PUSH_NOLEN_VOID\fP"
.IX Subsection "VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID"
True for perls that don't call \fIlen\fR magic when you push in void context an element in a magical array.
.ie n .SS """VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID\fP"
.IX Subsection "VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID"
True for perls that don't call \fIlen\fR magic when you unshift in void context an element in a magical array.
.ie n .SS """VMG_COMPAT_ARRAY_UNDEF_CLEAR"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_UNDEF_CLEAR\fP"
.IX Subsection "VMG_COMPAT_ARRAY_UNDEF_CLEAR"
True for perls that call \fIclear\fR magic when undefining magical arrays.
.ie n .SS """VMG_COMPAT_HASH_DELETE_NOUVAR_VOID"""
.el .SS "\f(CWVMG_COMPAT_HASH_DELETE_NOUVAR_VOID\fP"
.IX Subsection "VMG_COMPAT_HASH_DELETE_NOUVAR_VOID"
True for perls that don't call \fIdelete\fR magic when you delete an element from a hash in void context.
.ie n .SS """VMG_COMPAT_GLOB_GET"""
.el .SS "\f(CWVMG_COMPAT_GLOB_GET\fP"
.IX Subsection "VMG_COMPAT_GLOB_GET"
True for perls that call \fIget\fR magic for operations on globs.
.ie n .SS """VMG_PERL_PATCHLEVEL"""
.el .SS "\f(CWVMG_PERL_PATCHLEVEL\fP"
.IX Subsection "VMG_PERL_PATCHLEVEL"
The perl patchlevel this module was built with, or \f(CW0\fR for non-debugging perls.
.ie n .SS """VMG_THREADSAFE"""
.el .SS "\f(CWVMG_THREADSAFE\fP"
.IX Subsection "VMG_THREADSAFE"
True if and only if this module could have been built with thread-safety features enabled.
.ie n .SS """VMG_FORKSAFE"""
.el .SS "\f(CWVMG_FORKSAFE\fP"
.IX Subsection "VMG_FORKSAFE"
True if and only if this module could have been built with fork-safety features enabled.
This is always true except on Windows where it is false for perl 5.10.0 and below.
.ie n .SS """VMG_OP_INFO_NAME"""
.el .SS "\f(CWVMG_OP_INFO_NAME\fP"
.IX Subsection "VMG_OP_INFO_NAME"
Value to pass with \f(CW\*(C`op_info\*(C'\fR to get the current op name in the magic callbacks.
.ie n .SS """VMG_OP_INFO_OBJECT"""
.el .SS "\f(CWVMG_OP_INFO_OBJECT\fP"
.IX Subsection "VMG_OP_INFO_OBJECT"
Value to pass with \f(CW\*(C`op_info\*(C'\fR to get a \f(CW\*(C`B::OP\*(C'\fR object representing the current op in the magic callbacks.
.SH "COOKBOOK"
.IX Header "COOKBOOK"
.SS "Associate an object to any perl variable"
.IX Subsection "Associate an object to any perl variable"
This technique can be useful for passing user data through limited APIs.
It is similar to using inside-out objects, but without the drawback of having to implement a complex destructor.
.PP
.Vb 2
\&    {
\&     package Magical::UserData;
\&
\&     use Variable::Magic qw<wizard cast getdata>;
\&
\&     my $wiz = wizard data => sub { \e$_[1] };
\&
\&     sub ud (\e[$@%*&]) : lvalue {
\&      my ($var) = @_;
\&      my $data = &getdata($var, $wiz);
\&      unless (defined $data) {
\&       $data = \e(my $slot);
\&       &cast($var, $wiz, $slot)
\&                 or die "Couldn\*(Aqt cast UserData magic onto the variable";
\&      }
\&      $$data;
\&     }
\&    }
\&
\&    {
\&     BEGIN { *ud = \e&Magical::UserData::ud }
\&
\&     my $cb;
\&     $cb = sub { print \*(AqHello, \*(Aq, ud(&$cb), "!\en" };
\&
\&     ud(&$cb) = \*(Aqworld\*(Aq;
\&     $cb\->(); # Hello, world!
\&    }
.Ve
.SS "Recursively cast magic on datastructures"
.IX Subsection "Recursively cast magic on datastructures"
\&\f(CW\*(C`cast\*(C'\fR can be called from any magical callback, and in particular from \f(CW\*(C`data\*(C'\fR.
This allows you to recursively cast magic on datastructures :
.PP
.Vb 10
\&    my $wiz;
\&    $wiz = wizard data => sub {
\&     my ($var, $depth) = @_;
\&     $depth ||= 0;
\&     my $r = ref $var;
\&     if ($r eq \*(AqARRAY\*(Aq) {
\&      &cast((ref() ? $_ : \e$_), $wiz, $depth + 1) for @$var;
\&     } elsif ($r eq \*(AqHASH\*(Aq) {
\&      &cast((ref() ? $_ : \e$_), $wiz, $depth + 1) for values %$var;
\&     }
\&     return $depth;
\&    },
\&    free => sub {
\&     my ($var, $depth) = @_;
\&     my $r = ref $var;
\&     print "free $r at depth $depth\en";
\&     ();
\&    };
\&
\&    {
\&     my %h = (
\&      a => [ 1, 2 ],
\&      b => { c => 3 }
\&     );
\&     cast %h, $wiz;
\&    }
.Ve
.PP
When \f(CW%h\fR goes out of scope, this prints something among the lines of :
.PP
.Vb 6
\&    free HASH at depth 0
\&    free HASH at depth 1
\&    free SCALAR at depth 2
\&    free ARRAY at depth 1
\&    free SCALAR at depth 3
\&    free SCALAR at depth 3
.Ve
.PP
Of course, this example does nothing with the values that are added after the \f(CW\*(C`cast\*(C'\fR.
.SH "PERL MAGIC HISTORY"
.IX Header "PERL MAGIC HISTORY"
The places where magic is invoked have changed a bit through perl history.
Here is a little list of the most recent ones.
.IP "\(bu" 4
\&\fB5.6.x\fR
.Sp
\&\fIp14416\fR : \fIcopy\fR and \fIdup\fR magic.
.IP "\(bu" 4
\&\fB5.8.9\fR
.Sp
\&\fIp28160\fR : Integration of \fIp25854\fR (see below).
.Sp
\&\fIp32542\fR : Integration of \fIp31473\fR (see below).
.IP "\(bu" 4
\&\fB5.9.3\fR
.Sp
\&\fIp25854\fR : \fIlen\fR magic is no longer called when pushing an element into a magic array.
.Sp
\&\fIp26569\fR : \fIlocal\fR magic.
.IP "\(bu" 4
\&\fB5.9.5\fR
.Sp
\&\fIp31064\fR : Meaningful \fIuvar\fR magic.
.Sp
\&\fIp31473\fR : \fIclear\fR magic was not invoked when undefining an array.
The bug is fixed as of this version.
.IP "\(bu" 4
\&\fB5.10.0\fR
.Sp
Since \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR is uppercased, \f(CW\*(C`hv_magic_check()\*(C'\fR triggers \fIcopy\fR magic on hash stores for (non-tied) hashes that also have \fIuvar\fR magic.
.IP "\(bu" 4
\&\fB5.11.x\fR
.Sp
\&\fIp32969\fR : \fIlen\fR magic is no longer invoked when calling \f(CW\*(C`length\*(C'\fR with a magical scalar.
.Sp
\&\fIp34908\fR : \fIlen\fR magic is no longer called when pushing / unshifting an element into a magical array in void context.
The \f(CW\*(C`push\*(C'\fR part was already covered by \fIp25854\fR.
.Sp
\&\fIg9cdcb38b\fR : \fIlen\fR magic is called again when pushing into a magical array in non-void context.
.SH "EXPORT"
.IX Header "EXPORT"
The functions \*(L"wizard\*(R", \*(L"cast\*(R", \*(L"getdata\*(R" and \*(L"dispell\*(R" are only exported on request.
All of them are exported by the tags \f(CW\*(Aq:funcs\*(Aq\fR and \f(CW\*(Aq:all\*(Aq\fR.
.PP
All the constants are also only exported on request, either individually or by the tags \f(CW\*(Aq:consts\*(Aq\fR and \f(CW\*(Aq:all\*(Aq\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
In order to hook hash operations with magic, you need at least perl 5.10.0 (see \*(L"\s-1VMG_UVAR\*(R"\s0).
.PP
If you want to store a magic object in the private data slot, you will not be able to recover the magic with \*(L"getdata\*(R", since magic is not copied by assignment.
You can work around this gotcha by storing a reference to the magic object instead.
.PP
If you define a wizard with \fIfree\fR magic and cast it on itself, it results in a memory cycle, so this destructor will not be called when the wizard is freed.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
perl 5.8.
.PP
A C compiler.
This module may happen to build with a \*(C+ compiler as well, but don't rely on it, as no guarantee is made in this regard.
.PP
Carp (core since perl 5), XSLoader (since 5.6.0).
.PP
Copy tests need Tie::Array (core since perl 5.005) and Tie::Hash (since 5.002).
Some uvar tests need Hash::Util::FieldHash (since 5.9.4).
Glob tests need Symbol (since 5.002).
Threads tests need threads and threads::shared (both since 5.7.3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts and perlapi for internal information about magic.
.PP
perltie and overload for other ways of enhancing objects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Vincent Pit, \f(CW\*(C`<perl at profvince.com>\*(C'\fR, <http://www.profvince.com>.
.PP
You can contact me by mail or on \f(CW\*(C`irc.perl.org\*(C'\fR (vincent).
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-variable\-magic at rt.cpan.org\*(C'\fR, or through the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable\-Magic>.
I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Variable::Magic
.Ve
.PP
Tests code coverage report is available at <http://www.profvince.com/perl/cover/Variable\-Magic>.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007,2008,2009,2010,2011,2012,2013 Vincent Pit, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Variable::Magic5.16.3pm                      0100644 0001750 0001750 00000066567 12566242327 024512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Variable::Magic 3"
.TH Variable::Magic 3 "2012-08-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Variable::Magic \- Associate user\-defined magic to variables from Perl.
.SH "VERSION"
.IX Header "VERSION"
Version 0.51
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Variable::Magic qw<wizard cast VMG_OP_INFO_NAME>;
\&
\&    { # A variable tracer
\&     my $wiz = wizard(
\&      set  => sub { print "now set to ${$_[0]}!\en" },
\&      free => sub { print "destroyed!\en" },
\&     );
\&
\&     my $a = 1;
\&     cast $a, $wiz;
\&     $a = 2;        # "now set to 2!"
\&    }               # "destroyed!"
\&
\&    { # A hash with a default value
\&     my $wiz = wizard(
\&      data     => sub { $_[1] },
\&      fetch    => sub { $_[2] = $_[1] unless exists $_[0]\->{$_[2]}; () },
\&      store    => sub { print "key $_[2] stored in $_[\-1]\en" },
\&      copy_key => 1,
\&      op_info  => VMG_OP_INFO_NAME,
\&     );
\&
\&     my %h = (_default => 0, apple => 2);
\&     cast %h, $wiz, \*(Aq_default\*(Aq;
\&     print $h{banana}, "\en"; # "0" (there is no \*(Aqbanana\*(Aq key in %h)
\&     $h{pear} = 1;           # "key pear stored in helem"
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Magic is Perl's way of enhancing variables.
This mechanism lets the user add extra data to any variable and hook syntactical operations (such as access, assignment or destruction) that can be applied to it.
With this module, you can add your own magic to any variable without having to write a single line of \s-1XS\s0.
.PP
You'll realize that these magic variables look a lot like tied variables.
It is not surprising, as tied variables are implemented as a special kind of magic, just like any 'irregular' Perl variable : scalars like \f(CW$!\fR, \f(CW$(\fR or \f(CW$^W\fR, the \f(CW%ENV\fR and \f(CW%SIG\fR hashes, the \f(CW@ISA\fR array,  \f(CW\*(C`vec()\*(C'\fR and \f(CW\*(C`substr()\*(C'\fR lvalues, threads::shared variables...
They all share the same underlying C \s-1API\s0, and this module gives you direct access to it.
.PP
Still, the magic made available by this module differs from tieing and overloading in several ways :
.IP "\(bu" 4
Magic is not copied on assignment.
.Sp
You attach it to variables, not values (as for blessed references).
.IP "\(bu" 4
Magic does not replace the original semantics.
.Sp
Magic callbacks usually get triggered before the original action takes place, and cannot prevent it from happening.
This also makes catching individual events easier than with \f(CW\*(C`tie\*(C'\fR, where you have to provide fallbacks methods for all actions by usually inheriting from the correct \f(CW\*(C`Tie::Std*\*(C'\fR class and overriding individual methods in your own class.
.IP "\(bu" 4
Magic is multivalued.
.Sp
You can safely apply different kinds of magics to the same variable, and each of them will be invoked successively.
.IP "\(bu" 4
Magic is type-agnostic.
.Sp
The same magic can be applied on scalars, arrays, hashes, subs or globs.
But the same hook (see below for a list) may trigger differently depending on the the type of the variable.
.IP "\(bu" 4
Magic is invisible at Perl level.
.Sp
Magical and non-magical variables cannot be distinguished with \f(CW\*(C`ref\*(C'\fR, \f(CW\*(C`tied\*(C'\fR or another trick.
.IP "\(bu" 4
Magic is notably faster.
.Sp
Mainly because perl's way of handling magic is lighter by nature, and because there is no need for any method resolution.
Also, since you don't have to reimplement all the variable semantics, you only pay for what you actually use.
.PP
The operations that can be overloaded are :
.IP "\(bu" 4
\&\fIget\fR
.Sp
This magic is invoked when the variable is evaluated.
It is never called for arrays and hashes.
.IP "\(bu" 4
\&\fIset\fR
.Sp
This magic is called each time the value of the variable changes.
It is called for array subscripts and slices, but never for hashes.
.IP "\(bu" 4
\&\fIlen\fR
.Sp
This magic only applies to scalars and arrays, and is triggered when the 'size' or the 'length' of the variable has to be known by Perl.
This is typically the magic involved when an array is evaluated in scalar context, but also on array assignment and loops (\f(CW\*(C`for\*(C'\fR, \f(CW\*(C`map\*(C'\fR or \f(CW\*(C`grep\*(C'\fR).
The length is returned from the callback as an integer.
.IP "\(bu" 4
\&\fIclear\fR
.Sp
This magic is invoked when the variable is reset, such as when an array is emptied.
Please note that this is different from undefining the variable, even though the magic is called when the clearing is a result of the undefine (e.g. for an array, but actually a bug prevent it to work before perl 5.9.5 \- see the history).
.IP "\(bu" 4
\&\fIfree\fR
.Sp
This magic is called when a variable is destroyed as the result of going out of scope (but not when it is undefined).
It behaves roughly like Perl object destructors (i.e. \f(CW\*(C`DESTROY\*(C'\fR methods), except that exceptions thrown from inside a \fIfree\fR callback will always be propagated to the surrounding code.
.IP "\(bu" 4
\&\fIcopy\fR
.Sp
This magic only applies to tied arrays and hashes, and fires when you try to access or change their elements.
.IP "\(bu" 4
\&\fIdup\fR
.Sp
This magic is invoked when the variable is cloned across threads.
It is currently not available.
.IP "\(bu" 4
\&\fIlocal\fR
.Sp
When this magic is set on a variable, all subsequent localizations of the variable will trigger the callback.
It is available on your perl if and only if \f(CW\*(C`MGf_LOCAL\*(C'\fR is true.
.PP
The following actions only apply to hashes and are available if and only if \*(L"\s-1VMG_UVAR\s0\*(R" is true.
They are referred to as \fIuvar\fR magics.
.IP "\(bu" 4
\&\fIfetch\fR
.Sp
This magic is invoked each time an element is fetched from the hash.
.IP "\(bu" 4
\&\fIstore\fR
.Sp
This one is called when an element is stored into the hash.
.IP "\(bu" 4
\&\fIexists\fR
.Sp
This magic fires when a key is tested for existence in the hash.
.IP "\(bu" 4
\&\fIdelete\fR
.Sp
This magic is triggered when a key is deleted in the hash, regardless of whether the key actually exists in it.
.PP
You can refer to the tests to have more insight of where the different magics are invoked.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS """wizard"""
.el .SS "\f(CWwizard\fP"
.IX Subsection "wizard"
.Vb 10
\&    wizard(
\&     data     => sub { ... },
\&     get      => sub { my ($ref, $data [, $op]) = @_; ... },
\&     set      => sub { my ($ref, $data [, $op]) = @_; ... },
\&     len      => sub {
\&      my ($ref, $data, $len [, $op]) = @_; ... ; return $newlen
\&     },
\&     clear    => sub { my ($ref, $data [, $op]) = @_; ... },
\&     free     => sub { my ($ref, $data [, $op]) = @_, ... },
\&     copy     => sub { my ($ref, $data, $key, $elt [, $op]) = @_; ... },
\&     local    => sub { my ($ref, $data [, $op]) = @_; ... },
\&     fetch    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     store    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     exists   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     delete   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     copy_key => $bool,
\&     op_info  => [ 0 | VMG_OP_INFO_NAME | VMG_OP_INFO_OBJECT ],
\&    )
.Ve
.PP
This function creates a 'wizard', an opaque object that holds the magic information.
It takes a list of keys / values as argument, whose keys can be :
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR
.Sp
A code (or string) reference to a private data constructor.
It is called in scalar context each time the magic is cast onto a variable, with \f(CW$_[0]\fR being a reference to this variable and \f(CW@_[1 .. @_\-1]\fR being all extra arguments that were passed to \*(L"cast\*(R".
The scalar returned from this call is then attached to the variable and can be retrieved later with \*(L"getdata\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`get\*(C'\fR, \f(CW\*(C`set\*(C'\fR, \f(CW\*(C`len\*(C'\fR, \f(CW\*(C`clear\*(C'\fR, \f(CW\*(C`free\*(C'\fR, \f(CW\*(C`copy\*(C'\fR, \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`fetch\*(C'\fR, \f(CW\*(C`store\*(C'\fR, \f(CW\*(C`exists\*(C'\fR and \f(CW\*(C`delete\*(C'\fR
.Sp
Code (or string) references to the respective magic callbacks.
You don't have to specify all of them : the magic corresponding to undefined entries will simply not be hooked.
.Sp
When those callbacks are executed, \f(CW$_[0]\fR is a reference to the magic variable and \f(CW$_[1]\fR is the associated private data (or \f(CW\*(C`undef\*(C'\fR when no private data constructor is supplied with the wizard).
Other arguments depend on which kind of magic is involved :
.RS 4
.IP "\(bu" 8
\&\fIlen\fR
.Sp
\&\f(CW$_[2]\fR contains the natural, non-magical length of the variable (which can only be a scalar or an array as \fIlen\fR magic is only relevant for these types).
The callback is expected to return the new scalar or array length to use, or \f(CW\*(C`undef\*(C'\fR to default to the normal length.
.IP "\(bu" 8
\&\fIcopy\fR
.Sp
\&\f(CW$_[2]\fR is a either an alias or a copy of the current key, and \f(CW$_[3]\fR is an alias to the current element (i.e. the value).
Because \f(CW$_[2]\fR might be a copy, it is useless to try to change it or cast magic on it.
.IP "\(bu" 8
\&\fIfetch\fR, \fIstore\fR, \fIexists\fR and \fIdelete\fR
.Sp
\&\f(CW$_[2]\fR is an alias to the current key.
Note that \f(CW$_[2]\fR may rightfully be readonly if the key comes from a bareword, and as such it is unsafe to assign to it.
You can ask for a copy instead by passing \f(CW\*(C`copy_key => 1\*(C'\fR to \*(L"wizard\*(R" which, at the price of a small performance hit, allows you to safely assign to \f(CW$_[2]\fR in order to e.g. redirect the action to another key.
.RE
.RS 4
.Sp
Finally, if \f(CW\*(C`op_info => $num\*(C'\fR is also passed to \f(CW\*(C`wizard\*(C'\fR, then one extra element is appended to \f(CW@_\fR.
Its nature depends on the value of \f(CW$num\fR :
.IP "\(bu" 8
\&\f(CW\*(C`VMG_OP_INFO_NAME\*(C'\fR
.Sp
\&\f(CW$_[\-1]\fR is the current op name.
.IP "\(bu" 8
\&\f(CW\*(C`VMG_OP_INFO_OBJECT\*(C'\fR
.Sp
\&\f(CW$_[\-1]\fR is the \f(CW\*(C`B::OP\*(C'\fR object for the current op.
.RE
.RS 4
.Sp
Both result in a small performance hit, but just getting the name is lighter than getting the op object.
.Sp
These callbacks are executed in scalar context and are expected to return an integer, which is then passed straight to the perl magic \s-1API\s0.
However, only the return value of the \fIlen\fR magic callback currently holds a meaning.
.RE
.PP
Each callback can be specified as :
.IP "\(bu" 4
a code reference, which will be called as a subroutine.
.IP "\(bu" 4
a string reference, where the string denotes which subroutine is to be called when magic is triggered.
If the subroutine name is not fully qualified, then the current package at the time the magic is invoked will be used instead.
.IP "\(bu" 4
a reference to \f(CW\*(C`undef\*(C'\fR, in which case a no-op magic callback is installed instead of the default one.
This may especially be helpful for \fIlocal\fR magic, where an empty callback prevents magic from being copied during localization.
.PP
Note that \fIfree\fR magic is never called during global destruction, as there is no way to ensure that the wizard object and the callback were not destroyed before the variable.
.PP
Here is a simple usage example :
.PP
.Vb 6
\&    # A simple scalar tracer
\&    my $wiz = wizard(
\&     get  => sub { print STDERR "got ${$_[0]}\en" },
\&     set  => sub { print STDERR "set to ${$_[0]}\en" },
\&     free => sub { print STDERR "${$_[0]} was deleted\en" },
\&    );
.Ve
.ie n .SS """cast"""
.el .SS "\f(CWcast\fP"
.IX Subsection "cast"
.Vb 1
\&    cast [$@%&*]var, $wiz, @args
.Ve
.PP
This function associates \f(CW$wiz\fR magic to the supplied variable, without overwriting any other kind of magic.
It returns true on success or when \f(CW$wiz\fR magic is already attached, and croaks on error.
When \f(CW$wiz\fR provides a data constructor, it is called just before magic is cast onto the variable, and it receives a reference to the target variable in \f(CW$_[0]\fR and the content of \f(CW@args\fR in \f(CW@_[1 .. @args]\fR.
Otherwise, \f(CW@args\fR is ignored.
.PP
.Vb 3
\&    # Casts $wiz onto $x, passing (\e$x, \*(Aq1\*(Aq) to the data constructor.
\&    my $x;
\&    cast $x, $wiz, 1;
.Ve
.PP
The \f(CW\*(C`var\*(C'\fR argument can be an array or hash value.
Magic for these scalars behaves like for any other, except that it is dispelled when the entry is deleted from the container.
For example, if you want to call \f(CW\*(C`POSIX::tzset\*(C'\fR each time the \f(CW\*(AqTZ\*(Aq\fR environment variable is changed in \f(CW%ENV\fR, you can use :
.PP
.Vb 2
\&    use POSIX;
\&    cast $ENV{TZ}, wizard set => sub { POSIX::tzset(); () };
.Ve
.PP
If you want to handle the possible deletion of the \f(CW\*(AqTZ\*(Aq\fR entry, you must also specify \fIstore\fR magic.
.ie n .SS """getdata"""
.el .SS "\f(CWgetdata\fP"
.IX Subsection "getdata"
.Vb 1
\&    getdata [$@%&*]var, $wiz
.Ve
.PP
This accessor fetches the private data associated with the magic \f(CW$wiz\fR in the variable.
It croaks when \f(CW$wiz\fR does not represent a valid magic object, and returns an empty list if no such magic is attached to the variable or when the wizard has no data constructor.
.PP
.Vb 3
\&    # Get the data attached to $wiz in $x, or undef if $wiz
\&    # did not attach any.
\&    my $data = getdata $x, $wiz;
.Ve
.ie n .SS """dispell"""
.el .SS "\f(CWdispell\fP"
.IX Subsection "dispell"
.Vb 1
\&    dispell [$@%&*]variable, $wiz
.Ve
.PP
The exact opposite of \*(L"cast\*(R" : it dissociates \f(CW$wiz\fR magic from the variable.
This function returns true on success, \f(CW0\fR when no magic represented by \f(CW$wiz\fR could be found in the variable, and croaks if the supplied wizard is invalid.
.PP
.Vb 2
\&    # Dispell now.
\&    die \*(Aqno such magic in $x\*(Aq unless dispell $x, $wiz;
.Ve
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.ie n .SS """MGf_COPY"""
.el .SS "\f(CWMGf_COPY\fP"
.IX Subsection "MGf_COPY"
Evaluates to true if and only if the \fIcopy\fR magic is available.
This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
.ie n .SS """MGf_DUP"""
.el .SS "\f(CWMGf_DUP\fP"
.IX Subsection "MGf_DUP"
Evaluates to true if and only if the \fIdup\fR magic is available.
This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
.ie n .SS """MGf_LOCAL"""
.el .SS "\f(CWMGf_LOCAL\fP"
.IX Subsection "MGf_LOCAL"
Evaluates to true if and only if the \fIlocal\fR magic is available.
This is the case for perl 5.9.3 and greater.
.ie n .SS """VMG_UVAR"""
.el .SS "\f(CWVMG_UVAR\fP"
.IX Subsection "VMG_UVAR"
When this constant is true, you can use the \fIfetch\fR, \fIstore\fR, \fIexists\fR and \fIdelete\fR magics on hashes.
Initial \*(L"\s-1VMG_UVAR\s0\*(R" capability was introduced in perl 5.9.5, with a fully functional implementation shipped with perl 5.10.0.
.ie n .SS """VMG_COMPAT_SCALAR_LENGTH_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_SCALAR_LENGTH_NOLEN\fP"
.IX Subsection "VMG_COMPAT_SCALAR_LENGTH_NOLEN"
True for perls that don't call \fIlen\fR magic when taking the \f(CW\*(C`length\*(C'\fR of a magical scalar.
.ie n .SS """VMG_COMPAT_ARRAY_PUSH_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_PUSH_NOLEN\fP"
.IX Subsection "VMG_COMPAT_ARRAY_PUSH_NOLEN"
True for perls that don't call \fIlen\fR magic when you push an element in a magical array.
Starting from perl 5.11.0, this only refers to pushes in non-void context and hence is false.
.ie n .SS """VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_PUSH_NOLEN_VOID\fP"
.IX Subsection "VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID"
True for perls that don't call \fIlen\fR magic when you push in void context an element in a magical array.
.ie n .SS """VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID\fP"
.IX Subsection "VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID"
True for perls that don't call \fIlen\fR magic when you unshift in void context an element in a magical array.
.ie n .SS """VMG_COMPAT_ARRAY_UNDEF_CLEAR"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_UNDEF_CLEAR\fP"
.IX Subsection "VMG_COMPAT_ARRAY_UNDEF_CLEAR"
True for perls that call \fIclear\fR magic when undefining magical arrays.
.ie n .SS """VMG_COMPAT_HASH_DELETE_NOUVAR_VOID"""
.el .SS "\f(CWVMG_COMPAT_HASH_DELETE_NOUVAR_VOID\fP"
.IX Subsection "VMG_COMPAT_HASH_DELETE_NOUVAR_VOID"
True for perls that don't call \fIdelete\fR magic when you delete an element from a hash in void context.
.ie n .SS """VMG_COMPAT_GLOB_GET"""
.el .SS "\f(CWVMG_COMPAT_GLOB_GET\fP"
.IX Subsection "VMG_COMPAT_GLOB_GET"
True for perls that call \fIget\fR magic for operations on globs.
.ie n .SS """VMG_PERL_PATCHLEVEL"""
.el .SS "\f(CWVMG_PERL_PATCHLEVEL\fP"
.IX Subsection "VMG_PERL_PATCHLEVEL"
The perl patchlevel this module was built with, or \f(CW0\fR for non-debugging perls.
.ie n .SS """VMG_THREADSAFE"""
.el .SS "\f(CWVMG_THREADSAFE\fP"
.IX Subsection "VMG_THREADSAFE"
True if and only if this module could have been built with thread-safety features enabled.
.ie n .SS """VMG_FORKSAFE"""
.el .SS "\f(CWVMG_FORKSAFE\fP"
.IX Subsection "VMG_FORKSAFE"
True if and only if this module could have been built with fork-safety features enabled.
This is always true except on Windows where it is false for perl 5.10.0 and below.
.ie n .SS """VMG_OP_INFO_NAME"""
.el .SS "\f(CWVMG_OP_INFO_NAME\fP"
.IX Subsection "VMG_OP_INFO_NAME"
Value to pass with \f(CW\*(C`op_info\*(C'\fR to get the current op name in the magic callbacks.
.ie n .SS """VMG_OP_INFO_OBJECT"""
.el .SS "\f(CWVMG_OP_INFO_OBJECT\fP"
.IX Subsection "VMG_OP_INFO_OBJECT"
Value to pass with \f(CW\*(C`op_info\*(C'\fR to get a \f(CW\*(C`B::OP\*(C'\fR object representing the current op in the magic callbacks.
.SH "COOKBOOK"
.IX Header "COOKBOOK"
.SS "Associate an object to any perl variable"
.IX Subsection "Associate an object to any perl variable"
This technique can be useful for passing user data through limited APIs.
It is similar to using inside-out objects, but without the drawback of having to implement a complex destructor.
.PP
.Vb 2
\&    {
\&     package Magical::UserData;
\&
\&     use Variable::Magic qw<wizard cast getdata>;
\&
\&     my $wiz = wizard data => sub { \e$_[1] };
\&
\&     sub ud (\e[$@%*&]) : lvalue {
\&      my ($var) = @_;
\&      my $data = &getdata($var, $wiz);
\&      unless (defined $data) {
\&       $data = \e(my $slot);
\&       &cast($var, $wiz, $slot)
\&                 or die "Couldn\*(Aqt cast UserData magic onto the variable";
\&      }
\&      $$data;
\&     }
\&    }
\&
\&    {
\&     BEGIN { *ud = \e&Magical::UserData::ud }
\&
\&     my $cb;
\&     $cb = sub { print \*(AqHello, \*(Aq, ud(&$cb), "!\en" };
\&
\&     ud(&$cb) = \*(Aqworld\*(Aq;
\&     $cb\->(); # Hello, world!
\&    }
.Ve
.SS "Recursively cast magic on datastructures"
.IX Subsection "Recursively cast magic on datastructures"
\&\f(CW\*(C`cast\*(C'\fR can be called from any magical callback, and in particular from \f(CW\*(C`data\*(C'\fR.
This allows you to recursively cast magic on datastructures :
.PP
.Vb 10
\&    my $wiz;
\&    $wiz = wizard data => sub {
\&     my ($var, $depth) = @_;
\&     $depth ||= 0;
\&     my $r = ref $var;
\&     if ($r eq \*(AqARRAY\*(Aq) {
\&      &cast((ref() ? $_ : \e$_), $wiz, $depth + 1) for @$var;
\&     } elsif ($r eq \*(AqHASH\*(Aq) {
\&      &cast((ref() ? $_ : \e$_), $wiz, $depth + 1) for values %$var;
\&     }
\&     return $depth;
\&    },
\&    free => sub {
\&     my ($var, $depth) = @_;
\&     my $r = ref $var;
\&     print "free $r at depth $depth\en";
\&     ();
\&    };
\&
\&    {
\&     my %h = (
\&      a => [ 1, 2 ],
\&      b => { c => 3 }
\&     );
\&     cast %h, $wiz;
\&    }
.Ve
.PP
When \f(CW%h\fR goes out of scope, this prints something among the lines of :
.PP
.Vb 6
\&    free HASH at depth 0
\&    free HASH at depth 1
\&    free SCALAR at depth 2
\&    free ARRAY at depth 1
\&    free SCALAR at depth 3
\&    free SCALAR at depth 3
.Ve
.PP
Of course, this example does nothing with the values that are added after the \f(CW\*(C`cast\*(C'\fR.
.SH "PERL MAGIC HISTORY"
.IX Header "PERL MAGIC HISTORY"
The places where magic is invoked have changed a bit through perl history.
Here is a little list of the most recent ones.
.IP "\(bu" 4
\&\fB5.6.x\fR
.Sp
\&\fIp14416\fR : \fIcopy\fR and \fIdup\fR magic.
.IP "\(bu" 4
\&\fB5.8.9\fR
.Sp
\&\fIp28160\fR : Integration of \fIp25854\fR (see below).
.Sp
\&\fIp32542\fR : Integration of \fIp31473\fR (see below).
.IP "\(bu" 4
\&\fB5.9.3\fR
.Sp
\&\fIp25854\fR : \fIlen\fR magic is no longer called when pushing an element into a magic array.
.Sp
\&\fIp26569\fR : \fIlocal\fR magic.
.IP "\(bu" 4
\&\fB5.9.5\fR
.Sp
\&\fIp31064\fR : Meaningful \fIuvar\fR magic.
.Sp
\&\fIp31473\fR : \fIclear\fR magic was not invoked when undefining an array.
The bug is fixed as of this version.
.IP "\(bu" 4
\&\fB5.10.0\fR
.Sp
Since \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR is uppercased, \f(CW\*(C`hv_magic_check()\*(C'\fR triggers \fIcopy\fR magic on hash stores for (non-tied) hashes that also have \fIuvar\fR magic.
.IP "\(bu" 4
\&\fB5.11.x\fR
.Sp
\&\fIp32969\fR : \fIlen\fR magic is no longer invoked when calling \f(CW\*(C`length\*(C'\fR with a magical scalar.
.Sp
\&\fIp34908\fR : \fIlen\fR magic is no longer called when pushing / unshifting an element into a magical array in void context.
The \f(CW\*(C`push\*(C'\fR part was already covered by \fIp25854\fR.
.Sp
\&\fIg9cdcb38b\fR : \fIlen\fR magic is called again when pushing into a magical array in non-void context.
.SH "EXPORT"
.IX Header "EXPORT"
The functions \*(L"wizard\*(R", \*(L"cast\*(R", \*(L"getdata\*(R" and \*(L"dispell\*(R" are only exported on request.
All of them are exported by the tags \f(CW\*(Aq:funcs\*(Aq\fR and \f(CW\*(Aq:all\*(Aq\fR.
.PP
All the constants are also only exported on request, either individually or by the tags \f(CW\*(Aq:consts\*(Aq\fR and \f(CW\*(Aq:all\*(Aq\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
In order to hook hash operations with magic, you need at least perl 5.10.0 (see \*(L"\s-1VMG_UVAR\s0\*(R").
.PP
If you want to store a magic object in the private data slot, you will not be able to recover the magic with \*(L"getdata\*(R", since magic is not copied by assignment.
You can work around this gotcha by storing a reference to the magic object instead.
.PP
If you define a wizard with \fIfree\fR magic and cast it on itself, it results in a memory cycle, so this destructor will not be called when the wizard is freed.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
perl 5.8.
.PP
A C compiler.
This module may happen to build with a \*(C+ compiler as well, but don't rely on it, as no guarantee is made in this regard.
.PP
Carp (core since perl 5), XSLoader (since 5.006).
.PP
Copy tests need Tie::Array (core since perl 5.005) and Tie::Hash (since 5.002).
Some uvar tests need Hash::Util::FieldHash (since 5.009004).
Glob tests need Symbol (since 5.002).
Threads tests need threads and threads::shared (both since 5.007003).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts and perlapi for internal information about magic.
.PP
perltie and overload for other ways of enhancing objects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Vincent Pit, \f(CW\*(C`<perl at profvince.com>\*(C'\fR, <http://www.profvince.com>.
.PP
You can contact me by mail or on \f(CW\*(C`irc.perl.org\*(C'\fR (vincent).
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-variable\-magic at rt.cpan.org\*(C'\fR, or through the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable\-Magic <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable-Magic>.
I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Variable::Magic
.Ve
.PP
Tests code coverage report is available at http://www.profvince.com/perl/cover/Variable\-Magic <http://www.profvince.com/perl/cover/Variable-Magic>.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007,2008,2009,2010,2011,2012 Vincent Pit, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Variable::Magic5.18.3pm                      0100644 0001750 0001750 00000070166 12566242326 024501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Variable::Magic 3"
.TH Variable::Magic 3 "2013-09-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Variable::Magic \- Associate user\-defined magic to variables from Perl.
.SH "VERSION"
.IX Header "VERSION"
Version 0.53
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Variable::Magic qw<wizard cast VMG_OP_INFO_NAME>;
\&
\&    { # A variable tracer
\&     my $wiz = wizard(
\&      set  => sub { print "now set to ${$_[0]}!\en" },
\&      free => sub { print "destroyed!\en" },
\&     );
\&
\&     my $a = 1;
\&     cast $a, $wiz;
\&     $a = 2;        # "now set to 2!"
\&    }               # "destroyed!"
\&
\&    { # A hash with a default value
\&     my $wiz = wizard(
\&      data     => sub { $_[1] },
\&      fetch    => sub { $_[2] = $_[1] unless exists $_[0]\->{$_[2]}; () },
\&      store    => sub { print "key $_[2] stored in $_[\-1]\en" },
\&      copy_key => 1,
\&      op_info  => VMG_OP_INFO_NAME,
\&     );
\&
\&     my %h = (_default => 0, apple => 2);
\&     cast %h, $wiz, \*(Aq_default\*(Aq;
\&     print $h{banana}, "\en"; # "0" (there is no \*(Aqbanana\*(Aq key in %h)
\&     $h{pear} = 1;           # "key pear stored in helem"
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Magic is Perl's way of enhancing variables.
This mechanism lets the user add extra data to any variable and hook syntactical operations (such as access, assignment or destruction) that can be applied to it.
With this module, you can add your own magic to any variable without having to write a single line of \s-1XS.\s0
.PP
You'll realize that these magic variables look a lot like tied variables.
It is not surprising, as tied variables are implemented as a special kind of magic, just like any 'irregular' Perl variable : scalars like \f(CW$!\fR, \f(CW$(\fR or \f(CW$^W\fR, the \f(CW%ENV\fR and \f(CW%SIG\fR hashes, the \f(CW@ISA\fR array,  \f(CW\*(C`vec()\*(C'\fR and \f(CW\*(C`substr()\*(C'\fR lvalues, threads::shared variables...
They all share the same underlying C \s-1API,\s0 and this module gives you direct access to it.
.PP
Still, the magic made available by this module differs from tieing and overloading in several ways :
.IP "\(bu" 4
Magic is not copied on assignment.
.Sp
You attach it to variables, not values (as for blessed references).
.IP "\(bu" 4
Magic does not replace the original semantics.
.Sp
Magic callbacks usually get triggered before the original action takes place, and cannot prevent it from happening.
This also makes catching individual events easier than with \f(CW\*(C`tie\*(C'\fR, where you have to provide fallbacks methods for all actions by usually inheriting from the correct \f(CW\*(C`Tie::Std*\*(C'\fR class and overriding individual methods in your own class.
.IP "\(bu" 4
Magic is multivalued.
.Sp
You can safely apply different kinds of magics to the same variable, and each of them will be invoked successively.
.IP "\(bu" 4
Magic is type-agnostic.
.Sp
The same magic can be applied on scalars, arrays, hashes, subs or globs.
But the same hook (see below for a list) may trigger differently depending on the type of the variable.
.IP "\(bu" 4
Magic is invisible at Perl level.
.Sp
Magical and non-magical variables cannot be distinguished with \f(CW\*(C`ref\*(C'\fR, \f(CW\*(C`tied\*(C'\fR or another trick.
.IP "\(bu" 4
Magic is notably faster.
.Sp
Mainly because perl's way of handling magic is lighter by nature, and because there is no need for any method resolution.
Also, since you don't have to reimplement all the variable semantics, you only pay for what you actually use.
.PP
The operations that can be overloaded are :
.IP "\(bu" 4
\&\fIget\fR
.Sp
This magic is invoked when the variable is evaluated.
It is never called for arrays and hashes.
.IP "\(bu" 4
\&\fIset\fR
.Sp
This magic is called each time the value of the variable changes.
It is called for array subscripts and slices, but never for hashes.
.IP "\(bu" 4
\&\fIlen\fR
.Sp
This magic only applies to arrays (though it used to also apply to scalars), and is triggered when the 'size' or the 'length' of the variable has to be known by Perl.
This is typically the magic involved when an array is evaluated in scalar context, but also on array assignment and loops (\f(CW\*(C`for\*(C'\fR, \f(CW\*(C`map\*(C'\fR or \f(CW\*(C`grep\*(C'\fR).
The length is returned from the callback as an integer.
.Sp
Starting from perl 5.12, this magic is no longer called by the \f(CW\*(C`length\*(C'\fR keyword, and starting from perl 5.17.4 it is also no longer called for scalars in any situation, making this magic only meaningful on arrays.
You can use the constants \*(L"\s-1VMG_COMPAT_SCALAR_LENGTH_NOLEN\*(R"\s0 and \*(L"\s-1VMG_COMPAT_SCALAR_NOLEN\*(R"\s0 to see if this magic is available for scalars or not.
.IP "\(bu" 4
\&\fIclear\fR
.Sp
This magic is invoked when the variable is reset, such as when an array is emptied.
Please note that this is different from undefining the variable, even though the magic is called when the clearing is a result of the undefine (e.g. for an array, but actually a bug prevent it to work before perl 5.9.5 \- see the history).
.IP "\(bu" 4
\&\fIfree\fR
.Sp
This magic is called when a variable is destroyed as the result of going out of scope (but not when it is undefined).
It behaves roughly like Perl object destructors (i.e. \f(CW\*(C`DESTROY\*(C'\fR methods), except that exceptions thrown from inside a \fIfree\fR callback will always be propagated to the surrounding code.
.IP "\(bu" 4
\&\fIcopy\fR
.Sp
This magic only applies to tied arrays and hashes, and fires when you try to access or change their elements.
.IP "\(bu" 4
\&\fIdup\fR
.Sp
This magic is invoked when the variable is cloned across threads.
It is currently not available.
.IP "\(bu" 4
\&\fIlocal\fR
.Sp
When this magic is set on a variable, all subsequent localizations of the variable will trigger the callback.
It is available on your perl if and only if \f(CW\*(C`MGf_LOCAL\*(C'\fR is true.
.PP
The following actions only apply to hashes and are available if and only if \*(L"\s-1VMG_UVAR\*(R"\s0 is true.
They are referred to as \fIuvar\fR magics.
.IP "\(bu" 4
\&\fIfetch\fR
.Sp
This magic is invoked each time an element is fetched from the hash.
.IP "\(bu" 4
\&\fIstore\fR
.Sp
This one is called when an element is stored into the hash.
.IP "\(bu" 4
\&\fIexists\fR
.Sp
This magic fires when a key is tested for existence in the hash.
.IP "\(bu" 4
\&\fIdelete\fR
.Sp
This magic is triggered when a key is deleted in the hash, regardless of whether the key actually exists in it.
.PP
You can refer to the tests to have more insight of where the different magics are invoked.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS """wizard"""
.el .SS "\f(CWwizard\fP"
.IX Subsection "wizard"
.Vb 10
\&    wizard(
\&     data     => sub { ... },
\&     get      => sub { my ($ref, $data [, $op]) = @_; ... },
\&     set      => sub { my ($ref, $data [, $op]) = @_; ... },
\&     len      => sub {
\&      my ($ref, $data, $len [, $op]) = @_; ... ; return $newlen
\&     },
\&     clear    => sub { my ($ref, $data [, $op]) = @_; ... },
\&     free     => sub { my ($ref, $data [, $op]) = @_, ... },
\&     copy     => sub { my ($ref, $data, $key, $elt [, $op]) = @_; ... },
\&     local    => sub { my ($ref, $data [, $op]) = @_; ... },
\&     fetch    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     store    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     exists   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     delete   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
\&     copy_key => $bool,
\&     op_info  => [ 0 | VMG_OP_INFO_NAME | VMG_OP_INFO_OBJECT ],
\&    )
.Ve
.PP
This function creates a 'wizard', an opaque object that holds the magic information.
It takes a list of keys / values as argument, whose keys can be :
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR
.Sp
A code (or string) reference to a private data constructor.
It is called in scalar context each time the magic is cast onto a variable, with \f(CW$_[0]\fR being a reference to this variable and \f(CW@_[1 .. @_\-1]\fR being all extra arguments that were passed to \*(L"cast\*(R".
The scalar returned from this call is then attached to the variable and can be retrieved later with \*(L"getdata\*(R".
.IP "\(bu" 4
\&\f(CW\*(C`get\*(C'\fR, \f(CW\*(C`set\*(C'\fR, \f(CW\*(C`len\*(C'\fR, \f(CW\*(C`clear\*(C'\fR, \f(CW\*(C`free\*(C'\fR, \f(CW\*(C`copy\*(C'\fR, \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`fetch\*(C'\fR, \f(CW\*(C`store\*(C'\fR, \f(CW\*(C`exists\*(C'\fR and \f(CW\*(C`delete\*(C'\fR
.Sp
Code (or string) references to the respective magic callbacks.
You don't have to specify all of them : the magic corresponding to undefined entries will simply not be hooked.
.Sp
When those callbacks are executed, \f(CW$_[0]\fR is a reference to the magic variable and \f(CW$_[1]\fR is the associated private data (or \f(CW\*(C`undef\*(C'\fR when no private data constructor is supplied with the wizard).
Other arguments depend on which kind of magic is involved :
.RS 4
.IP "\(bu" 8
\&\fIlen\fR
.Sp
\&\f(CW$_[2]\fR contains the natural, non-magical length of the variable (which can only be a scalar or an array as \fIlen\fR magic is only relevant for these types).
The callback is expected to return the new scalar or array length to use, or \f(CW\*(C`undef\*(C'\fR to default to the normal length.
.IP "\(bu" 8
\&\fIcopy\fR
.Sp
\&\f(CW$_[2]\fR is a either an alias or a copy of the current key, and \f(CW$_[3]\fR is an alias to the current element (i.e. the value).
Because \f(CW$_[2]\fR might be a copy, it is useless to try to change it or cast magic on it.
.IP "\(bu" 8
\&\fIfetch\fR, \fIstore\fR, \fIexists\fR and \fIdelete\fR
.Sp
\&\f(CW$_[2]\fR is an alias to the current key.
Note that \f(CW$_[2]\fR may rightfully be readonly if the key comes from a bareword, and as such it is unsafe to assign to it.
You can ask for a copy instead by passing \f(CW\*(C`copy_key => 1\*(C'\fR to \*(L"wizard\*(R" which, at the price of a small performance hit, allows you to safely assign to \f(CW$_[2]\fR in order to e.g. redirect the action to another key.
.RE
.RS 4
.Sp
Finally, if \f(CW\*(C`op_info => $num\*(C'\fR is also passed to \f(CW\*(C`wizard\*(C'\fR, then one extra element is appended to \f(CW@_\fR.
Its nature depends on the value of \f(CW$num\fR :
.IP "\(bu" 8
\&\f(CW\*(C`VMG_OP_INFO_NAME\*(C'\fR
.Sp
\&\f(CW$_[\-1]\fR is the current op name.
.IP "\(bu" 8
\&\f(CW\*(C`VMG_OP_INFO_OBJECT\*(C'\fR
.Sp
\&\f(CW$_[\-1]\fR is the \f(CW\*(C`B::OP\*(C'\fR object for the current op.
.RE
.RS 4
.Sp
Both result in a small performance hit, but just getting the name is lighter than getting the op object.
.Sp
These callbacks are executed in scalar context and are expected to return an integer, which is then passed straight to the perl magic \s-1API.\s0
However, only the return value of the \fIlen\fR magic callback currently holds a meaning.
.RE
.PP
Each callback can be specified as :
.IP "\(bu" 4
a code reference, which will be called as a subroutine.
.IP "\(bu" 4
a string reference, where the string denotes which subroutine is to be called when magic is triggered.
If the subroutine name is not fully qualified, then the current package at the time the magic is invoked will be used instead.
.IP "\(bu" 4
a reference to \f(CW\*(C`undef\*(C'\fR, in which case a no-op magic callback is installed instead of the default one.
This may especially be helpful for \fIlocal\fR magic, where an empty callback prevents magic from being copied during localization.
.PP
Note that \fIfree\fR magic is never called during global destruction, as there is no way to ensure that the wizard object and the callback were not destroyed before the variable.
.PP
Here is a simple usage example :
.PP
.Vb 6
\&    # A simple scalar tracer
\&    my $wiz = wizard(
\&     get  => sub { print STDERR "got ${$_[0]}\en" },
\&     set  => sub { print STDERR "set to ${$_[0]}\en" },
\&     free => sub { print STDERR "${$_[0]} was deleted\en" },
\&    );
.Ve
.ie n .SS """cast"""
.el .SS "\f(CWcast\fP"
.IX Subsection "cast"
.Vb 1
\&    cast [$@%&*]var, $wiz, @args
.Ve
.PP
This function associates \f(CW$wiz\fR magic to the supplied variable, without overwriting any other kind of magic.
It returns true on success or when \f(CW$wiz\fR magic is already attached, and croaks on error.
When \f(CW$wiz\fR provides a data constructor, it is called just before magic is cast onto the variable, and it receives a reference to the target variable in \f(CW$_[0]\fR and the content of \f(CW@args\fR in \f(CW@_[1 .. @args]\fR.
Otherwise, \f(CW@args\fR is ignored.
.PP
.Vb 3
\&    # Casts $wiz onto $x, passing (\e$x, \*(Aq1\*(Aq) to the data constructor.
\&    my $x;
\&    cast $x, $wiz, 1;
.Ve
.PP
The \f(CW\*(C`var\*(C'\fR argument can be an array or hash value.
Magic for these scalars behaves like for any other, except that it is dispelled when the entry is deleted from the container.
For example, if you want to call \f(CW\*(C`POSIX::tzset\*(C'\fR each time the \f(CW\*(AqTZ\*(Aq\fR environment variable is changed in \f(CW%ENV\fR, you can use :
.PP
.Vb 2
\&    use POSIX;
\&    cast $ENV{TZ}, wizard set => sub { POSIX::tzset(); () };
.Ve
.PP
If you want to handle the possible deletion of the \f(CW\*(AqTZ\*(Aq\fR entry, you must also specify \fIstore\fR magic.
.ie n .SS """getdata"""
.el .SS "\f(CWgetdata\fP"
.IX Subsection "getdata"
.Vb 1
\&    getdata [$@%&*]var, $wiz
.Ve
.PP
This accessor fetches the private data associated with the magic \f(CW$wiz\fR in the variable.
It croaks when \f(CW$wiz\fR does not represent a valid magic object, and returns an empty list if no such magic is attached to the variable or when the wizard has no data constructor.
.PP
.Vb 3
\&    # Get the data attached to $wiz in $x, or undef if $wiz
\&    # did not attach any.
\&    my $data = getdata $x, $wiz;
.Ve
.ie n .SS """dispell"""
.el .SS "\f(CWdispell\fP"
.IX Subsection "dispell"
.Vb 1
\&    dispell [$@%&*]variable, $wiz
.Ve
.PP
The exact opposite of \*(L"cast\*(R" : it dissociates \f(CW$wiz\fR magic from the variable.
This function returns true on success, \f(CW0\fR when no magic represented by \f(CW$wiz\fR could be found in the variable, and croaks if the supplied wizard is invalid.
.PP
.Vb 2
\&    # Dispell now.
\&    die \*(Aqno such magic in $x\*(Aq unless dispell $x, $wiz;
.Ve
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.ie n .SS """MGf_COPY"""
.el .SS "\f(CWMGf_COPY\fP"
.IX Subsection "MGf_COPY"
Evaluates to true if and only if the \fIcopy\fR magic is available.
This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
.ie n .SS """MGf_DUP"""
.el .SS "\f(CWMGf_DUP\fP"
.IX Subsection "MGf_DUP"
Evaluates to true if and only if the \fIdup\fR magic is available.
This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
.ie n .SS """MGf_LOCAL"""
.el .SS "\f(CWMGf_LOCAL\fP"
.IX Subsection "MGf_LOCAL"
Evaluates to true if and only if the \fIlocal\fR magic is available.
This is the case for perl 5.9.3 and greater.
.ie n .SS """VMG_UVAR"""
.el .SS "\f(CWVMG_UVAR\fP"
.IX Subsection "VMG_UVAR"
When this constant is true, you can use the \fIfetch\fR, \fIstore\fR, \fIexists\fR and \fIdelete\fR magics on hashes.
Initial \*(L"\s-1VMG_UVAR\*(R"\s0 capability was introduced in perl 5.9.5, with a fully functional implementation shipped with perl 5.10.0.
.ie n .SS """VMG_COMPAT_SCALAR_LENGTH_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_SCALAR_LENGTH_NOLEN\fP"
.IX Subsection "VMG_COMPAT_SCALAR_LENGTH_NOLEN"
True for perls that don't call \fIlen\fR magic when taking the \f(CW\*(C`length\*(C'\fR of a magical scalar.
.ie n .SS """VMG_COMPAT_SCALAR_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_SCALAR_NOLEN\fP"
.IX Subsection "VMG_COMPAT_SCALAR_NOLEN"
True for perls that don't call \fIlen\fR magic on scalars.
Implies \*(L"\s-1VMG_COMPAT_SCALAR_LENGTH_NOLEN\*(R"\s0.
.ie n .SS """VMG_COMPAT_ARRAY_PUSH_NOLEN"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_PUSH_NOLEN\fP"
.IX Subsection "VMG_COMPAT_ARRAY_PUSH_NOLEN"
True for perls that don't call \fIlen\fR magic when you push an element in a magical array.
Starting from perl 5.11.0, this only refers to pushes in non-void context and hence is false.
.ie n .SS """VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_PUSH_NOLEN_VOID\fP"
.IX Subsection "VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID"
True for perls that don't call \fIlen\fR magic when you push in void context an element in a magical array.
.ie n .SS """VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID\fP"
.IX Subsection "VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID"
True for perls that don't call \fIlen\fR magic when you unshift in void context an element in a magical array.
.ie n .SS """VMG_COMPAT_ARRAY_UNDEF_CLEAR"""
.el .SS "\f(CWVMG_COMPAT_ARRAY_UNDEF_CLEAR\fP"
.IX Subsection "VMG_COMPAT_ARRAY_UNDEF_CLEAR"
True for perls that call \fIclear\fR magic when undefining magical arrays.
.ie n .SS """VMG_COMPAT_HASH_DELETE_NOUVAR_VOID"""
.el .SS "\f(CWVMG_COMPAT_HASH_DELETE_NOUVAR_VOID\fP"
.IX Subsection "VMG_COMPAT_HASH_DELETE_NOUVAR_VOID"
True for perls that don't call \fIdelete\fR magic when you delete an element from a hash in void context.
.ie n .SS """VMG_COMPAT_GLOB_GET"""
.el .SS "\f(CWVMG_COMPAT_GLOB_GET\fP"
.IX Subsection "VMG_COMPAT_GLOB_GET"
True for perls that call \fIget\fR magic for operations on globs.
.ie n .SS """VMG_PERL_PATCHLEVEL"""
.el .SS "\f(CWVMG_PERL_PATCHLEVEL\fP"
.IX Subsection "VMG_PERL_PATCHLEVEL"
The perl patchlevel this module was built with, or \f(CW0\fR for non-debugging perls.
.ie n .SS """VMG_THREADSAFE"""
.el .SS "\f(CWVMG_THREADSAFE\fP"
.IX Subsection "VMG_THREADSAFE"
True if and only if this module could have been built with thread-safety features enabled.
.ie n .SS """VMG_FORKSAFE"""
.el .SS "\f(CWVMG_FORKSAFE\fP"
.IX Subsection "VMG_FORKSAFE"
True if and only if this module could have been built with fork-safety features enabled.
This is always true except on Windows where it is false for perl 5.10.0 and below.
.ie n .SS """VMG_OP_INFO_NAME"""
.el .SS "\f(CWVMG_OP_INFO_NAME\fP"
.IX Subsection "VMG_OP_INFO_NAME"
Value to pass with \f(CW\*(C`op_info\*(C'\fR to get the current op name in the magic callbacks.
.ie n .SS """VMG_OP_INFO_OBJECT"""
.el .SS "\f(CWVMG_OP_INFO_OBJECT\fP"
.IX Subsection "VMG_OP_INFO_OBJECT"
Value to pass with \f(CW\*(C`op_info\*(C'\fR to get a \f(CW\*(C`B::OP\*(C'\fR object representing the current op in the magic callbacks.
.SH "COOKBOOK"
.IX Header "COOKBOOK"
.SS "Associate an object to any perl variable"
.IX Subsection "Associate an object to any perl variable"
This technique can be useful for passing user data through limited APIs.
It is similar to using inside-out objects, but without the drawback of having to implement a complex destructor.
.PP
.Vb 2
\&    {
\&     package Magical::UserData;
\&
\&     use Variable::Magic qw<wizard cast getdata>;
\&
\&     my $wiz = wizard data => sub { \e$_[1] };
\&
\&     sub ud (\e[$@%*&]) : lvalue {
\&      my ($var) = @_;
\&      my $data = &getdata($var, $wiz);
\&      unless (defined $data) {
\&       $data = \e(my $slot);
\&       &cast($var, $wiz, $slot)
\&                 or die "Couldn\*(Aqt cast UserData magic onto the variable";
\&      }
\&      $$data;
\&     }
\&    }
\&
\&    {
\&     BEGIN { *ud = \e&Magical::UserData::ud }
\&
\&     my $cb;
\&     $cb = sub { print \*(AqHello, \*(Aq, ud(&$cb), "!\en" };
\&
\&     ud(&$cb) = \*(Aqworld\*(Aq;
\&     $cb\->(); # Hello, world!
\&    }
.Ve
.SS "Recursively cast magic on datastructures"
.IX Subsection "Recursively cast magic on datastructures"
\&\f(CW\*(C`cast\*(C'\fR can be called from any magical callback, and in particular from \f(CW\*(C`data\*(C'\fR.
This allows you to recursively cast magic on datastructures :
.PP
.Vb 10
\&    my $wiz;
\&    $wiz = wizard data => sub {
\&     my ($var, $depth) = @_;
\&     $depth ||= 0;
\&     my $r = ref $var;
\&     if ($r eq \*(AqARRAY\*(Aq) {
\&      &cast((ref() ? $_ : \e$_), $wiz, $depth + 1) for @$var;
\&     } elsif ($r eq \*(AqHASH\*(Aq) {
\&      &cast((ref() ? $_ : \e$_), $wiz, $depth + 1) for values %$var;
\&     }
\&     return $depth;
\&    },
\&    free => sub {
\&     my ($var, $depth) = @_;
\&     my $r = ref $var;
\&     print "free $r at depth $depth\en";
\&     ();
\&    };
\&
\&    {
\&     my %h = (
\&      a => [ 1, 2 ],
\&      b => { c => 3 }
\&     );
\&     cast %h, $wiz;
\&    }
.Ve
.PP
When \f(CW%h\fR goes out of scope, this prints something among the lines of :
.PP
.Vb 6
\&    free HASH at depth 0
\&    free HASH at depth 1
\&    free SCALAR at depth 2
\&    free ARRAY at depth 1
\&    free SCALAR at depth 3
\&    free SCALAR at depth 3
.Ve
.PP
Of course, this example does nothing with the values that are added after the \f(CW\*(C`cast\*(C'\fR.
.SH "PERL MAGIC HISTORY"
.IX Header "PERL MAGIC HISTORY"
The places where magic is invoked have changed a bit through perl history.
Here is a little list of the most recent ones.
.IP "\(bu" 4
\&\fB5.6.x\fR
.Sp
\&\fIp14416\fR : \fIcopy\fR and \fIdup\fR magic.
.IP "\(bu" 4
\&\fB5.8.9\fR
.Sp
\&\fIp28160\fR : Integration of \fIp25854\fR (see below).
.Sp
\&\fIp32542\fR : Integration of \fIp31473\fR (see below).
.IP "\(bu" 4
\&\fB5.9.3\fR
.Sp
\&\fIp25854\fR : \fIlen\fR magic is no longer called when pushing an element into a magic array.
.Sp
\&\fIp26569\fR : \fIlocal\fR magic.
.IP "\(bu" 4
\&\fB5.9.5\fR
.Sp
\&\fIp31064\fR : Meaningful \fIuvar\fR magic.
.Sp
\&\fIp31473\fR : \fIclear\fR magic was not invoked when undefining an array.
The bug is fixed as of this version.
.IP "\(bu" 4
\&\fB5.10.0\fR
.Sp
Since \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR is uppercased, \f(CW\*(C`hv_magic_check()\*(C'\fR triggers \fIcopy\fR magic on hash stores for (non-tied) hashes that also have \fIuvar\fR magic.
.IP "\(bu" 4
\&\fB5.11.x\fR
.Sp
\&\fIp32969\fR : \fIlen\fR magic is no longer invoked when calling \f(CW\*(C`length\*(C'\fR with a magical scalar.
.Sp
\&\fIp34908\fR : \fIlen\fR magic is no longer called when pushing / unshifting an element into a magical array in void context.
The \f(CW\*(C`push\*(C'\fR part was already covered by \fIp25854\fR.
.Sp
\&\fIg9cdcb38b\fR : \fIlen\fR magic is called again when pushing into a magical array in non-void context.
.SH "EXPORT"
.IX Header "EXPORT"
The functions \*(L"wizard\*(R", \*(L"cast\*(R", \*(L"getdata\*(R" and \*(L"dispell\*(R" are only exported on request.
All of them are exported by the tags \f(CW\*(Aq:funcs\*(Aq\fR and \f(CW\*(Aq:all\*(Aq\fR.
.PP
All the constants are also only exported on request, either individually or by the tags \f(CW\*(Aq:consts\*(Aq\fR and \f(CW\*(Aq:all\*(Aq\fR.
.SH "CAVEATS"
.IX Header "CAVEATS"
In order to hook hash operations with magic, you need at least perl 5.10.0 (see \*(L"\s-1VMG_UVAR\*(R"\s0).
.PP
If you want to store a magic object in the private data slot, you will not be able to recover the magic with \*(L"getdata\*(R", since magic is not copied by assignment.
You can work around this gotcha by storing a reference to the magic object instead.
.PP
If you define a wizard with \fIfree\fR magic and cast it on itself, it results in a memory cycle, so this destructor will not be called when the wizard is freed.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
perl 5.8.
.PP
A C compiler.
This module may happen to build with a \*(C+ compiler as well, but don't rely on it, as no guarantee is made in this regard.
.PP
Carp (core since perl 5), XSLoader (since 5.6.0).
.PP
Copy tests need Tie::Array (core since perl 5.005) and Tie::Hash (since 5.002).
Some uvar tests need Hash::Util::FieldHash (since 5.9.4).
Glob tests need Symbol (since 5.002).
Threads tests need threads and threads::shared (both since 5.7.3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts and perlapi for internal information about magic.
.PP
perltie and overload for other ways of enhancing objects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Vincent Pit, \f(CW\*(C`<perl at profvince.com>\*(C'\fR, <http://www.profvince.com>.
.PP
You can contact me by mail or on \f(CW\*(C`irc.perl.org\*(C'\fR (vincent).
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-variable\-magic at rt.cpan.org\*(C'\fR, or through the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable\-Magic>.
I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Variable::Magic
.Ve
.PP
Tests code coverage report is available at <http://www.profvince.com/perl/cover/Variable\-Magic>.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007,2008,2009,2010,2011,2012,2013 Vincent Pit, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Version::Requirements.3pm                    0100644 0001750 0001750 00000024256 12566207442 025527  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Version::Requirements 3pm"
.TH Version::Requirements 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Version::Requirements \- a set of version requirements for a CPAN dist
.SH "VERSION"
.IX Header "VERSION"
version 0.101022
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Version::Requirements;
\&
\&  my $build_requires = Version::Requirements\->new;
\&
\&  $build_requires\->add_minimum(\*(AqLibrary::Foo\*(Aq => 1.208);
\&
\&  $build_requires\->add_minimum(\*(AqLibrary::Foo\*(Aq => 2.602);
\&
\&  $build_requires\->add_minimum(\*(AqModule::Bar\*(Aq  => \*(Aqv1.2.3\*(Aq);
\&
\&  $METAyml\->{build_requires} = $build_requires\->as_string_hash;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Version::Requirements object models a set of version constraints like those
specified in the \fI\s-1META\s0.yml\fR or \fI\s-1META\s0.json\fR files in \s-1CPAN\s0 distributions.  It
can be built up by adding more and more constraints, and it will reduce them to
the simplest representation.
.PP
Logically impossible constraints will be identified immediately by thrown
exceptions.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $req = Version::Requirements\->new;
.Ve
.PP
This returns a new Version::Requirements object.  It ignores any arguments
given.
.SS "add_minimum"
.IX Subsection "add_minimum"
.Vb 1
\&  $req\->add_minimum( $module => $version );
.Ve
.PP
This adds a new minimum version requirement.  If the new requirement is
redundant to the existing specification, this has no effect.
.PP
Minimum requirements are inclusive.  \f(CW$version\fR is required, along with any
greater version number.
.PP
This method returns the requirements object.
.SS "add_maximum"
.IX Subsection "add_maximum"
.Vb 1
\&  $req\->add_maximum( $module => $version );
.Ve
.PP
This adds a new maximum version requirement.  If the new requirement is
redundant to the existing specification, this has no effect.
.PP
Maximum requirements are inclusive.  No version strictly greater than the given
version is allowed.
.PP
This method returns the requirements object.
.SS "add_exclusion"
.IX Subsection "add_exclusion"
.Vb 1
\&  $req\->add_exclusion( $module => $version );
.Ve
.PP
This adds a new excluded version.  For example, you might use these three
method calls:
.PP
.Vb 2
\&  $req\->add_minimum( $module => \*(Aq1.00\*(Aq );
\&  $req\->add_maximum( $module => \*(Aq1.82\*(Aq );
\&
\&  $req\->add_exclusion( $module => \*(Aq1.75\*(Aq );
.Ve
.PP
Any version between 1.00 and 1.82 inclusive would be acceptable, except for
1.75.
.PP
This method returns the requirements object.
.SS "exact_version"
.IX Subsection "exact_version"
.Vb 1
\&  $req\->exact_version( $module => $version );
.Ve
.PP
This sets the version required for the given module to \fIexactly\fR the given
version.  No other version would be considered acceptable.
.PP
This method returns the requirements object.
.SS "add_requirements"
.IX Subsection "add_requirements"
.Vb 1
\&  $req\->add_requirements( $another_req_object );
.Ve
.PP
This method adds all the requirements in the given Version::Requirements object
to the requirements object on which it was called.  If there are any conflicts,
an exception is thrown.
.PP
This method returns the requirements object.
.SS "accepts_module"
.IX Subsection "accepts_module"
.Vb 1
\&  my $bool = $req\->accepts_modules($module => $version);
.Ve
.PP
Given an module and version, this method returns true if the version
specification for the module accepts the provided version.  In other words,
given:
.PP
.Vb 1
\&  Module => \*(Aq>= 1.00, < 2.00\*(Aq
.Ve
.PP
We will accept 1.00 and 1.75 but not 0.50 or 2.00.
.PP
For modules that do not appear in the requirements, this method will return
true.
.SS "clear_requirement"
.IX Subsection "clear_requirement"
.Vb 1
\&  $req\->clear_requirement( $module );
.Ve
.PP
This removes the requirement for a given module from the object.
.PP
This method returns the requirements object.
.SS "required_modules"
.IX Subsection "required_modules"
This method returns a list of all the modules for which requirements have been
specified.
.SS "clone"
.IX Subsection "clone"
.Vb 1
\&  $req\->clone;
.Ve
.PP
This method returns a clone of the invocant.  The clone and the original object
can then be changed independent of one another.
.SS "is_simple"
.IX Subsection "is_simple"
This method returns true if and only if all requirements are inclusive minimums
\&\*(-- that is, if their string expression is just the version number.
.SS "is_finalized"
.IX Subsection "is_finalized"
This method returns true if the requirements have been finalized by having the
\&\f(CW\*(C`finalize\*(C'\fR method called on them.
.SS "finalize"
.IX Subsection "finalize"
This method marks the requirements finalized.  Subsequent attempts to change
the requirements will be fatal, \fIif\fR they would result in a change.  If they
would not alter the requirements, they have no effect.
.PP
If a finalized set of requirements is cloned, the cloned requirements are not
also finalized.
.SS "as_string_hash"
.IX Subsection "as_string_hash"
This returns a reference to a hash describing the requirements using the
strings in the \fI\s-1META\s0.yml\fR specification.
.PP
For example after the following program:
.PP
.Vb 1
\&  my $req = Version::Requirements\->new;
\&
\&  $req\->add_minimum(\*(AqVersion::Requirements\*(Aq => 0.102);
\&
\&  $req\->add_minimum(\*(AqLibrary::Foo\*(Aq => 1.208);
\&
\&  $req\->add_maximum(\*(AqLibrary::Foo\*(Aq => 2.602);
\&
\&  $req\->add_minimum(\*(AqModule::Bar\*(Aq  => \*(Aqv1.2.3\*(Aq);
\&
\&  $req\->add_exclusion(\*(AqModule::Bar\*(Aq  => \*(Aqv1.2.8\*(Aq);
\&
\&  $req\->exact_version(\*(AqXyzzy\*(Aq  => \*(Aq6.01\*(Aq);
\&
\&  my $hashref = $req\->as_string_hash;
.Ve
.PP
\&\f(CW$hashref\fR would contain:
.PP
.Vb 6
\&  {
\&    \*(AqVersion::Requirements\*(Aq => \*(Aq0.102\*(Aq,
\&    \*(AqLibrary::Foo\*(Aq => \*(Aq>= 1.208, <= 2.206\*(Aq,
\&    \*(AqModule::Bar\*(Aq  => \*(Aq>= v1.2.3, != v1.2.8\*(Aq,
\&    \*(AqXyzzy\*(Aq        => \*(Aq== 6.01\*(Aq,
\&  }
.Ve
.SS "from_string_hash"
.IX Subsection "from_string_hash"
.Vb 1
\&  my $req = Version::Requirements\->from_string_hash( \e%hash );
.Ve
.PP
This is an alternate constructor for a Version::Requirements object.  It takes
a hash of module names and version requirement strings and returns a new
Version::Requirements object.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Version::Requirements5.16.3pm                0100644 0001750 0001750 00000024256 12566207442 026041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Version::Requirements 3pm"
.TH Version::Requirements 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Version::Requirements \- a set of version requirements for a CPAN dist
.SH "VERSION"
.IX Header "VERSION"
version 0.101022
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Version::Requirements;
\&
\&  my $build_requires = Version::Requirements\->new;
\&
\&  $build_requires\->add_minimum(\*(AqLibrary::Foo\*(Aq => 1.208);
\&
\&  $build_requires\->add_minimum(\*(AqLibrary::Foo\*(Aq => 2.602);
\&
\&  $build_requires\->add_minimum(\*(AqModule::Bar\*(Aq  => \*(Aqv1.2.3\*(Aq);
\&
\&  $METAyml\->{build_requires} = $build_requires\->as_string_hash;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Version::Requirements object models a set of version constraints like those
specified in the \fI\s-1META\s0.yml\fR or \fI\s-1META\s0.json\fR files in \s-1CPAN\s0 distributions.  It
can be built up by adding more and more constraints, and it will reduce them to
the simplest representation.
.PP
Logically impossible constraints will be identified immediately by thrown
exceptions.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $req = Version::Requirements\->new;
.Ve
.PP
This returns a new Version::Requirements object.  It ignores any arguments
given.
.SS "add_minimum"
.IX Subsection "add_minimum"
.Vb 1
\&  $req\->add_minimum( $module => $version );
.Ve
.PP
This adds a new minimum version requirement.  If the new requirement is
redundant to the existing specification, this has no effect.
.PP
Minimum requirements are inclusive.  \f(CW$version\fR is required, along with any
greater version number.
.PP
This method returns the requirements object.
.SS "add_maximum"
.IX Subsection "add_maximum"
.Vb 1
\&  $req\->add_maximum( $module => $version );
.Ve
.PP
This adds a new maximum version requirement.  If the new requirement is
redundant to the existing specification, this has no effect.
.PP
Maximum requirements are inclusive.  No version strictly greater than the given
version is allowed.
.PP
This method returns the requirements object.
.SS "add_exclusion"
.IX Subsection "add_exclusion"
.Vb 1
\&  $req\->add_exclusion( $module => $version );
.Ve
.PP
This adds a new excluded version.  For example, you might use these three
method calls:
.PP
.Vb 2
\&  $req\->add_minimum( $module => \*(Aq1.00\*(Aq );
\&  $req\->add_maximum( $module => \*(Aq1.82\*(Aq );
\&
\&  $req\->add_exclusion( $module => \*(Aq1.75\*(Aq );
.Ve
.PP
Any version between 1.00 and 1.82 inclusive would be acceptable, except for
1.75.
.PP
This method returns the requirements object.
.SS "exact_version"
.IX Subsection "exact_version"
.Vb 1
\&  $req\->exact_version( $module => $version );
.Ve
.PP
This sets the version required for the given module to \fIexactly\fR the given
version.  No other version would be considered acceptable.
.PP
This method returns the requirements object.
.SS "add_requirements"
.IX Subsection "add_requirements"
.Vb 1
\&  $req\->add_requirements( $another_req_object );
.Ve
.PP
This method adds all the requirements in the given Version::Requirements object
to the requirements object on which it was called.  If there are any conflicts,
an exception is thrown.
.PP
This method returns the requirements object.
.SS "accepts_module"
.IX Subsection "accepts_module"
.Vb 1
\&  my $bool = $req\->accepts_modules($module => $version);
.Ve
.PP
Given an module and version, this method returns true if the version
specification for the module accepts the provided version.  In other words,
given:
.PP
.Vb 1
\&  Module => \*(Aq>= 1.00, < 2.00\*(Aq
.Ve
.PP
We will accept 1.00 and 1.75 but not 0.50 or 2.00.
.PP
For modules that do not appear in the requirements, this method will return
true.
.SS "clear_requirement"
.IX Subsection "clear_requirement"
.Vb 1
\&  $req\->clear_requirement( $module );
.Ve
.PP
This removes the requirement for a given module from the object.
.PP
This method returns the requirements object.
.SS "required_modules"
.IX Subsection "required_modules"
This method returns a list of all the modules for which requirements have been
specified.
.SS "clone"
.IX Subsection "clone"
.Vb 1
\&  $req\->clone;
.Ve
.PP
This method returns a clone of the invocant.  The clone and the original object
can then be changed independent of one another.
.SS "is_simple"
.IX Subsection "is_simple"
This method returns true if and only if all requirements are inclusive minimums
\&\*(-- that is, if their string expression is just the version number.
.SS "is_finalized"
.IX Subsection "is_finalized"
This method returns true if the requirements have been finalized by having the
\&\f(CW\*(C`finalize\*(C'\fR method called on them.
.SS "finalize"
.IX Subsection "finalize"
This method marks the requirements finalized.  Subsequent attempts to change
the requirements will be fatal, \fIif\fR they would result in a change.  If they
would not alter the requirements, they have no effect.
.PP
If a finalized set of requirements is cloned, the cloned requirements are not
also finalized.
.SS "as_string_hash"
.IX Subsection "as_string_hash"
This returns a reference to a hash describing the requirements using the
strings in the \fI\s-1META\s0.yml\fR specification.
.PP
For example after the following program:
.PP
.Vb 1
\&  my $req = Version::Requirements\->new;
\&
\&  $req\->add_minimum(\*(AqVersion::Requirements\*(Aq => 0.102);
\&
\&  $req\->add_minimum(\*(AqLibrary::Foo\*(Aq => 1.208);
\&
\&  $req\->add_maximum(\*(AqLibrary::Foo\*(Aq => 2.602);
\&
\&  $req\->add_minimum(\*(AqModule::Bar\*(Aq  => \*(Aqv1.2.3\*(Aq);
\&
\&  $req\->add_exclusion(\*(AqModule::Bar\*(Aq  => \*(Aqv1.2.8\*(Aq);
\&
\&  $req\->exact_version(\*(AqXyzzy\*(Aq  => \*(Aq6.01\*(Aq);
\&
\&  my $hashref = $req\->as_string_hash;
.Ve
.PP
\&\f(CW$hashref\fR would contain:
.PP
.Vb 6
\&  {
\&    \*(AqVersion::Requirements\*(Aq => \*(Aq0.102\*(Aq,
\&    \*(AqLibrary::Foo\*(Aq => \*(Aq>= 1.208, <= 2.206\*(Aq,
\&    \*(AqModule::Bar\*(Aq  => \*(Aq>= v1.2.3, != v1.2.8\*(Aq,
\&    \*(AqXyzzy\*(Aq        => \*(Aq== 6.01\*(Aq,
\&  }
.Ve
.SS "from_string_hash"
.IX Subsection "from_string_hash"
.Vb 1
\&  my $req = Version::Requirements\->from_string_hash( \e%hash );
.Ve
.PP
This is an alternate constructor for a Version::Requirements object.  It takes
a hash of module names and version requirement strings and returns a new
Version::Requirements object.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/WWW::RobotRules.3pm                          0100644 0001750 0001750 00000023250 12566241325 024172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::RobotRules 3"
.TH WWW::RobotRules 3 "2012-02-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::RobotRules \- database of robots.txt\-derived permissions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use WWW::RobotRules;
\& my $rules = WWW::RobotRules\->new(\*(AqMOMspider/1.0\*(Aq);
\&
\& use LWP::Simple qw(get);
\&
\& {
\&   my $url = "http://some.place/robots.txt";
\&   my $robots_txt = get $url;
\&   $rules\->parse($url, $robots_txt) if defined $robots_txt;
\& }
\&
\& {
\&   my $url = "http://some.other.place/robots.txt";
\&   my $robots_txt = get $url;
\&   $rules\->parse($url, $robots_txt) if defined $robots_txt;
\& }
\&
\& # Now we can check if a URL is valid for those servers
\& # whose "robots.txt" files we\*(Aqve gotten and parsed:
\& if($rules\->allowed($url)) {
\&     $c = get $url;
\&     ...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module parses \fI/robots.txt\fR files as specified in
\&\*(L"A Standard for Robot Exclusion\*(R", at
<http://www.robotstxt.org/wc/norobots.html>
Webmasters can use the \fI/robots.txt\fR file to forbid conforming
robots from accessing parts of their web site.
.PP
The parsed files are kept in a WWW::RobotRules object, and this object
provides methods to check if access to a given \s-1URL\s0 is prohibited.  The
same WWW::RobotRules object can be used for one or more parsed
\&\fI/robots.txt\fR files on any number of hosts.
.PP
The following methods are provided:
.ie n .IP "$rules = WWW::RobotRules\->new($robot_name)" 4
.el .IP "\f(CW$rules\fR = WWW::RobotRules\->new($robot_name)" 4
.IX Item "$rules = WWW::RobotRules->new($robot_name)"
This is the constructor for WWW::RobotRules objects.  The first
argument given to \fInew()\fR is the name of the robot.
.ie n .IP "$rules\->parse($robot_txt_url, $content, $fresh_until)" 4
.el .IP "\f(CW$rules\fR\->parse($robot_txt_url, \f(CW$content\fR, \f(CW$fresh_until\fR)" 4
.IX Item "$rules->parse($robot_txt_url, $content, $fresh_until)"
The \fIparse()\fR method takes as arguments the \s-1URL\s0 that was used to
retrieve the \fI/robots.txt\fR file, and the contents of the file.
.ie n .IP "$rules\->allowed($uri)" 4
.el .IP "\f(CW$rules\fR\->allowed($uri)" 4
.IX Item "$rules->allowed($uri)"
Returns \s-1TRUE\s0 if this robot is allowed to retrieve this \s-1URL.\s0
.ie n .IP "$rules\->agent([$name])" 4
.el .IP "\f(CW$rules\fR\->agent([$name])" 4
.IX Item "$rules->agent([$name])"
Get/set the agent name. \s-1NOTE:\s0 Changing the agent name will clear the robots.txt
rules and expire times out of the cache.
.SH "ROBOTS.TXT"
.IX Header "ROBOTS.TXT"
The format and semantics of the \*(L"/robots.txt\*(R" file are as follows
(this is an edited abstract of
<http://www.robotstxt.org/wc/norobots.html>):
.PP
The file consists of one or more records separated by one or more
blank lines. Each record contains lines of the form
.PP
.Vb 1
\&  <field\-name>: <value>
.Ve
.PP
The field name is case insensitive.  Text after the '#' character on a
line is ignored during parsing.  This is used for comments.  The
following <field\-names> can be used:
.IP "User-Agent" 3
.IX Item "User-Agent"
The value of this field is the name of the robot the record is
describing access policy for.  If more than one \fIUser-Agent\fR field is
present the record describes an identical access policy for more than
one robot. At least one field needs to be present per record.  If the
value is '*', the record describes the default access policy for any
robot that has not not matched any of the other records.
.Sp
The \fIUser-Agent\fR fields must occur before the \fIDisallow\fR fields.  If a
record contains a \fIUser-Agent\fR field after a \fIDisallow\fR field, that
constitutes a malformed record.  This parser will assume that a blank
line should have been placed before that \fIUser-Agent\fR field, and will
break the record into two.  All the fields before the \fIUser-Agent\fR field
will constitute a record, and the \fIUser-Agent\fR field will be the first
field in a new record.
.IP "Disallow" 3
.IX Item "Disallow"
The value of this field specifies a partial \s-1URL\s0 that is not to be
visited. This can be a full path, or a partial path; any \s-1URL\s0 that
starts with this value will not be retrieved
.PP
Unrecognized records are ignored.
.SH "ROBOTS.TXT EXAMPLES"
.IX Header "ROBOTS.TXT EXAMPLES"
The following example \*(L"/robots.txt\*(R" file specifies that no robots
should visit any \s-1URL\s0 starting with \*(L"/cyberworld/map/\*(R" or \*(L"/tmp/\*(R":
.PP
.Vb 3
\&  User\-agent: *
\&  Disallow: /cyberworld/map/ # This is an infinite virtual URL space
\&  Disallow: /tmp/ # these will soon disappear
.Ve
.PP
This example \*(L"/robots.txt\*(R" file specifies that no robots should visit
any \s-1URL\s0 starting with \*(L"/cyberworld/map/\*(R", except the robot called
\&\*(L"cybermapper\*(R":
.PP
.Vb 2
\&  User\-agent: *
\&  Disallow: /cyberworld/map/ # This is an infinite virtual URL space
\&
\&  # Cybermapper knows where to go.
\&  User\-agent: cybermapper
\&  Disallow:
.Ve
.PP
This example indicates that no robots should visit this site further:
.PP
.Vb 3
\&  # go away
\&  User\-agent: *
\&  Disallow: /
.Ve
.PP
This is an example of a malformed robots.txt file.
.PP
.Vb 10
\&  # robots.txt for ancientcastle.example.com
\&  # I\*(Aqve locked myself away.
\&  User\-agent: *
\&  Disallow: /
\&  # The castle is your home now, so you can go anywhere you like.
\&  User\-agent: Belle
\&  Disallow: /west\-wing/ # except the west wing!
\&  # It\*(Aqs good to be the Prince...
\&  User\-agent: Beast
\&  Disallow:
.Ve
.PP
This file is missing the required blank lines between records.
However, the intention is clear.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
LWP::RobotUA, WWW::RobotRules::AnyDBM_File
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\&  Copyright 1995\-2009, Gisle Aas
\&  Copyright 1995, Martijn Koster
.Ve
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/WWW::RobotRules5.16.3pm                      0100644 0001750 0001750 00000022727 12566241326 024515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::RobotRules 3"
.TH WWW::RobotRules 3 "2012-02-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::RobotRules \- database of robots.txt\-derived permissions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use WWW::RobotRules;
\& my $rules = WWW::RobotRules\->new(\*(AqMOMspider/1.0\*(Aq);
\&
\& use LWP::Simple qw(get);
\&
\& {
\&   my $url = "http://some.place/robots.txt";
\&   my $robots_txt = get $url;
\&   $rules\->parse($url, $robots_txt) if defined $robots_txt;
\& }
\&
\& {
\&   my $url = "http://some.other.place/robots.txt";
\&   my $robots_txt = get $url;
\&   $rules\->parse($url, $robots_txt) if defined $robots_txt;
\& }
\&
\& # Now we can check if a URL is valid for those servers
\& # whose "robots.txt" files we\*(Aqve gotten and parsed:
\& if($rules\->allowed($url)) {
\&     $c = get $url;
\&     ...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module parses \fI/robots.txt\fR files as specified in
\&\*(L"A Standard for Robot Exclusion\*(R", at
<http://www.robotstxt.org/wc/norobots.html>
Webmasters can use the \fI/robots.txt\fR file to forbid conforming
robots from accessing parts of their web site.
.PP
The parsed files are kept in a WWW::RobotRules object, and this object
provides methods to check if access to a given \s-1URL\s0 is prohibited.  The
same WWW::RobotRules object can be used for one or more parsed
\&\fI/robots.txt\fR files on any number of hosts.
.PP
The following methods are provided:
.ie n .IP "$rules = WWW::RobotRules\->new($robot_name)" 4
.el .IP "\f(CW$rules\fR = WWW::RobotRules\->new($robot_name)" 4
.IX Item "$rules = WWW::RobotRules->new($robot_name)"
This is the constructor for WWW::RobotRules objects.  The first
argument given to \fInew()\fR is the name of the robot.
.ie n .IP "$rules\->parse($robot_txt_url, $content, $fresh_until)" 4
.el .IP "\f(CW$rules\fR\->parse($robot_txt_url, \f(CW$content\fR, \f(CW$fresh_until\fR)" 4
.IX Item "$rules->parse($robot_txt_url, $content, $fresh_until)"
The \fIparse()\fR method takes as arguments the \s-1URL\s0 that was used to
retrieve the \fI/robots.txt\fR file, and the contents of the file.
.ie n .IP "$rules\->allowed($uri)" 4
.el .IP "\f(CW$rules\fR\->allowed($uri)" 4
.IX Item "$rules->allowed($uri)"
Returns \s-1TRUE\s0 if this robot is allowed to retrieve this \s-1URL\s0.
.ie n .IP "$rules\->agent([$name])" 4
.el .IP "\f(CW$rules\fR\->agent([$name])" 4
.IX Item "$rules->agent([$name])"
Get/set the agent name. \s-1NOTE:\s0 Changing the agent name will clear the robots.txt
rules and expire times out of the cache.
.SH "ROBOTS.TXT"
.IX Header "ROBOTS.TXT"
The format and semantics of the \*(L"/robots.txt\*(R" file are as follows
(this is an edited abstract of
<http://www.robotstxt.org/wc/norobots.html>):
.PP
The file consists of one or more records separated by one or more
blank lines. Each record contains lines of the form
.PP
.Vb 1
\&  <field\-name>: <value>
.Ve
.PP
The field name is case insensitive.  Text after the '#' character on a
line is ignored during parsing.  This is used for comments.  The
following <field\-names> can be used:
.IP "User-Agent" 3
.IX Item "User-Agent"
The value of this field is the name of the robot the record is
describing access policy for.  If more than one \fIUser-Agent\fR field is
present the record describes an identical access policy for more than
one robot. At least one field needs to be present per record.  If the
value is '*', the record describes the default access policy for any
robot that has not not matched any of the other records.
.Sp
The \fIUser-Agent\fR fields must occur before the \fIDisallow\fR fields.  If a
record contains a \fIUser-Agent\fR field after a \fIDisallow\fR field, that
constitutes a malformed record.  This parser will assume that a blank
line should have been placed before that \fIUser-Agent\fR field, and will
break the record into two.  All the fields before the \fIUser-Agent\fR field
will constitute a record, and the \fIUser-Agent\fR field will be the first
field in a new record.
.IP "Disallow" 3
.IX Item "Disallow"
The value of this field specifies a partial \s-1URL\s0 that is not to be
visited. This can be a full path, or a partial path; any \s-1URL\s0 that
starts with this value will not be retrieved
.PP
Unrecognized records are ignored.
.SH "ROBOTS.TXT EXAMPLES"
.IX Header "ROBOTS.TXT EXAMPLES"
The following example \*(L"/robots.txt\*(R" file specifies that no robots
should visit any \s-1URL\s0 starting with \*(L"/cyberworld/map/\*(R" or \*(L"/tmp/\*(R":
.PP
.Vb 3
\&  User\-agent: *
\&  Disallow: /cyberworld/map/ # This is an infinite virtual URL space
\&  Disallow: /tmp/ # these will soon disappear
.Ve
.PP
This example \*(L"/robots.txt\*(R" file specifies that no robots should visit
any \s-1URL\s0 starting with \*(L"/cyberworld/map/\*(R", except the robot called
\&\*(L"cybermapper\*(R":
.PP
.Vb 2
\&  User\-agent: *
\&  Disallow: /cyberworld/map/ # This is an infinite virtual URL space
\&
\&  # Cybermapper knows where to go.
\&  User\-agent: cybermapper
\&  Disallow:
.Ve
.PP
This example indicates that no robots should visit this site further:
.PP
.Vb 3
\&  # go away
\&  User\-agent: *
\&  Disallow: /
.Ve
.PP
This is an example of a malformed robots.txt file.
.PP
.Vb 10
\&  # robots.txt for ancientcastle.example.com
\&  # I\*(Aqve locked myself away.
\&  User\-agent: *
\&  Disallow: /
\&  # The castle is your home now, so you can go anywhere you like.
\&  User\-agent: Belle
\&  Disallow: /west\-wing/ # except the west wing!
\&  # It\*(Aqs good to be the Prince...
\&  User\-agent: Beast
\&  Disallow:
.Ve
.PP
This file is missing the required blank lines between records.
However, the intention is clear.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
LWP::RobotUA, WWW::RobotRules::AnyDBM_File
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\&  Copyright 1995\-2009, Gisle Aas
\&  Copyright 1995, Martijn Koster
.Ve
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/WWW::RobotRules5.18.3pm                      0100644 0001750 0001750 00000023250 12566241325 024506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::RobotRules 3"
.TH WWW::RobotRules 3 "2012-02-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::RobotRules \- database of robots.txt\-derived permissions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use WWW::RobotRules;
\& my $rules = WWW::RobotRules\->new(\*(AqMOMspider/1.0\*(Aq);
\&
\& use LWP::Simple qw(get);
\&
\& {
\&   my $url = "http://some.place/robots.txt";
\&   my $robots_txt = get $url;
\&   $rules\->parse($url, $robots_txt) if defined $robots_txt;
\& }
\&
\& {
\&   my $url = "http://some.other.place/robots.txt";
\&   my $robots_txt = get $url;
\&   $rules\->parse($url, $robots_txt) if defined $robots_txt;
\& }
\&
\& # Now we can check if a URL is valid for those servers
\& # whose "robots.txt" files we\*(Aqve gotten and parsed:
\& if($rules\->allowed($url)) {
\&     $c = get $url;
\&     ...
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module parses \fI/robots.txt\fR files as specified in
\&\*(L"A Standard for Robot Exclusion\*(R", at
<http://www.robotstxt.org/wc/norobots.html>
Webmasters can use the \fI/robots.txt\fR file to forbid conforming
robots from accessing parts of their web site.
.PP
The parsed files are kept in a WWW::RobotRules object, and this object
provides methods to check if access to a given \s-1URL\s0 is prohibited.  The
same WWW::RobotRules object can be used for one or more parsed
\&\fI/robots.txt\fR files on any number of hosts.
.PP
The following methods are provided:
.ie n .IP "$rules = WWW::RobotRules\->new($robot_name)" 4
.el .IP "\f(CW$rules\fR = WWW::RobotRules\->new($robot_name)" 4
.IX Item "$rules = WWW::RobotRules->new($robot_name)"
This is the constructor for WWW::RobotRules objects.  The first
argument given to \fInew()\fR is the name of the robot.
.ie n .IP "$rules\->parse($robot_txt_url, $content, $fresh_until)" 4
.el .IP "\f(CW$rules\fR\->parse($robot_txt_url, \f(CW$content\fR, \f(CW$fresh_until\fR)" 4
.IX Item "$rules->parse($robot_txt_url, $content, $fresh_until)"
The \fIparse()\fR method takes as arguments the \s-1URL\s0 that was used to
retrieve the \fI/robots.txt\fR file, and the contents of the file.
.ie n .IP "$rules\->allowed($uri)" 4
.el .IP "\f(CW$rules\fR\->allowed($uri)" 4
.IX Item "$rules->allowed($uri)"
Returns \s-1TRUE\s0 if this robot is allowed to retrieve this \s-1URL.\s0
.ie n .IP "$rules\->agent([$name])" 4
.el .IP "\f(CW$rules\fR\->agent([$name])" 4
.IX Item "$rules->agent([$name])"
Get/set the agent name. \s-1NOTE:\s0 Changing the agent name will clear the robots.txt
rules and expire times out of the cache.
.SH "ROBOTS.TXT"
.IX Header "ROBOTS.TXT"
The format and semantics of the \*(L"/robots.txt\*(R" file are as follows
(this is an edited abstract of
<http://www.robotstxt.org/wc/norobots.html>):
.PP
The file consists of one or more records separated by one or more
blank lines. Each record contains lines of the form
.PP
.Vb 1
\&  <field\-name>: <value>
.Ve
.PP
The field name is case insensitive.  Text after the '#' character on a
line is ignored during parsing.  This is used for comments.  The
following <field\-names> can be used:
.IP "User-Agent" 3
.IX Item "User-Agent"
The value of this field is the name of the robot the record is
describing access policy for.  If more than one \fIUser-Agent\fR field is
present the record describes an identical access policy for more than
one robot. At least one field needs to be present per record.  If the
value is '*', the record describes the default access policy for any
robot that has not not matched any of the other records.
.Sp
The \fIUser-Agent\fR fields must occur before the \fIDisallow\fR fields.  If a
record contains a \fIUser-Agent\fR field after a \fIDisallow\fR field, that
constitutes a malformed record.  This parser will assume that a blank
line should have been placed before that \fIUser-Agent\fR field, and will
break the record into two.  All the fields before the \fIUser-Agent\fR field
will constitute a record, and the \fIUser-Agent\fR field will be the first
field in a new record.
.IP "Disallow" 3
.IX Item "Disallow"
The value of this field specifies a partial \s-1URL\s0 that is not to be
visited. This can be a full path, or a partial path; any \s-1URL\s0 that
starts with this value will not be retrieved
.PP
Unrecognized records are ignored.
.SH "ROBOTS.TXT EXAMPLES"
.IX Header "ROBOTS.TXT EXAMPLES"
The following example \*(L"/robots.txt\*(R" file specifies that no robots
should visit any \s-1URL\s0 starting with \*(L"/cyberworld/map/\*(R" or \*(L"/tmp/\*(R":
.PP
.Vb 3
\&  User\-agent: *
\&  Disallow: /cyberworld/map/ # This is an infinite virtual URL space
\&  Disallow: /tmp/ # these will soon disappear
.Ve
.PP
This example \*(L"/robots.txt\*(R" file specifies that no robots should visit
any \s-1URL\s0 starting with \*(L"/cyberworld/map/\*(R", except the robot called
\&\*(L"cybermapper\*(R":
.PP
.Vb 2
\&  User\-agent: *
\&  Disallow: /cyberworld/map/ # This is an infinite virtual URL space
\&
\&  # Cybermapper knows where to go.
\&  User\-agent: cybermapper
\&  Disallow:
.Ve
.PP
This example indicates that no robots should visit this site further:
.PP
.Vb 3
\&  # go away
\&  User\-agent: *
\&  Disallow: /
.Ve
.PP
This is an example of a malformed robots.txt file.
.PP
.Vb 10
\&  # robots.txt for ancientcastle.example.com
\&  # I\*(Aqve locked myself away.
\&  User\-agent: *
\&  Disallow: /
\&  # The castle is your home now, so you can go anywhere you like.
\&  User\-agent: Belle
\&  Disallow: /west\-wing/ # except the west wing!
\&  # It\*(Aqs good to be the Prince...
\&  User\-agent: Beast
\&  Disallow:
.Ve
.PP
This file is missing the required blank lines between records.
However, the intention is clear.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
LWP::RobotUA, WWW::RobotRules::AnyDBM_File
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\&  Copyright 1995\-2009, Gisle Aas
\&  Copyright 1995, Martijn Koster
.Ve
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/WWW::RobotRules::AnyDBM_File.3pm             0100644 0001750 0001750 00000012057 12566241325 026313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::RobotRules::AnyDBM_File 3"
.TH WWW::RobotRules::AnyDBM_File 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::RobotRules::AnyDBM_File \- Persistent RobotRules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require WWW::RobotRules::AnyDBM_File;
\& require LWP::RobotUA;
\&
\& # Create a robot useragent that uses a diskcaching RobotRules
\& my $rules = WWW::RobotRules::AnyDBM_File\->new( \*(Aqmy\-robot/1.0\*(Aq, \*(Aqcachefile\*(Aq );
\& my $ua = WWW::RobotUA\->new( \*(Aqmy\-robot/1.0\*(Aq, \*(Aqme@foo.com\*(Aq, $rules );
\&
\& # Then just use $ua as usual
\& $res = $ua\->request($req);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \fIWWW::RobotRules\fR that uses the AnyDBM_File
package to implement persistent diskcaching of \fIrobots.txt\fR and host
visit information.
.PP
The constructor (the \fInew()\fR method) takes an extra argument specifying
the name of the \s-1DBM\s0 file to use.  If the \s-1DBM\s0 file already exists, then
you can specify undef as agent name as the name can be obtained from
the \s-1DBM\s0 database.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
WWW::RobotRules, LWP::RobotUA
.SH "AUTHORS"
.IX Header "AUTHORS"
Hakan Ardo <hakan@munin.ub2.lu.se>, Gisle Aas <aas@sn.no>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/WWW::RobotRules::AnyDBM_File5.16.3pm         0100644 0001750 0001750 00000011536 12566241326 026627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::RobotRules::AnyDBM_File 3"
.TH WWW::RobotRules::AnyDBM_File 3 "2012-02-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::RobotRules::AnyDBM_File \- Persistent RobotRules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require WWW::RobotRules::AnyDBM_File;
\& require LWP::RobotUA;
\&
\& # Create a robot useragent that uses a diskcaching RobotRules
\& my $rules = WWW::RobotRules::AnyDBM_File\->new( \*(Aqmy\-robot/1.0\*(Aq, \*(Aqcachefile\*(Aq );
\& my $ua = WWW::RobotUA\->new( \*(Aqmy\-robot/1.0\*(Aq, \*(Aqme@foo.com\*(Aq, $rules );
\&
\& # Then just use $ua as usual
\& $res = $ua\->request($req);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \fIWWW::RobotRules\fR that uses the AnyDBM_File
package to implement persistent diskcaching of \fIrobots.txt\fR and host
visit information.
.PP
The constructor (the \fInew()\fR method) takes an extra argument specifying
the name of the \s-1DBM\s0 file to use.  If the \s-1DBM\s0 file already exists, then
you can specify undef as agent name as the name can be obtained from
the \s-1DBM\s0 database.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
WWW::RobotRules, LWP::RobotUA
.SH "AUTHORS"
.IX Header "AUTHORS"
Hakan Ardo <hakan@munin.ub2.lu.se>, Gisle Aas <aas@sn.no>
                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/WWW::RobotRules::AnyDBM_File5.18.3pm         0100644 0001750 0001750 00000012057 12566241325 026627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "WWW::RobotRules::AnyDBM_File 3"
.TH WWW::RobotRules::AnyDBM_File 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
WWW::RobotRules::AnyDBM_File \- Persistent RobotRules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require WWW::RobotRules::AnyDBM_File;
\& require LWP::RobotUA;
\&
\& # Create a robot useragent that uses a diskcaching RobotRules
\& my $rules = WWW::RobotRules::AnyDBM_File\->new( \*(Aqmy\-robot/1.0\*(Aq, \*(Aqcachefile\*(Aq );
\& my $ua = WWW::RobotUA\->new( \*(Aqmy\-robot/1.0\*(Aq, \*(Aqme@foo.com\*(Aq, $rules );
\&
\& # Then just use $ua as usual
\& $res = $ua\->request($req);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \fIWWW::RobotRules\fR that uses the AnyDBM_File
package to implement persistent diskcaching of \fIrobots.txt\fR and host
visit information.
.PP
The constructor (the \fInew()\fR method) takes an extra argument specifying
the name of the \s-1DBM\s0 file to use.  If the \s-1DBM\s0 file already exists, then
you can specify undef as agent name as the name can be obtained from
the \s-1DBM\s0 database.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
WWW::RobotRules, LWP::RobotUA
.SH "AUTHORS"
.IX Header "AUTHORS"
Hakan Ardo <hakan@munin.ub2.lu.se>, Gisle Aas <aas@sn.no>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Win32::DBIODBC.3pm                           0100644 0001750 0001750 00000011221 12566241600 023325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Win32::DBIODBC 3"
.TH Win32::DBIODBC 3 "2013-05-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Win32::DBIODBC \- Win32::ODBC emulation layer for the DBI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Win32::DBIODBC;     # instead of use Win32::ODBC
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIvery\fR basic \fIvery\fR alpha quality Win32::ODBC emulation
for the \s-1DBI.\s0 To use it just replace
.PP
.Vb 1
\&        use Win32::ODBC;
.Ve
.PP
in your scripts with
.PP
.Vb 1
\&        use Win32::DBIODBC;
.Ve
.PP
or, while experimenting, you can pre-load this module without changing your
scripts by doing
.PP
.Vb 1
\&        perl \-MWin32::DBIODBC your_script_name
.Ve
.SH "TO DO"
.IX Header "TO DO"
Error handling is virtually non-existent.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Horen <tho@melexis.com>
                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Win32::DBIODBC5.16.3pm                       0100644 0001750 0001750 00000010700 12566241600 023640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Win32::DBIODBC 3"
.TH Win32::DBIODBC 3 "2010-06-08" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Win32::DBIODBC \- Win32::ODBC emulation layer for the DBI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Win32::DBIODBC;     # instead of use Win32::ODBC
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIvery\fR basic \fIvery\fR alpha quality Win32::ODBC emulation
for the \s-1DBI\s0. To use it just replace
.PP
.Vb 1
\&        use Win32::ODBC;
.Ve
.PP
in your scripts with
.PP
.Vb 1
\&        use Win32::DBIODBC;
.Ve
.PP
or, while experimenting, you can pre-load this module without changing your
scripts by doing
.PP
.Vb 1
\&        perl \-MWin32::DBIODBC your_script_name
.Ve
.SH "TO DO"
.IX Header "TO DO"
Error handling is virtually non-existent.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Horen <tho@melexis.com>
                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Win32::DBIODBC5.18.3pm                       0100644 0001750 0001750 00000011221 12566241600 023641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Win32::DBIODBC 3"
.TH Win32::DBIODBC 3 "2013-05-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Win32::DBIODBC \- Win32::ODBC emulation layer for the DBI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Win32::DBIODBC;     # instead of use Win32::ODBC
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a \fIvery\fR basic \fIvery\fR alpha quality Win32::ODBC emulation
for the \s-1DBI.\s0 To use it just replace
.PP
.Vb 1
\&        use Win32::ODBC;
.Ve
.PP
in your scripts with
.PP
.Vb 1
\&        use Win32::DBIODBC;
.Ve
.PP
or, while experimenting, you can pre-load this module without changing your
scripts by doing
.PP
.Vb 1
\&        perl \-MWin32::DBIODBC your_script_name
.Ve
.SH "TO DO"
.IX Header "TO DO"
Error handling is virtually non-existent.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Horen <tho@melexis.com>
                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_ENTRY_create_by_NID.3ssl           0120777 0001750 0001750 00000000000 12620245063 033633  2X509_NAME_ENTRY_get_object.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_ENTRY_create_by_OBJ.3ssl           0120777 0001750 0001750 00000000000 12620245063 033633  2X509_NAME_ENTRY_get_object.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_ENTRY_create_by_txt.3ssl           0120777 0001750 0001750 00000000000 12620245063 034040  2X509_NAME_ENTRY_get_object.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_ENTRY_get_data.3ssl                0120777 0001750 0001750 00000000000 12620245063 032754  2X509_NAME_ENTRY_get_object.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_ENTRY_get_object.3ssl              0100644 0001750 0001750 00000015706 12566201142 026101  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "X509_NAME_ENTRY_get_object 3"
.TH X509_NAME_ENTRY_get_object 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X509_NAME_ENTRY_get_object, X509_NAME_ENTRY_get_data,
X509_NAME_ENTRY_set_object, X509_NAME_ENTRY_set_data,
X509_NAME_ENTRY_create_by_txt, X509_NAME_ENTRY_create_by_NID,
X509_NAME_ENTRY_create_by_OBJ \- X509_NAME_ENTRY utility functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& ASN1_OBJECT * X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne);
\& ASN1_STRING * X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne);
\&
\& int X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, ASN1_OBJECT *obj);
\& int X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type, const unsigned char *bytes, int len);
\&
\& X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne, const char *field, int type, const unsigned char *bytes, int len);
\& X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid, int type,unsigned char *bytes, int len);
\& X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne, ASN1_OBJECT *obj, int type, const unsigned char *bytes, int len);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIX509_NAME_ENTRY_get_object()\fR retrieves the field name of \fBne\fR in
and \fB\s-1ASN1_OBJECT\s0\fR structure.
.PP
\&\fIX509_NAME_ENTRY_get_data()\fR retrieves the field value of \fBne\fR in
and \fB\s-1ASN1_STRING\s0\fR structure.
.PP
\&\fIX509_NAME_ENTRY_set_object()\fR sets the field name of \fBne\fR to \fBobj\fR.
.PP
\&\fIX509_NAME_ENTRY_set_data()\fR sets the field value of \fBne\fR to string type
\&\fBtype\fR and value determined by \fBbytes\fR and \fBlen\fR.
.PP
\&\fIX509_NAME_ENTRY_create_by_txt()\fR, \fIX509_NAME_ENTRY_create_by_NID()\fR
and \fIX509_NAME_ENTRY_create_by_OBJ()\fR create and return an 
\&\fBX509_NAME_ENTRY\fR structure.
.SH "NOTES"
.IX Header "NOTES"
\&\fIX509_NAME_ENTRY_get_object()\fR and \fIX509_NAME_ENTRY_get_data()\fR can be
used to examine an \fBX509_NAME_ENTRY\fR function as returned by 
\&\fIX509_NAME_get_entry()\fR for example.
.PP
\&\fIX509_NAME_ENTRY_create_by_txt()\fR, \fIX509_NAME_ENTRY_create_by_NID()\fR,
and \fIX509_NAME_ENTRY_create_by_OBJ()\fR create and return an
.PP
\&\fIX509_NAME_ENTRY_create_by_txt()\fR, \fIX509_NAME_ENTRY_create_by_OBJ()\fR,
\&\fIX509_NAME_ENTRY_create_by_NID()\fR and \fIX509_NAME_ENTRY_set_data()\fR
are seldom used in practice because \fBX509_NAME_ENTRY\fR structures
are almost always part of \fBX509_NAME\fR structures and the
corresponding \fBX509_NAME\fR functions are typically used to
create and add new entries in a single operation.
.PP
The arguments of these functions support similar options to the similarly
named ones of the corresponding \fBX509_NAME\fR functions such as
\&\fIX509_NAME_add_entry_by_txt()\fR. So for example \fBtype\fR can be set to
\&\fB\s-1MBSTRING_ASC\s0\fR but in the case of \fIX509_set_data()\fR the field name must be
set first so the relevant field information can be looked up internally.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fId2i_X509_NAME\fR\|(3),
\&\fIOBJ_nid2obj\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\s-1TBA\s0
                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_ENTRY_set_data.3ssl                0120777 0001750 0001750 00000000000 12620245063 032770  2X509_NAME_ENTRY_get_object.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_ENTRY_set_object.3ssl              0120777 0001750 0001750 00000000000 12620245063 033325  2X509_NAME_ENTRY_get_object.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_add_entry.3ssl                     0120777 0001750 0001750 00000000000 12620245063 032450  2X509_NAME_add_entry_by_txt.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_add_entry_by_NID.3ssl              0120777 0001750 0001750 00000000000 12620245063 033634  2X509_NAME_add_entry_by_txt.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_add_entry_by_OBJ.3ssl              0120777 0001750 0001750 00000000000 12620245063 033634  2X509_NAME_add_entry_by_txt.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_add_entry_by_txt.3ssl              0100644 0001750 0001750 00000020762 12566201143 026354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "X509_NAME_add_entry_by_txt 3"
.TH X509_NAME_add_entry_by_txt 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X509_NAME_add_entry_by_txt, X509_NAME_add_entry_by_OBJ, X509_NAME_add_entry_by_NID,
X509_NAME_add_entry, X509_NAME_delete_entry \- X509_NAME modification functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type, const unsigned char *bytes, int len, int loc, int set);
\&
\& int X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type, unsigned char *bytes, int len, int loc, int set);
\&
\& int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type, unsigned char *bytes, int len, int loc, int set);
\&
\& int X509_NAME_add_entry(X509_NAME *name,X509_NAME_ENTRY *ne, int loc, int set);
\&
\& X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIX509_NAME_add_entry_by_txt()\fR, \fIX509_NAME_add_entry_by_OBJ()\fR and
\&\fIX509_NAME_add_entry_by_NID()\fR add a field whose name is defined
by a string \fBfield\fR, an object \fBobj\fR or a \s-1NID \s0\fBnid\fR respectively.
The field value to be added is in \fBbytes\fR of length \fBlen\fR. If
\&\fBlen\fR is \-1 then the field length is calculated internally using
strlen(bytes).
.PP
The type of field is determined by \fBtype\fR which can either be a
definition of the type of \fBbytes\fR (such as \fB\s-1MBSTRING_ASC\s0\fR) or a
standard \s-1ASN1\s0 type (such as \fBV_ASN1_IA5STRING\fR). The new entry is
added to a position determined by \fBloc\fR and \fBset\fR.
.PP
\&\fIX509_NAME_add_entry()\fR adds a copy of \fBX509_NAME_ENTRY\fR structure \fBne\fR
to \fBname\fR. The new entry is added to a position determined by \fBloc\fR
and \fBset\fR. Since a copy of \fBne\fR is added \fBne\fR must be freed up after
the call.
.PP
\&\fIX509_NAME_delete_entry()\fR deletes an entry from \fBname\fR at position
\&\fBloc\fR. The deleted entry is returned and must be freed up.
.SH "NOTES"
.IX Header "NOTES"
The use of string types such as \fB\s-1MBSTRING_ASC\s0\fR or \fB\s-1MBSTRING_UTF8\s0\fR
is strongly recommened for the \fBtype\fR parameter. This allows the
internal code to correctly determine the type of the field and to
apply length checks according to the relevant standards. This is
done using \fIASN1_STRING_set_by_NID()\fR.
.PP
If instead an \s-1ASN1\s0 type is used no checks are performed and the
supplied data in \fBbytes\fR is used directly.
.PP
In \fIX509_NAME_add_entry_by_txt()\fR the \fBfield\fR string represents
the field name using OBJ_txt2obj(field, 0).
.PP
The \fBloc\fR and \fBset\fR parameters determine where a new entry should
be added. For almost all applications \fBloc\fR can be set to \-1 and \fBset\fR
to 0. This adds a new entry to the end of \fBname\fR as a single valued
RelativeDistinguishedName (\s-1RDN\s0).
.PP
\&\fBloc\fR actually determines the index where the new entry is inserted:
if it is \-1 it is appended.
.PP
\&\fBset\fR determines how the new type is added. If it is zero a
new \s-1RDN\s0 is created.
.PP
If \fBset\fR is \-1 or 1 it is added to the previous or next \s-1RDN\s0
structure respectively. This will then be a multivalued \s-1RDN:\s0
since multivalues RDNs are very seldom used \fBset\fR is almost
always set to zero.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Create an \fBX509_NAME\fR structure:
.PP
\&\*(L"C=UK, O=Disorganized Organization, CN=Joe Bloggs\*(R"
.PP
.Vb 10
\& X509_NAME *nm;
\& nm = X509_NAME_new();
\& if (nm == NULL)
\&        /* Some error */
\& if (!X509_NAME_add_entry_by_txt(nm, MBSTRING_ASC,
\&                        "C", "UK", \-1, \-1, 0))
\&        /* Error */
\& if (!X509_NAME_add_entry_by_txt(nm, MBSTRING_ASC,
\&                        "O", "Disorganized Organization", \-1, \-1, 0))
\&        /* Error */
\& if (!X509_NAME_add_entry_by_txt(nm, MBSTRING_ASC,
\&                        "CN", "Joe Bloggs", \-1, \-1, 0))
\&        /* Error */
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIX509_NAME_add_entry_by_txt()\fR, \fIX509_NAME_add_entry_by_OBJ()\fR,
\&\fIX509_NAME_add_entry_by_NID()\fR and \fIX509_NAME_add_entry()\fR return 1 for
success of 0 if an error occurred.
.PP
\&\fIX509_NAME_delete_entry()\fR returns either the deleted \fBX509_NAME_ENTRY\fR
structure of \fB\s-1NULL\s0\fR if an error occurred.
.SH "BUGS"
.IX Header "BUGS"
\&\fBtype\fR can still be set to \fBV_ASN1_APP_CHOOSE\fR to use a
different algorithm to determine field types. Since this form does
not understand multicharacter types, performs no length checks and
can result in invalid field types its use is strongly discouraged.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fId2i_X509_NAME\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_delete_entry.3ssl                  0120777 0001750 0001750 00000000000 12620245063 033162  2X509_NAME_add_entry_by_txt.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_entry_count.3ssl                   0120777 0001750 0001750 00000000000 12620245063 032640  2X509_NAME_get_index_by_NID.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_get_entry.3ssl                     0120777 0001750 0001750 00000000000 12620245063 032267  2X509_NAME_get_index_by_NID.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_get_index_by_NID.3ssl              0100644 0001750 0001750 00000017426 12566201143 026147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "X509_NAME_get_index_by_NID 3"
.TH X509_NAME_get_index_by_NID 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X509_NAME_get_index_by_NID, X509_NAME_get_index_by_OBJ, X509_NAME_get_entry,
X509_NAME_entry_count, X509_NAME_get_text_by_NID, X509_NAME_get_text_by_OBJ \-
X509_NAME lookup and enumeration functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& int X509_NAME_get_index_by_NID(X509_NAME *name,int nid,int lastpos);
\& int X509_NAME_get_index_by_OBJ(X509_NAME *name,ASN1_OBJECT *obj, int lastpos);
\&
\& int X509_NAME_entry_count(X509_NAME *name);
\& X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc);
\&
\& int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf,int len);
\& int X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf,int len);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These functions allow an \fBX509_NAME\fR structure to be examined. The
\&\fBX509_NAME\fR structure is the same as the \fBName\fR type defined in
\&\s-1RFC2459 \s0(and elsewhere) and used for example in certificate subject
and issuer names.
.PP
\&\fIX509_NAME_get_index_by_NID()\fR and \fIX509_NAME_get_index_by_OBJ()\fR retrieve
the next index matching \fBnid\fR or \fBobj\fR after \fBlastpos\fR. \fBlastpos\fR
should initially be set to \-1. If there are no more entries \-1 is returned.
.PP
\&\fIX509_NAME_entry_count()\fR returns the total number of entries in \fBname\fR.
.PP
\&\fIX509_NAME_get_entry()\fR retrieves the \fBX509_NAME_ENTRY\fR from \fBname\fR
corresponding to index \fBloc\fR. Acceptable values for \fBloc\fR run from
0 to (X509_NAME_entry_count(name) \- 1). The value returned is an
internal pointer which must not be freed.
.PP
\&\fIX509_NAME_get_text_by_NID()\fR, \fIX509_NAME_get_text_by_OBJ()\fR retrieve
the \*(L"text\*(R" from the first entry in \fBname\fR which matches \fBnid\fR or
\&\fBobj\fR, if no such entry exists \-1 is returned. At most \fBlen\fR bytes
will be written and the text written to \fBbuf\fR will be null
terminated. The length of the output string written is returned
excluding the terminating null. If \fBbuf\fR is <\s-1NULL\s0> then the amount
of space needed in \fBbuf\fR (excluding the final null) is returned.
.SH "NOTES"
.IX Header "NOTES"
\&\fIX509_NAME_get_text_by_NID()\fR and \fIX509_NAME_get_text_by_OBJ()\fR are
legacy functions which have various limitations which make them
of minimal use in practice. They can only find the first matching
entry and will copy the contents of the field verbatim: this can
be highly confusing if the target is a muticharacter string type
like a BMPString or a UTF8String.
.PP
For a more general solution \fIX509_NAME_get_index_by_NID()\fR or
\&\fIX509_NAME_get_index_by_OBJ()\fR should be used followed by
\&\fIX509_NAME_get_entry()\fR on any matching indices and then the
various \fBX509_NAME_ENTRY\fR utility functions on the result.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Process all entries:
.PP
.Vb 2
\& int i;
\& X509_NAME_ENTRY *e;
\&
\& for (i = 0; i < X509_NAME_entry_count(nm); i++)
\&        {
\&        e = X509_NAME_get_entry(nm, i);
\&        /* Do something with e */
\&        }
.Ve
.PP
Process all commonName entries:
.PP
.Vb 2
\& int loc;
\& X509_NAME_ENTRY *e;
\&
\& loc = \-1;
\& for (;;)
\&        {
\&        lastpos = X509_NAME_get_index_by_NID(nm, NID_commonName, lastpos);
\&        if (lastpos == \-1)
\&                break;
\&        e = X509_NAME_get_entry(nm, lastpos);
\&        /* Do something with e */
\&        }
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIX509_NAME_get_index_by_NID()\fR and \fIX509_NAME_get_index_by_OBJ()\fR
return the index of the next matching entry or \-1 if not found.
.PP
\&\fIX509_NAME_entry_count()\fR returns the total number of entries.
.PP
\&\fIX509_NAME_get_entry()\fR returns an \fBX509_NAME\fR pointer to the
requested entry or \fB\s-1NULL\s0\fR if the index is invalid.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fId2i_X509_NAME\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\s-1TBA\s0
                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_get_index_by_OBJ.3ssl              0120777 0001750 0001750 00000000000 12620245063 033421  2X509_NAME_get_index_by_NID.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_get_text_by_NID.3ssl               0120777 0001750 0001750 00000000000 12620245063 033276  2X509_NAME_get_index_by_NID.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_get_text_by_OBJ.3ssl               0120777 0001750 0001750 00000000000 12620245063 033276  2X509_NAME_get_index_by_NID.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_oneline.3ssl                       0120777 0001750 0001750 00000000000 12620245063 030416  2X509_NAME_print_ex.3ssl                                                                             ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_print.3ssl                         0120777 0001750 0001750 00000000000 12620245063 030121  2X509_NAME_print_ex.3ssl                                                                             ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_print_ex.3ssl                      0100644 0001750 0001750 00000021605 12566201144 024640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "X509_NAME_print_ex 3"
.TH X509_NAME_print_ex 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X509_NAME_print_ex, X509_NAME_print_ex_fp, X509_NAME_print,
X509_NAME_oneline \- X509_NAME printing routines.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& int X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unsigned long flags);
\& int X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unsigned long flags);
\& char * X509_NAME_oneline(X509_NAME *a,char *buf,int size);
\& int X509_NAME_print(BIO *bp, X509_NAME *name, int obase);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIX509_NAME_print_ex()\fR prints a human readable version of \fBnm\fR to \s-1BIO \s0\fBout\fR. Each
line (for multiline formats) is indented by \fBindent\fR spaces. The output format
can be extensively customised by use of the \fBflags\fR parameter.
.PP
\&\fIX509_NAME_print_ex_fp()\fR is identical to \fIX509_NAME_print_ex()\fR except the output is
written to \s-1FILE\s0 pointer \fBfp\fR.
.PP
\&\fIX509_NAME_oneline()\fR prints an \s-1ASCII\s0 version of \fBa\fR to \fBbuf\fR. At most \fBsize\fR
bytes will be written. If \fBbuf\fR is \fB\s-1NULL\s0\fR then a buffer is dynamically allocated
and returned, otherwise \fBbuf\fR is returned.
.PP
\&\fIX509_NAME_print()\fR prints out \fBname\fR to \fBbp\fR indenting each line by \fBobase\fR 
characters. Multiple lines are used if the output (including indent) exceeds
80 characters.
.SH "NOTES"
.IX Header "NOTES"
The functions \fIX509_NAME_oneline()\fR and \fIX509_NAME_print()\fR are legacy functions which
produce a non standard output form, they don't handle multi character fields and
have various quirks and inconsistencies. Their use is strongly discouraged in new
applications.
.PP
Although there are a large number of possible flags for most purposes
\&\fB\s-1XN_FLAG_ONELINE\s0\fR, \fB\s-1XN_FLAG_MULTILINE\s0\fR or \fB\s-1XN_FLAG_RFC2253\s0\fR will suffice.
As noted on the \fIASN1_STRING_print_ex\fR\|(3) manual page
for \s-1UTF8\s0 terminals the \fB\s-1ASN1_STRFLGS_ESC_MSB\s0\fR should be unset: so for example
\&\fB\s-1XN_FLAG_ONELINE &\s0 ~ASN1_STRFLGS_ESC_MSB\fR would be used.
.PP
The complete set of the flags supported by \fIX509_NAME_print_ex()\fR is listed below.
.PP
Several options can be ored together.
.PP
The options \fB\s-1XN_FLAG_SEP_COMMA_PLUS\s0\fR, \fB\s-1XN_FLAG_SEP_CPLUS_SPC\s0\fR,
\&\fB\s-1XN_FLAG_SEP_SPLUS_SPC\s0\fR and \fB\s-1XN_FLAG_SEP_MULTILINE\s0\fR determine the field separators
to use. Two distinct separators are used between distinct RelativeDistinguishedName
components and separate values in the same \s-1RDN\s0 for a multi-valued \s-1RDN.\s0 Multi-valued
RDNs are currently very rare so the second separator will hardly ever be used.
.PP
\&\fB\s-1XN_FLAG_SEP_COMMA_PLUS\s0\fR uses comma and plus as separators. \fB\s-1XN_FLAG_SEP_CPLUS_SPC\s0\fR
uses comma and plus with spaces: this is more readable that plain comma and plus.
\&\fB\s-1XN_FLAG_SEP_SPLUS_SPC\s0\fR uses spaced semicolon and plus. \fB\s-1XN_FLAG_SEP_MULTILINE\s0\fR uses
spaced newline and plus respectively.
.PP
If \fB\s-1XN_FLAG_DN_REV\s0\fR is set the whole \s-1DN\s0 is printed in reversed order.
.PP
The fields \fB\s-1XN_FLAG_FN_SN\s0\fR, \fB\s-1XN_FLAG_FN_LN\s0\fR, \fB\s-1XN_FLAG_FN_OID\s0\fR,
\&\fB\s-1XN_FLAG_FN_NONE\s0\fR determine how a field name is displayed. It will
use the short name (e.g. \s-1CN\s0) the long name (e.g. commonName) always
use \s-1OID\s0 numerical form (normally OIDs are only used if the field name is not
recognised) and no field name respectively.
.PP
If \fB\s-1XN_FLAG_SPC_EQ\s0\fR is set then spaces will be placed around the '=' character
separating field names and values.
.PP
If \fB\s-1XN_FLAG_DUMP_UNKNOWN_FIELDS\s0\fR is set then the encoding of unknown fields is
printed instead of the values.
.PP
If \fB\s-1XN_FLAG_FN_ALIGN\s0\fR is set then field names are padded to 20 characters: this
is only of use for multiline format.
.PP
Additionally all the options supported by \fIASN1_STRING_print_ex()\fR can be used to 
control how each field value is displayed.
.PP
In addition a number options can be set for commonly used formats.
.PP
\&\fB\s-1XN_FLAG_RFC2253\s0\fR sets options which produce an output compatible with \s-1RFC2253\s0 it
is equivalent to:
 \fB\s-1ASN1_STRFLGS_RFC2253\s0 | \s-1XN_FLAG_SEP_COMMA_PLUS\s0 | \s-1XN_FLAG_DN_REV\s0 | \s-1XN_FLAG_FN_SN\s0 | \s-1XN_FLAG_DUMP_UNKNOWN_FIELDS\s0\fR
.PP
\&\fB\s-1XN_FLAG_ONELINE\s0\fR is a more readable one line format which is the same as:
 \fB\s-1ASN1_STRFLGS_RFC2253\s0 | \s-1ASN1_STRFLGS_ESC_QUOTE\s0 | \s-1XN_FLAG_SEP_CPLUS_SPC\s0 | \s-1XN_FLAG_SPC_EQ\s0 | \s-1XN_FLAG_FN_SN\s0\fR
.PP
\&\fB\s-1XN_FLAG_MULTILINE\s0\fR is a multiline format which is the same as:
 \fB\s-1ASN1_STRFLGS_ESC_CTRL\s0 | \s-1ASN1_STRFLGS_ESC_MSB\s0 | \s-1XN_FLAG_SEP_MULTILINE\s0 | \s-1XN_FLAG_SPC_EQ\s0 | \s-1XN_FLAG_FN_LN\s0 | \s-1XN_FLAG_FN_ALIGN\s0\fR
.PP
\&\fB\s-1XN_FLAG_COMPAT\s0\fR uses a format identical to \fIX509_NAME_print()\fR: in fact it calls \fIX509_NAME_print()\fR internally.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIASN1_STRING_print_ex\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\s-1TBA\s0
                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_NAME_print_ex_fp.3ssl                   0120777 0001750 0001750 00000000000 12620245063 031302  2X509_NAME_print_ex.3ssl                                                                             ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_free.3ssl                               0120777 0001750 0001750 00000000000 12620245063 025247  2X509_new.3ssl                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/X509_new.3ssl                                0100644 0001750 0001750 00000011564 12566201144 023004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "X509_new 3"
.TH X509_new 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
X509_new, X509_free \- X509 certificate ASN1 allocation functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& X509 *X509_new(void);
\& void X509_free(X509 *a);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The X509 \s-1ASN1\s0 allocation routines, allocate and free an
X509 structure, which represents an X509 certificate.
.PP
\&\fIX509_new()\fR allocates and initializes a X509 structure.
.PP
\&\fIX509_free()\fR frees up the \fBX509\fR structure \fBa\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
If the allocation fails, \fIX509_new()\fR returns \fB\s-1NULL\s0\fR and sets an error
code that can be obtained by \fIERR_get_error\fR\|(3).
Otherwise it returns a pointer to the newly allocated structure.
.PP
\&\fIX509_free()\fR returns no value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3), \fId2i_X509\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIX509_new()\fR and \fIX509_free()\fR are available in all versions of SSLeay and OpenSSL.
                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML.3pm                              0100644 0001750 0001750 00000051132 12566241670 023140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LibXML 3"
.TH LibXML 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML \- Perl Binding for libxml2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use XML::LibXML;
\&  my $dom = XML::LibXML\->load_xml(string => <<\*(AqEOT\*(Aq);
\&  <some\-xml/>
\&  EOT
\&
\&  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
\&  $Version_ID = XML::LibXML::LIBXML_VERSION;
\&  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
\&  $libxmlnode = XML::LibXML\->import_GDOME( $node, $deep );
\&  $gdomenode = XML::LibXML\->export_GDOME( $node, $deep );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an interface to libxml2, providing \s-1XML\s0 and \s-1HTML\s0 parsers with
\&\s-1DOM, SAX\s0 and XMLReader interfaces, a large subset of \s-1DOM\s0 Layer 3 interface and
a XML::XPath\-like interface to XPath \s-1API\s0 of libxml2. The module is split into
several packages which are not described in this section; unless stated
otherwise, you only need to \f(CW\*(C`use XML::LibXML;\*(C'\fR in your programs.
.PP
For further information, please check the following documentation:
.IP "XML::LibXML::Parser" 4
.IX Item "XML::LibXML::Parser"
Parsing \s-1XML\s0 files with XML::LibXML
.IP "XML::LibXML::DOM" 4
.IX Item "XML::LibXML::DOM"
XML::LibXML Document Object Model (\s-1DOM\s0) Implementation
.IP "XML::LibXML::SAX" 4
.IX Item "XML::LibXML::SAX"
XML::LibXML direct \s-1SAX\s0 parser
.IP "XML::LibXML::Reader" 4
.IX Item "XML::LibXML::Reader"
Reading \s-1XML\s0 with a pull-parser
.IP "XML::LibXML::Dtd" 4
.IX Item "XML::LibXML::Dtd"
XML::LibXML frontend for \s-1DTD\s0 validation
.IP "XML::LibXML::RelaxNG" 4
.IX Item "XML::LibXML::RelaxNG"
XML::LibXML frontend for RelaxNG schema validation
.IP "XML::LibXML::Schema" 4
.IX Item "XML::LibXML::Schema"
XML::LibXML frontend for W3C Schema schema validation
.IP "XML::LibXML::XPathContext" 4
.IX Item "XML::LibXML::XPathContext"
\&\s-1API\s0 for evaluating XPath expressions with enhanced support for the evaluation
context
.IP "XML::LibXML::InputCallback" 4
.IX Item "XML::LibXML::InputCallback"
Implementing custom \s-1URI\s0 Resolver and input callbacks
.IP "XML::LibXML::Common" 4
.IX Item "XML::LibXML::Common"
Common functions for XML::LibXML related Classes
.PP
The nodes in the Document Object Model (\s-1DOM\s0) are represented by the following
classes (most of which \*(L"inherit\*(R" from XML::LibXML::Node):
.IP "XML::LibXML::Document" 4
.IX Item "XML::LibXML::Document"
XML::LibXML class for \s-1DOM\s0 document nodes
.IP "XML::LibXML::Node" 4
.IX Item "XML::LibXML::Node"
Abstract base class for XML::LibXML \s-1DOM\s0 nodes
.IP "XML::LibXML::Element" 4
.IX Item "XML::LibXML::Element"
XML::LibXML class for \s-1DOM\s0 element nodes
.IP "XML::LibXML::Text" 4
.IX Item "XML::LibXML::Text"
XML::LibXML class for \s-1DOM\s0 text nodes
.IP "XML::LibXML::Comment" 4
.IX Item "XML::LibXML::Comment"
XML::LibXML class for comment \s-1DOM\s0 nodes
.IP "XML::LibXML::CDATASection" 4
.IX Item "XML::LibXML::CDATASection"
XML::LibXML class for \s-1DOM CDATA\s0 sections
.IP "XML::LibXML::Attr" 4
.IX Item "XML::LibXML::Attr"
XML::LibXML \s-1DOM\s0 attribute class
.IP "XML::LibXML::DocumentFragment" 4
.IX Item "XML::LibXML::DocumentFragment"
XML::LibXML's \s-1DOM L2\s0 Document Fragment implementation
.IP "XML::LibXML::Namespace" 4
.IX Item "XML::LibXML::Namespace"
XML::LibXML \s-1DOM\s0 namespace nodes
.IP "XML::LibXML::PI" 4
.IX Item "XML::LibXML::PI"
XML::LibXML \s-1DOM\s0 processing instruction nodes
.SH "ENCODINGS SUPPORT IN XML::LIBXML"
.IX Header "ENCODINGS SUPPORT IN XML::LIBXML"
Recall that since version 5.6.1, Perl distinguishes between character strings
(internally encoded in \s-1UTF\-8\s0) and so called binary data and, accordingly,
applies either character or byte semantics to them. A scalar representing a
character string is distinguished from a byte string by special flag (\s-1UTF8\s0).
Please refer to \fIperlunicode\fR for details.
.PP
XML::LibXML's \s-1API\s0 is designed to deal with many encodings of \s-1XML\s0 documents
completely transparently, so that the application using XML::LibXML can be
completely ignorant about the encoding of the \s-1XML\s0 documents it works with. On
the other hand, functions like \f(CW\*(C`XML::LibXML::Document\->setEncoding\*(C'\fR give the user control over the document encoding.
.PP
To ensure the aforementioned transparency and uniformity, most functions of
XML::LibXML that work with in-memory trees accept and return data as character
strings (i.e. \s-1UTF\-8\s0 encoded with the \s-1UTF8\s0 flag on) regardless of the original
document encoding; however, the functions related to I/O operations (i.e.
parsing and saving) operate with binary data (in the original document
encoding) obeying the encoding declaration of the \s-1XML\s0 documents.
.PP
Below we summarize basic rules and principles regarding encoding:
.IP "1." 4
Do \s-1NOT\s0 apply any encoding-related PerlIO layers (\f(CW\*(C`:utf8\*(C'\fR or \f(CW\*(C`:encoding(...)\*(C'\fR) to file handles that are an input for the parses or an output for a
serializer of (full) \s-1XML\s0 documents. This is because the conversion of the data
to/from the internal character representation is provided by libxml2 itself
which must be able to enforce the encoding specified by the \f(CW\*(C`<?xml version="1.0" encoding="..."?>\*(C'\fR declaration. Here is an example to follow:
.Sp
.Vb 5
\&  use XML::LibXML;
\&  # load
\&  open my $fh, \*(Aq<\*(Aq, \*(Aqfile.xml\*(Aq;
\&  binmode $fh; # drop all PerlIO layers possibly created by a use open pragma
\&  $doc = XML::LibXML\->load_xml(IO => $fh);
\&
\&  # save
\&  open my $out, \*(Aq>\*(Aq, \*(Aqout.xml\*(Aq;
\&  binmode $out; # as above
\&  $doc\->toFH($out);
\&  # or
\&  print {$out} $doc\->toString();
.Ve
.IP "2." 4
All functions working with \s-1DOM\s0 accept and return character strings (\s-1UTF\-8\s0
encoded with \s-1UTF8\s0 flag on). E.g.
.Sp
.Vb 5
\&  my $doc = XML::LibXML::Document\->new(\*(Aq1.0\*(Aq,$some_encoding);
\&  my $element = $doc\->createElement($name);
\&  $element\->appendText($text);
\&  $xml_fragment = $element\->toString(); # returns a character string
\&  $xml_document = $doc\->toString(); # returns a byte string
.Ve
.Sp
where \f(CW$some_encoding\fR is the document encoding that will be used when saving the document, and \f(CW$name\fR and \f(CW$text\fR contain character strings (\s-1UTF\-8\s0 encoded with \s-1UTF8\s0 flag on). Note that the
method \f(CW\*(C`toString\*(C'\fR returns \s-1XML\s0 as a character string if applied to other node than the Document
node and a byte string containing the appropriate
.Sp
.Vb 1
\&  <?xml version="1.0" encoding="..."?>
.Ve
.Sp
declaration if applied to a XML::LibXML::Document.
.IP "3." 4
\&\s-1DOM\s0 methods also accept binary strings in the original encoding of the document
to which the node belongs (\s-1UTF\-8\s0 is assumed if the node is not attached to any
document). Exploiting this feature is \s-1NOT RECOMMENDED\s0 since it is considered
bad practice.
.Sp
.Vb 3
\&  my $doc = XML::LibXML::Document\->new(\*(Aq1.0\*(Aq,\*(Aqiso\-8859\-2\*(Aq);
\&  my $text = $doc\->createTextNode($some_latin2_encoded_byte_string);
\&  # WORKS, BUT NOT RECOMMENDED!
.Ve
.PP
\&\fI\s-1NOTE:\s0\fR libxml2 support for many encodings is based on the iconv library. The actual
list of supported encodings may vary from platform to platform. To test if your
platform works correctly with your language encoding, build a simple document
in the particular encoding and try to parse it with XML::LibXML to see if the
parser produces any errors. Occasional crashes were reported on rare platforms
that ship with a broken version of iconv.
.SH "THREAD SUPPORT"
.IX Header "THREAD SUPPORT"
XML::LibXML since 1.67 partially supports Perl threads in Perl >= 5.8.8.
XML::LibXML can be used with threads in two ways:
.PP
By default, all XML::LibXML classes use \s-1CLONE_SKIP\s0 class method to prevent Perl
from copying XML::LibXML::* objects when a new thread is spawn. In this mode,
all XML::LibXML::* objects are thread specific. This is the safest way to work
with XML::LibXML in threads.
.PP
Alternatively, one may use
.PP
.Vb 2
\&  use threads;
\&  use XML::LibXML qw(:threads_shared);
.Ve
.PP
to indicate, that all XML::LibXML node and parser objects should be shared
between the main thread and any thread spawn from there. For example, in
.PP
.Vb 6
\&  my $doc = XML::LibXML\->load_xml(location => $filename);
\&  my $thr = threads\->new(sub{
\&    # code working with $doc
\&    1;
\&  });
\&  $thr\->join;
.Ve
.PP
the variable \f(CW$doc\fR refers to the exact same XML::LibXML::Document in the spawned thread as in the
main thread.
.PP
Without using mutex locks, parallel threads may read the same document (i.e.
any node that belongs to the document), parse files, and modify different
documents.
.PP
However, if there is a chance that some of the threads will attempt to modify a
document (or even create new nodes based on that document, e.g. with \f(CW\*(C`$doc\->createElement\*(C'\fR) that other threads may be reading at the same time, the user is responsible
for creating a mutex lock and using it in \fIboth\fR in the thread that modifies and the thread that reads:
.PP
.Vb 10
\&  my $doc = XML::LibXML\->load_xml(location => $filename);
\&  my $mutex : shared;
\&  my $thr = threads\->new(sub{
\&     lock $mutex;
\&     my $el = $doc\->createElement(\*(Aqfoo\*(Aq);
\&     # ...
\&    1;
\&  });
\&  {
\&    lock $mutex;
\&    my $root = $doc\->documentElement;
\&    say $root\->name;
\&  }
\&  $thr\->join;
.Ve
.PP
Note that libxml2 uses dictionaries to store short strings and these
dictionaries are kept on a document node. Without mutex locks, it could happen
in the previous example that the thread modifies the dictionary while other
threads attempt to read from it, which could easily lead to a crash.
.SH "VERSION INFORMATION"
.IX Header "VERSION INFORMATION"
Sometimes it is useful to figure out, for which version XML::LibXML was
compiled for. In most cases this is for debugging or to check if a given
installation meets all functionality for the package. The functions
XML::LibXML::LIBXML_DOTTED_VERSION and XML::LibXML::LIBXML_VERSION provide this
version information. Both functions simply pass through the values of the
similar named macros of libxml2. Similarly, XML::LibXML::LIBXML_RUNTIME_VERSION
returns the version of the (usually dynamically) linked libxml2.
.IP "XML::LibXML::LIBXML_DOTTED_VERSION" 4
.IX Item "XML::LibXML::LIBXML_DOTTED_VERSION"
.Vb 1
\&  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
.Ve
.Sp
Returns the version string of the libxml2 version XML::LibXML was compiled for.
This will be \*(L"2.6.2\*(R" for \*(L"libxml2 2.6.2\*(R".
.IP "XML::LibXML::LIBXML_VERSION" 4
.IX Item "XML::LibXML::LIBXML_VERSION"
.Vb 1
\&  $Version_ID = XML::LibXML::LIBXML_VERSION;
.Ve
.Sp
Returns the version id of the libxml2 version XML::LibXML was compiled for.
This will be \*(L"20602\*(R" for \*(L"libxml2 2.6.2\*(R". Don't mix this version id with
\&\f(CW$XML::LibXML::VERSION\fR. The latter contains the version of XML::LibXML itself
while the first contains the version of libxml2 XML::LibXML was compiled for.
.IP "XML::LibXML::LIBXML_RUNTIME_VERSION" 4
.IX Item "XML::LibXML::LIBXML_RUNTIME_VERSION"
.Vb 1
\&  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
.Ve
.Sp
Returns a version string of the libxml2 which is (usually dynamically) linked
by XML::LibXML. This will be \*(L"20602\*(R" for libxml2 released as \*(L"2.6.2\*(R" and
something like \*(L"20602\-CVS2032\*(R" for a \s-1CVS\s0 build of libxml2.
.Sp
XML::LibXML issues a warning if the version of libxml2 dynamically linked to it
is less than the version of libxml2 which it was compiled against.
.SH "EXPORTS"
.IX Header "EXPORTS"
By default the module exports all constants and functions listed in the :all
tag, described below.
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.ie n .IP """:all""" 4
.el .IP "\f(CW:all\fR" 4
.IX Item ":all"
Includes the tags \f(CW\*(C`:libxml\*(C'\fR, \f(CW\*(C`:encoding\*(C'\fR, and \f(CW\*(C`:ns\*(C'\fR described below.
.ie n .IP """:libxml""" 4
.el .IP "\f(CW:libxml\fR" 4
.IX Item ":libxml"
Exports integer constants for \s-1DOM\s0 node types.
.Sp
.Vb 10
\&  XML_ELEMENT_NODE            => 1
\&  XML_ATTRIBUTE_NODE          => 2
\&  XML_TEXT_NODE               => 3
\&  XML_CDATA_SECTION_NODE      => 4
\&  XML_ENTITY_REF_NODE         => 5
\&  XML_ENTITY_NODE             => 6
\&  XML_PI_NODE                 => 7
\&  XML_COMMENT_NODE            => 8
\&  XML_DOCUMENT_NODE           => 9
\&  XML_DOCUMENT_TYPE_NODE      => 10
\&  XML_DOCUMENT_FRAG_NODE      => 11
\&  XML_NOTATION_NODE           => 12
\&  XML_HTML_DOCUMENT_NODE      => 13
\&  XML_DTD_NODE                => 14
\&  XML_ELEMENT_DECL            => 15
\&  XML_ATTRIBUTE_DECL          => 16
\&  XML_ENTITY_DECL             => 17
\&  XML_NAMESPACE_DECL          => 18
\&  XML_XINCLUDE_START          => 19
\&  XML_XINCLUDE_END            => 20
.Ve
.ie n .IP """:encoding""" 4
.el .IP "\f(CW:encoding\fR" 4
.IX Item ":encoding"
Exports two encoding conversion functions from XML::LibXML::Common.
.Sp
.Vb 2
\&  encodeToUTF8()
\&  decodeFromUTF8()
.Ve
.ie n .IP """:ns""" 4
.el .IP "\f(CW:ns\fR" 4
.IX Item ":ns"
Exports two convenience constants: the implicit namespace of the reserved \f(CW\*(C`xml:\*(C'\fR prefix, and the implicit namespace for the reserved \f(CW\*(C`xmlns:\*(C'\fR prefix.
.Sp
.Vb 2
\&  XML_XML_NS    => \*(Aqhttp://www.w3.org/XML/1998/namespace\*(Aq
\&  XML_XMLNS_NS  => \*(Aqhttp://www.w3.org/2000/xmlns/\*(Aq
.Ve
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
The modules described in this section are not part of the XML::LibXML package
itself. As they support some additional features, they are mentioned here.
.IP "XML::LibXSLT" 4
.IX Item "XML::LibXSLT"
\&\s-1XSLT 1.0\s0 Processor using libxslt and XML::LibXML
.IP "XML::LibXML::Iterator" 4
.IX Item "XML::LibXML::Iterator"
XML::LibXML Implementation of the \s-1DOM\s0 Traversal Specification
.IP "XML::CompactTree::XS" 4
.IX Item "XML::CompactTree::XS"
Uses XML::LibXML::Reader to very efficiently to parse \s-1XML\s0 document or element
into native Perl data structures, which are less flexible but significantly
faster to process then \s-1DOM.\s0
.SH "XML::LIBXML AND XML::GDOME"
.IX Header "XML::LIBXML AND XML::GDOME"
Note: \fI\s-1THE FUNCTIONS DESCRIBED HERE ARE STILL EXPERIMENTAL\s0\fR
.PP
Although both modules make use of libxml2's \s-1XML\s0 capabilities, the \s-1DOM\s0
implementation of both modules are not compatible. But still it is possible to
exchange nodes from one \s-1DOM\s0 to the other. The concept of this exchange is
pretty similar to the function \fIcloneNode()\fR: The particular node is copied on
the low-level to the opposite \s-1DOM\s0 implementation.
.PP
Since the \s-1DOM\s0 implementations cannot coexist within one document, one is forced
to copy each node that should be used. Because you are always keeping two nodes
this may cause quite an impact on a machines memory usage.
.PP
XML::LibXML provides two functions to export or import \s-1GDOME\s0 nodes:
\&\fIimport_GDOME()\fR and \fIexport_GDOME()\fR. Both function have two parameters: the node
and a flag for recursive import. The flag works as in \fIcloneNode()\fR.
.PP
The two functions allow to export and import \s-1XML::GDOME\s0 nodes explicitly,
however, XML::LibXML allows also the transparent import of \s-1XML::GDOME\s0 nodes in
functions such as \fIappendChild()\fR, \fIinsertAfter()\fR and so on. While native nodes
are automatically adopted in most functions \s-1XML::GDOME\s0 nodes are always cloned
in advance. Thus if the original node is modified after the operation, the node
in the XML::LibXML document will not have this information.
.IP "import_GDOME" 4
.IX Item "import_GDOME"
.Vb 1
\&  $libxmlnode = XML::LibXML\->import_GDOME( $node, $deep );
.Ve
.Sp
This clones an \s-1XML::GDOME\s0 node to an XML::LibXML node explicitly.
.IP "export_GDOME" 4
.IX Item "export_GDOME"
.Vb 1
\&  $gdomenode = XML::LibXML\->export_GDOME( $node, $deep );
.Ve
.Sp
Allows one to clone an XML::LibXML node into an \s-1XML::GDOME\s0 node.
.SH "CONTACTS"
.IX Header "CONTACTS"
For bug reports, please use the \s-1CPAN\s0 request tracker on
http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML\-LibXML
.PP
For suggestions etc., and other issues related to XML::LibXML you may use the
perl \s-1XML\s0 mailing list (\f(CW\*(C`perl\-xml@listserv.ActiveState.com\*(C'\fR), where most XML-related Perl modules are discussed. In case of problems you
should check the archives of that list first. Many problems are already
discussed there. You can find the list's archives and subscription options at <http://aspn.activestate.com/ASPN/Mail/Browse/Threaded/perl\-xml>.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML5.16.3pm                          0100644 0001750 0001750 00000050563 12566241665 023465  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LibXML 3"
.TH LibXML 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML \- Perl Binding for libxml2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use XML::LibXML;
\&  my $dom = XML::LibXML\->load_xml(string => <<\*(AqEOT\*(Aq);
\&  <some\-xml/>
\&  EOT
\&
\&  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
\&  $Version_ID = XML::LibXML::LIBXML_VERSION;
\&  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
\&  $libxmlnode = XML::LibXML\->import_GDOME( $node, $deep );
\&  $gdomenode = XML::LibXML\->export_GDOME( $node, $deep );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an interface to libxml2, providing \s-1XML\s0 and \s-1HTML\s0 parsers with
\&\s-1DOM\s0, \s-1SAX\s0 and XMLReader interfaces, a large subset of \s-1DOM\s0 Layer 3 interface and
a XML::XPath\-like interface to XPath \s-1API\s0 of libxml2. The module is split into
several packages which are not described in this section; unless stated
otherwise, you only need to \f(CW\*(C`use XML::LibXML;\*(C'\fR in your programs.
.PP
For further information, please check the following documentation:
.IP "XML::LibXML::Parser" 4
.IX Item "XML::LibXML::Parser"
Parsing \s-1XML\s0 files with XML::LibXML
.IP "XML::LibXML::DOM" 4
.IX Item "XML::LibXML::DOM"
XML::LibXML Document Object Model (\s-1DOM\s0) Implementation
.IP "XML::LibXML::SAX" 4
.IX Item "XML::LibXML::SAX"
XML::LibXML direct \s-1SAX\s0 parser
.IP "XML::LibXML::Reader" 4
.IX Item "XML::LibXML::Reader"
Reading \s-1XML\s0 with a pull-parser
.IP "XML::LibXML::Dtd" 4
.IX Item "XML::LibXML::Dtd"
XML::LibXML frontend for \s-1DTD\s0 validation
.IP "XML::LibXML::RelaxNG" 4
.IX Item "XML::LibXML::RelaxNG"
XML::LibXML frontend for RelaxNG schema validation
.IP "XML::LibXML::Schema" 4
.IX Item "XML::LibXML::Schema"
XML::LibXML frontend for W3C Schema schema validation
.IP "XML::LibXML::XPathContext" 4
.IX Item "XML::LibXML::XPathContext"
\&\s-1API\s0 for evaluating XPath expressions with enhanced support for the evaluation
context
.IP "XML::LibXML::InputCallback" 4
.IX Item "XML::LibXML::InputCallback"
Implementing custom \s-1URI\s0 Resolver and input callbacks
.IP "XML::LibXML::Common" 4
.IX Item "XML::LibXML::Common"
Common functions for XML::LibXML related Classes
.PP
The nodes in the Document Object Model (\s-1DOM\s0) are represented by the following
classes (most of which \*(L"inherit\*(R" from XML::LibXML::Node):
.IP "XML::LibXML::Document" 4
.IX Item "XML::LibXML::Document"
XML::LibXML class for \s-1DOM\s0 document nodes
.IP "XML::LibXML::Node" 4
.IX Item "XML::LibXML::Node"
Abstract base class for XML::LibXML \s-1DOM\s0 nodes
.IP "XML::LibXML::Element" 4
.IX Item "XML::LibXML::Element"
XML::LibXML class for \s-1DOM\s0 element nodes
.IP "XML::LibXML::Text" 4
.IX Item "XML::LibXML::Text"
XML::LibXML class for \s-1DOM\s0 text nodes
.IP "XML::LibXML::Comment" 4
.IX Item "XML::LibXML::Comment"
XML::LibXML class for comment \s-1DOM\s0 nodes
.IP "XML::LibXML::CDATASection" 4
.IX Item "XML::LibXML::CDATASection"
XML::LibXML class for \s-1DOM\s0 \s-1CDATA\s0 sections
.IP "XML::LibXML::Attr" 4
.IX Item "XML::LibXML::Attr"
XML::LibXML \s-1DOM\s0 attribute class
.IP "XML::LibXML::DocumentFragment" 4
.IX Item "XML::LibXML::DocumentFragment"
XML::LibXML's \s-1DOM\s0 L2 Document Fragment implementation
.IP "XML::LibXML::Namespace" 4
.IX Item "XML::LibXML::Namespace"
XML::LibXML \s-1DOM\s0 namespace nodes
.IP "XML::LibXML::PI" 4
.IX Item "XML::LibXML::PI"
XML::LibXML \s-1DOM\s0 processing instruction nodes
.SH "ENCODINGS SUPPORT IN XML::LIBXML"
.IX Header "ENCODINGS SUPPORT IN XML::LIBXML"
Recall that since version 5.6.1, Perl distinguishes between character strings
(internally encoded in \s-1UTF\-8\s0) and so called binary data and, accordingly,
applies either character or byte semantics to them. A scalar representing a
character string is distinguished from a byte string by special flag (\s-1UTF8\s0).
Please refer to \fIperlunicode\fR for details.
.PP
XML::LibXML's \s-1API\s0 is designed to deal with many encodings of \s-1XML\s0 documents
completely transparently, so that the application using XML::LibXML can be
completely ignorant about the encoding of the \s-1XML\s0 documents it works with. On
the other hand, functions like \f(CW\*(C`XML::LibXML::Document\->setEncoding\*(C'\fR give the user control over the document encoding.
.PP
To ensure the aforementioned transparency and uniformity, most functions of
XML::LibXML that work with in-memory trees accept and return data as character
strings (i.e. \s-1UTF\-8\s0 encoded with the \s-1UTF8\s0 flag on) regardless of the original
document encoding; however, the functions related to I/O operations (i.e.
parsing and saving) operate with binary data (in the original document
encoding) obeying the encoding declaration of the \s-1XML\s0 documents.
.PP
Below we summarize basic rules and principles regarding encoding:
.IP "1." 4
Do \s-1NOT\s0 apply any encoding-related PerlIO layers (\f(CW\*(C`:utf8\*(C'\fR or \f(CW\*(C`:encoding(...)\*(C'\fR) to file handles that are an input for the parses or an output for a
serializer of (full) \s-1XML\s0 documents. This is because the conversion of the data
to/from the internal character representation is provided by libxml2 itself
which must be able to enforce the encoding specified by the \f(CW\*(C`<?xml version="1.0" encoding="..."?>\*(C'\fR declaration. Here is an example to follow:
.Sp
.Vb 5
\&  use XML::LibXML;
\&  # load
\&  open my $fh, \*(Aq<\*(Aq, \*(Aqfile.xml\*(Aq;
\&  binmode $fh; # drop all PerlIO layers possibly created by a use open pragma
\&  $doc = XML::LibXML\->load_xml(IO => $fh);
\&
\&  # save
\&  open my $out, \*(Aq>\*(Aq, \*(Aqout.xml\*(Aq;
\&  binmode $out; # as above
\&  $doc\->toFH($out);
\&  # or
\&  print {$out} $doc\->toString();
.Ve
.IP "2." 4
All functions working with \s-1DOM\s0 accept and return character strings (\s-1UTF\-8\s0
encoded with \s-1UTF8\s0 flag on). E.g.
.Sp
.Vb 5
\&  my $doc = XML::LibXML::Document\->new(\*(Aq1.0\*(Aq,$some_encoding);
\&  my $element = $doc\->createElement($name);
\&  $element\->appendText($text);
\&  $xml_fragment = $element\->toString(); # returns a character string
\&  $xml_document = $doc\->toString(); # returns a byte string
.Ve
.Sp
where \f(CW$some_encoding\fR is the document encoding that will be used when saving the document, and \f(CW$name\fR and \f(CW$text\fR contain character strings (\s-1UTF\-8\s0 encoded with \s-1UTF8\s0 flag on). Note that the
method \f(CW\*(C`toString\*(C'\fR returns \s-1XML\s0 as a character string if applied to other node than the Document
node and a byte string containing the appropriate
.Sp
.Vb 1
\&  <?xml version="1.0" encoding="..."?>
.Ve
.Sp
declaration if applied to a XML::LibXML::Document.
.IP "3." 4
\&\s-1DOM\s0 methods also accept binary strings in the original encoding of the document
to which the node belongs (\s-1UTF\-8\s0 is assumed if the node is not attached to any
document). Exploiting this feature is \s-1NOT\s0 \s-1RECOMMENDED\s0 since it is considered
bad practice.
.Sp
.Vb 3
\&  my $doc = XML::LibXML::Document\->new(\*(Aq1.0\*(Aq,\*(Aqiso\-8859\-2\*(Aq);
\&  my $text = $doc\->createTextNode($some_latin2_encoded_byte_string);
\&  # WORKS, BUT NOT RECOMMENDED!
.Ve
.PP
\&\fI\s-1NOTE:\s0\fR libxml2 support for many encodings is based on the iconv library. The actual
list of supported encodings may vary from platform to platform. To test if your
platform works correctly with your language encoding, build a simple document
in the particular encoding and try to parse it with XML::LibXML to see if the
parser produces any errors. Occasional crashes were reported on rare platforms
that ship with a broken version of iconv.
.SH "THREAD SUPPORT"
.IX Header "THREAD SUPPORT"
XML::LibXML since 1.67 partially supports Perl threads in Perl >= 5.8.8.
XML::LibXML can be used with threads in two ways:
.PP
By default, all XML::LibXML classes use \s-1CLONE_SKIP\s0 class method to prevent Perl
from copying XML::LibXML::* objects when a new thread is spawn. In this mode,
all XML::LibXML::* objects are thread specific. This is the safest way to work
with XML::LibXML in threads.
.PP
Alternatively, one may use
.PP
.Vb 2
\&  use threads;
\&  use XML::LibXML qw(:threads_shared);
.Ve
.PP
to indicate, that all XML::LibXML node and parser objects should be shared
between the main thread and any thread spawn from there. For example, in
.PP
.Vb 6
\&  my $doc = XML::LibXML\->load_xml(location => $filename);
\&  my $thr = threads\->new(sub{
\&    # code working with $doc
\&    1;
\&  });
\&  $thr\->join;
.Ve
.PP
the variable \f(CW$doc\fR refers to the exact same XML::LibXML::Document in the spawned thread as in the
main thread.
.PP
Without using mutex locks, parallel threads may read the same document (i.e.
any node that belongs to the document), parse files, and modify different
documents.
.PP
However, if there is a chance that some of the threads will attempt to modify a
document (or even create new nodes based on that document, e.g. with \f(CW\*(C`$doc\->createElement\*(C'\fR) that other threads may be reading at the same time, the user is responsible
for creating a mutex lock and using it in \fIboth\fR in the thread that modifies and the thread that reads:
.PP
.Vb 10
\&  my $doc = XML::LibXML\->load_xml(location => $filename);
\&  my $mutex : shared;
\&  my $thr = threads\->new(sub{
\&     lock $mutex;
\&     my $el = $doc\->createElement(\*(Aqfoo\*(Aq);
\&     # ...
\&    1;
\&  });
\&  {
\&    lock $mutex;
\&    my $root = $doc\->documentElement;
\&    say $root\->name;
\&  }
\&  $thr\->join;
.Ve
.PP
Note that libxml2 uses dictionaries to store short strings and these
dictionaries are kept on a document node. Without mutex locks, it could happen
in the previous example that the thread modifies the dictionary while other
threads attempt to read from it, which could easily lead to a crash.
.SH "VERSION INFORMATION"
.IX Header "VERSION INFORMATION"
Sometimes it is useful to figure out, for which version XML::LibXML was
compiled for. In most cases this is for debugging or to check if a given
installation meets all functionality for the package. The functions
XML::LibXML::LIBXML_DOTTED_VERSION and XML::LibXML::LIBXML_VERSION provide this
version information. Both functions simply pass through the values of the
similar named macros of libxml2. Similarly, XML::LibXML::LIBXML_RUNTIME_VERSION
returns the version of the (usually dynamically) linked libxml2.
.IP "XML::LibXML::LIBXML_DOTTED_VERSION" 4
.IX Item "XML::LibXML::LIBXML_DOTTED_VERSION"
.Vb 1
\&  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
.Ve
.Sp
Returns the version string of the libxml2 version XML::LibXML was compiled for.
This will be \*(L"2.6.2\*(R" for \*(L"libxml2 2.6.2\*(R".
.IP "XML::LibXML::LIBXML_VERSION" 4
.IX Item "XML::LibXML::LIBXML_VERSION"
.Vb 1
\&  $Version_ID = XML::LibXML::LIBXML_VERSION;
.Ve
.Sp
Returns the version id of the libxml2 version XML::LibXML was compiled for.
This will be \*(L"20602\*(R" for \*(L"libxml2 2.6.2\*(R". Don't mix this version id with
\&\f(CW$XML::LibXML::VERSION\fR. The latter contains the version of XML::LibXML itself
while the first contains the version of libxml2 XML::LibXML was compiled for.
.IP "XML::LibXML::LIBXML_RUNTIME_VERSION" 4
.IX Item "XML::LibXML::LIBXML_RUNTIME_VERSION"
.Vb 1
\&  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
.Ve
.Sp
Returns a version string of the libxml2 which is (usually dynamically) linked
by XML::LibXML. This will be \*(L"20602\*(R" for libxml2 released as \*(L"2.6.2\*(R" and
something like \*(L"20602\-CVS2032\*(R" for a \s-1CVS\s0 build of libxml2.
.Sp
XML::LibXML issues a warning if the version of libxml2 dynamically linked to it
is less than the version of libxml2 which it was compiled against.
.SH "EXPORTS"
.IX Header "EXPORTS"
By default the module exports all constants and functions listed in the :all
tag, described below.
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.ie n .IP """:all""" 4
.el .IP "\f(CW:all\fR" 4
.IX Item ":all"
Includes the tags \f(CW\*(C`:libxml\*(C'\fR, \f(CW\*(C`:encoding\*(C'\fR, and \f(CW\*(C`:ns\*(C'\fR described below.
.ie n .IP """:libxml""" 4
.el .IP "\f(CW:libxml\fR" 4
.IX Item ":libxml"
Exports integer constants for \s-1DOM\s0 node types.
.Sp
.Vb 10
\&  XML_ELEMENT_NODE            => 1
\&  XML_ATTRIBUTE_NODE          => 2
\&  XML_TEXT_NODE               => 3
\&  XML_CDATA_SECTION_NODE      => 4
\&  XML_ENTITY_REF_NODE         => 5
\&  XML_ENTITY_NODE             => 6
\&  XML_PI_NODE                 => 7
\&  XML_COMMENT_NODE            => 8
\&  XML_DOCUMENT_NODE           => 9
\&  XML_DOCUMENT_TYPE_NODE      => 10
\&  XML_DOCUMENT_FRAG_NODE      => 11
\&  XML_NOTATION_NODE           => 12
\&  XML_HTML_DOCUMENT_NODE      => 13
\&  XML_DTD_NODE                => 14
\&  XML_ELEMENT_DECL            => 15
\&  XML_ATTRIBUTE_DECL          => 16
\&  XML_ENTITY_DECL             => 17
\&  XML_NAMESPACE_DECL          => 18
\&  XML_XINCLUDE_START          => 19
\&  XML_XINCLUDE_END            => 20
.Ve
.ie n .IP """:encoding""" 4
.el .IP "\f(CW:encoding\fR" 4
.IX Item ":encoding"
Exports two encoding conversion functions from XML::LibXML::Common.
.Sp
.Vb 2
\&  encodeToUTF8()
\&  decodeFromUTF8()
.Ve
.ie n .IP """:ns""" 4
.el .IP "\f(CW:ns\fR" 4
.IX Item ":ns"
Exports two convenience constants: the implicit namespace of the reserved \f(CW\*(C`xml:\*(C'\fR prefix, and the implicit namespace for the reserved \f(CW\*(C`xmlns:\*(C'\fR prefix.
.Sp
.Vb 2
\&  XML_XML_NS    => \*(Aqhttp://www.w3.org/XML/1998/namespace\*(Aq
\&  XML_XMLNS_NS  => \*(Aqhttp://www.w3.org/2000/xmlns/\*(Aq
.Ve
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
The modules described in this section are not part of the XML::LibXML package
itself. As they support some additional features, they are mentioned here.
.IP "XML::LibXSLT" 4
.IX Item "XML::LibXSLT"
\&\s-1XSLT\s0 1.0 Processor using libxslt and XML::LibXML
.IP "XML::LibXML::Iterator" 4
.IX Item "XML::LibXML::Iterator"
XML::LibXML Implementation of the \s-1DOM\s0 Traversal Specification
.IP "XML::CompactTree::XS" 4
.IX Item "XML::CompactTree::XS"
Uses XML::LibXML::Reader to very efficiently to parse \s-1XML\s0 document or element
into native Perl data structures, which are less flexible but significantly
faster to process then \s-1DOM\s0.
.SH "XML::LIBXML AND XML::GDOME"
.IX Header "XML::LIBXML AND XML::GDOME"
Note: \fI\s-1THE\s0 \s-1FUNCTIONS\s0 \s-1DESCRIBED\s0 \s-1HERE\s0 \s-1ARE\s0 \s-1STILL\s0 \s-1EXPERIMENTAL\s0\fR
.PP
Although both modules make use of libxml2's \s-1XML\s0 capabilities, the \s-1DOM\s0
implementation of both modules are not compatible. But still it is possible to
exchange nodes from one \s-1DOM\s0 to the other. The concept of this exchange is
pretty similar to the function \fIcloneNode()\fR: The particular node is copied on
the low-level to the opposite \s-1DOM\s0 implementation.
.PP
Since the \s-1DOM\s0 implementations cannot coexist within one document, one is forced
to copy each node that should be used. Because you are always keeping two nodes
this may cause quite an impact on a machines memory usage.
.PP
XML::LibXML provides two functions to export or import \s-1GDOME\s0 nodes:
\&\fIimport_GDOME()\fR and \fIexport_GDOME()\fR. Both function have two parameters: the node
and a flag for recursive import. The flag works as in \fIcloneNode()\fR.
.PP
The two functions allow to export and import \s-1XML::GDOME\s0 nodes explicitly,
however, XML::LibXML allows also the transparent import of \s-1XML::GDOME\s0 nodes in
functions such as \fIappendChild()\fR, \fIinsertAfter()\fR and so on. While native nodes
are automatically adopted in most functions \s-1XML::GDOME\s0 nodes are always cloned
in advance. Thus if the original node is modified after the operation, the node
in the XML::LibXML document will not have this information.
.IP "import_GDOME" 4
.IX Item "import_GDOME"
.Vb 1
\&  $libxmlnode = XML::LibXML\->import_GDOME( $node, $deep );
.Ve
.Sp
This clones an \s-1XML::GDOME\s0 node to an XML::LibXML node explicitly.
.IP "export_GDOME" 4
.IX Item "export_GDOME"
.Vb 1
\&  $gdomenode = XML::LibXML\->export_GDOME( $node, $deep );
.Ve
.Sp
Allows to clone an XML::LibXML node into an \s-1XML::GDOME\s0 node.
.SH "CONTACTS"
.IX Header "CONTACTS"
For bug reports, please use the \s-1CPAN\s0 request tracker on
http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML\-LibXML
.PP
For suggestions etc., and other issues related to XML::LibXML you may use the
perl \s-1XML\s0 mailing list (\f(CW\*(C`perl\-xml@listserv.ActiveState.com\*(C'\fR), where most XML-related Perl modules are discussed. In case of problems you
should check the archives of that list first. Many problems are already
discussed there. You can find the list's archives and subscription options at http://aspn.activestate.com/ASPN/Mail/Browse/Threaded/perl\-xml <http://aspn.activestate.com/ASPN/Mail/Browse/Threaded/perl-xml>.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML5.18.3pm                          0100644 0001750 0001750 00000051132 12566241670 023454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LibXML 3"
.TH LibXML 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML \- Perl Binding for libxml2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use XML::LibXML;
\&  my $dom = XML::LibXML\->load_xml(string => <<\*(AqEOT\*(Aq);
\&  <some\-xml/>
\&  EOT
\&
\&  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
\&  $Version_ID = XML::LibXML::LIBXML_VERSION;
\&  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
\&  $libxmlnode = XML::LibXML\->import_GDOME( $node, $deep );
\&  $gdomenode = XML::LibXML\->export_GDOME( $node, $deep );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an interface to libxml2, providing \s-1XML\s0 and \s-1HTML\s0 parsers with
\&\s-1DOM, SAX\s0 and XMLReader interfaces, a large subset of \s-1DOM\s0 Layer 3 interface and
a XML::XPath\-like interface to XPath \s-1API\s0 of libxml2. The module is split into
several packages which are not described in this section; unless stated
otherwise, you only need to \f(CW\*(C`use XML::LibXML;\*(C'\fR in your programs.
.PP
For further information, please check the following documentation:
.IP "XML::LibXML::Parser" 4
.IX Item "XML::LibXML::Parser"
Parsing \s-1XML\s0 files with XML::LibXML
.IP "XML::LibXML::DOM" 4
.IX Item "XML::LibXML::DOM"
XML::LibXML Document Object Model (\s-1DOM\s0) Implementation
.IP "XML::LibXML::SAX" 4
.IX Item "XML::LibXML::SAX"
XML::LibXML direct \s-1SAX\s0 parser
.IP "XML::LibXML::Reader" 4
.IX Item "XML::LibXML::Reader"
Reading \s-1XML\s0 with a pull-parser
.IP "XML::LibXML::Dtd" 4
.IX Item "XML::LibXML::Dtd"
XML::LibXML frontend for \s-1DTD\s0 validation
.IP "XML::LibXML::RelaxNG" 4
.IX Item "XML::LibXML::RelaxNG"
XML::LibXML frontend for RelaxNG schema validation
.IP "XML::LibXML::Schema" 4
.IX Item "XML::LibXML::Schema"
XML::LibXML frontend for W3C Schema schema validation
.IP "XML::LibXML::XPathContext" 4
.IX Item "XML::LibXML::XPathContext"
\&\s-1API\s0 for evaluating XPath expressions with enhanced support for the evaluation
context
.IP "XML::LibXML::InputCallback" 4
.IX Item "XML::LibXML::InputCallback"
Implementing custom \s-1URI\s0 Resolver and input callbacks
.IP "XML::LibXML::Common" 4
.IX Item "XML::LibXML::Common"
Common functions for XML::LibXML related Classes
.PP
The nodes in the Document Object Model (\s-1DOM\s0) are represented by the following
classes (most of which \*(L"inherit\*(R" from XML::LibXML::Node):
.IP "XML::LibXML::Document" 4
.IX Item "XML::LibXML::Document"
XML::LibXML class for \s-1DOM\s0 document nodes
.IP "XML::LibXML::Node" 4
.IX Item "XML::LibXML::Node"
Abstract base class for XML::LibXML \s-1DOM\s0 nodes
.IP "XML::LibXML::Element" 4
.IX Item "XML::LibXML::Element"
XML::LibXML class for \s-1DOM\s0 element nodes
.IP "XML::LibXML::Text" 4
.IX Item "XML::LibXML::Text"
XML::LibXML class for \s-1DOM\s0 text nodes
.IP "XML::LibXML::Comment" 4
.IX Item "XML::LibXML::Comment"
XML::LibXML class for comment \s-1DOM\s0 nodes
.IP "XML::LibXML::CDATASection" 4
.IX Item "XML::LibXML::CDATASection"
XML::LibXML class for \s-1DOM CDATA\s0 sections
.IP "XML::LibXML::Attr" 4
.IX Item "XML::LibXML::Attr"
XML::LibXML \s-1DOM\s0 attribute class
.IP "XML::LibXML::DocumentFragment" 4
.IX Item "XML::LibXML::DocumentFragment"
XML::LibXML's \s-1DOM L2\s0 Document Fragment implementation
.IP "XML::LibXML::Namespace" 4
.IX Item "XML::LibXML::Namespace"
XML::LibXML \s-1DOM\s0 namespace nodes
.IP "XML::LibXML::PI" 4
.IX Item "XML::LibXML::PI"
XML::LibXML \s-1DOM\s0 processing instruction nodes
.SH "ENCODINGS SUPPORT IN XML::LIBXML"
.IX Header "ENCODINGS SUPPORT IN XML::LIBXML"
Recall that since version 5.6.1, Perl distinguishes between character strings
(internally encoded in \s-1UTF\-8\s0) and so called binary data and, accordingly,
applies either character or byte semantics to them. A scalar representing a
character string is distinguished from a byte string by special flag (\s-1UTF8\s0).
Please refer to \fIperlunicode\fR for details.
.PP
XML::LibXML's \s-1API\s0 is designed to deal with many encodings of \s-1XML\s0 documents
completely transparently, so that the application using XML::LibXML can be
completely ignorant about the encoding of the \s-1XML\s0 documents it works with. On
the other hand, functions like \f(CW\*(C`XML::LibXML::Document\->setEncoding\*(C'\fR give the user control over the document encoding.
.PP
To ensure the aforementioned transparency and uniformity, most functions of
XML::LibXML that work with in-memory trees accept and return data as character
strings (i.e. \s-1UTF\-8\s0 encoded with the \s-1UTF8\s0 flag on) regardless of the original
document encoding; however, the functions related to I/O operations (i.e.
parsing and saving) operate with binary data (in the original document
encoding) obeying the encoding declaration of the \s-1XML\s0 documents.
.PP
Below we summarize basic rules and principles regarding encoding:
.IP "1." 4
Do \s-1NOT\s0 apply any encoding-related PerlIO layers (\f(CW\*(C`:utf8\*(C'\fR or \f(CW\*(C`:encoding(...)\*(C'\fR) to file handles that are an input for the parses or an output for a
serializer of (full) \s-1XML\s0 documents. This is because the conversion of the data
to/from the internal character representation is provided by libxml2 itself
which must be able to enforce the encoding specified by the \f(CW\*(C`<?xml version="1.0" encoding="..."?>\*(C'\fR declaration. Here is an example to follow:
.Sp
.Vb 5
\&  use XML::LibXML;
\&  # load
\&  open my $fh, \*(Aq<\*(Aq, \*(Aqfile.xml\*(Aq;
\&  binmode $fh; # drop all PerlIO layers possibly created by a use open pragma
\&  $doc = XML::LibXML\->load_xml(IO => $fh);
\&
\&  # save
\&  open my $out, \*(Aq>\*(Aq, \*(Aqout.xml\*(Aq;
\&  binmode $out; # as above
\&  $doc\->toFH($out);
\&  # or
\&  print {$out} $doc\->toString();
.Ve
.IP "2." 4
All functions working with \s-1DOM\s0 accept and return character strings (\s-1UTF\-8\s0
encoded with \s-1UTF8\s0 flag on). E.g.
.Sp
.Vb 5
\&  my $doc = XML::LibXML::Document\->new(\*(Aq1.0\*(Aq,$some_encoding);
\&  my $element = $doc\->createElement($name);
\&  $element\->appendText($text);
\&  $xml_fragment = $element\->toString(); # returns a character string
\&  $xml_document = $doc\->toString(); # returns a byte string
.Ve
.Sp
where \f(CW$some_encoding\fR is the document encoding that will be used when saving the document, and \f(CW$name\fR and \f(CW$text\fR contain character strings (\s-1UTF\-8\s0 encoded with \s-1UTF8\s0 flag on). Note that the
method \f(CW\*(C`toString\*(C'\fR returns \s-1XML\s0 as a character string if applied to other node than the Document
node and a byte string containing the appropriate
.Sp
.Vb 1
\&  <?xml version="1.0" encoding="..."?>
.Ve
.Sp
declaration if applied to a XML::LibXML::Document.
.IP "3." 4
\&\s-1DOM\s0 methods also accept binary strings in the original encoding of the document
to which the node belongs (\s-1UTF\-8\s0 is assumed if the node is not attached to any
document). Exploiting this feature is \s-1NOT RECOMMENDED\s0 since it is considered
bad practice.
.Sp
.Vb 3
\&  my $doc = XML::LibXML::Document\->new(\*(Aq1.0\*(Aq,\*(Aqiso\-8859\-2\*(Aq);
\&  my $text = $doc\->createTextNode($some_latin2_encoded_byte_string);
\&  # WORKS, BUT NOT RECOMMENDED!
.Ve
.PP
\&\fI\s-1NOTE:\s0\fR libxml2 support for many encodings is based on the iconv library. The actual
list of supported encodings may vary from platform to platform. To test if your
platform works correctly with your language encoding, build a simple document
in the particular encoding and try to parse it with XML::LibXML to see if the
parser produces any errors. Occasional crashes were reported on rare platforms
that ship with a broken version of iconv.
.SH "THREAD SUPPORT"
.IX Header "THREAD SUPPORT"
XML::LibXML since 1.67 partially supports Perl threads in Perl >= 5.8.8.
XML::LibXML can be used with threads in two ways:
.PP
By default, all XML::LibXML classes use \s-1CLONE_SKIP\s0 class method to prevent Perl
from copying XML::LibXML::* objects when a new thread is spawn. In this mode,
all XML::LibXML::* objects are thread specific. This is the safest way to work
with XML::LibXML in threads.
.PP
Alternatively, one may use
.PP
.Vb 2
\&  use threads;
\&  use XML::LibXML qw(:threads_shared);
.Ve
.PP
to indicate, that all XML::LibXML node and parser objects should be shared
between the main thread and any thread spawn from there. For example, in
.PP
.Vb 6
\&  my $doc = XML::LibXML\->load_xml(location => $filename);
\&  my $thr = threads\->new(sub{
\&    # code working with $doc
\&    1;
\&  });
\&  $thr\->join;
.Ve
.PP
the variable \f(CW$doc\fR refers to the exact same XML::LibXML::Document in the spawned thread as in the
main thread.
.PP
Without using mutex locks, parallel threads may read the same document (i.e.
any node that belongs to the document), parse files, and modify different
documents.
.PP
However, if there is a chance that some of the threads will attempt to modify a
document (or even create new nodes based on that document, e.g. with \f(CW\*(C`$doc\->createElement\*(C'\fR) that other threads may be reading at the same time, the user is responsible
for creating a mutex lock and using it in \fIboth\fR in the thread that modifies and the thread that reads:
.PP
.Vb 10
\&  my $doc = XML::LibXML\->load_xml(location => $filename);
\&  my $mutex : shared;
\&  my $thr = threads\->new(sub{
\&     lock $mutex;
\&     my $el = $doc\->createElement(\*(Aqfoo\*(Aq);
\&     # ...
\&    1;
\&  });
\&  {
\&    lock $mutex;
\&    my $root = $doc\->documentElement;
\&    say $root\->name;
\&  }
\&  $thr\->join;
.Ve
.PP
Note that libxml2 uses dictionaries to store short strings and these
dictionaries are kept on a document node. Without mutex locks, it could happen
in the previous example that the thread modifies the dictionary while other
threads attempt to read from it, which could easily lead to a crash.
.SH "VERSION INFORMATION"
.IX Header "VERSION INFORMATION"
Sometimes it is useful to figure out, for which version XML::LibXML was
compiled for. In most cases this is for debugging or to check if a given
installation meets all functionality for the package. The functions
XML::LibXML::LIBXML_DOTTED_VERSION and XML::LibXML::LIBXML_VERSION provide this
version information. Both functions simply pass through the values of the
similar named macros of libxml2. Similarly, XML::LibXML::LIBXML_RUNTIME_VERSION
returns the version of the (usually dynamically) linked libxml2.
.IP "XML::LibXML::LIBXML_DOTTED_VERSION" 4
.IX Item "XML::LibXML::LIBXML_DOTTED_VERSION"
.Vb 1
\&  $Version_String = XML::LibXML::LIBXML_DOTTED_VERSION;
.Ve
.Sp
Returns the version string of the libxml2 version XML::LibXML was compiled for.
This will be \*(L"2.6.2\*(R" for \*(L"libxml2 2.6.2\*(R".
.IP "XML::LibXML::LIBXML_VERSION" 4
.IX Item "XML::LibXML::LIBXML_VERSION"
.Vb 1
\&  $Version_ID = XML::LibXML::LIBXML_VERSION;
.Ve
.Sp
Returns the version id of the libxml2 version XML::LibXML was compiled for.
This will be \*(L"20602\*(R" for \*(L"libxml2 2.6.2\*(R". Don't mix this version id with
\&\f(CW$XML::LibXML::VERSION\fR. The latter contains the version of XML::LibXML itself
while the first contains the version of libxml2 XML::LibXML was compiled for.
.IP "XML::LibXML::LIBXML_RUNTIME_VERSION" 4
.IX Item "XML::LibXML::LIBXML_RUNTIME_VERSION"
.Vb 1
\&  $DLL_Version = XML::LibXML::LIBXML_RUNTIME_VERSION;
.Ve
.Sp
Returns a version string of the libxml2 which is (usually dynamically) linked
by XML::LibXML. This will be \*(L"20602\*(R" for libxml2 released as \*(L"2.6.2\*(R" and
something like \*(L"20602\-CVS2032\*(R" for a \s-1CVS\s0 build of libxml2.
.Sp
XML::LibXML issues a warning if the version of libxml2 dynamically linked to it
is less than the version of libxml2 which it was compiled against.
.SH "EXPORTS"
.IX Header "EXPORTS"
By default the module exports all constants and functions listed in the :all
tag, described below.
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.ie n .IP """:all""" 4
.el .IP "\f(CW:all\fR" 4
.IX Item ":all"
Includes the tags \f(CW\*(C`:libxml\*(C'\fR, \f(CW\*(C`:encoding\*(C'\fR, and \f(CW\*(C`:ns\*(C'\fR described below.
.ie n .IP """:libxml""" 4
.el .IP "\f(CW:libxml\fR" 4
.IX Item ":libxml"
Exports integer constants for \s-1DOM\s0 node types.
.Sp
.Vb 10
\&  XML_ELEMENT_NODE            => 1
\&  XML_ATTRIBUTE_NODE          => 2
\&  XML_TEXT_NODE               => 3
\&  XML_CDATA_SECTION_NODE      => 4
\&  XML_ENTITY_REF_NODE         => 5
\&  XML_ENTITY_NODE             => 6
\&  XML_PI_NODE                 => 7
\&  XML_COMMENT_NODE            => 8
\&  XML_DOCUMENT_NODE           => 9
\&  XML_DOCUMENT_TYPE_NODE      => 10
\&  XML_DOCUMENT_FRAG_NODE      => 11
\&  XML_NOTATION_NODE           => 12
\&  XML_HTML_DOCUMENT_NODE      => 13
\&  XML_DTD_NODE                => 14
\&  XML_ELEMENT_DECL            => 15
\&  XML_ATTRIBUTE_DECL          => 16
\&  XML_ENTITY_DECL             => 17
\&  XML_NAMESPACE_DECL          => 18
\&  XML_XINCLUDE_START          => 19
\&  XML_XINCLUDE_END            => 20
.Ve
.ie n .IP """:encoding""" 4
.el .IP "\f(CW:encoding\fR" 4
.IX Item ":encoding"
Exports two encoding conversion functions from XML::LibXML::Common.
.Sp
.Vb 2
\&  encodeToUTF8()
\&  decodeFromUTF8()
.Ve
.ie n .IP """:ns""" 4
.el .IP "\f(CW:ns\fR" 4
.IX Item ":ns"
Exports two convenience constants: the implicit namespace of the reserved \f(CW\*(C`xml:\*(C'\fR prefix, and the implicit namespace for the reserved \f(CW\*(C`xmlns:\*(C'\fR prefix.
.Sp
.Vb 2
\&  XML_XML_NS    => \*(Aqhttp://www.w3.org/XML/1998/namespace\*(Aq
\&  XML_XMLNS_NS  => \*(Aqhttp://www.w3.org/2000/xmlns/\*(Aq
.Ve
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
The modules described in this section are not part of the XML::LibXML package
itself. As they support some additional features, they are mentioned here.
.IP "XML::LibXSLT" 4
.IX Item "XML::LibXSLT"
\&\s-1XSLT 1.0\s0 Processor using libxslt and XML::LibXML
.IP "XML::LibXML::Iterator" 4
.IX Item "XML::LibXML::Iterator"
XML::LibXML Implementation of the \s-1DOM\s0 Traversal Specification
.IP "XML::CompactTree::XS" 4
.IX Item "XML::CompactTree::XS"
Uses XML::LibXML::Reader to very efficiently to parse \s-1XML\s0 document or element
into native Perl data structures, which are less flexible but significantly
faster to process then \s-1DOM.\s0
.SH "XML::LIBXML AND XML::GDOME"
.IX Header "XML::LIBXML AND XML::GDOME"
Note: \fI\s-1THE FUNCTIONS DESCRIBED HERE ARE STILL EXPERIMENTAL\s0\fR
.PP
Although both modules make use of libxml2's \s-1XML\s0 capabilities, the \s-1DOM\s0
implementation of both modules are not compatible. But still it is possible to
exchange nodes from one \s-1DOM\s0 to the other. The concept of this exchange is
pretty similar to the function \fIcloneNode()\fR: The particular node is copied on
the low-level to the opposite \s-1DOM\s0 implementation.
.PP
Since the \s-1DOM\s0 implementations cannot coexist within one document, one is forced
to copy each node that should be used. Because you are always keeping two nodes
this may cause quite an impact on a machines memory usage.
.PP
XML::LibXML provides two functions to export or import \s-1GDOME\s0 nodes:
\&\fIimport_GDOME()\fR and \fIexport_GDOME()\fR. Both function have two parameters: the node
and a flag for recursive import. The flag works as in \fIcloneNode()\fR.
.PP
The two functions allow to export and import \s-1XML::GDOME\s0 nodes explicitly,
however, XML::LibXML allows also the transparent import of \s-1XML::GDOME\s0 nodes in
functions such as \fIappendChild()\fR, \fIinsertAfter()\fR and so on. While native nodes
are automatically adopted in most functions \s-1XML::GDOME\s0 nodes are always cloned
in advance. Thus if the original node is modified after the operation, the node
in the XML::LibXML document will not have this information.
.IP "import_GDOME" 4
.IX Item "import_GDOME"
.Vb 1
\&  $libxmlnode = XML::LibXML\->import_GDOME( $node, $deep );
.Ve
.Sp
This clones an \s-1XML::GDOME\s0 node to an XML::LibXML node explicitly.
.IP "export_GDOME" 4
.IX Item "export_GDOME"
.Vb 1
\&  $gdomenode = XML::LibXML\->export_GDOME( $node, $deep );
.Ve
.Sp
Allows one to clone an XML::LibXML node into an \s-1XML::GDOME\s0 node.
.SH "CONTACTS"
.IX Header "CONTACTS"
For bug reports, please use the \s-1CPAN\s0 request tracker on
http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML\-LibXML
.PP
For suggestions etc., and other issues related to XML::LibXML you may use the
perl \s-1XML\s0 mailing list (\f(CW\*(C`perl\-xml@listserv.ActiveState.com\*(C'\fR), where most XML-related Perl modules are discussed. In case of problems you
should check the archives of that list first. Many problems are already
discussed there. You can find the list's archives and subscription options at <http://aspn.activestate.com/ASPN/Mail/Browse/Threaded/perl\-xml>.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Attr.3pm                        0100644 0001750 0001750 00000020737 12566241670 024166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Attr 3"
.TH XML::LibXML::Attr 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Attr \- XML::LibXML Attribute Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Attribute nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $attr = XML::LibXML::Attr\->new($name [,$value]);
\&  $string = $attr\->getValue();
\&  $string = $attr\->value;
\&  $attr\->setValue( $string );
\&  $node = $attr\->getOwnerElement();
\&  $attr\->setNamespace($nsURI, $prefix);
\&  $bool = $attr\->isId;
\&  $string = $attr\->serializeContent;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the interface to handle Attributes like ordinary nodes. The naming of
the class relies on the W3C \s-1DOM\s0 documentation.
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $attr = XML::LibXML::Attr\->new($name [,$value]);
.Ve
.Sp
Class constructor. If you need to work with \s-1ISO\s0 encoded strings, you should \fIalways\fR use the \f(CW\*(C`createAttribute\*(C'\fR of XML::LibXML::Document.
.IP "getValue" 4
.IX Item "getValue"
.Vb 1
\&  $string = $attr\->getValue();
.Ve
.Sp
Returns the value stored for the attribute. If undef is returned, the attribute
has no value, which is different of being \f(CW\*(C`not specified\*(C'\fR.
.IP "value" 4
.IX Item "value"
.Vb 1
\&  $string = $attr\->value;
.Ve
.Sp
Alias for \fI\fIgetValue()\fI\fR
.IP "setValue" 4
.IX Item "setValue"
.Vb 1
\&  $attr\->setValue( $string );
.Ve
.Sp
This is needed to set a new attribute value. If \s-1ISO\s0 encoded strings are passed
as parameter, the node has to be bound to a document, otherwise the encoding
might be done incorrectly.
.IP "getOwnerElement" 4
.IX Item "getOwnerElement"
.Vb 1
\&  $node = $attr\->getOwnerElement();
.Ve
.Sp
returns the node the attribute belongs to. If the attribute is not bound to a
node, undef will be returned. Overwriting the underlying implementation, the \fIparentNode\fR function will return undef, instead of the owner element.
.IP "setNamespace" 4
.IX Item "setNamespace"
.Vb 1
\&  $attr\->setNamespace($nsURI, $prefix);
.Ve
.Sp
This function tries to bound the attribute to a given namespace. If \f(CW$nsURI\fR is undefined or empty, the function discards any previous association of the
attribute with a namespace. If the namespace was not previously declared in the
context of the attribute, this function will fail. In this case you may wish to
call \fIsetNamespace()\fR on the ownerElement. If the namespace \s-1URI\s0 is non-empty and
declared in the context of the attribute, but only with a different (non-empty)
prefix, then the attribute is still bound to the namespace but gets a different
prefix than \f(CW$prefix\fR. The function also fails if the prefix is empty but the namespace \s-1URI\s0 is not
(because unprefixed attributes should by definition belong to no namespace).
This function returns 1 on success, 0 otherwise.
.IP "isId" 4
.IX Item "isId"
.Vb 1
\&  $bool = $attr\->isId;
.Ve
.Sp
Determine whether an attribute is of type \s-1ID.\s0 For documents with a \s-1DTD,\s0 this
information is only available if \s-1DTD\s0 loading/validation has been requested. For
\&\s-1HTML\s0 documents parsed with the \s-1HTML\s0 parser \s-1ID\s0 detection is done automatically.
In \s-1XML\s0 documents, all \*(L"xml:id\*(R" attributes are considered to be of type \s-1ID.\s0
.IP "serializeContent($docencoding)" 4
.IX Item "serializeContent($docencoding)"
.Vb 1
\&  $string = $attr\->serializeContent;
.Ve
.Sp
This function is not part of \s-1DOM API.\s0 It returns attribute content in the form
in which it serializes into \s-1XML,\s0 that is with all meta-characters properly
quoted and with raw entity references (except for entities expanded during
parse time). Setting the optional \f(CW$docencoding\fR flag to 1 enforces document
encoding for the output string (which is then passed to Perl as a byte string).
Otherwise the string is passed to Perl as (\s-1UTF\-8\s0 encoded) characters.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Attr5.16.3pm                    0100644 0001750 0001750 00000020254 12566241665 024476  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Attr 3"
.TH XML::LibXML::Attr 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Attr \- XML::LibXML Attribute Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Attribute nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $attr = XML::LibXML::Attr\->new($name [,$value]);
\&  $string = $attr\->getValue();
\&  $string = $attr\->value;
\&  $attr\->setValue( $string );
\&  $node = $attr\->getOwnerElement();
\&  $attr\->setNamespace($nsURI, $prefix);
\&  $bool = $attr\->isId;
\&  $string = $attr\->serializeContent;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the interface to handle Attributes like ordinary nodes. The naming of
the class relies on the W3C \s-1DOM\s0 documentation.
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (http://www.w3.org/TR/DOM\-Level\-3\-Core/ <http://www.w3.org/TR/DOM-Level-3-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $attr = XML::LibXML::Attr\->new($name [,$value]);
.Ve
.Sp
Class constructor. If you need to work with \s-1ISO\s0 encoded strings, you should \fIalways\fR use the \f(CW\*(C`createAttribute\*(C'\fR of XML::LibXML::Document.
.IP "getValue" 4
.IX Item "getValue"
.Vb 1
\&  $string = $attr\->getValue();
.Ve
.Sp
Returns the value stored for the attribute. If undef is returned, the attribute
has no value, which is different of being \f(CW\*(C`not specified\*(C'\fR.
.IP "value" 4
.IX Item "value"
.Vb 1
\&  $string = $attr\->value;
.Ve
.Sp
Alias for \fI\fIgetValue()\fI\fR
.IP "setValue" 4
.IX Item "setValue"
.Vb 1
\&  $attr\->setValue( $string );
.Ve
.Sp
This is needed to set a new attribute value. If \s-1ISO\s0 encoded strings are passed
as parameter, the node has to be bound to a document, otherwise the encoding
might be done incorrectly.
.IP "getOwnerElement" 4
.IX Item "getOwnerElement"
.Vb 1
\&  $node = $attr\->getOwnerElement();
.Ve
.Sp
returns the node the attribute belongs to. If the attribute is not bound to a
node, undef will be returned. Overwriting the underlying implementation, the \fIparentNode\fR function will return undef, instead of the owner element.
.IP "setNamespace" 4
.IX Item "setNamespace"
.Vb 1
\&  $attr\->setNamespace($nsURI, $prefix);
.Ve
.Sp
This function tries to bound the attribute to a given namespace. If \f(CW$nsURI\fR is undefined or empty, the function discards any previous association of the
attribute with a namespace. If the namespace was not previously declared in the
context of the attribute, this function will fail. In this case you may wish to
call \fIsetNamespace()\fR on the ownerElement. If the namespace \s-1URI\s0 is non-empty and
declared in the context of the attribute, but only with a different (non-empty)
prefix, then the attribute is still bound to the namespace but gets a different
prefix than \f(CW$prefix\fR. The function also fails if the prefix is empty but the namespace \s-1URI\s0 is not
(because unprefixed attributes should by definition belong to no namespace).
This function returns 1 on success, 0 otherwise.
.IP "isId" 4
.IX Item "isId"
.Vb 1
\&  $bool = $attr\->isId;
.Ve
.Sp
Determine whether an attribute is of type \s-1ID\s0. For documents with a \s-1DTD\s0, this
information is only available if \s-1DTD\s0 loading/validation has been requested. For
\&\s-1HTML\s0 documents parsed with the \s-1HTML\s0 parser \s-1ID\s0 detection is done automatically.
In \s-1XML\s0 documents, all \*(L"xml:id\*(R" attributes are considered to be of type \s-1ID\s0.
.IP "serializeContent($docencoding)" 4
.IX Item "serializeContent($docencoding)"
.Vb 1
\&  $string = $attr\->serializeContent;
.Ve
.Sp
This function is not part of \s-1DOM\s0 \s-1API\s0. It returns attribute content in the form
in which it serializes into \s-1XML\s0, that is with all meta-characters properly
quoted and with raw entity references (except for entities expanded during
parse time). Setting the optional \f(CW$docencoding\fR flag to 1 enforces document
encoding for the output string (which is then passed to Perl as a byte string).
Otherwise the string is passed to Perl as (\s-1UTF\-8\s0 encoded) characters.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Attr5.18.3pm                    0100644 0001750 0001750 00000020737 12566241670 024502  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Attr 3"
.TH XML::LibXML::Attr 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Attr \- XML::LibXML Attribute Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Attribute nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $attr = XML::LibXML::Attr\->new($name [,$value]);
\&  $string = $attr\->getValue();
\&  $string = $attr\->value;
\&  $attr\->setValue( $string );
\&  $node = $attr\->getOwnerElement();
\&  $attr\->setNamespace($nsURI, $prefix);
\&  $bool = $attr\->isId;
\&  $string = $attr\->serializeContent;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the interface to handle Attributes like ordinary nodes. The naming of
the class relies on the W3C \s-1DOM\s0 documentation.
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $attr = XML::LibXML::Attr\->new($name [,$value]);
.Ve
.Sp
Class constructor. If you need to work with \s-1ISO\s0 encoded strings, you should \fIalways\fR use the \f(CW\*(C`createAttribute\*(C'\fR of XML::LibXML::Document.
.IP "getValue" 4
.IX Item "getValue"
.Vb 1
\&  $string = $attr\->getValue();
.Ve
.Sp
Returns the value stored for the attribute. If undef is returned, the attribute
has no value, which is different of being \f(CW\*(C`not specified\*(C'\fR.
.IP "value" 4
.IX Item "value"
.Vb 1
\&  $string = $attr\->value;
.Ve
.Sp
Alias for \fI\fIgetValue()\fI\fR
.IP "setValue" 4
.IX Item "setValue"
.Vb 1
\&  $attr\->setValue( $string );
.Ve
.Sp
This is needed to set a new attribute value. If \s-1ISO\s0 encoded strings are passed
as parameter, the node has to be bound to a document, otherwise the encoding
might be done incorrectly.
.IP "getOwnerElement" 4
.IX Item "getOwnerElement"
.Vb 1
\&  $node = $attr\->getOwnerElement();
.Ve
.Sp
returns the node the attribute belongs to. If the attribute is not bound to a
node, undef will be returned. Overwriting the underlying implementation, the \fIparentNode\fR function will return undef, instead of the owner element.
.IP "setNamespace" 4
.IX Item "setNamespace"
.Vb 1
\&  $attr\->setNamespace($nsURI, $prefix);
.Ve
.Sp
This function tries to bound the attribute to a given namespace. If \f(CW$nsURI\fR is undefined or empty, the function discards any previous association of the
attribute with a namespace. If the namespace was not previously declared in the
context of the attribute, this function will fail. In this case you may wish to
call \fIsetNamespace()\fR on the ownerElement. If the namespace \s-1URI\s0 is non-empty and
declared in the context of the attribute, but only with a different (non-empty)
prefix, then the attribute is still bound to the namespace but gets a different
prefix than \f(CW$prefix\fR. The function also fails if the prefix is empty but the namespace \s-1URI\s0 is not
(because unprefixed attributes should by definition belong to no namespace).
This function returns 1 on success, 0 otherwise.
.IP "isId" 4
.IX Item "isId"
.Vb 1
\&  $bool = $attr\->isId;
.Ve
.Sp
Determine whether an attribute is of type \s-1ID.\s0 For documents with a \s-1DTD,\s0 this
information is only available if \s-1DTD\s0 loading/validation has been requested. For
\&\s-1HTML\s0 documents parsed with the \s-1HTML\s0 parser \s-1ID\s0 detection is done automatically.
In \s-1XML\s0 documents, all \*(L"xml:id\*(R" attributes are considered to be of type \s-1ID.\s0
.IP "serializeContent($docencoding)" 4
.IX Item "serializeContent($docencoding)"
.Vb 1
\&  $string = $attr\->serializeContent;
.Ve
.Sp
This function is not part of \s-1DOM API.\s0 It returns attribute content in the form
in which it serializes into \s-1XML,\s0 that is with all meta-characters properly
quoted and with raw entity references (except for entities expanded during
parse time). Setting the optional \f(CW$docencoding\fR flag to 1 enforces document
encoding for the output string (which is then passed to Perl as a byte string).
Otherwise the string is passed to Perl as (\s-1UTF\-8\s0 encoded) characters.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::AttributeHash.3pm               0100644 0001750 0001750 00000013121 12566241670 026010  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::AttributeHash 3"
.TH XML::LibXML::AttributeHash 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::AttributeHash \- tie an XML::LibXML::Element to a hash to access its attributes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element;
\& $hash{\*(Aqhref\*(Aq} = \*(Aqhttp://example.com/\*(Aq;
\& print $element\->getAttribute(\*(Aqhref\*(Aq) . "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class allows an element's attributes to be accessed as if they were a
plain old Perl hash. Attribute names become hash keys. Namespaced attributes
are keyed using Clark notation.
.PP
.Vb 4
\& my $XLINK = \*(Aqhttp://www.w3.org/1999/xlink\*(Aq;
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element;
\& $hash{"{$XLINK}href"} = \*(Aqhttp://localhost/\*(Aq;
\& print $element\->getAttributeNS($XLINK, \*(Aqhref\*(Aq) . "\en";
.Ve
.PP
There is rarely any need to use XML::LibXML::AttributeHash directly. In
general, it is possible to take advantage of XML::LibXML::Element's
overloading. The example in the \s-1SYNOPSIS\s0 could have been written:
.PP
.Vb 2
\& $element\->{\*(Aqhref\*(Aq} = \*(Aqhttp://example.com/\*(Aq;
\& print $element\->getAttribute(\*(Aqhref\*(Aq) . "\en";
.Ve
.PP
The tie interface allows the passing of additional arguments to
XML::LibXML::AttributeHash:
.PP
.Vb 1
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element, %args;
.Ve
.PP
Currently only one argument is supported, the boolean \*(L"weaken\*(R" which (if
true) indicates that the tied object's reference to the element should be
a weak reference. This is used by XML::LibXML::Element's overloading. The
\&\*(L"weaken\*(R" argument is ignored if you don't have a working Scalar::Util::weaken.
                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::AttributeHash5.16.3pm           0100644 0001750 0001750 00000012600 12566241665 026327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::AttributeHash 3"
.TH XML::LibXML::AttributeHash 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::AttributeHash \- tie an XML::LibXML::Element to a hash to access its attributes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element;
\& $hash{\*(Aqhref\*(Aq} = \*(Aqhttp://example.com/\*(Aq;
\& print $element\->getAttribute(\*(Aqhref\*(Aq) . "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class allows an element's attributes to be accessed as if they were a
plain old Perl hash. Attribute names become hash keys. Namespaced attributes
are keyed using Clark notation.
.PP
.Vb 4
\& my $XLINK = \*(Aqhttp://www.w3.org/1999/xlink\*(Aq;
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element;
\& $hash{"{$XLINK}href"} = \*(Aqhttp://localhost/\*(Aq;
\& print $element\->getAttributeNS($XLINK, \*(Aqhref\*(Aq) . "\en";
.Ve
.PP
There is rarely any need to use XML::LibXML::AttributeHash directly. In
general, it is possible to take advantage of XML::LibXML::Element's
overloading. The example in the \s-1SYNOPSIS\s0 could have been written:
.PP
.Vb 2
\& $element\->{\*(Aqhref\*(Aq} = \*(Aqhttp://example.com/\*(Aq;
\& print $element\->getAttribute(\*(Aqhref\*(Aq) . "\en";
.Ve
.PP
The tie interface allows the passing of additional arguments to
XML::LibXML::AttributeHash:
.PP
.Vb 1
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element, %args;
.Ve
.PP
Currently only one argument is supported, the boolean \*(L"weaken\*(R" which (if
true) indicates that the tied object's reference to the element should be
a weak reference. This is used by XML::LibXML::Element's overloading. The
\&\*(L"weaken\*(R" argument is ignored if you don't have a working Scalar::Util::weaken.
                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::AttributeHash5.18.3pm           0100644 0001750 0001750 00000013121 12566241670 026324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::AttributeHash 3"
.TH XML::LibXML::AttributeHash 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::AttributeHash \- tie an XML::LibXML::Element to a hash to access its attributes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element;
\& $hash{\*(Aqhref\*(Aq} = \*(Aqhttp://example.com/\*(Aq;
\& print $element\->getAttribute(\*(Aqhref\*(Aq) . "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class allows an element's attributes to be accessed as if they were a
plain old Perl hash. Attribute names become hash keys. Namespaced attributes
are keyed using Clark notation.
.PP
.Vb 4
\& my $XLINK = \*(Aqhttp://www.w3.org/1999/xlink\*(Aq;
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element;
\& $hash{"{$XLINK}href"} = \*(Aqhttp://localhost/\*(Aq;
\& print $element\->getAttributeNS($XLINK, \*(Aqhref\*(Aq) . "\en";
.Ve
.PP
There is rarely any need to use XML::LibXML::AttributeHash directly. In
general, it is possible to take advantage of XML::LibXML::Element's
overloading. The example in the \s-1SYNOPSIS\s0 could have been written:
.PP
.Vb 2
\& $element\->{\*(Aqhref\*(Aq} = \*(Aqhttp://example.com/\*(Aq;
\& print $element\->getAttribute(\*(Aqhref\*(Aq) . "\en";
.Ve
.PP
The tie interface allows the passing of additional arguments to
XML::LibXML::AttributeHash:
.PP
.Vb 1
\& tie my %hash, \*(AqXML::LibXML::AttributeHash\*(Aq, $element, %args;
.Ve
.PP
Currently only one argument is supported, the boolean \*(L"weaken\*(R" which (if
true) indicates that the tied object's reference to the element should be
a weak reference. This is used by XML::LibXML::Element's overloading. The
\&\*(L"weaken\*(R" argument is ignored if you don't have a working Scalar::Util::weaken.
                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Boolean.3pm                     0100644 0001750 0001750 00000011070 12566241670 024621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Boolean 3"
.TH XML::LibXML::Boolean 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Boolean \- Boolean true/false values
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML::Boolean objects implement simple boolean true/false objects.
.SH "API"
.IX Header "API"
.SS "XML::LibXML::Boolean\->True"
.IX Subsection "XML::LibXML::Boolean->True"
Creates a new Boolean object with a true value.
.SS "XML::LibXML::Boolean\->False"
.IX Subsection "XML::LibXML::Boolean->False"
Creates a new Boolean object with a false value.
.SS "\fIvalue()\fP"
.IX Subsection "value()"
Returns true or false.
.SS "\fIto_literal()\fP"
.IX Subsection "to_literal()"
Returns the string \*(L"true\*(R" or \*(L"false\*(R".
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Boolean5.16.3pm                 0100644 0001750 0001750 00000010547 12566241665 025147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Boolean 3"
.TH XML::LibXML::Boolean 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Boolean \- Boolean true/false values
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML::Boolean objects implement simple boolean true/false objects.
.SH "API"
.IX Header "API"
.SS "XML::LibXML::Boolean\->True"
.IX Subsection "XML::LibXML::Boolean->True"
Creates a new Boolean object with a true value.
.SS "XML::LibXML::Boolean\->False"
.IX Subsection "XML::LibXML::Boolean->False"
Creates a new Boolean object with a false value.
.SS "\fIvalue()\fP"
.IX Subsection "value()"
Returns true or false.
.SS "\fIto_literal()\fP"
.IX Subsection "to_literal()"
Returns the string \*(L"true\*(R" or \*(L"false\*(R".
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Boolean5.18.3pm                 0100644 0001750 0001750 00000011070 12566241670 025135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Boolean 3"
.TH XML::LibXML::Boolean 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Boolean \- Boolean true/false values
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML::Boolean objects implement simple boolean true/false objects.
.SH "API"
.IX Header "API"
.SS "XML::LibXML::Boolean\->True"
.IX Subsection "XML::LibXML::Boolean->True"
Creates a new Boolean object with a true value.
.SS "XML::LibXML::Boolean\->False"
.IX Subsection "XML::LibXML::Boolean->False"
Creates a new Boolean object with a false value.
.SS "\fIvalue()\fP"
.IX Subsection "value()"
Returns true or false.
.SS "\fIto_literal()\fP"
.IX Subsection "to_literal()"
Returns the string \*(L"true\*(R" or \*(L"false\*(R".
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::CDATASection.3pm                0100644 0001750 0001750 00000012547 12566241670 025415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::CDATASection 3"
.TH XML::LibXML::CDATASection 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::CDATASection \- XML::LibXML Class for CDATA Sections
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to CDATA nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::CDATASection\->new( $content );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides all functions of XML::LibXML::Text, but for \s-1CDATA\s0 nodes.
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::CDATASection\->new( $content );
.Ve
.Sp
The constructor is the only provided function for this package. It is required,
because \fIlibxml2\fR treats the different text node types slightly differently.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::CDATASection5.16.3pm            0100644 0001750 0001750 00000012055 12566241665 025725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::CDATASection 3"
.TH XML::LibXML::CDATASection 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::CDATASection \- XML::LibXML Class for CDATA Sections
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to CDATA nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::CDATASection\->new( $content );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides all functions of XML::LibXML::Text, but for \s-1CDATA\s0 nodes.
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (http://www.w3.org/TR/DOM\-Level\-3\-Core/ <http://www.w3.org/TR/DOM-Level-3-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::CDATASection\->new( $content );
.Ve
.Sp
The constructor is the only provided function for this package. It is required,
because \fIlibxml2\fR treats the different text node types slightly differently.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::CDATASection5.18.3pm            0100644 0001750 0001750 00000012547 12566241670 025731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::CDATASection 3"
.TH XML::LibXML::CDATASection 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::CDATASection \- XML::LibXML Class for CDATA Sections
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to CDATA nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::CDATASection\->new( $content );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides all functions of XML::LibXML::Text, but for \s-1CDATA\s0 nodes.
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::CDATASection\->new( $content );
.Ve
.Sp
The constructor is the only provided function for this package. It is required,
because \fIlibxml2\fR treats the different text node types slightly differently.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Comment.3pm                     0100644 0001750 0001750 00000012650 12566241667 024657  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Comment 3"
.TH XML::LibXML::Comment 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Comment \- XML::LibXML Comment Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Comment nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::Comment\->new( $content );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides all functions of XML::LibXML::Text, but for comment nodes. This can be done, since only the output of the node
types is different, but not the data structure. :\-)
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::Comment\->new( $content );
.Ve
.Sp
The constructor is the only provided function for this package. It is required,
because \fIlibxml2\fR treats text nodes and comment nodes slightly differently.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Comment5.16.3pm                 0100644 0001750 0001750 00000012156 12566241665 025170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Comment 3"
.TH XML::LibXML::Comment 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Comment \- XML::LibXML Comment Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Comment nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::Comment\->new( $content );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides all functions of XML::LibXML::Text, but for comment nodes. This can be done, since only the output of the node
types is different, but not the data structure. :\-)
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (http://www.w3.org/TR/DOM\-Level\-3\-Core/ <http://www.w3.org/TR/DOM-Level-3-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::Comment\->new( $content );
.Ve
.Sp
The constructor is the only provided function for this package. It is required,
because \fIlibxml2\fR treats text nodes and comment nodes slightly differently.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Comment5.18.3pm                 0100644 0001750 0001750 00000012650 12566241667 025173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Comment 3"
.TH XML::LibXML::Comment 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Comment \- XML::LibXML Comment Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Comment nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::Comment\->new( $content );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides all functions of XML::LibXML::Text, but for comment nodes. This can be done, since only the output of the node
types is different, but not the data structure. :\-)
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::Comment\->new( $content );
.Ve
.Sp
The constructor is the only provided function for this package. It is required,
because \fIlibxml2\fR treats text nodes and comment nodes slightly differently.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Common.3pm                      0100644 0001750 0001750 00000020007 12566241670 024472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Common 3"
.TH XML::LibXML::Common 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Common \- Constants and Character Encoding Routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML::Common;
\&
\&  $encodedstring = encodeToUTF8( $name_of_encoding, $sting_to_encode );
\&  $decodedstring = decodeFromUTF8($name_of_encoding, $string_to_decode );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML::Common defines constants for all node types and provides interface
to libxml2 charset conversion functions.
.PP
Since XML::LibXML use their own node type definitions, one may want to use
XML::LibXML::Common in its compatibility mode:
.SS "Exporter \s-1TAGS\s0"
.IX Subsection "Exporter TAGS"
.Vb 1
\&  use XML::LibXML::Common qw(:libxml);
.Ve
.PP
\&\f(CW\*(C`:libxml\*(C'\fR tag will use the XML::LibXML Compatibility mode, which defines the old '\s-1XML_\s0'
node-type definitions.
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:gdome);
.Ve
.PP
\&\f(CW\*(C`:gdome\*(C'\fR tag will use the \s-1XML::GDOME\s0 Compatibility mode, which defines the old '\s-1GDOME_\s0'
node-type definitions.
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:w3c);
.Ve
.PP
This uses the nodetype definition names as specified for \s-1DOM.\s0
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:encoding);
.Ve
.PP
This tag can be used to export only the charset encoding functions of
XML::LibXML::Common.
.SS "Exports"
.IX Subsection "Exports"
By default the W3 definitions as defined in the \s-1DOM\s0 specifications and the
encoding functions are exported by XML::LibXML::Common.
.SS "Encoding functions"
.IX Subsection "Encoding functions"
To encode or decode a string to or from \s-1UTF\-8,\s0 XML::LibXML::Common exports two
functions, which provide an interface to the encoding support in \f(CW\*(C`libxml2\*(C'\fR. Which encodings are supported by these functions depends on how \f(CW\*(C`libxml2\*(C'\fR was compiled. \s-1UTF\-16\s0 is always supported and on most installations, \s-1ISO\s0
encodings are supported as well.
.PP
This interface was useful for older versions of Perl. Since Perl >= 5.8
provides similar functions via the \f(CW\*(C`Encode\*(C'\fR module, it is probably a good idea to use those instead.
.IP "encodeToUTF8" 4
.IX Item "encodeToUTF8"
.Vb 1
\&  $encodedstring = encodeToUTF8( $name_of_encoding, $sting_to_encode );
.Ve
.Sp
The function will convert a byte string from the specified encoding to an \s-1UTF\-8\s0
encoded character string.
.IP "decodeToUTF8" 4
.IX Item "decodeToUTF8"
.Vb 1
\&  $decodedstring = decodeFromUTF8($name_of_encoding, $string_to_decode );
.Ve
.Sp
This function converts an \s-1UTF\-8\s0 encoded character string to a specified
encoding. Note that the conversion can raise an error if the given string
contains characters that cannot be represented in the target encoding.
.PP
Both these functions report their errors on the standard error. If an error
occurs the function will \fIcroak()\fR. To catch the error information it is required
to call the encoding function from within an eval block in order to prevent the
entire script from being stopped on encoding error.
.SS "A note on history"
.IX Subsection "A note on history"
Before XML::LibXML 1.70, this class was available as a separate \s-1CPAN\s0
distribution, intended to provide functionality shared between XML::LibXML,
\&\s-1XML::GDOME,\s0 and possibly other modules. Since there seems to be no progress in
this direction, we decided to merge XML::LibXML::Common 0.13 and XML::LibXML
1.70 to one \s-1CPAN\s0 distribution.
.PP
The merge also naturally eliminates a practical and urgent problem experienced
by many XML::LibXML users on certain platforms, namely mysterious misbehavior
of XML::LibXML occurring if the installed (often pre-packaged) version of
XML::LibXML::Common was compiled against an older version of libxml2 than
XML::LibXML.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Common5.16.3pm                  0100644 0001750 0001750 00000017246 12566241665 025023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Common 3"
.TH XML::LibXML::Common 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Common \- Constants and Character Encoding Routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML::Common;
\&
\&  $encodedstring = encodeToUTF8( $name_of_encoding, $sting_to_encode );
\&  $decodedstring = decodeFromUTF8($name_of_encoding, $string_to_decode );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML::Common defines constants for all node types and provides interface
to libxml2 charset conversion functions.
.PP
Since XML::LibXML use their own node type definitions, one may want to use
XML::LibXML::Common in its compatibility mode:
.SS "Exporter \s-1TAGS\s0"
.IX Subsection "Exporter TAGS"
.Vb 1
\&  use XML::LibXML::Common qw(:libxml);
.Ve
.PP
\&\f(CW\*(C`:libxml\*(C'\fR tag will use the XML::LibXML Compatibility mode, which defines the old '\s-1XML_\s0'
node-type definitions.
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:gdome);
.Ve
.PP
\&\f(CW\*(C`:gdome\*(C'\fR tag will use the \s-1XML::GDOME\s0 Compatibility mode, which defines the old '\s-1GDOME_\s0'
node-type definitions.
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:w3c);
.Ve
.PP
This uses the nodetype definition names as specified for \s-1DOM\s0.
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:encoding);
.Ve
.PP
This tag can be used to export only the charset encoding functions of
XML::LibXML::Common.
.SS "Exports"
.IX Subsection "Exports"
By default the W3 definitions as defined in the \s-1DOM\s0 specifications and the
encoding functions are exported by XML::LibXML::Common.
.SS "Encoding functions"
.IX Subsection "Encoding functions"
To encode or decode a string to or from \s-1UTF\-8\s0, XML::LibXML::Common exports two
functions, which provide an interface to the encoding support in \f(CW\*(C`libxml2\*(C'\fR. Which encodings are supported by these functions depends on how \f(CW\*(C`libxml2\*(C'\fR was compiled. \s-1UTF\-16\s0 is always supported and on most installations, \s-1ISO\s0
encodings are supported as well.
.PP
This interface was useful for older versions of Perl. Since Perl >= 5.8
provides similar functions via the \f(CW\*(C`Encode\*(C'\fR module, it is probably a good idea to use those instead.
.IP "encodeToUTF8" 4
.IX Item "encodeToUTF8"
.Vb 1
\&  $encodedstring = encodeToUTF8( $name_of_encoding, $sting_to_encode );
.Ve
.Sp
The function will convert a byte string from the specified encoding to an \s-1UTF\-8\s0
encoded character string.
.IP "decodeToUTF8" 4
.IX Item "decodeToUTF8"
.Vb 1
\&  $decodedstring = decodeFromUTF8($name_of_encoding, $string_to_decode );
.Ve
.Sp
This function converts an \s-1UTF\-8\s0 encoded character string to a specified
encoding. Note that the conversion can raise an error if the given string
contains characters that cannot be represented in the target encoding.
.PP
Both these functions report their errors on the standard error. If an error
occurs the function will \fIcroak()\fR. To catch the error information it is required
to call the encoding function from within an eval block in order to prevent the
entire script from being stopped on encoding error.
.SS "A note on history"
.IX Subsection "A note on history"
Before XML::LibXML 1.70, this class was available as a separate \s-1CPAN\s0
distribution, intended to provide functionality shared between XML::LibXML,
\&\s-1XML::GDOME\s0, and possibly other modules. Since there seems to be no progress in
this direction, we decided to merge XML::LibXML::Common 0.13 and XML::LibXML
1.70 to one \s-1CPAN\s0 distribution.
.PP
The merge also naturally eliminates a practical and urgent problem experienced
by many XML::LibXML users on certain platforms, namely mysterious misbehavior
of XML::LibXML occurring if the installed (often pre-packaged) version of
XML::LibXML::Common was compiled against an older version of libxml2 than
XML::LibXML.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Common5.18.3pm                  0100644 0001750 0001750 00000020007 12566241670 025006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Common 3"
.TH XML::LibXML::Common 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Common \- Constants and Character Encoding Routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML::Common;
\&
\&  $encodedstring = encodeToUTF8( $name_of_encoding, $sting_to_encode );
\&  $decodedstring = decodeFromUTF8($name_of_encoding, $string_to_decode );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML::Common defines constants for all node types and provides interface
to libxml2 charset conversion functions.
.PP
Since XML::LibXML use their own node type definitions, one may want to use
XML::LibXML::Common in its compatibility mode:
.SS "Exporter \s-1TAGS\s0"
.IX Subsection "Exporter TAGS"
.Vb 1
\&  use XML::LibXML::Common qw(:libxml);
.Ve
.PP
\&\f(CW\*(C`:libxml\*(C'\fR tag will use the XML::LibXML Compatibility mode, which defines the old '\s-1XML_\s0'
node-type definitions.
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:gdome);
.Ve
.PP
\&\f(CW\*(C`:gdome\*(C'\fR tag will use the \s-1XML::GDOME\s0 Compatibility mode, which defines the old '\s-1GDOME_\s0'
node-type definitions.
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:w3c);
.Ve
.PP
This uses the nodetype definition names as specified for \s-1DOM.\s0
.PP
.Vb 1
\&  use XML::LibXML::Common qw(:encoding);
.Ve
.PP
This tag can be used to export only the charset encoding functions of
XML::LibXML::Common.
.SS "Exports"
.IX Subsection "Exports"
By default the W3 definitions as defined in the \s-1DOM\s0 specifications and the
encoding functions are exported by XML::LibXML::Common.
.SS "Encoding functions"
.IX Subsection "Encoding functions"
To encode or decode a string to or from \s-1UTF\-8,\s0 XML::LibXML::Common exports two
functions, which provide an interface to the encoding support in \f(CW\*(C`libxml2\*(C'\fR. Which encodings are supported by these functions depends on how \f(CW\*(C`libxml2\*(C'\fR was compiled. \s-1UTF\-16\s0 is always supported and on most installations, \s-1ISO\s0
encodings are supported as well.
.PP
This interface was useful for older versions of Perl. Since Perl >= 5.8
provides similar functions via the \f(CW\*(C`Encode\*(C'\fR module, it is probably a good idea to use those instead.
.IP "encodeToUTF8" 4
.IX Item "encodeToUTF8"
.Vb 1
\&  $encodedstring = encodeToUTF8( $name_of_encoding, $sting_to_encode );
.Ve
.Sp
The function will convert a byte string from the specified encoding to an \s-1UTF\-8\s0
encoded character string.
.IP "decodeToUTF8" 4
.IX Item "decodeToUTF8"
.Vb 1
\&  $decodedstring = decodeFromUTF8($name_of_encoding, $string_to_decode );
.Ve
.Sp
This function converts an \s-1UTF\-8\s0 encoded character string to a specified
encoding. Note that the conversion can raise an error if the given string
contains characters that cannot be represented in the target encoding.
.PP
Both these functions report their errors on the standard error. If an error
occurs the function will \fIcroak()\fR. To catch the error information it is required
to call the encoding function from within an eval block in order to prevent the
entire script from being stopped on encoding error.
.SS "A note on history"
.IX Subsection "A note on history"
Before XML::LibXML 1.70, this class was available as a separate \s-1CPAN\s0
distribution, intended to provide functionality shared between XML::LibXML,
\&\s-1XML::GDOME,\s0 and possibly other modules. Since there seems to be no progress in
this direction, we decided to merge XML::LibXML::Common 0.13 and XML::LibXML
1.70 to one \s-1CPAN\s0 distribution.
.PP
The merge also naturally eliminates a practical and urgent problem experienced
by many XML::LibXML users on certain platforms, namely mysterious misbehavior
of XML::LibXML occurring if the installed (often pre-packaged) version of
XML::LibXML::Common was compiled against an older version of libxml2 than
XML::LibXML.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::DOM.3pm                         0100644 0001750 0001750 00000025251 12566241670 023667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::DOM 3"
.TH XML::LibXML::DOM 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::DOM \- XML::LibXML DOM Implementation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML provides an light-wight interface to \fImodify\fR a node of the document tree generated by the XML::LibXML parser. This interface
follows as far as possible the \s-1DOM\s0 Level 3 specification. Additionally to the
specified functions the XML::LibXML supports some functions that are more handy
to use in the perl environment.
.PP
One also has to remember, that XML::LibXML is an interface to libxml2 nodes
which actually reside on the C\-Level of XML::LibXML. This means each node is a
reference to a structure different than a perl hash or array. The only way to
access these structure's values is through the \s-1DOM\s0 interface provided by
XML::LibXML. This also means, that one \fIcan't\fR simply inherit an XML::LibXML node and add new member variables as they were
hash keys.
.PP
The \s-1DOM\s0 interface of XML::LibXML does not intend to implement a full \s-1DOM\s0
interface as it is done by \s-1XML::GDOME\s0 and used for full featured application.
Moreover, it offers an simple way to build or modify documents that are created
by XML::LibXML's parser.
.PP
Another target of the XML::LibXML interface is to make the interfaces of
libxml2 available to the perl community. This includes also some workarounds to
some features where libxml2 assumes more control over the C\-Level that most
perl users don't have.
.PP
One of the most important parts of the XML::LibXML \s-1DOM\s0 interface is, that the
interfaces try do follow the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>) rather strictly. This means the interface functions are named as the \s-1DOM\s0
specification says and not what widespread Java interfaces claim to be
standard. Although there are several functions that have only a singular
interface that conforms to the \s-1DOM\s0 spec XML::LibXML provides an additional Java
style alias interface.
.PP
Also there are some function interfaces left over from early stages of
XML::LibXML for compatibility reasons. These interfaces are for compatibility
reasons \fIonly\fR. They might disappear in one of the future versions of XML::LibXML, so a user
is requested to switch over to the official functions.
.SS "Encodings and XML::LibXML's \s-1DOM\s0 implementation"
.IX Subsection "Encodings and XML::LibXML's DOM implementation"
See the section on Encodings in the \fIXML::LibXML\fR manual page.
.SS "Namespaces and XML::LibXML's \s-1DOM\s0 implementation"
.IX Subsection "Namespaces and XML::LibXML's DOM implementation"
XML::LibXML's \s-1DOM\s0 implementation is limited by the \s-1DOM\s0 implementation of
libxml2 which treats namespaces slightly differently than required by the \s-1DOM\s0
Level 2 specification.
.PP
According to the \s-1DOM\s0 Level 2 specification, namespaces of elements and
attributes should be persistent, and nodes should be permanently bound to
namespace URIs as they get created; it should be possible to manipulate the
special attributes used for declaring \s-1XML\s0 namespaces just as other attributes
without affecting the namespaces of other nodes. In \s-1DOM\s0 Level 2, the
application is responsible for creating the special attributes consistently
and/or for correct serialization of the document.
.PP
This is both inconvenient, causes problems in serialization of \s-1DOM\s0 to \s-1XML,\s0 and
most importantly, seems almost impossible to implement over libxml2.
.PP
In libxml2, namespace \s-1URI\s0 and prefix of a node is provided by a pointer to a
namespace declaration (appearing as a special xmlns attribute in the \s-1XML\s0
document). If the prefix or namespace \s-1URI\s0 of the declaration changes, the
prefix and namespace \s-1URI\s0 of all nodes that point to it changes as well.
Moreover, in contrast to \s-1DOM,\s0 a node (element or attribute) can only be bound
to a namespace \s-1URI\s0 if there is some namespace declaration in the document to
point to.
.PP
Therefore current \s-1DOM\s0 implementation in XML::LibXML tries to treat namespace
declarations in a compromise between reason, common sense, limitations of
libxml2, and the \s-1DOM\s0 Level 2 specification.
.PP
In XML::LibXML, special attributes declaring \s-1XML\s0 namespaces are often created
automatically, usually when a namespaced node is attached to a document and no
existing declaration of the namespace and prefix is in the scope to be reused.
In this respect, XML::LibXML \s-1DOM\s0 implementation differs from the \s-1DOM\s0 Level 2
specification according to which special attributes for declaring the
appropriate \s-1XML\s0 namespaces should not be added when a node with a namespace
prefix and namespace \s-1URI\s0 is created.
.PP
Namespace declarations are also created when XML::LibXML::Document's \fIcreateElementNS()\fR or \fIcreateAttributeNS()\fR function are used. If the a
namespace is not declared on the documentElement, the namespace will be locally
declared for the newly created node. In case of Attributes this may look a bit
confusing, since these nodes cannot have namespace declarations itself. In this
case the namespace is internally applied to the attribute and later declared on
the node the attribute is appended to (if required).
.PP
The following example may explain this a bit:
.PP
.Vb 3
\&  my $doc = XML::LibXML\->createDocument;
\&  my $root = $doc\->createElementNS( "", "foo" );
\&  $doc\->setDocumentElement( $root );
\&
\&  my $attr = $doc\->createAttributeNS( "bar", "bar:foo", "test" );
\&  $root\->setAttributeNodeNS( $attr );
.Ve
.PP
This piece of code will result in the following document:
.PP
.Vb 2
\&  <?xml version="1.0"?>
\&  <foo xmlns:bar="bar" bar:foo="test"/>
.Ve
.PP
The namespace is declared on the document element during the
\&\fIsetAttributeNodeNS()\fR call.
.PP
Namespaces can be also declared explicitly by the use of XML::LibXML::Element's
\&\fIsetNamespace()\fR function. Since 1.61, they can also be manipulated with
functions \fIsetNamespaceDeclPrefix()\fR and \fIsetNamespaceDeclURI()\fR (not available in
\&\s-1DOM\s0). Changing an \s-1URI\s0 or prefix of an existing namespace declaration affects
the namespace \s-1URI\s0 and prefix of all nodes which point to it (that is the nodes
in its scope).
.PP
It is also important to repeat the specification: While working with namespaces
you should use the namespace aware functions instead of the simplified
versions. For example you should \fInever\fR use \fIsetAttribute()\fR but \fIsetAttributeNS()\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::DOM5.16.3pm                     0100644 0001750 0001750 00000024557 12566241665 024215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::DOM 3"
.TH XML::LibXML::DOM 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::DOM \- XML::LibXML DOM Implementation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML provides an light-wight interface to \fImodify\fR a node of the document tree generated by the XML::LibXML parser. This interface
follows as far as possible the \s-1DOM\s0 Level 3 specification. Additionally to the
specified functions the XML::LibXML supports some functions that are more handy
to use in the perl environment.
.PP
One also has to remember, that XML::LibXML is an interface to libxml2 nodes
which actually reside on the C\-Level of XML::LibXML. This means each node is a
reference to a structure different than a perl hash or array. The only way to
access these structure's values is through the \s-1DOM\s0 interface provided by
XML::LibXML. This also means, that one \fIcan't\fR simply inherit an XML::LibXML node and add new member variables as they were
hash keys.
.PP
The \s-1DOM\s0 interface of XML::LibXML does not intend to implement a full \s-1DOM\s0
interface as it is done by \s-1XML::GDOME\s0 and used for full featured application.
Moreover, it offers an simple way to build or modify documents that are created
by XML::LibXML's parser.
.PP
Another target of the XML::LibXML interface is to make the interfaces of
libxml2 available to the perl community. This includes also some workarounds to
some features where libxml2 assumes more control over the C\-Level that most
perl users don't have.
.PP
One of the most important parts of the XML::LibXML \s-1DOM\s0 interface is, that the
interfaces try do follow the \s-1DOM\s0 Level 3 specification (http://www.w3.org/TR/DOM\-Level\-3\-Core/ <http://www.w3.org/TR/DOM-Level-3-Core/>) rather strictly. This means the interface functions are named as the \s-1DOM\s0
specification says and not what widespread Java interfaces claim to be
standard. Although there are several functions that have only a singular
interface that conforms to the \s-1DOM\s0 spec XML::LibXML provides an additional Java
style alias interface.
.PP
Also there are some function interfaces left over from early stages of
XML::LibXML for compatibility reasons. These interfaces are for compatibility
reasons \fIonly\fR. They might disappear in one of the future versions of XML::LibXML, so a user
is requested to switch over to the official functions.
.SS "Encodings and XML::LibXML's \s-1DOM\s0 implementation"
.IX Subsection "Encodings and XML::LibXML's DOM implementation"
See the section on Encodings in the \fIXML::LibXML\fR manual page.
.SS "Namespaces and XML::LibXML's \s-1DOM\s0 implementation"
.IX Subsection "Namespaces and XML::LibXML's DOM implementation"
XML::LibXML's \s-1DOM\s0 implementation is limited by the \s-1DOM\s0 implementation of
libxml2 which treats namespaces slightly differently than required by the \s-1DOM\s0
Level 2 specification.
.PP
According to the \s-1DOM\s0 Level 2 specification, namespaces of elements and
attributes should be persistent, and nodes should be permanently bound to
namespace URIs as they get created; it should be possible to manipulate the
special attributes used for declaring \s-1XML\s0 namespaces just as other attributes
without affecting the namespaces of other nodes. In \s-1DOM\s0 Level 2, the
application is responsible for creating the special attributes consistently
and/or for correct serialization of the document.
.PP
This is both inconvenient, causes problems in serialization of \s-1DOM\s0 to \s-1XML\s0, and
most importantly, seems almost impossible to implement over libxml2.
.PP
In libxml2, namespace \s-1URI\s0 and prefix of a node is provided by a pointer to a
namespace declaration (appearing as a special xmlns attribute in the \s-1XML\s0
document). If the prefix or namespace \s-1URI\s0 of the declaration changes, the
prefix and namespace \s-1URI\s0 of all nodes that point to it changes as well.
Moreover, in contrast to \s-1DOM\s0, a node (element or attribute) can only be bound
to a namespace \s-1URI\s0 if there is some namespace declaration in the document to
point to.
.PP
Therefore current \s-1DOM\s0 implementation in XML::LibXML tries to treat namespace
declarations in a compromise between reason, common sense, limitations of
libxml2, and the \s-1DOM\s0 Level 2 specification.
.PP
In XML::LibXML, special attributes declaring \s-1XML\s0 namespaces are often created
automatically, usually when a namespaced node is attached to a document and no
existing declaration of the namespace and prefix is in the scope to be reused.
In this respect, XML::LibXML \s-1DOM\s0 implementation differs from the \s-1DOM\s0 Level 2
specification according to which special attributes for declaring the
appropriate \s-1XML\s0 namespaces should not be added when a node with a namespace
prefix and namespace \s-1URI\s0 is created.
.PP
Namespace declarations are also created when XML::LibXML::Document's \fIcreateElementNS()\fR or \fIcreateAttributeNS()\fR function are used. If the a
namespace is not declared on the documentElement, the namespace will be locally
declared for the newly created node. In case of Attributes this may look a bit
confusing, since these nodes cannot have namespace declarations itself. In this
case the namespace is internally applied to the attribute and later declared on
the node the attribute is appended to (if required).
.PP
The following example may explain this a bit:
.PP
.Vb 3
\&  my $doc = XML::LibXML\->createDocument;
\&  my $root = $doc\->createElementNS( "", "foo" );
\&  $doc\->setDocumentElement( $root );
\&
\&  my $attr = $doc\->createAttributeNS( "bar", "bar:foo", "test" );
\&  $root\->setAttributeNodeNS( $attr );
.Ve
.PP
This piece of code will result in the following document:
.PP
.Vb 2
\&  <?xml version="1.0"?>
\&  <foo xmlns:bar="bar" bar:foo="test"/>
.Ve
.PP
The namespace is declared on the document element during the
\&\fIsetAttributeNodeNS()\fR call.
.PP
Namespaces can be also declared explicitly by the use of XML::LibXML::Element's
\&\fIsetNamespace()\fR function. Since 1.61, they can also be manipulated with
functions \fIsetNamespaceDeclPrefix()\fR and \fIsetNamespaceDeclURI()\fR (not available in
\&\s-1DOM\s0). Changing an \s-1URI\s0 or prefix of an existing namespace declaration affects
the namespace \s-1URI\s0 and prefix of all nodes which point to it (that is the nodes
in its scope).
.PP
It is also important to repeat the specification: While working with namespaces
you should use the namespace aware functions instead of the simplified
versions. For example you should \fInever\fR use \fIsetAttribute()\fR but \fIsetAttributeNS()\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::DOM5.18.3pm                     0100644 0001750 0001750 00000025251 12566241670 024203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::DOM 3"
.TH XML::LibXML::DOM 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::DOM \- XML::LibXML DOM Implementation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::LibXML provides an light-wight interface to \fImodify\fR a node of the document tree generated by the XML::LibXML parser. This interface
follows as far as possible the \s-1DOM\s0 Level 3 specification. Additionally to the
specified functions the XML::LibXML supports some functions that are more handy
to use in the perl environment.
.PP
One also has to remember, that XML::LibXML is an interface to libxml2 nodes
which actually reside on the C\-Level of XML::LibXML. This means each node is a
reference to a structure different than a perl hash or array. The only way to
access these structure's values is through the \s-1DOM\s0 interface provided by
XML::LibXML. This also means, that one \fIcan't\fR simply inherit an XML::LibXML node and add new member variables as they were
hash keys.
.PP
The \s-1DOM\s0 interface of XML::LibXML does not intend to implement a full \s-1DOM\s0
interface as it is done by \s-1XML::GDOME\s0 and used for full featured application.
Moreover, it offers an simple way to build or modify documents that are created
by XML::LibXML's parser.
.PP
Another target of the XML::LibXML interface is to make the interfaces of
libxml2 available to the perl community. This includes also some workarounds to
some features where libxml2 assumes more control over the C\-Level that most
perl users don't have.
.PP
One of the most important parts of the XML::LibXML \s-1DOM\s0 interface is, that the
interfaces try do follow the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>) rather strictly. This means the interface functions are named as the \s-1DOM\s0
specification says and not what widespread Java interfaces claim to be
standard. Although there are several functions that have only a singular
interface that conforms to the \s-1DOM\s0 spec XML::LibXML provides an additional Java
style alias interface.
.PP
Also there are some function interfaces left over from early stages of
XML::LibXML for compatibility reasons. These interfaces are for compatibility
reasons \fIonly\fR. They might disappear in one of the future versions of XML::LibXML, so a user
is requested to switch over to the official functions.
.SS "Encodings and XML::LibXML's \s-1DOM\s0 implementation"
.IX Subsection "Encodings and XML::LibXML's DOM implementation"
See the section on Encodings in the \fIXML::LibXML\fR manual page.
.SS "Namespaces and XML::LibXML's \s-1DOM\s0 implementation"
.IX Subsection "Namespaces and XML::LibXML's DOM implementation"
XML::LibXML's \s-1DOM\s0 implementation is limited by the \s-1DOM\s0 implementation of
libxml2 which treats namespaces slightly differently than required by the \s-1DOM\s0
Level 2 specification.
.PP
According to the \s-1DOM\s0 Level 2 specification, namespaces of elements and
attributes should be persistent, and nodes should be permanently bound to
namespace URIs as they get created; it should be possible to manipulate the
special attributes used for declaring \s-1XML\s0 namespaces just as other attributes
without affecting the namespaces of other nodes. In \s-1DOM\s0 Level 2, the
application is responsible for creating the special attributes consistently
and/or for correct serialization of the document.
.PP
This is both inconvenient, causes problems in serialization of \s-1DOM\s0 to \s-1XML,\s0 and
most importantly, seems almost impossible to implement over libxml2.
.PP
In libxml2, namespace \s-1URI\s0 and prefix of a node is provided by a pointer to a
namespace declaration (appearing as a special xmlns attribute in the \s-1XML\s0
document). If the prefix or namespace \s-1URI\s0 of the declaration changes, the
prefix and namespace \s-1URI\s0 of all nodes that point to it changes as well.
Moreover, in contrast to \s-1DOM,\s0 a node (element or attribute) can only be bound
to a namespace \s-1URI\s0 if there is some namespace declaration in the document to
point to.
.PP
Therefore current \s-1DOM\s0 implementation in XML::LibXML tries to treat namespace
declarations in a compromise between reason, common sense, limitations of
libxml2, and the \s-1DOM\s0 Level 2 specification.
.PP
In XML::LibXML, special attributes declaring \s-1XML\s0 namespaces are often created
automatically, usually when a namespaced node is attached to a document and no
existing declaration of the namespace and prefix is in the scope to be reused.
In this respect, XML::LibXML \s-1DOM\s0 implementation differs from the \s-1DOM\s0 Level 2
specification according to which special attributes for declaring the
appropriate \s-1XML\s0 namespaces should not be added when a node with a namespace
prefix and namespace \s-1URI\s0 is created.
.PP
Namespace declarations are also created when XML::LibXML::Document's \fIcreateElementNS()\fR or \fIcreateAttributeNS()\fR function are used. If the a
namespace is not declared on the documentElement, the namespace will be locally
declared for the newly created node. In case of Attributes this may look a bit
confusing, since these nodes cannot have namespace declarations itself. In this
case the namespace is internally applied to the attribute and later declared on
the node the attribute is appended to (if required).
.PP
The following example may explain this a bit:
.PP
.Vb 3
\&  my $doc = XML::LibXML\->createDocument;
\&  my $root = $doc\->createElementNS( "", "foo" );
\&  $doc\->setDocumentElement( $root );
\&
\&  my $attr = $doc\->createAttributeNS( "bar", "bar:foo", "test" );
\&  $root\->setAttributeNodeNS( $attr );
.Ve
.PP
This piece of code will result in the following document:
.PP
.Vb 2
\&  <?xml version="1.0"?>
\&  <foo xmlns:bar="bar" bar:foo="test"/>
.Ve
.PP
The namespace is declared on the document element during the
\&\fIsetAttributeNodeNS()\fR call.
.PP
Namespaces can be also declared explicitly by the use of XML::LibXML::Element's
\&\fIsetNamespace()\fR function. Since 1.61, they can also be manipulated with
functions \fIsetNamespaceDeclPrefix()\fR and \fIsetNamespaceDeclURI()\fR (not available in
\&\s-1DOM\s0). Changing an \s-1URI\s0 or prefix of an existing namespace declaration affects
the namespace \s-1URI\s0 and prefix of all nodes which point to it (that is the nodes
in its scope).
.PP
It is also important to repeat the specification: While working with namespaces
you should use the namespace aware functions instead of the simplified
versions. For example you should \fInever\fR use \fIsetAttribute()\fR but \fIsetAttributeNS()\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Devel.3pm                       0100644 0001750 0001750 00000021467 12566241670 024314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Devel 3"
.TH XML::LibXML::Devel 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Devel \- makes functions from LibXML.xs available
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  /**********************************************
\&   * C functions you want to access
\&   */
\&  xmlNode *return_node();
\&  void receive_node(xmlNode *);
\&
\&  ###############################################
\&  # XS Code
\&  void *
\&    xs_return_node
\&    CODE:
\&        RETVAL = return_node();
\&    OUTPUT:
\&        RETVAL
\&
\&  void
\&    xs_receive_node
\&        void *n
\&    CODE:
\&        receive_node(n);
\&
\&  ###############################################
\&  # Perl code
\&  use XML::LibXML::Devel;
\&
\&  sub return_node
\&  {
\&    my $raw_node = xs_return_node();
\&    my $node = XML::LibXML::Devel::node_to_perl($raw_node);
\&    XML::LibXML::Devel::refcnt_inc($raw_node);
\&    return $node;
\&  }
\&
\&  sub receive_node
\&  {
\&    my ($node) = @_;
\&    my $raw_node = XML::LibXML::Devel::node_from_perl($node);
\&    xs_receive_node($raw_node);
\&    XML::LibXML::Devel::refcnt_inc($raw_node);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`XML::LibXML::Devel\*(C'\fR makes functions from LibXML.xs available that
are needed to wrap libxml2 nodes in and out of XML::LibXML::Nodes.
This gives cleaner dependencies than using LibXML.so directly.
.PP
To \s-1XS\s0 a library that uses libxml2 nodes the first step is to
do this so that xmlNodePtr is passed as void *. These raw nodes
are then turned into libxml nodes by using this \f(CW\*(C`Devel\*(C'\fR functions.
.PP
Be aware that this module is currently rather experimental. The function
names may change if I \s-1XS\s0 more functions and introduce a reasonable
naming convention.
.PP
Be also aware that this module is a great tool to cause segfaults and
introduce memory leaks. It does however provide a partial cure by making
\&\f(CW\*(C`xmlMemUsed\*(C'\fR available as \f(CW\*(C`mem_used\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1NODE MANAGEMENT\s0"
.IX Subsection "NODE MANAGEMENT"
.IP "node_to_perl" 1
.IX Item "node_to_perl"
.Vb 1
\&  node_to_perl($raw_node);
.Ve
.Sp
Returns a LibXML::Node object. This has a proxy node with a reference
counter and an owner attached. The raw node will be deleted as soon
as the reference counter reaches zero.
If the C library is keeping a
pointer to the raw node, you need to call refcnt_inc immediately.
You also need to replace xmlFreeNode by a call to refcnt_dec.
.IP "node_to_perl" 1
.IX Item "node_to_perl"
.Vb 1
\&  node_from_perl($node);
.Ve
.Sp
Returns a raw node. This is a void * pointer and you can do nothing
but passing it to functions that treat it as an xmlNodePtr. The
raw node will be freed as soon as its reference counter reaches zero.
If the C library is keeping a
pointer to the raw node, you need to call refcnt_inc immediately.
You also need to replace xmlFreeNode by a call to refcnt_dec.
.IP "refcnt_inc" 1
.IX Item "refcnt_inc"
.Vb 1
\&  refcnt_inc($raw_node);
.Ve
.Sp
Increments the raw nodes reference counter. The raw node must already
be known to perl to have a reference counter.
.IP "refcnt_dec" 1
.IX Item "refcnt_dec"
.Vb 1
\&  refcnt_dec($raw_node);
.Ve
.Sp
Decrements the raw nodes reference counter and returns the value it
had before. if the counter becomes zero or less,
this method will free the proxy node holding the reference counter.
If the node is part of a
subtree, refcnt_dec will fix the reference counts and delete
the subtree if it is not required any more.
.IP "refcnt" 1
.IX Item "refcnt"
.Vb 1
\&  refcnt($raw_node);
.Ve
.Sp
Returns the value of the reference counter.
.IP "fix_owner" 1
.IX Item "fix_owner"
.Vb 1
\&  fix_owner($raw_node, $raw_parent);
.Ve
.Sp
This functions fixes the reference counts for an entire subtree.
it is very important to fix an entire subtree after node operations
where the documents or the owner node may get changed. this method is
aware about nodes that already belong to a certain owner node.
.SS "\s-1MEMORY DEBUGGING\s0"
.IX Subsection "MEMORY DEBUGGING"
.ie n .IP "$ENV{\s-1DEBUG_MEMORY\s0}" 1
.el .IP "\f(CW$ENV\fR{\s-1DEBUG_MEMORY\s0}" 1
.IX Item "$ENV{DEBUG_MEMORY}"
.Vb 2
\&  BEGIN {$ENV{DEBUG_MEMORY} = 1;};
\&  use XML::LibXML;
.Ve
.Sp
This turns on libxml2 memory debugging. It must be set before
XML::LibXML is loaded.
.IP "mem_used" 1
.IX Item "mem_used"
.Vb 1
\&  mem_used();
.Ve
.Sp
Returns the number of bytes currently allocated.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This was created to support the needs of Apache2::ModXml2. So this
can serve as an example.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joachim Zobel <jz\-2011@heute\-morgen.de>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2011 by Joachim Zobel
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.1 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Devel5.16.3pm                   0100644 0001750 0001750 00000021164 12566241665 024624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Devel 3"
.TH XML::LibXML::Devel 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Devel \- makes functions from LibXML.xs available
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  /**********************************************
\&   * C functions you want to access
\&   */
\&  xmlNode *return_node();
\&  void receive_node(xmlNode *);
\&
\&  ###############################################
\&  # XS Code
\&  void *
\&    xs_return_node
\&    CODE:
\&        RETVAL = return_node();
\&    OUTPUT:
\&        RETVAL
\&
\&  void
\&    xs_receive_node
\&        void *n
\&    CODE:
\&        receive_node(n);
\&
\&  ###############################################
\&  # Perl code
\&  use XML::LibXML::Devel;
\&
\&  sub return_node
\&  {
\&    my $raw_node = xs_return_node();
\&    my $node = XML::LibXML::Devel::node_to_perl($raw_node);
\&    XML::LibXML::Devel::refcnt_inc($raw_node);
\&    return $node;
\&  }
\&
\&  sub receive_node
\&  {
\&    my ($node) = @_;
\&    my $raw_node = XML::LibXML::Devel::node_from_perl($node);
\&    xs_receive_node($raw_node);
\&    XML::LibXML::Devel::refcnt_inc($raw_node);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`XML::LibXML::Devel\*(C'\fR makes functions from LibXML.xs available that
are needed to wrap libxml2 nodes in and out of XML::LibXML::Nodes.
This gives cleaner dependencies than using LibXML.so directly.
.PP
To \s-1XS\s0 a library that uses libxml2 nodes the first step is to
do this so that xmlNodePtr is passed as void *. These raw nodes
are then turned into libxml nodes by using this \f(CW\*(C`Devel\*(C'\fR functions.
.PP
Be aware that this module is currently rather experimental. The function
names may change if I \s-1XS\s0 more functions and introduce a reasonable
naming convention.
.PP
Be also aware that this module is a great tool to cause segfaults and
introduce memory leaks. It does however provide a partial cure by making
\&\f(CW\*(C`xmlMemUsed\*(C'\fR available as \f(CW\*(C`mem_used\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1NODE\s0 \s-1MANAGEMENT\s0"
.IX Subsection "NODE MANAGEMENT"
.IP "node_to_perl" 1
.IX Item "node_to_perl"
.Vb 1
\&  node_to_perl($raw_node);
.Ve
.Sp
Returns a LibXML::Node object. This has a proxy node with a reference
counter and an owner attached. The raw node will be deleted as soon
as the reference counter reaches zero.
If the C library is keeping a
pointer to the raw node, you need to call refcnt_inc immediately.
You also need to replace xmlFreeNode by a call to refcnt_dec.
.IP "node_to_perl" 1
.IX Item "node_to_perl"
.Vb 1
\&  node_from_perl($node);
.Ve
.Sp
Returns a raw node. This is a void * pointer and you can do nothing
but passing it to functions that treat it as an xmlNodePtr. The
raw node will be freed as soon as its reference counter reaches zero.
If the C library is keeping a
pointer to the raw node, you need to call refcnt_inc immediately.
You also need to replace xmlFreeNode by a call to refcnt_dec.
.IP "refcnt_inc" 1
.IX Item "refcnt_inc"
.Vb 1
\&  refcnt_inc($raw_node);
.Ve
.Sp
Increments the raw nodes reference counter. The raw node must already
be known to perl to have a reference counter.
.IP "refcnt_dec" 1
.IX Item "refcnt_dec"
.Vb 1
\&  refcnt_dec($raw_node);
.Ve
.Sp
Decrements the raw nodes reference counter and returns the value it
had before. if the counter becomes zero or less,
this method will free the proxy node holding the reference counter.
If the node is part of a
subtree, refcnt_dec will fix the reference counts and delete
the subtree if it is not required any more.
.IP "refcnt" 1
.IX Item "refcnt"
.Vb 1
\&  refcnt($raw_node);
.Ve
.Sp
Returns the value of the reference counter.
.IP "fix_owner" 1
.IX Item "fix_owner"
.Vb 1
\&  fix_owner($raw_node, $raw_parent);
.Ve
.Sp
This functions fixes the reference counts for an entire subtree.
it is very important to fix an entire subtree after node operations
where the documents or the owner node may get changed. this method is
aware about nodes that already belong to a certain owner node.
.SS "\s-1MEMORY\s0 \s-1DEBUGGING\s0"
.IX Subsection "MEMORY DEBUGGING"
.ie n .IP "$ENV{\s-1DEBUG_MEMORY\s0}" 1
.el .IP "\f(CW$ENV\fR{\s-1DEBUG_MEMORY\s0}" 1
.IX Item "$ENV{DEBUG_MEMORY}"
.Vb 2
\&  BEGIN {$ENV{DEBUG_MEMORY} = 1;};
\&  use XML::LibXML;
.Ve
.Sp
This turns on libxml2 memory debugging. It must be set before
XML::LibXML is loaded.
.IP "mem_used" 1
.IX Item "mem_used"
.Vb 1
\&  mem_used();
.Ve
.Sp
Returns the number of bytes currently allocated.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This was created to support the needs of Apache2::ModXml2. So this
can serve as an example.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joachim Zobel <jz\-2011@heute\-morgen.de>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2011 by Joachim Zobel
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.1 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Devel5.18.3pm                   0100644 0001750 0001750 00000021467 12566241670 024630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Devel 3"
.TH XML::LibXML::Devel 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Devel \- makes functions from LibXML.xs available
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  /**********************************************
\&   * C functions you want to access
\&   */
\&  xmlNode *return_node();
\&  void receive_node(xmlNode *);
\&
\&  ###############################################
\&  # XS Code
\&  void *
\&    xs_return_node
\&    CODE:
\&        RETVAL = return_node();
\&    OUTPUT:
\&        RETVAL
\&
\&  void
\&    xs_receive_node
\&        void *n
\&    CODE:
\&        receive_node(n);
\&
\&  ###############################################
\&  # Perl code
\&  use XML::LibXML::Devel;
\&
\&  sub return_node
\&  {
\&    my $raw_node = xs_return_node();
\&    my $node = XML::LibXML::Devel::node_to_perl($raw_node);
\&    XML::LibXML::Devel::refcnt_inc($raw_node);
\&    return $node;
\&  }
\&
\&  sub receive_node
\&  {
\&    my ($node) = @_;
\&    my $raw_node = XML::LibXML::Devel::node_from_perl($node);
\&    xs_receive_node($raw_node);
\&    XML::LibXML::Devel::refcnt_inc($raw_node);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`XML::LibXML::Devel\*(C'\fR makes functions from LibXML.xs available that
are needed to wrap libxml2 nodes in and out of XML::LibXML::Nodes.
This gives cleaner dependencies than using LibXML.so directly.
.PP
To \s-1XS\s0 a library that uses libxml2 nodes the first step is to
do this so that xmlNodePtr is passed as void *. These raw nodes
are then turned into libxml nodes by using this \f(CW\*(C`Devel\*(C'\fR functions.
.PP
Be aware that this module is currently rather experimental. The function
names may change if I \s-1XS\s0 more functions and introduce a reasonable
naming convention.
.PP
Be also aware that this module is a great tool to cause segfaults and
introduce memory leaks. It does however provide a partial cure by making
\&\f(CW\*(C`xmlMemUsed\*(C'\fR available as \f(CW\*(C`mem_used\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1NODE MANAGEMENT\s0"
.IX Subsection "NODE MANAGEMENT"
.IP "node_to_perl" 1
.IX Item "node_to_perl"
.Vb 1
\&  node_to_perl($raw_node);
.Ve
.Sp
Returns a LibXML::Node object. This has a proxy node with a reference
counter and an owner attached. The raw node will be deleted as soon
as the reference counter reaches zero.
If the C library is keeping a
pointer to the raw node, you need to call refcnt_inc immediately.
You also need to replace xmlFreeNode by a call to refcnt_dec.
.IP "node_to_perl" 1
.IX Item "node_to_perl"
.Vb 1
\&  node_from_perl($node);
.Ve
.Sp
Returns a raw node. This is a void * pointer and you can do nothing
but passing it to functions that treat it as an xmlNodePtr. The
raw node will be freed as soon as its reference counter reaches zero.
If the C library is keeping a
pointer to the raw node, you need to call refcnt_inc immediately.
You also need to replace xmlFreeNode by a call to refcnt_dec.
.IP "refcnt_inc" 1
.IX Item "refcnt_inc"
.Vb 1
\&  refcnt_inc($raw_node);
.Ve
.Sp
Increments the raw nodes reference counter. The raw node must already
be known to perl to have a reference counter.
.IP "refcnt_dec" 1
.IX Item "refcnt_dec"
.Vb 1
\&  refcnt_dec($raw_node);
.Ve
.Sp
Decrements the raw nodes reference counter and returns the value it
had before. if the counter becomes zero or less,
this method will free the proxy node holding the reference counter.
If the node is part of a
subtree, refcnt_dec will fix the reference counts and delete
the subtree if it is not required any more.
.IP "refcnt" 1
.IX Item "refcnt"
.Vb 1
\&  refcnt($raw_node);
.Ve
.Sp
Returns the value of the reference counter.
.IP "fix_owner" 1
.IX Item "fix_owner"
.Vb 1
\&  fix_owner($raw_node, $raw_parent);
.Ve
.Sp
This functions fixes the reference counts for an entire subtree.
it is very important to fix an entire subtree after node operations
where the documents or the owner node may get changed. this method is
aware about nodes that already belong to a certain owner node.
.SS "\s-1MEMORY DEBUGGING\s0"
.IX Subsection "MEMORY DEBUGGING"
.ie n .IP "$ENV{\s-1DEBUG_MEMORY\s0}" 1
.el .IP "\f(CW$ENV\fR{\s-1DEBUG_MEMORY\s0}" 1
.IX Item "$ENV{DEBUG_MEMORY}"
.Vb 2
\&  BEGIN {$ENV{DEBUG_MEMORY} = 1;};
\&  use XML::LibXML;
.Ve
.Sp
This turns on libxml2 memory debugging. It must be set before
XML::LibXML is loaded.
.IP "mem_used" 1
.IX Item "mem_used"
.Vb 1
\&  mem_used();
.Ve
.Sp
Returns the number of bytes currently allocated.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This was created to support the needs of Apache2::ModXml2. So this
can serve as an example.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joachim Zobel <jz\-2011@heute\-morgen.de>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2011 by Joachim Zobel
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.10.1 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Document.3pm                    0100644 0001750 0001750 00000067576 12566241670 025046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Document 3"
.TH XML::LibXML::Document 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Document \- XML::LibXML DOM Document Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Document nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $dom = XML::LibXML::Document\->new( $version, $encoding );
\&  $dom = XML::LibXML::Document\->createDocument( $version, $encoding );
\&  $strURI = $doc\->URI();
\&  $doc\->setURI($strURI);
\&  $strEncoding = $doc\->encoding();
\&  $strEncoding = $doc\->actualEncoding();
\&  $doc\->setEncoding($new_encoding);
\&  $strVersion = $doc\->version();
\&  $doc\->standalone
\&  $doc\->setStandalone($numvalue);
\&  my $compression = $doc\->compression;
\&  $doc\->setCompression($ziplevel);
\&  $docstring = $dom\->toString($format);
\&  $c14nstr = $doc\->toStringC14N($comment_flag, $xpath [, $xpath_context ]);
\&  $ec14nstr = $doc\->toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
\&  $str = $doc\->serialize($format);
\&  $state = $doc\->toFile($filename, $format);
\&  $state = $doc\->toFH($fh, $format);
\&  $str = $document\->toStringHTML();
\&  $str = $document\->serialize_html();
\&  $bool = $dom\->is_valid();
\&  $dom\->validate();
\&  $root = $dom\->documentElement();
\&  $dom\->setDocumentElement( $root );
\&  $element = $dom\->createElement( $nodename );
\&  $element = $dom\->createElementNS( $namespaceURI, $qname );
\&  $text = $dom\->createTextNode( $content_text );
\&  $comment = $dom\->createComment( $comment_text );
\&  $attrnode = $doc\->createAttribute($name [,$value]);
\&  $attrnode = $doc\->createAttributeNS( namespaceURI, $name [,$value] );
\&  $fragment = $doc\->createDocumentFragment();
\&  $cdata = $dom\->createCDATASection( $cdata_content );
\&  my $pi = $doc\->createProcessingInstruction( $target, $data );
\&  my $entref = $doc\->createEntityReference($refname);
\&  $dtd = $document\->createInternalSubset( $rootnode, $public, $system);
\&  $dtd = $document\->createExternalSubset( $rootnode_name, $publicId, $systemId);
\&  $document\->importNode( $node );
\&  $document\->adoptNode( $node );
\&  my $dtd = $doc\->externalSubset;
\&  my $dtd = $doc\->internalSubset;
\&  $doc\->setExternalSubset($dtd);
\&  $doc\->setInternalSubset($dtd);
\&  my $dtd = $doc\->removeExternalSubset();
\&  my $dtd = $doc\->removeInternalSubset();
\&  my @nodelist = $doc\->getElementsByTagName($tagname);
\&  my @nodelist = $doc\->getElementsByTagNameNS($nsURI,$tagname);
\&  my @nodelist = $doc\->getElementsByLocalName($localname);
\&  my $node = $doc\->getElementById($id);
\&  $dom\->indexElements();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Document Class is in most cases the result of a parsing process. But
sometimes it is necessary to create a Document from scratch. The \s-1DOM\s0 Document
Class provides functions that conform to the \s-1DOM\s0 Core naming style.
.PP
It inherits all functions from XML::LibXML::Node as specified in the \s-1DOM\s0 specification. This enables access to the nodes besides
the root element on document level \- a \f(CW\*(C`DTD\*(C'\fR for example. The support for these nodes is limited at the moment.
.PP
While generally nodes are bound to a document in the \s-1DOM\s0 concept it is
suggested that one should always create a node not bound to any document. There
is no need of really including the node to the document, but once the node is
bound to a document, it is quite safe that all strings have the correct
encoding. If an unbound text node with an \s-1ISO\s0 encoded string is created (e.g.
with \f(CW$CLASS\fR\->\fInew()\fR), the \f(CW\*(C`toString\*(C'\fR function may not return the expected result.
.PP
To prevent such problems, it is recommended to pass all data to XML::LibXML
methods as character strings (i.e. \s-1UTF\-8\s0 encoded, with the \s-1UTF8\s0 flag on).
.SH "METHODS"
.IX Header "METHODS"
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $dom = XML::LibXML::Document\->new( $version, $encoding );
.Ve
.Sp
alias for \fIcreateDocument()\fR
.IP "createDocument" 4
.IX Item "createDocument"
.Vb 1
\&  $dom = XML::LibXML::Document\->createDocument( $version, $encoding );
.Ve
.Sp
The constructor for the document class. As Parameter it takes the version
string and (optionally) the encoding string. Simply calling \fIcreateDocument\fR() will create the document:
.Sp
.Vb 1
\&  <?xml version="your version" encoding="your encoding"?>
.Ve
.Sp
Both parameter are optional. The default value for \fI\f(CI$version\fI\fR is \f(CW1.0\fR, of course. If the \fI\f(CI$encoding\fI\fR parameter is not set, the encoding will be left unset, which means \s-1UTF\-8\s0 is
implied.
.Sp
The call of \fIcreateDocument\fR() without any parameter will result the following code:
.Sp
.Vb 1
\&  <?xml version="1.0"?>
.Ve
.Sp
Alternatively one can call this constructor directly from the XML::LibXML class
level, to avoid some typing. This will not have any effect on the class
instance, which is always XML::LibXML::Document.
.Sp
.Vb 1
\&  my $document = XML::LibXML\->createDocument( "1.0", "UTF\-8" );
.Ve
.Sp
is therefore a shortcut for
.Sp
.Vb 1
\&  my $document = XML::LibXML::Document\->createDocument( "1.0", "UTF\-8" );
.Ve
.IP "\s-1URI\s0" 4
.IX Item "URI"
.Vb 1
\&  $strURI = $doc\->URI();
.Ve
.Sp
Returns the \s-1URI \s0(or filename) of the original document. For documents obtained
by parsing a string of a \s-1FH\s0 without using the \s-1URI\s0 parsing argument of the
corresponding \f(CW\*(C`parse_*\*(C'\fR function, the result is a generated string unknown-XYZ where \s-1XYZ\s0 is some
number; for documents created with the constructor \f(CW\*(C`new\*(C'\fR, the \s-1URI\s0 is undefined.
.Sp
The value can be modified by calling \f(CW\*(C`setURI\*(C'\fR method on the document node.
.IP "setURI" 4
.IX Item "setURI"
.Vb 1
\&  $doc\->setURI($strURI);
.Ve
.Sp
Sets the \s-1URI\s0 of the document reported by the method \s-1URI \s0(see also the \s-1URI\s0
argument to the various \f(CW\*(C`parse_*\*(C'\fR functions).
.IP "encoding" 4
.IX Item "encoding"
.Vb 1
\&  $strEncoding = $doc\->encoding();
.Ve
.Sp
returns the encoding string of the document.
.Sp
.Vb 2
\&  my $doc = XML::LibXML\->createDocument( "1.0", "ISO\-8859\-15" );
\&  print $doc\->encoding; # prints ISO\-8859\-15
.Ve
.IP "actualEncoding" 4
.IX Item "actualEncoding"
.Vb 1
\&  $strEncoding = $doc\->actualEncoding();
.Ve
.Sp
returns the encoding in which the \s-1XML\s0 will be returned by \f(CW$doc\fR\->\fItoString()\fR.
This is usually the original encoding of the document as declared in the \s-1XML\s0
declaration and returned by \f(CW$doc\fR\->encoding. If the original encoding is not
known (e.g. if created in memory or parsed from a \s-1XML\s0 without a declared
encoding), '\s-1UTF\-8\s0' is returned.
.Sp
.Vb 2
\&  my $doc = XML::LibXML\->createDocument( "1.0", "ISO\-8859\-15" );
\&  print $doc\->encoding; # prints ISO\-8859\-15
.Ve
.IP "setEncoding" 4
.IX Item "setEncoding"
.Vb 1
\&  $doc\->setEncoding($new_encoding);
.Ve
.Sp
This method allows one to change the declaration of encoding in the \s-1XML\s0
declaration of the document. The value also affects the encoding in which the
document is serialized to \s-1XML\s0 by \f(CW$doc\fR\->\fItoString()\fR. Use \fIsetEncoding()\fR to remove
the encoding declaration.
.IP "version" 4
.IX Item "version"
.Vb 1
\&  $strVersion = $doc\->version();
.Ve
.Sp
returns the version string of the document
.Sp
\&\fI\fIgetVersion()\fI\fR is an alternative form of this function.
.IP "standalone" 4
.IX Item "standalone"
.Vb 1
\&  $doc\->standalone
.Ve
.Sp
This function returns the Numerical value of a documents \s-1XML\s0 declarations
standalone attribute. It returns \fI1\fR if standalone=\*(L"yes\*(R" was found, \fI0\fR if standalone=\*(L"no\*(R" was found and \fI\-1\fR if standalone was not specified (default on creation).
.IP "setStandalone" 4
.IX Item "setStandalone"
.Vb 1
\&  $doc\->setStandalone($numvalue);
.Ve
.Sp
Through this method it is possible to alter the value of a documents standalone
attribute. Set it to \fI1\fR to set standalone=\*(L"yes\*(R", to \fI0\fR to set standalone=\*(L"no\*(R" or set it to \fI\-1\fR to remove the standalone attribute from the \s-1XML\s0 declaration.
.IP "compression" 4
.IX Item "compression"
.Vb 1
\&  my $compression = $doc\->compression;
.Ve
.Sp
libxml2 allows reading of documents directly from gzipped files. In this case
the compression variable is set to the compression level of that file (0\-8). If
XML::LibXML parsed a different source or the file wasn't compressed, the
returned value will be \fI\-1\fR.
.IP "setCompression" 4
.IX Item "setCompression"
.Vb 1
\&  $doc\->setCompression($ziplevel);
.Ve
.Sp
If one intends to write the document directly to a file, it is possible to set
the compression level for a given document. This level can be in the range from
0 to 8. If XML::LibXML should not try to compress use \fI\-1\fR (default).
.Sp
Note that this feature will \fIonly\fR work if libxml2 is compiled with zlib support and \fItoFile()\fR is used for output.
.IP "toString" 4
.IX Item "toString"
.Vb 1
\&  $docstring = $dom\->toString($format);
.Ve
.Sp
\&\fItoString\fR is a \s-1DOM\s0 serializing function, so the \s-1DOM\s0 Tree is serialized into an \s-1XML\s0
string, ready for output.
.Sp
\&\s-1IMPORTANT:\s0 unlike toString for other nodes, on document nodes this function
returns the \s-1XML\s0 as a byte string in the original encoding of the document (see
the \fIactualEncoding()\fR method)! This means you can simply do:
.Sp
.Vb 2
\&  open my $out_fh, \*(Aq>\*(Aq, $file;
\&  print {$out_fh} $doc\->toString;
.Ve
.Sp
regardless of the actual encoding of the document. See the section on encodings
in XML::LibXML for more details.
.Sp
The optional \fI\f(CI$format\fI\fR parameter sets the indenting of the output. This parameter is expected to be an \f(CW\*(C`integer\*(C'\fR value, that specifies that indentation should be used. The format parameter can
have three different values if it is used:
.Sp
If \f(CW$format\fR is 0, than the document is dumped as it was originally parsed
.Sp
If \f(CW$format\fR is 1, libxml2 will add ignorable white spaces, so the nodes content
is easier to read. Existing text nodes will not be altered
.Sp
If \f(CW$format\fR is 2 (or higher), libxml2 will act as \f(CW$format\fR == 1 but it add a
leading and a trailing line break to each text node.
.Sp
libxml2 uses a hard-coded indentation of 2 space characters per indentation
level. This value can not be altered on run-time.
.IP "toStringC14N" 4
.IX Item "toStringC14N"
.Vb 1
\&  $c14nstr = $doc\->toStringC14N($comment_flag, $xpath [, $xpath_context ]);
.Ve
.Sp
See the documentation in XML::LibXML::Node.
.IP "toStringEC14N" 4
.IX Item "toStringEC14N"
.Vb 1
\&  $ec14nstr = $doc\->toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
.Ve
.Sp
See the documentation in XML::LibXML::Node.
.IP "serialize" 4
.IX Item "serialize"
.Vb 1
\&  $str = $doc\->serialize($format);
.Ve
.Sp
An alias for \fItoString()\fR. This function was name added to be more consistent
with libxml2.
.IP "serialize_c14n" 4
.IX Item "serialize_c14n"
An alias for \fItoStringC14N()\fR.
.IP "serialize_exc_c14n" 4
.IX Item "serialize_exc_c14n"
An alias for \fItoStringEC14N()\fR.
.IP "toFile" 4
.IX Item "toFile"
.Vb 1
\&  $state = $doc\->toFile($filename, $format);
.Ve
.Sp
This function is similar to \fItoString()\fR, but it writes the document directly
into a filesystem. This function is very useful, if one needs to store large
documents.
.Sp
The format parameter has the same behaviour as in \fItoString()\fR.
.IP "toFH" 4
.IX Item "toFH"
.Vb 1
\&  $state = $doc\->toFH($fh, $format);
.Ve
.Sp
This function is similar to \fItoString()\fR, but it writes the document directly to
a filehandle or a stream. A byte stream in the document encoding is passed to
the file handle. Do \s-1NOT\s0 apply any \f(CW\*(C`:encoding(...)\*(C'\fR or \f(CW\*(C`:utf8\*(C'\fR PerlIO layer to the filehandle! See the section on encodings in XML::LibXML for more details.
.Sp
The format parameter has the same behaviour as in \fItoString()\fR.
.IP "toStringHTML" 4
.IX Item "toStringHTML"
.Vb 1
\&  $str = $document\->toStringHTML();
.Ve
.Sp
\&\fItoStringHTML\fR serialize the tree to a byte string in the document encoding as \s-1HTML.\s0 With this
method indenting is automatic and managed by libxml2 internally.
.IP "serialize_html" 4
.IX Item "serialize_html"
.Vb 1
\&  $str = $document\->serialize_html();
.Ve
.Sp
An alias for \fItoStringHTML()\fR.
.IP "is_valid" 4
.IX Item "is_valid"
.Vb 1
\&  $bool = $dom\->is_valid();
.Ve
.Sp
Returns either \s-1TRUE\s0 or \s-1FALSE\s0 depending on whether the \s-1DOM\s0 Tree is a valid
Document or not.
.Sp
You may also pass in a XML::LibXML::Dtd object, to validate against an external \s-1DTD:\s0
.Sp
.Vb 3
\&  if (!$dom\->is_valid($dtd)) {
\&       warn("document is not valid!");
\&   }
.Ve
.IP "validate" 4
.IX Item "validate"
.Vb 1
\&  $dom\->validate();
.Ve
.Sp
This is an exception throwing equivalent of is_valid. If the document is not
valid it will throw an exception containing the error. This allows you much
better error reporting than simply is_valid or not.
.Sp
Again, you may pass in a \s-1DTD\s0 object
.IP "documentElement" 4
.IX Item "documentElement"
.Vb 1
\&  $root = $dom\->documentElement();
.Ve
.Sp
Returns the root element of the Document. A document can have just one root
element to contain the documents data.
.Sp
Optionally one can use \fIgetDocumentElement\fR.
.IP "setDocumentElement" 4
.IX Item "setDocumentElement"
.Vb 1
\&  $dom\->setDocumentElement( $root );
.Ve
.Sp
This function enables you to set the root element for a document. The function
supports the import of a node from a different document tree, but does not
support a document fragment as \f(CW$root\fR.
.IP "createElement" 4
.IX Item "createElement"
.Vb 1
\&  $element = $dom\->createElement( $nodename );
.Ve
.Sp
This function creates a new Element Node bound to the \s-1DOM\s0 with the name \f(CW$nodename\fR.
.IP "createElementNS" 4
.IX Item "createElementNS"
.Vb 1
\&  $element = $dom\->createElementNS( $namespaceURI, $qname );
.Ve
.Sp
This function creates a new Element Node bound to the \s-1DOM\s0 with the name \f(CW$nodename\fR and placed in the given namespace.
.IP "createTextNode" 4
.IX Item "createTextNode"
.Vb 1
\&  $text = $dom\->createTextNode( $content_text );
.Ve
.Sp
As an equivalent of \fIcreateElement\fR, but it creates a \fIText Node\fR bound to the \s-1DOM.\s0
.IP "createComment" 4
.IX Item "createComment"
.Vb 1
\&  $comment = $dom\->createComment( $comment_text );
.Ve
.Sp
As an equivalent of \fIcreateElement\fR, but it creates a \fIComment Node\fR bound to the \s-1DOM.\s0
.IP "createAttribute" 4
.IX Item "createAttribute"
.Vb 1
\&  $attrnode = $doc\->createAttribute($name [,$value]);
.Ve
.Sp
Creates a new Attribute node.
.IP "createAttributeNS" 4
.IX Item "createAttributeNS"
.Vb 1
\&  $attrnode = $doc\->createAttributeNS( namespaceURI, $name [,$value] );
.Ve
.Sp
Creates an Attribute bound to a namespace.
.IP "createDocumentFragment" 4
.IX Item "createDocumentFragment"
.Vb 1
\&  $fragment = $doc\->createDocumentFragment();
.Ve
.Sp
This function creates a DocumentFragment.
.IP "createCDATASection" 4
.IX Item "createCDATASection"
.Vb 1
\&  $cdata = $dom\->createCDATASection( $cdata_content );
.Ve
.Sp
Similar to createTextNode and createComment, this function creates a
CDataSection bound to the current \s-1DOM.\s0
.IP "createProcessingInstruction" 4
.IX Item "createProcessingInstruction"
.Vb 1
\&  my $pi = $doc\->createProcessingInstruction( $target, $data );
.Ve
.Sp
create a processing instruction node.
.Sp
Since this method is quite long one may use its short form \fI\fIcreatePI()\fI\fR.
.IP "createEntityReference" 4
.IX Item "createEntityReference"
.Vb 1
\&  my $entref = $doc\->createEntityReference($refname);
.Ve
.Sp
If a document has a \s-1DTD\s0 specified, one can create entity references by using
this function. If one wants to add a entity reference to the document, this
reference has to be created by this function.
.Sp
An entity reference is unique to a document and cannot be passed to other
documents as other nodes can be passed.
.Sp
\&\fI\s-1NOTE:\s0\fR A text content containing something that looks like an entity reference, will
not be expanded to a real entity reference unless it is a predefined entity
.Sp
.Vb 3
\&  my $string = "&foo;";
\&   $some_element\->appendText( $string );
\&   print $some_element\->textContent; # prints "&amp;foo;"
.Ve
.IP "createInternalSubset" 4
.IX Item "createInternalSubset"
.Vb 1
\&  $dtd = $document\->createInternalSubset( $rootnode, $public, $system);
.Ve
.Sp
This function creates and adds an internal subset to the given document.
Because the function automatically adds the \s-1DTD\s0 to the document there is no
need to add the created node explicitly to the document.
.Sp
.Vb 2
\&  my $document = XML::LibXML::Document\->new();
\&   my $dtd      = $document\->createInternalSubset( "foo", undef, "foo.dtd" );
.Ve
.Sp
will result in the following \s-1XML\s0 document:
.Sp
.Vb 2
\&  <?xml version="1.0"?>
\&   <!DOCTYPE foo SYSTEM "foo.dtd">
.Ve
.Sp
By setting the public parameter it is possible to set \s-1PUBLIC\s0 DTDs to a given
document. So
.Sp
.Vb 2
\&  my $document = XML::LibXML::Document\->new();
\&  my $dtd      = $document\->createInternalSubset( "foo", "\-//FOO//DTD FOO 0.1//EN", undef );
.Ve
.Sp
will cause the following declaration to be created on the document:
.Sp
.Vb 2
\&  <?xml version="1.0"?>
\&  <!DOCTYPE foo PUBLIC "\-//FOO//DTD FOO 0.1//EN">
.Ve
.IP "createExternalSubset" 4
.IX Item "createExternalSubset"
.Vb 1
\&  $dtd = $document\->createExternalSubset( $rootnode_name, $publicId, $systemId);
.Ve
.Sp
This function is similar to \f(CW\*(C`createInternalSubset()\*(C'\fR but this \s-1DTD\s0 is considered to be external and is therefore not added to the
document itself. Nevertheless it can be used for validation purposes.
.IP "importNode" 4
.IX Item "importNode"
.Vb 1
\&  $document\->importNode( $node );
.Ve
.Sp
If a node is not part of a document, it can be imported to another document. As
specified in \s-1DOM\s0 Level 2 Specification the Node will not be altered or removed
from its original document (\f(CW\*(C`$node\->cloneNode(1)\*(C'\fR will get called implicitly).
.Sp
\&\fI\s-1NOTE:\s0\fR Don't try to use \fIimportNode()\fR to import sub-trees that contain an entity
reference \- even if the entity reference is the root node of the sub-tree. This
will cause serious problems to your program. This is a limitation of libxml2
and not of XML::LibXML itself.
.IP "adoptNode" 4
.IX Item "adoptNode"
.Vb 1
\&  $document\->adoptNode( $node );
.Ve
.Sp
If a node is not part of a document, it can be imported to another document. As
specified in \s-1DOM\s0 Level 3 Specification the Node will not be altered but it will
removed from its original document.
.Sp
After a document adopted a node, the node, its attributes and all its
descendants belong to the new document. Because the node does not belong to the
old document, it will be unlinked from its old location first.
.Sp
\&\fI\s-1NOTE:\s0\fR Don't try to \fIadoptNode()\fR to import sub-trees that contain entity references \-
even if the entity reference is the root node of the sub-tree. This will cause
serious problems to your program. This is a limitation of libxml2 and not of
XML::LibXML itself.
.IP "externalSubset" 4
.IX Item "externalSubset"
.Vb 1
\&  my $dtd = $doc\->externalSubset;
.Ve
.Sp
If a document has an external subset defined it will be returned by this
function.
.Sp
\&\fI\s-1NOTE\s0\fR Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in
XML::LibXML is still limited. In particular one may not want use common node
function on doctype declaration nodes!
.IP "internalSubset" 4
.IX Item "internalSubset"
.Vb 1
\&  my $dtd = $doc\->internalSubset;
.Ve
.Sp
If a document has an internal subset defined it will be returned by this
function.
.Sp
\&\fI\s-1NOTE\s0\fR Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in
XML::LibXML is still limited. In particular one may not want use common node
function on doctype declaration nodes!
.IP "setExternalSubset" 4
.IX Item "setExternalSubset"
.Vb 1
\&  $doc\->setExternalSubset($dtd);
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
This method sets a \s-1DTD\s0 node as an external subset of the given document.
.IP "setInternalSubset" 4
.IX Item "setInternalSubset"
.Vb 1
\&  $doc\->setInternalSubset($dtd);
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
This method sets a \s-1DTD\s0 node as an internal subset of the given document.
.IP "removeExternalSubset" 4
.IX Item "removeExternalSubset"
.Vb 1
\&  my $dtd = $doc\->removeExternalSubset();
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
If a document has an external subset defined it can be removed from the
document by using this function. The removed dtd node will be returned.
.IP "removeInternalSubset" 4
.IX Item "removeInternalSubset"
.Vb 1
\&  my $dtd = $doc\->removeInternalSubset();
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
If a document has an internal subset defined it can be removed from the
document by using this function. The removed dtd node will be returned.
.IP "getElementsByTagName" 4
.IX Item "getElementsByTagName"
.Vb 1
\&  my @nodelist = $doc\->getElementsByTagName($tagname);
.Ve
.Sp
Implements the \s-1DOM\s0 Level 2 function
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByTagNameNS" 4
.IX Item "getElementsByTagNameNS"
.Vb 1
\&  my @nodelist = $doc\->getElementsByTagNameNS($nsURI,$tagname);
.Ve
.Sp
Implements the \s-1DOM\s0 Level 2 function
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByLocalName" 4
.IX Item "getElementsByLocalName"
.Vb 1
\&  my @nodelist = $doc\->getElementsByLocalName($localname);
.Ve
.Sp
This allows the fetching of all nodes from a given document with the given
Localname.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementById" 4
.IX Item "getElementById"
.Vb 1
\&  my $node = $doc\->getElementById($id);
.Ve
.Sp
Returns the element that has an \s-1ID\s0 attribute with the given value. If no such
element exists, this returns undef.
.Sp
Note: the \s-1ID\s0 of an element may change while manipulating the document. For
documents with a \s-1DTD,\s0 the information about \s-1ID\s0 attributes is only available if
\&\s-1DTD\s0 loading/validation has been requested. For \s-1HTML\s0 documents parsed with the
\&\s-1HTML\s0 parser \s-1ID\s0 detection is done automatically. In \s-1XML\s0 documents, all \*(L"xml:id\*(R"
attributes are considered to be of type \s-1ID.\s0 You can test ID-ness of an
attribute node with \f(CW$attr\fR\->\fIisId()\fR.
.Sp
In versions 1.59 and earlier this method was called \fIgetElementsById()\fR (plural)
by mistake. Starting from 1.60 this name is maintained as an alias only for
backward compatibility.
.IP "indexElements" 4
.IX Item "indexElements"
.Vb 1
\&  $dom\->indexElements();
.Ve
.Sp
This function causes libxml2 to stamp all elements in a document with their
document position index which considerably speeds up XPath queries for large
documents. It should only be used with static documents that won't be further
changed by any \s-1DOM\s0 methods, because once a document is indexed, XPath will
always prefer the index to other methods of determining the document order of
nodes. XPath could therefore return improperly ordered node-lists when applied
on a document that has been changed after being indexed. It is of course
possible to use this method to re-index a modified document before using it
with XPath again. This function is not a part of the \s-1DOM\s0 specification.
.Sp
This function returns number of elements indexed, \-1 if error occurred, or \-2
if this feature is not available in the running libxml2.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Document5.16.3pm                0100644 0001750 0001750 00000067100 12566241665 025343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Document 3"
.TH XML::LibXML::Document 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Document \- XML::LibXML DOM Document Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Document nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $dom = XML::LibXML::Document\->new( $version, $encoding );
\&  $dom = XML::LibXML::Document\->createDocument( $version, $encoding );
\&  $strURI = $doc\->URI();
\&  $doc\->setURI($strURI);
\&  $strEncoding = $doc\->encoding();
\&  $strEncoding = $doc\->actualEncoding();
\&  $doc\->setEncoding($new_encoding);
\&  $strVersion = $doc\->version();
\&  $doc\->standalone
\&  $doc\->setStandalone($numvalue);
\&  my $compression = $doc\->compression;
\&  $doc\->setCompression($ziplevel);
\&  $docstring = $dom\->toString($format);
\&  $c14nstr = $doc\->toStringC14N($comment_flag, $xpath [, $xpath_context ]);
\&  $ec14nstr = $doc\->toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
\&  $str = $doc\->serialize($format);
\&  $state = $doc\->toFile($filename, $format);
\&  $state = $doc\->toFH($fh, $format);
\&  $str = $document\->toStringHTML();
\&  $str = $document\->serialize_html();
\&  $bool = $dom\->is_valid();
\&  $dom\->validate();
\&  $root = $dom\->documentElement();
\&  $dom\->setDocumentElement( $root );
\&  $element = $dom\->createElement( $nodename );
\&  $element = $dom\->createElementNS( $namespaceURI, $qname );
\&  $text = $dom\->createTextNode( $content_text );
\&  $comment = $dom\->createComment( $comment_text );
\&  $attrnode = $doc\->createAttribute($name [,$value]);
\&  $attrnode = $doc\->createAttributeNS( namespaceURI, $name [,$value] );
\&  $fragment = $doc\->createDocumentFragment();
\&  $cdata = $dom\->createCDATASection( $cdata_content );
\&  my $pi = $doc\->createProcessingInstruction( $target, $data );
\&  my $entref = $doc\->createEntityReference($refname);
\&  $dtd = $document\->createInternalSubset( $rootnode, $public, $system);
\&  $dtd = $document\->createExternalSubset( $rootnode_name, $publicId, $systemId);
\&  $document\->importNode( $node );
\&  $document\->adoptNode( $node );
\&  my $dtd = $doc\->externalSubset;
\&  my $dtd = $doc\->internalSubset;
\&  $doc\->setExternalSubset($dtd);
\&  $doc\->setInternalSubset($dtd);
\&  my $dtd = $doc\->removeExternalSubset();
\&  my $dtd = $doc\->removeInternalSubset();
\&  my @nodelist = $doc\->getElementsByTagName($tagname);
\&  my @nodelist = $doc\->getElementsByTagNameNS($nsURI,$tagname);
\&  my @nodelist = $doc\->getElementsByLocalName($localname);
\&  my $node = $doc\->getElementById($id);
\&  $dom\->indexElements();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Document Class is in most cases the result of a parsing process. But
sometimes it is necessary to create a Document from scratch. The \s-1DOM\s0 Document
Class provides functions that conform to the \s-1DOM\s0 Core naming style.
.PP
It inherits all functions from XML::LibXML::Node as specified in the \s-1DOM\s0 specification. This enables access to the nodes besides
the root element on document level \- a \f(CW\*(C`DTD\*(C'\fR for example. The support for these nodes is limited at the moment.
.PP
While generally nodes are bound to a document in the \s-1DOM\s0 concept it is
suggested that one should always create a node not bound to any document. There
is no need of really including the node to the document, but once the node is
bound to a document, it is quite safe that all strings have the correct
encoding. If an unbound text node with an \s-1ISO\s0 encoded string is created (e.g.
with \f(CW$CLASS\fR\->\fInew()\fR), the \f(CW\*(C`toString\*(C'\fR function may not return the expected result.
.PP
To prevent such problems, it is recommended to pass all data to XML::LibXML
methods as character strings (i.e. \s-1UTF\-8\s0 encoded, with the \s-1UTF8\s0 flag on).
.SH "METHODS"
.IX Header "METHODS"
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (http://www.w3.org/TR/DOM\-Level\-3\-Core/ <http://www.w3.org/TR/DOM-Level-3-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $dom = XML::LibXML::Document\->new( $version, $encoding );
.Ve
.Sp
alias for \fIcreateDocument()\fR
.IP "createDocument" 4
.IX Item "createDocument"
.Vb 1
\&  $dom = XML::LibXML::Document\->createDocument( $version, $encoding );
.Ve
.Sp
The constructor for the document class. As Parameter it takes the version
string and (optionally) the encoding string. Simply calling \fIcreateDocument\fR() will create the document:
.Sp
.Vb 1
\&  <?xml version="your version" encoding="your encoding"?>
.Ve
.Sp
Both parameter are optional. The default value for \fI\f(CI$version\fI\fR is \f(CW1.0\fR, of course. If the \fI\f(CI$encoding\fI\fR parameter is not set, the encoding will be left unset, which means \s-1UTF\-8\s0 is
implied.
.Sp
The call of \fIcreateDocument\fR() without any parameter will result the following code:
.Sp
.Vb 1
\&  <?xml version="1.0"?>
.Ve
.Sp
Alternatively one can call this constructor directly from the XML::LibXML class
level, to avoid some typing. This will not have any effect on the class
instance, which is always XML::LibXML::Document.
.Sp
.Vb 1
\&  my $document = XML::LibXML\->createDocument( "1.0", "UTF\-8" );
.Ve
.Sp
is therefore a shortcut for
.Sp
.Vb 1
\&  my $document = XML::LibXML::Document\->createDocument( "1.0", "UTF\-8" );
.Ve
.IP "\s-1URI\s0" 4
.IX Item "URI"
.Vb 1
\&  $strURI = $doc\->URI();
.Ve
.Sp
Returns the \s-1URI\s0 (or filename) of the original document. For documents obtained
by parsing a string of a \s-1FH\s0 without using the \s-1URI\s0 parsing argument of the
corresponding \f(CW\*(C`parse_*\*(C'\fR function, the result is a generated string unknown-XYZ where \s-1XYZ\s0 is some
number; for documents created with the constructor \f(CW\*(C`new\*(C'\fR, the \s-1URI\s0 is undefined.
.Sp
The value can be modified by calling \f(CW\*(C`setURI\*(C'\fR method on the document node.
.IP "setURI" 4
.IX Item "setURI"
.Vb 1
\&  $doc\->setURI($strURI);
.Ve
.Sp
Sets the \s-1URI\s0 of the document reported by the method \s-1URI\s0 (see also the \s-1URI\s0
argument to the various \f(CW\*(C`parse_*\*(C'\fR functions).
.IP "encoding" 4
.IX Item "encoding"
.Vb 1
\&  $strEncoding = $doc\->encoding();
.Ve
.Sp
returns the encoding string of the document.
.Sp
.Vb 2
\&  my $doc = XML::LibXML\->createDocument( "1.0", "ISO\-8859\-15" );
\&  print $doc\->encoding; # prints ISO\-8859\-15
.Ve
.IP "actualEncoding" 4
.IX Item "actualEncoding"
.Vb 1
\&  $strEncoding = $doc\->actualEncoding();
.Ve
.Sp
returns the encoding in which the \s-1XML\s0 will be returned by \f(CW$doc\fR\->\fItoString()\fR.
This is usually the original encoding of the document as declared in the \s-1XML\s0
declaration and returned by \f(CW$doc\fR\->encoding. If the original encoding is not
known (e.g. if created in memory or parsed from a \s-1XML\s0 without a declared
encoding), '\s-1UTF\-8\s0' is returned.
.Sp
.Vb 2
\&  my $doc = XML::LibXML\->createDocument( "1.0", "ISO\-8859\-15" );
\&  print $doc\->encoding; # prints ISO\-8859\-15
.Ve
.IP "setEncoding" 4
.IX Item "setEncoding"
.Vb 1
\&  $doc\->setEncoding($new_encoding);
.Ve
.Sp
This method allows to change the declaration of encoding in the \s-1XML\s0 declaration
of the document. The value also affects the encoding in which the document is
serialized to \s-1XML\s0 by \f(CW$doc\fR\->\fItoString()\fR. Use \fIsetEncoding()\fR to remove the encoding
declaration.
.IP "version" 4
.IX Item "version"
.Vb 1
\&  $strVersion = $doc\->version();
.Ve
.Sp
returns the version string of the document
.Sp
\&\fI\fIgetVersion()\fI\fR is an alternative form of this function.
.IP "standalone" 4
.IX Item "standalone"
.Vb 1
\&  $doc\->standalone
.Ve
.Sp
This function returns the Numerical value of a documents \s-1XML\s0 declarations
standalone attribute. It returns \fI1\fR if standalone=\*(L"yes\*(R" was found, \fI0\fR if standalone=\*(L"no\*(R" was found and \fI\-1\fR if standalone was not specified (default on creation).
.IP "setStandalone" 4
.IX Item "setStandalone"
.Vb 1
\&  $doc\->setStandalone($numvalue);
.Ve
.Sp
Through this method it is possible to alter the value of a documents standalone
attribute. Set it to \fI1\fR to set standalone=\*(L"yes\*(R", to \fI0\fR to set standalone=\*(L"no\*(R" or set it to \fI\-1\fR to remove the standalone attribute from the \s-1XML\s0 declaration.
.IP "compression" 4
.IX Item "compression"
.Vb 1
\&  my $compression = $doc\->compression;
.Ve
.Sp
libxml2 allows reading of documents directly from gzipped files. In this case
the compression variable is set to the compression level of that file (0\-8). If
XML::LibXML parsed a different source or the file wasn't compressed, the
returned value will be \fI\-1\fR.
.IP "setCompression" 4
.IX Item "setCompression"
.Vb 1
\&  $doc\->setCompression($ziplevel);
.Ve
.Sp
If one intends to write the document directly to a file, it is possible to set
the compression level for a given document. This level can be in the range from
0 to 8. If XML::LibXML should not try to compress use \fI\-1\fR (default).
.Sp
Note that this feature will \fIonly\fR work if libxml2 is compiled with zlib support and \fItoFile()\fR is used for output.
.IP "toString" 4
.IX Item "toString"
.Vb 1
\&  $docstring = $dom\->toString($format);
.Ve
.Sp
\&\fItoString\fR is a \s-1DOM\s0 serializing function, so the \s-1DOM\s0 Tree is serialized into an \s-1XML\s0
string, ready for output.
.Sp
\&\s-1IMPORTANT:\s0 unlike toString for other nodes, on document nodes this function
returns the \s-1XML\s0 as a byte string in the original encoding of the document (see
the \fIactualEncoding()\fR method)! This means you can simply do:
.Sp
.Vb 2
\&  open my $out_fh, \*(Aq>\*(Aq, $file;
\&  print {$out_fh} $doc\->toString;
.Ve
.Sp
regardless of the actual encoding of the document. See the section on encodings
in XML::LibXML for more details.
.Sp
The optional \fI\f(CI$format\fI\fR parameter sets the indenting of the output. This parameter is expected to be an \f(CW\*(C`integer\*(C'\fR value, that specifies that indentation should be used. The format parameter can
have three different values if it is used:
.Sp
If \f(CW$format\fR is 0, than the document is dumped as it was originally parsed
.Sp
If \f(CW$format\fR is 1, libxml2 will add ignorable white spaces, so the nodes content
is easier to read. Existing text nodes will not be altered
.Sp
If \f(CW$format\fR is 2 (or higher), libxml2 will act as \f(CW$format\fR == 1 but it add a
leading and a trailing line break to each text node.
.Sp
libxml2 uses a hard-coded indentation of 2 space characters per indentation
level. This value can not be altered on run-time.
.IP "toStringC14N" 4
.IX Item "toStringC14N"
.Vb 1
\&  $c14nstr = $doc\->toStringC14N($comment_flag, $xpath [, $xpath_context ]);
.Ve
.Sp
See the documentation in XML::LibXML::Node.
.IP "toStringEC14N" 4
.IX Item "toStringEC14N"
.Vb 1
\&  $ec14nstr = $doc\->toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
.Ve
.Sp
See the documentation in XML::LibXML::Node.
.IP "serialize" 4
.IX Item "serialize"
.Vb 1
\&  $str = $doc\->serialize($format);
.Ve
.Sp
An alias for \fItoString()\fR. This function was name added to be more consistent
with libxml2.
.IP "serialize_c14n" 4
.IX Item "serialize_c14n"
An alias for \fItoStringC14N()\fR.
.IP "serialize_exc_c14n" 4
.IX Item "serialize_exc_c14n"
An alias for \fItoStringEC14N()\fR.
.IP "toFile" 4
.IX Item "toFile"
.Vb 1
\&  $state = $doc\->toFile($filename, $format);
.Ve
.Sp
This function is similar to \fItoString()\fR, but it writes the document directly
into a filesystem. This function is very useful, if one needs to store large
documents.
.Sp
The format parameter has the same behaviour as in \fItoString()\fR.
.IP "toFH" 4
.IX Item "toFH"
.Vb 1
\&  $state = $doc\->toFH($fh, $format);
.Ve
.Sp
This function is similar to \fItoString()\fR, but it writes the document directly to
a filehandle or a stream. A byte stream in the document encoding is passed to
the file handle. Do \s-1NOT\s0 apply any \f(CW\*(C`:encoding(...)\*(C'\fR or \f(CW\*(C`:utf8\*(C'\fR PerlIO layer to the filehandle! See the section on encodings in XML::LibXML for more details.
.Sp
The format parameter has the same behaviour as in \fItoString()\fR.
.IP "toStringHTML" 4
.IX Item "toStringHTML"
.Vb 1
\&  $str = $document\->toStringHTML();
.Ve
.Sp
\&\fItoStringHTML\fR serialize the tree to a byte string in the document encoding as \s-1HTML\s0. With this
method indenting is automatic and managed by libxml2 internally.
.IP "serialize_html" 4
.IX Item "serialize_html"
.Vb 1
\&  $str = $document\->serialize_html();
.Ve
.Sp
An alias for \fItoStringHTML()\fR.
.IP "is_valid" 4
.IX Item "is_valid"
.Vb 1
\&  $bool = $dom\->is_valid();
.Ve
.Sp
Returns either \s-1TRUE\s0 or \s-1FALSE\s0 depending on whether the \s-1DOM\s0 Tree is a valid
Document or not.
.Sp
You may also pass in a XML::LibXML::Dtd object, to validate against an external \s-1DTD:\s0
.Sp
.Vb 3
\&  if (!$dom\->is_valid($dtd)) {
\&       warn("document is not valid!");
\&   }
.Ve
.IP "validate" 4
.IX Item "validate"
.Vb 1
\&  $dom\->validate();
.Ve
.Sp
This is an exception throwing equivalent of is_valid. If the document is not
valid it will throw an exception containing the error. This allows you much
better error reporting than simply is_valid or not.
.Sp
Again, you may pass in a \s-1DTD\s0 object
.IP "documentElement" 4
.IX Item "documentElement"
.Vb 1
\&  $root = $dom\->documentElement();
.Ve
.Sp
Returns the root element of the Document. A document can have just one root
element to contain the documents data.
.Sp
Optionally one can use \fIgetDocumentElement\fR.
.IP "setDocumentElement" 4
.IX Item "setDocumentElement"
.Vb 1
\&  $dom\->setDocumentElement( $root );
.Ve
.Sp
This function enables you to set the root element for a document. The function
supports the import of a node from a different document tree, but does not
support a document fragment as \f(CW$root\fR.
.IP "createElement" 4
.IX Item "createElement"
.Vb 1
\&  $element = $dom\->createElement( $nodename );
.Ve
.Sp
This function creates a new Element Node bound to the \s-1DOM\s0 with the name \f(CW$nodename\fR.
.IP "createElementNS" 4
.IX Item "createElementNS"
.Vb 1
\&  $element = $dom\->createElementNS( $namespaceURI, $qname );
.Ve
.Sp
This function creates a new Element Node bound to the \s-1DOM\s0 with the name \f(CW$nodename\fR and placed in the given namespace.
.IP "createTextNode" 4
.IX Item "createTextNode"
.Vb 1
\&  $text = $dom\->createTextNode( $content_text );
.Ve
.Sp
As an equivalent of \fIcreateElement\fR, but it creates a \fIText Node\fR bound to the \s-1DOM\s0.
.IP "createComment" 4
.IX Item "createComment"
.Vb 1
\&  $comment = $dom\->createComment( $comment_text );
.Ve
.Sp
As an equivalent of \fIcreateElement\fR, but it creates a \fIComment Node\fR bound to the \s-1DOM\s0.
.IP "createAttribute" 4
.IX Item "createAttribute"
.Vb 1
\&  $attrnode = $doc\->createAttribute($name [,$value]);
.Ve
.Sp
Creates a new Attribute node.
.IP "createAttributeNS" 4
.IX Item "createAttributeNS"
.Vb 1
\&  $attrnode = $doc\->createAttributeNS( namespaceURI, $name [,$value] );
.Ve
.Sp
Creates an Attribute bound to a namespace.
.IP "createDocumentFragment" 4
.IX Item "createDocumentFragment"
.Vb 1
\&  $fragment = $doc\->createDocumentFragment();
.Ve
.Sp
This function creates a DocumentFragment.
.IP "createCDATASection" 4
.IX Item "createCDATASection"
.Vb 1
\&  $cdata = $dom\->createCDATASection( $cdata_content );
.Ve
.Sp
Similar to createTextNode and createComment, this function creates a
CDataSection bound to the current \s-1DOM\s0.
.IP "createProcessingInstruction" 4
.IX Item "createProcessingInstruction"
.Vb 1
\&  my $pi = $doc\->createProcessingInstruction( $target, $data );
.Ve
.Sp
create a processing instruction node.
.Sp
Since this method is quite long one may use its short form \fI\fIcreatePI()\fI\fR.
.IP "createEntityReference" 4
.IX Item "createEntityReference"
.Vb 1
\&  my $entref = $doc\->createEntityReference($refname);
.Ve
.Sp
If a document has a \s-1DTD\s0 specified, one can create entity references by using
this function. If one wants to add a entity reference to the document, this
reference has to be created by this function.
.Sp
An entity reference is unique to a document and cannot be passed to other
documents as other nodes can be passed.
.Sp
\&\fI\s-1NOTE:\s0\fR A text content containing something that looks like an entity reference, will
not be expanded to a real entity reference unless it is a predefined entity
.Sp
.Vb 3
\&  my $string = "&foo;";
\&   $some_element\->appendText( $string );
\&   print $some_element\->textContent; # prints "&amp;foo;"
.Ve
.IP "createInternalSubset" 4
.IX Item "createInternalSubset"
.Vb 1
\&  $dtd = $document\->createInternalSubset( $rootnode, $public, $system);
.Ve
.Sp
This function creates and adds an internal subset to the given document.
Because the function automatically adds the \s-1DTD\s0 to the document there is no
need to add the created node explicitly to the document.
.Sp
.Vb 2
\&  my $document = XML::LibXML::Document\->new();
\&   my $dtd      = $document\->createInternalSubset( "foo", undef, "foo.dtd" );
.Ve
.Sp
will result in the following \s-1XML\s0 document:
.Sp
.Vb 2
\&  <?xml version="1.0"?>
\&   <!DOCTYPE foo SYSTEM "foo.dtd">
.Ve
.Sp
By setting the public parameter it is possible to set \s-1PUBLIC\s0 DTDs to a given
document. So
.Sp
.Vb 2
\&  my $document = XML::LibXML::Document\->new();
\&  my $dtd      = $document\->createInternalSubset( "foo", "\-//FOO//DTD FOO 0.1//EN", undef );
.Ve
.Sp
will cause the following declaration to be created on the document:
.Sp
.Vb 2
\&  <?xml version="1.0"?>
\&  <!DOCTYPE foo PUBLIC "\-//FOO//DTD FOO 0.1//EN">
.Ve
.IP "createExternalSubset" 4
.IX Item "createExternalSubset"
.Vb 1
\&  $dtd = $document\->createExternalSubset( $rootnode_name, $publicId, $systemId);
.Ve
.Sp
This function is similar to \f(CW\*(C`createInternalSubset()\*(C'\fR but this \s-1DTD\s0 is considered to be external and is therefore not added to the
document itself. Nevertheless it can be used for validation purposes.
.IP "importNode" 4
.IX Item "importNode"
.Vb 1
\&  $document\->importNode( $node );
.Ve
.Sp
If a node is not part of a document, it can be imported to another document. As
specified in \s-1DOM\s0 Level 2 Specification the Node will not be altered or removed
from its original document (\f(CW\*(C`$node\->cloneNode(1)\*(C'\fR will get called implicitly).
.Sp
\&\fI\s-1NOTE:\s0\fR Don't try to use \fIimportNode()\fR to import sub-trees that contain an entity
reference \- even if the entity reference is the root node of the sub-tree. This
will cause serious problems to your program. This is a limitation of libxml2
and not of XML::LibXML itself.
.IP "adoptNode" 4
.IX Item "adoptNode"
.Vb 1
\&  $document\->adoptNode( $node );
.Ve
.Sp
If a node is not part of a document, it can be imported to another document. As
specified in \s-1DOM\s0 Level 3 Specification the Node will not be altered but it will
removed from its original document.
.Sp
After a document adopted a node, the node, its attributes and all its
descendants belong to the new document. Because the node does not belong to the
old document, it will be unlinked from its old location first.
.Sp
\&\fI\s-1NOTE:\s0\fR Don't try to \fIadoptNode()\fR to import sub-trees that contain entity references \-
even if the entity reference is the root node of the sub-tree. This will cause
serious problems to your program. This is a limitation of libxml2 and not of
XML::LibXML itself.
.IP "externalSubset" 4
.IX Item "externalSubset"
.Vb 1
\&  my $dtd = $doc\->externalSubset;
.Ve
.Sp
If a document has an external subset defined it will be returned by this
function.
.Sp
\&\fI\s-1NOTE\s0\fR Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in
XML::LibXML is still limited. In particular one may not want use common node
function on doctype declaration nodes!
.IP "internalSubset" 4
.IX Item "internalSubset"
.Vb 1
\&  my $dtd = $doc\->internalSubset;
.Ve
.Sp
If a document has an internal subset defined it will be returned by this
function.
.Sp
\&\fI\s-1NOTE\s0\fR Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in
XML::LibXML is still limited. In particular one may not want use common node
function on doctype declaration nodes!
.IP "setExternalSubset" 4
.IX Item "setExternalSubset"
.Vb 1
\&  $doc\->setExternalSubset($dtd);
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
This method sets a \s-1DTD\s0 node as an external subset of the given document.
.IP "setInternalSubset" 4
.IX Item "setInternalSubset"
.Vb 1
\&  $doc\->setInternalSubset($dtd);
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
This method sets a \s-1DTD\s0 node as an internal subset of the given document.
.IP "removeExternalSubset" 4
.IX Item "removeExternalSubset"
.Vb 1
\&  my $dtd = $doc\->removeExternalSubset();
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
If a document has an external subset defined it can be removed from the
document by using this function. The removed dtd node will be returned.
.IP "removeInternalSubset" 4
.IX Item "removeInternalSubset"
.Vb 1
\&  my $dtd = $doc\->removeInternalSubset();
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
If a document has an internal subset defined it can be removed from the
document by using this function. The removed dtd node will be returned.
.IP "getElementsByTagName" 4
.IX Item "getElementsByTagName"
.Vb 1
\&  my @nodelist = $doc\->getElementsByTagName($tagname);
.Ve
.Sp
Implements the \s-1DOM\s0 Level 2 function
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByTagNameNS" 4
.IX Item "getElementsByTagNameNS"
.Vb 1
\&  my @nodelist = $doc\->getElementsByTagNameNS($nsURI,$tagname);
.Ve
.Sp
Implements the \s-1DOM\s0 Level 2 function
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByLocalName" 4
.IX Item "getElementsByLocalName"
.Vb 1
\&  my @nodelist = $doc\->getElementsByLocalName($localname);
.Ve
.Sp
This allows the fetching of all nodes from a given document with the given
Localname.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementById" 4
.IX Item "getElementById"
.Vb 1
\&  my $node = $doc\->getElementById($id);
.Ve
.Sp
Returns the element that has an \s-1ID\s0 attribute with the given value. If no such
element exists, this returns undef.
.Sp
Note: the \s-1ID\s0 of an element may change while manipulating the document. For
documents with a \s-1DTD\s0, the information about \s-1ID\s0 attributes is only available if
\&\s-1DTD\s0 loading/validation has been requested. For \s-1HTML\s0 documents parsed with the
\&\s-1HTML\s0 parser \s-1ID\s0 detection is done automatically. In \s-1XML\s0 documents, all \*(L"xml:id\*(R"
attributes are considered to be of type \s-1ID\s0. You can test ID-ness of an
attribute node with \f(CW$attr\fR\->\fIisId()\fR.
.Sp
In versions 1.59 and earlier this method was called \fIgetElementsById()\fR (plural)
by mistake. Starting from 1.60 this name is maintained as an alias only for
backward compatibility.
.IP "indexElements" 4
.IX Item "indexElements"
.Vb 1
\&  $dom\->indexElements();
.Ve
.Sp
This function causes libxml2 to stamp all elements in a document with their
document position index which considerably speeds up XPath queries for large
documents. It should only be used with static documents that won't be further
changed by any \s-1DOM\s0 methods, because once a document is indexed, XPath will
always prefer the index to other methods of determining the document order of
nodes. XPath could therefore return improperly ordered node-lists when applied
on a document that has been changed after being indexed. It is of course
possible to use this method to re-index a modified document before using it
with XPath again. This function is not a part of the \s-1DOM\s0 specification.
.Sp
This function returns number of elements indexed, \-1 if error occurred, or \-2
if this feature is not available in the running libxml2.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Document5.18.3pm                0100644 0001750 0001750 00000067576 12566241670 025362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Document 3"
.TH XML::LibXML::Document 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Document \- XML::LibXML DOM Document Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Document nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $dom = XML::LibXML::Document\->new( $version, $encoding );
\&  $dom = XML::LibXML::Document\->createDocument( $version, $encoding );
\&  $strURI = $doc\->URI();
\&  $doc\->setURI($strURI);
\&  $strEncoding = $doc\->encoding();
\&  $strEncoding = $doc\->actualEncoding();
\&  $doc\->setEncoding($new_encoding);
\&  $strVersion = $doc\->version();
\&  $doc\->standalone
\&  $doc\->setStandalone($numvalue);
\&  my $compression = $doc\->compression;
\&  $doc\->setCompression($ziplevel);
\&  $docstring = $dom\->toString($format);
\&  $c14nstr = $doc\->toStringC14N($comment_flag, $xpath [, $xpath_context ]);
\&  $ec14nstr = $doc\->toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
\&  $str = $doc\->serialize($format);
\&  $state = $doc\->toFile($filename, $format);
\&  $state = $doc\->toFH($fh, $format);
\&  $str = $document\->toStringHTML();
\&  $str = $document\->serialize_html();
\&  $bool = $dom\->is_valid();
\&  $dom\->validate();
\&  $root = $dom\->documentElement();
\&  $dom\->setDocumentElement( $root );
\&  $element = $dom\->createElement( $nodename );
\&  $element = $dom\->createElementNS( $namespaceURI, $qname );
\&  $text = $dom\->createTextNode( $content_text );
\&  $comment = $dom\->createComment( $comment_text );
\&  $attrnode = $doc\->createAttribute($name [,$value]);
\&  $attrnode = $doc\->createAttributeNS( namespaceURI, $name [,$value] );
\&  $fragment = $doc\->createDocumentFragment();
\&  $cdata = $dom\->createCDATASection( $cdata_content );
\&  my $pi = $doc\->createProcessingInstruction( $target, $data );
\&  my $entref = $doc\->createEntityReference($refname);
\&  $dtd = $document\->createInternalSubset( $rootnode, $public, $system);
\&  $dtd = $document\->createExternalSubset( $rootnode_name, $publicId, $systemId);
\&  $document\->importNode( $node );
\&  $document\->adoptNode( $node );
\&  my $dtd = $doc\->externalSubset;
\&  my $dtd = $doc\->internalSubset;
\&  $doc\->setExternalSubset($dtd);
\&  $doc\->setInternalSubset($dtd);
\&  my $dtd = $doc\->removeExternalSubset();
\&  my $dtd = $doc\->removeInternalSubset();
\&  my @nodelist = $doc\->getElementsByTagName($tagname);
\&  my @nodelist = $doc\->getElementsByTagNameNS($nsURI,$tagname);
\&  my @nodelist = $doc\->getElementsByLocalName($localname);
\&  my $node = $doc\->getElementById($id);
\&  $dom\->indexElements();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Document Class is in most cases the result of a parsing process. But
sometimes it is necessary to create a Document from scratch. The \s-1DOM\s0 Document
Class provides functions that conform to the \s-1DOM\s0 Core naming style.
.PP
It inherits all functions from XML::LibXML::Node as specified in the \s-1DOM\s0 specification. This enables access to the nodes besides
the root element on document level \- a \f(CW\*(C`DTD\*(C'\fR for example. The support for these nodes is limited at the moment.
.PP
While generally nodes are bound to a document in the \s-1DOM\s0 concept it is
suggested that one should always create a node not bound to any document. There
is no need of really including the node to the document, but once the node is
bound to a document, it is quite safe that all strings have the correct
encoding. If an unbound text node with an \s-1ISO\s0 encoded string is created (e.g.
with \f(CW$CLASS\fR\->\fInew()\fR), the \f(CW\*(C`toString\*(C'\fR function may not return the expected result.
.PP
To prevent such problems, it is recommended to pass all data to XML::LibXML
methods as character strings (i.e. \s-1UTF\-8\s0 encoded, with the \s-1UTF8\s0 flag on).
.SH "METHODS"
.IX Header "METHODS"
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $dom = XML::LibXML::Document\->new( $version, $encoding );
.Ve
.Sp
alias for \fIcreateDocument()\fR
.IP "createDocument" 4
.IX Item "createDocument"
.Vb 1
\&  $dom = XML::LibXML::Document\->createDocument( $version, $encoding );
.Ve
.Sp
The constructor for the document class. As Parameter it takes the version
string and (optionally) the encoding string. Simply calling \fIcreateDocument\fR() will create the document:
.Sp
.Vb 1
\&  <?xml version="your version" encoding="your encoding"?>
.Ve
.Sp
Both parameter are optional. The default value for \fI\f(CI$version\fI\fR is \f(CW1.0\fR, of course. If the \fI\f(CI$encoding\fI\fR parameter is not set, the encoding will be left unset, which means \s-1UTF\-8\s0 is
implied.
.Sp
The call of \fIcreateDocument\fR() without any parameter will result the following code:
.Sp
.Vb 1
\&  <?xml version="1.0"?>
.Ve
.Sp
Alternatively one can call this constructor directly from the XML::LibXML class
level, to avoid some typing. This will not have any effect on the class
instance, which is always XML::LibXML::Document.
.Sp
.Vb 1
\&  my $document = XML::LibXML\->createDocument( "1.0", "UTF\-8" );
.Ve
.Sp
is therefore a shortcut for
.Sp
.Vb 1
\&  my $document = XML::LibXML::Document\->createDocument( "1.0", "UTF\-8" );
.Ve
.IP "\s-1URI\s0" 4
.IX Item "URI"
.Vb 1
\&  $strURI = $doc\->URI();
.Ve
.Sp
Returns the \s-1URI \s0(or filename) of the original document. For documents obtained
by parsing a string of a \s-1FH\s0 without using the \s-1URI\s0 parsing argument of the
corresponding \f(CW\*(C`parse_*\*(C'\fR function, the result is a generated string unknown-XYZ where \s-1XYZ\s0 is some
number; for documents created with the constructor \f(CW\*(C`new\*(C'\fR, the \s-1URI\s0 is undefined.
.Sp
The value can be modified by calling \f(CW\*(C`setURI\*(C'\fR method on the document node.
.IP "setURI" 4
.IX Item "setURI"
.Vb 1
\&  $doc\->setURI($strURI);
.Ve
.Sp
Sets the \s-1URI\s0 of the document reported by the method \s-1URI \s0(see also the \s-1URI\s0
argument to the various \f(CW\*(C`parse_*\*(C'\fR functions).
.IP "encoding" 4
.IX Item "encoding"
.Vb 1
\&  $strEncoding = $doc\->encoding();
.Ve
.Sp
returns the encoding string of the document.
.Sp
.Vb 2
\&  my $doc = XML::LibXML\->createDocument( "1.0", "ISO\-8859\-15" );
\&  print $doc\->encoding; # prints ISO\-8859\-15
.Ve
.IP "actualEncoding" 4
.IX Item "actualEncoding"
.Vb 1
\&  $strEncoding = $doc\->actualEncoding();
.Ve
.Sp
returns the encoding in which the \s-1XML\s0 will be returned by \f(CW$doc\fR\->\fItoString()\fR.
This is usually the original encoding of the document as declared in the \s-1XML\s0
declaration and returned by \f(CW$doc\fR\->encoding. If the original encoding is not
known (e.g. if created in memory or parsed from a \s-1XML\s0 without a declared
encoding), '\s-1UTF\-8\s0' is returned.
.Sp
.Vb 2
\&  my $doc = XML::LibXML\->createDocument( "1.0", "ISO\-8859\-15" );
\&  print $doc\->encoding; # prints ISO\-8859\-15
.Ve
.IP "setEncoding" 4
.IX Item "setEncoding"
.Vb 1
\&  $doc\->setEncoding($new_encoding);
.Ve
.Sp
This method allows one to change the declaration of encoding in the \s-1XML\s0
declaration of the document. The value also affects the encoding in which the
document is serialized to \s-1XML\s0 by \f(CW$doc\fR\->\fItoString()\fR. Use \fIsetEncoding()\fR to remove
the encoding declaration.
.IP "version" 4
.IX Item "version"
.Vb 1
\&  $strVersion = $doc\->version();
.Ve
.Sp
returns the version string of the document
.Sp
\&\fI\fIgetVersion()\fI\fR is an alternative form of this function.
.IP "standalone" 4
.IX Item "standalone"
.Vb 1
\&  $doc\->standalone
.Ve
.Sp
This function returns the Numerical value of a documents \s-1XML\s0 declarations
standalone attribute. It returns \fI1\fR if standalone=\*(L"yes\*(R" was found, \fI0\fR if standalone=\*(L"no\*(R" was found and \fI\-1\fR if standalone was not specified (default on creation).
.IP "setStandalone" 4
.IX Item "setStandalone"
.Vb 1
\&  $doc\->setStandalone($numvalue);
.Ve
.Sp
Through this method it is possible to alter the value of a documents standalone
attribute. Set it to \fI1\fR to set standalone=\*(L"yes\*(R", to \fI0\fR to set standalone=\*(L"no\*(R" or set it to \fI\-1\fR to remove the standalone attribute from the \s-1XML\s0 declaration.
.IP "compression" 4
.IX Item "compression"
.Vb 1
\&  my $compression = $doc\->compression;
.Ve
.Sp
libxml2 allows reading of documents directly from gzipped files. In this case
the compression variable is set to the compression level of that file (0\-8). If
XML::LibXML parsed a different source or the file wasn't compressed, the
returned value will be \fI\-1\fR.
.IP "setCompression" 4
.IX Item "setCompression"
.Vb 1
\&  $doc\->setCompression($ziplevel);
.Ve
.Sp
If one intends to write the document directly to a file, it is possible to set
the compression level for a given document. This level can be in the range from
0 to 8. If XML::LibXML should not try to compress use \fI\-1\fR (default).
.Sp
Note that this feature will \fIonly\fR work if libxml2 is compiled with zlib support and \fItoFile()\fR is used for output.
.IP "toString" 4
.IX Item "toString"
.Vb 1
\&  $docstring = $dom\->toString($format);
.Ve
.Sp
\&\fItoString\fR is a \s-1DOM\s0 serializing function, so the \s-1DOM\s0 Tree is serialized into an \s-1XML\s0
string, ready for output.
.Sp
\&\s-1IMPORTANT:\s0 unlike toString for other nodes, on document nodes this function
returns the \s-1XML\s0 as a byte string in the original encoding of the document (see
the \fIactualEncoding()\fR method)! This means you can simply do:
.Sp
.Vb 2
\&  open my $out_fh, \*(Aq>\*(Aq, $file;
\&  print {$out_fh} $doc\->toString;
.Ve
.Sp
regardless of the actual encoding of the document. See the section on encodings
in XML::LibXML for more details.
.Sp
The optional \fI\f(CI$format\fI\fR parameter sets the indenting of the output. This parameter is expected to be an \f(CW\*(C`integer\*(C'\fR value, that specifies that indentation should be used. The format parameter can
have three different values if it is used:
.Sp
If \f(CW$format\fR is 0, than the document is dumped as it was originally parsed
.Sp
If \f(CW$format\fR is 1, libxml2 will add ignorable white spaces, so the nodes content
is easier to read. Existing text nodes will not be altered
.Sp
If \f(CW$format\fR is 2 (or higher), libxml2 will act as \f(CW$format\fR == 1 but it add a
leading and a trailing line break to each text node.
.Sp
libxml2 uses a hard-coded indentation of 2 space characters per indentation
level. This value can not be altered on run-time.
.IP "toStringC14N" 4
.IX Item "toStringC14N"
.Vb 1
\&  $c14nstr = $doc\->toStringC14N($comment_flag, $xpath [, $xpath_context ]);
.Ve
.Sp
See the documentation in XML::LibXML::Node.
.IP "toStringEC14N" 4
.IX Item "toStringEC14N"
.Vb 1
\&  $ec14nstr = $doc\->toStringEC14N($comment_flag, $xpath [, $xpath_context ], $inclusive_prefix_list);
.Ve
.Sp
See the documentation in XML::LibXML::Node.
.IP "serialize" 4
.IX Item "serialize"
.Vb 1
\&  $str = $doc\->serialize($format);
.Ve
.Sp
An alias for \fItoString()\fR. This function was name added to be more consistent
with libxml2.
.IP "serialize_c14n" 4
.IX Item "serialize_c14n"
An alias for \fItoStringC14N()\fR.
.IP "serialize_exc_c14n" 4
.IX Item "serialize_exc_c14n"
An alias for \fItoStringEC14N()\fR.
.IP "toFile" 4
.IX Item "toFile"
.Vb 1
\&  $state = $doc\->toFile($filename, $format);
.Ve
.Sp
This function is similar to \fItoString()\fR, but it writes the document directly
into a filesystem. This function is very useful, if one needs to store large
documents.
.Sp
The format parameter has the same behaviour as in \fItoString()\fR.
.IP "toFH" 4
.IX Item "toFH"
.Vb 1
\&  $state = $doc\->toFH($fh, $format);
.Ve
.Sp
This function is similar to \fItoString()\fR, but it writes the document directly to
a filehandle or a stream. A byte stream in the document encoding is passed to
the file handle. Do \s-1NOT\s0 apply any \f(CW\*(C`:encoding(...)\*(C'\fR or \f(CW\*(C`:utf8\*(C'\fR PerlIO layer to the filehandle! See the section on encodings in XML::LibXML for more details.
.Sp
The format parameter has the same behaviour as in \fItoString()\fR.
.IP "toStringHTML" 4
.IX Item "toStringHTML"
.Vb 1
\&  $str = $document\->toStringHTML();
.Ve
.Sp
\&\fItoStringHTML\fR serialize the tree to a byte string in the document encoding as \s-1HTML.\s0 With this
method indenting is automatic and managed by libxml2 internally.
.IP "serialize_html" 4
.IX Item "serialize_html"
.Vb 1
\&  $str = $document\->serialize_html();
.Ve
.Sp
An alias for \fItoStringHTML()\fR.
.IP "is_valid" 4
.IX Item "is_valid"
.Vb 1
\&  $bool = $dom\->is_valid();
.Ve
.Sp
Returns either \s-1TRUE\s0 or \s-1FALSE\s0 depending on whether the \s-1DOM\s0 Tree is a valid
Document or not.
.Sp
You may also pass in a XML::LibXML::Dtd object, to validate against an external \s-1DTD:\s0
.Sp
.Vb 3
\&  if (!$dom\->is_valid($dtd)) {
\&       warn("document is not valid!");
\&   }
.Ve
.IP "validate" 4
.IX Item "validate"
.Vb 1
\&  $dom\->validate();
.Ve
.Sp
This is an exception throwing equivalent of is_valid. If the document is not
valid it will throw an exception containing the error. This allows you much
better error reporting than simply is_valid or not.
.Sp
Again, you may pass in a \s-1DTD\s0 object
.IP "documentElement" 4
.IX Item "documentElement"
.Vb 1
\&  $root = $dom\->documentElement();
.Ve
.Sp
Returns the root element of the Document. A document can have just one root
element to contain the documents data.
.Sp
Optionally one can use \fIgetDocumentElement\fR.
.IP "setDocumentElement" 4
.IX Item "setDocumentElement"
.Vb 1
\&  $dom\->setDocumentElement( $root );
.Ve
.Sp
This function enables you to set the root element for a document. The function
supports the import of a node from a different document tree, but does not
support a document fragment as \f(CW$root\fR.
.IP "createElement" 4
.IX Item "createElement"
.Vb 1
\&  $element = $dom\->createElement( $nodename );
.Ve
.Sp
This function creates a new Element Node bound to the \s-1DOM\s0 with the name \f(CW$nodename\fR.
.IP "createElementNS" 4
.IX Item "createElementNS"
.Vb 1
\&  $element = $dom\->createElementNS( $namespaceURI, $qname );
.Ve
.Sp
This function creates a new Element Node bound to the \s-1DOM\s0 with the name \f(CW$nodename\fR and placed in the given namespace.
.IP "createTextNode" 4
.IX Item "createTextNode"
.Vb 1
\&  $text = $dom\->createTextNode( $content_text );
.Ve
.Sp
As an equivalent of \fIcreateElement\fR, but it creates a \fIText Node\fR bound to the \s-1DOM.\s0
.IP "createComment" 4
.IX Item "createComment"
.Vb 1
\&  $comment = $dom\->createComment( $comment_text );
.Ve
.Sp
As an equivalent of \fIcreateElement\fR, but it creates a \fIComment Node\fR bound to the \s-1DOM.\s0
.IP "createAttribute" 4
.IX Item "createAttribute"
.Vb 1
\&  $attrnode = $doc\->createAttribute($name [,$value]);
.Ve
.Sp
Creates a new Attribute node.
.IP "createAttributeNS" 4
.IX Item "createAttributeNS"
.Vb 1
\&  $attrnode = $doc\->createAttributeNS( namespaceURI, $name [,$value] );
.Ve
.Sp
Creates an Attribute bound to a namespace.
.IP "createDocumentFragment" 4
.IX Item "createDocumentFragment"
.Vb 1
\&  $fragment = $doc\->createDocumentFragment();
.Ve
.Sp
This function creates a DocumentFragment.
.IP "createCDATASection" 4
.IX Item "createCDATASection"
.Vb 1
\&  $cdata = $dom\->createCDATASection( $cdata_content );
.Ve
.Sp
Similar to createTextNode and createComment, this function creates a
CDataSection bound to the current \s-1DOM.\s0
.IP "createProcessingInstruction" 4
.IX Item "createProcessingInstruction"
.Vb 1
\&  my $pi = $doc\->createProcessingInstruction( $target, $data );
.Ve
.Sp
create a processing instruction node.
.Sp
Since this method is quite long one may use its short form \fI\fIcreatePI()\fI\fR.
.IP "createEntityReference" 4
.IX Item "createEntityReference"
.Vb 1
\&  my $entref = $doc\->createEntityReference($refname);
.Ve
.Sp
If a document has a \s-1DTD\s0 specified, one can create entity references by using
this function. If one wants to add a entity reference to the document, this
reference has to be created by this function.
.Sp
An entity reference is unique to a document and cannot be passed to other
documents as other nodes can be passed.
.Sp
\&\fI\s-1NOTE:\s0\fR A text content containing something that looks like an entity reference, will
not be expanded to a real entity reference unless it is a predefined entity
.Sp
.Vb 3
\&  my $string = "&foo;";
\&   $some_element\->appendText( $string );
\&   print $some_element\->textContent; # prints "&amp;foo;"
.Ve
.IP "createInternalSubset" 4
.IX Item "createInternalSubset"
.Vb 1
\&  $dtd = $document\->createInternalSubset( $rootnode, $public, $system);
.Ve
.Sp
This function creates and adds an internal subset to the given document.
Because the function automatically adds the \s-1DTD\s0 to the document there is no
need to add the created node explicitly to the document.
.Sp
.Vb 2
\&  my $document = XML::LibXML::Document\->new();
\&   my $dtd      = $document\->createInternalSubset( "foo", undef, "foo.dtd" );
.Ve
.Sp
will result in the following \s-1XML\s0 document:
.Sp
.Vb 2
\&  <?xml version="1.0"?>
\&   <!DOCTYPE foo SYSTEM "foo.dtd">
.Ve
.Sp
By setting the public parameter it is possible to set \s-1PUBLIC\s0 DTDs to a given
document. So
.Sp
.Vb 2
\&  my $document = XML::LibXML::Document\->new();
\&  my $dtd      = $document\->createInternalSubset( "foo", "\-//FOO//DTD FOO 0.1//EN", undef );
.Ve
.Sp
will cause the following declaration to be created on the document:
.Sp
.Vb 2
\&  <?xml version="1.0"?>
\&  <!DOCTYPE foo PUBLIC "\-//FOO//DTD FOO 0.1//EN">
.Ve
.IP "createExternalSubset" 4
.IX Item "createExternalSubset"
.Vb 1
\&  $dtd = $document\->createExternalSubset( $rootnode_name, $publicId, $systemId);
.Ve
.Sp
This function is similar to \f(CW\*(C`createInternalSubset()\*(C'\fR but this \s-1DTD\s0 is considered to be external and is therefore not added to the
document itself. Nevertheless it can be used for validation purposes.
.IP "importNode" 4
.IX Item "importNode"
.Vb 1
\&  $document\->importNode( $node );
.Ve
.Sp
If a node is not part of a document, it can be imported to another document. As
specified in \s-1DOM\s0 Level 2 Specification the Node will not be altered or removed
from its original document (\f(CW\*(C`$node\->cloneNode(1)\*(C'\fR will get called implicitly).
.Sp
\&\fI\s-1NOTE:\s0\fR Don't try to use \fIimportNode()\fR to import sub-trees that contain an entity
reference \- even if the entity reference is the root node of the sub-tree. This
will cause serious problems to your program. This is a limitation of libxml2
and not of XML::LibXML itself.
.IP "adoptNode" 4
.IX Item "adoptNode"
.Vb 1
\&  $document\->adoptNode( $node );
.Ve
.Sp
If a node is not part of a document, it can be imported to another document. As
specified in \s-1DOM\s0 Level 3 Specification the Node will not be altered but it will
removed from its original document.
.Sp
After a document adopted a node, the node, its attributes and all its
descendants belong to the new document. Because the node does not belong to the
old document, it will be unlinked from its old location first.
.Sp
\&\fI\s-1NOTE:\s0\fR Don't try to \fIadoptNode()\fR to import sub-trees that contain entity references \-
even if the entity reference is the root node of the sub-tree. This will cause
serious problems to your program. This is a limitation of libxml2 and not of
XML::LibXML itself.
.IP "externalSubset" 4
.IX Item "externalSubset"
.Vb 1
\&  my $dtd = $doc\->externalSubset;
.Ve
.Sp
If a document has an external subset defined it will be returned by this
function.
.Sp
\&\fI\s-1NOTE\s0\fR Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in
XML::LibXML is still limited. In particular one may not want use common node
function on doctype declaration nodes!
.IP "internalSubset" 4
.IX Item "internalSubset"
.Vb 1
\&  my $dtd = $doc\->internalSubset;
.Ve
.Sp
If a document has an internal subset defined it will be returned by this
function.
.Sp
\&\fI\s-1NOTE\s0\fR Dtd nodes are no ordinary nodes in libxml2. The support for these nodes in
XML::LibXML is still limited. In particular one may not want use common node
function on doctype declaration nodes!
.IP "setExternalSubset" 4
.IX Item "setExternalSubset"
.Vb 1
\&  $doc\->setExternalSubset($dtd);
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
This method sets a \s-1DTD\s0 node as an external subset of the given document.
.IP "setInternalSubset" 4
.IX Item "setInternalSubset"
.Vb 1
\&  $doc\->setInternalSubset($dtd);
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
This method sets a \s-1DTD\s0 node as an internal subset of the given document.
.IP "removeExternalSubset" 4
.IX Item "removeExternalSubset"
.Vb 1
\&  my $dtd = $doc\->removeExternalSubset();
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
If a document has an external subset defined it can be removed from the
document by using this function. The removed dtd node will be returned.
.IP "removeInternalSubset" 4
.IX Item "removeInternalSubset"
.Vb 1
\&  my $dtd = $doc\->removeInternalSubset();
.Ve
.Sp
\&\fI\s-1EXPERIMENTAL\s0!\fR
.Sp
If a document has an internal subset defined it can be removed from the
document by using this function. The removed dtd node will be returned.
.IP "getElementsByTagName" 4
.IX Item "getElementsByTagName"
.Vb 1
\&  my @nodelist = $doc\->getElementsByTagName($tagname);
.Ve
.Sp
Implements the \s-1DOM\s0 Level 2 function
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByTagNameNS" 4
.IX Item "getElementsByTagNameNS"
.Vb 1
\&  my @nodelist = $doc\->getElementsByTagNameNS($nsURI,$tagname);
.Ve
.Sp
Implements the \s-1DOM\s0 Level 2 function
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByLocalName" 4
.IX Item "getElementsByLocalName"
.Vb 1
\&  my @nodelist = $doc\->getElementsByLocalName($localname);
.Ve
.Sp
This allows the fetching of all nodes from a given document with the given
Localname.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementById" 4
.IX Item "getElementById"
.Vb 1
\&  my $node = $doc\->getElementById($id);
.Ve
.Sp
Returns the element that has an \s-1ID\s0 attribute with the given value. If no such
element exists, this returns undef.
.Sp
Note: the \s-1ID\s0 of an element may change while manipulating the document. For
documents with a \s-1DTD,\s0 the information about \s-1ID\s0 attributes is only available if
\&\s-1DTD\s0 loading/validation has been requested. For \s-1HTML\s0 documents parsed with the
\&\s-1HTML\s0 parser \s-1ID\s0 detection is done automatically. In \s-1XML\s0 documents, all \*(L"xml:id\*(R"
attributes are considered to be of type \s-1ID.\s0 You can test ID-ness of an
attribute node with \f(CW$attr\fR\->\fIisId()\fR.
.Sp
In versions 1.59 and earlier this method was called \fIgetElementsById()\fR (plural)
by mistake. Starting from 1.60 this name is maintained as an alias only for
backward compatibility.
.IP "indexElements" 4
.IX Item "indexElements"
.Vb 1
\&  $dom\->indexElements();
.Ve
.Sp
This function causes libxml2 to stamp all elements in a document with their
document position index which considerably speeds up XPath queries for large
documents. It should only be used with static documents that won't be further
changed by any \s-1DOM\s0 methods, because once a document is indexed, XPath will
always prefer the index to other methods of determining the document order of
nodes. XPath could therefore return improperly ordered node-lists when applied
on a document that has been changed after being indexed. It is of course
possible to use this method to re-index a modified document before using it
with XPath again. This function is not a part of the \s-1DOM\s0 specification.
.Sp
This function returns number of elements indexed, \-1 if error occurred, or \-2
if this feature is not available in the running libxml2.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::DocumentFragment.3pm            0100644 0001750 0001750 00000011574 12566241670 026515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::DocumentFragment 3"
.TH XML::LibXML::DocumentFragment 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::DocumentFragment \- XML::LibXML's DOM L2 Document Fragment Implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a helper class as described in the \s-1DOM\s0 Level 2 Specification. It
is implemented as a node without name. All adding, inserting or replacing
functions are aware of document fragments now.
.PP
As well \fIall\fR unbound nodes (all nodes that do not belong to any document sub-tree) are
implicit members of document fragments.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::DocumentFragment5.16.3pm        0100644 0001750 0001750 00000011033 12566241665 027021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::DocumentFragment 3"
.TH XML::LibXML::DocumentFragment 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::DocumentFragment \- XML::LibXML's DOM L2 Document Fragment Implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a helper class as described in the \s-1DOM\s0 Level 2 Specification. It
is implemented as a node without name. All adding, inserting or replacing
functions are aware of document fragments now.
.PP
As well \fIall\fR unbound nodes (all nodes that do not belong to any document sub-tree) are
implicit members of document fragments.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::DocumentFragment5.18.3pm        0100644 0001750 0001750 00000011574 12566241670 027031  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::DocumentFragment 3"
.TH XML::LibXML::DocumentFragment 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::DocumentFragment \- XML::LibXML's DOM L2 Document Fragment Implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a helper class as described in the \s-1DOM\s0 Level 2 Specification. It
is implemented as a node without name. All adding, inserting or replacing
functions are aware of document fragments now.
.PP
As well \fIall\fR unbound nodes (all nodes that do not belong to any document sub-tree) are
implicit members of document fragments.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Dtd.3pm                         0100644 0001750 0001750 00000014540 12566241670 023762  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Dtd 3"
.TH XML::LibXML::Dtd 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Dtd \- XML::LibXML DTD Handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
\&
\&  $dtd = XML::LibXML::Dtd\->new($public_id, $system_id);
\&  $dtd = XML::LibXML::Dtd\->parse_string($dtd_str);
\&  $publicId = $dtd\->getName();
\&  $publicId = $dtd\->publicId();
\&  $systemId = $dtd\->systemId();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class holds a \s-1DTD.\s0 You may parse a \s-1DTD\s0 from either a string, or from an
external \s-1SYSTEM\s0 identifier.
.PP
No support is available as yet for parsing from a filehandle.
.PP
XML::LibXML::Dtd is a sub-class of XML::LibXML::Node, so all the methods available to nodes (particularly \fItoString()\fR) are available
to Dtd objects.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $dtd = XML::LibXML::Dtd\->new($public_id, $system_id);
.Ve
.Sp
Parse a \s-1DTD\s0 from the system identifier, and return a \s-1DTD\s0 object that you can
pass to \f(CW$doc\fR\->\fIis_valid()\fR or \f(CW$doc\fR\->\fIvalidate()\fR.
.Sp
.Vb 6
\&  my $dtd = XML::LibXML::Dtd\->new(
\&                        "SOME // Public / ID / 1.0",
\&                        "test.dtd"
\&                                  );
\&   my $doc = XML::LibXML\->new\->parse_file("test.xml");
\&   $doc\->validate($dtd);
.Ve
.IP "parse_string" 4
.IX Item "parse_string"
.Vb 1
\&  $dtd = XML::LibXML::Dtd\->parse_string($dtd_str);
.Ve
.Sp
The same as \fInew()\fR above, except you can parse a \s-1DTD\s0 from a string. Note that
parsing from string may fail if the \s-1DTD\s0 contains external parametric-entity
references with relative URLs.
.IP "getName" 4
.IX Item "getName"
.Vb 1
\&  $publicId = $dtd\->getName();
.Ve
.Sp
Returns the name of \s-1DTD\s0; i.e., the name immediately following the \s-1DOCTYPE\s0
keyword.
.IP "publicId" 4
.IX Item "publicId"
.Vb 1
\&  $publicId = $dtd\->publicId();
.Ve
.Sp
Returns the public identifier of the external subset.
.IP "systemId" 4
.IX Item "systemId"
.Vb 1
\&  $systemId = $dtd\->systemId();
.Ve
.Sp
Returns the system identifier of the external subset.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Dtd5.16.3pm                     0100644 0001750 0001750 00000013777 12566241665 024313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Dtd 3"
.TH XML::LibXML::Dtd 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Dtd \- XML::LibXML DTD Handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
\&
\&  $dtd = XML::LibXML::Dtd\->new($public_id, $system_id);
\&  $dtd = XML::LibXML::Dtd\->parse_string($dtd_str);
\&  $publicId = $dtd\->getName();
\&  $publicId = $dtd\->publicId();
\&  $systemId = $dtd\->systemId();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class holds a \s-1DTD\s0. You may parse a \s-1DTD\s0 from either a string, or from an
external \s-1SYSTEM\s0 identifier.
.PP
No support is available as yet for parsing from a filehandle.
.PP
XML::LibXML::Dtd is a sub-class of XML::LibXML::Node, so all the methods available to nodes (particularly \fItoString()\fR) are available
to Dtd objects.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $dtd = XML::LibXML::Dtd\->new($public_id, $system_id);
.Ve
.Sp
Parse a \s-1DTD\s0 from the system identifier, and return a \s-1DTD\s0 object that you can
pass to \f(CW$doc\fR\->\fIis_valid()\fR or \f(CW$doc\fR\->\fIvalidate()\fR.
.Sp
.Vb 6
\&  my $dtd = XML::LibXML::Dtd\->new(
\&                        "SOME // Public / ID / 1.0",
\&                        "test.dtd"
\&                                  );
\&   my $doc = XML::LibXML\->new\->parse_file("test.xml");
\&   $doc\->validate($dtd);
.Ve
.IP "parse_string" 4
.IX Item "parse_string"
.Vb 1
\&  $dtd = XML::LibXML::Dtd\->parse_string($dtd_str);
.Ve
.Sp
The same as \fInew()\fR above, except you can parse a \s-1DTD\s0 from a string. Note that
parsing from string may fail if the \s-1DTD\s0 contains external parametric-entity
references with relative URLs.
.IP "getName" 4
.IX Item "getName"
.Vb 1
\&  $publicId = $dtd\->getName();
.Ve
.Sp
Returns the name of \s-1DTD\s0; i.e., the name immediately following the \s-1DOCTYPE\s0
keyword.
.IP "publicId" 4
.IX Item "publicId"
.Vb 1
\&  $publicId = $dtd\->publicId();
.Ve
.Sp
Returns the public identifier of the external subset.
.IP "systemId" 4
.IX Item "systemId"
.Vb 1
\&  $systemId = $dtd\->systemId();
.Ve
.Sp
Returns the system identifier of the external subset.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Dtd5.18.3pm                     0100644 0001750 0001750 00000014540 12566241670 024276  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Dtd 3"
.TH XML::LibXML::Dtd 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Dtd \- XML::LibXML DTD Handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
\&
\&  $dtd = XML::LibXML::Dtd\->new($public_id, $system_id);
\&  $dtd = XML::LibXML::Dtd\->parse_string($dtd_str);
\&  $publicId = $dtd\->getName();
\&  $publicId = $dtd\->publicId();
\&  $systemId = $dtd\->systemId();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class holds a \s-1DTD.\s0 You may parse a \s-1DTD\s0 from either a string, or from an
external \s-1SYSTEM\s0 identifier.
.PP
No support is available as yet for parsing from a filehandle.
.PP
XML::LibXML::Dtd is a sub-class of XML::LibXML::Node, so all the methods available to nodes (particularly \fItoString()\fR) are available
to Dtd objects.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $dtd = XML::LibXML::Dtd\->new($public_id, $system_id);
.Ve
.Sp
Parse a \s-1DTD\s0 from the system identifier, and return a \s-1DTD\s0 object that you can
pass to \f(CW$doc\fR\->\fIis_valid()\fR or \f(CW$doc\fR\->\fIvalidate()\fR.
.Sp
.Vb 6
\&  my $dtd = XML::LibXML::Dtd\->new(
\&                        "SOME // Public / ID / 1.0",
\&                        "test.dtd"
\&                                  );
\&   my $doc = XML::LibXML\->new\->parse_file("test.xml");
\&   $doc\->validate($dtd);
.Ve
.IP "parse_string" 4
.IX Item "parse_string"
.Vb 1
\&  $dtd = XML::LibXML::Dtd\->parse_string($dtd_str);
.Ve
.Sp
The same as \fInew()\fR above, except you can parse a \s-1DTD\s0 from a string. Note that
parsing from string may fail if the \s-1DTD\s0 contains external parametric-entity
references with relative URLs.
.IP "getName" 4
.IX Item "getName"
.Vb 1
\&  $publicId = $dtd\->getName();
.Ve
.Sp
Returns the name of \s-1DTD\s0; i.e., the name immediately following the \s-1DOCTYPE\s0
keyword.
.IP "publicId" 4
.IX Item "publicId"
.Vb 1
\&  $publicId = $dtd\->publicId();
.Ve
.Sp
Returns the public identifier of the external subset.
.IP "systemId" 4
.IX Item "systemId"
.Vb 1
\&  $systemId = $dtd\->systemId();
.Ve
.Sp
Returns the system identifier of the external subset.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Element.3pm                     0100644 0001750 0001750 00000046043 12566241670 024643  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Element 3"
.TH XML::LibXML::Element 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Element \- XML::LibXML Class for Element Nodes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Element nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::Element\->new( $name );
\&  $node\->setAttribute( $aname, $avalue );
\&  $node\->setAttributeNS( $nsURI, $aname, $avalue );
\&  $avalue = $node\->getAttribute( $aname );
\&  $avalue = $node\->getAttributeNS( $nsURI, $aname );
\&  $attrnode = $node\->getAttributeNode( $aname );
\&  $attrnode = $node\->getAttributeNodeNS( $namespaceURI, $aname );
\&  $node\->removeAttribute( $aname );
\&  $node\->removeAttributeNS( $nsURI, $aname );
\&  $boolean = $node\->hasAttribute( $aname );
\&  $boolean = $node\->hasAttributeNS( $nsURI, $aname );
\&  @nodes = $node\->getChildrenByTagName($tagname);
\&  @nodes = $node\->getChildrenByTagNameNS($nsURI,$tagname);
\&  @nodes = $node\->getChildrenByLocalName($localname);
\&  @nodes = $node\->getElementsByTagName($tagname);
\&  @nodes = $node\->getElementsByTagNameNS($nsURI,$localname);
\&  @nodes = $node\->getElementsByLocalName($localname);
\&  $node\->appendWellBalancedChunk( $chunk );
\&  $node\->appendText( $PCDATA );
\&  $node\->appendTextNode( $PCDATA );
\&  $node\->appendTextChild( $childname , $PCDATA );
\&  $node\->setNamespace( $nsURI , $nsPrefix, $activate );
\&  $node\->setNamespaceDeclURI( $nsPrefix, $newURI );
\&  $node\->setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
.Ve
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::Element\->new( $name );
.Ve
.Sp
This function creates a new node unbound to any \s-1DOM.\s0
.IP "setAttribute" 4
.IX Item "setAttribute"
.Vb 1
\&  $node\->setAttribute( $aname, $avalue );
.Ve
.Sp
This method sets or replaces the node's attribute \f(CW$aname\fR to the value \f(CW$avalue\fR
.IP "setAttributeNS" 4
.IX Item "setAttributeNS"
.Vb 1
\&  $node\->setAttributeNS( $nsURI, $aname, $avalue );
.Ve
.Sp
Namespace-aware version of \f(CW\*(C`setAttribute\*(C'\fR, where \f(CW$nsURI\fR is a namespace \s-1URI, \s0\f(CW$aname\fR is a qualified name, and \f(CW$avalue\fR is the value. The namespace \s-1URI\s0 may be null (empty or undefined) in order to
create an attribute which has no namespace.
.Sp
The current implementation differs from \s-1DOM\s0 in the following aspects
.Sp
If an attribute with the same local name and namespace \s-1URI\s0 already exists on
the element, but its prefix differs from the prefix of \f(CW$aname\fR, then this function is supposed to change the prefix (regardless of namespace
declarations and possible collisions). However, the current implementation does
rather the opposite. If a prefix is declared for the namespace \s-1URI\s0 in the scope
of the attribute, then the already declared prefix is used, disregarding the
prefix specified in \f(CW$aname\fR. If no prefix is declared for the namespace, the function tries to declare the
prefix specified in \f(CW$aname\fR and dies if the prefix is already taken by some other namespace.
.Sp
According to \s-1DOM\s0 Level 2 specification, this method can also be used to create
or modify special attributes used for declaring \s-1XML\s0 namespaces (which belong to
the namespace \*(L"http://www.w3.org/2000/xmlns/\*(R" and have prefix or name \*(L"xmlns\*(R").
This should work since version 1.61, but again the implementation differs from
\&\s-1DOM\s0 specification in the following: if a declaration of the same namespace
prefix already exists on the element, then changing its value via this method
automatically changes the namespace of all elements and attributes in its
scope. This is because in libxml2 the namespace \s-1URI\s0 of an element is not static
but is computed from a pointer to a namespace declaration attribute.
.IP "getAttribute" 4
.IX Item "getAttribute"
.Vb 1
\&  $avalue = $node\->getAttribute( $aname );
.Ve
.Sp
If \f(CW$node\fR has an attribute with the name \f(CW$aname\fR, the value of this attribute will get returned.
.IP "getAttributeNS" 4
.IX Item "getAttributeNS"
.Vb 1
\&  $avalue = $node\->getAttributeNS( $nsURI, $aname );
.Ve
.Sp
Retrieves an attribute value by local name and namespace \s-1URI.\s0
.IP "getAttributeNode" 4
.IX Item "getAttributeNode"
.Vb 1
\&  $attrnode = $node\->getAttributeNode( $aname );
.Ve
.Sp
Retrieve an attribute node by name. If no attribute with a given name exists, \f(CW\*(C`undef\*(C'\fR is returned.
.IP "getAttributeNodeNS" 4
.IX Item "getAttributeNodeNS"
.Vb 1
\&  $attrnode = $node\->getAttributeNodeNS( $namespaceURI, $aname );
.Ve
.Sp
Retrieves an attribute node by local name and namespace \s-1URI.\s0 If no attribute
with a given localname and namespace exists, \f(CW\*(C`undef\*(C'\fR is returned.
.IP "removeAttribute" 4
.IX Item "removeAttribute"
.Vb 1
\&  $node\->removeAttribute( $aname );
.Ve
.Sp
The method removes the attribute \f(CW$aname\fR from the node's attribute list, if the attribute can be found.
.IP "removeAttributeNS" 4
.IX Item "removeAttributeNS"
.Vb 1
\&  $node\->removeAttributeNS( $nsURI, $aname );
.Ve
.Sp
Namespace version of \f(CW\*(C`removeAttribute\*(C'\fR
.IP "hasAttribute" 4
.IX Item "hasAttribute"
.Vb 1
\&  $boolean = $node\->hasAttribute( $aname );
.Ve
.Sp
This function tests if the named attribute is set for the node. If the
attribute is specified, \s-1TRUE \\fIs0\fR\|(1) will be returned, otherwise the return value
is \s-1FALSE \\fIs0\fR\|(0).
.IP "hasAttributeNS" 4
.IX Item "hasAttributeNS"
.Vb 1
\&  $boolean = $node\->hasAttributeNS( $nsURI, $aname );
.Ve
.Sp
namespace version of \f(CW\*(C`hasAttribute\*(C'\fR
.IP "getChildrenByTagName" 4
.IX Item "getChildrenByTagName"
.Vb 1
\&  @nodes = $node\->getChildrenByTagName($tagname);
.Ve
.Sp
The function gives direct access to all child elements of the current node with
a given tagname, where tagname is a qualified name, that is, in case of
namespace usage it may consist of a prefix and local name. This function makes
things a lot easier if one needs to handle big data sets. A special tagname '*'
can be used to match any name.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getChildrenByTagNameNS" 4
.IX Item "getChildrenByTagNameNS"
.Vb 1
\&  @nodes = $node\->getChildrenByTagNameNS($nsURI,$tagname);
.Ve
.Sp
Namespace version of \f(CW\*(C`getChildrenByTagName\*(C'\fR. A special nsURI '*' matches any namespace \s-1URI,\s0 in which case the function
behaves just like \f(CW\*(C`getChildrenByLocalName\*(C'\fR.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getChildrenByLocalName" 4
.IX Item "getChildrenByLocalName"
.Vb 1
\&  @nodes = $node\->getChildrenByLocalName($localname);
.Ve
.Sp
The function gives direct access to all child elements of the current node with
a given local name. It makes things a lot easier if one needs to handle big
data sets. A special \f(CW\*(C`localname\*(C'\fR '*' can be used to match any local name.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getElementsByTagName" 4
.IX Item "getElementsByTagName"
.Vb 1
\&  @nodes = $node\->getElementsByTagName($tagname);
.Ve
.Sp
This function is part of the spec. It fetches all descendants of a node with a
given tagname, where \f(CW\*(C`tagname\*(C'\fR is a qualified name, that is, in case of namespace usage it may consist of a
prefix and local name. A special \f(CW\*(C`tagname\*(C'\fR '*' can be used to match any tag name.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByTagNameNS" 4
.IX Item "getElementsByTagNameNS"
.Vb 1
\&  @nodes = $node\->getElementsByTagNameNS($nsURI,$localname);
.Ve
.Sp
Namespace version of \f(CW\*(C`getElementsByTagName\*(C'\fR as found in the \s-1DOM\s0 spec. A special \f(CW\*(C`localname\*(C'\fR '*' can be used to match any local name and \f(CW\*(C`nsURI\*(C'\fR '*' can be used to match any namespace \s-1URI.\s0
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByLocalName" 4
.IX Item "getElementsByLocalName"
.Vb 1
\&  @nodes = $node\->getElementsByLocalName($localname);
.Ve
.Sp
This function is not found in the \s-1DOM\s0 specification. It is a mix of
getElementsByTagName and getElementsByTagNameNS. It will fetch all tags
matching the given local-name. This allows one to select tags with the same
local name across namespace borders.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "appendWellBalancedChunk" 4
.IX Item "appendWellBalancedChunk"
.Vb 1
\&  $node\->appendWellBalancedChunk( $chunk );
.Ve
.Sp
Sometimes it is necessary to append a string coded \s-1XML\s0 Tree to a node. \fIappendWellBalancedChunk\fR will do the trick for you. But this is only done if the String is \f(CW\*(C`well\-balanced\*(C'\fR.
.Sp
\&\fINote that \fIappendWellBalancedChunk()\fI is only left for compatibility reasons\fR. Implicitly it uses
.Sp
.Vb 2
\&  my $fragment = $parser\->parse_balanced_chunk( $chunk );
\&   $node\->appendChild( $fragment );
.Ve
.Sp
This form is more explicit and makes it easier to control the flow of a script.
.IP "appendText" 4
.IX Item "appendText"
.Vb 1
\&  $node\->appendText( $PCDATA );
.Ve
.Sp
alias for \fIappendTextNode()\fR.
.IP "appendTextNode" 4
.IX Item "appendTextNode"
.Vb 1
\&  $node\->appendTextNode( $PCDATA );
.Ve
.Sp
This wrapper function lets you add a string directly to an element node.
.IP "appendTextChild" 4
.IX Item "appendTextChild"
.Vb 1
\&  $node\->appendTextChild( $childname , $PCDATA );
.Ve
.Sp
Somewhat similar with \f(CW\*(C`appendTextNode\*(C'\fR: It lets you set an Element, that contains only a \f(CW\*(C`text node\*(C'\fR directly by specifying the name and the text content.
.IP "setNamespace" 4
.IX Item "setNamespace"
.Vb 1
\&  $node\->setNamespace( $nsURI , $nsPrefix, $activate );
.Ve
.Sp
\&\fIsetNamespace()\fR allows one to apply a namespace to an element. The function
takes three parameters: 1. the namespace \s-1URI,\s0 which is required and the two
optional values prefix, which is the namespace prefix, as it should be used in
child elements or attributes as well as the additional activate parameter. If
prefix is not given, undefined or empty, this function tries to create a
declaration of the default namespace.
.Sp
The activate parameter is most useful: If this parameter is set to \s-1FALSE \\fIs0\fR\|(0), a
new namespace declaration is simply added to the element while the element's
namespace itself is not altered. Nevertheless, activate is set to \s-1TRUE \\fIs0\fR\|(1) on
default. In this case the namespace is used as the node's effective namespace.
This means the namespace prefix is added to the node name and if there was a
namespace already active for the node, it will be replaced (but its declaration
is not removed from the document). A new namespace declaration is only created
if necessary (that is, if the element is already in the scope of a namespace
declaration associating the prefix with the namespace \s-1URI,\s0 then this
declaration is reused).
.Sp
The following example may clarify this:
.Sp
.Vb 2
\&  my $e1 = $doc\->createElement("bar");
\&   $e1\->setNamespace("http://foobar.org", "foo")
.Ve
.Sp
results
.Sp
.Vb 1
\&  <foo:bar xmlns:foo="http://foobar.org"/>
.Ve
.Sp
while
.Sp
.Vb 2
\&  my $e2 = $doc\->createElement("bar");
\&   $e2\->setNamespace("http://foobar.org", "foo",0)
.Ve
.Sp
results only
.Sp
.Vb 1
\&  <bar xmlns:foo="http://foobar.org"/>
.Ve
.Sp
By using \f(CW$activate\fR == 0 it is possible to create multiple namespace
declarations on a single element.
.Sp
The function fails if it is required to create a declaration associating the
prefix with the namespace \s-1URI\s0 but the element already carries a declaration
with the same prefix but different namespace \s-1URI.\s0
.IP "setNamespaceDeclURI" 4
.IX Item "setNamespaceDeclURI"
.Vb 1
\&  $node\->setNamespaceDeclURI( $nsPrefix, $newURI );
.Ve
.Sp
\&\s-1EXPERIMENTAL IN 1.61 \s0!
.Sp
This function manipulates directly with an existing namespace declaration on an
element. It takes two parameters: the prefix by which it looks up the namespace
declaration and a new namespace \s-1URI\s0 which replaces its previous value.
.Sp
It returns 1 if the namespace declaration was found and changed, 0 otherwise.
.Sp
All elements and attributes (even those previously unbound from the document)
for which the namespace declaration determines their namespace belong to the
new namespace after the change.
.Sp
If the new \s-1URI\s0 is undef or empty, the nodes have no namespace and no prefix
after the change. Namespace declarations once nulled in this way do not further
appear in the serialized output (but do remain in the document for internal
integrity of libxml2 data structures).
.Sp
This function is \s-1NOT\s0 part of any \s-1DOM API.\s0
.IP "setNamespaceDeclPrefix" 4
.IX Item "setNamespaceDeclPrefix"
.Vb 1
\&  $node\->setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
.Ve
.Sp
\&\s-1EXPERIMENTAL IN 1.61 \s0!
.Sp
This function manipulates directly with an existing namespace declaration on an
element. It takes two parameters: the old prefix by which it looks up the
namespace declaration and a new prefix which is to replace the old one.
.Sp
The function dies with an error if the element is in the scope of another
declaration whose prefix equals to the new prefix, or if the change should
result in a declaration with a non-empty prefix but empty namespace \s-1URI.\s0
Otherwise, it returns 1 if the namespace declaration was found and changed and
0 if not found.
.Sp
All elements and attributes (even those previously unbound from the document)
for which the namespace declaration determines their namespace change their
prefix to the new value.
.Sp
If the new prefix is undef or empty, the namespace declaration becomes a
declaration of a default namespace. The corresponding nodes drop their
namespace prefix (but remain in the, now default, namespace). In this case the
function fails, if the containing element is in the scope of another default
namespace declaration.
.Sp
This function is \s-1NOT\s0 part of any \s-1DOM API.\s0
.SH "OVERLOADING"
.IX Header "OVERLOADING"
XML::LibXML::Element overloads hash dereferencing to provide access to the
element's attributes. For non-namespaced attributes, the attribute name is the
hash key, and the attribute value is the hash value. For namespaced attributes,
the hash key is qualified with the namespace \s-1URI,\s0 using Clark notation.
.PP
Perl's \*(L"tied hash\*(R" feature is used, which means that the hash gives you
read-write access to the element's attributes. For more information, see XML::LibXML::AttributeHash
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Element5.16.3pm                 0100644 0001750 0001750 00000045345 12566241665 025165  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Element 3"
.TH XML::LibXML::Element 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Element \- XML::LibXML Class for Element Nodes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Element nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::Element\->new( $name );
\&  $node\->setAttribute( $aname, $avalue );
\&  $node\->setAttributeNS( $nsURI, $aname, $avalue );
\&  $avalue = $node\->getAttribute( $aname );
\&  $avalue = $node\->getAttributeNS( $nsURI, $aname );
\&  $attrnode = $node\->getAttributeNode( $aname );
\&  $attrnode = $node\->getAttributeNodeNS( $namespaceURI, $aname );
\&  $node\->removeAttribute( $aname );
\&  $node\->removeAttributeNS( $nsURI, $aname );
\&  $boolean = $node\->hasAttribute( $aname );
\&  $boolean = $node\->hasAttributeNS( $nsURI, $aname );
\&  @nodes = $node\->getChildrenByTagName($tagname);
\&  @nodes = $node\->getChildrenByTagNameNS($nsURI,$tagname);
\&  @nodes = $node\->getChildrenByLocalName($localname);
\&  @nodes = $node\->getElementsByTagName($tagname);
\&  @nodes = $node\->getElementsByTagNameNS($nsURI,$localname);
\&  @nodes = $node\->getElementsByLocalName($localname);
\&  $node\->appendWellBalancedChunk( $chunk );
\&  $node\->appendText( $PCDATA );
\&  $node\->appendTextNode( $PCDATA );
\&  $node\->appendTextChild( $childname , $PCDATA );
\&  $node\->setNamespace( $nsURI , $nsPrefix, $activate );
\&  $node\->setNamespaceDeclURI( $nsPrefix, $newURI );
\&  $node\->setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
.Ve
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (http://www.w3.org/TR/DOM\-Level\-3\-Core/ <http://www.w3.org/TR/DOM-Level-3-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::Element\->new( $name );
.Ve
.Sp
This function creates a new node unbound to any \s-1DOM\s0.
.IP "setAttribute" 4
.IX Item "setAttribute"
.Vb 1
\&  $node\->setAttribute( $aname, $avalue );
.Ve
.Sp
This method sets or replaces the node's attribute \f(CW$aname\fR to the value \f(CW$avalue\fR
.IP "setAttributeNS" 4
.IX Item "setAttributeNS"
.Vb 1
\&  $node\->setAttributeNS( $nsURI, $aname, $avalue );
.Ve
.Sp
Namespace-aware version of \f(CW\*(C`setAttribute\*(C'\fR, where \f(CW$nsURI\fR is a namespace \s-1URI\s0, \f(CW$aname\fR is a qualified name, and \f(CW$avalue\fR is the value. The namespace \s-1URI\s0 may be null (empty or undefined) in order to
create an attribute which has no namespace.
.Sp
The current implementation differs from \s-1DOM\s0 in the following aspects
.Sp
If an attribute with the same local name and namespace \s-1URI\s0 already exists on
the element, but its prefix differs from the prefix of \f(CW$aname\fR, then this function is supposed to change the prefix (regardless of namespace
declarations and possible collisions). However, the current implementation does
rather the opposite. If a prefix is declared for the namespace \s-1URI\s0 in the scope
of the attribute, then the already declared prefix is used, disregarding the
prefix specified in \f(CW$aname\fR. If no prefix is declared for the namespace, the function tries to declare the
prefix specified in \f(CW$aname\fR and dies if the prefix is already taken by some other namespace.
.Sp
According to \s-1DOM\s0 Level 2 specification, this method can also be used to create
or modify special attributes used for declaring \s-1XML\s0 namespaces (which belong to
the namespace \*(L"http://www.w3.org/2000/xmlns/\*(R" and have prefix or name \*(L"xmlns\*(R").
This should work since version 1.61, but again the implementation differs from
\&\s-1DOM\s0 specification in the following: if a declaration of the same namespace
prefix already exists on the element, then changing its value via this method
automatically changes the namespace of all elements and attributes in its
scope. This is because in libxml2 the namespace \s-1URI\s0 of an element is not static
but is computed from a pointer to a namespace declaration attribute.
.IP "getAttribute" 4
.IX Item "getAttribute"
.Vb 1
\&  $avalue = $node\->getAttribute( $aname );
.Ve
.Sp
If \f(CW$node\fR has an attribute with the name \f(CW$aname\fR, the value of this attribute will get returned.
.IP "getAttributeNS" 4
.IX Item "getAttributeNS"
.Vb 1
\&  $avalue = $node\->getAttributeNS( $nsURI, $aname );
.Ve
.Sp
Retrieves an attribute value by local name and namespace \s-1URI\s0.
.IP "getAttributeNode" 4
.IX Item "getAttributeNode"
.Vb 1
\&  $attrnode = $node\->getAttributeNode( $aname );
.Ve
.Sp
Retrieve an attribute node by name. If no attribute with a given name exists, \f(CW\*(C`undef\*(C'\fR is returned.
.IP "getAttributeNodeNS" 4
.IX Item "getAttributeNodeNS"
.Vb 1
\&  $attrnode = $node\->getAttributeNodeNS( $namespaceURI, $aname );
.Ve
.Sp
Retrieves an attribute node by local name and namespace \s-1URI\s0. If no attribute
with a given localname and namespace exists, \f(CW\*(C`undef\*(C'\fR is returned.
.IP "removeAttribute" 4
.IX Item "removeAttribute"
.Vb 1
\&  $node\->removeAttribute( $aname );
.Ve
.Sp
The method removes the attribute \f(CW$aname\fR from the node's attribute list, if the attribute can be found.
.IP "removeAttributeNS" 4
.IX Item "removeAttributeNS"
.Vb 1
\&  $node\->removeAttributeNS( $nsURI, $aname );
.Ve
.Sp
Namespace version of \f(CW\*(C`removeAttribute\*(C'\fR
.IP "hasAttribute" 4
.IX Item "hasAttribute"
.Vb 1
\&  $boolean = $node\->hasAttribute( $aname );
.Ve
.Sp
This function tests if the named attribute is set for the node. If the
attribute is specified, \s-1TRUE\s0 (1) will be returned, otherwise the return value
is \s-1FALSE\s0 (0).
.IP "hasAttributeNS" 4
.IX Item "hasAttributeNS"
.Vb 1
\&  $boolean = $node\->hasAttributeNS( $nsURI, $aname );
.Ve
.Sp
namespace version of \f(CW\*(C`hasAttribute\*(C'\fR
.IP "getChildrenByTagName" 4
.IX Item "getChildrenByTagName"
.Vb 1
\&  @nodes = $node\->getChildrenByTagName($tagname);
.Ve
.Sp
The function gives direct access to all child elements of the current node with
a given tagname, where tagname is a qualified name, that is, in case of
namespace usage it may consist of a prefix and local name. This function makes
things a lot easier if one needs to handle big data sets. A special tagname '*'
can be used to match any name.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getChildrenByTagNameNS" 4
.IX Item "getChildrenByTagNameNS"
.Vb 1
\&  @nodes = $node\->getChildrenByTagNameNS($nsURI,$tagname);
.Ve
.Sp
Namespace version of \f(CW\*(C`getChildrenByTagName\*(C'\fR. A special nsURI '*' matches any namespace \s-1URI\s0, in which case the function
behaves just like \f(CW\*(C`getChildrenByLocalName\*(C'\fR.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getChildrenByLocalName" 4
.IX Item "getChildrenByLocalName"
.Vb 1
\&  @nodes = $node\->getChildrenByLocalName($localname);
.Ve
.Sp
The function gives direct access to all child elements of the current node with
a given local name. It makes things a lot easier if one needs to handle big
data sets. A special \f(CW\*(C`localname\*(C'\fR '*' can be used to match any local name.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getElementsByTagName" 4
.IX Item "getElementsByTagName"
.Vb 1
\&  @nodes = $node\->getElementsByTagName($tagname);
.Ve
.Sp
This function is part of the spec. It fetches all descendants of a node with a
given tagname, where \f(CW\*(C`tagname\*(C'\fR is a qualified name, that is, in case of namespace usage it may consist of a
prefix and local name. A special \f(CW\*(C`tagname\*(C'\fR '*' can be used to match any tag name.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByTagNameNS" 4
.IX Item "getElementsByTagNameNS"
.Vb 1
\&  @nodes = $node\->getElementsByTagNameNS($nsURI,$localname);
.Ve
.Sp
Namespace version of \f(CW\*(C`getElementsByTagName\*(C'\fR as found in the \s-1DOM\s0 spec. A special \f(CW\*(C`localname\*(C'\fR '*' can be used to match any local name and \f(CW\*(C`nsURI\*(C'\fR '*' can be used to match any namespace \s-1URI\s0.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByLocalName" 4
.IX Item "getElementsByLocalName"
.Vb 1
\&  @nodes = $node\->getElementsByLocalName($localname);
.Ve
.Sp
This function is not found in the \s-1DOM\s0 specification. It is a mix of
getElementsByTagName and getElementsByTagNameNS. It will fetch all tags
matching the given local-name. This allows one to select tags with the same
local name across namespace borders.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "appendWellBalancedChunk" 4
.IX Item "appendWellBalancedChunk"
.Vb 1
\&  $node\->appendWellBalancedChunk( $chunk );
.Ve
.Sp
Sometimes it is necessary to append a string coded \s-1XML\s0 Tree to a node. \fIappendWellBalancedChunk\fR will do the trick for you. But this is only done if the String is \f(CW\*(C`well\-balanced\*(C'\fR.
.Sp
\&\fINote that \fIappendWellBalancedChunk()\fI is only left for compatibility reasons\fR. Implicitly it uses
.Sp
.Vb 2
\&  my $fragment = $parser\->parse_balanced_chunk( $chunk );
\&   $node\->appendChild( $fragment );
.Ve
.Sp
This form is more explicit and makes it easier to control the flow of a script.
.IP "appendText" 4
.IX Item "appendText"
.Vb 1
\&  $node\->appendText( $PCDATA );
.Ve
.Sp
alias for \fIappendTextNode()\fR.
.IP "appendTextNode" 4
.IX Item "appendTextNode"
.Vb 1
\&  $node\->appendTextNode( $PCDATA );
.Ve
.Sp
This wrapper function lets you add a string directly to an element node.
.IP "appendTextChild" 4
.IX Item "appendTextChild"
.Vb 1
\&  $node\->appendTextChild( $childname , $PCDATA );
.Ve
.Sp
Somewhat similar with \f(CW\*(C`appendTextNode\*(C'\fR: It lets you set an Element, that contains only a \f(CW\*(C`text node\*(C'\fR directly by specifying the name and the text content.
.IP "setNamespace" 4
.IX Item "setNamespace"
.Vb 1
\&  $node\->setNamespace( $nsURI , $nsPrefix, $activate );
.Ve
.Sp
\&\fIsetNamespace()\fR allows one to apply a namespace to an element. The function
takes three parameters: 1. the namespace \s-1URI\s0, which is required and the two
optional values prefix, which is the namespace prefix, as it should be used in
child elements or attributes as well as the additional activate parameter. If
prefix is not given, undefined or empty, this function tries to create a
declaration of the default namespace.
.Sp
The activate parameter is most useful: If this parameter is set to \s-1FALSE\s0 (0), a
new namespace declaration is simply added to the element while the element's
namespace itself is not altered. Nevertheless, activate is set to \s-1TRUE\s0 (1) on
default. In this case the namespace is used as the node's effective namespace.
This means the namespace prefix is added to the node name and if there was a
namespace already active for the node, it will be replaced (but its declaration
is not removed from the document). A new namespace declaration is only created
if necessary (that is, if the element is already in the scope of a namespace
declaration associating the prefix with the namespace \s-1URI\s0, then this
declaration is reused).
.Sp
The following example may clarify this:
.Sp
.Vb 2
\&  my $e1 = $doc\->createElement("bar");
\&   $e1\->setNamespace("http://foobar.org", "foo")
.Ve
.Sp
results
.Sp
.Vb 1
\&  <foo:bar xmlns:foo="http://foobar.org"/>
.Ve
.Sp
while
.Sp
.Vb 2
\&  my $e2 = $doc\->createElement("bar");
\&   $e2\->setNamespace("http://foobar.org", "foo",0)
.Ve
.Sp
results only
.Sp
.Vb 1
\&  <bar xmlns:foo="http://foobar.org"/>
.Ve
.Sp
By using \f(CW$activate\fR == 0 it is possible to create multiple namespace
declarations on a single element.
.Sp
The function fails if it is required to create a declaration associating the
prefix with the namespace \s-1URI\s0 but the element already carries a declaration
with the same prefix but different namespace \s-1URI\s0.
.IP "setNamespaceDeclURI" 4
.IX Item "setNamespaceDeclURI"
.Vb 1
\&  $node\->setNamespaceDeclURI( $nsPrefix, $newURI );
.Ve
.Sp
\&\s-1EXPERIMENTAL\s0 \s-1IN\s0 1.61 !
.Sp
This function manipulates directly with an existing namespace declaration on an
element. It takes two parameters: the prefix by which it looks up the namespace
declaration and a new namespace \s-1URI\s0 which replaces its previous value.
.Sp
It returns 1 if the namespace declaration was found and changed, 0 otherwise.
.Sp
All elements and attributes (even those previously unbound from the document)
for which the namespace declaration determines their namespace belong to the
new namespace after the change.
.Sp
If the new \s-1URI\s0 is undef or empty, the nodes have no namespace and no prefix
after the change. Namespace declarations once nulled in this way do not further
appear in the serialized output (but do remain in the document for internal
integrity of libxml2 data structures).
.Sp
This function is \s-1NOT\s0 part of any \s-1DOM\s0 \s-1API\s0.
.IP "setNamespaceDeclPrefix" 4
.IX Item "setNamespaceDeclPrefix"
.Vb 1
\&  $node\->setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
.Ve
.Sp
\&\s-1EXPERIMENTAL\s0 \s-1IN\s0 1.61 !
.Sp
This function manipulates directly with an existing namespace declaration on an
element. It takes two parameters: the old prefix by which it looks up the
namespace declaration and a new prefix which is to replace the old one.
.Sp
The function dies with an error if the element is in the scope of another
declaration whose prefix equals to the new prefix, or if the change should
result in a declaration with a non-empty prefix but empty namespace \s-1URI\s0.
Otherwise, it returns 1 if the namespace declaration was found and changed and
0 if not found.
.Sp
All elements and attributes (even those previously unbound from the document)
for which the namespace declaration determines their namespace change their
prefix to the new value.
.Sp
If the new prefix is undef or empty, the namespace declaration becomes a
declaration of a default namespace. The corresponding nodes drop their
namespace prefix (but remain in the, now default, namespace). In this case the
function fails, if the containing element is in the scope of another default
namespace declaration.
.Sp
This function is \s-1NOT\s0 part of any \s-1DOM\s0 \s-1API\s0.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
XML::LibXML::Element overloads hash dereferencing to provide access to the
element's attributes. For non-namespaced attributes, the attribute name is the
hash key, and the attribute value is the hash value. For namespaced attributes,
the hash key is qualified with the namespace \s-1URI\s0, using Clark notation.
.PP
Perl's \*(L"tied hash\*(R" feature is used, which means that the hash gives you
read-write access to the element's attributes. For more information, see XML::LibXML::AttributeHash
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Element5.18.3pm                 0100644 0001750 0001750 00000046043 12566241670 025157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Element 3"
.TH XML::LibXML::Element 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Element \- XML::LibXML Class for Element Nodes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use XML::LibXML;
\&  # Only methods specific to Element nodes are listed here,
\&  # see XML::LibXML::Node manpage for other methods
\&
\&  $node = XML::LibXML::Element\->new( $name );
\&  $node\->setAttribute( $aname, $avalue );
\&  $node\->setAttributeNS( $nsURI, $aname, $avalue );
\&  $avalue = $node\->getAttribute( $aname );
\&  $avalue = $node\->getAttributeNS( $nsURI, $aname );
\&  $attrnode = $node\->getAttributeNode( $aname );
\&  $attrnode = $node\->getAttributeNodeNS( $namespaceURI, $aname );
\&  $node\->removeAttribute( $aname );
\&  $node\->removeAttributeNS( $nsURI, $aname );
\&  $boolean = $node\->hasAttribute( $aname );
\&  $boolean = $node\->hasAttributeNS( $nsURI, $aname );
\&  @nodes = $node\->getChildrenByTagName($tagname);
\&  @nodes = $node\->getChildrenByTagNameNS($nsURI,$tagname);
\&  @nodes = $node\->getChildrenByLocalName($localname);
\&  @nodes = $node\->getElementsByTagName($tagname);
\&  @nodes = $node\->getElementsByTagNameNS($nsURI,$localname);
\&  @nodes = $node\->getElementsByLocalName($localname);
\&  $node\->appendWellBalancedChunk( $chunk );
\&  $node\->appendText( $PCDATA );
\&  $node\->appendTextNode( $PCDATA );
\&  $node\->appendTextChild( $childname , $PCDATA );
\&  $node\->setNamespace( $nsURI , $nsPrefix, $activate );
\&  $node\->setNamespaceDeclURI( $nsPrefix, $newURI );
\&  $node\->setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
.Ve
.SH "METHODS"
.IX Header "METHODS"
The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.
.PP
Many functions listed here are extensively documented in the \s-1DOM\s0 Level 3 specification (<http://www.w3.org/TR/DOM\-Level\-3\-Core/>). Please refer to the specification for extensive documentation.
.IP "new" 4
.IX Item "new"
.Vb 1
\&  $node = XML::LibXML::Element\->new( $name );
.Ve
.Sp
This function creates a new node unbound to any \s-1DOM.\s0
.IP "setAttribute" 4
.IX Item "setAttribute"
.Vb 1
\&  $node\->setAttribute( $aname, $avalue );
.Ve
.Sp
This method sets or replaces the node's attribute \f(CW$aname\fR to the value \f(CW$avalue\fR
.IP "setAttributeNS" 4
.IX Item "setAttributeNS"
.Vb 1
\&  $node\->setAttributeNS( $nsURI, $aname, $avalue );
.Ve
.Sp
Namespace-aware version of \f(CW\*(C`setAttribute\*(C'\fR, where \f(CW$nsURI\fR is a namespace \s-1URI, \s0\f(CW$aname\fR is a qualified name, and \f(CW$avalue\fR is the value. The namespace \s-1URI\s0 may be null (empty or undefined) in order to
create an attribute which has no namespace.
.Sp
The current implementation differs from \s-1DOM\s0 in the following aspects
.Sp
If an attribute with the same local name and namespace \s-1URI\s0 already exists on
the element, but its prefix differs from the prefix of \f(CW$aname\fR, then this function is supposed to change the prefix (regardless of namespace
declarations and possible collisions). However, the current implementation does
rather the opposite. If a prefix is declared for the namespace \s-1URI\s0 in the scope
of the attribute, then the already declared prefix is used, disregarding the
prefix specified in \f(CW$aname\fR. If no prefix is declared for the namespace, the function tries to declare the
prefix specified in \f(CW$aname\fR and dies if the prefix is already taken by some other namespace.
.Sp
According to \s-1DOM\s0 Level 2 specification, this method can also be used to create
or modify special attributes used for declaring \s-1XML\s0 namespaces (which belong to
the namespace \*(L"http://www.w3.org/2000/xmlns/\*(R" and have prefix or name \*(L"xmlns\*(R").
This should work since version 1.61, but again the implementation differs from
\&\s-1DOM\s0 specification in the following: if a declaration of the same namespace
prefix already exists on the element, then changing its value via this method
automatically changes the namespace of all elements and attributes in its
scope. This is because in libxml2 the namespace \s-1URI\s0 of an element is not static
but is computed from a pointer to a namespace declaration attribute.
.IP "getAttribute" 4
.IX Item "getAttribute"
.Vb 1
\&  $avalue = $node\->getAttribute( $aname );
.Ve
.Sp
If \f(CW$node\fR has an attribute with the name \f(CW$aname\fR, the value of this attribute will get returned.
.IP "getAttributeNS" 4
.IX Item "getAttributeNS"
.Vb 1
\&  $avalue = $node\->getAttributeNS( $nsURI, $aname );
.Ve
.Sp
Retrieves an attribute value by local name and namespace \s-1URI.\s0
.IP "getAttributeNode" 4
.IX Item "getAttributeNode"
.Vb 1
\&  $attrnode = $node\->getAttributeNode( $aname );
.Ve
.Sp
Retrieve an attribute node by name. If no attribute with a given name exists, \f(CW\*(C`undef\*(C'\fR is returned.
.IP "getAttributeNodeNS" 4
.IX Item "getAttributeNodeNS"
.Vb 1
\&  $attrnode = $node\->getAttributeNodeNS( $namespaceURI, $aname );
.Ve
.Sp
Retrieves an attribute node by local name and namespace \s-1URI.\s0 If no attribute
with a given localname and namespace exists, \f(CW\*(C`undef\*(C'\fR is returned.
.IP "removeAttribute" 4
.IX Item "removeAttribute"
.Vb 1
\&  $node\->removeAttribute( $aname );
.Ve
.Sp
The method removes the attribute \f(CW$aname\fR from the node's attribute list, if the attribute can be found.
.IP "removeAttributeNS" 4
.IX Item "removeAttributeNS"
.Vb 1
\&  $node\->removeAttributeNS( $nsURI, $aname );
.Ve
.Sp
Namespace version of \f(CW\*(C`removeAttribute\*(C'\fR
.IP "hasAttribute" 4
.IX Item "hasAttribute"
.Vb 1
\&  $boolean = $node\->hasAttribute( $aname );
.Ve
.Sp
This function tests if the named attribute is set for the node. If the
attribute is specified, \s-1TRUE \\fIs0\fR\|(1) will be returned, otherwise the return value
is \s-1FALSE \\fIs0\fR\|(0).
.IP "hasAttributeNS" 4
.IX Item "hasAttributeNS"
.Vb 1
\&  $boolean = $node\->hasAttributeNS( $nsURI, $aname );
.Ve
.Sp
namespace version of \f(CW\*(C`hasAttribute\*(C'\fR
.IP "getChildrenByTagName" 4
.IX Item "getChildrenByTagName"
.Vb 1
\&  @nodes = $node\->getChildrenByTagName($tagname);
.Ve
.Sp
The function gives direct access to all child elements of the current node with
a given tagname, where tagname is a qualified name, that is, in case of
namespace usage it may consist of a prefix and local name. This function makes
things a lot easier if one needs to handle big data sets. A special tagname '*'
can be used to match any name.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getChildrenByTagNameNS" 4
.IX Item "getChildrenByTagNameNS"
.Vb 1
\&  @nodes = $node\->getChildrenByTagNameNS($nsURI,$tagname);
.Ve
.Sp
Namespace version of \f(CW\*(C`getChildrenByTagName\*(C'\fR. A special nsURI '*' matches any namespace \s-1URI,\s0 in which case the function
behaves just like \f(CW\*(C`getChildrenByLocalName\*(C'\fR.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getChildrenByLocalName" 4
.IX Item "getChildrenByLocalName"
.Vb 1
\&  @nodes = $node\->getChildrenByLocalName($localname);
.Ve
.Sp
The function gives direct access to all child elements of the current node with
a given local name. It makes things a lot easier if one needs to handle big
data sets. A special \f(CW\*(C`localname\*(C'\fR '*' can be used to match any local name.
.Sp
If this function is called in \s-1SCALAR\s0 context, it returns the number of elements
found.
.IP "getElementsByTagName" 4
.IX Item "getElementsByTagName"
.Vb 1
\&  @nodes = $node\->getElementsByTagName($tagname);
.Ve
.Sp
This function is part of the spec. It fetches all descendants of a node with a
given tagname, where \f(CW\*(C`tagname\*(C'\fR is a qualified name, that is, in case of namespace usage it may consist of a
prefix and local name. A special \f(CW\*(C`tagname\*(C'\fR '*' can be used to match any tag name.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByTagNameNS" 4
.IX Item "getElementsByTagNameNS"
.Vb 1
\&  @nodes = $node\->getElementsByTagNameNS($nsURI,$localname);
.Ve
.Sp
Namespace version of \f(CW\*(C`getElementsByTagName\*(C'\fR as found in the \s-1DOM\s0 spec. A special \f(CW\*(C`localname\*(C'\fR '*' can be used to match any local name and \f(CW\*(C`nsURI\*(C'\fR '*' can be used to match any namespace \s-1URI.\s0
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "getElementsByLocalName" 4
.IX Item "getElementsByLocalName"
.Vb 1
\&  @nodes = $node\->getElementsByLocalName($localname);
.Ve
.Sp
This function is not found in the \s-1DOM\s0 specification. It is a mix of
getElementsByTagName and getElementsByTagNameNS. It will fetch all tags
matching the given local-name. This allows one to select tags with the same
local name across namespace borders.
.Sp
In \s-1SCALAR\s0 context this function returns an XML::LibXML::NodeList object.
.IP "appendWellBalancedChunk" 4
.IX Item "appendWellBalancedChunk"
.Vb 1
\&  $node\->appendWellBalancedChunk( $chunk );
.Ve
.Sp
Sometimes it is necessary to append a string coded \s-1XML\s0 Tree to a node. \fIappendWellBalancedChunk\fR will do the trick for you. But this is only done if the String is \f(CW\*(C`well\-balanced\*(C'\fR.
.Sp
\&\fINote that \fIappendWellBalancedChunk()\fI is only left for compatibility reasons\fR. Implicitly it uses
.Sp
.Vb 2
\&  my $fragment = $parser\->parse_balanced_chunk( $chunk );
\&   $node\->appendChild( $fragment );
.Ve
.Sp
This form is more explicit and makes it easier to control the flow of a script.
.IP "appendText" 4
.IX Item "appendText"
.Vb 1
\&  $node\->appendText( $PCDATA );
.Ve
.Sp
alias for \fIappendTextNode()\fR.
.IP "appendTextNode" 4
.IX Item "appendTextNode"
.Vb 1
\&  $node\->appendTextNode( $PCDATA );
.Ve
.Sp
This wrapper function lets you add a string directly to an element node.
.IP "appendTextChild" 4
.IX Item "appendTextChild"
.Vb 1
\&  $node\->appendTextChild( $childname , $PCDATA );
.Ve
.Sp
Somewhat similar with \f(CW\*(C`appendTextNode\*(C'\fR: It lets you set an Element, that contains only a \f(CW\*(C`text node\*(C'\fR directly by specifying the name and the text content.
.IP "setNamespace" 4
.IX Item "setNamespace"
.Vb 1
\&  $node\->setNamespace( $nsURI , $nsPrefix, $activate );
.Ve
.Sp
\&\fIsetNamespace()\fR allows one to apply a namespace to an element. The function
takes three parameters: 1. the namespace \s-1URI,\s0 which is required and the two
optional values prefix, which is the namespace prefix, as it should be used in
child elements or attributes as well as the additional activate parameter. If
prefix is not given, undefined or empty, this function tries to create a
declaration of the default namespace.
.Sp
The activate parameter is most useful: If this parameter is set to \s-1FALSE \\fIs0\fR\|(0), a
new namespace declaration is simply added to the element while the element's
namespace itself is not altered. Nevertheless, activate is set to \s-1TRUE \\fIs0\fR\|(1) on
default. In this case the namespace is used as the node's effective namespace.
This means the namespace prefix is added to the node name and if there was a
namespace already active for the node, it will be replaced (but its declaration
is not removed from the document). A new namespace declaration is only created
if necessary (that is, if the element is already in the scope of a namespace
declaration associating the prefix with the namespace \s-1URI,\s0 then this
declaration is reused).
.Sp
The following example may clarify this:
.Sp
.Vb 2
\&  my $e1 = $doc\->createElement("bar");
\&   $e1\->setNamespace("http://foobar.org", "foo")
.Ve
.Sp
results
.Sp
.Vb 1
\&  <foo:bar xmlns:foo="http://foobar.org"/>
.Ve
.Sp
while
.Sp
.Vb 2
\&  my $e2 = $doc\->createElement("bar");
\&   $e2\->setNamespace("http://foobar.org", "foo",0)
.Ve
.Sp
results only
.Sp
.Vb 1
\&  <bar xmlns:foo="http://foobar.org"/>
.Ve
.Sp
By using \f(CW$activate\fR == 0 it is possible to create multiple namespace
declarations on a single element.
.Sp
The function fails if it is required to create a declaration associating the
prefix with the namespace \s-1URI\s0 but the element already carries a declaration
with the same prefix but different namespace \s-1URI.\s0
.IP "setNamespaceDeclURI" 4
.IX Item "setNamespaceDeclURI"
.Vb 1
\&  $node\->setNamespaceDeclURI( $nsPrefix, $newURI );
.Ve
.Sp
\&\s-1EXPERIMENTAL IN 1.61 \s0!
.Sp
This function manipulates directly with an existing namespace declaration on an
element. It takes two parameters: the prefix by which it looks up the namespace
declaration and a new namespace \s-1URI\s0 which replaces its previous value.
.Sp
It returns 1 if the namespace declaration was found and changed, 0 otherwise.
.Sp
All elements and attributes (even those previously unbound from the document)
for which the namespace declaration determines their namespace belong to the
new namespace after the change.
.Sp
If the new \s-1URI\s0 is undef or empty, the nodes have no namespace and no prefix
after the change. Namespace declarations once nulled in this way do not further
appear in the serialized output (but do remain in the document for internal
integrity of libxml2 data structures).
.Sp
This function is \s-1NOT\s0 part of any \s-1DOM API.\s0
.IP "setNamespaceDeclPrefix" 4
.IX Item "setNamespaceDeclPrefix"
.Vb 1
\&  $node\->setNamespaceDeclPrefix( $oldPrefix, $newPrefix );
.Ve
.Sp
\&\s-1EXPERIMENTAL IN 1.61 \s0!
.Sp
This function manipulates directly with an existing namespace declaration on an
element. It takes two parameters: the old prefix by which it looks up the
namespace declaration and a new prefix which is to replace the old one.
.Sp
The function dies with an error if the element is in the scope of another
declaration whose prefix equals to the new prefix, or if the change should
result in a declaration with a non-empty prefix but empty namespace \s-1URI.\s0
Otherwise, it returns 1 if the namespace declaration was found and changed and
0 if not found.
.Sp
All elements and attributes (even those previously unbound from the document)
for which the namespace declaration determines their namespace change their
prefix to the new value.
.Sp
If the new prefix is undef or empty, the namespace declaration becomes a
declaration of a default namespace. The corresponding nodes drop their
namespace prefix (but remain in the, now default, namespace). In this case the
function fails, if the containing element is in the scope of another default
namespace declaration.
.Sp
This function is \s-1NOT\s0 part of any \s-1DOM API.\s0
.SH "OVERLOADING"
.IX Header "OVERLOADING"
XML::LibXML::Element overloads hash dereferencing to provide access to the
element's attributes. For non-namespaced attributes, the attribute name is the
hash key, and the attribute value is the hash value. For namespaced attributes,
the hash key is qualified with the namespace \s-1URI,\s0 using Clark notation.
.PP
Perl's \*(L"tied hash\*(R" feature is used, which means that the hash gives you
read-write access to the element's attributes. For more information, see XML::LibXML::AttributeHash
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::ErrNo.3pm                       0100644 0001750 0001750 00000011072 12566241670 024271  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::ErrNo 3"
.TH XML::LibXML::ErrNo 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::ErrNo \- Structured Errors
This module is based on xmlerror.h libxml2 C header file. It defines symbolic
constants for all libxml2 error codes. Currently libxml2 uses over 480
different error codes. See also XML::LibXML::Error.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::ErrNo5.16.3pm                   0100644 0001750 0001750 00000010331 12566241665 024604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::ErrNo 3"
.TH XML::LibXML::ErrNo 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::ErrNo \- Structured Errors
This module is based on xmlerror.h libxml2 C header file. It defines symbolic
constants for all libxml2 error codes. Currently libxml2 uses over 480
different error codes. See also XML::LibXML::Error.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::ErrNo5.18.3pm                   0100644 0001750 0001750 00000011072 12566241670 024605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::ErrNo 3"
.TH XML::LibXML::ErrNo 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::ErrNo \- Structured Errors
This module is based on xmlerror.h libxml2 C header file. It defines symbolic
constants for all libxml2 error codes. Currently libxml2 uses over 480
different error codes. See also XML::LibXML::Error.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Error.3pm                       0100644 0001750 0001750 00000025725 12566241670 024347  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Error 3"
.TH XML::LibXML::Error 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Error \- Structured Errors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  eval { ... };
\&          if (ref($@)) {
\&            # handle a structured error (XML::LibXML::Error object)
\&          } elsif ($@) {
\&            # error, but not an XML::LibXML::Error object
\&          } else {
\&            # no error
\&          }
\&
\&  $XML::LibXML::Error::WARNINGS=1;
\&  $message = $@\->as_string();
\&  print $@\->dump();
\&  $error_domain = $@\->domain();
\&  $error_code = $@\->code();
\&  $error_message = $@\->message();
\&  $error_level = $@\->level();
\&  $filename = $@\->file();
\&  $line = $@\->line();
\&  $nodename = $@\->nodename();
\&  $error_str1 = $@\->str1();
\&  $error_str2 = $@\->str2();
\&  $error_str3 = $@\->str3();
\&  $error_num1 = $@\->num1();
\&  $error_num2 = $@\->num2();
\&  $string = $@\->context();
\&  $offset = $@\->column();
\&  $previous_error = $@\->_prev();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The XML::LibXML::Error class is a tiny frontend to \fIlibxml2\fR's structured error support. If XML::LibXML is compiled with structured error
support, all errors reported by libxml2 are transformed to XML::LibXML::Error
objects. These objects automatically serialize to the corresponding error
messages when printed or used in a string operation, but as objects, can also
be used to get a detailed and structured information about the error that
occurred.
.PP
Unlike most other XML::LibXML objects, XML::LibXML::Error doesn't wrap an
underlying \fIlibxml2\fR structure directly, but rather transforms it to a blessed Perl hash reference
containing the individual fields of the structured error information as hash
key-value pairs. Individual items (fields) of a structured error can either be
obtained directly as $@\->{field}, or using autoloaded methods such as
$@\->\fIfield()\fR (where field is the field name). XML::LibXML::Error objects have
the following fields: domain, code, level, file, line, nodename, message, str1,
str2, str3, num1, num2, and _prev (some of them may be undefined).
.ie n .IP "$XML::LibXML::Error::WARNINGS" 4
.el .IP "\f(CW$XML::LibXML::Error::WARNINGS\fR" 4
.IX Item "$XML::LibXML::Error::WARNINGS"
.Vb 1
\&  $XML::LibXML::Error::WARNINGS=1;
.Ve
.Sp
Traditionally, XML::LibXML was suppressing parser warnings by setting libxml2's
global variable xmlGetWarningsDefaultValue to 0. Since 1.70 we do not change
libxml2's global variables anymore; for backward compatibility, XML::LibXML
suppresses warnings. This variable can be set to 1 to enable reporting of these
warnings via Perl \f(CW\*(C`warn\*(C'\fR and to 2 to report hem via \f(CW\*(C`die\*(C'\fR.
.IP "as_string" 4
.IX Item "as_string"
.Vb 1
\&  $message = $@\->as_string();
.Ve
.Sp
This function serializes an XML::LibXML::Error object to a string containing
the full error message close to the message produced by \fIlibxml2\fR default error handlers and tools like xmllint. This method is also used to
overload "" operator on XML::LibXML::Error, so it is automatically called
whenever XML::LibXML::Error object is treated as a string (e.g. in print $@).
.IP "dump" 4
.IX Item "dump"
.Vb 1
\&  print $@\->dump();
.Ve
.Sp
This function serializes an XML::LibXML::Error to a string displaying all
fields of the error structure individually on separate lines of the form 'name'
=> 'value'.
.IP "domain" 4
.IX Item "domain"
.Vb 1
\&  $error_domain = $@\->domain();
.Ve
.Sp
Returns string containing information about what part of the library raised the
error. Can be one of: \*(L"parser\*(R", \*(L"tree\*(R", \*(L"namespace\*(R", \*(L"validity\*(R", \*(L"\s-1HTML\s0 parser\*(R",
\&\*(L"memory\*(R", \*(L"output\*(R", \*(L"I/O\*(R", \*(L"ftp\*(R", \*(L"http\*(R", \*(L"XInclude\*(R", \*(L"XPath\*(R", \*(L"xpointer\*(R",
\&\*(L"regexp\*(R", \*(L"Schemas datatype\*(R", \*(L"Schemas parser\*(R", \*(L"Schemas validity\*(R", \*(L"Relax-NG
parser\*(R", \*(L"Relax-NG validity\*(R", \*(L"Catalog\*(R", \*(L"C14N\*(R", \*(L"\s-1XSLT\*(R", \s0\*(L"validity\*(R".
.IP "code" 4
.IX Item "code"
.Vb 1
\&  $error_code = $@\->code();
.Ve
.Sp
Returns the actual libxml2 error code. The XML::LibXML::ErrNo module defines
constants for individual error codes. Currently libxml2 uses over 480 different
error codes.
.IP "message" 4
.IX Item "message"
.Vb 1
\&  $error_message = $@\->message();
.Ve
.Sp
Returns a human-readable informative error message.
.IP "level" 4
.IX Item "level"
.Vb 1
\&  $error_level = $@\->level();
.Ve
.Sp
Returns an integer value describing how consequent is the error.
XML::LibXML::Error defines the following constants:
.RS 4
.IP "\(bu" 4
\&\s-1XML_ERR_NONE\s0 = 0
.IP "\(bu" 4
\&\s-1XML_ERR_WARNING\s0 = 1 : A simple warning.
.IP "\(bu" 4
\&\s-1XML_ERR_ERROR\s0 = 2 : A recoverable error.
.IP "\(bu" 4
\&\s-1XML_ERR_FATAL\s0 = 3 : A fatal error.
.RE
.RS 4
.RE
.IP "file" 4
.IX Item "file"
.Vb 1
\&  $filename = $@\->file();
.Ve
.Sp
Returns the filename of the file being processed while the error occurred.
.IP "line" 4
.IX Item "line"
.Vb 1
\&  $line = $@\->line();
.Ve
.Sp
The line number, if available.
.IP "nodename" 4
.IX Item "nodename"
.Vb 1
\&  $nodename = $@\->nodename();
.Ve
.Sp
Name of the node where error occurred, if available. When this field is
non-empty, libxml2 actually returned a physical pointer to the specified node.
Due to memory management issues, it is very difficult to implement a way to
expose the pointer to the Perl level as a XML::LibXML::Node. For this reason,
XML::LibXML::Error currently only exposes the name the node.
.IP "str1" 4
.IX Item "str1"
.Vb 1
\&  $error_str1 = $@\->str1();
.Ve
.Sp
Error specific. Extra string information.
.IP "str2" 4
.IX Item "str2"
.Vb 1
\&  $error_str2 = $@\->str2();
.Ve
.Sp
Error specific. Extra string information.
.IP "str3" 4
.IX Item "str3"
.Vb 1
\&  $error_str3 = $@\->str3();
.Ve
.Sp
Error specific. Extra string information.
.IP "num1" 4
.IX Item "num1"
.Vb 1
\&  $error_num1 = $@\->num1();
.Ve
.Sp
Error specific. Extra numeric information.
.IP "num2" 4
.IX Item "num2"
.Vb 1
\&  $error_num2 = $@\->num2();
.Ve
.Sp
In recent libxml2 versions, this value contains a column number of the error or
0 if N/A.
.IP "context" 4
.IX Item "context"
.Vb 1
\&  $string = $@\->context();
.Ve
.Sp
For parsing errors, this field contains about 80 characters of the \s-1XML\s0 near the
place where the error occurred. The field \f(CW\*(C`$@\->column()\*(C'\fR contains the corresponding offset. Where N/A, the field is undefined.
.IP "column" 4
.IX Item "column"
.Vb 1
\&  $offset = $@\->column();
.Ve
.Sp
See \f(CW\*(C`$@\->column()\*(C'\fR above.
.IP "_prev" 4
.IX Item "_prev"
.Vb 1
\&  $previous_error = $@\->_prev();
.Ve
.Sp
This field can possibly hold a reference to another XML::LibXML::Error object
representing an error which occurred just before this error.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Error5.16.3pm                   0100644 0001750 0001750 00000025167 12566241665 024665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Error 3"
.TH XML::LibXML::Error 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Error \- Structured Errors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  eval { ... };
\&          if (ref($@)) {
\&            # handle a structured error (XML::LibXML::Error object)
\&          } elsif ($@) {
\&            # error, but not an XML::LibXML::Error object
\&          } else {
\&            # no error
\&          }
\&
\&  $XML::LibXML::Error::WARNINGS=1;
\&  $message = $@\->as_string();
\&  print $@\->dump();
\&  $error_domain = $@\->domain();
\&  $error_code = $@\->code();
\&  $error_message = $@\->message();
\&  $error_level = $@\->level();
\&  $filename = $@\->file();
\&  $line = $@\->line();
\&  $nodename = $@\->nodename();
\&  $error_str1 = $@\->str1();
\&  $error_str2 = $@\->str2();
\&  $error_str3 = $@\->str3();
\&  $error_num1 = $@\->num1();
\&  $error_num2 = $@\->num2();
\&  $string = $@\->context();
\&  $offset = $@\->column();
\&  $previous_error = $@\->_prev();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The XML::LibXML::Error class is a tiny frontend to \fIlibxml2\fR's structured error support. If XML::LibXML is compiled with structured error
support, all errors reported by libxml2 are transformed to XML::LibXML::Error
objects. These objects automatically serialize to the corresponding error
messages when printed or used in a string operation, but as objects, can also
be used to get a detailed and structured information about the error that
occurred.
.PP
Unlike most other XML::LibXML objects, XML::LibXML::Error doesn't wrap an
underlying \fIlibxml2\fR structure directly, but rather transforms it to a blessed Perl hash reference
containing the individual fields of the structured error information as hash
key-value pairs. Individual items (fields) of a structured error can either be
obtained directly as $@\->{field}, or using autoloaded methods such as as
$@\->\fIfield()\fR (where field is the field name). XML::LibXML::Error objects have
the following fields: domain, code, level, file, line, nodename, message, str1,
str2, str3, num1, num2, and _prev (some of them may be undefined).
.ie n .IP "$XML::LibXML::Error::WARNINGS" 4
.el .IP "\f(CW$XML::LibXML::Error::WARNINGS\fR" 4
.IX Item "$XML::LibXML::Error::WARNINGS"
.Vb 1
\&  $XML::LibXML::Error::WARNINGS=1;
.Ve
.Sp
Traditionally, XML::LibXML was suppressing parser warnings by setting libxml2's
global variable xmlGetWarningsDefaultValue to 0. Since 1.70 we do not change
libxml2's global variables anymore; for backward compatibility, XML::LibXML
suppresses warnings. This variable can be set to 1 to enable reporting of these
warnings via Perl \f(CW\*(C`warn\*(C'\fR and to 2 to report hem via \f(CW\*(C`die\*(C'\fR.
.IP "as_string" 4
.IX Item "as_string"
.Vb 1
\&  $message = $@\->as_string();
.Ve
.Sp
This function serializes an XML::LibXML::Error object to a string containing
the full error message close to the message produced by \fIlibxml2\fR default error handlers and tools like xmllint. This method is also used to
overload "" operator on XML::LibXML::Error, so it is automatically called
whenever XML::LibXML::Error object is treated as a string (e.g. in print $@).
.IP "dump" 4
.IX Item "dump"
.Vb 1
\&  print $@\->dump();
.Ve
.Sp
This function serializes an XML::LibXML::Error to a string displaying all
fields of the error structure individually on separate lines of the form 'name'
=> 'value'.
.IP "domain" 4
.IX Item "domain"
.Vb 1
\&  $error_domain = $@\->domain();
.Ve
.Sp
Returns string containing information about what part of the library raised the
error. Can be one of: \*(L"parser\*(R", \*(L"tree\*(R", \*(L"namespace\*(R", \*(L"validity\*(R", \*(L"\s-1HTML\s0 parser\*(R",
\&\*(L"memory\*(R", \*(L"output\*(R", \*(L"I/O\*(R", \*(L"ftp\*(R", \*(L"http\*(R", \*(L"XInclude\*(R", \*(L"XPath\*(R", \*(L"xpointer\*(R",
\&\*(L"regexp\*(R", \*(L"Schemas datatype\*(R", \*(L"Schemas parser\*(R", \*(L"Schemas validity\*(R", \*(L"Relax-NG
parser\*(R", \*(L"Relax-NG validity\*(R", \*(L"Catalog\*(R", \*(L"C14N\*(R", \*(L"\s-1XSLT\s0\*(R", \*(L"validity\*(R".
.IP "code" 4
.IX Item "code"
.Vb 1
\&  $error_code = $@\->code();
.Ve
.Sp
Returns the actual libxml2 error code. The XML::LibXML::ErrNo module defines
constants for individual error codes. Currently libxml2 uses over 480 different
error codes.
.IP "message" 4
.IX Item "message"
.Vb 1
\&  $error_message = $@\->message();
.Ve
.Sp
Returns a human-readable informative error message.
.IP "level" 4
.IX Item "level"
.Vb 1
\&  $error_level = $@\->level();
.Ve
.Sp
Returns an integer value describing how consequent is the error.
XML::LibXML::Error defines the following constants:
.RS 4
.IP "\(bu" 4
\&\s-1XML_ERR_NONE\s0 = 0
.IP "\(bu" 4
\&\s-1XML_ERR_WARNING\s0 = 1 : A simple warning.
.IP "\(bu" 4
\&\s-1XML_ERR_ERROR\s0 = 2 : A recoverable error.
.IP "\(bu" 4
\&\s-1XML_ERR_FATAL\s0 = 3 : A fatal error.
.RE
.RS 4
.RE
.IP "file" 4
.IX Item "file"
.Vb 1
\&  $filename = $@\->file();
.Ve
.Sp
Returns the filename of the file being processed while the error occurred.
.IP "line" 4
.IX Item "line"
.Vb 1
\&  $line = $@\->line();
.Ve
.Sp
The line number, if available.
.IP "nodename" 4
.IX Item "nodename"
.Vb 1
\&  $nodename = $@\->nodename();
.Ve
.Sp
Name of the node where error occurred, if available. When this field is
non-empty, libxml2 actually returned a physical pointer to the specified node.
Due to memory management issues, it is very difficult to implement a way to
expose the pointer to the Perl level as a XML::LibXML::Node. For this reason,
XML::LibXML::Error currently only exposes the name the node.
.IP "str1" 4
.IX Item "str1"
.Vb 1
\&  $error_str1 = $@\->str1();
.Ve
.Sp
Error specific. Extra string information.
.IP "str2" 4
.IX Item "str2"
.Vb 1
\&  $error_str2 = $@\->str2();
.Ve
.Sp
Error specific. Extra string information.
.IP "str3" 4
.IX Item "str3"
.Vb 1
\&  $error_str3 = $@\->str3();
.Ve
.Sp
Error specific. Extra string information.
.IP "num1" 4
.IX Item "num1"
.Vb 1
\&  $error_num1 = $@\->num1();
.Ve
.Sp
Error specific. Extra numeric information.
.IP "num2" 4
.IX Item "num2"
.Vb 1
\&  $error_num2 = $@\->num2();
.Ve
.Sp
In recent libxml2 versions, this value contains a column number of the error or
0 if N/A.
.IP "context" 4
.IX Item "context"
.Vb 1
\&  $string = $@\->context();
.Ve
.Sp
For parsing errors, this field contains about 80 characters of the \s-1XML\s0 near the
place where the error occurred. The field \f(CW\*(C`$@\->column()\*(C'\fR contains the corresponding offset. Where N/A, the field is undefined.
.IP "column" 4
.IX Item "column"
.Vb 1
\&  $offset = $@\->column();
.Ve
.Sp
See \f(CW\*(C`$@\->column()\*(C'\fR above.
.IP "_prev" 4
.IX Item "_prev"
.Vb 1
\&  $previous_error = $@\->_prev();
.Ve
.Sp
This field can possibly hold a reference to another XML::LibXML::Error object
representing an error which occurred just before this error.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Error5.18.3pm                   0100644 0001750 0001750 00000025725 12566241670 024663  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Error 3"
.TH XML::LibXML::Error 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Error \- Structured Errors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  eval { ... };
\&          if (ref($@)) {
\&            # handle a structured error (XML::LibXML::Error object)
\&          } elsif ($@) {
\&            # error, but not an XML::LibXML::Error object
\&          } else {
\&            # no error
\&          }
\&
\&  $XML::LibXML::Error::WARNINGS=1;
\&  $message = $@\->as_string();
\&  print $@\->dump();
\&  $error_domain = $@\->domain();
\&  $error_code = $@\->code();
\&  $error_message = $@\->message();
\&  $error_level = $@\->level();
\&  $filename = $@\->file();
\&  $line = $@\->line();
\&  $nodename = $@\->nodename();
\&  $error_str1 = $@\->str1();
\&  $error_str2 = $@\->str2();
\&  $error_str3 = $@\->str3();
\&  $error_num1 = $@\->num1();
\&  $error_num2 = $@\->num2();
\&  $string = $@\->context();
\&  $offset = $@\->column();
\&  $previous_error = $@\->_prev();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The XML::LibXML::Error class is a tiny frontend to \fIlibxml2\fR's structured error support. If XML::LibXML is compiled with structured error
support, all errors reported by libxml2 are transformed to XML::LibXML::Error
objects. These objects automatically serialize to the corresponding error
messages when printed or used in a string operation, but as objects, can also
be used to get a detailed and structured information about the error that
occurred.
.PP
Unlike most other XML::LibXML objects, XML::LibXML::Error doesn't wrap an
underlying \fIlibxml2\fR structure directly, but rather transforms it to a blessed Perl hash reference
containing the individual fields of the structured error information as hash
key-value pairs. Individual items (fields) of a structured error can either be
obtained directly as $@\->{field}, or using autoloaded methods such as
$@\->\fIfield()\fR (where field is the field name). XML::LibXML::Error objects have
the following fields: domain, code, level, file, line, nodename, message, str1,
str2, str3, num1, num2, and _prev (some of them may be undefined).
.ie n .IP "$XML::LibXML::Error::WARNINGS" 4
.el .IP "\f(CW$XML::LibXML::Error::WARNINGS\fR" 4
.IX Item "$XML::LibXML::Error::WARNINGS"
.Vb 1
\&  $XML::LibXML::Error::WARNINGS=1;
.Ve
.Sp
Traditionally, XML::LibXML was suppressing parser warnings by setting libxml2's
global variable xmlGetWarningsDefaultValue to 0. Since 1.70 we do not change
libxml2's global variables anymore; for backward compatibility, XML::LibXML
suppresses warnings. This variable can be set to 1 to enable reporting of these
warnings via Perl \f(CW\*(C`warn\*(C'\fR and to 2 to report hem via \f(CW\*(C`die\*(C'\fR.
.IP "as_string" 4
.IX Item "as_string"
.Vb 1
\&  $message = $@\->as_string();
.Ve
.Sp
This function serializes an XML::LibXML::Error object to a string containing
the full error message close to the message produced by \fIlibxml2\fR default error handlers and tools like xmllint. This method is also used to
overload "" operator on XML::LibXML::Error, so it is automatically called
whenever XML::LibXML::Error object is treated as a string (e.g. in print $@).
.IP "dump" 4
.IX Item "dump"
.Vb 1
\&  print $@\->dump();
.Ve
.Sp
This function serializes an XML::LibXML::Error to a string displaying all
fields of the error structure individually on separate lines of the form 'name'
=> 'value'.
.IP "domain" 4
.IX Item "domain"
.Vb 1
\&  $error_domain = $@\->domain();
.Ve
.Sp
Returns string containing information about what part of the library raised the
error. Can be one of: \*(L"parser\*(R", \*(L"tree\*(R", \*(L"namespace\*(R", \*(L"validity\*(R", \*(L"\s-1HTML\s0 parser\*(R",
\&\*(L"memory\*(R", \*(L"output\*(R", \*(L"I/O\*(R", \*(L"ftp\*(R", \*(L"http\*(R", \*(L"XInclude\*(R", \*(L"XPath\*(R", \*(L"xpointer\*(R",
\&\*(L"regexp\*(R", \*(L"Schemas datatype\*(R", \*(L"Schemas parser\*(R", \*(L"Schemas validity\*(R", \*(L"Relax-NG
parser\*(R", \*(L"Relax-NG validity\*(R", \*(L"Catalog\*(R", \*(L"C14N\*(R", \*(L"\s-1XSLT\*(R", \s0\*(L"validity\*(R".
.IP "code" 4
.IX Item "code"
.Vb 1
\&  $error_code = $@\->code();
.Ve
.Sp
Returns the actual libxml2 error code. The XML::LibXML::ErrNo module defines
constants for individual error codes. Currently libxml2 uses over 480 different
error codes.
.IP "message" 4
.IX Item "message"
.Vb 1
\&  $error_message = $@\->message();
.Ve
.Sp
Returns a human-readable informative error message.
.IP "level" 4
.IX Item "level"
.Vb 1
\&  $error_level = $@\->level();
.Ve
.Sp
Returns an integer value describing how consequent is the error.
XML::LibXML::Error defines the following constants:
.RS 4
.IP "\(bu" 4
\&\s-1XML_ERR_NONE\s0 = 0
.IP "\(bu" 4
\&\s-1XML_ERR_WARNING\s0 = 1 : A simple warning.
.IP "\(bu" 4
\&\s-1XML_ERR_ERROR\s0 = 2 : A recoverable error.
.IP "\(bu" 4
\&\s-1XML_ERR_FATAL\s0 = 3 : A fatal error.
.RE
.RS 4
.RE
.IP "file" 4
.IX Item "file"
.Vb 1
\&  $filename = $@\->file();
.Ve
.Sp
Returns the filename of the file being processed while the error occurred.
.IP "line" 4
.IX Item "line"
.Vb 1
\&  $line = $@\->line();
.Ve
.Sp
The line number, if available.
.IP "nodename" 4
.IX Item "nodename"
.Vb 1
\&  $nodename = $@\->nodename();
.Ve
.Sp
Name of the node where error occurred, if available. When this field is
non-empty, libxml2 actually returned a physical pointer to the specified node.
Due to memory management issues, it is very difficult to implement a way to
expose the pointer to the Perl level as a XML::LibXML::Node. For this reason,
XML::LibXML::Error currently only exposes the name the node.
.IP "str1" 4
.IX Item "str1"
.Vb 1
\&  $error_str1 = $@\->str1();
.Ve
.Sp
Error specific. Extra string information.
.IP "str2" 4
.IX Item "str2"
.Vb 1
\&  $error_str2 = $@\->str2();
.Ve
.Sp
Error specific. Extra string information.
.IP "str3" 4
.IX Item "str3"
.Vb 1
\&  $error_str3 = $@\->str3();
.Ve
.Sp
Error specific. Extra string information.
.IP "num1" 4
.IX Item "num1"
.Vb 1
\&  $error_num1 = $@\->num1();
.Ve
.Sp
Error specific. Extra numeric information.
.IP "num2" 4
.IX Item "num2"
.Vb 1
\&  $error_num2 = $@\->num2();
.Ve
.Sp
In recent libxml2 versions, this value contains a column number of the error or
0 if N/A.
.IP "context" 4
.IX Item "context"
.Vb 1
\&  $string = $@\->context();
.Ve
.Sp
For parsing errors, this field contains about 80 characters of the \s-1XML\s0 near the
place where the error occurred. The field \f(CW\*(C`$@\->column()\*(C'\fR contains the corresponding offset. Where N/A, the field is undefined.
.IP "column" 4
.IX Item "column"
.Vb 1
\&  $offset = $@\->column();
.Ve
.Sp
See \f(CW\*(C`$@\->column()\*(C'\fR above.
.IP "_prev" 4
.IX Item "_prev"
.Vb 1
\&  $previous_error = $@\->_prev();
.Ve
.Sp
This field can possibly hold a reference to another XML::LibXML::Error object
representing an error which occurred just before this error.
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::InputCallback.3pm               0100644 0001750 0001750 00000036006 12566241670 025764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::InputCallback 3"
.TH XML::LibXML::InputCallback 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::InputCallback \- XML::LibXML Class for Input Callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
You may get unexpected results if you are trying to load external documents
during libxml2 parsing if the location of the resource is not a \s-1HTTP, FTP\s0 or
relative location but a absolute path for example. To get around this
limitation, you may add your own input handler to open, read and close
particular types of locations or \s-1URI\s0 classes. Using this input callback
handlers, you can handle your own custom \s-1URI\s0 schemes for example.
.PP
The input callbacks are used whenever LibXML has to get something other than
externally parsed entities from somewhere. They are implemented using a
callback stack on the Perl layer in analogy to libxml2's native callback stack.
.PP
The XML::LibXML::InputCallback class transparently registers the input
callbacks for the libxml2's parser processes.
.SS "How does XML::LibXML::InputCallback work?"
.IX Subsection "How does XML::LibXML::InputCallback work?"
The libxml2 library offers a callback implementation as global functions only.
To work-around the troubles resulting in having only global callbacks \- for
example, if the same global callback stack is manipulated by different
applications running together in a single Apache Web-server environment \-,
XML::LibXML::InputCallback comes with a object-oriented and a function-oriented
part.
.PP
Using the function-oriented part the global callback stack of libxml2 can be
manipulated. Those functions can be used as interface to the callbacks on the
C\- and \s-1XS\s0 Layer. At the object-oriented part, operations for working with the
\&\*(L"pseudo-localized\*(R" callback stack are implemented. Currently, you can register
and de-register callbacks on the Perl layer and initialize them on a per parser
basis.
.PP
\fICallback Groups\fR
.IX Subsection "Callback Groups"
.PP
The libxml2 input callbacks come in groups. One group contains a \s-1URI\s0 matcher (\fImatch\fR), a data stream constructor (\fIopen\fR), a data stream reader (\fIread\fR), and a data stream destructor (\fIclose\fR). The callbacks can be manipulated on a per group basis only.
.PP
\fIThe Parser Process\fR
.IX Subsection "The Parser Process"
.PP
The parser process works on an \s-1XML\s0 data stream, along which, links to other
resources can be embedded. This can be links to external DTDs or XIncludes for
example. Those resources are identified by URIs. The callback implementation of
libxml2 assumes that one callback group can handle a certain amount of URIs and
a certain \s-1URI\s0 scheme. Per default, callback handlers for \fIfile://*\fR, \fIfile:://*.gz\fR, \fIhttp://*\fR and \fIftp://*\fR are registered.
.PP
Callback groups in the callback stack are processed from top to bottom, meaning
that callback groups registered later will be processed before the earlier
registered ones.
.PP
While parsing the data stream, the libxml2 parser checks if a registered
callback group will handle a \s-1URI \-\s0 if they will not, the \s-1URI\s0 will be
interpreted as \fIfile://URI\fR. To handle a \s-1URI,\s0 the \fImatch\fR callback will have to return '1'. If that happens, the handling of the \s-1URI\s0 will
be passed to that callback group. Next, the \s-1URI\s0 will be passed to the \fIopen\fR callback, which should return a \fIreference\fR to the data stream if it successfully opened the file, '0' otherwise. If
opening the stream was successful, the \fIread\fR callback will be called repeatedly until it returns an empty string. After the
read callback, the \fIclose\fR callback will be called to close the stream.
.PP
\fIOrganisation of callback groups in XML::LibXML::InputCallback\fR
.IX Subsection "Organisation of callback groups in XML::LibXML::InputCallback"
.PP
Callback groups are implemented as a stack (Array), each entry holds a
reference to an array of the callbacks. For the libxml2 library, the
XML::LibXML::InputCallback callback implementation appears as one single
callback group. The Perl implementation however allows one to manage different
callback stacks on a per libxml2\-parser basis.
.SS "Using XML::LibXML::InputCallback"
.IX Subsection "Using XML::LibXML::InputCallback"
After object instantiation using the parameter-less constructor, you can
register callback groups.
.PP
.Vb 7
\&  my $input_callbacks = XML::LibXML::InputCallback\->new();
\&  $input_callbacks\->register_callbacks([ $match_cb1, $open_cb1,
\&                                         $read_cb1, $close_cb1 ] );
\&  $input_callbacks\->register_callbacks([ $match_cb2, $open_cb2,
\&                                         $read_cb2, $close_cb2 ] );
\&  $input_callbacks\->register_callbacks( [ $match_cb3, $open_cb3,
\&                                          $read_cb3, $close_cb3 ] );
\&
\&  $parser\->input_callbacks( $input_callbacks );
\&  $parser\->parse_file( $some_xml_file );
.Ve
.SS "What about the old callback system prior to XML::LibXML::InputCallback?"
.IX Subsection "What about the old callback system prior to XML::LibXML::InputCallback?"
In XML::LibXML versions prior to 1.59 \- i.e. without the
XML::LibXML::InputCallback module \- you could define your callbacks either
using globally or locally. You still can do that using
XML::LibXML::InputCallback, and in addition to that you can define the
callbacks on a per parser basis!
.PP
If you use the old callback interface through global callbacks,
XML::LibXML::InputCallback will treat them with a lower priority as the ones
registered using the new interface. The global callbacks will not override the
callback groups registered using the new interface. Local callbacks are
attached to a specific parser instance, therefore they are treated with highest
priority. If the \fImatch\fR callback of the callback group registered as local variable is identical to one
of the callback groups registered using the new interface, that callback group
will be replaced.
.PP
Users of the old callback implementation whose \fIopen\fR callback returned a plain string, will have to adapt their code to return a
reference to that string after upgrading to version >= 1.59. The new callback
system can only deal with the \fIopen\fR callback returning a reference!
.SH "INTERFACE DESCRIPTION"
.IX Header "INTERFACE DESCRIPTION"
.SS "Global Variables"
.IX Subsection "Global Variables"
.ie n .IP "$_CUR_CB" 4
.el .IP "\f(CW$_CUR_CB\fR" 4
.IX Item "$_CUR_CB"
Stores the current callback and can be used as shortcut to access the callback
stack.
.ie n .IP "@_GLOBAL_CALLBACKS" 4
.el .IP "\f(CW@_GLOBAL_CALLBACKS\fR" 4
.IX Item "@_GLOBAL_CALLBACKS"
Stores all callback groups for the current parser process.
.ie n .IP "@_CB_STACK" 4
.el .IP "\f(CW@_CB_STACK\fR" 4
.IX Item "@_CB_STACK"
Stores the currently used callback group. Used to prevent parser errors when
dealing with nested \s-1XML\s0 data.
.SS "Global Callbacks"
.IX Subsection "Global Callbacks"
.IP "_callback_match" 4
.IX Item "_callback_match"
Implements the interface for the \fImatch\fR callback at C\-level and for the selection of the callback group from the
callbacks defined at the Perl-level.
.IP "_callback_open" 4
.IX Item "_callback_open"
Forwards the \fIopen\fR callback from libxml2 to the corresponding callback function at the Perl-level.
.IP "_callback_read" 4
.IX Item "_callback_read"
Forwards the read request to the corresponding callback function at the
Perl-level and returns the result to libxml2.
.IP "_callback_close" 4
.IX Item "_callback_close"
Forwards the \fIclose\fR callback from libxml2 to the corresponding callback function at the
Perl-level..
.SS "Class methods"
.IX Subsection "Class methods"
.IP "\fInew()\fR" 4
.IX Item "new()"
A simple constructor.
.ie n .IP "register_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])" 4
.el .IP "register_callbacks( [ \f(CW$match_cb\fR, \f(CW$open_cb\fR, \f(CW$read_cb\fR, \f(CW$close_cb\fR ])" 4
.IX Item "register_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
The four callbacks \fIhave\fR to be given as array reference in the above order \fImatch\fR, \fIopen\fR, \fIread\fR, \fIclose\fR!
.ie n .IP "unregister_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])" 4
.el .IP "unregister_callbacks( [ \f(CW$match_cb\fR, \f(CW$open_cb\fR, \f(CW$read_cb\fR, \f(CW$close_cb\fR ])" 4
.IX Item "unregister_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
With no arguments given, \f(CW\*(C`unregister_callbacks()\*(C'\fR will delete the last registered callback group from the stack. If four
callbacks are passed as array reference, the callback group to unregister will
be identified by the \fImatch\fR callback and deleted from the callback stack. Note that if several identical \fImatch\fR callbacks are defined in different callback groups, \s-1ALL\s0 of them will be deleted
from the stack.
.ie n .IP "init_callbacks( $parser )" 4
.el .IP "init_callbacks( \f(CW$parser\fR )" 4
.IX Item "init_callbacks( $parser )"
Initializes the callback system for the provided parser before starting a
parsing process.
.IP "\fIcleanup_callbacks()\fR" 4
.IX Item "cleanup_callbacks()"
Resets global variables and the libxml2 callback stack.
.IP "\fIlib_init_callbacks()\fR" 4
.IX Item "lib_init_callbacks()"
Used internally for callback registration at C\-level.
.IP "\fIlib_cleanup_callbacks()\fR" 4
.IX Item "lib_cleanup_callbacks()"
Used internally for callback resetting at the C\-level.
.SH "EXAMPLE CALLBACKS"
.IX Header "EXAMPLE CALLBACKS"
The following example is a purely fictitious example that uses a
MyScheme::Handler object that responds to methods similar to an IO::Handle.
.PP
.Vb 5
\&  # Define the four callback functions
\&  sub match_uri {
\&      my $uri = shift;
\&      return $uri =~ /^myscheme:/; # trigger our callback group at a \*(Aqmyscheme\*(Aq URIs
\&  }
\&
\&  sub open_uri {
\&      my $uri = shift;
\&      my $handler = MyScheme::Handler\->new($uri);
\&      return $handler;
\&  }
\&
\&  # The returned $buffer will be parsed by the libxml2 parser
\&  sub read_uri {
\&      my $handler = shift;
\&      my $length = shift;
\&      my $buffer;
\&      read($handler, $buffer, $length);
\&      return $buffer; # $buffer will be an empty string \*(Aq\*(Aq if read() is done
\&  }
\&
\&  # Close the handle associated with the resource.
\&  sub close_uri {
\&      my $handler = shift;
\&      close($handler);
\&  }
\&
\&  # Register them with a instance of XML::LibXML::InputCallback
\&  my $input_callbacks = XML::LibXML::InputCallback\->new();
\&  $input_callbacks\->register_callbacks([ \e&match_uri, \e&open_uri,
\&                                         \e&read_uri, \e&close_uri ] );
\&
\&  # Register the callback group at a parser instance
\&  $parser\->input_callbacks( $input_callbacks );
\&
\&  # $some_xml_file will be parsed using our callbacks
\&  $parser\->parse_file( $some_xml_file );
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::InputCallback5.16.3pm           0100644 0001750 0001750 00000035250 12566241665 026302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::InputCallback 3"
.TH XML::LibXML::InputCallback 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::InputCallback \- XML::LibXML Class for Input Callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
You may get unexpected results if you are trying to load external documents
during libxml2 parsing if the location of the resource is not a \s-1HTTP\s0, \s-1FTP\s0 or
relative location but a absolute path for example. To get around this
limitation, you may add your own input handler to open, read and close
particular types of locations or \s-1URI\s0 classes. Using this input callback
handlers, you can handle your own custom \s-1URI\s0 schemes for example.
.PP
The input callbacks are used whenever LibXML has to get something other than
externally parsed entities from somewhere. They are implemented using a
callback stack on the Perl layer in analogy to libxml2's native callback stack.
.PP
The XML::LibXML::InputCallback class transparently registers the input
callbacks for the libxml2's parser processes.
.SS "How does XML::LibXML::InputCallback work?"
.IX Subsection "How does XML::LibXML::InputCallback work?"
The libxml2 library offers a callback implementation as global functions only.
To work-around the troubles resulting in having only global callbacks \- for
example, if the same global callback stack is manipulated by different
applications running together in a single Apache Web-server environment \-,
XML::LibXML::InputCallback comes with a object-oriented and a function-oriented
part.
.PP
Using the function-oriented part the global callback stack of libxml2 can be
manipulated. Those functions can be used as interface to the callbacks on the
C\- and \s-1XS\s0 Layer. At the object-oriented part, operations for working with the
\&\*(L"pseudo-localized\*(R" callback stack are implemented. Currently, you can register
and de-register callbacks on the Perl layer and initialize them on a per parser
basis.
.PP
\fICallback Groups\fR
.IX Subsection "Callback Groups"
.PP
The libxml2 input callbacks come in groups. One group contains a \s-1URI\s0 matcher (\fImatch\fR), a data stream constructor (\fIopen\fR), a data stream reader (\fIread\fR), and a data stream destructor (\fIclose\fR). The callbacks can be manipulated on a per group basis only.
.PP
\fIThe Parser Process\fR
.IX Subsection "The Parser Process"
.PP
The parser process works on an \s-1XML\s0 data stream, along which, links to other
resources can be embedded. This can be links to external DTDs or XIncludes for
example. Those resources are identified by URIs. The callback implementation of
libxml2 assumes that one callback group can handle a certain amount of URIs and
a certain \s-1URI\s0 scheme. Per default, callback handlers for \fIfile://*\fR, \fIfile:://*.gz\fR, \fIhttp://*\fR and \fIftp://*\fR are registered.
.PP
Callback groups in the callback stack are processed from top to bottom, meaning
that callback groups registered later will be processed before the earlier
registered ones.
.PP
While parsing the data stream, the libxml2 parser checks if a registered
callback group will handle a \s-1URI\s0 \- if they will not, the \s-1URI\s0 will be
interpreted as \fIfile://URI\fR. To handle a \s-1URI\s0, the \fImatch\fR callback will have to return '1'. If that happens, the handling of the \s-1URI\s0 will
be passed to that callback group. Next, the \s-1URI\s0 will be passed to the \fIopen\fR callback, which should return a \fIreference\fR to the data stream if it successfully opened the file, '0' otherwise. If
opening the stream was successful, the \fIread\fR callback will be called repeatedly until it returns an empty string. After the
read callback, the \fIclose\fR callback will be called to close the stream.
.PP
\fIOrganisation of callback groups in XML::LibXML::InputCallback\fR
.IX Subsection "Organisation of callback groups in XML::LibXML::InputCallback"
.PP
Callback groups are implemented as a stack (Array), each entry holds a
reference to an array of the callbacks. For the libxml2 library, the
XML::LibXML::InputCallback callback implementation appears as one single
callback group. The Perl implementation however allows to manage different
callback stacks on a per libxml2\-parser basis.
.SS "Using XML::LibXML::InputCallback"
.IX Subsection "Using XML::LibXML::InputCallback"
After object instantiation using the parameter-less constructor, you can
register callback groups.
.PP
.Vb 7
\&  my $input_callbacks = XML::LibXML::InputCallback\->new();
\&  $input_callbacks\->register_callbacks([ $match_cb1, $open_cb1,
\&                                         $read_cb1, $close_cb1 ] );
\&  $input_callbacks\->register_callbacks([ $match_cb2, $open_cb2,
\&                                         $read_cb2, $close_cb2 ] );
\&  $input_callbacks\->register_callbacks( [ $match_cb3, $open_cb3,
\&                                          $read_cb3, $close_cb3 ] );
\&
\&  $parser\->input_callbacks( $input_callbacks );
\&  $parser\->parse_file( $some_xml_file );
.Ve
.SS "What about the old callback system prior to XML::LibXML::InputCallback?"
.IX Subsection "What about the old callback system prior to XML::LibXML::InputCallback?"
In XML::LibXML versions prior to 1.59 \- i.e. without the
XML::LibXML::InputCallback module \- you could define your callbacks either
using globally or locally. You still can do that using
XML::LibXML::InputCallback, and in addition to that you can define the
callbacks on a per parser basis!
.PP
If you use the old callback interface through global callbacks,
XML::LibXML::InputCallback will treat them with a lower priority as the ones
registered using the new interface. The global callbacks will not override the
callback groups registered using the new interface. Local callbacks are
attached to a specific parser instance, therefore they are treated with highest
priority. If the \fImatch\fR callback of the callback group registered as local variable is identical to one
of the callback groups registered using the new interface, that callback group
will be replaced.
.PP
Users of the old callback implementation whose \fIopen\fR callback returned a plain string, will have to adapt their code to return a
reference to that string after upgrading to version >= 1.59. The new callback
system can only deal with the \fIopen\fR callback returning a reference!
.SH "INTERFACE DESCRIPTION"
.IX Header "INTERFACE DESCRIPTION"
.SS "Global Variables"
.IX Subsection "Global Variables"
.ie n .IP "$_CUR_CB" 4
.el .IP "\f(CW$_CUR_CB\fR" 4
.IX Item "$_CUR_CB"
Stores the current callback and can be used as shortcut to access the callback
stack.
.ie n .IP "@_GLOBAL_CALLBACKS" 4
.el .IP "\f(CW@_GLOBAL_CALLBACKS\fR" 4
.IX Item "@_GLOBAL_CALLBACKS"
Stores all callback groups for the current parser process.
.ie n .IP "@_CB_STACK" 4
.el .IP "\f(CW@_CB_STACK\fR" 4
.IX Item "@_CB_STACK"
Stores the currently used callback group. Used to prevent parser errors when
dealing with nested \s-1XML\s0 data.
.SS "Global Callbacks"
.IX Subsection "Global Callbacks"
.IP "_callback_match" 4
.IX Item "_callback_match"
Implements the interface for the \fImatch\fR callback at C\-level and for the selection of the callback group from the
callbacks defined at the Perl-level.
.IP "_callback_open" 4
.IX Item "_callback_open"
Forwards the \fIopen\fR callback from libxml2 to the corresponding callback function at the Perl-level.
.IP "_callback_read" 4
.IX Item "_callback_read"
Forwards the read request to the corresponding callback function at the
Perl-level and returns the result to libxml2.
.IP "_callback_close" 4
.IX Item "_callback_close"
Forwards the \fIclose\fR callback from libxml2 to the corresponding callback function at the
Perl-level..
.SS "Class methods"
.IX Subsection "Class methods"
.IP "\fInew()\fR" 4
.IX Item "new()"
A simple constructor.
.ie n .IP "register_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])" 4
.el .IP "register_callbacks( [ \f(CW$match_cb\fR, \f(CW$open_cb\fR, \f(CW$read_cb\fR, \f(CW$close_cb\fR ])" 4
.IX Item "register_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
The four callbacks \fIhave\fR to be given as array reference in the above order \fImatch\fR, \fIopen\fR, \fIread\fR, \fIclose\fR!
.ie n .IP "unregister_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])" 4
.el .IP "unregister_callbacks( [ \f(CW$match_cb\fR, \f(CW$open_cb\fR, \f(CW$read_cb\fR, \f(CW$close_cb\fR ])" 4
.IX Item "unregister_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
With no arguments given, \f(CW\*(C`unregister_callbacks()\*(C'\fR will delete the last registered callback group from the stack. If four
callbacks are passed as array reference, the callback group to unregister will
be identified by the \fImatch\fR callback and deleted from the callback stack. Note that if several identical \fImatch\fR callbacks are defined in different callback groups, \s-1ALL\s0 of them will be deleted
from the stack.
.ie n .IP "init_callbacks( $parser )" 4
.el .IP "init_callbacks( \f(CW$parser\fR )" 4
.IX Item "init_callbacks( $parser )"
Initializes the callback system for the provided parser before starting a
parsing process.
.IP "\fIcleanup_callbacks()\fR" 4
.IX Item "cleanup_callbacks()"
Resets global variables and the libxml2 callback stack.
.IP "\fIlib_init_callbacks()\fR" 4
.IX Item "lib_init_callbacks()"
Used internally for callback registration at C\-level.
.IP "\fIlib_cleanup_callbacks()\fR" 4
.IX Item "lib_cleanup_callbacks()"
Used internally for callback resetting at the C\-level.
.SH "EXAMPLE CALLBACKS"
.IX Header "EXAMPLE CALLBACKS"
The following example is a purely fictitious example that uses a
MyScheme::Handler object that responds to methods similar to an IO::Handle.
.PP
.Vb 5
\&  # Define the four callback functions
\&  sub match_uri {
\&      my $uri = shift;
\&      return $uri =~ /^myscheme:/; # trigger our callback group at a \*(Aqmyscheme\*(Aq URIs
\&  }
\&
\&  sub open_uri {
\&      my $uri = shift;
\&      my $handler = MyScheme::Handler\->new($uri);
\&      return $handler;
\&  }
\&
\&  # The returned $buffer will be parsed by the libxml2 parser
\&  sub read_uri {
\&      my $handler = shift;
\&      my $length = shift;
\&      my $buffer;
\&      read($handler, $buffer, $length);
\&      return $buffer; # $buffer will be an empty string \*(Aq\*(Aq if read() is done
\&  }
\&
\&  # Close the handle associated with the resource.
\&  sub close_uri {
\&      my $handler = shift;
\&      close($handler);
\&  }
\&
\&  # Register them with a instance of XML::LibXML::InputCallback
\&  my $input_callbacks = XML::LibXML::InputCallback\->new();
\&  $input_callbacks\->register_callbacks([ \e&match_uri, \e&open_uri,
\&                                         \e&read_uri, \e&close_uri ] );
\&
\&  # Register the callback group at a parser instance
\&  $parser\->input_callbacks( $input_callbacks );
\&
\&  # $some_xml_file will be parsed using our callbacks
\&  $parser\->parse_file( $some_xml_file );
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0008
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::InputCallback5.18.3pm           0100644 0001750 0001750 00000036006 12566241670 026300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::InputCallback 3"
.TH XML::LibXML::InputCallback 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::InputCallback \- XML::LibXML Class for Input Callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::LibXML;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
You may get unexpected results if you are trying to load external documents
during libxml2 parsing if the location of the resource is not a \s-1HTTP, FTP\s0 or
relative location but a absolute path for example. To get around this
limitation, you may add your own input handler to open, read and close
particular types of locations or \s-1URI\s0 classes. Using this input callback
handlers, you can handle your own custom \s-1URI\s0 schemes for example.
.PP
The input callbacks are used whenever LibXML has to get something other than
externally parsed entities from somewhere. They are implemented using a
callback stack on the Perl layer in analogy to libxml2's native callback stack.
.PP
The XML::LibXML::InputCallback class transparently registers the input
callbacks for the libxml2's parser processes.
.SS "How does XML::LibXML::InputCallback work?"
.IX Subsection "How does XML::LibXML::InputCallback work?"
The libxml2 library offers a callback implementation as global functions only.
To work-around the troubles resulting in having only global callbacks \- for
example, if the same global callback stack is manipulated by different
applications running together in a single Apache Web-server environment \-,
XML::LibXML::InputCallback comes with a object-oriented and a function-oriented
part.
.PP
Using the function-oriented part the global callback stack of libxml2 can be
manipulated. Those functions can be used as interface to the callbacks on the
C\- and \s-1XS\s0 Layer. At the object-oriented part, operations for working with the
\&\*(L"pseudo-localized\*(R" callback stack are implemented. Currently, you can register
and de-register callbacks on the Perl layer and initialize them on a per parser
basis.
.PP
\fICallback Groups\fR
.IX Subsection "Callback Groups"
.PP
The libxml2 input callbacks come in groups. One group contains a \s-1URI\s0 matcher (\fImatch\fR), a data stream constructor (\fIopen\fR), a data stream reader (\fIread\fR), and a data stream destructor (\fIclose\fR). The callbacks can be manipulated on a per group basis only.
.PP
\fIThe Parser Process\fR
.IX Subsection "The Parser Process"
.PP
The parser process works on an \s-1XML\s0 data stream, along which, links to other
resources can be embedded. This can be links to external DTDs or XIncludes for
example. Those resources are identified by URIs. The callback implementation of
libxml2 assumes that one callback group can handle a certain amount of URIs and
a certain \s-1URI\s0 scheme. Per default, callback handlers for \fIfile://*\fR, \fIfile:://*.gz\fR, \fIhttp://*\fR and \fIftp://*\fR are registered.
.PP
Callback groups in the callback stack are processed from top to bottom, meaning
that callback groups registered later will be processed before the earlier
registered ones.
.PP
While parsing the data stream, the libxml2 parser checks if a registered
callback group will handle a \s-1URI \-\s0 if they will not, the \s-1URI\s0 will be
interpreted as \fIfile://URI\fR. To handle a \s-1URI,\s0 the \fImatch\fR callback will have to return '1'. If that happens, the handling of the \s-1URI\s0 will
be passed to that callback group. Next, the \s-1URI\s0 will be passed to the \fIopen\fR callback, which should return a \fIreference\fR to the data stream if it successfully opened the file, '0' otherwise. If
opening the stream was successful, the \fIread\fR callback will be called repeatedly until it returns an empty string. After the
read callback, the \fIclose\fR callback will be called to close the stream.
.PP
\fIOrganisation of callback groups in XML::LibXML::InputCallback\fR
.IX Subsection "Organisation of callback groups in XML::LibXML::InputCallback"
.PP
Callback groups are implemented as a stack (Array), each entry holds a
reference to an array of the callbacks. For the libxml2 library, the
XML::LibXML::InputCallback callback implementation appears as one single
callback group. The Perl implementation however allows one to manage different
callback stacks on a per libxml2\-parser basis.
.SS "Using XML::LibXML::InputCallback"
.IX Subsection "Using XML::LibXML::InputCallback"
After object instantiation using the parameter-less constructor, you can
register callback groups.
.PP
.Vb 7
\&  my $input_callbacks = XML::LibXML::InputCallback\->new();
\&  $input_callbacks\->register_callbacks([ $match_cb1, $open_cb1,
\&                                         $read_cb1, $close_cb1 ] );
\&  $input_callbacks\->register_callbacks([ $match_cb2, $open_cb2,
\&                                         $read_cb2, $close_cb2 ] );
\&  $input_callbacks\->register_callbacks( [ $match_cb3, $open_cb3,
\&                                          $read_cb3, $close_cb3 ] );
\&
\&  $parser\->input_callbacks( $input_callbacks );
\&  $parser\->parse_file( $some_xml_file );
.Ve
.SS "What about the old callback system prior to XML::LibXML::InputCallback?"
.IX Subsection "What about the old callback system prior to XML::LibXML::InputCallback?"
In XML::LibXML versions prior to 1.59 \- i.e. without the
XML::LibXML::InputCallback module \- you could define your callbacks either
using globally or locally. You still can do that using
XML::LibXML::InputCallback, and in addition to that you can define the
callbacks on a per parser basis!
.PP
If you use the old callback interface through global callbacks,
XML::LibXML::InputCallback will treat them with a lower priority as the ones
registered using the new interface. The global callbacks will not override the
callback groups registered using the new interface. Local callbacks are
attached to a specific parser instance, therefore they are treated with highest
priority. If the \fImatch\fR callback of the callback group registered as local variable is identical to one
of the callback groups registered using the new interface, that callback group
will be replaced.
.PP
Users of the old callback implementation whose \fIopen\fR callback returned a plain string, will have to adapt their code to return a
reference to that string after upgrading to version >= 1.59. The new callback
system can only deal with the \fIopen\fR callback returning a reference!
.SH "INTERFACE DESCRIPTION"
.IX Header "INTERFACE DESCRIPTION"
.SS "Global Variables"
.IX Subsection "Global Variables"
.ie n .IP "$_CUR_CB" 4
.el .IP "\f(CW$_CUR_CB\fR" 4
.IX Item "$_CUR_CB"
Stores the current callback and can be used as shortcut to access the callback
stack.
.ie n .IP "@_GLOBAL_CALLBACKS" 4
.el .IP "\f(CW@_GLOBAL_CALLBACKS\fR" 4
.IX Item "@_GLOBAL_CALLBACKS"
Stores all callback groups for the current parser process.
.ie n .IP "@_CB_STACK" 4
.el .IP "\f(CW@_CB_STACK\fR" 4
.IX Item "@_CB_STACK"
Stores the currently used callback group. Used to prevent parser errors when
dealing with nested \s-1XML\s0 data.
.SS "Global Callbacks"
.IX Subsection "Global Callbacks"
.IP "_callback_match" 4
.IX Item "_callback_match"
Implements the interface for the \fImatch\fR callback at C\-level and for the selection of the callback group from the
callbacks defined at the Perl-level.
.IP "_callback_open" 4
.IX Item "_callback_open"
Forwards the \fIopen\fR callback from libxml2 to the corresponding callback function at the Perl-level.
.IP "_callback_read" 4
.IX Item "_callback_read"
Forwards the read request to the corresponding callback function at the
Perl-level and returns the result to libxml2.
.IP "_callback_close" 4
.IX Item "_callback_close"
Forwards the \fIclose\fR callback from libxml2 to the corresponding callback function at the
Perl-level..
.SS "Class methods"
.IX Subsection "Class methods"
.IP "\fInew()\fR" 4
.IX Item "new()"
A simple constructor.
.ie n .IP "register_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])" 4
.el .IP "register_callbacks( [ \f(CW$match_cb\fR, \f(CW$open_cb\fR, \f(CW$read_cb\fR, \f(CW$close_cb\fR ])" 4
.IX Item "register_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
The four callbacks \fIhave\fR to be given as array reference in the above order \fImatch\fR, \fIopen\fR, \fIread\fR, \fIclose\fR!
.ie n .IP "unregister_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])" 4
.el .IP "unregister_callbacks( [ \f(CW$match_cb\fR, \f(CW$open_cb\fR, \f(CW$read_cb\fR, \f(CW$close_cb\fR ])" 4
.IX Item "unregister_callbacks( [ $match_cb, $open_cb, $read_cb, $close_cb ])"
With no arguments given, \f(CW\*(C`unregister_callbacks()\*(C'\fR will delete the last registered callback group from the stack. If four
callbacks are passed as array reference, the callback group to unregister will
be identified by the \fImatch\fR callback and deleted from the callback stack. Note that if several identical \fImatch\fR callbacks are defined in different callback groups, \s-1ALL\s0 of them will be deleted
from the stack.
.ie n .IP "init_callbacks( $parser )" 4
.el .IP "init_callbacks( \f(CW$parser\fR )" 4
.IX Item "init_callbacks( $parser )"
Initializes the callback system for the provided parser before starting a
parsing process.
.IP "\fIcleanup_callbacks()\fR" 4
.IX Item "cleanup_callbacks()"
Resets global variables and the libxml2 callback stack.
.IP "\fIlib_init_callbacks()\fR" 4
.IX Item "lib_init_callbacks()"
Used internally for callback registration at C\-level.
.IP "\fIlib_cleanup_callbacks()\fR" 4
.IX Item "lib_cleanup_callbacks()"
Used internally for callback resetting at the C\-level.
.SH "EXAMPLE CALLBACKS"
.IX Header "EXAMPLE CALLBACKS"
The following example is a purely fictitious example that uses a
MyScheme::Handler object that responds to methods similar to an IO::Handle.
.PP
.Vb 5
\&  # Define the four callback functions
\&  sub match_uri {
\&      my $uri = shift;
\&      return $uri =~ /^myscheme:/; # trigger our callback group at a \*(Aqmyscheme\*(Aq URIs
\&  }
\&
\&  sub open_uri {
\&      my $uri = shift;
\&      my $handler = MyScheme::Handler\->new($uri);
\&      return $handler;
\&  }
\&
\&  # The returned $buffer will be parsed by the libxml2 parser
\&  sub read_uri {
\&      my $handler = shift;
\&      my $length = shift;
\&      my $buffer;
\&      read($handler, $buffer, $length);
\&      return $buffer; # $buffer will be an empty string \*(Aq\*(Aq if read() is done
\&  }
\&
\&  # Close the handle associated with the resource.
\&  sub close_uri {
\&      my $handler = shift;
\&      close($handler);
\&  }
\&
\&  # Register them with a instance of XML::LibXML::InputCallback
\&  my $input_callbacks = XML::LibXML::InputCallback\->new();
\&  $input_callbacks\->register_callbacks([ \e&match_uri, \e&open_uri,
\&                                         \e&read_uri, \e&close_uri ] );
\&
\&  # Register the callback group at a parser instance
\&  $parser\->input_callbacks( $input_callbacks );
\&
\&  # $some_xml_file will be parsed using our callbacks
\&  $parser\->parse_file( $some_xml_file );
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Matt Sergeant,
Christian Glahn,
Petr Pajas
.SH "VERSION"
.IX Header "VERSION"
2.0110
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
2001\-2007, AxKit.com Ltd.
.PP
2002\-2006, Christian Glahn.
.PP
2006\-2009, Petr Pajas.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Literal.3pm                     0100644 0001750 0001750 00000011657 12566241670 024651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Literal 3"
.TH XML::LibXML::Literal 3 "2014-02-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Literal \- Simple string values.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In XPath terms a Literal is what we know as a string.
.SH "API"
.IX Header "API"
.SS "new($string)"
.IX Subsection "new($string)"
Create a new Literal object with the value in \f(CW$string\fR. Note that &quot; and
&apos; will be converted to " and ' respectively. That is not part of the XPath
specification, but I consider it useful. Note though that you have to go
to extraordinary lengths in an \s-1XML\s0 template file (be it \s-1XSLT\s0 or whatever) to
make use of this:
.PP
.Vb 1
\&        <xsl:value\-of select="&quot;I\*(Aqm feeling &amp;quot;sad&amp;quot;&quot;"/>
.Ve
.PP
Which produces a Literal of:
.PP
.Vb 1
\&        I\*(Aqm feeling "sad"
.Ve
.SS "\fIvalue()\fP"
.IX Subsection "value()"
Also overloaded as stringification, simply returns the literal string value.
.SS "cmp($literal)"
.IX Subsection "cmp($literal)"
Returns the equivalent of perl's cmp operator against the given \f(CW$literal\fR.
                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/XML::LibXML::Literal5.16.3pm                 0100644 0001750 0001750 00000011336 12566241665 025161  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.