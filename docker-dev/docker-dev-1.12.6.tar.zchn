SharedData, __NSScrollingConcurrentSwipeVBLPreprocessFilter, 
                       __NSScrollingConcurrentVBLMonitor, __NSScrollingConcurrentVBLPreprocessFilter, 
                       __NSScrollingMomentumBasCalculator, __NSScrollingMomentumCalculatorBase, 
                       __NSScrollingMomentumCatesCalculator, __NSScrollingMomentumDampenedSpringCalculator, 
                       __NSScrollingScore, __NSSegmentItemAuxiliary, __NSSegmentedCellAuxiliary, 
                       __NSServicesCarbonPrincipalMenuUpdater, __NSSizeIndicatorView, 
                       __NSSliderCellPrivateData, __NSSplitViewControllerPrivateData, 
                       __NSSplitViewItemPrivateData, __NSSplitViewItemViewWrapper, 
                       __NSSplitViewShadowView, __NSSplitViewSizeTrackingOverlayView, 
                       __NSSplitViewSpringLoadingView, __NSStackViewLayoutGuideView, 
                       __NSStackViewPrivateData, __NSStoryboardPrivateData, 
                       __NSTabViewControllerPrivateData, __NSTableGroupRowSupport, 
                       __NSTableRowIndexResolverTuple, __NSTableRowSwipeVelocityFilter, 
                       __NSTableViewAnimator, __NSTableViewDelayProxy, 
                       __NSTextFinderAsyncSearchOperation, __NSTextFinderAttributedStringProxy, 
                       __NSTextFinderImpl, __NSTextFinderOverlayWindow, 
                       __NSTextFinderReplacementStringArray, __NSTextFinderSubstringProxy, 
                       __NSTextViewBackingLayer, __NSThemeFullScreenButton, 
                       __NSThemeZoomWidget, __NSThemeZoomWidgetCell, __NSThreadedPeriodicInvoker, 
                       __NSTiledLayer, __NSTiledLayerContents, __NSTiledLayerVisibleRectObserver, 
                       __NSTitleControlCrossFadeAnimation, __NSToolbarDefaultImageRepWindow, 
                       __NSToolbarExternalDragItem, __NSTrackingRegionData, 
                       __NSTrackingRegionKey, __NSTypeSelectData, __NSViewAnimator, 
                       __NSViewAnimator_NSClipView, __NSViewAnimator_NSCollectionView, 
                       __NSViewAnimator_NSStackView, __NSViewBackingLayer, 
                       __NSViewControllerPrivateData, __NSViewLayerSurface, 
                       __NSViewLayoutAux, __NSViewNotification, __NSVisualizedConstraintsView, 
                       __NSWindowFullScreenTransition, __NSWindowManagementHelper, 
                       __NSWindowSpringLoadingController, __NSWorkspacePowerNotifier, 
                       ___NSARCWeakRef__, ___NSInspectorBarItemController, 
                       ___NSInspectorBarView, ___NSSeparatorInspectorBarItem, 
                       ___NSTextInputContextAuxiliaryStorage, ___NSTexturedPopUpButtonCell ]
  - archs:           [ x86_64 ]
    symbols:         [ '$ld$add$os10.5$_OBJC_CLASS_$_NSFileWrapper', '$ld$add$os10.5$_OBJC_CLASS_$_NSLayoutConstraint', 
                       '$ld$add$os10.5$_OBJC_METACLASS_$_NSFileWrapper', 
                       '$ld$add$os10.5$_OBJC_METACLASS_$_NSLayoutConstraint', 
                       '$ld$add$os10.6$_OBJC_CLASS_$_NSFileWrapper', '$ld$add$os10.6$_OBJC_CLASS_$_NSLayoutConstraint', 
                       '$ld$add$os10.6$_OBJC_METACLASS_$_NSFileWrapper', 
                       '$ld$add$os10.6$_OBJC_METACLASS_$_NSLayoutConstraint', 
                       '$ld$add$os10.7$_OBJC_CLASS_$_NSLayoutConstraint', 
                       '$ld$add$os10.7$_OBJC_METACLASS_$_NSLayoutConstraint', 
                       _NSActivityContinuationAllActivitiesIdentifier, 
                       _NSExtensionAvailableExtensions, _NSExtensionAvailableExtensionsChangedNotification, 
                       _NSUserActivityDocumentURLKey ]
    objc-classes:    [ _NSServicesRolloverButtonCell ]
    objc-ivars:      [ _HICocoaWindowContentView._didReceiveEvent, _HINSMenuItemProxy._action, 
                       _HINSMenuItemProxy._tag, _NSATSUStyleObject.exclusives, 
                       _NSATSUStyleObject.style, _NSAccessibilityAXUIElementWrapper._elementRef, 
                       _NSAccessibilityElement._private, _NSAccessibilityImageMockUIElement._bounds, 
                       _NSAccessibilityImageMockUIElement._description, 
                       _NSAccessibilityImageMockUIElement._help, _NSAccessibilityIndexedMockUIElement._index, 
                       _NSAccessibilityMockUIElement._parent, _NSAccessibilityMockUIElement._role, 
                       _NSAccessibilityMockUIElement._subrole, _NSAccessibilityRemoteUIElement._elementRef, 
                       _NSAccessibilityRemoteUIElement._topLevelUIElement, 
                       _NSAccessibilityRemoteUIElement._windowUIElement, 
                       _NSAccessibilityReparentingProxy._fauxParent, _NSAccessibilityReparentingProxy._realElement, 
                       _NSAccessibilityRulerMarker._marker, _NSAccessibilityScrollerPart._partCode, 
                       _NSAccessibilitySectionSearchElement._element, _NSAccessibilitySectionSearchElement._searchKeys, 
                       _NSAccessibilityStepperArrowButton._increments, 
                       _NSAccessibilityTextLink._characterRange, _NSActionCell._action, 
                       _NSActionCell._controlView, _NSActionCell._tag, 
                       _NSActionCell._target, _NSAnimationHelper._done, 
                       _NSAnimationHelper._moveTimer, _NSAnimationHelper._moveTimerFiringInterval, 
                       _NSAnimationHelper._runLoop, _NSAnimationHelper._startTime, 
                       _NSAnimationHelper._totalTime, _NSAnimationInfo._effect, 
                       _NSAnimationInfo._endFrame, _NSAnimationInfo._lastFrame, 
                       _NSAnimationInfo._startFrame, _NSAnimationInfo._viewImage, 
                       _NSAnimationInfo._viewImageAlignmentRect, _NSApplication._appFlags, 
                       _NSApplication._appIcon, _NSApplication._appleEventSuspensionID, 
                       _NSApplication._context, _NSApplication._currentEvent, 
                       _NSApplication._delegate, _NSApplication._eventDelegate, 
                       _NSApplication._hiddenCount, _NSApplication._hiddenList, 
                       _NSApplication._keyWindow, _NSApplication._mainMenu, 
                       _NSApplication._mainWindow, _NSApplication._previousKeyWindow, 
                       _NSApplication._running, _NSApplication._threadingSupport, 
                       _NSApplication._unused, _NSApplication._unusedApp, 
                       _NSApplication._windowList, _NSApplicationExtensionItem._storageDictionary, 
                       _NSArrayDetailBinder._arrayDetailBinderFlags, _NSAttachmentTextStorage._realTS, 
                       _NSBinder._bindingsBoundMask, _NSBinder._expectedObservingInfo, 
                       _NSBinder._plugin, _NSBitmapGraphicsContext._bgcFlags, 
                       _NSBitmapGraphicsContext._imageRep, _NSBitmapImageRep._bytesPerRow, 
                       _NSBitmapImageRep._dataObj, _NSBitmapImageRep._moreRepFlags, 
                       _NSBitmapImageRep._properties, _NSBitmapImageRep._tiffData, 
                       _NSBox._bFlags, _NSBox._borderRect, _NSBox._contentView, 
                       _NSBox._offsets, _NSBox._titleCell, _NSBox._titleRect, 
                       _NSBox._unused, _NSBoxAuxiliary.borderColor, _NSBoxAuxiliary.borderWidth, 
                       _NSBoxAuxiliary.cornerRadius, _NSBoxAuxiliary.fillColor, 
                       _NSBrowser._brAuxiliaryStorage, _NSBrowser._brflags, 
                       _NSBrowser._cellPrototype, _NSBrowser._columnSize, 
                       _NSBrowser._columns, _NSBrowser._delegate, _NSBrowser._doubleAction, 
                       _NSBrowser._firstColumnTitle, _NSBrowser._firstVisibleColumn, 
                       _NSBrowser._matrixClass, _NSBrowser._maxVisibleColumns, 
                       _NSBrowser._minColumnWidth, _NSBrowser._nsreserved2, 
                       _NSBrowser._nsreserved3, _NSBrowser._numberOfVisibleColumns, 
                       _NSBrowser._pathSeparator, _NSBrowser._scroller, 
                       _NSBrowser._titles, _NSBrowserBinder._browserBinderFlags, 
                       _NSBrowserBinder._selectedIndexPaths, _NSBrowserBinder._treeNodeObservingTracker, 
                       _NSButtonCell._altContents, _NSButtonCell._alternateImageOrKeyEquivalentFont, 
                       _NSButtonCell._bcFlags, _NSButtonCell._bcFlags2, 
                       _NSButtonCell._keyEquivalent, _NSButtonCell._normalImage, 
                       _NSButtonCell._periodicDelay, _NSButtonCell._periodicInterval, 
                       _NSButtonCell._sound, _NSCGImageRep._cgImage, _NSCGImageRep.reserved1, 
                       _NSCGImageRep.reserved2, _NSCGImageRep.reserved3, 
                       _NSCGImageRep.reserved4, _NSCGSContext._cgsContext, 
                       _NSCIImageRep._ciImage, _NSCMYKSliders.blackSlider, 
                       _NSCMYKSliders.blackText, _NSCMYKSliders.cmykView, 
                       _NSCMYKSliders.cyanSlider, _NSCMYKSliders.cyanText, 
                       _NSCMYKSliders.magentaSlider, _NSCMYKSliders.magentaText, 
                       _NSCMYKSliders.yellowSlider, _NSCMYKSliders.yellowText, 
                       _NSCachedImageRep._cache, _NSCachedImageRep._origin, 
                       _NSCachedImageRep._window, _NSCalibratedRGBColor._cachedCGColor, 
                       _NSCalibratedRGBColor.alphaComponent, _NSCalibratedRGBColor.blueComponent, 
                       _NSCalibratedRGBColor.greenComponent, _NSCalibratedRGBColor.redComponent, 
                       _NSCalibratedWhiteColor._cachedCGColor, _NSCalibratedWhiteColor.alphaComponent, 
                       _NSCalibratedWhiteColor.whiteComponent, _NSCallbackDictionary._context, 
                       _NSCallbackDictionary._delegate, _NSCallbackDictionary._keyToSelectorMap, 
                       _NSCarbonMenuImpl._checkoutTokens, _NSCarbonMenuImpl._extraVars, 
                       _NSCarbonMenuImpl._initialMenuRef, _NSCarbonMenuImpl._mFlags, 
                       _NSCarbonMenuImpl._menu, _NSCarbonMenuImpl._menuEventHandler, 
                       _NSCarbonMenuImpl._principalMenuRef, _NSCarbonMenuImpl.currentMenuUpdateFlags, 
                       _NSCarbonMenuImpl.customContentDrawingClientCount, 
                       _NSCarbonMenuImpl.customTextDrawingClientCount, 
                       _NSCarbonMenuImpl.customViewClientCount, _NSCarbonMenuImpl.lastHighlightedItem, 
                       _NSCatalogColor.catalogNameComponent, _NSCatalogColor.colorNameComponent, 
                       _NSCatalogColor.genericColor, _NSCell._cFlags, _NSCell._contents, 
                       _NSCellAuxiliary._currentDragEventTracker, _NSCellAuxiliary.auxCFlags, 
                       _NSCellAuxiliary.cachedAttributedStringGeneration, 
                       _NSCellAuxiliary.cachedAttributedStringValue, _NSCellAuxiliary.controlView, 
                       _NSCellAuxiliary.formatter, _NSCellAuxiliary.image, 
                       _NSCellAuxiliary.menu, _NSCellAuxiliary.representedObject, 
                       _NSCellAuxiliary.textAttributes, _NSCellAuxiliary.userInterfaceItemIdentifier, 
                       _NSCellUndoManager._nextUndoManager, _NSClipView._backgroundColor, 
                       _NSClipView._cursor, _NSClipView._cvFlags, _NSClipView._docRect, 
                       _NSClipView._docView, _NSClipView._oldDocFrame, 
                       _NSClipView._scrollAnimationHelper, _NSColorList._clAuxiliaryStorage, 
                       _NSColorList._colorArray, _NSColorList._fileName, 
                       _NSColorList._flags, _NSColorList._keyArray, _NSColorList._keyToIndexTable, 
                       _NSColorList._name, _NSColorList._printerType, _NSColorListAuxiliary._bundleForColorListDirectory, 
                       _NSColorListAuxiliary._cmPageInfoPtr, _NSColorListAuxiliary._lastEditableCheck, 
                       _NSColorListAuxiliary._localizedCopyRightString, 
                       _NSColorPanel._accessoryContainerView, _NSColorPanel._accessoryContainerViewHeight, 
                       _NSColorPanel._accessoryView, _NSColorPanel._action, 
                       _NSColorPanel._allowColorSetting, _NSColorPanel._bottomConstraint, 
                       _NSColorPanel._colorSwatch, _NSColorPanel._colorWell, 
                       _NSColorPanel._continuous, _NSColorPanel._currViewObject, 
                       _NSColorPanel._customPickerList, _NSColorPanel._customViewsList, 
                       _NSColorPanel._handlingOpacityMoveAction, _NSColorPanel._ignoreConstraints, 
                       _NSColorPanel._magnifyButton, _NSColorPanel._maxColorPanelSize, 
                       _NSColorPanel._middleView, _NSColorPanel._minColorPanelSize, 
                       _NSColorPanel._modalButtons, _NSColorPanel._opacitySlider, 
                       _NSColorPanel._opacityText, _NSColorPanel._opacityTextController, 
                       _NSColorPanel._opacityView, _NSColorPanel._opacityViewHeight, 
                       _NSColorPanel._pickerView, _NSColorPanel._pickersWithLoadedViews, 
                       _NSColorPanel._reserved1, _NSColorPanel._reserved2, 
                       _NSColorPanel._reserved3, _NSColorPanel._reserved4, 
                       _NSColorPanel._reserved5, _NSColorPanel._resizeDimple, 
                       _NSColorPanel._stillInitializing, _NSColorPanel._target, 
                       _NSColorPanelColorWell._actsLikeButton, _NSColorPanelColorWell._controlSize, 
                       _NSColorPanelColorWell._disabledAsColorDestination, 
                       _NSColorPicker._buttonToolTip, _NSColorPicker._colorPanel, 
                       _NSColorPicker._imageObject, _NSColorPickerSliders.cmykSliders, 
                       _NSColorPickerSliders.colorProfileButton, _NSColorPickerSliders.currViewObject, 
                       _NSColorPickerSliders.greySliders, _NSColorPickerSliders.hsbSliders, 
                       _NSColorPickerSliders.modeMask, _NSColorPickerSliders.rgbSliders, 
                       _NSColorPickerSliders.sliderContainer, _NSColorPickerSliders.sliderModePopUp, 
                       _NSColorPickerSliders.slidersView, _NSColorPickerUser.bScaleOrNot, 
                       _NSColorPickerUser.currImageName, _NSColorPickerUser.defaultTiffImage, 
                       _NSColorPickerUser.imageDictionary, _NSColorPickerUser.optionsPopUp, 
                       _NSColorPickerUser.palettePopUpButton, _NSColorPickerUser.paste, 
                       _NSColorPickerUser.removeField, _NSColorPickerUser.renameField, 
                       _NSColorPickerUser.renamePanelController, _NSColorPickerUser.reserved1, 
                       _NSColorPickerUser.reserved2, _NSColorPickerUser.spectrumMenuItem, 
                       _NSColorPickerUser.tiffView, _NSColorPickerUser.userPickerView, 
                       _NSColorPickerUserView._imageForLockFocusUse, _NSColorPickerUserView.colorPanel, 
                       _NSColorPickerUserView.controllingPicker, _NSColorPickerUserView.currImage, 
                       _NSColorPickerUserView.currentPt, _NSColorPickerWheel.brightnessSlider, 
                       _NSColorPickerWheel.containerView, _NSColorPickerWheel.previouslyTracking, 
                       _NSColorPickerWheel.wheelView, _NSColorPickerWheelView.brightness, 
                       _NSColorPickerWheelView.colorPanel, _NSColorPickerWheelView.controllingPicker, 
                       _NSColorPickerWheelView.currentPt, _NSColorPickerWheelView.displayWheelImage, 
                       _NSColorPickerWheelView.tracking, _NSColorProfile._dProfileRef, 
                       _NSColorProfile._header, _NSColorProfile._location, 
                       _NSColorProfile._md5, _NSColorProfile._name, _NSColorProfile._profile, 
                       _NSColorProfile._reserved, _NSColorScaleSliderCell._flippedHorizontally, 
                       _NSColorScaleSliderCell._scaleBitmap, _NSColorScaleSliderCell._scaleBitmapValid, 
                       _NSColorScaleSliderCell._scaleColor, _NSColorScaleSliderCell._scaleType, 
                       _NSColorSpace.__cgColorSpace, _NSColorSpace.__cgColorTransform, 
                       _NSColorSpace._flags, _NSColorSpace._profile, _NSColorSpace._reserved, 
                       _NSColorSpaceColor._cachedCGColor, _NSColorSpaceColor.colorSpace, 
                       _NSColorSpaceColor.components, _NSColorSpaceColor.numComponents, 
                       _NSColorSpaceSliders.activeColorSpace, _NSColorSpaceSliders.colorPanel, 
                       _NSColorSpaceSliders.controllingPicker, _NSColorSwatch._currentHeightConstraint, 
                       _NSColorSwatch.colorPanel, _NSColorSwatch.colors, 
                       _NSColorSwatch.currentHighlight, _NSColorSwatch.draggedColorIndex, 
                       _NSColorSwatch.focusedColor, _NSColorSwatch.mousedColor, 
                       _NSColorSwatch.numRowsToToggleVisible, _NSColorWell._color, 
                       _NSColorWell._cwFlags, _NSColorWell._reserved, _NSColorWell._reserved2, 
                       _NSComboBox._dataSource, _NSComboBoxCell._buttonCell, 
                       _NSComboBoxCell._cbcFlags, _NSComboBoxCell._cellFrame, 
                       _NSComboBoxCell._dataSource, _NSComboBoxCell._delegate, 
                       _NSComboBoxCell._popUp, _NSComboBoxCell._popUpList, 
                       _NSComboBoxCell._reserved, _NSComboBoxCell._scrollView, 
                       _NSComboBoxCell._tableView, _NSComboBoxWindow._attachedToParent, 
                       _NSComboBoxWindow._comboBoxCell, _NSComboTableView._lastReturnedNumberOfRows, 
                       _NSCompositeImageRep._baseFrame, _NSCompositeImageRep._baseImage, 
                       _NSCompositeImageRep._overlayFrame, _NSCompositeImageRep._overlayImage, 
                       _NSCompositeImageRep._translation, _NSControl._aux, 
                       _NSControl._cell, _NSControl._conFlags, _NSControlAuxiliary._action, 
                       _NSControlAuxiliary._flags, _NSControlAuxiliary._tag, 
                       _NSControlAuxiliary._target, _NSController._expectedObservingInfo, 
                       _NSController._modelObservingTracker, _NSController._singleValueAccessor, 
                       _NSControllerConfigurationBinder._controllerConfigurationBinderFlags, 
                       _NSCoreDragManager._dragSession, _NSCoreDragManager.applicationHandlerRef, 
                       _NSCoreUIImageRep._coreUIImageOptions, _NSCoreUIImageRep._preferredAppearance, 
                       _NSCursor._flags, _NSCursor._hotSpot, _NSCursor._image, 
                       _NSCustomImageRep._drawMethod, _NSCustomImageRep._drawObject, 
                       _NSCustomImageRep._reserved, _NSCustomReleaseData._bytes, 
                       _NSCustomReleaseData._length, _NSCustomReleaseData._releaseBytesBlock, 
                       _NSDataAsset._namedData, _NSDataDetectionIndicatorView._dataResult, 
                       _NSDataDetectionIndicatorView._range, _NSDataDetectionIndicatorView._string, 
                       _NSDataDetectionIndicatorView._textView, _NSDataDetectionIndicatorView._trackingArea, 
                       _NSDeviceCMYKColor._cachedCGColor, _NSDeviceCMYKColor.alphaComponent, 
                       _NSDeviceCMYKColor.blackComponent, _NSDeviceCMYKColor.cyanComponent, 
                       _NSDeviceCMYKColor.magentaComponent, _NSDeviceCMYKColor.yellowComponent, 
                       _NSDockMiniViewController._contextid, _NSDockMiniViewController._view, 
                       _NSDockMiniViewController._window, _NSDockMiniViewWindow.shown, 
                       _NSDocumentDragButton._ddbFlags, _NSDocumentDragButton.mouseDownEvent, 
                       _NSDocumentDragButton.representedURL, _NSDocumentTextAttachmentScrollView._charIndex, 
                       _NSDocumentTextAttachmentScrollView._expandedView, 
                       _NSDocumentTextAttachmentScrollView._imageView, 
                       _NSDocumentTextAttachmentScrollView._isExpanded, 
                       _NSDocumentTextAttachmentScrollView._layoutManager, 
                       _NSDownloadController._alert, _NSDownloadController._autoOpen, 
                       _NSDownloadController._contentType, _NSDownloadController._didEndSelector, 
                       _NSDownloadController._downloadInfo, _NSDownloadController._filename, 
                       _NSDownloadController._informativeText, _NSDownloadController._messageText, 
                       _NSDownloadController._mimeType, _NSDownloadController._modalDelegate, 
                       _NSDownloadController._reserved, _NSDownloadController._riskCategory, 
                       _NSDownloadController._useSave, _NSDownloadController.reserved1, 
                       _NSDragDestination._deviceID, _NSDragDestination._drag, 
                       _NSDragDestination._dragCompletionTargets, _NSDragDestination._finalSlideLocation, 
                       _NSDragDestination._flags, _NSDragDestination._lastDragDestinationOperation, 
                       _NSDragDestination._lastDragLocation, _NSDragDestination._lastDragTimestamp, 
                       _NSDragDestination._lastSpringLoadingOptions, _NSDragDestination._pasteboardName, 
                       _NSDragDestination._respondsToSelector, _NSDragDestination._runLoop, 
                       _NSDragDestination._springLoadingHighlight, _NSDragDestination._target, 
                       _NSDragDestination._updateDraggingItemsTimerValid, 
                       _NSDragDestination._updateTimer, _NSDragDestination._window, 
                       _NSDragDestination.receiveHandlerRef, _NSDragDestination.trackingHandlerRef, 
                       _NSDrawer._drawerDelegate, _NSDrawer._drawerEdge, 
                       _NSDrawer._drawerFlags, _NSDrawer._drawerLeadingOffset, 
                       _NSDrawer._drawerLock, _NSDrawer._drawerLoop, _NSDrawer._drawerNextEdge, 
                       _NSDrawer._drawerNextParentWindow, _NSDrawer._drawerNextState, 
                       _NSDrawer._drawerObserver, _NSDrawer._drawerParentWindow, 
                       _NSDrawer._drawerPercent, _NSDrawer._drawerPercentSaved, 
                       _NSDrawer._drawerPreferredEdge, _NSDrawer._drawerSaveName, 
                       _NSDrawer._drawerStartTime, _NSDrawer._drawerState, 
                       _NSDrawer._drawerTimer, _NSDrawer._drawerTotalTime, 
                       _NSDrawer._drawerTrailingOffset, _NSDrawer._drawerWindow, 
                       _NSDrawerFrame.drawerBackground, _NSDrawerFrame.drawerEdge, 
                       _NSDrawerFrame.registeredForEdgeChanges, _NSDrawerFrame.shouldInvalidateShadow, 
                       _NSDrawerFrame.trackingTag, _NSDrawerWindow._drawer, 
                       _NSDrawerWindow._drawerParentWindow, _NSEPSImageRep._bBoxOrigin, 
                       _NSEPSImageRep._epsData, _NSEPSImageRep._pdfImageRep, 
                       _NSEditableBinder._editableBinderFlags, _NSEvent._WSTimestamp, 
                       _NSEvent._context, _NSEvent._data, _NSEvent._eventRef, 
                       _NSEvent._location, _NSEvent._modifierFlags, _NSEvent._timestamp, 
                       _NSEvent._type, _NSEvent._window, _NSEvent._windowNumber, 
                       _NSEvent.reserved1, _NSEvent.reserved2, _NSEventAuxiliary.cgEventRef, 
                       _NSEventAuxiliary.touches, _NSExtraMICData.item, 
                       _NSExtraMICData.keUniquer, _NSExtraMIData._image, 
                       _NSExtraMIData.actionBlock, _NSExtraMIData.alternateAttributedTitle, 
                       _NSExtraMIData.attributedTitle, _NSExtraMIData.attributedTitleHasAttachment, 
                       _NSExtraMIData.bindingAdaptor, _NSExtraMIData.cachedAttributedTitleHeightForDrawing, 
                       _NSExtraMIData.cachedAttributedTitleSize, _NSExtraMIData.defaultKEPriority, 
                       _NSExtraMIData.font, _NSExtraMIData.menuItemViewer, 
                       _NSExtraMIData.mixedStateImage, _NSExtraMIData.newItemsCount, 
                       _NSExtraMIData.offStateImage, _NSExtraMIData.onStateImage, 
                       _NSExtraMIData.tooltip, _NSExtraMIData.userKE, _NSExtraMIData.userKEMask, 
                       _NSExtraMIData.virtualKeyCode, _NSFilePromiseDragSource._dragEnded, 
                       _NSFilePromiseDragSource._dragSource, _NSFilePromiseDragSource._dropDestination, 
                       _NSFilePromiseDragSource._filenames, _NSFilePromiseDragSource._typeCount, 
                       _NSFilterServicesPasteboard._data, _NSFilterServicesPasteboard._pb, 
                       _NSFilterServicesPasteboard._type, _NSFindPanel._caseInsensitiveSearchDefault, 
                       _NSFindPanel._fe, _NSFindPanel._findComboBox, _NSFindPanel._findNextButton, 
                       _NSFindPanel._findPreviousButton, _NSFindPanel._ignoreCaseButton, 
                       _NSFindPanel._lastFindWasSuccessful, _NSFindPanel._matchPopUp, 
                       _NSFindPanel._numberOfRecentStrings, _NSFindPanel._recentFindOptions, 
                       _NSFindPanel._recentFindStrings, _NSFindPanel._recentReplaceStrings, 
                       _NSFindPanel._replaceAllButton, _NSFindPanel._replaceAndFindButton, 
                       _NSFindPanel._replaceButton, _NSFindPanel._replaceComboBox, 
                       _NSFindPanel._statusField, _NSFindPanel._substringMatchDefault, 
                       _NSFindPanel._wrapAroundButton, _NSFindPattern.allowsBackreferences, 
                       _NSFindPattern.captureGroupID, _NSFindPattern.displayString, 
                       _NSFindPattern.groupID, _NSFindPattern.regularExpression, 
                       _NSFindPattern.repeatedPatternID, _NSFindPattern.replacementString, 
                       _NSFindPattern.tokenString, _NSFindPattern.uniqueID, 
                       _NSFloatRange._length, _NSFloatRange._location, 
                       _NSFocusState.clipEmpty, _NSFocusState.clipSet, 
                       _NSFocusState.specialGStateViews, _NSFocusState.theClip, 
                       _NSFocusState.window, _NSFontEffectsBox._angleDial, 
                       _NSFontEffectsBox._angleLabel, _NSFontEffectsBox._attributesToAdd, 
                       _NSFontEffectsBox._attributesToRemove, _NSFontEffectsBox._blurSlider, 
                       _NSFontEffectsBox._colorState, _NSFontEffectsBox._documentColorButton, 
                       _NSFontEffectsBox._febFlags, _NSFontEffectsBox._febUnused, 
                       _NSFontEffectsBox._mainControlsBox, _NSFontEffectsBox._mainEffectsBox, 
                       _NSFontEffectsBox._opacitySlider, _NSFontEffectsBox._radiusSlider, 
                       _NSFontEffectsBox._shadowAngleDialToolbarItem, _NSFontEffectsBox._shadowBlur, 
                       _NSFontEffectsBox._shadowBlurSliderToolbarItem, 
                       _NSFontEffectsBox._shadowControlsBox, _NSFontEffectsBox._shadowOffsetSliderToolbarItem, 
                       _NSFontEffectsBox._shadowOpacitySliderToolbarItem, 
                       _NSFontEffectsBox._shadowToggleButton, _NSFontEffectsBox._strikeButton, 
                       _NSFontEffectsBox._textColorButton, _NSFontEffectsBox._underlineButton, 
                       _NSFontPanel._accessoryView, _NSFontPanel._actionButton, 
                       _NSFontPanel._addCollectionButton, _NSFontPanel._availableSizes, 
                       _NSFontPanel._carbonNotification, _NSFontPanel._collectionLabel, 
                       _NSFontPanel._collectionNames, _NSFontPanel._editSizeList, 
                       _NSFontPanel._editSizeListBox, _NSFontPanel._editSizeSliderBox, 
                       _NSFontPanel._editSizeSliderMaxField, _NSFontPanel._editSizeSliderMinField, 
                       _NSFontPanel._faceDivider, _NSFontPanel._faceList, 
                       _NSFontPanel._familyLabel, _NSFontPanel._familyList, 
                       _NSFontPanel._fixedListButton, _NSFontPanel._fontEffectsBox, 
                       _NSFontPanel._fontPanelPreviewHeight, _NSFontPanel._fpFlags, 
                       _NSFontPanel._fullSizeHeightConstraint, _NSFontPanel._mainCollectionList, 
                       _NSFontPanel._mainSplitView, _NSFontPanel._manager, 
                       _NSFontPanel._miniModeBox, _NSFontPanel._mmCollectionList, 
                       _NSFontPanel._mmFaceList, _NSFontPanel._mmFamilyList, 
                       _NSFontPanel._mmSizeList, _NSFontPanel._newSizeField, 
                       _NSFontPanel._preview, _NSFontPanel._previewContainer, 
                       _NSFontPanel._regularModeBox, _NSFontPanel._removeCollectionButton, 
                       _NSFontPanel._searchField, _NSFontPanel._selection, 
                       _NSFontPanel._sizeBox, _NSFontPanel._sizeEditWindow, 
                       _NSFontPanel._sizeField, _NSFontPanel._sizeLabel, 
                       _NSFontPanel._sizeList, _NSFontPanel._sizeSlider, 
                       _NSFontPanel._sizeSliderBox, _NSFontPanel._sizeStyle, 
                       _NSFontPanel._sizeStyleButton, _NSFontPanel._sliderButton, 
                       _NSFontPanel._targetObject, _NSFontPanel._typographyPanel, 
                       _NSForceClickMonitor._action, _NSForceClickMonitor._allowableMovement, 
                       _NSForceClickMonitor._animationStartTime, _NSForceClickMonitor._flags, 
                       _NSForceClickMonitor._location, _NSForceClickMonitor._maxProgress, 
                       _NSForceClickMonitor._progress, _NSForceClickMonitor._startEvent, 
                       _NSForceClickMonitor._startLocation, _NSForceClickMonitor._state, 
                       _NSForceClickMonitor._target, _NSFormCell._preferredTextFieldWidth, 
                       _NSFormCell._titleCell, _NSFormCell._titleEndPoint, 
                       _NSFormCell._titleWidth, _NSFrameView.___available_for_whatever, 
                       _NSFrameView.__unusedShadowState, _NSFrameView._title, 
                       _NSFrameView.closeButton, _NSFrameView.edgeResizingTrackingAreas, 
                       _NSFrameView.minimizeButton, _NSFrameView.resizeByIncrement, 
                       _NSFrameView.resizeParameter, _NSFrameView.styleMask, 
                       _NSFrameView.tabViewCount, _NSFrameView.titleCell, 
                       _NSFrameView.zoomButton, _NSGreySliders.alphaButtonsAreHidden, 
                       _NSGreySliders.greyButtons, _NSGreySliders.greySlider, 
                       _NSGreySliders.greyText, _NSGreySliders.greyView, 
                       _NSGreySliders.opacityButtons, _NSGreySliders.opacityDistanceFromBottom, 
                       _NSHSBSliders.backgroundColor, _NSHSBSliders.brightnessSlider, 
                       _NSHSBSliders.brightnessText, _NSHSBSliders.currColor, 
                       _NSHSBSliders.hsbView, _NSHSBSliders.hueSlider, 
                       _NSHSBSliders.hueText, _NSHSBSliders.saturationSlider, 
                       _NSHSBSliders.saturationText, _NSHSBSliders.sliderMatrix, 
                       _NSHelpAttachment.fileName, _NSHelpAttachment.markerName, 
                       _NSHelpManager._bundleMapTable, _NSHelpManager._evtWindow, 
                       _NSHelpManager._helpBundle, _NSHelpManager._helpMapTable, 
                       _NSHelpManager._helpWindow, _NSHelpManager._keyMapTable, 
                       _NSHelpManager._shadowWindow, _NSHyphenator.exceptionsTable, 
                       _NSHyphenator.maxPatternLength, _NSHyphenator.patternMemory, 
                       _NSHyphenator.patternTable, _NSIBObjectDataAuxilary.shouldEncodeDesigntimeData, 
                       _NSIBUserDefinedRuntimeAttributesConnector.keyPaths, 
                       _NSIBUserDefinedRuntimeAttributesConnector.object, 
                       _NSIBUserDefinedRuntimeAttributesConnector.values, 
                       _NSIconRefImageRep._fallbackBitmap, _NSIconRefImageRep._iconRef, 
                       _NSIconRefImageRep._scaleIdentifier, _NSIconRefImageRep._sizeIdentifier, 
                       _NSImage._flags, _NSImage._imageAuxiliary, _NSImage._name, 
                       _NSImage._reps, _NSImage._size, _NSImageCacheView._threadEntries, 
                       _NSImageCacheView.isOpaque, _NSImageCell._animationState, 
                       _NSImageCell._controlView, _NSImageCell._icFlags, 
                       _NSImageCell._scaledImage, _NSImageIconRefRepProvider._iconRef, 
                       _NSImageIconRefRepProvider._includeThumbnail, _NSImageIconRefRepProvider._representations, 
                       _NSImageKitViewTextAttachmentCellHelper._charIndex, 
                       _NSImageMultiURLReferencingRepProvider._representations, 
                       _NSImageMultiURLReferencingRepProvider._urls, _NSImageRep._colorSpaceName, 
                       _NSImageRep._pixelsHigh, _NSImageRep._pixelsWide, 
                       _NSImageRep._repFlags, _NSImageRep._size, _NSImageURLReferencingRepProvider._representations, 
                       _NSImageURLReferencingRepProvider._url, _NSImageView._action, 
                       _NSImageView._ivFlags, _NSImageView._target, _NSInputAlignmentController._delegate, 
                       _NSInputAlignmentController._reserved0, _NSInputAlignmentController._sessions, 
                       _NSInputAlignmentFilter._cumulativeMovementSinceLastAlignment, 
                       _NSInputAlignmentFilter._currentLocation, _NSInputAlignmentFilter._currentTimestamp, 
                       _NSInputAlignmentFilter._flags, _NSInputAlignmentFilter._lastAlignmentDistance, 
                       _NSInputAlignmentFilter._lastMovementTimestamp, 
                       _NSInputAlignmentFilter._modifierFlags, _NSInputAlignmentFilter._movementSinceLastAlignment, 
                       _NSInputAlignmentFilter._periodicUpdateTimer, _NSInputAlignmentFilter._references, 
                       _NSInputAlignmentFilter._reserved0, _NSInputAlignmentFilter._reserved1, 
                       _NSInputAlignmentFilter._velocityFilter, _NSInputAlignmentGuide._guideType, 
                       _NSInputAlignmentGuide._referenceValues, _NSInputClientWrapper._lastRange, 
                       _NSInputClientWrapper._lastString, _NSInputClientWrapper._realClient, 
                       _NSInputServer._delegate, _NSInputServer._name, 
                       _NSInspectorBar._inspectorBarView, _NSKeyBindingAtom.key, 
                       _NSKeyBindingAtom.mask, _NSKeyboardShortcut._keyEquivalent, 
                       _NSKeyboardShortcut._modifierMask, _NSKitPanelController.panel, 
                       _NSLSNotificationHelperCountedSet._dictionary, _NSLSNotificationHelperWeakArray._observers, 
                       _NSLazyBrowserList.count, _NSMatrix._backgroundColor, 
                       _NSMatrix._cellClass, _NSMatrix._cellSize, _NSMatrix._cells, 
                       _NSMatrix._delegate, _NSMatrix._doubleAction, _NSMatrix._errorAction, 
                       _NSMatrix._font, _NSMatrix._intercell, _NSMatrix._mFlags, 
                       _NSMatrix._numCols, _NSMatrix._numRows, _NSMatrix._private, 
                       _NSMatrix._protoCell, _NSMatrix._reserved2, _NSMatrix._reserved3, 
                       _NSMatrix._selectedCell, _NSMatrix._selectedCol, 
                       _NSMatrix._selectedRow, _NSMenuCustomCarbonEventHandler.blockGetter, 
                       _NSMenuCustomCarbonEventHandler.eventHandlerRef, 
                       _NSMenuCustomCarbonEventHandler.eventSpecs, _NSMenuCustomCarbonEventHandler.handlerBlock, 
                       _NSMenuCustomCarbonEventHandler.menuImpl, _NSMenuCustomCarbonEventHandler.nextHandler, 
                       _NSMenuCustomCarbonEventHandler.specCount, _NSMenuKEUniquer.keyTable, 
                       _NSMenuKEUniquer.lock, _NSMenuTemplate.cMenuClassName, 
                       _NSMenuTemplate.disabled, _NSMenuTemplate.extension, 
                       _NSMenuTemplate.interfaceStyle, _NSMenuTemplate.isFontMenu, 
                       _NSMenuTemplate.isRequestMenu, _NSMenuTemplate.isWindowsMenu, 
                       _NSMenuTemplate.location, _NSMenuTemplate.menuClassName, 
                       _NSMenuTemplate.popupCell, _NSMenuTemplate.realObject, 
                       _NSMenuTemplate.supermenu, _NSMenuTemplate.title, 
                       _NSMenuTemplate.view, _NSMetalPatternColor._bottomHeight, 
                       _NSMetalPatternColor._pattern, _NSMetalPatternColor._style, 
                       _NSMetalPatternColor._topHeight, _NSMetalPatternColor._windowBounds, 
                       _NSMovieViewTextAttachmentCell._movie, _NSMovieViewTextAttachmentCell._size, 
                       _NSMultiplePagePDFImageView._imageRep, _NSMultiplePagePDFImageViewTextAttachmentCell._isExpanded, 
                       _NSNavAdvancedSearchController._addingAnyAttributeItem, 
                       _NSNavAdvancedSearchController._anyAttributeMenuItem, 
                       _NSNavAdvancedSearchController._availableSearchAttributes, 
                       _NSNavAdvancedSearchController._booleanOptionsView, 
                       _NSNavAdvancedSearchController._canShowAttributes, 
                       _NSNavAdvancedSearchController._dateOptionsView, 
                       _NSNavAdvancedSearchController._delegate, _NSNavAdvancedSearchController._editSearchTermsWindow, 
                       _NSNavAdvancedSearchController._extraRootItems, 
                       _NSNavAdvancedSearchController._keywordsComboBox, 
                       _NSNavAdvancedSearchController._keywordsTokenField, 
                       _NSNavAdvancedSearchController._kindPopUpButton, 
                       _NSNavAdvancedSearchController._kindsComboBox, _NSNavAdvancedSearchController._numberOptionsView, 
                       _NSNavAdvancedSearchController._plainTextFieldView, 
                       _NSNavAdvancedSearchController._rootItem, _NSNavAdvancedSearchController._ruleEditor, 
                       _NSNavAdvancedSearchController._ruleItemsView, _NSNavAdvancedSearchController._saveAsTextField, 
                       _NSNavAdvancedSearchController._saveForAllAppsButton, 
                       _NSNavAdvancedSearchController._saveQueryButton, 
                       _NSNavAdvancedSearchController._saveSearchWindow, 
                       _NSNavAdvancedSearchController._searchKeywords, 
                       _NSNavAdvancedSearchController._searchKeywordsQuery, 
                       _NSNavAdvancedSearchController._searchKindQuery, 
                       _NSNavAdvancedSearchController._searchKinds, _NSNavAdvancedSearchController._searchTermsArrayController, 
                       _NSNavAdvancedSearchController._seperatorAdded, 
                       _NSNavAdvancedSearchController._textFieldWithOptionsView, 
                       _NSNavAdvancedSearchController._updateCount, _NSNavBrowserCell._controlView, 
                       _NSNavBrowserCell._nbcFlags, _NSNavBrowserCell._node, 
                       _NSNavBrowserDelegate._browser, _NSNavBrowserDelegate._lastSelectedNode, 
                       _NSNavDataSource._allowsExpandingMultipleDirectories, 
                       _NSNavDataSource._allowsMultipleSelection, _NSNavDataSource._calculatesAllSizes, 
                       _NSNavDataSource._canClickDisabledFiles, _NSNavDataSource._creatingDelegate, 
                       _NSNavDataSource._currentHistoryPosition, _NSNavDataSource._expandedNodes, 
                       _NSNavDataSource._fileDelegates, _NSNavDataSource._fileListMode, 
                       _NSNavDataSource._fileListOrderedByFileProperty, 
                       _NSNavDataSource._history, _NSNavDataSource._isFileListOrderedCaseSensitive, 
                       _NSNavDataSource._isFileListOrderedDescending, _NSNavDataSource._isReloading, 
                       _NSNavDataSource._lastFileListMode, _NSNavDataSource._lastNonNaughtFileListMode, 
                       _NSNavDataSource._makeHistoryDisabledCount, _NSNavDataSource._navNodeClass, 
                       _NSNavDataSource._navView, _NSNavDataSource._padding, 
                       _NSNavDataSource._replacedNodes, _NSNavDataSource._resolvesAliases, 
                       _NSNavDataSource._rootNode, _NSNavDataSource._showsHiddenFiles, 
                       _NSNavDataSource._sortedChildren, _NSNavDataSource._treatsDirectoryAliasesAsDirectories, 
                       _NSNavDataSource._treatsFilePackagesAsDirectories, 
                       _NSNavFBENode._clearRegisteredForAttributes, _NSNavFBENode._fbeNode, 
                       _NSNavFileListDelegate._currentBrowsingNodePath, 
                       _NSNavFileListDelegate._dataSource, _NSNavHistoryState._currentBrowsingNodePath, 
                       _NSNavHistoryState._fileListMode, _NSNavNameFieldFormatter._autoAddExtensionToNextInput, 
                       _NSNavNameFieldFormatter._panel, _NSNavNaughtDelegate._currentDirectoryNode, 
                       _NSNavNaughtDelegate._selectedNodes, _NSNavNode._aliasState, 
                       _NSNavNode._ejecting, _NSNavNode._openSyncStarted, 
                       _NSNavNode._registeredForAttributeChanges, _NSNavNode._registeredForChildChanges, 
                       _NSNavNode._reserved, _NSNavNode._reserved2, _NSNavNode._reserved3, 
                       _NSNavNode._selfChangeRegistrationCount, _NSNavNode._waitingForAttributeChangeCallback, 
                       _NSNavNodePopUpButton._firstItemDirty, _NSNavNodePopUpButton._groupIdentifiers, 
                       _NSNavNodePopUpButton._inMenuTrackingMode, _NSNavNodePopUpButton._nodeInfoTable, 
                       _NSNavNodePopUpButton._otherMenuContentsDirty, _NSNavNodePopUpButton._otherMenuIconsDirty, 
                       _NSNavNodePopUpButton._reserved, _NSNavNodePopUpButton._watchingNodes, 
                       _NSNavNodePopUpButton._windowOrderedOut, _NSNavOutlineDelegate._calculateFolderSizes, 
                       _NSNavOutlineDelegate._currentDirectoryNode, _NSNavOutlineDelegate._highlightedNodesToRestore, 
                       _NSNavOutlineDelegate._normalIndentationPerLevel, 
                       _NSNavOutlineDelegate._outline, _NSNavOutlineDelegate._reserved, 
                       _NSNavOutlineDelegate._showIconThumbnails, _NSNavOutlineDelegate._topNodeBeforeReload, 
                       _NSNavOutlineDelegate._useRelativeDates, _NSNavOutlineHeaderCell._tableColumn, 
                       _NSNavSimpleButtonCell._buttonImagesTable, _NSNavSimpleButtonCell._disabledWhenInactive, 
                       _NSNavSimpleButtonCell._mouseInside, _NSNavSimpleButtonCell._showsRollover, 
                       _NSNavSimpleButtonCell._showsShadowedText, _NSNavSimpleButtonCell._titleSize, 
                       _NSNavSortingContext._ascending, _NSNavSortingContext._count, 
                       _NSNavSortingContext._sortOrder, _NSNavView._advSearchController, 
                       _NSNavView._browser, _NSNavView._currentModeView, 
                       _NSNavView._dataSource, _NSNavView._delegate, _NSNavView._fileListModeControl, 
                       _NSNavView._fileListModeControlSetup, _NSNavView._fileListViewContainer, 
                       _NSNavView._filenameToSelectWhenDoneResolving, _NSNavView._filepathInputController, 
                       _NSNavView._historyControl, _NSNavView._iconView, 
                       _NSNavView._iconViewMenu, _NSNavView._inConfigureForDirectory, 
                       _NSNavView._isSaveMode, _NSNavView._mediaBrowserNode, 
                       _NSNavView._mediaBrowserShownTypes, _NSNavView._mediaBrowserView, 
                       _NSNavView._navViewController, _NSNavView._newFolderController, 
                       _NSNavView._outline, _NSNavView._pathComponentPicker, 
                       _NSNavView._pathLocationControl, _NSNavView._reserved, 
                       _NSNavView._resolvingNodeFromPath, _NSNavView._restoredSavedSettings, 
                       _NSNavView._savePanel, _NSNavView._searchField, 
                       _NSNavView._searchProgressIndicator, _NSNavView._searchResultsCountField, 
                       _NSNavView._searchScopeView, _NSNavView._sharedFolderBannerView, 
                       _NSNavView._sharedFolderNode, _NSNavView._sharedServerBannerController, 
                       _NSNavView._showingSearchParts, _NSNavView._sidebarController, 
                       _NSNavView._sidebarLoaded, _NSNavView._sidebarOutlineView, 
                       _NSNavView._sliceRuleEditor, _NSNavView._splitViewController, 
                       _NSNavView._unused, _NSNavView._userChangedDirectory, 
                       _NSNavVirtualNode._children, _NSNavVirtualNode._comment, 
                       _NSNavVirtualNode._creationDate, _NSNavVirtualNode._displayName, 
                       _NSNavVirtualNode._fileType, _NSNavVirtualNode._icon, 
                       _NSNavVirtualNode._iconRef, _NSNavVirtualNode._isAlias, 
                       _NSNavVirtualNode._isContainer, _NSNavVirtualNode._isDisconnectedMountPoint, 
                       _NSNavVirtualNode._isExtensionHidden, _NSNavVirtualNode._isPackage, 
                       _NSNavVirtualNode._isUnauthenticatedMountPoint, 
                       _NSNavVirtualNode._isVisible, _NSNavVirtualNode._isVolume, 
                       _NSNavVirtualNode._kind, _NSNavVirtualNode._logicalSize, 
                       _NSNavVirtualNode._modDate, _NSNavVirtualNode._name, 
                       _NSNavVirtualNode._originalNode, _NSNavVirtualNode._parent, 
                       _NSNavVirtualNode._path, _NSNavVirtualNode._physicalSize, 
                       _NSNavVirtualNode._shortVersion, _NSNavVirtualNode._sidebarIcon, 
                       _NSNavVirtualNode._usedSize, _NSNextStepFrame.edgeResizingTrackingAreas, 
                       _NSNextStepFrame.fvFlags, _NSNextStepFrame.nsfReserved, 
                       _NSNextStepFrame.sizingParams, _NSNextStepFrame.styleMask, 
                       _NSNextStepFrame.titleCell, _NSNibExternalObjectPlaceholder._externalObjectPlaceholderIdentifier, 
                       _NSObjectController._content, _NSObjectController._objectHandler, 
                       _NSObjectDetailBinder._errorPresenter, _NSObjectDetailBinder._objectDetailBinderFlags, 
                       _NSObsoleteBitmap.isBuiltIn, _NSObsoleteBitmap.name, 
                       _NSOneLevelViewBuffer._cgLayer, _NSOneLevelViewBuffer._window, 
                       _NSOutlineViewBinder._contentBindingController, 
                       _NSOutlineViewBinder._ignoreChangesCount, _NSOutlineViewBinder._outlineViewBinderFlags, 
                       _NSOutlineViewBinder._previousVisibleRange, _NSOutlineViewBinder._treeNodeObservingTracker, 
                       _NSPDFInfo._URL, _NSPDFInfo._attributes, _NSPDFInfo._fileExtensionHidden, 
                       _NSPDFInfo._orientation, _NSPDFInfo._paperSize, 
                       _NSPDFInfo._tagNames, _NSPDFPanel._accessoryController, 
                       _NSPDFPanel._defaultFileName, _NSPDFPanel._options, 
                       _NSPDFPanel._panel, _NSPDFPanel._private, _NSPDFPanelAccessoryViewController._customAccessoryViewController, 
                       _NSPDFPanelAccessoryViewController._orientationContainer, 
                       _NSPDFPanelAccessoryViewController._orientationMatrix, 
                       _NSPDFPanelAccessoryViewController._pageSizeContainer, 
                       _NSPDFPanelAccessoryViewController._pageSizePopup, 
                       _NSPDFPanelAccessoryViewController.showOrientation, 
                       _NSPDFPanelAccessoryViewController.showPaperSize, 
                       _NSPICTImageRep._imageRep, _NSPICTImageRep._pictData, 
                       _NSPICTImageRep._pictOffset, _NSPICTImageRep._pictOrigin, 
                       _NSPICTImageRep._reserved1, _NSPICTImageRep._reserved2, 
                       _NSPPDParse.argBuf, _NSPPDParse.argTran, _NSPPDParse.delegate, 
                       _NSPPDParse.input, _NSPPDParse.inputStreamStack, 
                       _NSPPDParse.keyTran, _NSPSMatrix.mFlags, _NSPSMatrix.matrixElements, 
                       _NSPanelController.action, _NSPanelController.alertPanel, 
                       _NSPanelController.gotString, _NSPanelController.iconView, 
                       _NSPanelController.okButton, _NSPanelController.renameLabel, 
                       _NSPanelController.renameTextField, _NSPanelController.target, 
                       _NSPanelController.textFieldStringValue, _NSPasteboardFilter._intype, 
                       _NSPasteboardFilter._outtype, _NSPasteboardFilter._spec, 
                       _NSPatternColor._patternImage, _NSPatternColor.cachedPatternColor, 
                       _NSPersistentUICrashHandler.crashBlameCounter, _NSPersistentUICrashHandler.restorationCountFileURL, 
                       _NSPersistentUIEncodedReference.persistentIdentifier, 
                       _NSPersistentUIEncodedReference.windowID, _NSPersistentUIManager.IOQueue, 
                       _NSPersistentUIManager.additionalBuckets, _NSPersistentUIManager.bundleID, 
                       _NSPersistentUIManager.contiguousInactiveFlushCount, 
                       _NSPersistentUIManager.crashHandler, _NSPersistentUIManager.currentFileSize, 
                       _NSPersistentUIManager.disableRestorableStateWritingCounter, 
                       _NSPersistentUIManager.elideAllFileWrites, _NSPersistentUIManager.fileSizeAfterLastRewrite, 
                       _NSPersistentUIManager.flushTimer, _NSPersistentUIManager.isClosedToChanges, 
                       _NSPersistentUIManager.objectToPendingKeyPaths, 
                       _NSPersistentUIManager.pendingRecords, _NSPersistentUIManager.persistentStateDirectoryURL, 
                       _NSPersistentUIManager.publicPlistChecksum, _NSPersistentUIManager.publicPlistFD, 
                       _NSPersistentUIManager.rawHadValidStateDirectoryAtLaunch, 
                       _NSPersistentUIManager.rawStateDirectoryAtLaunch, 
                       _NSPersistentUIManager.scheduledFlushDate, _NSPersistentUIManager.scheduledFlushDeadline, 
                       _NSPersistentUIManager.sortedWindowInfos, _NSPersistentUIManager.spinlock, 
                       _NSPersistentUIManager.stateDirectoryHasBeenRefreshed, 
                       _NSPersistentUIManager.stateFileFD, _NSPersistentUIManager.stateFileHasBeenCreated, 
                       _NSPersistentUIManager.stateRestorer, _NSPersistentUIManager.suppressedCGWindowOrderingStatus, 
                       _NSPersistentUIManager.suppressedCGWindowOrderingSuccessfully, 
                       _NSPersistentUIManager.treatEverythingAsDirty, _NSPersistentUIManager.urlHerder, 
                       _NSPersistentUIManager.windowSnapshotter, _NSPersistentUIManager.workQueue, 
                       _NSPersistentUIRestorer.crashHandler, _NSPersistentUIRestorer.hasFinishedRestoringWindows, 
                       _NSPersistentUIRestorer.performingWindowOrdering, 
                       _NSPersistentUIRestorer.suppressedCGWindowOrderingStatus, 
                       _NSPersistentUIRestorer.suppressedCGWindowOrderingSuccessfully, 
                       _NSPersistentUIRestorer.urlHerder, _NSPersistentUIRestorer.windowRestorations, 
                       _NSPersistentUIRestorer.windowRestorationsByWindowID, 
                       _NSPersistentUISecureURLHerder.bundleID, _NSPersistentUISecureURLHerder.lsSharedFileList, 
                       _NSPersistentUISecureURLHerder.urlsStashedInLSToSharedFileListItemRefs, 
                       _NSPersistentUIWindowSnapshotter.IOQueue, _NSPersistentUIWindowSnapshotter._cryptoKey, 
                       _NSPersistentUIWindowSnapshotter._cryptoKeyGeneration, 
                       _NSPersistentUIWindowSnapshotter._cryptoUUID, _NSPersistentUIWindowSnapshotter.hasDisabledSuddenTermination, 
                       _NSPersistentUIWindowSnapshotter.persistentStateDirectoryURL, 
                       _NSPersistentUIWindowSnapshotter.volumeIsLocal, 
                       _NSPersistentUIWindowSnapshotter.windowIDsToSnapshotInfo, 
                       _NSPersistentUIWindowSnapshotter.windowsPendingSnapshotting, 
                       _NSPoofView.poofIndex, _NSPopoverAnimationController._anchorView, 
                       _NSPopoverAnimationController._popover, _NSPopoverAnimationController._positioningRect, 
                       _NSPopoverAnimationController._preferredEdge, _NSPopoverAnimationController._reserved2, 
                       _NSPopoverAnimationController._reservedPopoverFlags, 
                       _NSPopoverAnimationController._weakAnchorViewHelper, 
                       _NSPopoverColorWell._afterRenderer, _NSPopoverColorWell._flags, 
                       _NSPredicateEditor._allTemplates, _NSPredicateEditor._peFlags, 
                       _NSPredicateEditor._predicateAction, _NSPredicateEditor._predicateEditorReserved, 
                       _NSPredicateEditor._predicateTarget, _NSPredicateEditor._rootHeaderTrees, 
                       _NSPredicateEditor._rootTrees, _NSPreferences._applyButton, 
                       _NSPreferences._cancelButton, _NSPreferences._constrainedWidth, 
                       _NSPreferences._currentModule, _NSPreferences._currentSessionPreferenceViews, 
                       _NSPreferences._isModal, _NSPreferences._masterPreferenceViews, 
                       _NSPreferences._moduleMatrix, _NSPreferences._okButton, 
                       _NSPreferences._originalContentView, _NSPreferences._preferenceBox, 
                       _NSPreferences._preferenceModules, _NSPreferences._preferenceTitles, 
                       _NSPreferences._preferencesPanel, _NSPreferences._reserved, 
                       _NSPreferencesModule._hasChanges, _NSPreferencesModule._minSize, 
                       _NSPreferencesModule._preferencesView, _NSPreferencesModule._reserved, 
                       _NSPressureConfiguration._pressureBehavior, _NSPressureConfiguration._reserved1, 
                       _NSPrintInfoAdditionalIVars.attributesDictionaryProxy, 
                       _NSPrintInfoAdditionalIVars.flattenedPageFormatData, 
                       _NSPrintInfoAdditionalIVars.flattenedPrintSettingsData, 
                       _NSPrintInfoAdditionalIVars.pageFormat, _NSPrintInfoAdditionalIVars.pageFormatIsReconciled, 
                       _NSPrintInfoAdditionalIVars.pageFormatIsValidated, 
                       _NSPrintInfoAdditionalIVars.printSession, _NSPrintInfoAdditionalIVars.printSessionIsReconciled, 
                       _NSPrintInfoAdditionalIVars.printSettings, _NSPrintInfoAdditionalIVars.printSettingsDictionaryProxy, 
                       _NSPrintInfoAdditionalIVars.printSettingsIsReconciled, 
                       _NSPrintInfoAdditionalIVars.printSettingsIsValidated, 
                       _NSPrintInfoAdditionalIVars.printerWasSetExplicitly, 
                       _NSPrintOperationPrintEventRetrofitInfo.contextInfo, 
                       _NSPrintOperationPrintEventRetrofitInfo.delegate, 
                       _NSPrintOperationPrintEventRetrofitInfo.didPrintSelector, 
                       _NSPrintOperationPrintEventRetrofitInfo.printSettings, 
                       _NSPrintOperationPrintEventRetrofitInfo.sender, 
                       _NSPrintOperationPrintEventRetrofitInfo.showPrintPanel, 
                       _NSRGBSliders.blueSlider, _NSRGBSliders.blueText, 
                       _NSRGBSliders.greenSlider, _NSRGBSliders.greenText, 
                       _NSRGBSliders.hexText, _NSRGBSliders.redSlider, 
                       _NSRGBSliders.redText, _NSRGBSliders.rgbText, _NSRGBSliders.rgbView, 
                       _NSResponder._nextResponder, _NSRuleEditorLocalizer._default, 
                       _NSRuleEditorLocalizer._dictionary, _NSRuleEditorLocalizer._localized, 
                       _NSRuleEditorLocalizer._ruleEditorLocalizerReserved, 
                       _NSRuleEditorViewSlice._animationTargetRect, _NSRuleEditorViewSlice._backgroundColor, 
                       _NSRuleEditorViewSlice._flags, _NSRuleEditorViewSlice._indentation, 
                       _NSRuleEditorViewSlice._rowIndex, _NSRuleEditorViewSlice._ruleEditor, 
                       _NSRuleEditorViewSliceRow._addButton, _NSRuleEditorViewSliceRow._correspondingRuleItems, 
                       _NSRuleEditorViewSliceRow._plusButtonRowType, _NSRuleEditorViewSliceRow._rowType, 
                       _NSRuleEditorViewSliceRow._ruleOptionFrames, _NSRuleEditorViewSliceRow._ruleOptionInitialViewFrames, 
                       _NSRuleEditorViewSliceRow._ruleOptionViews, _NSRuleEditorViewSliceRow._sliceRowFlags, 
                       _NSRuleEditorViewSliceRow._sliceRowReserved, _NSRuleEditorViewSliceRow._subtractButton, 
                       _NSRulerMarker._image, _NSRulerMarker._imageOrigin, 
                       _NSRulerMarker._location, _NSRulerMarker._rFlags, 
                       _NSRulerMarker._representedObject, _NSRulerMarker._ruler, 
                       _NSRulerMarkerView._rulerMarker, _NSRulerViewAccessibilityPanelController._accessibilityPanel, 
                       _NSRulerViewAccessibilityPanelController._markerTypeButton, 
                       _NSRulerViewAccessibilityPanelController._rulerView, 
                       _NSRulerViewAccessibilityPanelController._valueField, 
                       _NSRulerViewPrivateData._accessibilityPanelController, 
                       _NSRulerViewPrivateData._draggingMarkerView, _NSRulerViewPrivateData._formattedHashLabelCache, 
                       _NSRulerViewPrivateData._markerLines, _NSRulerViewPrivateData._rvFlags, 
                       _NSSavePanel.__navView, _NSSavePanel._accessoryView, 
                       _NSSavePanel._accessoryViewContainer, _NSSavePanel._allowedFileTypes, 
                       _NSSavePanel._bottomControlsContainer, _NSSavePanel._cancelButton, 
                       _NSSavePanel._directoryPopUp, _NSSavePanel._directoryPopUpContainer, 
                       _NSSavePanel._directoryPopUpLabel, _NSSavePanel._expansionButton, 
                       _NSSavePanel._filepathInputController, _NSSavePanel._hiddenExtension, 
                       _NSSavePanel._hideExtensionButton, _NSSavePanel._messageTextField, 
                       _NSSavePanel._nameField, _NSSavePanel._nameFieldLabel, 
                       _NSSavePanel._navViewContainer, _NSSavePanel._newFolderButton, 
                       _NSSavePanel._okButton, _NSSavePanel._reservedID, 
                       _NSSavePanel._saveNavSeparatorBox, _NSSavePanel._savePane, 
                       _NSSavePanel._savePaneTopPartsContainer, _NSSavePanel._spAuxiliaryStorage, 
                       _NSSavePanel._spFlags, _NSSavePanel._validatedPosixName, 
                       _NSSavePanelAuxiliary._alertStyleContentView, _NSSavePanelAuxiliary._alertStyleMinWidth, 
                       _NSSavePanelAuxiliary._animatingSetFrame, _NSSavePanelAuxiliary._appCentricAccessoryViewSeparatorBox, 
                       _NSSavePanelAuxiliary._beginWithFileNames, _NSSavePanelAuxiliary._canSendSynchronousMessagesToRemote, 
                       _NSSavePanelAuxiliary._clientSetADirectory, _NSSavePanelAuxiliary._clientWillSetTags, 
                       _NSSavePanelAuxiliary._completionHandler, _NSSavePanelAuxiliary._distanceBetweenExtensionCheckAndNewFolderOrDocumentButton, 
                       _NSSavePanelAuxiliary._dontSaveButton, _NSSavePanelAuxiliary._enabledFileTypes, 
                       _NSSavePanelAuxiliary._fauxFilePackageTypes, _NSSavePanelAuxiliary._hideExtension, 
                       _NSSavePanelAuxiliary._iCloudOpenPanel, _NSSavePanelAuxiliary._initialTags, 
                       _NSSavePanelAuxiliary._lastNameFieldText, _NSSavePanelAuxiliary._newDocumentButton, 
                       _NSSavePanelAuxiliary._optionsButton, _NSSavePanelAuxiliary._overwritingAlertSuppressionURL, 
                       _NSSavePanelAuxiliary._remoteAccessoryViewAvailable, 
                       _NSSavePanelAuxiliary._remotePID, _NSSavePanelAuxiliary._reserved, 
                       _NSSavePanelAuxiliary._retained, _NSSavePanelAuxiliary._revertOriginalDocumentButton, 
                       _NSSavePanelAuxiliary._revertOriginalDocumentChanges, 
                       _NSSavePanelAuxiliary._runningAsAService, _NSSavePanelAuxiliary._runningAsASheet, 
                       _NSSavePanelAuxiliary._sandboxExtensions, _NSSavePanelAuxiliary._sandboxPermissions, 
                       _NSSavePanelAuxiliary._showNewDocumentButton, _NSSavePanelAuxiliary._showOptionsButton, 
                       _NSSavePanelAuxiliary._showRevertOriginalDocumentButton, 
                       _NSSavePanelAuxiliary._showTagField, _NSSavePanelAuxiliary._tagField, 
                       _NSSavePanelAuxiliary._tagFieldContainer, _NSSavePanelAuxiliary._tagFieldLabel, 
                       _NSSavePanelAuxiliary._tags, _NSSavePanelAuxiliary._useAlertStyle, 
                       _NSSavePanelAuxiliary.contextInfo, _NSSavePanelAuxiliary.currentAlert, 
                       _NSSavePanelAuxiliary.delegate, _NSSavePanelAuxiliary.modalDelegate, 
                       _NSSavePanelAuxiliary.modalDelegateDidEndSelector, 
                       _NSSavePanelAuxiliary.openProgressIndicatorScheduled, 
                       _NSScrollAnimationHelper._completionHandler, _NSScrollAnimationHelper._delegate, 
                       _NSScrollAnimationHelper._endPoint, _NSScrollAnimationHelper._sahFlags, 
                       _NSScrollAnimationHelper._startPoint, _NSScrollAnimationHelper._totalDelta, 
                       _NSScrollView._contentView, _NSScrollView._cornerView, 
                       _NSScrollView._extraIvars, _NSScrollView._hScroller, 
                       _NSScrollView._headerClipView, _NSScrollView._horizontalRuler, 
                       _NSScrollView._ruler, _NSScrollView._sFlags, _NSScrollView._vScroller, 
                       _NSScrollView._verticalRuler, _NSScroller._curValue, 
                       _NSScroller._knobSize, _NSScroller._percent, _NSScroller._reserved, 
                       _NSScroller._reserved2, _NSScroller._sFlags2, _NSScroller.sFlags, 
                       _NSScrollerImp._blurFilter, _NSScrollerImp._expansionTransitionProgress, 
                       _NSScrollerImp._sFlags2, _NSScrollerImp._uiStateTransitionProgress, 
                       _NSScrollerImp.action, _NSScrollerImp.blur, _NSScrollerImp.boundsSize, 
                       _NSScrollerImp.contentViewTrackingArea, _NSScrollerImp.delegate, 
                       _NSScrollerImp.doubleValue, _NSScrollerImp.knobAlpha, 
                       _NSScrollerImp.knobLayer, _NSScrollerImp.knobLength, 
                       _NSScrollerImp.knobProportion, _NSScrollerImp.layer, 
                       _NSScrollerImp.outstandingRolloverAnimationCancelledPtr, 
                       _NSScrollerImp.presentationValue, _NSScrollerImp.rangeIndicatorAlpha, 
                       _NSScrollerImp.sFlags, _NSScrollerImp.scroller, 
                       _NSScrollerImp.target, _NSScrollerImp.trackAlpha, 
                       _NSScrollerImp.trackLayer, _NSScrollerImpPair.contentViewTrackingArea, 
                       _NSScrollerImpPair.delegate, _NSScrollerImpPair.flags, 
                       _NSScrollerImpPair.flags2, _NSScrollerImpPair.horizontalScrollerImp, 
                       _NSScrollerImpPair.lastMouseInContentPoint, _NSScrollerImpPair.overlayScrollerHideTimer, 
                       _NSScrollerImpPair.reserved2, _NSScrollerImpPair.reserved3, 
                       _NSScrollerImpPair.scrollView, _NSScrollerImpPair.scrollerStyle, 
                       _NSScrollerImpPair.verticalScrollerImp, _NSSecureStringWrapper._bulletCharacter, 
                       _NSSecureStringWrapper._length, _NSSecureStringWrapper._originalString, 
                       _NSSecureTextStorage._bulletCharacter, _NSSecureTextStorage._font, 
                       _NSSecureTextStorage._level, _NSSecureTextStorage._storage, 
                       _NSSecureTextView._innerTag, _NSSecureTextView._outerTag, 
                       _NSSecureTextView._sdvFlags, _NSSegmentItem._alternateImage, 
                       _NSSegmentItem._flags, _NSSegmentItem._fullWidth, 
                       _NSSegmentItem._image, _NSSegmentItem._imageRect, 
                       _NSSegmentItem._label, _NSSegmentItem._labelRect, 
                       _NSSegmentItem._menu, _NSSegmentItem._menuIndRect, 
                       _NSSegmentItem._owningCell, _NSSegmentItem._shrinkage, 
                       _NSSegmentItem._tag, _NSSegmentItem._toolTip, _NSSegmentItem._toolTipTag, 
                       _NSSegmentItem._width, _NSSelectionBinder._contentPlacementTag, 
                       _NSSelectionBinder._modelObservingTracker, _NSSelectionBinder._selectionBinderFlags, 
                       _NSServiceListener.serviceProviders, _NSServiceMaster._localObjects, 
                       _NSServiceMaster._reserved, _NSServiceMaster._serviceFlags, 
                       _NSSharingServicePickerReserved.delegate, _NSSharingServicePickerReserved.items, 
                       _NSSharingServicePickerReserved.picker, _NSSharingServicePickerReserved.style, 
                       _NSSharingServiceReserved.delegate, _NSSharingServiceReserved.service, 
                       _NSSliderCell._altIncValue, _NSSliderCell._knobOffset, 
                       _NSSliderCell._maxValue, _NSSliderCell._minValue, 
                       _NSSliderCell._numberOfTickMarks, _NSSliderCell._previousValue, 
                       _NSSliderCell._scFlags, _NSSliderCell._sliderCellPrivateData, 
                       _NSSliderCell._trackRect, _NSSliderCell._value, 
                       _NSSnapshotContextSignature._colorSpace, _NSSnapshotContextSignature._imageInterpolation, 
                       _NSSnapshotContextSignature._modelLogicalRect, _NSSnapshotContextSignature._modelPixelDrawingRect, 
                       _NSSnapshotContextSignature._modelPixelLogicalRect, 
                       _NSSpeechRecognizerVars._delegate, _NSSpeechRecognizerVars._displayedStringsArray, 
                       _NSSpeechRecognizerVars._displayedStringsTitle, 
                       _NSSpeechRecognizerVars._locale, _NSSpeechRecognizerVars._recognitionSystem, 
                       _NSSpeechRecognizerVars._recognizer, _NSSpeechRecognizerVars._simpleCommandsArray, 
                       _NSSpeechSynthesizerVars._currentVoice, _NSSpeechSynthesizerVars._delegate, 
                       _NSSpeechSynthesizerVars._needsResyncWithDefaultVoice, 
                       _NSSpeechSynthesizerVars._normalSpeakingRate, _NSSpeechSynthesizerVars._speakingSpeechFeedbackServices, 
                       _NSSpeechSynthesizerVars._speechChannel, _NSSpeechSynthesizerVars._speechFeedbackServicesInvoker, 
                       _NSSpeechSynthesizerVars._speechFeedbackServicesRef, 
                       _NSSpeechSynthesizerVars._speechFinishedSuccessfully, 
                       _NSSpeechSynthesizerVars._synthesizerIsRetained, 
                       _NSSpeechSynthesizerVars._usesFeedbackWindow, _NSSpeechSynthesizerVars._usingDefaultVoice, 
                       _NSSplitViewSplitter._index, _NSStatusBarWindow._effectView, 
                       _NSStatusBarWindow._statusItem, _NSStatusBarWindow._viewToSelectionViewDictionary, 
                       _NSStopTouchingMeBox.offset, _NSStopTouchingMeBox.sibling1, 
                       _NSStopTouchingMeBox.sibling2, _NSStoryboardEmbedSegueTemplate._containerView, 
                       _NSStoryboardPopoverSegueTemplate._anchorView, _NSStoryboardPopoverSegueTemplate._popoverBehavior, 
                       _NSStoryboardPopoverSegueTemplate._preferredEdge, 
                       _NSStoryboardShowSegueTemplate._uniqueControllerIdentifier, 
                       _NSSystemInfoPanel._optionsDictionary, _NSSystemInfoPanel.appIconView, 
                       _NSSystemInfoPanel.appNameField, _NSSystemInfoPanel.copyrightView, 
                       _NSSystemInfoPanel.creditScrollView, _NSSystemInfoPanel.creditView, 
                       _NSSystemInfoPanel.infoPanel, _NSSystemInfoPanel.versionField, 
                       _NSSystemStatusBar._adjustmentCompletionHandlers, 
                       _NSSystemStatusBar.adjustmentDeferred, _NSSystemStatusBar.deferringAdjustmentCount, 
                       _NSSystemStatusBar.replicantKeys, _NSSystemStatusBar.screenNotificationToken, 
                       _NSTabViewControllerSegmentedControlUIProvider._segmentedControl, 
                       _NSTabViewControllerSegmentedControlUIProvider._segmentedControlLocation, 
                       _NSTabViewControllerSegmentedControlUIProvider._tabViewController, 
                       _NSTabWell._disabled, _NSTabWell._prototype, _NSTableCellViewAux._doingLayout, 
                       _NSTableCellViewAux._isLegacySourceList, _NSTableCellViewAux._isSourceList, 
                       _NSTableCellViewAux.autounbinder, _NSTableCellViewAux.contentView, 
                       _NSTableColumn._cFlags, _NSTableColumn._dataCell, 
                       _NSTableColumn._headerCell, _NSTableColumn._identifier, 
                       _NSTableColumn._maxWidth, _NSTableColumn._minWidth, 
                       _NSTableColumn._tableView, _NSTableColumn._tcAuxiliaryStorage, 
                       _NSTableColumn._width, _NSTableHeaderView._addedBlurToClipView, 
                       _NSTableHeaderView._alignTitleWithDataCell, _NSTableHeaderView._draggedColumn, 
                       _NSTableHeaderView._draggedDistance, _NSTableHeaderView._headerDragImage, 
                       _NSTableHeaderView._isColumnResizing, _NSTableHeaderView._nextColumnAfterDrawnOneIsSelected, 
                       _NSTableHeaderView._pressedColumn, _NSTableHeaderView._reserved, 
                       _NSTableHeaderView._resizedColumn, _NSTableHeaderView._showHandCursorFired, 
                       _NSTableHeaderView._skipDrawingSeparator, _NSTableHeaderView._tableView, 
                       _NSTableHeaderView._toolTipRectsDirty, _NSTableHeaderView._usedNewHeight, 
                       _NSTableHeaderView._viewDataX, _NSTableHeaderView._wantsTranslucency, 
                       _NSTableRow._row, _NSTableRow._tableView, _NSTableView._backgroundColor, 
                       _NSTableView._columnDragInfoX, _NSTableView._cornerView, 
                       _NSTableView._dataSource, _NSTableView._delegate, 
                       _NSTableView._doubleAction, _NSTableView._editingCell, 
                       _NSTableView._editingColumn, _NSTableView._editingRow, 
                       _NSTableView._gridColor, _NSTableView._headerView, 
                       _NSTableView._intercellSpacing, _NSTableView._lastCachedRectColumn, 
                       _NSTableView._lastCachedRectRow, _NSTableView._lastSelectedColumn, 
                       _NSTableView._lastSelectedRow, _NSTableView._rectOfLastColumn, 
                       _NSTableView._rectOfLastRow, _NSTableView._reserved, 
                       _NSTableView._reserved3, _NSTableView._reserved4, 
                       _NSTableView._rowDataX, _NSTableView._rowHeight, 
                       _NSTableView._selectedColumns, _NSTableView._selectedRows, 
                       _NSTableView._tableColumns, _NSTableView._tvFlags, 
                       _NSTableViewCellMockElement._childView, _NSTableViewCellMockElement._row, 
                       _NSTableViewCellMockElement._tableColumn, _NSTableViewCellProxy._alternateParentClass, 
                       _NSTableViewCellProxy._realElement, _NSTableViewCellProxy._row, 
                       _NSTableViewCellProxy._tableColumn, _NSTargetAnimationInfo._animation, 
                       _NSTargetAnimationInfo._progress, _NSTargetAnimationInfo._start, 
                       _NSText._ivars, _NSTextAttachmentCell._attachment, 
                       _NSTextCheckingOperation._checkingTypes, _NSTextCheckingOperation._completionHandler, 
                       _NSTextCheckingOperation._offset, _NSTextCheckingOperation._options, 
                       _NSTextCheckingOperation._orthography, _NSTextCheckingOperation._range, 
                       _NSTextCheckingOperation._results, _NSTextCheckingOperation._sequenceNumber, 
                       _NSTextCheckingOperation._string, _NSTextCheckingOperation._tag, 
                       _NSTextCheckingOperation._wordCount, _NSTextField._delegate, 
                       _NSTextField._errorAction, _NSTextFieldCell._backgroundColor, 
                       _NSTextFieldCell._textColor, _NSTextFieldCell._tfFlags, 
                       _NSTextReplacementNode.children, _NSTextReplacementNode.curString, 
                       _NSTextReplacementNode.replacementFlags, _NSTextReplacementNode.replacementString, 
                       _NSTextTemplate._alignment, _NSTextTemplate._backgroundColor, 
                       _NSTextTemplate._contents, _NSTextTemplate._delegate, 
                       _NSTextTemplate._font, _NSTextTemplate._maxSize, 
                       _NSTextTemplate._minSize, _NSTextTemplate._textColor, 
                       _NSTextTemplate._ttFlags, _NSTextViewCompletionController._charRange, 
                       _NSTextViewCompletionController._completionWindow, 
                       _NSTextViewCompletionController._completions, _NSTextViewCompletionController._endDisplayNoComplete, 
                       _NSTextViewCompletionController._movement, _NSTextViewCompletionController._originalString, 
                       _NSTextViewCompletionController._sessionTerminatingEvent, 
                       _NSTextViewCompletionController._tableView, _NSTextViewCompletionController._textView, 
                       _NSTextViewCompletionController._textViewWindow, 
                       _NSTextViewCompletionController._textViewWindowNumber, 
                       _NSTextViewIvars._adjustedSelectedRangeForActions, 
                       _NSTextViewIvars._highlightIndicator, _NSTextViewIvars._immediateActionGestureRecognizer, 
                       _NSTextViewIvars._insertionPointRect, _NSTextViewIvars._insertionPointRectCache, 
                       _NSTextViewIvars._lastFirstMouseEvent, _NSTextViewIvars._placeholderString, 
                       _NSTextViewIvars._selectionDragCursorTimer, _NSTextViewIvars._trackingArea, 
                       _NSTextViewIvars.dirtyRectForDisplayWithoutLayout, 
                       _NSTextViewIvars.dragInfo, _NSTextViewIvars.eventList, 
                       _NSTextViewIvars.layoutManager, _NSTextViewIvars.maxBoundsSize, 
                       _NSTextViewIvars.minBoundsSize, _NSTextViewIvars.sharedData, 
                       _NSTextViewIvars.textContainer, _NSTextViewIvars.textContainerInset, 
                       _NSTextViewIvars.textContainerOrigin, _NSTextViewIvars.textStorage, 
                       _NSTextViewIvars.tvFlags, _NSTextViewSharedData.__reserved1, 
                       _NSTextViewSharedData._allowedInputLocales, _NSTextViewSharedData._alternateBlinkRect, 
                       _NSTextViewSharedData._attributedStringForMarkedRange, 
                       _NSTextViewSharedData._backgroundColor, _NSTextViewSharedData._blinkContainer, 
                       _NSTextViewSharedData._blinkRect, _NSTextViewSharedData._blinkTimer, 
                       _NSTextViewSharedData._bubbleRange, _NSTextViewSharedData._bubbleTimer, 
                       _NSTextViewSharedData._clickedCharIndex, _NSTextViewSharedData._considerDeferredTextChecking, 
                       _NSTextViewSharedData._correctingTextView, _NSTextViewSharedData._dataDetectionHighlight, 
                       _NSTextViewSharedData._dataDetectionPoint, _NSTextViewSharedData._dataDetectionRange, 
                       _NSTextViewSharedData._dataDetectionWindow, _NSTextViewSharedData._defaultParagraphStyle, 
                       _NSTextViewSharedData._deferredCheckingRange, _NSTextViewSharedData._delegate, 
                       _NSTextViewSharedData._distanceForVerticalArrowKeyMovement, 
                       _NSTextViewSharedData._dragAndDropCharRange, _NSTextViewSharedData._dragAndDropCharRanges, 
                       _NSTextViewSharedData._emacsMarkCharRange, _NSTextViewSharedData._fieldEditorUndoManager, 
                       _NSTextViewSharedData._inputContext, _NSTextViewSharedData._insertionPointColor, 
                       _NSTextViewSharedData._inspectorBarItems, _NSTextViewSharedData._lastDeferredCheckingRange, 
                       _NSTextViewSharedData._lastSelectedCharRangeForZoomNotification, 
                       _NSTextViewSharedData._linkAttributesDict, _NSTextViewSharedData._markedAttributesDict, 
                       _NSTextViewSharedData._markedCharRange, _NSTextViewSharedData._markedTypingAttributesDict, 
                       _NSTextViewSharedData._notifyingTextView, _NSTextViewSharedData._otherEnabledTextCheckingTypes, 
                       _NSTextViewSharedData._pastedGraphicCount, _NSTextViewSharedData._performTextChecking, 
                       _NSTextViewSharedData._prechangeCheckingSequenceNumber, 
                       _NSTextViewSharedData._preferredTextFinderStyle, 
                       _NSTextViewSharedData._previousCheckingSequenceNumber, 
                       _NSTextViewSharedData._ruler, _NSTextViewSharedData._rulerClient, 
                       _NSTextViewSharedData._rulerStyle, _NSTextViewSharedData._savedSelectedRanges, 
                       _NSTextViewSharedData._sdFlags, _NSTextViewSharedData._sdFlags2, 
                       _NSTextViewSharedData._sdFlags3, _NSTextViewSharedData._selectedAttributesDict, 
                       _NSTextViewSharedData._selectedCharRange, _NSTextViewSharedData._selectedRanges, 
                       _NSTextViewSharedData._selectionRolloverPicker, 
                       _NSTextViewSharedData._selectionRolloverRange, _NSTextViewSharedData._selectionRolloverTimer, 
                       _NSTextViewSharedData._smartLinkLocations, _NSTextViewSharedData._spellCheckerDocumentTag, 
                       _NSTextViewSharedData._spellingFromMenuRange, _NSTextViewSharedData._temporaryCorrectionRange, 
                       _NSTextViewSharedData._textCheckingChangeLocations, 
                       _NSTextViewSharedData._textCheckingScheduledRanges, 
                       _NSTextViewSharedData._textFinder, _NSTextViewSharedData._toolTipPoint, 
                       _NSTextViewSharedData._toolTipTimer, _NSTextViewSharedData._toolTipTrackingArea, 
                       _NSTextViewSharedData._toolTipWindow, _NSTextViewSharedData._typingAttributesDict, 
                       _NSTextViewSharedData._undoTextObject, _NSTextViewSharedData._updateDragTypeRegistration, 
                       _NSTextViewSharedData._validMarkedAttributesDict, 
                       _NSTextViewTemplate._backgroundColor, _NSTextViewTemplate._containerSize, 
                       _NSTextViewTemplate._contents, _NSTextViewTemplate._delegate, 
                       _NSTextViewTemplate._insertionPointColor, _NSTextViewTemplate._maxSize, 
                       _NSTextViewTemplate._minSize, _NSTextViewTemplate._selectedTextAttributes, 
                       _NSTextViewTemplate._tvtFlags, _NSTextViewTemplate._typingAttrs, 
                       _NSThemeDocumentButtonPopUpMenuProxy.documentButton, 
                       _NSThemeDocumentButtonPopUpMenuProxy.pathControl, 
                       _NSThemeDocumentButtonPopUpMenuProxy.realObject, 
                       _NSThemeFrame._displayName, _NSThemeFrame._showToolbarPreWindowSize, 
                       _NSThemeFrame._tFlags, _NSThemeFrame._toolbarVisibleStatus, 
                       _NSThemeFrame.bottomBorderThickness, _NSThemeFrame.fullScreenButton, 
                       _NSThemeFrame.leftGroupTrackingTagNum, _NSThemeFrame.lockButton, 
                       _NSThemeFrame.rightGroupTrackingTagNum, _NSThemeFrame.showToolbarTransitionLayer, 
                       _NSThemeFrame.toolbarButton, _NSThemeFrame.topBorderThickness, 
                       _NSThemeFrame.widgetState, _NSTitledFrame.fileButton, 
                       _NSTitledFrame.resizeFlags, _NSTitledFrame.titleCellSize, 
                       _NSTokenAttachment._delegate, _NSTokenAttachment._needsSeparator, 
                       _NSTokenAttachmentCell._representedObject, _NSTokenAttachmentCell._tacFlags, 
                       _NSTokenAttachmentCell._textColor, _NSTokenAttachmentCell._view, 
                       _NSTokenField._reserved1, _NSTokenField._reserved2, 
                       _NSTokenField._reserved3, _NSTokenField._reserved4, 
                       _NSTokenField._reserved5, _NSTokenField._reserved6, 
                       _NSTokenField._reserved7, _NSTokenField._trackingRectTag, 
                       _NSToolTip.cell, _NSToolTip.dataDictionary, _NSToolTip.owner, 
                       _NSToolTip.string, _NSToolTip.trackingNum, _NSToolTip.trackingRect, 
                       _NSToolTip.ttFlags, _NSToolTip.view, _NSToolTip.weakData, 
                       _NSToolTipStringDrawingLayoutManager._layoutManager, 
                       _NSToolTipStringDrawingLayoutManager._wrappingAttributes, 
                       _NSToolbarConfigPanel._configPanelReserved, _NSToolbarConfigPanel._defaultItemsText, 
                       _NSToolbarConfigPanel._defaultToolbarImageRep, _NSToolbarConfigPanel._desiredSheetWidth, 
                       _NSToolbarConfigPanel._displayModePopUp, _NSToolbarConfigPanel._editedToolbar, 
                       _NSToolbarConfigPanel._individualItemsScrollView, 
                       _NSToolbarConfigPanel._individualItemsText, _NSToolbarConfigPanel._individualItemsToolbar, 
                       _NSToolbarConfigPanel._individualItemsToolbarView, 
                       _NSToolbarConfigPanel._maxIndividualItemViewHeight, 
                       _NSToolbarConfigPanel._useSmallIconsCheckBox, _NSToolbarConfigPanel._widthOfWidgets, 
                       _NSToolbarGroupView._groupItem, _NSToolbarGroupView._gvFlags, 
                       _NSToolbarGroupView.action, _NSToolbarGroupView.tooltipTags, 
                       _NSToolbarItemConfigWrapper._activeImage, _NSToolbarItemConfigWrapper._inactiveImage, 
                       _NSToolbarItemConfigWrapper._wrappedItem, _NSToolbarPoofAnimator._callbackInfo, 
                       _NSToolbarPoofAnimator._poofWindow, _NSToolbarPoofAnimator._poofWindowImageView, 
                       _NSToolbarPoofAnimator._releasesAfterPoofing, _NSToolbarSeparatorItem._separatorItemReserved, 
                       _NSTouchDevice._deviceID, _NSTouchDevice._flags, 
                       _NSTouchDevice._reserved1, _NSTouchDevice._reserved2, 
                       _NSTouchDevice._reserved3, _NSTouchDevice._surfaceSize, 
                       _NSTreeController._arrangedObjects, _NSTreeController._childrenKeyPath, 
                       _NSTreeController._countKeyPath, _NSTreeController._leafKeyPath, 
                       _NSTreeController._modelObservingKeyPaths, _NSTreeController._rootNode, 
                       _NSTreeController._selectedObjects, _NSTreeController._selectionIndexPaths, 
                       _NSTreeController._sortDescriptors, _NSTreeController._treeControllerFlags, 
                       _NSTreeController._treeControllerReserved1, _NSTreeController._treeStructureObservers, 
                       _NSTreeControllerTreeNode._NSTreeControllerTreeNodeFlags, 
                       _NSTreeControllerTreeNode._childrenKeyPath, _NSTreeControllerTreeNode._countKeyPath, 
                       _NSTreeControllerTreeNode._leafKeyPath, _NSTreeControllerTreeNode._treeController, 
                       _NSTreeDetailBinder._treeDetailBinderFlags, _NSTreeNode._NSTreeNodeFlags, 
                       _NSTreeNode._childNodes, _NSTreeNode._childNodesProxy, 
                       _NSTreeNode._observationInfo, _NSTreeNode._parentNode, 
                       _NSTreeNode._representedObject, _NSTreeNode._reserved2, 
                       _NSUIHeartBeat._blockLock, _NSUIHeartBeat._clients, 
                       _NSUIHeartBeat._clientsLock, _NSUIHeartBeat._currentView, 
                       _NSUIHeartBeat._drawingThreadLock, _NSUIHeartBeat._hbFlags, 
                       _NSUIHeartBeat._heartBeatThread, _NSUIHeartBeat._times, 
                       _NSUndoReplaceCharacters._attributedString, _NSUndoReplaceCharacters._replacementRange, 
                       _NSUndoSetAttributes._attributes, _NSUndoTextOperation._affectedRange, 
                       _NSUndoTextOperation._layoutManager, _NSUndoTextOperation._undoManager, 
                       _NSUndoTyping._attributedString, _NSUndoTyping._replacementRange, 
                       _NSVBSavePanel._animatingSetFrame, _NSVBSavePanel._attachSandboxExtensionsToFinalURLDone, 
                       _NSVBSavePanel._attachSandboxExtensionsToFinalURLsDone, 
                       _NSVBSavePanel._expectingInvalidation, _NSVBSavePanel._finalURL, 
                       _NSVBSavePanel._finalURLs, _NSVBSavePanel._hostWindow_runningAsASheet, 
                       _NSVBSavePanel._iCloudOpenPanel, _NSVBSavePanel._observingBridge, 
                       _NSVBSavePanel._panelCompleted, _NSVBSavePanel._panelIsNowUseless, 
                       _NSVBSavePanel._remoteAccessoryView, _NSVBSavePanel._retained, 
                       _NSVBSavePanel._runningAsASheet, _NSValueBinder._referenceBinding, 
                       _NSView._bounds, _NSView._dragTypes, _NSView._frame, 
                       _NSView._frameMatrix, _NSView._layer, _NSView._subviews, 
                       _NSView._superview, _NSView._unused_was_gState, 
                       _NSView._vFlags, _NSView._vFlags2, _NSView._viewAuxiliary, 
                       _NSView._window, _NSViewBuffer._isValid, _NSViewBuffer._view, 
                       _NSViewBuffer._viewRect, _NSViewDynamicToolTipManager._displayToolTipDelay, 
                       _NSViewDynamicToolTipManager._inQuickToolTipMode, 
                       _NSViewDynamicToolTipManager._lastFixedMousePoint, 
                       _NSViewDynamicToolTipManager._lastFixedMousePointTime, 
                       _NSViewDynamicToolTipManager._lastFixedMousePointToolTipRect, 
                       _NSViewDynamicToolTipManager._monitorMovementTimerRef, 
                       _NSViewDynamicToolTipManager._mouseInsideVisibleTrackingRect, 
                       _NSViewDynamicToolTipManager._reserved, _NSViewDynamicToolTipManager._toolTipTrackingRect, 
                       _NSViewDynamicToolTipManager._toolTipTrackingRectTag, 
                       _NSViewDynamicToolTipManager._trackingAreaAroundMouse, 
                       _NSViewDynamicToolTipManager._view, _NSViewDynamicToolTipManager._visibleViewTrackingRectTag, 
                       _NSViewTemplate._className, _NSViewTextAttachmentCellHelper._attachmentCell, 
                       _NSViewTextAttachmentCellHelper._layoutManager, 
                       _NSViewTextAttachmentCellHelper._view, _NSViewWindowBackingStoreBuffer._savedImage, 
                       _NSViewWindowBackingStoreBuffer._savedRect, _NSViewWindowBackingStoreBuffer._window, 
                       _NSViewWindowBackingStoreBuffer._windowRect, _NSWindow._auxiliaryStorage, 
                       _NSWindow._backgroundColor, _NSWindow._bamboo, _NSWindow._borderView, 
                       _NSWindow._contentView, _NSWindow._cursorRects, 
                       _NSWindow._defaultButtonCell, _NSWindow._delegate, 
                       _NSWindow._dragTypes, _NSWindow._fieldEditor, _NSWindow._firstResponder, 
                       _NSWindow._flushDisabled, _NSWindow._frame, _NSWindow._frameSaveName, 
                       _NSWindow._initialFirstResponder, _NSWindow._lastLeftHit, 
                       _NSWindow._lastRightHit, _NSWindow._level, _NSWindow._miniIcon, 
                       _NSWindow._postingDisabled, _NSWindow._representedURL, 
                       _NSWindow._reservedWindow1, _NSWindow._sizeLimits, 
                       _NSWindow._styleMask, _NSWindow._toolbar, _NSWindow._trectTable, 
                       _NSWindow._unusedWindow2, _NSWindow._wFlags, _NSWindow._winEventMask, 
                       _NSWindow._windowNum, _NSWindowAuxiliary._activeGestureRecognizerEvents, 
                       _NSWindowAuxiliary._activeGestureRecognizers, _NSWindowAuxiliary._activeGestureRecognizersStartEvent, 
                       _NSWindowAuxiliary._activeGestureRecognizersStartView, 
                       _NSWindowAuxiliary._animationBehavior, _NSWindowAuxiliary._animationsDictionary, 
                       _NSWindowAuxiliary._animator, _NSWindowAuxiliary._attachedSheets, 
                       _NSWindowAuxiliary._auxWFlags, _NSWindowAuxiliary._bindingAdaptor, 
                       _NSWindowAuxiliary._customFieldEditors, _NSWindowAuxiliary._deferredNeedsDisplayRegion, 
                       _NSWindowAuxiliary._delayedDisplayDisableCount, 
                       _NSWindowAuxiliary._displayCycleObserver, _NSWindowAuxiliary._growBoxOwner, 
                       _NSWindowAuxiliary._heartBeatClients, _NSWindowAuxiliary._hostsLayersInWindowServerSuspensions, 
                       _NSWindowAuxiliary._invalidCursorObserver, _NSWindowAuxiliary._lastDisplayTime, 
                       _NSWindowAuxiliary._lastFocusRingBleedRegion, _NSWindowAuxiliary._lastFocusRingView, 
                       _NSWindowAuxiliary._lastGestureRecognizerPressureMTID, 
                       _NSWindowAuxiliary._lastOtherHit, _NSWindowAuxiliary._latchedViewForScrollEvents, 
                       _NSWindowAuxiliary._layoutMaxSize, _NSWindowAuxiliary._layoutMinSize, 
                       _NSWindowAuxiliary._liveResizeCount, _NSWindowAuxiliary._mouseMovedListeners, 
                       _NSWindowAuxiliary._moveHelper, _NSWindowAuxiliary._needsDisplayRegion, 
                       _NSWindowAuxiliary._previousGestureEventMaskBeforeRecognizers, 
                       _NSWindowAuxiliary._queuedSheets, _NSWindowAuxiliary._rememberedFirstResponder, 
                       _NSWindowAuxiliary._rememberedFirstResponderState, 
                       _NSWindowAuxiliary._runningWindowTransformAnimation, 
                       _NSWindowAuxiliary._scaleFactor, _NSWindowAuxiliary._shadowTransitionProgress, 
                       _NSWindowAuxiliary._threadContexts, _NSWindowAuxiliary._toolTipDisabledCount, 
                       _NSWindowAuxiliary._touchListeners, _NSWindowAuxiliary._userInterfaceItemIdentifier, 
                       _NSWindowAuxiliary._viewScrollingCount, _NSWindowAuxiliary._willDisplayBeforeEndOfCurrentRunloopPassCount, 
                       _NSWindowAuxiliary._windowDisplayObserver, _NSWindowAuxiliary._windowDragTypeObserver, 
                       _NSWindowAuxiliary._windowRef, _NSWindowAuxiliary.alpha, 
                       _NSWindowAuxiliary.autoPositionMask, _NSWindowAuxiliary.childOrdering, 
                       _NSWindowAuxiliary.childWindows, _NSWindowAuxiliary.clientSideDragPort, 
                       _NSWindowAuxiliary.clientSideDragSource, _NSWindowAuxiliary.collapsedOrigin, 
                       _NSWindowAuxiliary.colorSpace, _NSWindowAuxiliary.compositedPattern, 
                       _NSWindowAuxiliary.cursorZone, _NSWindowAuxiliary.docWindow, 
                       _NSWindowAuxiliary.dockTile, _NSWindowAuxiliary.dockWindowTitle, 
                       _NSWindowAuxiliary.documentAutosavingError, _NSWindowAuxiliary.documentEditingState, 
                       _NSWindowAuxiliary.fullScreenAnimator, _NSWindowAuxiliary.fullScreenPresentationOptions, 
                       _NSWindowAuxiliary.fullScreenStorage, _NSWindowAuxiliary.growBoxView, 
                       _NSWindowAuxiliary.inspectorBar, _NSWindowAuxiliary.lastDragRegionData, 
                       _NSWindowAuxiliary.movementGroupID, _NSWindowAuxiliary.nonModalDocumentError, 
                       _NSWindowAuxiliary.parentWindow, _NSWindowAuxiliary.pattern, 
                       _NSWindowAuxiliary.persistentUIWindowID, _NSWindowAuxiliary.realWindowNumber, 
                       _NSWindowAuxiliary.responderLock, _NSWindowAuxiliary.restorationClass, 
                       _NSWindowAuxiliary.rootMetricsHandlerRef, _NSWindowAuxiliary.savedFirstResponder, 
                       _NSWindowAuxiliary.screenUpdatesDisabledUntilFlushToken, 
                       _NSWindowAuxiliary.sheetWindow, _NSWindowAuxiliary.standardFrame, 
                       _NSWindowAuxiliary.stashedOrigin, _NSWindowAuxiliary.surfacesThatIntersectGrowBox, 
                       _NSWindowAuxiliary.timeMachineDelegate, _NSWindowAuxiliary.titleFieldPlaceholderView, 
                       _NSWindowAuxiliary.transformDidCompleteHandler, 
                       _NSWindowAuxiliary.undoManager, _NSWindowAuxiliary.userFrame, 
                       _NSWindowAuxiliary.viewBackingSurfaces, _NSWindowAuxiliary.viewHierarchyLock, 
                       _NSWindowAuxiliary.windowController, _NSWindowAuxiliary.windowHandlerRef, 
                       _NSWindowGraphicsContext._cgsWindowID, _NSWindowMenuItem._path, 
                       _NSWindowMenuItem._title, _NSWindowMenuItem._window, 
                       _NSWindowTemplate._wtFlags, _NSWindowTemplate.animationBehavior, 
                       _NSWindowTemplate.appearance, _NSWindowTemplate.autorecalculateContentBorderThicknesses, 
                       _NSWindowTemplate.collectionBehavior, _NSWindowTemplate.contentBorderThicknesses, 
                       _NSWindowTemplate.contentMaxSize, _NSWindowTemplate.contentMinSize, 
                       _NSWindowTemplate.extension, _NSWindowTemplate.frameAutosaveName, 
                       _NSWindowTemplate.isRestorableWasDecodedFromArchive, 
                       _NSWindowTemplate.maxSize, _NSWindowTemplate.minSize, 
                       _NSWindowTemplate.realObject, _NSWindowTemplate.screenRect, 
                       _NSWindowTemplate.userInterfaceIdentifier, _NSWindowTemplate.viewClass, 
                       _NSWindowTemplate.windowBacking, _NSWindowTemplate.windowBackingLocation, 
                       _NSWindowTemplate.windowClass, _NSWindowTemplate.windowRect, 
                       _NSWindowTemplate.windowSharingType, _NSWindowTemplate.windowStyleMask, 
                       _NSWindowTemplate.windowTitle, _NSWindowTemplate.windowView, 
                       _NSWorkspaceNotificationCenter._notificationObservers, 
                       _NSWorkspaceNotificationCenter._subsystemContexts, 
                       _NSWorkspaceNotificationCenter._volumeRefQueue, 
                       _NSWorkspaceNotificationCenter._workspace, _NSWorkspaceNotificationCenter._workspaceLock, 
                       __NSAccessibilityOverriddenAttributeUIElementValue._value, 
                       __NSActionBinderPlugin._actionIndex, __NSBalancedModelObservingTracker._modelAndProxyKeysSet, 
                       __NSBinderPlugin._binder, __NSBinderPlugin._binderPluginFlags, 
                       __NSBrowserAuxiliary._autoExpandDraggingSource, 
                       __NSBrowserAuxiliary._autoExpandOriginalSelection, 
                       __NSBrowserAuxiliary._autoExpandingLastSelectedItems, 
                       __NSBrowserAuxiliary._backgroundColor, __NSBrowserAuxiliary._brflags2, 
                       __NSBrowserAuxiliary._clickedColumn, __NSBrowserAuxiliary._clickedRow, 
                       __NSBrowserAuxiliary._clipViewForTitles, __NSBrowserAuxiliary._columnAnimationDisabledCount, 
                       __NSBrowserAuxiliary._columnControllers, __NSBrowserAuxiliary._columnResizingNotificationDisabledCount, 
                       __NSBrowserAuxiliary._columnResizingType, __NSBrowserAuxiliary._columnsAutosaveName, 
                       __NSBrowserAuxiliary._contentInsets, __NSBrowserAuxiliary._disableUpdatesToken, 
                       __NSBrowserAuxiliary._dragSourceContext, __NSBrowserAuxiliary._draggingSourceOperationMaskForLocal, 
                       __NSBrowserAuxiliary._draggingSourceOperationMaskForNonLocal, 
                       __NSBrowserAuxiliary._dropContext, __NSBrowserAuxiliary._emptyVerticalSrollerImageCache, 
                       __NSBrowserAuxiliary._eventBeforeHandlingSingleActionForView, 
                       __NSBrowserAuxiliary._handlingViewSingleActionForView, 
                       __NSBrowserAuxiliary._leafItemViewControllerByItem, 
                       __NSBrowserAuxiliary._preferedColumnWidthToArchive, 
                       __NSBrowserAuxiliary._reserved, __NSBrowserAuxiliary._rowHeight, 
                       __NSBrowserAuxiliary._scrollNotificationDisableCount, 
                       __NSBrowserAuxiliary._scrollToPointHelper, __NSBrowserAuxiliary._scrollViewForColumns, 
                       __NSBrowserAuxiliary._typeSelectData, __NSBrowserAuxiliary._unusedColumns, 
                       __NSBrowserAuxiliary._visitedColumnContentWidths, 
                       __NSBrowserColumnScrollHelper._brcshFlags, __NSBrowserColumnScrollHelper._destinationRect, 
                       __NSBrowserColumnScrollHelper._displayWindowForBrowserObserver, 
                       __NSBrowserColumnScrollHelper._initialOrigin, __NSBrowserColumnScrollHelper._optimizableColumn, 
                       __NSBrowserColumnScrollHelper._runLoop, __NSBrowserColumnScrollHelper._scrollView, 
                       __NSBrowserColumnScrollHelper._startTime, __NSBrowserColumnScrollHelper._timer, 
                       __NSBrowserColumnScrollHelper._totalDistance, __NSBrowserColumnScrollHelper._totalDuration, 
                       __NSBrowserColumnsContainerView._brccvFlags, __NSBrowserDragSourceContext.draggedColumn, 
                       __NSBrowserDragSourceContext.draggedRows, __NSBrowserDropDestContext.dragOperation, 
                       __NSBrowserDropDestContext.lastDragOperationMask, 
                       __NSBrowserDropDestContext.lastDropOperation, __NSBrowserDropDestContext.lastOpInTopHalf, 
                       __NSBrowserDropDestContext.lastTargetColumn, __NSBrowserDropDestContext.lastTargetRow, 
                       __NSBrowserDropDestContext.targetColumn, __NSBrowserDropDestContext.targetDropOperation, 
                       __NSBrowserDropDestContext.targetRow, __NSButtonImage.bezelStyle, 
                       __NSButtonImage.focusRingImage, __NSButtonImage.image, 
                       __NSButtonImage.isBordered, __NSButtonImage.isOpaque, 
                       __NSButtonImage.useDisabledEffect, __NSButtonImage.useHighlightEffect, 
                       __NSCarbonMenuWindowTrackingAreaReference.f, __NSCarbonMenuWindowTrackingAreaReference.rect, 
                       __NSCarbonMenuWindowTrackingAreaReference.trackingNum, 
                       __NSCarbonMenuWindowTrackingAreaReference.trackingRef, 
                       __NSCarbonMenuWindowTrackingAreaReference.userData, 
                       __NSCheckBoxPlugin._checkBoxPluginFlags, __NSColorPanelToolbar._isMoving, 
                       __NSColorPanelToolbar._refusesToBeShown, __NSColorPanelToolbar._reserved, 
                       __NSColorPanelToolbar.colorPanel, __NSColorPanelToolbarItem.representedObject, 
                       __NSComboBoxPlugin._originalMaxValue, __NSComboBoxPlugin._originalMinValue, 
                       __NSControllerArrayProxyMutatorArray._controller, 
                       __NSControllerArrayProxyMutatorArray._keyPath, __NSControllerEditorSheetContext._delegate, 
                       __NSControllerEditorSheetContext._didCommitSelector, 
                       __NSControllerEditorSheetContext._embeddedContextInfo, 
                       __NSControllerTreeProxy._controller, __NSDatePickerCellExtraIvars._arrowLeftCell, 
                       __NSDatePickerCellExtraIvars._arrowRightCell, __NSDatePickerCellExtraIvars._calendarDisplayedMonthDateComponents, 
                       __NSDatePickerCellExtraIvars._changeMonthTimer, 
                       __NSDatePickerCellExtraIvars._disabledTextColor, 
                       __NSDatePickerCellExtraIvars._lastFireDateForChangeMonthTimer, 
                       __NSDatePickerCellExtraIvars._numberFormatter, __NSDatePickerCellExtraIvars._returnToHomeMonthButtonCell, 
                       __NSDatePickerCellSubfield._dateFormat, __NSDatePickerCellSubfield._element, 
                       __NSDatePickerCellSubfield._frame, __NSDatePickerCellSubfield._stringValue, 
                       __NSDatePickerRange._anchorOnLeft, __NSDatePickerRange._date, 
                       __NSDatePickerRange._timeInterval, __NSDateValueBinderPlugin._originalMaxValue, 
                       __NSDateValueBinderPlugin._originalMinValue, __NSDisplayFontBinderPlugin._displayFontBinderPluginFlags, 
                       __NSDoubleValueBinderPlugin._originalMaxValue, __NSDoubleValueBinderPlugin._originalMinValue, 
                       __NSDragManager._autoscrollDate, __NSDrawingThreadData.argument, 
                       __NSDrawingThreadData.selector, __NSDrawingThreadData.target, 
                       __NSDuplicateDocumentAnimationProjectionWindow.sourceWindow, 
                       __NSDuplicateDocumentAnimationProjectionWindow.targetWindow, 
                       __NSEventObserver._block, __NSEventObserver._mask, 
                       __NSExpectedObservingInfo._allSuppressedObject, 
                       __NSExpectedObservingInfo._specificSuppressedKeyPath, 
                       __NSExpectedObservingInfo._specificSuppressedObject, 
                       __NSExpectedObservingInfo._suppressAllNotificationCounter, 
                       __NSFilterPredicateVisitor._bail, __NSFilterPredicateVisitor._didFirstVisit, 
                       __NSFilterPredicateVisitor._predicateParts, __NSFilterPredicateVisitor._predicatePartsCount, 
                       __NSFilterPredicateVisitor._substitutedValue, __NSFilterPredicateVisitor._visitingIndex, 
                       __NSFocusStackElement._errorData, __NSFocusStackElement._originalWindow, 
                       __NSFocusStackElement._valid, __NSFocusStackElement._view, 
                       __NSGlobalEventObserver._handler, __NSIconAnimation._startingIconSize, 
                       __NSIconAnimation._targetIconSize, __NSIconViewDragContext.dragOperation, 
                       __NSIconViewDragContext.dropIndex, __NSIconViewDragContext.lastDropIndex, 
                       __NSIconViewDragContext.lastDropSourceMask, __NSImageAuxiliary.accessibilityDescriptionBacking, 
                       __NSImageAuxiliary.alignmentRectInNormalizedCoordinates, 
                       __NSImageAuxiliary.backgroundColor, __NSImageAuxiliary.cachedRep, 
                       __NSImageAuxiliary.capInsets, __NSImageAuxiliary.imageDelegate, 
                       __NSImageAuxiliary.resizingMode, __NSInputAlignmentControllerSession._activeFilter, 
                       __NSInputAlignmentControllerSession._alignmentGuidesAffectingItem, 
                       __NSInputAlignmentControllerSession._controller, 
                       __NSInputAlignmentControllerSession._item, __NSInputAlignmentGuide._guide, 
                       __NSInputAlignmentGuide._guideType, __NSInputAlignmentGuide._referenceValues, 
                       __NSInputAlignmentGuide._representativeIndex, __NSInputAlignmentItem._item, 
                       __NSInputAlignmentItem._representativeGuides, __NSInputAlignmentMatch._alignmentGuide, 
                       __NSInputAlignmentMatch._alignsX, __NSInputAlignmentMatch._alignsY, 
                       __NSInputAlignmentMatch._delta, __NSInputAlignmentMatch._item, 
                       __NSInputAlignmentMatch._itemRepresentativeGuide, 
                       __NSKeyBindingStateActual._atomList, __NSKeyBindingStateActual._currentAtomArray, 
                       __NSKeyBindingStateActual._currentInstance, __NSKeyBindingStateActual._repeatCount, 
                       __NSKeyBindingStateActual._stateFlag, __NSKeyBindingStateActual._toInsert, 
                       __NSKeyboardFocusClipView._adjustment, __NSKeyboardFocusClipView._bezelStyle, 
                       __NSKeyboardFocusClipView._drawFocus, __NSKeyboardFocusClipView._lastFocusRingRect, 
                       __NSKeyboardFocusClipView._representedView, __NSLazyFetchingArray._batchSize, 
                       __NSLazyFetchingArray._fetchedIndexes, __NSLazyFetchingArray._hasChanges, 
                       __NSLazyFetchingArray._madeMutable, __NSLazyFetchingArray._objects, 
                       __NSLazyFetchingArray._owner, __NSLazyFetchingArray._shouldFetchAllRanges, 
                       __NSLocalEventObserver._isAdditive, __NSMagnifier._continuous, 
                       __NSMagnifier._magnifyingGlassWindow, __NSMatrixPlugin._matrixPluginFlags, 
                       __NSMatrixPrivateIvars._cellBackgroundColor, __NSMatrixPrivateIvars._clickedCell, 
                       __NSMatrixPrivateIvars._drawingCol, __NSMatrixPrivateIvars._drawingRow, 
                       __NSMatrixPrivateIvars._getRowColumnOfCellLastFoundIndexCache, 
                       __NSMatrixPrivateIvars._keyCol, __NSMatrixPrivateIvars._keyRow, 
                       __NSMatrixPrivateIvars._mFlags2, __NSMatrixPrivateIvars._matrixMDFlags, 
                       __NSMenuContext._attrStringToCheck, __NSMenuContext._carbonCopyUTIs, 
                       __NSMenuContext._carbonPasteUTIs, __NSMenuContext._duplicateServicesMask, 
                       __NSMenuContext._errorLoadingUTIs, __NSMenuContext._fileURLsToCheck, 
                       __NSMenuContext._flags, __NSMenuContext._preloadedUTIsOfFileURLsToCheck, 
                       __NSMenuContext._rangeOfAttrStringToCheck, __NSMenuContext._rangeOfStringToCheck, 
                       __NSMenuContext._requestor, __NSMenuContext._requestorInfos, 
                       __NSMenuContext._sendTypes, __NSMenuContext._source, 
                       __NSMenuContext._stringToCheck, __NSMenuImpl._contextMenuPluginAEDesc, 
                       __NSMenuImpl._delegateClass, __NSMenuImpl._delegateWrapper, 
                       __NSMenuImpl._font, __NSMenuImpl._impl, __NSMenuImpl._indentationWidth, 
                       __NSMenuImpl._menuOwner, __NSMenuImpl._minimumWidth, 
                       __NSMenuImpl._name, __NSMenuImpl._startingRequestor, 
                       __NSMenuImpl._storyboard, __NSMenuImpl.sidebandUpdaters, 
                       __NSMenuServicesView._actualWidths, __NSMenuServicesView._bundlePath, 
                       __NSMenuServicesView._categoryName, __NSMenuServicesView._categoryNameWidth, 
                       __NSMenuServicesView._explicitMenuItem, __NSMenuServicesView._flags, 
                       __NSMenuServicesView._image, __NSMenuServicesView._minimumWidths, 
                       __NSMenuServicesViewOperation.completionBlocksToInvoke, 
                       __NSMenuServicesViewOperation.imageIsLoaded, __NSMenuServicesViewOperation.objectsToNotify, 
                       __NSMenuServicesViewOperation.path, __NSMenuServicesViewOperation.resultImage, 
                       __NSMultipleSelectionMatrixPlugin._mode, __NSMultipleSelectionMatrixPlugin._multipleSelectionMatrixPluginFlags, 
                       __NSOrderOutAnimationProxyWindowContentView.snapshot, 
                       __NSPasteboardItemCollection._cachedItemGenerationCount, 
                       __NSPasteboardItemCollection._sparsePasteboardItems, 
                       __NSPasteboardOwnersCollection._ownerCounts, __NSPasteboardOwnersCollection._ownersByIndex, 
                       __NSPasteboardOwnersCollection._pasteboard, __NSPasteboardTypeCache._cachedRequestOnlyTypeNames, 
                       __NSPasteboardTypeCache._cachedTypeNameUnion, __NSPasteboardTypeCache._cachedTypeNames, 
                       __NSPasteboardTypeCache._conformingTypeIdentifiers, 
                       __NSPboardImageTypeConverter._sourceType, __NSPeriodicEventSource.delay, 
                       __NSPeriodicEventSource.errorData, __NSPeriodicEventSource.period, 
                       __NSPeriodicEventSource.timer, __NSPeriodicInvoker._cancelled, 
                       __NSPeriodicInvoker._delay, __NSPeriodicInvoker._enabled, 
                       __NSPeriodicInvoker._helper, __NSPeriodicInvoker._work, 
                       __NSPopUpButtonPlugin._dynamicContentPlacementIndex, 
                       __NSPopUpButtonPlugin._dynamicallyGeneratedItems, 
                       __NSPopUpButtonPlugin._modeWhileIgnoringPopUpPopulation, 
                       __NSPredicateEditorRowNode.children, __NSPredicateEditorRowNode.copiedTemplateContainer, 
                       __NSPredicateEditorRowNode.templateViews, __NSPredicateEditorRowNode.tree, 
                       __NSPredicateEditorTree.children, __NSPredicateEditorTree.indexIntoTemplate, 
                       __NSPredicateEditorTree.menuItemIndex, __NSPredicateEditorTree.template, 
                       __NSPredicateEditorTree.title, __NSPrintThumbnailBaseView._initialKeyView, 
                       __NSPrintThumbnailBaseView._lastKeyView, __NSRuleEditorCache.indentation, 
                       __NSRuleEditorCache.rowIndex, __NSRuleEditorCache.rowObject, 
                       __NSRuleEditorViewUnboundRowHolder.boundArray, __NSScrollerStyleRecommender.iokitMachPort, 
                       __NSScrollerStyleRecommender.iokitNotificationMachPort, 
                       __NSScrollerStyleRecommender.iokitNotificationPort, 
                       __NSScrollerStyleRecommender.lastRecommendedScrollerStyle, 
                       __NSScrollerStyleRecommender.scrollerStyleRecommendationUpdateTimer, 
                       __NSScrollerStyleRecommender.servicePublishNotification, 
                       __NSScrollerStyleRecommender.serviceTerminationNotification, 
                       __NSSearchFieldBinderPredicateOptionPair._predicate, 
                       __NSSearchFieldBinderPredicateOptionPair._predicateName, 
                       __NSSearchFieldBinderPredicateOptionPair._predicateString, 
                       __NSSearchFieldBinderPredicateOptionPair._visitor, 
                       __NSServiceEntry._flags, __NSServiceEntry._serviceFilters, 
                       __NSServiceEntry.bundleIdentifier, __NSServiceEntry.bundlePath, 
                       __NSServiceEntry.defaultKeyboardShortcut, __NSServiceEntry.defaultTitle, 
                       __NSServiceEntry.executablePath, __NSServiceEntry.filter, 
                       __NSServiceEntry.keyboardShortcut, __NSServiceEntry.languages, 
                       __NSServiceEntry.localizedServiceDescription, __NSServiceEntry.localizedTitleWithoutSubstitutions, 
                       __NSServiceEntry.menuItemTitle, __NSServiceEntry.message, 
                       __NSServiceEntry.originalTitle, __NSServiceEntry.portName, 
                       __NSServiceEntry.returnTypes, __NSServiceEntry.sendFileTypes, 
                       __NSServiceEntry.sendPasteboardTypes, __NSServiceEntry.timeout, 
                       __NSServiceEntry.userData, __NSServiceEntry.uuid, 
                       __NSServiceFilter.bundleIdentifier, __NSServiceFilter.characterLimit, 
                       __NSServiceFilter.entry, __NSServiceFilter.fileType, 
                       __NSServiceFilter.flags, __NSServiceFilter.linkSchemes, 
                       __NSServiceFilter.nonstandardContentTypes, __NSServiceFilter.textLanguage, 
                       __NSServiceFilter.textScript, __NSServiceFilter.wordLimit, 
                       __NSServiceRequestorInfo.requestor, __NSServiceRequestorInfo.sendTypes, 
                       __NSServiceRequestorInfo.serviceEntries, __NSServicesContextMenuUpdater._pluggedMenu, 
                       __NSServicesContextMenuUpdater._pluggingMenu, __NSServicesContextMenuUpdater._requestorChain, 
                       __NSServicesContextMenuUpdater._submenuItem, __NSServicesMenuUpdater._pluggedMenuRef, 
                       __NSServicesMenuUpdater._servicesSeedChangeToken, 
                       __NSServicesMenuUpdater._updateGeneration, __NSSlideAndCrossFadeAnimationProjectionWindow.afterLayer, 
                       __NSSlideAndCrossFadeAnimationProjectionWindow.afterLayerFinalScreenRect, 
                       __NSSlideAndCrossFadeAnimationProjectionWindow.afterLayerInitialScreenRect, 
                       __NSSlideAndCrossFadeAnimationProjectionWindow.beforeLayer, 
                       __NSSlideAndCrossFadeAnimationProjectionWindow.beforeLayerFinalScreenRect, 
                       __NSSlideAndCrossFadeAnimationProjectionWindow.beforeLayerInitialScreenRect, 
                       __NSSoundAux._audioConverter, __NSSoundAux._audioDataLength, 
                       __NSSoundAux._audioDataReadHeadPosition, __NSSoundAux._audioFile, 
                       __NSSoundAux._audioFormat, __NSSoundAux._audioPacketDescriptions, 
                       __NSSoundAux._audioValidFrameCount, __NSSoundAux._converterBuffer, 
                       __NSSoundAux._ivarFlags, __NSSoundAux._maximumPackets, 
                       __NSSoundAux._outputUnit, __NSSoundAux._spinLock, 
                       __NSSoundAux._systemSoundCompletionHandler, __NSSoundAux._systemSoundID, 
                       __NSSoundAux._volume, __NSSoundAux.audioDeviceUID, 
                       __NSTabViewItemAuxiliary._springLoadingHighlight, 
                       __NSTabViewItemAuxiliary.cachedMinimumLabelSize, 
                       __NSTableColumnAuxiliary._bindingAdaptor, __NSTableColumnAuxiliary._headerToolTip, 
                       __NSTableColumnAuxiliary._sortDescriptorPrototype, 
                       __NSTableViewReserved._dynamicToolTipManager, __NSTableViewReserved._hiliteColId, 
                       __NSTableViewReserved._lastMouseDownLocalPoint, 
                       __NSTableViewReserved._rowSizeStyle, __NSTableViewReserved._selectionBlendingMode, 
                       __NSTableViewReserved._tvFlags2, __NSTableViewReserved._tvFlags4, 
                       __NSTableViewReserved.anchorRow, __NSTableViewReserved.archivedReusableViews, 
                       __NSTableViewReserved.autoSaveName, __NSTableViewReserved.cellTrackingData, 
                       __NSTableViewReserved.clickedColumn, __NSTableViewReserved.clickedRow, 
                       __NSTableViewReserved.columnLayoutMinRequiredVisibleWidth, 
                       __NSTableViewReserved.dragInfo, __NSTableViewReserved.draggingDestinationFeedbackStyle, 
                       __NSTableViewReserved.draggingSourceOperationMaskForLocal, 
                       __NSTableViewReserved.draggingSourceOperationMaskForNonLocal, 
                       __NSTableViewReserved.focusedColumn, __NSTableViewReserved.lastEditingCellFrame, 
                       __NSTableViewReserved.lastFocusRingFrame, __NSTableViewReserved.lastSelectRowEvent, 
                       __NSTableViewReserved.mouseDownEventNumber, __NSTableViewReserved.newSelectedRow, 
                       __NSTableViewReserved.nibExternalObjectsTables, 
                       __NSTableViewReserved.oldSelection, __NSTableViewReserved.preLiveColumnResizeFirstVisibleColumn, 
                       __NSTableViewReserved.preLiveColumnResizeFirstVisibleColumnInset, 
                       __NSTableViewReserved.preLiveColumnResizeWidthsByColumn, 
                       __NSTableViewReserved.rowHeightStorageX, __NSTableViewReserved.selectionChanging, 
                       __NSTableViewReserved.selectionHighlightStyle, __NSTableViewReserved.sortDescriptors, 
                       __NSTableViewReserved.trackingCell, __NSTableViewReserved.tvFlags3, 
                       __NSTableViewReserved.typeSelectData, __NSTableViewReserved.updateCount, 
                       __NSTextAnimationOverlayView._glyphRange, __NSTextAnimationOverlayView._renderer, 
                       __NSTextColorBinderPlugin._textColorBinderPluginFlags, 
                       __NSTextFieldPlugin._originalMaxValue, __NSTextFieldPlugin._originalMinValue, 
                       __NSThemeWidget._trackingTagNum, __NSThemeWidgetCell._buttonID, 
                       __NSThemeWidgetCell._coreUIDrawOptions, __NSThemeWidgetCell._hasRollover, 
                       __NSThemeWidgetCell._isObscured, __NSThemeWidgetCell._temporarilyDisabled, 
                       __NSToolbarAuxiliary._fullScreenAuxiliaryViewForceVisibleCounter, 
                       __NSToolbarAuxiliary._tbaFlags, __NSToolbarAuxiliary.allowedItems, 
                       __NSToolbarAuxiliary.autohideHeight, __NSToolbarAuxiliary.auxMaxHeight, 
                       __NSToolbarAuxiliary.auxMinHeight, __NSToolbarAuxiliary.backgroundColor, 
                       __NSToolbarAuxiliary.defaultItems, __NSToolbarAuxiliary.draggedTypes, 
                       __NSToolbarAuxiliary.identifiedItems, __NSToolbarAuxiliary.originalAutoresizingMask, 
                       __NSToolbarAuxiliary.savedMetrics, __NSToolbarAuxiliary.selectableItems, 
                       __NSToolbarAuxiliary.windowOriginOffsetWhenHidingHint, 
                       __NSToolbarConfigPanelLoader.panel, __NSToolbarGapItem._proxiedToolbarItem, 
                       __NSToolbarGapItem.resizeWeight, __NSToolbarGapItem.resizeWeightSharedWithDuplicateItems, 
                       __NSToolbarItemAuxiliary._allPossibleLabelsToFit, 
                       __NSToolbarItemAuxiliary._partitionAdapter, __NSToolbarItemAuxiliary._preferredWidthRatio, 
                       __NSToolbarItemAuxiliary._propertyListRepresentation, 
                       __NSToolbarItemAuxiliary._visibilityPriority, __NSToolbarItemConfigWrapperImageView.image, 
                       __NSToolbarItemConfigWrapperImageView.wrapper, __NSToolbarItemPlaceholder._hasCustomVisibilityPriority, 
                       __NSToolbarItemPlaceholder._itemIdentifier, __NSToolbarItemPlaceholder._propertyListRepresentation, 
                       __NSToolbarItemPlaceholder._tb, __NSToolbarItemPlaceholder._visibilityPriority, 
                       __NSToolbarItemViewerAccessibilityHelper._configuration, 
                       __NSToolbarItemViewerAccessibilityHelper._toolbarItemViewer, 
                       __NSToolbarItemViewerLabelCellPopUpCell._cachedOutputCellSize, 
                       __NSToolbarItemViewerLabelCellPopUpCell._itemViewer, 
                       __NSToolbarItemViewerLabelCellPopUpCell._realTitle, 
                       __NSToolbarProxyItemViewerAccessibilityHelper._realElement, 
                       __NSToolbarSeparator._inPalette, __NSToolbarSplitViewPartitionAdapter._dividerFrame, 
                       __NSToolbarSplitViewPartitionAdapter._dividerIndex, 
                       __NSToolbarSplitViewPartitionAdapter._splitView, 
                       __NSToolbarSplitViewPartitionAdapter._toolbarItem, 
                       __NSTreeNodeChildNodesArrayProxy._treeNode, __NSValueBinderPlugin._affectedIndex, 
                       __NSValueBinderPlugin._affectedIndexPath, __NSValueBinderPlugin._valueBinderPluginFlags, 
                       __NSValueBinderPlugin._valueClass, __NSViewAuxiliary._alphaValue, 
                       __NSViewAuxiliary._animationsDictionary, __NSViewAuxiliary._animator, 
                       __NSViewAuxiliary._appearance, __NSViewAuxiliary._backgroundColor, 
                       __NSViewAuxiliary._backgroundFilters, __NSViewAuxiliary._bindingAdaptor, 
                       __NSViewAuxiliary._cachedEffectiveAppearance, __NSViewAuxiliary._cachedVisibleRect, 
                       __NSViewAuxiliary._cachedWantsToPrefetchContent, 
                       __NSViewAuxiliary._clipPath, __NSViewAuxiliary._committedPreparedContentRect, 
                       __NSViewAuxiliary._compositingFilter, __NSViewAuxiliary._contentFilters, 
                       __NSViewAuxiliary._cornerRadius, __NSViewAuxiliary._descendentHasCachedVisibleRect, 
                       __NSViewAuxiliary._dontAskSuperForReferenceColorCheck, 
                       __NSViewAuxiliary._drawRectTimeStats, __NSViewAuxiliary._enumeratingSubviewsCount, 
                       __NSViewAuxiliary._errorOffsets, __NSViewAuxiliary._excludeSubviewsInCacheDisplayInRect, 
                       __NSViewAuxiliary._gestureRecognizers, __NSViewAuxiliary._gesturesEnabled, 
                       __NSViewAuxiliary._hasCachedContainingBackdropView, 
                       __NSViewAuxiliary._hasCachedVisibleRect, __NSViewAuxiliary._hasVibrancyFilter, 
                       __NSViewAuxiliary._idleTimerMonitor, __NSViewAuxiliary._isMagnifying, 
                       __NSViewAuxiliary._isScrolling, __NSViewAuxiliary._layerSurface, 
                       __NSViewAuxiliary._layoutAux, __NSViewAuxiliary._menu, 
                       __NSViewAuxiliary._needsGeometryInWindowDidChangeNotificationCount, 
                       __NSViewAuxiliary._opaqueIsPropagatedToCAView, __NSViewAuxiliary._preparedContentRect, 
                       __NSViewAuxiliary._registeredWithBackdropView, __NSViewAuxiliary._shadow, 
                       __NSViewAuxiliary._surface, __NSViewAuxiliary._surfaceColorSpace, 
                       __NSViewAuxiliary._trackingAreas, __NSViewAuxiliary._trackingAreasDirty, 
                       __NSViewAuxiliary._trackingRects, __NSViewAuxiliary._updateLayerHandler, 
                       __NSViewAuxiliary._userInterfaceItemIdentifier, 
                       __NSViewAuxiliary._userInterfaceItemIdentifierInternalNumber, 
                       __NSViewAuxiliary._vFlags2, __NSViewAuxiliary._vFlags3, 
                       __NSViewAuxiliary._vFlags4, __NSViewAuxiliary._vFlags5, 
                       __NSViewAuxiliary._viewController, __NSViewAuxiliary.oldSize, 
                       __NSViewAuxiliary.topLeft, __NSViewDrawOperation._options, 
                       __NSViewDrawOperation._owningDisplayOperation, __NSViewDrawOperation._rect, 
                       __NSViewDrawOperation._rectSet, __NSViewDrawOperation._view, 
                       __NSViewDrawOperation._windowRegion, __NSWorkspaceFileOperation.completionHandler, 
                       __NSWorkspaceFileOperation.lock, __NSWorkspaceFileOperation.operationRefs, 
                       __NSWorkspaceFileOperation.queue, __NSWorkspaceFileOperation.remainingURLs, 
                       __NSWorkspaceFileOperation.successfulFileCount, 
                       __NSWorkspaceFileOperation.urlToLastTriedName, __NSWorkspaceFileOperation.urlsOnVolumesWithoutTrash, 
                       __NSWorkspaceFileOperation.urlsToErrors, __NSWorkspaceFileOperation.urlsToNewURLs, 
                       __NSWorkspaceFileOperation.whichOperation, __NSWorkspaceVolumeStatusTracker._name, 
                       __NSWorkspaceVolumeStatusTracker._url, ___NSAppKitThreadSpecificData.NSActionCellReplacementString, 
                       ___NSAppKitThreadSpecificData.NSActionCellSelectionRange, 
                       ___NSAppKitThreadSpecificData.NSAlertCache, ___NSAppKitThreadSpecificData.NSCGSContextThreadStateStack, 
                       ___NSAppKitThreadSpecificData.NSCachedTitleCellMask, 
                       ___NSAppKitThreadSpecificData.NSCachedTitleCellSize, 
                       ___NSAppKitThreadSpecificData.NSCachedTitleCellTitle, 
                       ___NSAppKitThreadSpecificData.NSCarbonAppRunLoopEnterObserverRef, 
                       ___NSAppKitThreadSpecificData.NSCarbonAppRunLoopExitObserverRef, 
                       ___NSAppKitThreadSpecificData.NSColorPickerWheelImageCache, 
                       ___NSAppKitThreadSpecificData.NSCurrentAppearance, 
                       ___NSAppKitThreadSpecificData.NSCurrentDocumentVersion, 
                       ___NSAppKitThreadSpecificData.NSCurrentGraphicsContext, 
                       ___NSAppKitThreadSpecificData.NSCurrentNibLoadingBundles, 
                       ___NSAppKitThreadSpecificData.NSCurrentNibPaths, 
                       ___NSAppKitThreadSpecificData.NSCurrentPrintOperation, 
                       ___NSAppKitThreadSpecificData.NSDisplayOperationStack, 
                       ___NSAppKitThreadSpecificData.NSGlyphGeneratorCache, 
                       ___NSAppKitThreadSpecificData.NSLockCount, ___NSAppKitThreadSpecificData.NSOriginalVersionDocument, 
                       ___NSAppKitThreadSpecificData.NSPThreadSelf, ___NSAppKitThreadSpecificData.NSPeriodicEventSource, 
                       ___NSAppKitThreadSpecificData.NSPrintInfoStorage, 
                       ___NSAppKitThreadSpecificData.NSStringDrawingTextStorageSettings, 
                       ___NSAppKitThreadSpecificData.NSThreadFocusStack, 
                       ___NSAppKitThreadSpecificData.NSThreadFocusState, 
                       ___NSAppKitThreadSpecificData.NSThreadSequenceNumber, 
                       ___NSAppKitThreadSpecificData.NSWindowDisableFlushCounts, 
                       ___NSAppKitThreadSpecificData.NSWindowDisablePostingCounts, 
                       ___NSAppKitThreadSpecificData.reserved1, ___NSAppKitThreadSpecificData.reserved2, 
                       ___NSAppKitThreadSpecificData.reserved3, ___NSAppKitThreadSpecificData.reserved4, 
                       ___NSAppKitThreadSpecificData.reserved5, ___NSEventDiscardInfo.mask, 
                       ___NSEventDiscardInfo.time ]
  - archs:           [ i386, x86_64 ]
    re-exports:      [ /System/Library/Frameworks/ApplicationServices.framework/Versions/A/ApplicationServices, 
                       /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation, 
                       /System/Library/PrivateFrameworks/UIFoundation.framework/Versions/A/UIFoundation ]
    symbols:         [ '$ld$add$os10.5$__NSDictionaryOfVariableBindings', 
                       '$ld$add$os10.6$__NSDictionaryOfVariableBindings', 
                       '$ld$add$os10.7$__NSDictionaryOfVariableBindings', 
                       _GDBDumpCursorStack, _IBAppleScriptFramework, _IBCarbonFramework, 
                       _IBCocoaFramework, _IBSwingFramework, _NSAbortModalException, 
                       _NSAbortPrintingException, _NSAccessibilityActionDescription, 
                       _NSAccessibilityActivationPointAttribute, _NSAccessibilityAllObjectsAreAccessibilityElementsAttribute, 
                       _NSAccessibilityAllowedValuesAttribute, _NSAccessibilityAlternateUIVisibleAttribute, 
                       _NSAccessibilityAnimationOccurred, _NSAccessibilityAnimationTypeDownloadCompleted, 
                       _NSAccessibilityAnimationTypeDownloadStarted, _NSAccessibilityAnimationTypeKey, 
                       _NSAccessibilityAnimationTypeShake, _NSAccessibilityAnnouncementKey, 
                       _NSAccessibilityAnnouncementRequestedNotification, 
                       _NSAccessibilityAnyNotification, _NSAccessibilityApplicationActivatedNotification, 
                       _NSAccessibilityApplicationDeactivatedNotification, 
                       _NSAccessibilityApplicationHiddenNotification, _NSAccessibilityApplicationRole, 
                       _NSAccessibilityApplicationShownNotification, _NSAccessibilityAscendingSortDirectionValue, 
                       _NSAccessibilityAttachmentTextAttribute, _NSAccessibilityAttributeValue, 
                       _NSAccessibilityAttributedStringForRangeParameterizedAttribute, 
                       _NSAccessibilityAttributedValueForStringAttributeParameterizedAttribute, 
                       _NSAccessibilityAuditIssuesAttribute, _NSAccessibilityAutocorrectedTextAttribute, 
                       _NSAccessibilityAutocorrectionOccurred, _NSAccessibilityBackgroundColorTextAttribute, 
                       _NSAccessibilityBaseClasses, _NSAccessibilityBoundsForRangeParameterizedAttribute, 
                       _NSAccessibilityBrowserRole, _NSAccessibilityBusyIndicatorRole, 
                       _NSAccessibilityButtonRole, _NSAccessibilityCancelAction, 
                       _NSAccessibilityCancelButtonAttribute, _NSAccessibilityCancelDragAction, 
                       _NSAccessibilityCellForColumnAndRowParameterizedAttribute, 
                       _NSAccessibilityCellRole, _NSAccessibilityCenterTabStopMarkerTypeValue, 
                       _NSAccessibilityCentimetersUnitValue, _NSAccessibilityCheckBoxRole, 
                       _NSAccessibilityChildrenAttribute, _NSAccessibilityClearButtonAttribute, 
                       _NSAccessibilityCloseButtonAttribute, _NSAccessibilityCloseButtonSubrole, 
                       _NSAccessibilityColorWellRole, _NSAccessibilityColumnCountAttribute, 
                       _NSAccessibilityColumnHeaderUIElementsAttribute, 
                       _NSAccessibilityColumnIndexRangeAttribute, _NSAccessibilityColumnRole, 
                       _NSAccessibilityColumnTitlesAttribute, _NSAccessibilityColumnsAttribute, 
                       _NSAccessibilityComboBoxRole, _NSAccessibilityConfirmAction, 
                       _NSAccessibilityContainsProtectedContentAttribute, 
                       _NSAccessibilityContentIdentifier, _NSAccessibilityContentListSubrole, 
                       _NSAccessibilityContentNavigatorIdentifier, _NSAccessibilityContentsAttribute, 
                       _NSAccessibilityCreateAXUIElementRef, _NSAccessibilityCreatedNotification, 
                       _NSAccessibilityCriticalValueAttribute, _NSAccessibilityDateTimeAreaRole, 
                       _NSAccessibilityDateTimeComponentsAttribute, _NSAccessibilityDecimalTabStopMarkerTypeValue, 
                       _NSAccessibilityDecrementAction, _NSAccessibilityDecrementArrowSubrole, 
                       _NSAccessibilityDecrementButtonAttribute, _NSAccessibilityDecrementPageSubrole, 
                       _NSAccessibilityDefaultButtonAttribute, _NSAccessibilityDefinitionListSubrole, 
                       _NSAccessibilityDeleteAction, _NSAccessibilityDescendingSortDirectionValue, 
                       _NSAccessibilityDescriptionAttribute, _NSAccessibilityDescriptionListSubrole, 
                       _NSAccessibilityDialogSubrole, _NSAccessibilityDidEnterVersionBrowser, 
                       _NSAccessibilityDidExitVersionBrowser, _NSAccessibilityDisclosedByRowAttribute, 
                       _NSAccessibilityDisclosedRowsAttribute, _NSAccessibilityDisclosingAttribute, 
                       _NSAccessibilityDisclosureLevelAttribute, _NSAccessibilityDisclosureTriangleRole, 
                       _NSAccessibilityDocumentAttribute, _NSAccessibilityDraggingDestinationDragAcceptedNotification, 
                       _NSAccessibilityDraggingDestinationDragNotAcceptedNotification, 
                       _NSAccessibilityDraggingDestinationDropAllowedNotification, 
                       _NSAccessibilityDraggingDestinationDropNotAllowedNotification, 
                       _NSAccessibilityDraggingSourceDragBeganNotification, 
                       _NSAccessibilityDraggingSourceDragEndedNotification, 
                       _NSAccessibilityDrawerCreatedNotification, _NSAccessibilityDrawerRole, 
                       _NSAccessibilityEditedAttribute, _NSAccessibilityEnabledAttribute, 
                       _NSAccessibilityEnhancedUserInterfaceAttribute, 
                       _NSAccessibilityEntryPointActionNames, _NSAccessibilityEntryPointAttributeNames, 
                       _NSAccessibilityEntryPointIsAccessibilityElement, 
                       _NSAccessibilityEntryPointIsAttributeSettable, _NSAccessibilityEntryPointIsAttributeSupported, 
                       _NSAccessibilityEntryPointParameterizedAttributeNames, 
                       _NSAccessibilityEntryPointPerformAction, _NSAccessibilityEntryPointSetValueForAttribute, 
                       _NSAccessibilityEntryPointValueForAttribute, _NSAccessibilityEntryPointValueForAttributeWithParameter, 
                       _NSAccessibilityErrorCodeExceptionInfo, _NSAccessibilityEventProcessedNotification, 
                       _NSAccessibilityEventSourceProcessIDKey, _NSAccessibilityEventSourceStateIDKey, 
                       _NSAccessibilityEventSourceUserDataKey, _NSAccessibilityEventTimestampKey, 
                       _NSAccessibilityException, _NSAccessibilityExpandedAttribute, 
                       _NSAccessibilityExtrasMenuBarAttribute, _NSAccessibilityFilenameAttribute, 
                       _NSAccessibilityFirstLineIndentMarkerTypeValue, 
                       _NSAccessibilityFloatingWindowSubrole, _NSAccessibilityFocusedAttribute, 
                       _NSAccessibilityFocusedUIElementAttribute, _NSAccessibilityFocusedUIElementChangedNotification, 
                       _NSAccessibilityFocusedWindowAttribute, _NSAccessibilityFocusedWindowChangedNotification, 
                       _NSAccessibilityFontFamilyKey, _NSAccessibilityFontNameKey, 
                       _NSAccessibilityFontSizeKey, _NSAccessibilityFontTextAttribute, 
                       _NSAccessibilityForegroundColorTextAttribute, _NSAccessibilityFrameInView, 
                       _NSAccessibilityFrontmostAttribute, _NSAccessibilityFullScreenAttribute, 
                       _NSAccessibilityFullScreenButtonAttribute, _NSAccessibilityFullScreenButtonSubrole, 
                       _NSAccessibilityGridRole, _NSAccessibilityGroupRole, 
                       _NSAccessibilityGrowAreaAttribute, _NSAccessibilityGrowAreaRole, 
                       _NSAccessibilityHandleFocusChanged, _NSAccessibilityHandleRole, 
                       _NSAccessibilityHandlesAttribute, _NSAccessibilityHeadIndentMarkerTypeValue, 
                       _NSAccessibilityHeaderAttribute, _NSAccessibilityHeaderGroupAttribute, 
                       _NSAccessibilityHelpAttribute, _NSAccessibilityHelpTagCreatedNotification, 
                       _NSAccessibilityHelpTagRole, _NSAccessibilityHiddenAttribute, 
                       _NSAccessibilityHorizontalOrientationValue, _NSAccessibilityHorizontalScrollBarAttribute, 
                       _NSAccessibilityHorizontalUnitDescriptionAttribute, 
                       _NSAccessibilityHorizontalUnitsAttribute, _NSAccessibilityHorizontialUnitDescriptionAttribute, 
                       _NSAccessibilityHorizontialUnitsAttribute, _NSAccessibilityIdentifierAttribute, 
                       _NSAccessibilityImageRole, _NSAccessibilityInchesUnitValue, 
                       _NSAccessibilityIncrementAction, _NSAccessibilityIncrementArrowSubrole, 
                       _NSAccessibilityIncrementButtonAttribute, _NSAccessibilityIncrementPageSubrole, 
                       _NSAccessibilityIncrementorRole, _NSAccessibilityIndexAttribute, 
                       _NSAccessibilityIndexForChildUIElementParameterizedAttribute, 
                       _NSAccessibilityInsertionPointLineNumberAttribute, 
                       _NSAccessibilityIsAnyNotificationObserved, _NSAccessibilityIsAttributeSettable, 
                       _NSAccessibilityLabelUIElementsAttribute, _NSAccessibilityLabelValueAttribute, 
                       _NSAccessibilityLanguageTextAttribute, _NSAccessibilityLayoutAreaRole, 
                       _NSAccessibilityLayoutChangedNotification, _NSAccessibilityLayoutItemRole, 
                       _NSAccessibilityLayoutPointForScreenPointParameterizedAttribute, 
                       _NSAccessibilityLayoutSizeForScreenSizeParameterizedAttribute, 
                       _NSAccessibilityLeftTabStopMarkerTypeValue, _NSAccessibilityLevelIndicatorRole, 
                       _NSAccessibilityLineForIndexParameterizedAttribute, 
                       _NSAccessibilityLinkRole, _NSAccessibilityLinkTextAttribute, 
                       _NSAccessibilityLinkedUIElementsAttribute, _NSAccessibilityListItemIndexTextAttribute, 
                       _NSAccessibilityListItemLevelTextAttribute, _NSAccessibilityListItemPrefixTextAttribute, 
                       _NSAccessibilityListRole, _NSAccessibilityMainAttribute, 
                       _NSAccessibilityMainThreadIdleNotification, _NSAccessibilityMainThreadIdleUntilKey, 
                       _NSAccessibilityMainWindowAttribute, _NSAccessibilityMainWindowChangedNotification, 
                       _NSAccessibilityMarkedMisspelledTextAttribute, _NSAccessibilityMarkerGroupUIElementAttribute, 
                       _NSAccessibilityMarkerTypeAttribute, _NSAccessibilityMarkerTypeDescriptionAttribute, 
                       _NSAccessibilityMarkerUIElementsAttribute, _NSAccessibilityMarkerValuesAttribute, 
                       _NSAccessibilityMatteContentUIElementAttribute, 
                       _NSAccessibilityMatteHoleAttribute, _NSAccessibilityMatteRole, 
                       _NSAccessibilityMaxValueAttribute, _NSAccessibilityMenuBarAttribute, 
                       _NSAccessibilityMenuBarRole, _NSAccessibilityMenuButtonRole, 
                       _NSAccessibilityMenuItemRole, _NSAccessibilityMenuRole, 
                       _NSAccessibilityMinValueAttribute, _NSAccessibilityMinimizeButtonAttribute, 
                       _NSAccessibilityMinimizeButtonSubrole, _NSAccessibilityMinimizedAttribute, 
                       _NSAccessibilityMisspelledTextAttribute, _NSAccessibilityModalAttribute, 
                       _NSAccessibilityMovedNotification, _NSAccessibilityNaturalLanguageTextAttribute, 
                       _NSAccessibilityNextContentsAttribute, _NSAccessibilityNumberOfCharactersAttribute, 
                       _NSAccessibilityOpenAction, _NSAccessibilityOrderedByRowAttribute, 
                       _NSAccessibilityOrientationAttribute, _NSAccessibilityOutlineRole, 
                       _NSAccessibilityOutlineRowSubrole, _NSAccessibilityOverflowButtonAttribute, 
                       _NSAccessibilityParagraphStyleTextAttribute, _NSAccessibilityParentAttribute, 
                       _NSAccessibilityPathAttribute, _NSAccessibilityPicasUnitValue, 
                       _NSAccessibilityPickAction, _NSAccessibilityPlaceholderValueAttribute, 
                       _NSAccessibilityPointInView, _NSAccessibilityPointsUnitValue, 
                       _NSAccessibilityPopUpButtonRole, _NSAccessibilityPopoverRole, 
                       _NSAccessibilityPositionAttribute, _NSAccessibilityPostNotification, 
                       _NSAccessibilityPostNotificationForObservedElement, 
                       _NSAccessibilityPostNotificationForObservedElementWithUserInfo, 
                       _NSAccessibilityPostNotificationWithUserInfo, _NSAccessibilityPressAction, 
                       _NSAccessibilityPreviousContentsAttribute, _NSAccessibilityPriorityKey, 
                       _NSAccessibilityProgressIndicatorRole, _NSAccessibilityProxyAttribute, 
                       _NSAccessibilityRTFForRangeParameterizedAttribute, 
                       _NSAccessibilityRadioButtonRole, _NSAccessibilityRadioGroupRole, 
                       _NSAccessibilityRaiseAction, _NSAccessibilityRaiseArrayAttributeRangeException, 
                       _NSAccessibilityRaiseBadArgumentException, _NSAccessibilityRaiseUnsupportedActionException, 
                       _NSAccessibilityRangeForIndexParameterizedAttribute, 
                       _NSAccessibilityRangeForLineParameterizedAttribute, 
                       _NSAccessibilityRangeForPositionParameterizedAttribute, 
                       _NSAccessibilityRatingIndicatorSubrole, _NSAccessibilityRelevanceIndicatorRole, 
                       _NSAccessibilityRemoteApplicationElementsAddedNotification, 
                       _NSAccessibilityRemoteApplicationElementsKey, _NSAccessibilityRemoteApplicationElementsRemovedNotification, 
                       _NSAccessibilityReplacementStringTextAttribute, 
                       _NSAccessibilityResizedNotification, _NSAccessibilityRightTabStopMarkerTypeValue, 
                       _NSAccessibilityRoleAttribute, _NSAccessibilityRoleDescription, 
                       _NSAccessibilityRoleDescriptionAttribute, _NSAccessibilityRoleDescriptionForUIElement, 
                       _NSAccessibilityRowCollapsedNotification, _NSAccessibilityRowCountAttribute, 
                       _NSAccessibilityRowCountChangedNotification, _NSAccessibilityRowExpandedNotification, 
                       _NSAccessibilityRowHeaderUIElementsAttribute, _NSAccessibilityRowIndexRangeAttribute, 
                       _NSAccessibilityRowRole, _NSAccessibilityRowsAttribute, 
                       _NSAccessibilityRulerMarkerRole, _NSAccessibilityRulerRole, 
                       _NSAccessibilityScreenPointForLayoutPointParameterizedAttribute, 
                       _NSAccessibilityScreenSizeForLayoutSizeParameterizedAttribute, 
                       _NSAccessibilityScrollAreaRole, _NSAccessibilityScrollBarRole, 
                       _NSAccessibilitySearchButtonAttribute, _NSAccessibilitySearchFieldSubrole, 
                       _NSAccessibilitySearchIdentifier, _NSAccessibilitySearchMenuAttribute, 
                       _NSAccessibilitySectionDescriptionKey, _NSAccessibilitySectionObjectKey, 
                       _NSAccessibilitySectionUniqueIDKey, _NSAccessibilitySectionsAttribute, 
                       _NSAccessibilitySecureTextFieldSubrole, _NSAccessibilitySelectedAttribute, 
                       _NSAccessibilitySelectedCellsAttribute, _NSAccessibilitySelectedCellsChangedNotification, 
                       _NSAccessibilitySelectedChildrenAttribute, _NSAccessibilitySelectedChildrenChangedNotification, 
                       _NSAccessibilitySelectedChildrenMovedNotification, 
                       _NSAccessibilitySelectedColumnsAttribute, _NSAccessibilitySelectedColumnsChangedNotification, 
                       _NSAccessibilitySelectedRowsAttribute, _NSAccessibilitySelectedRowsChangedNotification, 
                       _NSAccessibilitySelectedTextAttribute, _NSAccessibilitySelectedTextChangedNotification, 
                       _NSAccessibilitySelectedTextRangeAttribute, _NSAccessibilitySelectedTextRangesAttribute, 
                       _NSAccessibilityServesAsTitleForUIElementsAttribute, 
                       _NSAccessibilitySetAttributeValue, _NSAccessibilitySetMayContainProtectedContent, 
                       _NSAccessibilityShadowTextAttribute, _NSAccessibilitySharedCharacterRangeAttribute, 
                       _NSAccessibilitySharedFocusElementsAttribute, _NSAccessibilitySharedTextElementForIndexParameterizedAttribute, 
                       _NSAccessibilitySharedTextUIElementsAttribute, _NSAccessibilitySheetCreatedNotification, 
                       _NSAccessibilitySheetRole, _NSAccessibilityShowAlternateUIAction, 
                       _NSAccessibilityShowDefaultUIAction, _NSAccessibilityShowMenuAction, 
                       _NSAccessibilityShownMenuAttribute, _NSAccessibilitySizeAttribute, 
                       _NSAccessibilitySliderRole, _NSAccessibilitySortButtonRole, 
                       _NSAccessibilitySortButtonSubrole, _NSAccessibilitySortDirectionAttribute, 
                       _NSAccessibilitySplitGroupRole, _NSAccessibilitySplitterRole, 
                       _NSAccessibilitySplittersAttribute, _NSAccessibilityStandardWindowSubrole, 
                       _NSAccessibilityStaticTextRole, _NSAccessibilityStrikethroughColorTextAttribute, 
                       _NSAccessibilityStrikethroughTextAttribute, _NSAccessibilityStringForRangeParameterizedAttribute, 
                       _NSAccessibilityStyleRangeForIndexParameterizedAttribute, 
                       _NSAccessibilitySubroleAttribute, _NSAccessibilitySuperscriptTextAttribute, 
                       _NSAccessibilitySupportsEventProcessedNotificationAttribute, 
                       _NSAccessibilitySupportsMainThreadIdleNotificationAttribute, 
                       _NSAccessibilitySwitchSubrole, _NSAccessibilitySystemDialogSubrole, 
                       _NSAccessibilitySystemFloatingWindowSubrole, _NSAccessibilitySystemWideRole, 
                       _NSAccessibilityTabGroupRole, _NSAccessibilityTableRole, 
                       _NSAccessibilityTableRowSubrole, _NSAccessibilityTabsAttribute, 
                       _NSAccessibilityTailIndentMarkerTypeValue, _NSAccessibilityTextAlignmentKey, 
                       _NSAccessibilityTextAreaRole, _NSAccessibilityTextAttachmentSubrole, 
                       _NSAccessibilityTextAttribute, _NSAccessibilityTextFieldRole, 
                       _NSAccessibilityTextInputMarkedRangeAttribute, _NSAccessibilityTextInputMarkingSessionBeganNotification, 
                       _NSAccessibilityTextInputMarkingSessionEndedNotification, 
                       _NSAccessibilityTextLinkSubrole, _NSAccessibilityTimelineSubrole, 
                       _NSAccessibilityTitleAttribute, _NSAccessibilityTitleChangedNotification, 
                       _NSAccessibilityTitleUIElementAttribute, _NSAccessibilityToggleSubrole, 
                       _NSAccessibilityToolbarButtonAttribute, _NSAccessibilityToolbarButtonSubrole, 
                       _NSAccessibilityToolbarRole, _NSAccessibilityTopLevelNavigatorIdentifier, 
                       _NSAccessibilityTopLevelUIElementAttribute, _NSAccessibilityUIElementDestroyedNotification, 
                       _NSAccessibilityUIElementsForRole, _NSAccessibilityUIElementsKey, 
                       _NSAccessibilityURLAttribute, _NSAccessibilityUnderlineColorTextAttribute, 
                       _NSAccessibilityUnderlineTextAttribute, _NSAccessibilityUnignoredAncestor, 
                       _NSAccessibilityUnignoredChildren, _NSAccessibilityUnignoredChildrenAttribute, 
                       _NSAccessibilityUnignoredChildrenForOnlyChild, _NSAccessibilityUnignoredDescendant, 
                       _NSAccessibilityUnignoredParentAttribute, _NSAccessibilityUnitDescriptionAttribute, 
                       _NSAccessibilityUnitsAttribute, _NSAccessibilityUnitsChangedNotification, 
                       _NSAccessibilityUnknownMarkerTypeValue, _NSAccessibilityUnknownOrientationValue, 
                       _NSAccessibilityUnknownRole, _NSAccessibilityUnknownSortDirectionValue, 
                       _NSAccessibilityUnknownSubrole, _NSAccessibilityUnknownUnitValue, 
                       _NSAccessibilityUnregisterUniqueIdForUIElement, 
                       _NSAccessibilityValueAttribute, _NSAccessibilityValueChangedNotification, 
                       _NSAccessibilityValueDescriptionAttribute, _NSAccessibilityValueIndicatorRole, 
                       _NSAccessibilityVerticalOrientationValue, _NSAccessibilityVerticalScrollBarAttribute, 
                       _NSAccessibilityVerticalUnitDescriptionAttribute, 
                       _NSAccessibilityVerticalUnitsAttribute, _NSAccessibilityVisibleCellsAttribute, 
                       _NSAccessibilityVisibleCharacterRangeAttribute, 
                       _NSAccessibilityVisibleChildrenAttribute, _NSAccessibilityVisibleColumnsAttribute, 
                       _NSAccessibilityVisibleNameKey, _NSAccessibilityVisibleRowsAttribute, 
                       _NSAccessibilityVisualTextAlignmentKey, _NSAccessibilityWarningValueAttribute, 
                       _NSAccessibilityWindowAttribute, _NSAccessibilityWindowCreatedNotification, 
                       _NSAccessibilityWindowDeminiaturizedNotification, 
                       _NSAccessibilityWindowMiniaturizedNotification, 
                       _NSAccessibilityWindowMovedNotification, _NSAccessibilityWindowProxyRole, 
                       _NSAccessibilityWindowResizedNotification, _NSAccessibilityWindowRole, 
                       _NSAccessibilityWindowTitleRole, _NSAccessibilityWindowsAttribute, 
                       _NSAccessibilityZoomButtonAttribute, _NSAccessibilityZoomButtonSubrole, 
                       _NSAlignmentBinding, _NSAllowsEditingMultipleValuesSelectionBindingOption, 
                       _NSAllowsNullArgumentBindingOption, _NSAlternateImageBinding, 
                       _NSAlternateTitleBinding, _NSAlwaysPresentsApplicationModalAlertsBindingOption, 
                       _NSAnimateBinding, _NSAnimationDelayBinding, _NSAnimationProgressMark, 
                       _NSAnimationProgressMarkNotification, _NSAnimationTriggerOrderIn, 
                       _NSAnimationTriggerOrderOut, _NSAntialiasThresholdChangedNotification, 
                       _NSApp, _NSAppKitIgnoredException, _NSAppKitPropertyCreator, 
                       _NSAppKitVersionNumber, _NSAppKitVersionString, 
                       _NSAppKitVirtualMemoryException, _NSAppearanceNameAqua, 
                       _NSAppearanceNameLightContent, _NSAppearanceNameVibrantDark, 
                       _NSAppearanceNameVibrantLight, _NSAppearanceTextEffectsAttributeName, 
                       _NSAppleAquaColorVariantChangedNotification, _NSAppleGradientValuesChangedNotification, 
                       _NSAppleMenuName, _NSAppleMenuSubmenuName, _NSAppleNoRedisplayAppearancePreferenceChanged, 
                       _NSApplicationDidBecomeActiveNotification, _NSApplicationDidChangeAccessibilityEnhancedUserInterfaceNotification, 
                       _NSApplicationDidChangeFocusedUIElementNotification, 
                       _NSApplicationDidChangeOcclusionStateNotification, 
                       _NSApplicationDidChangeScreenParametersNotification, 
                       _NSApplicationDidFinishLaunchingNotification, _NSApplicationDidFinishRestoringWindowsNotification, 
                       _NSApplicationDidHideNotification, _NSApplicationDidResignActiveNotification, 
                       _NSApplicationDidUnhideNotification, _NSApplicationDidUpdateNotification, 
                       _NSApplicationDockDidRestartNotification, _NSApplicationExtensionSessionMain, 
                       _NSApplicationFileType, _NSApplicationLaunchIsDefaultLaunchKey, 
                       _NSApplicationLaunchRemoteNotificationKey, _NSApplicationLaunchUserNotificationKey, 
                       _NSApplicationLoad, _NSApplicationMain, _NSApplicationWillBecomeActiveNotification, 
                       _NSApplicationWillFinishLaunchingNotification, _NSApplicationWillHideNotification, 
                       _NSApplicationWillResignActiveNotification, _NSApplicationWillTerminateNotification, 
                       _NSApplicationWillUnhideNotification, _NSApplicationWillUpdateNotification, 
                       _NSArgumentBinding, _NSAttributedStringBinding, 
                       _NSAttributedStringFromMacSimpleTextData, _NSAutorecalculatesContentBorderThicknessKeyForEdge, 
                       _NSAvailableWindowDepths, _NSBackingPropertyOldColorSpaceKey, 
                       _NSBackingPropertyOldScaleFactorKey, _NSBadBitmapParametersException, 
                       _NSBadComparisonException, _NSBadRTFColorTableException, 
                       _NSBadRTFDirectiveException, _NSBadRTFFontTableException, 
                       _NSBadRTFStyleSheetException, _NSBeep, _NSBeginAlertSheet, 
                       _NSBeginCriticalAlertSheet, _NSBeginInformationalAlertSheet, 
                       _NSBestDepth, _NSBitmapImageRepRespectOrientationKey, 
                       _NSBitsPerPixelFromDepth, _NSBitsPerSampleFromDepth, 
                       _NSBlack, _NSBoldSystemFont, _NSBrowserColumnConfigurationDidChangeNotification, 
                       _NSBrowserIllegalDelegateException, _NSCalibratedBlackColorSpace, 
                       _NSCalibratedRGBColorSpace, _NSCalibratedWhiteColorSpace, 
                       _NSCarbonWindowPropertyTag, _NSClassAndMethodExceptionInfo, 
                       _NSClickNotification, _NSClipFrameRect, _NSClipRectFill, 
                       _NSCollectionElementKindSelectionRectIndicator, 
                       _NSColorListDidChangeNotification, _NSColorListIOException, 
                       _NSColorListNotEditableException, _NSColorPanelColorDidChangeNotification, 
                       _NSColorPboardType, _NSColorSpaceFromDepth, _NSComboBoxCellSelectionDidChangeNotification, 
                       _NSComboBoxCellSelectionIsChangingNotification, 
                       _NSComboBoxCellWillDismissNotification, _NSComboBoxCellWillPopUpNotification, 
                       _NSComboBoxSelectionDidChangeNotification, _NSComboBoxSelectionIsChangingNotification, 
                       _NSComboBoxWillDismissNotification, _NSComboBoxWillPopUpNotification, 
                       _NSComposite, _NSCompositeRect, _NSConditionallySetsEditableBindingOption, 
                       _NSConditionallySetsEnabledBindingOption, _NSConditionallySetsHiddenBindingOption, 
                       _NSContainRect, _NSContentArrayBinding, _NSContentArrayForMultipleSelectionBinding, 
                       _NSContentBinding, _NSContentBorderThicknessKeyForEdge, 
                       _NSContentDictionaryBinding, _NSContentHeightBinding, 
                       _NSContentObjectBinding, _NSContentObjectsBinding, 
                       _NSContentPlacementTagBindingOption, _NSContentSetBinding, 
                       _NSContentValuesBinding, _NSContentWidthBinding, 
                       _NSContextHelpFilename, _NSContextHelpModeDidActivateNotification, 
                       _NSContextHelpModeDidDeactivateNotification, _NSContinuouslyUpdatesValueBindingOption, 
                       _NSControlTextDidBeginEditingNotification, _NSControlTextDidChangeNotification, 
                       _NSControlTextDidEndEditingNotification, _NSControlTintDidChangeNotification, 
                       _NSCopyBits, _NSCopyBitsFromGraphicsContext, _NSCountWindows, 
                       _NSCountWindowsForContext, _NSCreateFileContentsPboardType, 
                       _NSCreateFilenamePboardType, _NSCreatesSortDescriptorBindingOption, 
                       _NSCriticalValueBinding, _NSCustomColorSpace, _NSDIBPboardType, 
                       _NSDarkGray, _NSDataBinding, _NSDataLinkFilenameExtension, 
                       _NSDataLinkPboardType, _NSDefinitionPresentationTypeDictionaryApplication, 
                       _NSDefinitionPresentationTypeKey, _NSDefinitionPresentationTypeOverlay, 
                       _NSDeletesObjectsOnRemoveBindingsOption, _NSDeviceBitsPerSample, 
                       _NSDeviceBlackColorSpace, _NSDeviceCMYKColorSpace, 
                       _NSDeviceColorSpaceName, _NSDeviceIsPrinter, _NSDeviceIsScreen, 
                       _NSDeviceRGBColorSpace, _NSDeviceResolution, _NSDeviceSize, 
                       _NSDeviceWhiteColorSpace, _NSDifferenceRanges, _NSDirectoryFileType, 
                       _NSDisableScreenUpdates, _NSDisplayNameBindingOption, 
                       _NSDisplayPatternBindingOption, _NSDisplayPatternTitleBinding, 
                       _NSDisplayPatternValueBinding, _NSDockTileMiniViewDidHideNotification, 
                       _NSDockTileMiniViewDidShowNotification, _NSDocumentEditedBinding, 
                       _NSDottedFrameRect, _NSDoubleClickArgumentBinding, 
                       _NSDoubleClickTargetBinding, _NSDownloadContentType, 
                       _NSDownloadDestination, _NSDownloadFileCreator, 
                       _NSDownloadFileType, _NSDownloadFilename, _NSDownloadInitialFileContents, 
                       _NSDownloadIsSave, _NSDownloadMIMEType, _NSDownloadRiskCategory, 
                       _NSDownloadRiskCategoryContainsUnsafeExecutable, 
                       _NSDownloadRiskCategoryMayContainUnsafeExecutable, 
                       _NSDownloadRiskCategorySafe, _NSDownloadRiskCategoryUnknown, 
                       _NSDownloadRiskCategoryUnsafeExecutable, _NSDownloadSourceURL, 
                       _NSDownloadUserInteractionRequired, _NSDragCancelLimitDefault, 
                       _NSDragPboard, _NSDraggingException, _NSDraggingImageComponentDraggingItemKey, 
                       _NSDraggingImageComponentIconKey, _NSDraggingImageComponentLabelKey, 
                       _NSDrawBitmap, _NSDrawButton, _NSDrawColorTiledRects, 
                       _NSDrawDarkBezel, _NSDrawGrayBezel, _NSDrawGroove, 
                       _NSDrawHelpAreaBar, _NSDrawHelpAreaMenuBackground, 
                       _NSDrawHelpAreaMenuItemBackground, _NSDrawHelpResultsSeparator, 
                       _NSDrawLightBezel, _NSDrawMenuBackground, _NSDrawMenuItemBackground, 
                       _NSDrawNinePartImage, _NSDrawOverlayForMenuHelpResults, 
                       _NSDrawOverlayForMenuSearchResults, _NSDrawScopeBar, 
                       _NSDrawSearchAreaBar, _NSDrawSearchAreaMenuBackground, 
                       _NSDrawSearchAreaMenuItemBackground, _NSDrawSearchResultsSeparator, 
                       _NSDrawSourceListBackground, _NSDrawThreePartImage, 
                       _NSDrawTiledRects, _NSDrawTruthContentButton, _NSDrawTruthKeyFrameBezel, 
                       _NSDrawTruthKeyFrameButton, _NSDrawTruthMainFrameBezel, 
                       _NSDrawTruthMainFrameButton, _NSDrawTruthNotActiveFrameBezel, 
                       _NSDrawTruthNotActiveFrameButton, _NSDrawTruthTearOffTitlebarButton, 
                       _NSDrawWhiteBezel, _NSDrawWindowBackground, _NSDrawerDidCloseNotification, 
                       _NSDrawerDidOpenNotification, _NSDrawerWillCloseNotification, 
                       _NSDrawerWillOpenNotification, _NSDumpCGImage, _NSDumpImage, 
                       _NSDynamicSystemColorSpace, _NSEditableBinding, 
                       _NSEmbossmentEffectKey, _NSEnableScreenUpdates, 
                       _NSEnabledBinding, _NSEraseRect, _NSErrorCodeExceptionInfo, 
                       _NSEventTrackingRunLoopMode, _NSExcludedKeysBinding, 
                       _NSFileContentsPboardType, _NSFilenamesPboardType, 
                       _NSFilesPromisePboardType, _NSFilesystemFileType, 
                       _NSFilterPredicateBinding, _NSFindPanelCaseInsensitiveSearch, 
                       _NSFindPanelMaxRecentStrings, _NSFindPanelSearchOptionsPboardType, 
                       _NSFindPanelSubstringMatch, _NSFindPboard, _NSFocusReceivedNotification, 
                       _NSFontBinding, _NSFontBoldBinding, _NSFontCascadeListAttribute, 
                       _NSFontCharacterSetAttribute, _NSFontCollectionPath, 
                       _NSFontCollectionPathForUser, _NSFontColorAttribute, 
                       _NSFontDesignDefault, _NSFontDesignTrait, _NSFontFamilyNameBinding, 
                       _NSFontFavoritesFilename, _NSFontFavoritesFilenameForUser, 
                       _NSFontFeatureSelectorIdentifierKey, _NSFontFeatureSettingsAttribute, 
                       _NSFontFeatureTypeIdentifierKey, _NSFontFixedAdvanceAttribute, 
                       _NSFontFlippedMatrix, _NSFontIdentityMatrix, _NSFontItalicBinding, 
                       _NSFontMenuName, _NSFontNameBinding, _NSFontOptionsUpdateNotification, 
                       _NSFontPboard, _NSFontPboardType, _NSFontSetChangedNotification, 
                       _NSFontSizeBinding, _NSFontSlantTrait, _NSFontSystemFontDesignDefault, 
                       _NSFontSystemFontDesignTrait, _NSFontUnavailableException, 
                       _NSFontVariationAttribute, _NSFontVariationAxisDefaultValueKey, 
                       _NSFontVariationAxisIdentifierKey, _NSFontVariationAxisMaximumValueKey, 
                       _NSFontVariationAxisMinimumValueKey, _NSFontVariationAxisNameKey, 
                       _NSFontWeightBlack, _NSFontWeightBold, _NSFontWeightHeavy, 
                       _NSFontWeightLight, _NSFontWeightMedium, _NSFontWeightRegular, 
                       _NSFontWeightSemibold, _NSFontWeightThin, _NSFontWeightTrait, 
                       _NSFontWeightUltraLight, _NSFontWidthCondensed, 
                       _NSFontWidthExpanded, _NSFontWidthStandard, _NSFontWidthTrait, 
                       _NSFrameRect, _NSFrameRectWithWidth, _NSFrameRectWithWidthUsingOperation, 
                       _NSFullScreenModeAllScreens, _NSFullScreenModeAnimation, 
                       _NSFullScreenModeApplicationPresentationOptions, 
                       _NSFullScreenModeAspectRatio, _NSFullScreenModeBackgroundColor, 
                       _NSFullScreenModeSetting, _NSFullScreenModeWindowLevel, 
                       _NSGeneralPboard, _NSGetAlertPanel, _NSGetBooleanDefault, 
                       _NSGetCriticalAlertPanel, _NSGetFileType, _NSGetFileTypes, 
                       _NSGetInformationalAlertPanel, _NSGetIntegerDefault, 
                       _NSGetWindowServerMemory, _NSGlowEffectKey, _NSGraphicsContextDestinationAttributeName, 
                       _NSGraphicsContextPDFFormat, _NSGraphicsContextPSFormat, 
                       _NSGraphicsContextRepresentationFormatAttributeName, 
                       _NSGraphicsRunLoopMode, _NSHTMLPboardType, _NSHandlesContentAsCompoundValueBindingOption, 
                       _NSHeaderTitleBinding, _NSHelpManagerSystemBook, 
                       _NSHelpRTFDKey, _NSHelpRTFKey, _NSHelpVersionKey, 
                       _NSHelpVersionValue, _NSHiddenBinding, _NSHighlightRect, 
                       _NSHilitedNotification, _NSIconSize, _NSIdleNotification, 
                       _NSIllegalSelectorException, _NSImageBinding, _NSImageCacheException, 
                       _NSImageColorSyncProfileData, _NSImageCompressionFactor, 
                       _NSImageCompressionMethod, _NSImageCurrentFrame, 
                       _NSImageCurrentFrameDuration, _NSImageDitherTransparency, 
                       _NSImageEXIFData, _NSImageFallbackBackgroundColor, 
                       _NSImageFrameCount, _NSImageGamma, _NSImageHintCTM, 
                       _NSImageHintInterpolation, _NSImageInterlaced, _NSImageLoopCount, 
                       _NSImageNameActionTemplate, _NSImageNameAddBookmarkTemplate, 
                       _NSImageNameAddTemplate, _NSImageNameAdvanced, _NSImageNameApplicationIcon, 
                       _NSImageNameAudioOutputMuteTemplate, _NSImageNameAudioOutputVolumeHighTemplate, 
                       _NSImageNameAudioOutputVolumeLowTemplate, _NSImageNameAudioOutputVolumeMedTemplate, 
                       _NSImageNameAudioOutputVolumeOffTemplate, _NSImageNameBluetoothTemplate, 
                       _NSImageNameBonjour, _NSImageNameBookmarksTemplate, 
                       _NSImageNameCaution, _NSImageNameColorPanel, _NSImageNameColumnViewTemplate, 
                       _NSImageNameComputer, _NSImageNameDotMac, _NSImageNameDropDownIndicatorTemplate, 
                       _NSImageNameEnterFullScreenTemplate, _NSImageNameEveryone, 
                       _NSImageNameExitFullScreenTemplate, _NSImageNameFastForwardTemplate, 
                       _NSImageNameFlowViewTemplate, _NSImageNameFolder, 
                       _NSImageNameFolderBurnable, _NSImageNameFolderSmart, 
                       _NSImageNameFollowLinkFreestandingTemplate, _NSImageNameFontPanel, 
                       _NSImageNameGoLeftSmall, _NSImageNameGoLeftTemplate, 
                       _NSImageNameGoRightSmall, _NSImageNameGoRightTemplate, 
                       _NSImageNameHomeTemplate, _NSImageNameIChatTheaterTemplate, 
                       _NSImageNameIconViewTemplate, _NSImageNameInfo, 
                       _NSImageNameInvalidDataFreestandingTemplate, _NSImageNameLeftFacingTriangleTemplate, 
                       _NSImageNameLegacyScrollerCorner, _NSImageNameLegacyScrollerCornerSmall, 
                       _NSImageNameListViewTemplate, _NSImageNameLockLockedTemplate, 
                       _NSImageNameLockUnlockedTemplate, _NSImageNameMenuMixedStateTemplate, 
                       _NSImageNameMenuOnStateTemplate, _NSImageNameMobileMe, 
                       _NSImageNameMoveSpliterDownTemplate, _NSImageNameMoveSplitterLeftTemplate, 
                       _NSImageNameMoveSplitterRightTemplate, _NSImageNameMoveSplitterUpTemplate, 
                       _NSImageNameMultipleDocuments, _NSImageNameNetwork, 
                       _NSImageNamePathTemplate, _NSImageNamePauseTemplate, 
                       _NSImageNamePlayTemplate, _NSImageNamePreferencesGeneral, 
                       _NSImageNamePrivateArrowNextTemplate, _NSImageNamePrivateArrowPreviousTemplate, 
                       _NSImageNamePrivateChaptersTemplate, _NSImageNameQuickLookTemplate, 
                       _NSImageNameRecordStartTemplate, _NSImageNameRecordStopTemplate, 
                       _NSImageNameRefreshFreestandingTemplate, _NSImageNameRefreshTemplate, 
                       _NSImageNameRemoveTemplate, _NSImageNameRevealFreestandingTemplate, 
                       _NSImageNameRewindTemplate, _NSImageNameRightFacingTriangleTemplate, 
                       _NSImageNameScriptTemplate, _NSImageNameSecurity, 
                       _NSImageNameShareTemplate, _NSImageNameSkipAheadTemplate, 
                       _NSImageNameSkipBackTemplate, _NSImageNameSlideshowTemplate, 
                       _NSImageNameSmartBadgeTemplate, _NSImageNameStatusAvailable, 
                       _NSImageNameStatusAvailableFlat, _NSImageNameStatusAway, 
                       _NSImageNameStatusIdle, _NSImageNameStatusNone, 
                       _NSImageNameStatusNoneFlat, _NSImageNameStatusOffline, 
                       _NSImageNameStatusPartiallyAvailable, _NSImageNameStatusPartiallyAvailableFlat, 
                       _NSImageNameStatusUnavailable, _NSImageNameStatusUnavailableFlat, 
                       _NSImageNameStatusUnknown, _NSImageNameStopProgressFreestandingTemplate, 
                       _NSImageNameStopProgressTemplate, _NSImageNameSynchronize, 
                       _NSImageNameToolbarBookmarks, _NSImageNameToolbarMoreTemplate, 
                       _NSImageNameTrashEmpty, _NSImageNameTrashFull, _NSImageNameUser, 
                       _NSImageNameUserAccounts, _NSImageNameUserGroup, 
                       _NSImageNameUserGuest, _NSImageProgressive, _NSImageRGBColorTable, 
                       _NSImageRepRegistryDidChangeNotification, _NSIncludedKeysBinding, 
                       _NSInitialKeyBinding, _NSInitialValueBinding, _NSInitializeCGFocusRingStyleForTime, 
                       _NSInkTextPboardType, _NSInputAlignmentFilterGuideEqualityThreshold, 
                       _NSInputManagerPortName, _NSInsertsNullPlaceholderBindingOption, 
                       _NSInspectorBarFontFamilyItemIdentifier, _NSInspectorBarFontSizeItemIdentifier, 
                       _NSInspectorBarFontStyleItemIdentifier, _NSInspectorBarFontTypefaceItemIdentifier, 
                       _NSInspectorBarSeparatorItemIdentifier, _NSInspectorBarSpaceItemIdentifier, 
                       _NSInspectorBarTextAlignmentItemIdentifier, _NSInspectorBarTextBackgroundColorItemIdentifier, 
                       _NSInspectorBarTextForegroundColorItemIdentifier, 
                       _NSInspectorBarTextLineSpacingItemIdentifier, _NSInspectorBarTextListItemIdentifier, 
                       _NSInspectorBarTextStyleItemIdentifier, _NSInterfaceStyleDefault, 
                       _NSInterfaceStyleForKey, _NSInvokesSeparatelyWithArrayObjectsBindingOption, 
                       _NSIsControllerMarker, _NSIsIndeterminateBinding, 
                       _NSKeyDictionaryControllerKey, _NSKeyDownNotification, 
                       _NSKeyUpNotification, _NSLabelBinding, _NSLastTransactionExceptionInfo, 
                       _NSLightGray, _NSLocalizedKeyDictionaryBinding, 
                       _NSLocalizedKeyDictionaryControllerKey, _NSMainMenuName, 
                       _NSManagedObjectContextBinding, _NSMaxValueBinding, 
                       _NSMaxWidthBinding, _NSMaximumRecentsBinding, _NSMenuDidAddItemNotification, 
                       _NSMenuDidBeginTrackingNotification, _NSMenuDidChangeItemNotification, 
                       _NSMenuDidCompleteInteractionNotification, _NSMenuDidEndTrackingNotification, 
                       _NSMenuDidRemoveAllItemsNotification, _NSMenuDidRemoveItemNotification, 
                       _NSMenuDidSendActionNotification, _NSMenuFlashCount, 
                       _NSMenuWillSendActionNotification, _NSMinValueBinding, 
                       _NSMinWidthBinding, _NSMiscTraceFlavor, _NSMixedStateImageBinding, 
                       _NSModalPanelRunLoopMode, _NSMouseDownNotification, 
                       _NSMouseDraggedNotification, _NSMouseEnteredNotification, 
                       _NSMouseExitedNotification, _NSMouseMovedNotification, 
                       _NSMouseUpNotification, _NSMultipleTextSelectionPboardType, 
                       _NSMultipleValuesMarker, _NSMultipleValuesPlaceholderBindingOption, 
                       _NSNamedColorSpace, _NSNavCreationDateFileProperty, 
                       _NSNavDisplayNameFileProperty, _NSNavKeyValueChangeChildKey, 
                       _NSNavModDateFileProperty, _NSNavNodeAttributesArrayKey, 
                       _NSNavNodeAttributesChangedNotification, _NSNavNodeAttributesKey, 
                       _NSNavNodeChildrenChangedNotification, _NSNavNodePropertyChildren, 
                       _NSNavNodePropertyComment, _NSNavNodePropertyCreationDate, 
                       _NSNavNodePropertyDisplayName, _NSNavNodePropertyDisplayVersion, 
                       _NSNavNodePropertyIcon, _NSNavNodePropertyIsContainer, 
                       _NSNavNodePropertyKind, _NSNavNodePropertyKindWithoutPlatform, 
                       _NSNavNodePropertyLabelColor, _NSNavNodePropertyLabelColorIndex, 
                       _NSNavNodePropertyLabelName, _NSNavNodePropertyLastOpenedDate, 
                       _NSNavNodePropertyLogicalSize, _NSNavNodePropertyModDate, 
                       _NSNavNodePropertyName, _NSNavNodePropertyOpenSyncStarted, 
                       _NSNavNodePropertyPermissions, _NSNavNodePropertyPhysicalSize, 
                       _NSNavNodePropertyPreviewAttributes, _NSNavNodePropertyShortVersion, 
                       _NSNavNodePropertySystemVersion, _NSNavNodePropertyTypeIdentifier, 
                       _NSNavNodePropertyURL, _NSNavPhysicalSizeFileProperty, 
                       _NSNavPreviewAttributesForUTI, _NSNavPreviewTextForNode, 
                       _NSNibLoadingException, _NSNibOwner, _NSNibTopLevelObjects, 
                       _NSNoSelectionMarker, _NSNoSelectionPlaceholderBindingOption, 
                       _NSNotApplicableMarker, _NSNotApplicablePlaceholderBindingOption, 
                       _NSNullPlaceholderBindingOption, _NSNumberOfColorComponents, 
                       _NSObservedKeyPathKey, _NSObservedObjectKey, _NSOffStateImageBinding, 
                       _NSOnStateImageBinding, _NSOpenGLGetOption, _NSOpenGLGetVersion, 
                       _NSOpenGLSetOption, _NSOptionsKey, _NSOrderRanges, 
                       _NSOutlineViewColumnDidMoveNotification, _NSOutlineViewColumnDidResizeNotification, 
                       _NSOutlineViewDisclosureButtonKey, _NSOutlineViewItemDidCollapseNotification, 
                       _NSOutlineViewItemDidExpandNotification, _NSOutlineViewItemWillCollapseNotification, 
                       _NSOutlineViewItemWillExpandNotification, _NSOutlineViewSelectionDidChangeNotification, 
                       _NSOutlineViewSelectionIsChangingNotification, _NSOutlineViewShowHideButtonKey, 
                       _NSPDFPboardType, _NSPICTPboardType, _NSPNGPboardType, 
                       _NSPPDIncludeNotFoundException, _NSPPDIncludeStackOverflowException, 
                       _NSPPDIncludeStackUnderflowException, _NSPPDParseException, 
                       _NSPasteboardCommunicationException, _NSPasteboardTypeColor, 
                       _NSPasteboardTypeFindPanelSearchOptions, _NSPasteboardTypeFindPattern, 
                       _NSPasteboardTypeFont, _NSPasteboardTypeHTML, _NSPasteboardTypeMultipleTextSelection, 
                       _NSPasteboardTypePDF, _NSPasteboardTypePNG, _NSPasteboardTypeRTF, 
                       _NSPasteboardTypeRTFD, _NSPasteboardTypeRuler, _NSPasteboardTypeSound, 
                       _NSPasteboardTypeString, _NSPasteboardTypeTIFF, 
                       _NSPasteboardTypeTabularText, _NSPasteboardTypeTextFinderOptions, 
                       _NSPasteboardURLReadingContentsConformToTypesKey, 
                       _NSPasteboardURLReadingFileURLsOnlyKey, _NSPatternColorSpace, 
                       _NSPerformService, _NSPersistentUIBitmapEncryptionKeyDidChange, 
                       _NSPersistentUIOpenStateDirectory, _NSPlainFileType, 
                       _NSPlanarFromDepth, _NSPopUpButtonCellWillPopUpNotification, 
                       _NSPopUpButtonWillPopUpNotification, _NSPopUpMenuCarbonOptionsToSet, 
                       _NSPopUpMenuPopupButtonBounds, _NSPopUpMenuPopupButtonLabelOffset, 
                       _NSPopUpMenuPopupButtonSize, _NSPopUpMenuPopupButtonWidget, 
                       _NSPopoverCloseReasonDetachToWindow, _NSPopoverCloseReasonKey, 
                       _NSPopoverCloseReasonStandard, _NSPopoverCloseReasonUserInfoKey, 
                       _NSPopoverDidCloseNotification, _NSPopoverDidShowNotification, 
                       _NSPopoverWillCloseNotification, _NSPopoverWillShowNotification, 
                       _NSPositioningRectBinding, _NSPostScriptPboardType, 
                       _NSPredicateBinding, _NSPredicateFormatBindingOption, 
                       _NSPreferencesContentSize, _NSPreferencesDidChange, 
                       _NSPreferencesSelectedIndex, _NSPreferredScrollerStyleDidChangeNotification, 
                       _NSPrintAllPages, _NSPrintAllPresetsJobStyleHint, 
                       _NSPrintBottomMargin, _NSPrintCancelJob, _NSPrintCopies, 
                       _NSPrintDetailedErrorReporting, _NSPrintFaxCoverSheetName, 
                       _NSPrintFaxHighResolution, _NSPrintFaxJob, _NSPrintFaxModem, 
                       _NSPrintFaxNumber, _NSPrintFaxReceiverNames, _NSPrintFaxReceiverNumbers, 
                       _NSPrintFaxReturnReceipt, _NSPrintFaxSendTime, _NSPrintFaxTrimPageEnds, 
                       _NSPrintFaxUseCoverSheet, _NSPrintFirstPage, _NSPrintFormName, 
                       _NSPrintHeaderAndFooter, _NSPrintHorizontalPagination, 
                       _NSPrintHorizontallyCentered, _NSPrintInfoPageFormatAttributeKeys, 
                       _NSPrintInfoPrintSessionAttributeKeys, _NSPrintInfoPrintSettingsAttributeKeys, 
                       _NSPrintJobDisposition, _NSPrintJobFeatures, _NSPrintJobSavingFileNameExtensionHidden, 
                       _NSPrintJobSavingURL, _NSPrintLastPage, _NSPrintLeftMargin, 
                       _NSPrintManualFeed, _NSPrintMustCollate, _NSPrintNoPresetsJobStyleHint, 
                       _NSPrintOperationExistsException, _NSPrintOrientation, 
                       _NSPrintPackageException, _NSPrintPagesAcross, _NSPrintPagesDown, 
                       _NSPrintPagesPerSheet, _NSPrintPanelAccessorySummaryItemDescriptionKey, 
                       _NSPrintPanelAccessorySummaryItemNameKey, _NSPrintPaperFeed, 
                       _NSPrintPaperName, _NSPrintPaperSize, _NSPrintPhotoJobStyleHint, 
                       _NSPrintPreviewJob, _NSPrintPrinter, _NSPrintPrinterName, 
                       _NSPrintReversePageOrder, _NSPrintRightMargin, _NSPrintSaveJob, 
                       _NSPrintSavePath, _NSPrintScalingFactor, _NSPrintSelectionOnly, 
                       _NSPrintSpoolJob, _NSPrintTime, _NSPrintTopMargin, 
                       _NSPrintVerticalPagination, _NSPrintVerticallyCentered, 
                       _NSPrintingCommunicationException, _NSRTFDPboardType, 
                       _NSRTFPboardType, _NSRTFPropertyStackOverflowException, 
                       _NSRaisesForNotApplicableKeysBindingOption, _NSReadPixel, 
                       _NSRecentDocumentsMenuName, _NSRecentSearchesBinding, 
                       _NSRecoloringColorEffectKey, _NSRecommendedScrollerStyleDidChangeNotification, 
                       _NSRectClip, _NSRectClipList, _NSRectFill, _NSRectFillList, 
                       _NSRectFillListUsingOperation, _NSRectFillListWithColors, 
                       _NSRectFillListWithColorsUsingOperation, _NSRectFillListWithGrays, 
                       _NSRectFillUsingOperation, _NSRectangularTextSelectionPboardType, 
                       _NSRegisterServicesProvider, _NSReleaseAlertPanel, 
                       _NSRepresentedFilenameBinding, _NSRevertDocumentMenuName, 
                       _NSRowHeightBinding, _NSRuleEditorPredicateComparisonModifier, 
                       _NSRuleEditorPredicateCompoundType, _NSRuleEditorPredicateCustomSelector, 
                       _NSRuleEditorPredicateLeftExpression, _NSRuleEditorPredicateOperatorType, 
                       _NSRuleEditorPredicateOptions, _NSRuleEditorPredicateRightExpression, 
                       _NSRuleEditorRowCountChangeIndexes, _NSRuleEditorRowCountChangeType, 
                       _NSRuleEditorRowCountDidChangeNotification, _NSRuleEditorRowsDidChangeNotification, 
                       _NSRulerDocViewToRulerConversion, _NSRulerHashSizeCycle, 
                       _NSRulerHashSpacing, _NSRulerLabelInterval, _NSRulerPboard, 
                       _NSRulerPboardType, _NSRulerUnitAbbreviation, _NSRulerUnitConversionFactor, 
                       _NSRulerUnitStepDownCycle, _NSRulerUnitStepUpCycle, 
                       _NSRunAlertPanel, _NSRunAlertPanelRelativeToWindow, 
                       _NSRunCriticalAlertPanel, _NSRunCriticalAlertPanelRelativeToWindow, 
                       _NSRunInformationalAlertPanel, _NSRunInformationalAlertPanelRelativeToWindow, 
                       _NSScreenColorSpaceDidChangeNotification, _NSScrollViewDidEndLiveMagnifyNotification, 
                       _NSScrollViewDidEndLiveScrollNotification, _NSScrollViewDidLiveScrollNotification, 
                       _NSScrollViewWillStartLiveMagnifyNotification, _NSScrollViewWillStartLiveScrollNotification, 
                       _NSScrolledNotification, _NSScrollerPagingBehaviorDefault, 
                       _NSSegmentedCellSegmentShowingRolloverChangedNotification, 
                       _NSSelectedIdentifierBinding, _NSSelectedIndexBinding, 
                       _NSSelectedLabelBinding, _NSSelectedObjectBinding, 
                       _NSSelectedObjectsBinding, _NSSelectedTagBinding, 
                       _NSSelectedValueBinding, _NSSelectedValuesBinding, 
                       _NSSelectionIndexPathsBinding, _NSSelectionIndexesBinding, 
                       _NSSelectionMadeNotification, _NSSelectionPboardType, 
                       _NSSelectorExceptionInfo, _NSSelectorNameBindingOption, 
                       _NSSelectsAllWhenSettingContentBindingOption, _NSServiceControllerCopyServiceDictionaries, 
                       _NSServiceListenerName, _NSServicesCopyDynamicValueForKey, 
                       _NSServicesMenuName, _NSServicesWebSearchProviderKey, 
                       _NSSetFocusRingStyle, _NSSetShowsServicesMenuItem, 
                       _NSSetUseSplitCursor, _NSSetUseWritingDirectionKeyBindings, 
                       _NSShadowEffectKey, _NSSharingServiceMailExportFileKey, 
                       _NSSharingServiceMailExportFileObjectsKey, _NSSharingServiceMailExportFilesKey, 
                       _NSSharingServiceMailExportImageObjectsKey, _NSSharingServiceMailExportImagesKey, 
                       _NSSharingServiceMailExportTextKey, _NSSharingServiceMailExportTextObjectKey, 
                       _NSSharingServiceMailExportURLObjectKey, _NSSharingServiceMailExportWebArchiveObjectKey, 
                       _NSSharingServiceNameAddToAperture, _NSSharingServiceNameAddToIPhoto, 
                       _NSSharingServiceNameAddToSafariReadingList, _NSSharingServiceNameComposeEmail, 
                       _NSSharingServiceNameComposeMessage, _NSSharingServiceNameExportVideoOnFlickr, 
                       _NSSharingServiceNameExportVideoOnYouTube, _NSSharingServiceNamePostImageOnFlickr, 
                       _NSSharingServiceNamePostOnFacebook, _NSSharingServiceNamePostOnLinkedIn, 
                       _NSSharingServiceNamePostOnSinaWeibo, _NSSharingServiceNamePostOnTencentWeibo, 
                       _NSSharingServiceNamePostOnTwitter, _NSSharingServiceNamePostVideoOnFacebook, 
                       _NSSharingServiceNamePostVideoOnTudou, _NSSharingServiceNamePostVideoOnVimeo, 
                       _NSSharingServiceNamePostVideoOnYouku, _NSSharingServiceNameSendViaAirDrop, 
                       _NSSharingServiceNameUseAsAccountPicture, _NSSharingServiceNameUseAsBuddyPicture, 
                       _NSSharingServiceNameUseAsDesktopPicture, _NSSharingServiceNameUseAsFacebookProfileImage, 
                       _NSSharingServiceNameUseAsLinkedInProfileImage, 
                       _NSSharingServiceNameUseAsTwitterProfileImage, _NSSharingServiceOptionAlternateItemDisplayNameKey, 
                       _NSSharingServiceOptionAlternateItemIdentifierKey, 
                       _NSSharingServiceOptionAlternateItemUTIKey, _NSSharingServiceOptionAlternateItemsKey, 
                       _NSSharingServiceParametersAccountHintKey, _NSSharingServiceParametersAccountNameKey, 
                       _NSSharingServiceParametersAttachmentURLsKey, _NSSharingServiceParametersDefaultRecipientsKey, 
                       _NSSharingServiceParametersDefaultSubjectKey, _NSSharingServiceParametersDisableServiceWindowPresentationKey, 
                       _NSSharingServiceParametersDisplayStateKey, _NSSharingServiceParametersItemURLKey, 
                       _NSSharingServiceParametersMaskClientWindowKey, 
                       _NSSharingServiceParametersMenuItemCustomTitleKey, 
                       _NSSharingServiceParametersMenuItemIsAlternateKey, 
                       _NSSharingServiceParametersMenuItemKeyEquivalentKey, 
                       _NSSharingServiceParametersMenuItemKeyEquivalentModifierMaskKey, 
                       _NSSharingServiceParametersMessageKey, _NSSharingServiceParametersNarrowServiceWindowKey, 
                       _NSSharingServiceParametersPermaLinkKey, _NSSharingServiceParametersQuoteContentKey, 
                       _NSSharingServiceParametersRecipientsKey, _NSSharingServiceParametersSelectContentKey, 
                       _NSSharingServiceParametersSubjectKey, _NSSharingServiceParametersWebPageURLKey, 
                       _NSShellCommandFileType, _NSShowAnimationEffect, 
                       _NSShowSystemInfoPanel, _NSShowsServicesMenuItem, 
                       _NSSkipAheadRoundedTemplate, _NSSkipBackRoundedTemplate, 
                       _NSSortDescriptorsBinding, _NSSoundPboardType, _NSSpeechCharacterModeProperty, 
                       _NSSpeechCommandDelimiterProperty, _NSSpeechCommandPrefix, 
                       _NSSpeechCommandSuffix, _NSSpeechCurrentVoiceProperty, 
                       _NSSpeechDictionaryAbbreviations, _NSSpeechDictionaryEntryPhonemes, 
                       _NSSpeechDictionaryEntrySpelling, _NSSpeechDictionaryLocaleIdentifier, 
                       _NSSpeechDictionaryModificationDate, _NSSpeechDictionaryPronunciations, 
                       _NSSpeechErrorCount, _NSSpeechErrorNewestCharacterOffset, 
                       _NSSpeechErrorNewestCode, _NSSpeechErrorOldestCharacterOffset, 
                       _NSSpeechErrorOldestCode, _NSSpeechErrorsProperty, 
                       _NSSpeechInputModeProperty, _NSSpeechModeLiteral, 
                       _NSSpeechModeNormal, _NSSpeechModePhoneme, _NSSpeechModeText, 
                       _NSSpeechNumberModeProperty, _NSSpeechOutputToFileURLProperty, 
                       _NSSpeechPhonemeInfoExample, _NSSpeechPhonemeInfoHiliteEnd, 
                       _NSSpeechPhonemeInfoHiliteStart, _NSSpeechPhonemeInfoOpcode, 
                       _NSSpeechPhonemeInfoSymbol, _NSSpeechPhonemeSymbolsProperty, 
                       _NSSpeechPitchBaseProperty, _NSSpeechPitchModProperty, 
                       _NSSpeechRateProperty, _NSSpeechRecentSyncProperty, 
                       _NSSpeechResetProperty, _NSSpeechStatusNumberOfCharactersLeft, 
                       _NSSpeechStatusOutputBusy, _NSSpeechStatusOutputPaused, 
                       _NSSpeechStatusPhonemeCode, _NSSpeechStatusProperty, 
                       _NSSpeechSynthesizerBoundaryImmedidate, _NSSpeechSynthesizerBoundarySentence, 
                       _NSSpeechSynthesizerBoundaryWord, _NSSpeechSynthesizerInfoIdentifier, 
                       _NSSpeechSynthesizerInfoProperty, _NSSpeechSynthesizerInfoVersion, 
                       _NSSpeechVolumeProperty, _NSSpellCheckerDidChangeAutomaticDashSubstitutionNotification, 
                       _NSSpellCheckerDidChangeAutomaticQuoteSubstitutionNotification, 
                       _NSSpellCheckerDidChangeAutomaticSpellingCorrectionNotification, 
                       _NSSpellCheckerDidChangeAutomaticTextReplacementNotification, 
                       _NSSpellCheckerDidChangeLanguageNotification, _NSSpellCheckerDidLearnWordNotification, 
                       _NSSpellCheckerDidUnlearnWordNotification, _NSSpellCheckerDismissAuxiliaryWindowsNotification, 
                       _NSSplitViewControllerAutomaticDimension, _NSSplitViewDidResizeSubviewsNotification, 
                       _NSSplitViewDividerIndexKey, _NSSplitViewItemUnspecifiedDimension, 
                       _NSSplitViewUserResizeKey, _NSSplitViewWillResizeSubviewsNotification, 
                       _NSStringFromToolbarDisplayMode, _NSStringFromToolbarItemType, 
                       _NSStringFromToolbarSizeMode, _NSStringPboardType, 
                       _NSSystemColorPreferencesChangedNotification, _NSSystemColorsDidChangeNotification, 
                       _NSSystemFont, _NSTIFFException, _NSTIFFPboardType, 
                       _NSTableRowAnimationFromMask, _NSTableViewColumnDidMoveNotification, 
                       _NSTableViewColumnDidResizeNotification, _NSTableViewGroupViewKey, 
                       _NSTableViewRowViewKey, _NSTableViewSelectionDidChangeNotification, 
                       _NSTableViewSelectionIsChangingNotification, _NSTableViewTrackingAreaColumnKey, 
                       _NSTableViewTrackingAreaRowKey, _NSTabularTextPboardType, 
                       _NSTargetBinding, _NSTextCheckingDocumentAuthorKey, 
                       _NSTextCheckingDocumentTitleKey, _NSTextCheckingDocumentURLKey, 
                       _NSTextCheckingOrthographyKey, _NSTextCheckingQuotesKey, 
                       _NSTextCheckingReferenceDateKey, _NSTextCheckingReferenceTimeZoneKey, 
                       _NSTextCheckingRegularExpressionsKey, _NSTextCheckingReplacementsKey, 
                       _NSTextColorBinding, _NSTextDidBeginEditingNotification, 
                       _NSTextDidChangeNotification, _NSTextDidEndEditingNotification, 
                       _NSTextFinderCaseInsensitiveKey, _NSTextFinderMatchingTypeKey, 
                       _NSTextInputChromaticMarkedTextAttributeName, _NSTextInputContextKeyboardSelectionDidChangeNotification, 
                       _NSTextInputMarkedCandidatesForSearchAttributeName, 
                       _NSTextInputReplacementRangeAttributeName, _NSTextInsertionUndoableAttributeName, 
                       _NSTextLineTooLongException, _NSTextNoSelectionException, 
                       _NSTextPlaceholderAttributeName, _NSTextReadException, 
                       _NSTextReplacementAttributeName, _NSTextRulerOptionsUpdateNotification, 
                       _NSTextWriteException, _NSThemeSpace, _NSTintColorEffectKey, 
                       _NSTitleBinding, _NSTokenSize, _NSToolTipBinding, 
                       _NSToolTipHelpKey, _NSToolbarCustomizeToolbarItemIdentifier, 
                       _NSToolbarDidRemoveItemNotification, _NSToolbarDidReorderItemNotification, 
                       _NSToolbarFixedWidthSpaceItemIdentifier, _NSToolbarFlexibleSpaceItemIdentifier, 
                       _NSToolbarPrintItemIdentifier, _NSToolbarSeparatorItemIdentifier, 
                       _NSToolbarShowColorsItemIdentifier, _NSToolbarShowFontsItemIdentifier, 
                       _NSToolbarSpaceItemIdentifier, _NSToolbarToggleSidebarItemIdentifier, 
                       _NSToolbarWillAddItemNotification, _NSTouchDeviceAddedNotification, 
                       _NSTouchDeviceRemovedNotification, _NSTransparentBinding, 
                       _NSTypedFileContentsPboardType, _NSTypedFilenamesPboardType, 
                       _NSTypedStreamVersionException, _NSURLPboardType, 
                       _NSUnregisterServicesProvider, _NSUpdateDynamicServices, 
                       _NSUseSplitCursor, _NSUseWritingDirectionKeyBindings, 
                       _NSUserKeyEquivalents, _NSUsesScreenFontsDocumentAttribute, 
                       _NSVCardPboardType, _NSValidatesImmediatelyBindingOption, 
                       _NSValueBinding, _NSValueDictionaryControllerKey, 
                       _NSValuePathBinding, _NSValueTransformerBindingOption, 
                       _NSValueTransformerNameBindingOption, _NSValueURLBinding, 
                       _NSViewAnimationEffectKey, _NSViewAnimationEndFrameKey, 
                       _NSViewAnimationFadeInEffect, _NSViewAnimationFadeOutEffect, 
                       _NSViewAnimationStartFrameKey, _NSViewAnimationTargetKey, 
                       _NSViewBoundsDidChangeNotification, _NSViewCarbonControlViewPropertyTag, 
                       _NSViewDidChangeBackingScaleNotification, _NSViewDidUpdateTrackingAreasNotification, 
                       _NSViewFocusDidChangeNotification, _NSViewFrameDidChangeNotification, 
                       _NSViewGlobalFrameDidChangeNotification, _NSViewNoInstrinsicMetric, 
                       _NSViewNoIntrinsicMetric, _NSVisibleBinding, _NSVoiceAge, 
                       _NSVoiceDemoText, _NSVoiceGender, _NSVoiceGenderFemale, 
                       _NSVoiceGenderMale, _NSVoiceGenderNeuter, _NSVoiceIdentifier, 
                       _NSVoiceIndividuallySpokenCharacters, _NSVoiceLanguage, 
                       _NSVoiceLocaleIdentifier, _NSVoiceName, _NSVoiceSupportedCharacters, 
                       _NSWarningValueBinding, _NSWhite, _NSWidthBinding, 
                       _NSWindowDidBecomeKeyNotification, _NSWindowDidBecomeMainNotification, 
                       _NSWindowDidChangeBackingPropertiesNotification, 
                       _NSWindowDidChangeOcclusionStateNotification, _NSWindowDidChangeScreenNotification, 
                       _NSWindowDidChangeScreenProfileNotification, _NSWindowDidDeminiaturizeNotification, 
                       _NSWindowDidEndLiveResizeNotification, _NSWindowDidEndSheetNotification, 
                       _NSWindowDidEnterFullScreenNotification, _NSWindowDidEnterVersionBrowserNotification, 
                       _NSWindowDidExitFullScreenNotification, _NSWindowDidExitVersionBrowserNotification, 
                       _NSWindowDidExposeNotification, _NSWindowDidFailToEnterFullScreenNotification, 
                       _NSWindowDidFailToExitFullScreenNotification, _NSWindowDidMiniaturizeNotification, 
                       _NSWindowDidMoveNotification, _NSWindowDidOrderOffScreenAndFinishAnimatingNotification, 
                       _NSWindowDidOrderOffScreenNotification, _NSWindowDidOrderOnScreenAndFinishAnimatingNotification, 
                       _NSWindowDidOrderOnScreenNotification, _NSWindowDidResignKeyNotification, 
                       _NSWindowDidResignMainNotification, _NSWindowDidResizeNotification, 
                       _NSWindowDidUpdateNotification, _NSWindowList, _NSWindowListForContext, 
                       _NSWindowServerCommunicationException, _NSWindowWillBeginSheetNotification, 
                       _NSWindowWillCloseNotification, _NSWindowWillEnterFullScreenNotification, 
                       _NSWindowWillEnterVersionBrowserNotification, _NSWindowWillExitFullScreenNotification, 
                       _NSWindowWillExitVersionBrowserNotification, _NSWindowWillMiniaturizeNotification, 
                       _NSWindowWillMoveNotification, _NSWindowWillOrderOffScreenNotification, 
                       _NSWindowWillOrderOnScreenNotification, _NSWindowWillStartLiveResizeNotification, 
                       _NSWindowsMenuName, _NSWordTablesReadException, 
                       _NSWordTablesWriteException, _NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification, 
                       _NSWorkspaceActiveMenuBarDrawingStyleDidChangeNotification, 
                       _NSWorkspaceActiveSpaceDidChangeNotification, _NSWorkspaceApplicationKey, 
                       _NSWorkspaceCompressOperation, _NSWorkspaceCopyOperation, 
                       _NSWorkspaceDecompressOperation, _NSWorkspaceDecryptOperation, 
                       _NSWorkspaceDesktopImageAllowClippingKey, _NSWorkspaceDesktopImageFillColorKey, 
                       _NSWorkspaceDesktopImageScalingKey, _NSWorkspaceDestroyOperation, 
                       _NSWorkspaceDidActivateApplicationNotification, 
                       _NSWorkspaceDidChangeFileLabelsNotification, _NSWorkspaceDidDeactivateApplicationNotification, 
                       _NSWorkspaceDidHideApplicationNotification, _NSWorkspaceDidLaunchApplicationNotification, 
                       _NSWorkspaceDidMountNotification, _NSWorkspaceDidPerformFileOperationNotification, 
                       _NSWorkspaceDidRenameVolumeNotification, _NSWorkspaceDidTerminateApplicationNotification, 
                       _NSWorkspaceDidUnhideApplicationNotification, _NSWorkspaceDidUnmountNotification, 
                       _NSWorkspaceDidWakeNotification, _NSWorkspaceDuplicateOperation, 
                       _NSWorkspaceEncryptOperation, _NSWorkspaceLaunchConfigurationAppleEvent, 
                       _NSWorkspaceLaunchConfigurationArchitecture, _NSWorkspaceLaunchConfigurationArguments, 
                       _NSWorkspaceLaunchConfigurationEnvironment, _NSWorkspaceLinkOperation, 
                       _NSWorkspaceMoveOperation, _NSWorkspaceRecycleOperation, 
                       _NSWorkspaceScreensDidSleepNotification, _NSWorkspaceScreensDidWakeNotification, 
                       _NSWorkspaceSessionDidBecomeActiveNotification, 
                       _NSWorkspaceSessionDidResignActiveNotification, 
                       _NSWorkspaceVolumeLocalizedNameKey, _NSWorkspaceVolumeOldLocalizedNameKey, 
                       _NSWorkspaceVolumeOldURLKey, _NSWorkspaceVolumeURLKey, 
                       _NSWorkspaceWillLaunchApplicationNotification, _NSWorkspaceWillPowerOffNotification, 
                       _NSWorkspaceWillSleepNotification, _NSWorkspaceWillUnmountNotification, 
                       _NXWorkspaceName, _NXWorkspaceReplyName, __NSAccessibilityZoomWindowAction, 
                       __NSActivateSelf, __NSAddButtonRectToWindowWithActivation, 
                       __NSAddDragRectToWindow, __NSAddDragRectsToWindow, 
                       __NSAddMacBuckyBitGlyphsToAttributedString, __NSAddRectsToWindow, 
                       __NSAddSpecialCommandRectToWindow, __NSAdjustSelectionForCRLF, 
                       __NSAllKitModes, __NSAltFontNameBitForFace, __NSAppKitGlobalImageLock, 
                       __NSAppKitGlobalLock, __NSAppKitGlobalQTLock, __NSAppKitGlobalWinOrderingLock, 
                       __NSAppKitImgLock, __NSAppKitImgUnlock, __NSAppKitLock, 
                       __NSAppKitQTLock, __NSAppKitQTTryLock, __NSAppKitQTUnlock, 
                       __NSAppKitRetainLock, __NSAppKitUnlock, __NSAppendSimpleTextDataToAttributedString, 
                       __NSAppendToKillRing, __NSAppleMenuName, __NSAppleVersionDebug, 
                       __NSApplicationDiskUnmountApprovalCallback, __NSApplicationIsInterfaceBuilder, 
                       __NSApplicationIsInterfaceBuilderInTestMode, __NSArchivedNSColorAsNXColor, 
                       __NSArrayFromValue, __NSAttributedStringFromValue, 
                       __NSAttributedStringWithGlyphImage, __NSBindingCreationDelegate, 
                       __NSBindingToMaskMapTable, __NSBoolFromValue, __NSBrowserDidUserResizeColumns, 
                       __NSBrowserWillUserResizeColumns, __NSBuildSpellServerName, 
                       __NSBuildSpellServerPortName, __NSButtonMaskFromStyleMask, 
                       __NSBypassUncommittedCATransaction_THIS_MEANS_THERE_IS_AN_APP_BUG, 
                       __NSCGSToWindowDepth, __NSCachedExposedBindingsPerClass, 
                       __NSCalculateContainerOrigin, __NSCenteredRectForImage, 
                       __NSClearButtonRectsInWindow, __NSClearDragRectsInWindow, 
                       __NSClearFocusRingStyle, __NSClearMarkedRange, __NSClearTrackingRect, 
                       __NSClearTrackingRects, __NSCloseThemeFile, __NSCocoaViewCreate, 
                       __NSCocoaViewGetView, __NSCocoaViewRegisterClass, 
                       __NSCocoaViewSetView, __NSColorDrawSwatchInRectUsingLightBadging, 
                       __NSColorFromDefault, __NSColorFromValue, __NSColorSpaceNameFromNum, 
                       __NSColorSpaceNumFromName, __NSCompareBindingCategories, 
                       __NSCompareBindingConnectors, __NSCompareBindingInformation, 
                       __NSCompatibleListAlternateSelectedControlColor, 
                       __NSCompositeButtonImage, __NSCompositeNotScaled, 
                       __NSCompositePushButtonImage, __NSComputeFirstKeyViewVisuallyInDirection, 
                       __NSConcealedBindingsPerClass, __NSContentRectForFrameRect, 
                       __NSConvertBitmapRow, __NSCopyServiceActions, __NSCoreServicesPath, 
                       __NSCreateATSUStyleFromAttributes, __NSCreateAttributesFromATSUStyle, 
                       __NSCreateIconFamilyFromNSImage, __NSCreateImageRef, 
                       __NSCreateImageRef2, __NSCreateKeyBindingState, 
                       __NSCreatePatternForMetal, __NSCreatePatternFromContext, 
                       __NSCreatePatternFromPDF, __NSCreateShapeForRoundedWindow, 
                       __NSCreateWindow, __NSCurrentMouseLocationInWindow, 
                       __NSDataFromValue, __NSDateFromValue, __NSDeallocateKeyBindingState, 
                       __NSDebugLock, __NSDeepCopyPlist, __NSDefaultAndModalPanelModes, 
                       __NSDefaultControlTint, __NSDefaultTextZone, __NSDefaultTopLevelErrorHandler, 
                       __NSDesc, __NSDictionaryFromValue, __NSDictionaryWithAdditionalKeyAndObject, 
                       __NSDisableMouseMovedEventsForWindow, __NSDiscardCursorRect, 
                       __NSDoOneTimeDockRegistration, __NSDoUserAlignActionWithAlignment, 
                       __NSDoUserDeleteForCharRange, __NSDockAlive, __NSDocumentSerializationInfo, 
                       __NSDoubleFromValue, __NSDragWindowRelativeToMouseDown, 
                       __NSDraw3DBorderInRect, __NSDrawAllViews, __NSDrawCarbonThemeBezel, 
                       __NSDrawCarbonThemeListBox, __NSDrawColor3DBorderInRect, 
                       __NSDrawDisabledTextFieldBezel, __NSDrawFourPartImage, 
                       __NSDrawMacintoshStyleBezel, __NSDrawNinePartImage, 
                       __NSDrawThreePartImage, __NSDrawThreePartImageWithOperation, 
                       __NSDrawThreeSectionImage, __NSDrawThreeSectionImageWithOperation, 
                       __NSDrawVertStretchedImage, __NSDrawWindowBackgroundRegion, 
                       __NSDrawWindowsArrowButton, __NSEPSPassword, __NSEditTextCell, 
                       __NSEffectiveScrollerStyle, __NSElasticDeltaForReboundDelta, 
                       __NSElasticDeltaForTimeDelta, __NSElasticInitialPositionForZeroDelta, 
                       __NSEmptyAndImmutableArray, __NSEmptyAndImmutableDictionary, 
                       __NSEmptyAndImmutableIndexSet, __NSEmptyAttributedString, 
                       __NSEnableMouseMovedEventsForWindow, __NSExposeExtraBindings, 
                       __NSExposedBindingsPerClass, __NSExposedBindingsValueClassesPerClass, 
                       __NSFBEErrorString, __NSFBEEventString, __NSFBEPrintDebugNotice, 
                       __NSFamilyNameFromFontName, __NSFamilyNameFromFontObj, 
                       __NSFileDirTitleSeparator, __NSFilenameFromTitle, 
                       __NSFillRegionUsingOperation, __NSFindBestMatchInFontFamily, 
                       __NSFinishMinimizeToDock, __NSFinishRestoreFromDock, 
                       __NSFirstPathForDirectoriesInDomains, __NSFloatFromValue, 
                       __NSFlushCGSContext, __NSFlushCachedModifierGlyphs, 
                       __NSFontFromValue, __NSFontLibraryPaths, __NSFontMenuName, 
                       __NSFrameRectForContentRect, __NSGetAlignedRowBytes, 
                       __NSGetAppKitMenu, __NSGetCarbonMenu, __NSGetCarbonMenu2, 
                       __NSGetCurrentEventModifierFlags, __NSGetMenuItemForCommandKeyEvent, 
                       __NSGetPathToDictionary, __NSGetRoundedWindowResizeWeighting, 
                       __NSGetThemeButtonColorImage, __NSGetThemeButtonEdgeColorPattern, 
                       __NSGetThemeButtonEdgePattern, __NSGetThemeButtonImage, 
                       __NSGetThemeButtonPartColorImage, __NSGetThemeButtonPartImage, 
                       __NSGetThemeEdgePattern, __NSGetThemeFrameRects, 
                       __NSGetThemeImage, __NSGetThemePartColorImages, 
                       __NSGetThemePartColorPattern, __NSGetThemePartImages, 
                       __NSGetThemePartPattern, __NSGetThemePartTabViewColorImage, 
                       __NSGetThemePartTabViewPattern, __NSGetThemePattern, 
                       __NSGetThemePatternImage, __NSGetThemeSliderColorImage, 
                       __NSGetThemeSliderImage, __NSGetThemeThumbColorImages, 
                       __NSGetThemeThumbImages, __NSGetThemeTrackColorImages, 
                       __NSGetThemeTrackColorPattern, __NSGetThemeTrackImages, 
                       __NSGetThemeTrackPattern, __NSGetThemeWidgetColorImage, 
                       __NSGetThemeWidgetImage, __NSGetWindowResizeWeighting, 
                       __NSGlobalDefaultWindowDepthLimit, __NSHIViewDrawNSImage, 
                       __NSHelpMenuName, __NSHooke1Transform, __NSImageFree, 
                       __NSImageFromValue, __NSImageFromWindow, __NSImageGetSize, 
                       __NSImageMalloc, __NSImageMallocSize, __NSImageRealloc, 
                       __NSIndexPathForItem, __NSInitializeKillRing, __NSInsertCursorRect, 
                       __NSInstallCarbonAppApplicationLevelEventHandlers, 
                       __NSInstallCocoaAppApplicationLevelEventHandlers, 
                       __NSIntFromValue, __NSInvalidateWindowShadow, __NSIsCarbonApp, 
                       __NSIsDrawingMultiThreaded, __NSIsInsecureBundle, 
                       __NSIsKeyBindingStateProcessingArguments, __NSIsKeyBindingStateQuoted, 
                       __NSKeyBindingStateRepeatCount, __NSKeyEquivalentModifierMaskMatchesModifierFlags, 
                       __NSKeyboardUIHandleSymbolicHotKey, __NSKeyboardUIHotKeysCleanup, 
                       __NSKeyboardUIHotKeysInitialize, __NSKeyboardUISelectAnyValidResponder, 
                       __NSKitBundle, __NSLibraryPathsForType, __NSLoadMacSimpleTextFormat, 
                       __NSLoadMacSimpleTextFormatAux, __NSLoadMacSimpleTextFormatAuxError, 
                       __NSLoadMacSimpleTextFormatWithOptions, __NSLogCTM, 
                       __NSLogLockInformation, __NSLogUnlockInformation, 
                       __NSLookupPBServer, __NSMainMenuName, __NSMakeAttributedStringFromCarbonATSUIData, 
                       __NSMakeAttributedStringFromCarbonTEData, __NSMakeCarbonATSUIDataFromAttributedString, 
                       __NSMakeCarbonTEDataFromAttributedString, __NSMaskForBinding, 
                       __NSMeasureViewDrawing, __NSMenuToCarbonIndex, __NSMeshBitmapRow, 
                       __NSMiniaturizeOnDoubleClick, __NSMoveWindow, __NSNameFromKeyEquivalentString, 
                       __NSNavColumnAttributedTitleForProperty, __NSNavDrawLabelColorIndex, 
                       __NSNavDrawLabelColorIndexRects, __NSNavDrawSingleLineLabelColor, 
                       __NSNavFinderColumnViewOptionShowThumbnails, __NSNavFinderStandardViewSettingsForColumnView, 
                       __NSNavFinderStandardViewSettingsForListView, __NSNavResizeViewHeightLeavingTopFixed, 
                       __NSNavResizeWindowLeavingTopCenterFixed, __NSNavSetShowAndStartAutoresizingView, 
                       __NSNavSoftlinkLoadQuartz, __NSNavTileAsTopView, 
                       __NSNavTileViewAbove, __NSNavTileViewBelow, __NSNewCatalogColor, 
                       __NSNewFieldEditor, __NSNewKillRingSequence, __NSNullMarker, 
                       __NSNumberFromValue, __NSNumberWithInt, __NSObjectForItem, 
                       __NSObjectFromValue, __NSObservedObjectFromObject, 
                       __NSOpenAndSavePanelServiceRequestsOrderWindow, 
                       __NSOpenAndSavePanelServiceRequestsOrderWindowForTimeMachineModeInvocation, 
                       __NSOpenAndSavePanelServiceRequestsResizeKeepingPanelOnScreenInvocation, 
                       __NSOpenAndSavePanelServiceRequestsSendAccessoryViewInvocation, 
                       __NSOpenAndSavePanelServiceRequestsSetFrameOfRemoteWindowForTimeMachineMode, 
                       __NSOpenAndSavePanelsServiceBridgeKeMostRecentCompletion, 
                       __NSOpenAndSavePanelsServiceBridgeKeMostRecentCompletionKeyIndex, 
                       __NSOpenAndSavePanelsServiceBridgeKeMostRecentCompletionKeyResult, 
                       __NSOpenAndSavePanelsServiceBridgeKeyBOOL, __NSOpenAndSavePanelsServiceBridgeKeyNSError, 
                       __NSOpenAndSavePanelsServiceBridgeKeyQueryFilenameOK, 
                       __NSOpenAndSavePanelsServiceBridgeKeyRemoteDelegateInvocation, 
                       __NSOpenAndSavePanelsServiceBridgeKeyRemoteIBActionInvocation, 
                       __NSOpenAndSavePanelsServiceBridgeKeyRemoteIBActionNewDocument, 
                       __NSOpenAndSavePanelsServiceBridgeKeyRemoteMethodInvocation, 
                       __NSOpenAndSavePanelsServiceBridgeKeySendDelegateDirectoryChanged, 
                       __NSOpenAndSavePanelsServiceBridgeKeySendDelegateDirectoryURLChanged, 
                       __NSOpenAndSavePanelsServiceBridgeKeySendDelegatePanelShouldEnableURL, 
                       __NSOpenAndSavePanelsServiceBridgeKeySendDelegatePanelUserEnteredFilename, 
                       __NSOpenAndSavePanelsServiceBridgeKeySendDelegatePanelValidateURLsReturningError, 
                       __NSOpenAndSavePanelsServiceBridgeKeySendDelegatePanelWillExpand, 
                       __NSOpenAndSavePanelsServiceBridgeKeySendDelegateSelectionDidChange, 
                       __NSOpenAndSavePanelsServiceBridgeKeyUniqueID, __NSOpenThemeFile, 
                       __NSOperatorClearedKeyPath, __NSOrderPanelIfActive, 
                       __NSOrderWindow, __NSPBOXStatusErrorDomain, __NSParseWithFormat, 
                       __NSPathForResource, __NSPathForResourceFileFromCurrentNib, 
                       __NSPathForSystemFramework, __NSPersistentUICreateCGImageFromFile, 
                       __NSPersistentUICrossEncrypt, __NSPersistentUIMetadataWasSignedWithKey, 
                       __NSPersistentUIReadMetadataFromOpenFile, __NSPersistentUIReadMetadataFromURL, 
                       __NSPersistentUIShmemKey, __NSPopUpCarbonMenu, __NSPopUpCarbonMenu1, 
                       __NSPopUpCarbonMenu2, __NSPopUpCarbonMenu3, __NSPopoverOverrideSemitransientPopoverClosing, 
                       __NSPrependToKillRing, __NSPrintProtected, __NSPrintersPath, 
                       __NSPromiseContentsPboardType, __NSProtectVM, __NSRandomUniqueFileName, 
                       __NSReadThemeImageFromRsrc, __NSReadThemeImageFromTIFF, 
                       __NSReadThemeImageFromplutEntry, __NSReadThemePatternFromRsrc, 
                       __NSReboundDeltaForElasticDelta, __NSRecentDocumentsMenuName, 
                       __NSRecommendedScrollerStyle, __NSRecoverFromDockDeath, 
                       __NSRectFromValue, __NSRegisterMaskForBinding, __NSRegisterPlugins, 
                       __NSReleasePattern, __NSRelocateCursorRects, __NSRenderImageFromWindow, 
                       __NSResetBufferedStringInState, __NSResetKeyBindingState, 
                       __NSResetKillRingOperationFlag, __NSResetOtherWindows, 
                       __NSResetServiceActions, __NSRestoreFromDock, __NSRevertDocumentMenuName, 
                       __NSSafeOrderFront, __NSSafeOrderFrontDuringOpenFile, 
                       __NSSafeOrderMainBelowKey, __NSSavePanelCleanupNameFormatter, 
                       __NSSavePanelCleanupNavFBEQueryNode, __NSSavePanelCleanupTaskManager, 
                       __NSSavePanelInitOptionKeyPID, __NSSavePanelInitOptionKeyService, 
                       __NSSavePanelIsAllowedFileNameExtension, __NSSavePanelPAPerfLoggingOn, 
                       __NSSavePanelPAPerfOperation, __NSSavePanelPAPerfOperationMarkInterval, 
                       __NSSavePanelPAPerfOperationMarkName, __NSSavePanelResizeWindowAnimated, 
                       __NSSaveServiceActions, __NSScrollAnimationMaxDuration, 
                       __NSScrollAnimationSpeed, __NSScrollAnimationTargetFPS, 
                       __NSServicesMenuName, __NSSetAvoidsActivation, __NSSetCursorForWindowAndLocation, 
                       __NSSetCursorRect, __NSSetDefaultControlTint, __NSSetDottedLinePattern, 
                       __NSSetDraggingSource, __NSSetEventMask, __NSSetFocusRingStyle, 
                       __NSSetFocusRingStyleClip, __NSSetFromValue, __NSSetGlobalDefault, 
                       __NSSetHidesOnDeactivate, __NSSetIgnoresMouseEvents, 
                       __NSSetKeyBindingStateQuoted, __NSSetKillRingToYankedState, 
                       __NSSetLineWidth, __NSSetMainMenu, __NSSetMiniWindowImage, 
                       __NSSetModalWindowClassLevel, __NSSetMouseFocusWindow, 
                       __NSSetOpaqueForEvents, __NSSetOtherWindows, __NSSetPattern, 
                       __NSSetPreventsActivation, __NSSetSystemRGB, __NSSetToolbarLabelShadowTextAttributes, 
                       __NSSetTrackingRect, __NSSetUseCoreUI, __NSSetViewsPostSubviewHierarchyChangedNotifications, 
                       __NSSetWindowAlpha, __NSSetWindowAutofill, __NSSetWindowAutofillColor, 
                       __NSSetWindowOneShot, __NSSetWindowOpacity, __NSSetWindowShadow, 
                       __NSSetWindowTag, __NSSetWindowTitle, __NSShakeForAuthenticationFailureAmplitude, 
                       __NSShakeForAuthenticationFailureDuration, __NSShapePlainWindow, 
                       __NSShapeRoundedWindow, __NSShapeRoundedWindowWithWeighting, 
                       __NSShapeWindowForDropShadow, __NSShapeWindowForThemeTearOffMenu, 
                       __NSSharedKitBitmapInfo, __NSShortAppName, __NSShouldOverrideBoolAppConfig, 
                       __NSShouldOverrideCGFloatAppConfig, __NSShouldOverrideNSIntegerAppConfig, 
                       __NSShowKeyboardUILoop, __NSSingleWindowModeChanged, 
                       __NSSpokenNotifications, __NSStringFromValue, __NSStringType, 
                       __NSStringsFileFromCurrentNib, __NSStyleMaskFromTypeAndButtonMask, 
                       __NSSubclassOverridesSelector, __NSSubviewHierarchyDidChangeNotification, 
                       __NSSurfaceDidChangeScreenNotification, __NSSurfaceDidComeBackNotification, 
                       __NSSurfaceWillGoAwayNotification, __NSSystemLibraryPath, 
                       __NSTabViewFloatingCell, __NSTableViewDebugDynamicToolTipsShowRect, 
                       __NSTableViewStartRowDragBehavior, __NSTermWindow, 
                       __NSTextCellBoundingRect, __NSTextCellHitTest, __NSTextCellSize, 
                       __NSTextColorForObjectValuesSpecified, __NSTextContainerForTextCell, 
                       __NSTileImage, __NSTileImageWithOperation, __NSToolbarDisplayModeChangedDisplayModeKey, 
                       __NSToolbarDisplayModeChangedSizeModeKey, __NSToolbarItemDragType, 
                       __NSToolbarItemIdentifierPboardType, __NSToolbarMetricsGetDefault, 
                       __NSTraitsForFace, __NSTypeFromStyleMask, __NSURLFromValue, 
                       __NSUnMeshBitmapRow, __NSUniqueMenuItemNamesForFullPaths, 
                       __NSUnitTestOVRowEntrySize, __NSUseCoreUI, __NSUseLeopardWindowValues, 
                       __NSUsersPreferredScrollerStyle, __NSVBLogCaughtException, 
                       __NSVBLogFunc, __NSValidUser, __NSValueOfClassWithSpecialSpecificErrorMessage, 
                       __NSValuesAreEqual, __NSWarnDeprecatedHiDPIMethod, 
                       __NSWarnDeprecatedTableMethod, __NSWeightForFace, 
                       __NSWindowAutofill, __NSWindowDidBecomeVisible, 
                       __NSWindowDidChangeContentsHostedInLayerSurfaceNotification, 
                       __NSWindowDidChangeWindowNumber, __NSWindowToCGSDepth, 
                       __NSWindowWillBecomeVisible, __NSWindowWillChangeWindowNumber, 
                       __NSWindowsMenuName, __NSYankFromKillRing, __NSYankPreviousFromKillRing, 
                       __NSsetowner, __NXDocSvr, __NXDrawImage, __NXDrawSwatchAt, 
                       __NXDrawTextCell, __NXKitString, __NXLastDocModalSession, 
                       __NXLastModalSession, __NXPreventWindowOrdering, 
                       __NXScreenForRect, __NXScreenMaxYForRect, __NXShowKeyAndMain, 
                       __NXSmartPaste, ___NSADBKeyCodeMapping, ___NSAppKitGetThreadSpecificData, 
                       ___NSDragManagerLogLevel, ___NSDragManagerSetLogLevel, 
                       ___NSHasDisplayScaleFactor, ___NSHasDisplayScaleFactorTruthForMagnifyMode, 
                       ___NSSetDebugViewDrawing, ___NSSetDrawAllViews, 
                       ___NSSetMeasureViewDrawing, ___NSTreeControllerNilForZeroLengthString, 
                       __compareTabViewItemWidth, __enableNSPreferences, 
                       __exposeBindingLock, __lookupBinderClassesLock, 
                       __nsBeginNSPSupport, __pluginRegistryCreationLock, 
                       __pluginRegistryLock, __sharedPluginRegistryInfo, 
                       __sharedStateMarkerInfo, __sharedUserDefaultsControllerLock, 
                       __stateMarkerPlaceholderLock, _caps, _kBarThickness, 
                       _kDefaultLineAmount, _kDefaultMaxMagnification, 
                       _kDefaultMinMagnification, _kDefaultPageAmount, 
                       _kFocusThickness, _kKnobSizeAcrossBar, _kKnobSizeAlongBar, 
                       _kKnobSizeAlongBarWithTickMarks, _kMaximumNumberOfParts, 
                       _kScrollWheelMultiplier, _kThemeBarTrackThickeness, 
                       _kThemeCircularSliderHeight, _kThemeCircularSliderKnobRadius, 
                       _kThemeCircularSliderKnobSize, _kThemeCircularSliderWidth, 
                       _kThemeCircularTickMarkGap, _kThemeCircularTickMarkSize, 
                       _kThemeHorizKnobAboveHeight, _kThemeHorizKnobBelowHeight, 
                       _kThemeHorizKnobWidth, _kThemeHorizontalTickMarkGap, 
                       _kThemeKnobHorizDownPointLength, _kThemeKnobPointLength, 
                       _kThemeMiniBarTrackThickeness, _kThemeMiniHorizKnobAboveHeight, 
                       _kThemeMiniHorizKnobBelowHeight, _kThemeMiniHorizKnobWidth, 
                       _kThemeMiniHorizontalTickMarkGap, _kThemeMiniKnobHorizDownPointLength, 
                       _kThemeMiniKnobPointLength, _kThemeMiniRoundKnobHeight, 
                       _kThemeMiniRoundKnobWidth, _kThemeMiniTickMarkLength, 
                       _kThemeMiniVertKnobHeight, _kThemeMiniVertKnobLeftWidth, 
                       _kThemeMiniVertKnobRightWidth, _kThemeMiniVerticalTickMarkGap, 
                       _kThemeRoundKnobHeight, _kThemeRoundKnobWidth, _kThemeSmallBarTrackThickeness, 
                       _kThemeSmallCircularSliderHeight, _kThemeSmallCircularSliderKnobRadius, 
                       _kThemeSmallCircularSliderKnobSize, _kThemeSmallCircularSliderWidth, 
                       _kThemeSmallHorizKnobAboveHeight, _kThemeSmallHorizKnobBelowHeight, 
                       _kThemeSmallHorizKnobWidth, _kThemeSmallHorizontalTickMarkGap, 
                       _kThemeSmallKnobHorizDownPointLength, _kThemeSmallKnobPointLength, 
                       _kThemeSmallRoundKnobHeight, _kThemeSmallRoundKnobWidth, 
                       _kThemeSmallTickMarkLength, _kThemeSmallVertKnobHeight, 
                       _kThemeSmallVertKnobLeftWidth, _kThemeSmallVertKnobRightWidth, 
                       _kThemeSmallVerticalTickMarkGap, _kThemeTickMarkLength, 
                       _kThemeTickMarkThickness, _kThemeVertKnobHeight, 
                       _kThemeVertKnobLeftWidth, _kThemeVertKnobRightWidth, 
                       _kThemeVerticalTickMarkGap, _kTickMarkGap, _kTickMarkLength, 
                       _kTickMarkThickness, _titleAttributes ]
    objc-classes:    [ _HICocoaWindowAdapter, _HICocoaWindowContentView, 
                       _HINSMenuItemProxy, _NSATSUStyleObject, _NSAcceleratorGestureRecognizer, 
                       _NSAccessibilityAXUIElementWrapper, _NSAccessibilityElement, 
                       _NSAccessibilityImageMockUIElement, _NSAccessibilityIndexedMockUIElement, 
                       _NSAccessibilityMenuExtrasMenuBar, _NSAccessibilityMockStatusBarItem, 
                       _NSAccessibilityMockUIElement, _NSAccessibilityNotifier, 
                       _NSAccessibilityPathComponent, _NSAccessibilityProxy, 
                       _NSAccessibilityRemoteUIElement, _NSAccessibilityReparentingCellProxy, 
                       _NSAccessibilityReparentingProxy, _NSAccessibilityRulerMarker, 
                       _NSAccessibilityScrollerPart, _NSAccessibilitySectionSearchElement, 
                       _NSAccessibilitySegment, _NSAccessibilitySliderValueIndicator, 
                       _NSAccessibilityStepperArrowButton, _NSAccessibilityTableHeaderCellProxy, 
                       _NSAccessibilityTextLink, _NSAccessibilityWindowGrowBox, 
                       _NSActionBinder, _NSActionCell, _NSAlert, _NSAlignmentFeedbackFilter, 
                       _NSAnimation, _NSAnimationContext, _NSAnimationHelper, 
                       _NSAnimationInfo, _NSAnimationManager, _NSAppearance, 
                       _NSApplication, _NSApplicationExtensionItem, _NSApplicationExtensionSession, 
                       _NSArrayController, _NSArrayDetailBinder, _NSAttachmentTextStorage, 
                       _NSAutounbinder, _NSBezierPath, _NSBinder, _NSBitmapGraphicsContext, 
                       _NSBitmapImageRep, _NSBox, _NSBoxAuxiliary, _NSBrowser, 
                       _NSBrowserBinder, _NSBrowserCell, _NSBrowserColumnViewController, 
                       _NSBrowserTableView, _NSButton, _NSButtonCell, _NSButtonImageSource, 
                       _NSCGImageRep, _NSCGImageSnapshotRep, _NSCGSContext, 
                       _NSCIImageRep, _NSCMYKSliders, _NSCachedColorSpaceColor, 
                       _NSCachedDeviceRGBColor, _NSCachedDeviceWhiteColor, 
                       _NSCachedImageRep, _NSCachedRGBColor, _NSCachedWhiteColor, 
                       _NSCalibratedRGBColor, _NSCalibratedWhiteColor, 
                       _NSCallbackDictionary, _NSCarbonMenuImpl, _NSCarbonMenuWindow, 
                       _NSCarbonWindow, _NSCarbonWindowContentView, _NSCarbonWindowFrame, 
                       _NSCatalogColor, _NSCell, _NSCellAuxiliary, _NSCellUndoManager, 
                       _NSClassSwapper, _NSClickGestureRecognizer, _NSClipView, 
                       _NSCloudSharingPanel, _NSCollectionView, _NSCollectionViewBinder, 
                       _NSCollectionViewGridLayout, _NSCollectionViewItem, 
                       _NSColor, _NSColorList, _NSColorListAuxiliary, _NSColorPanel, 
                       _NSColorPanelColorWell, _NSColorPanelResizeDimple, 
                       _NSColorPanelTextController, _NSColorPicker, _NSColorPickerColorSpacePopUp, 
                       _NSColorPickerPageableNameList, _NSColorPickerPageableNameListScrollView, 
                       _NSColorPickerSliders, _NSColorPickerUser, _NSColorPickerUserView, 
                       _NSColorPickerWheel, _NSColorPickerWheelView, _NSColorProfile, 
                       _NSColorScaleSlider, _NSColorScaleSliderCell, _NSColorSpace, 
                       _NSColorSpaceColor, _NSColorSpaceSliders, _NSColorSwatch, 
                       _NSColorSwatchCell, _NSColorWell, _NSComboBox, _NSComboBoxButtonCell, 
                       _NSComboBoxCell, _NSComboBoxWindow, _NSComboTableView, 
                       _NSCompositeImageRep, _NSConcretePrintOperation, 
                       _NSControl, _NSControlAuxiliary, _NSController, 
                       _NSControllerConfigurationBinder, _NSCoreDragManager, 
                       _NSCoreUIImageRep, _NSCursor, _NSCustomImageRep, 
                       _NSCustomObject, _NSCustomReleaseData, _NSCustomResource, 
                       _NSCustomView, _NSDataAsset, _NSDataDetectionIndicatorView, 
                       _NSDatePicker, _NSDatePickerCell, _NSDeviceCMYKColor, 
                       _NSDeviceRGBColor, _NSDeviceWhiteColor, _NSDictionaryController, 
                       _NSDictionaryControllerKeyValuePair, _NSDictionaryDetailBinder, 
                       _NSDisclosureButtonCell, _NSDisplayFontBinder, _NSDisplayPatternBinder, 
                       _NSDisplayPatternTitleBinder, _NSDockFrameView, 
                       _NSDockMiniContentView, _NSDockMiniViewController, 
                       _NSDockMiniViewWindow, _NSDockTile, _NSDocument, 
                       _NSDocumentController, _NSDocumentDragButton, _NSDocumentErrorRecoveryAttempter, 
                       _NSDocumentTextAttachmentScrollView, _NSDocumentTypeDescription, 
                       _NSDoubleClickActionBinder, _NSDownloadController, 
                       _NSDragDestination, _NSDragEventTracker, _NSDraggingImageComponent, 
                       _NSDraggingItem, _NSDraggingSession, _NSDrawer, 
                       _NSDrawerBinder, _NSDrawerFrame, _NSDrawerWindow, 
                       _NSDynamicSystemColor, _NSEPSImageRep, _NSEagerTrackingCell, 
                       _NSEditableBinder, _NSEditorBinder, _NSEvent, _NSEventAuxiliary, 
                       _NSEventTracker, _NSExceptionAlertController, _NSExceptionHandlingRecursiveLock, 
                       _NSExtraMICData, _NSExtraMIData, _NSFileDragSource, 
                       _NSFileLocationComponent, _NSFileLocator, _NSFilePromiseDragSource, 
                       _NSFileSpecifier, _NSFilterServicesPasteboard, _NSFindIndicator, 
                       _NSFindPanel, _NSFindPattern, _NSFlippableView, 
                       _NSFloatRange, _NSFocusStack, _NSFocusState, _NSFontEffectsBox, 
                       _NSFontManager, _NSFontOptionsColorWell, _NSFontOptionsPreviewBox, 
                       _NSFontPanel, _NSFontPanelTableView, _NSForceClickMonitor, 
                       _NSForm, _NSFormCell, _NSFrameView, _NSGestureRecognizer, 
                       _NSGradient, _NSGradientColor, _NSGradientPatternColor, 
                       _NSGraphicCell, _NSGraphicsContext, _NSGrayFrame, 
                       _NSGreySliders, _NSHSBSliders, _NSHapticFeedbackManager, 
                       _NSHelpAttachment, _NSHelpManager, _NSHyphenator, 
                       _NSIBHelpConnector, _NSIBObjectData, _NSIBObjectDataAuxilary, 
                       _NSIBUserDefinedRuntimeAttributesConnector, _NSIconRefBitmapImageRep, 
                       _NSIconRefImageRep, _NSIconView, _NSIconViewCell, 
                       _NSImage, _NSImageCacheView, _NSImageCell, _NSImageIconRefRepProvider, 
                       _NSImageKitViewTextAttachmentCell, _NSImageKitViewTextAttachmentCellHelper, 
                       _NSImageMultiURLReferencingRepProvider, _NSImageRep, 
                       _NSImageTextFieldCell, _NSImageURLReferencingRepProvider, 
                       _NSImageView, _NSImageViewTextAttachmentCell, _NSImmediateActionGestureRecognizer, 
                       _NSInputAlignmentController, _NSInputAlignmentFilter, 
                       _NSInputAlignmentGuide, _NSInputClientWrapper, _NSInputContext, 
                       _NSInputFeedbackManager, _NSInputManager, _NSInputServer, 
                       _NSInspectorBar, _NSInspectorBarItem, _NSKeyBindingAtom, 
                       _NSKeyBindingManager, _NSKeyboardShortcut, _NSKitPanelController, 
                       _NSLSNotificationHelper, _NSLSNotificationHelperCountedSet, 
                       _NSLSNotificationHelperWeakArray, _NSLabelView, 
                       _NSLabelViewCell, _NSLayoutGuide, _NSLazyBrowserCell, 
                       _NSLazyBrowserList, _NSLevelIndicator, _NSLevelIndicatorCell, 
                       _NSLineHeightFormatter, _NSLocalInputServer, _NSLongClickGestureRecognizer, 
                       _NSMagnificationGestureRecognizer, _NSMatrix, _NSMediaLibraryBrowserController, 
                       _NSMenu, _NSMenuCustomCarbonEventHandler, _NSMenuItem, 
                       _NSMenuItemCell, _NSMenuItemHighlightColor, _NSMenuItemViewer, 
                       _NSMenuKEUniquer, _NSMenuTemplate, _NSMetalPatternColor, 
                       _NSMouseTracker, _NSMoveHelper, _NSMovePanel, _NSMovie, 
                       _NSMovieViewTextAttachmentCell, _NSMultiplePagePDFImageView, 
                       _NSMultiplePagePDFImageViewTextAttachmentCell, _NSMultipleSelectionBinder, 
                       _NSNavAdvancedSearchController, _NSNavBannerButtonCell, 
                       _NSNavBannerView, _NSNavBox, _NSNavBrowser, _NSNavBrowserCell, 
                       _NSNavBrowserDelegate, _NSNavBrowserTableView, _NSNavButton, 
                       _NSNavCell, _NSNavDataSource, _NSNavDisplayNameFilePropertySortDescriptor, 
                       _NSNavExpansionButtonCell, _NSNavFBENetworkNode, 
                       _NSNavFBENode, _NSNavFBENodePreviewHelper, _NSNavFBENodeTask, 
                       _NSNavFBEQueryChildNode, _NSNavFBEQueryNode, _NSNavFBETopLevelNode, 
                       _NSNavFileListDelegate, _NSNavFilePropertySortDescriptor, 
                       _NSNavFileSizeFormatter, _NSNavFilepathInputController, 
                       _NSNavFinderViewFileBrowser, _NSNavFlippedView, 
                       _NSNavHistoryState, _NSNavIconView, _NSNavIconViewCell, 
                       _NSNavIconViewDelegate, _NSNavLayoutView, _NSNavMatrix, 
                       _NSNavMediaBrowserDelegate, _NSNavMediaNode, _NSNavNameFieldFormatter, 
                       _NSNavNaughtDelegate, _NSNavNewFolderController, 
                       _NSNavNode, _NSNavNodePopUpButton, _NSNavNodePreviewController, 
                       _NSNavNodePreviewHelper, _NSNavNodeSharedServerController, 
                       _NSNavNodeTask, _NSNavODSAskToUseTask, _NSNavOutlineCell, 
                       _NSNavOutlineDateCell, _NSNavOutlineDelegate, _NSNavOutlineHeaderCell, 
                       _NSNavOutlineView, _NSNavPreviewController, _NSNavProgressErrorViewController, 
                       _NSNavProgressStatusViewController, _NSNavProgressWindow, 
                       _NSNavProgressWindowController, _NSNavRuleEditor, 
                       _NSNavScopeButton, _NSNavScopeButtonCell, _NSNavScopeView, 
                       _NSNavSegmentSwitchControl, _NSNavSegmentedCell, 
                       _NSNavSharedServerController, _NSNavSidebarController, 
                       _NSNavSimpleButtonCell, _NSNavSizePropertySortDescriptor, 
                       _NSNavSortingContext, _NSNavSplitView, _NSNavSplitViewController, 
                       _NSNavView, _NSNavViewController, _NSNavVirtualNode, 
                       _NSNextStepFrame, _NSNib, _NSNibAXAttributeConnector, 
                       _NSNibAXRelationshipConnector, _NSNibAuxiliaryActionConnector, 
                       _NSNibBindingConnector, _NSNibConnector, _NSNibControlConnector, 
                       _NSNibExternalObjectPlaceholder, _NSNibOutletCollectionConnector, 
                       _NSNibOutletConnector, _NSObjectController, _NSObjectDetailBinder, 
                       _NSObjectParameterBinder, _NSObsoleteBitmap, _NSOneLevelViewBuffer, 
                       _NSOpenGLContext, _NSOpenGLLayer, _NSOpenGLPixelBuffer, 
                       _NSOpenGLPixelFormat, _NSOpenGLView, _NSOpenPanel, 
                       _NSOutlineColumnMockGroup, _NSOutlineMockDisclosureTriangle, 
                       _NSOutlineRow, _NSOutlineView, _NSOutlineViewBinder, 
                       _NSPDFImageRep, _NSPDFInfo, _NSPDFPanel, _NSPDFPanelAccessoryViewController, 
                       _NSPICTImageRep, _NSPPDParse, _NSPSMatrix, _NSPageController, 
                       _NSPageLayout, _NSPageableTableView, _NSPanGestureRecognizer, 
                       _NSPanel, _NSPanelController, _NSPasteboard, _NSPasteboardFilter, 
                       _NSPasteboardItem, _NSPathCell, _NSPathComponentCell, 
                       _NSPathControl, _NSPathControlItem, _NSPatternColor, 
                       _NSPersistentDocument, _NSPersistentUICrashHandler, 
                       _NSPersistentUIEncodedReference, _NSPersistentUIManager, 
                       _NSPersistentUIRestorer, _NSPersistentUISecureURLHerder, 
                       _NSPersistentUIWindowSnapshotter, _NSPoofView, _NSPopUpButton, 
                       _NSPopUpButtonCell, _NSPopover, _NSPopoverAnimationController, 
                       _NSPopoverBinder, _NSPopoverColorWell, _NSPopoverFrame, 
                       _NSPredicateEditor, _NSPredicateEditorRowTemplate, 
                       _NSPreferences, _NSPreferencesModule, _NSPressGestureRecognizer, 
                       _NSPressureConfiguration, _NSPressureSensitivePanGestureRecognizer, 
                       _NSPrintCopyingGraphicsContext, _NSPrintInfo, _NSPrintInfoAdditionalIVars, 
                       _NSPrintInfoDictionaryProxy, _NSPrintOperation, 
                       _NSPrintOperationPrintEventRetrofitInfo, _NSPrintPanel, 
                       _NSPrintPanelOldAccessoryController, _NSPrintPreviewController, 
                       _NSPrintPreviewGraphicsContext, _NSPrintSpoolingGraphicsContext, 
                       _NSPrintThumbnailView, _NSPrinter, _NSProgressIndicator, 
                       _NSProgressIndicatorBinder, _NSProgressPanel, _NSPulseGestureRecognizer, 
                       _NSRGBSliders, _NSRectSet, _NSRegion, _NSRemoteInputServer, 
                       _NSResponder, _NSRotationGestureRecognizer, _NSRuleEditor, 
                       _NSRuleEditorButton, _NSRuleEditorButtonCell, _NSRuleEditorLocalizer, 
                       _NSRuleEditorPopupButton, _NSRuleEditorPopupButtonCell, 
                       _NSRuleEditorTextField, _NSRuleEditorTextFieldCell, 
                       _NSRuleEditorViewSlice, _NSRuleEditorViewSliceDropSeparator, 
                       _NSRuleEditorViewSliceRow, _NSRulerLabelCell, _NSRulerMarker, 
                       _NSRulerMarkerPanel, _NSRulerMarkerView, _NSRulerView, 
                       _NSRulerViewAccessibilityPanelController, _NSRulerViewPrivateData, 
                       _NSRunningApplication, _NSSavePanel, _NSSavePanelAuxiliary, 
                       _NSSavePanelNameFieldCell, _NSScreen, _NSScreenBackgroundView, 
                       _NSScrollAnimationHelper, _NSScrollView, _NSScroller, 
                       _NSScrollerImp, _NSScrollerImpPair, _NSSearchButtonCellProxy, 
                       _NSSearchField, _NSSearchFieldBinder, _NSSearchFieldCell, 
                       _NSSecureStringWrapper, _NSSecureTextField, _NSSecureTextFieldCell, 
                       _NSSecureTextStorage, _NSSecureTextView, _NSSegmentItem, 
                       _NSSegmentedCell, _NSSegmentedControl, _NSSegmentedControlBinder, 
                       _NSSelectionArray, _NSSelectionBinder, _NSServiceListener, 
                       _NSServiceMaster, _NSServicesMenuHandler, _NSShadowSurface, 
                       _NSSharingService, _NSSharingServicePicker, _NSSharingServicePickerReserved, 
                       _NSSharingServiceReserved, _NSSharingService_Subsystem, 
                       _NSSidebarImage, _NSSidebarImageCell, _NSSlider, 
                       _NSSliderCell, _NSSnapshotContextSignature, _NSSortedArray, 
                       _NSSound, _NSSourceListBackgroundColor, _NSSpeechRecognizer, 
                       _NSSpeechRecognizerVars, _NSSpeechSynthesizer, _NSSpeechSynthesizerVars, 
                       _NSSpellChecker, _NSSpellingLanguageTableView, _NSSpellingPanel, 
                       _NSSplitView, _NSSplitViewController, _NSSplitViewItem, 
                       _NSSplitViewSplitter, _NSStackView, _NSStatusBar, 
                       _NSStatusBarButton, _NSStatusBarButtonCell, _NSStatusBarWindow, 
                       _NSStatusItem, _NSStepper, _NSStepperCell, _NSStopTouchingMeBox, 
                       _NSStoryboard, _NSStoryboardControllerPlaceholder, 
                       _NSStoryboardEmbedSegueTemplate, _NSStoryboardModalSegueTemplate, 
                       _NSStoryboardPopoverSegueTemplate, _NSStoryboardSegue, 
                       _NSStoryboardSegueTemplate, _NSStoryboardSheetSegueTemplate, 
                       _NSStoryboardShowSegueTemplate, _NSSubTextStorage, 
                       _NSSurface, _NSSystemInfoPanel, _NSSystemStatusBar, 
                       _NSTabView, _NSTabViewBinder, _NSTabViewController, 
                       _NSTabViewControllerSegmentedControlUIProvider, 
                       _NSTabViewItem, _NSTabWell, _NSTableBinder, _NSTableCellView, 
                       _NSTableCellViewAux, _NSTableColumn, _NSTableColumnBinder, 
                       _NSTableHeaderCell, _NSTableHeaderCellView, _NSTableHeaderView, 
                       _NSTableRow, _NSTableRowView, _NSTableView, _NSTableViewCellMockElement, 
                       _NSTableViewCellProxy, _NSTableViewChildCellProxy, 
                       _NSTableViewDynamicToolTipManager, _NSTableViewListCellMockElement, 
                       _NSTableViewListCellProxy, _NSTableViewRowAction, 
                       _NSTargetAnimationInfo, _NSTemplatizingImageRep, 
                       _NSText, _NSTextAttachmentCell, _NSTextAttachmentImageView, 
                       _NSTextCheckingOperation, _NSTextColorBinder, _NSTextField, 
                       _NSTextFieldCell, _NSTextFinder, _NSTextFinderBarView, 
                       _NSTextInputContext, _NSTextPlaceholder, _NSTextReplacementNode, 
                       _NSTextStorageCharacterArray, _NSTextStorageElementArray, 
                       _NSTextTemplate, _NSTextValueBinder, _NSTextView, 
                       _NSTextViewCompletionController, _NSTextViewCompletionTableView, 
                       _NSTextViewCompletionWindow, _NSTextViewIvars, _NSTextViewSharedData, 
                       _NSTextViewTemplate, _NSThemeDocumentButton, _NSThemeDocumentButtonCell, 
                       _NSThemeDocumentButtonPopUpMenuProxy, _NSThemeFrame, 
                       _NSTitleBinder, _NSTitlebarAccessoryViewController, 
                       _NSTitledFrame, _NSTokenAttachment, _NSTokenAttachmentCell, 
                       _NSTokenField, _NSTokenFieldCell, _NSTokenTextView, 
                       _NSToolTip, _NSToolTipManager, _NSToolTipPanel, 
                       _NSToolTipStringDrawingLayoutManager, _NSToolbar, 
                       _NSToolbarButton, _NSToolbarClippedItemsIndicator, 
                       _NSToolbarConfigPanel, _NSToolbarFlexibleSpaceItem, 
                       _NSToolbarGroupView, _NSToolbarItem, _NSToolbarItemConfigWrapper, 
                       _NSToolbarItemGroup, _NSToolbarItemViewer, _NSToolbarPoofAnimator, 
                       _NSToolbarSeparatorItem, _NSToolbarSpaceItem, _NSToolbarView, 
                       _NSTouch, _NSTouchDevice, _NSTracer, _NSTrackableOutlineView, 
                       _NSTrackingArea, _NSTrackingInfoImpl, _NSTreeController, 
                       _NSTreeControllerTreeNode, _NSTreeDetailBinder, 
                       _NSTreeNode, _NSUIHeartBeat, _NSUndoReplaceCharacters, 
                       _NSUndoSetAttributes, _NSUndoTextOperation, _NSUndoTyping, 
                       _NSUserDefaultsController, _NSUserInterfaceTheme, 
                       _NSVBOpenPanel, _NSVBSavePanel, _NSValueBinder, 
                       _NSView, _NSViewAnimation, _NSViewBuffer, _NSViewController, 
                       _NSViewControllerPresentationAnimatorObject, _NSViewControllerPushTransition, 
                       _NSViewDynamicToolTipManager, _NSViewHierarchyLock, 
                       _NSViewStateBinder, _NSViewTemplate, _NSViewTextAttachmentCell, 
                       _NSViewTextAttachmentCellHelper, _NSViewWindowBackingStoreBuffer, 
                       _NSVisualEffectView, _NSWindow, _NSWindowAuxiliary, 
                       _NSWindowBinder, _NSWindowController, _NSWindowFullScreenController, 
                       _NSWindowGraphicsContext, _NSWindowMenuItem, _NSWindowTemplate, 
                       _NSWindowTitleBinder, _NSWorkspace, _NSWorkspaceNotificationCenter, 
                       __NS1DVelocityFilter, __NS2DVelocityFilter, __NSAccessibilityLabelViewLabel, 
                       __NSAccessibilityOverriddenAttributeUIElementValue, 
                       __NSActionBinderPlugin, __NSArrayControllerExtensions, 
                       __NSAutomaticFocusRing, __NSBalancedModelObservingTracker, 
                       __NSBinderAlertRecoveryAttempter, __NSBinderPlugin, 
                       __NSBinderPluginRegistry, __NSBindingAdaptor, __NSBindingInfo, 
                       __NSBorderlessLayerTreeProjectionWindow, __NSBorderlessLayerTreeProjectionWindowContentView, 
                       __NSBrowserAuxiliary, __NSBrowserBranchImageCell, 
                       __NSBrowserColumnScrollHelper, __NSBrowserColumnView, 
                       __NSBrowserColumnViewScrollHandler, __NSBrowserColumnsContainerView, 
                       __NSBrowserDragSourceContext, __NSBrowserDropDestContext, 
                       __NSBrowserFlippedClipView, __NSBrowserHeaderClipView, 
                       __NSBrowserMatrixColumnViewController, __NSBrowserPreviewColumnViewController, 
                       __NSBrowserScrollView, __NSBrowserTableColumnViewController, 
                       __NSBrowserTitlesContainerView, __NSButtonImage, 
                       __NSCarbonMenuWindowTrackingAreaReference, __NSCheckBoxPlugin, 
                       __NSClassAndClassInfo, __NSCollectionViewRubberband, 
                       __NSColorPanelToolbar, __NSColorPanelToolbarItem, 
                       __NSColorWellPlugin, __NSComboBoxPlugin, __NSContextHelpBorderView, 
                       __NSControllerArrayProxy, __NSControllerArrayProxyMutatorArray, 
                       __NSControllerEditorSheetContext, __NSControllerObjectProxy, 
                       __NSControllerTreeProxy, __NSControllerTreeProxyMutatorArray, 
                       __NSDatePickerCellExtraIvars, __NSDatePickerCellSubfield, 
                       __NSDatePickerRange, __NSDateValueBinderPlugin, 
                       __NSDisplayFontBinderPlugin, __NSDisplayOperation, 
                       __NSDisplayOperationStack, __NSDoubleClickActionBinderPlugin, 
                       __NSDoubleValueBinderPlugin, __NSDragManager, __NSDrawingThreadData, 
                       __NSDuplicateDocumentAnimationProjectionWindow, 
                       __NSEditableBinderPlugin, __NSEmptyIconViewCell, 
                       __NSEventObserver, __NSExpectedObservingInfo, __NSFilePromiseTypeConverter, 
                       __NSFilenamesPboardTypeConverter, __NSFilterPredicateVisitor, 
                       __NSFlippedImage, __NSFocusStackElement, __NSGlobalEventObserver, 
                       __NSGrowBoxView, __NSIconAnimation, __NSIconViewDragContext, 
                       __NSImageAuxiliary, __NSImageCellPlugin, __NSImageViewPlugin, 
                       __NSInputAlignmentControllerSession, __NSInputAlignmentGuide, 
                       __NSInputAlignmentItem, __NSInputAlignmentMatch, 
                       __NSKeyBindingStateActual, __NSKeyboardFocusClipView, 
                       __NSLayoutConstraintAnimator, __NSLazyFetchingArray, 
                       __NSLocalEventObserver, __NSMagnifier, __NSManagedProxy, 
                       __NSMatrixPlugin, __NSMatrixPrivateIvars, __NSMenuContext, 
                       __NSMenuImpl, __NSMenuItemPlugin, __NSMenuServicesView, 
                       __NSMenuServicesViewOperation, __NSModelObservingTracker, 
                       __NSMultipleSelectionMatrixPlugin, __NSNavButtonCell, 
                       __NSNavContextCloseObject, __NSNavNodeMenuItem, 
                       __NSOrderOutAnimationProxyWindow, __NSOrderOutAnimationProxyWindowContentView, 
                       __NSPDFDocument, __NSPasteboardItemAuxObject, __NSPasteboardItemCollection, 
                       __NSPasteboardOwnersCollection, __NSPasteboardTypeCache, 
                       __NSPathLocationAnimation, __NSPathPlugin, __NSPboardImageTypeConverter, 
                       __NSPboardTypeConverter, __NSPeriodicEventSource, 
                       __NSPeriodicInvoker, __NSPlaceholderTextFieldPlugin, 
                       __NSPopUpButtonPlugin, __NSPredicateEditorPlugin, 
                       __NSPredicateEditorRowNode, __NSPredicateEditorTree, 
                       __NSPrintThumbnailBaseView, __NSProgressIndicatorPlugin, 
                       __NSPromiseContentsTypeConverter, __NSRTFPboardTypeConverter, 
                       __NSRubberBand, __NSRuleEditorCache, __NSRuleEditorViewSliceHolder, 
                       __NSRuleEditorViewUnboundRowHolder, __NSSavePanelHackAlert, 
                       __NSSavePanelTextView, __NSScrollViewContentAreaLayout, 
                       __NSScrollerStyleRecommender, __NSScrollingMomentumCalculator, 
                       __NSScrollingPredominantAxisFilter, __NSScrollingRubberbandFilter, 
                       __NSScrollingScoreKeeper, __NSSearchFieldBinderPredicateOptionPair, 
                       __NSSearchFieldPlugin, __NSSearchSliceKindHandler, 
                       __NSSegmentedControlPlugin, __NSSelectionBinderPlugin, 
                       __NSServiceEntry, __NSServiceFilter, __NSServiceRequestorInfo, 
                       __NSServicesContextMenuUpdater, __NSServicesMenuUpdater, 
                       __NSServicesPrincipalMenuUpdater, __NSSlideAndCrossFadeAnimationProjectionWindow, 
                       __NSSoundAux, __NSStateMarker, __NSStringAndClassInfo, 
                       __NSStringPboardTypeConverter, __NSTabViewItemAuxiliary, 
                       __NSTableColumnAuxiliary, __NSTableRowHeightStorage, 
                       __NSTableUtilities, __NSTableViewReserved, __NSTextAnimationOverlayView, 
                       __NSTextColorBinderPlugin, __NSTextFieldPlugin, 
                       __NSTextPlugin, __NSThemeCloseWidget, __NSThemeCloseWidgetCell, 
                       __NSThemeFullScreenButtonCell, __NSThemeWidget, 
                       __NSThemeWidgetCell, __NSTokenFieldPlugin, __NSToolbarAuxiliary, 
                       __NSToolbarButtonCell, __NSToolbarButtonItemViewerAccessibilityHelper, 
                       __NSToolbarButtonViewItemViewerAccessibilityHelper, 
                       __NSToolbarClippedItemsIndicatorCell, __NSToolbarConfigPanelLoader, 
                       __NSToolbarFlexibleSpace, __NSToolbarGapItem, __NSToolbarImageRepView, 
                       __NSToolbarItemAuxiliary, __NSToolbarItemConfigWrapperImageView, 
                       __NSToolbarItemPlaceholder, __NSToolbarItemViewerAccessibilityHelper, 
                       __NSToolbarItemViewerLabelCell, __NSToolbarItemViewerLabelCellPopUpCell, 
                       __NSToolbarItemViewerLabelView, __NSToolbarPaletteItemViewerAccessibilityHelper, 
                       __NSToolbarProxyItemViewerAccessibilityHelper, __NSToolbarSegmentedViewItemViewerAccessibilityHelper, 
                       __NSToolbarSegmentedViewSegmentProxy, __NSToolbarSeparator, 
                       __NSToolbarSeparatorAndSpaceItemViewerAccessibilityHelper, 
                       __NSToolbarSingleSegmentSegmentedViewItemViewerAccessibilityHelper, 
                       __NSToolbarSpace, __NSToolbarSplitViewPartitionAdapter, 
                       __NSToolbarTransitionGraphicsContext, __NSToolbarViewClipView, 
                       __NSToolbarViewItemViewerAccessibilityHelper, __NSTreeNodeChildNodesArrayProxy, 
                       __NSTreeNodeObservingTracker, __NSURLPboardTypeConverter, 
                       __NSUnbufferedLayerTreeWindow, __NSUnbufferedLayerTreeWindowContentView, 
                       __NSValueBinderPlugin, __NSViewAnimator_NSScrollView, 
                       __NSViewAuxiliary, __NSViewDrawOperation, __NSWindowAnimator, 
                       __NSWindowBorderGradient, __NSWindowMenuUpdater, 
                       __NSWindowTransformAnimation, __NSWorkspaceFileOperation, 
                       __NSWorkspaceVolumeStatusTracker, ___NSAppKitThreadSpecificData, 
                       ___NSEventDiscardInfo, ___NSWindowData ]
...
                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers/  0040755 0001750 0001750 00000000000 12612224737 031076  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        AppKit.h                                                                                            0100644 0001750 0001750 00000017175 12567220725 032372  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	AppKit.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.

	This file is included by all AppKit application source files for easy building.  Using this file is preferred over importing individual files because it will use a precompiled version.
*/

#import <Foundation/Foundation.h>
#import <AppKit/AppKitDefines.h>
#import <AppKit/AppKitErrors.h>
#import <AppKit/NSGraphicsContext.h>
#import <AppKit/NSAccessibility.h>
#import <AppKit/NSActionCell.h>
#import <AppKit/NSAlert.h>
#import <AppKit/NSAnimationContext.h>
#import <AppKit/NSAppearance.h>
#import <AppKit/NSAppleScriptExtensions.h>
#import <AppKit/NSApplication.h>
#import <AppKit/NSBox.h>
#import <AppKit/NSButton.h>
#import <AppKit/NSButtonCell.h>
#import <AppKit/NSCell.h>
#import <AppKit/NSClipView.h>
#import <AppKit/NSCollectionView.h>
#import <AppKit/NSCollectionViewLayout.h>
#import <AppKit/NSCollectionViewFlowLayout.h>
#import <AppKit/NSCollectionViewGridLayout.h>
#import <AppKit/NSCollectionViewTransitionLayout.h>
#import <AppKit/NSControl.h>
#import <AppKit/NSDockTile.h>
#import <AppKit/NSFont.h>
#import <AppKit/NSFontCollection.h>
#import <AppKit/NSFontDescriptor.h>
#import <AppKit/NSFontManager.h>
#import <AppKit/NSFontPanel.h>
#import <AppKit/NSForm.h>
#import <AppKit/NSFormCell.h>
#import <AppKit/NSMatrix.h>
#import <AppKit/NSMenu.h>
#import <AppKit/NSMenuItem.h>
#import <AppKit/NSColor.h>
#import <AppKit/NSColorSpace.h>
#import <AppKit/NSBitmapImageRep.h>
#import <AppKit/NSBrowser.h>
#import <AppKit/NSBrowserCell.h>
#import <AppKit/NSCachedImageRep.h>
#import <AppKit/NSCIImageRep.h>
#import <AppKit/NSColorList.h>
#import <AppKit/NSColorPanel.h>
#import <AppKit/NSColorPicking.h>
#import <AppKit/NSColorPicker.h>
#import <AppKit/NSColorWell.h>
#import <AppKit/NSCursor.h>
#import <AppKit/NSCustomImageRep.h>
#import <AppKit/NSDocument.h>
#import <AppKit/NSDocumentController.h>
#import <AppKit/NSDragging.h>
#import <AppKit/NSDraggingItem.h>
#import <AppKit/NSDraggingSession.h>
#import <AppKit/NSEPSImageRep.h>
#import <AppKit/NSErrors.h>
#import <AppKit/NSEvent.h>
#import <AppKit/NSFileWrapperExtensions.h>
#import <AppKit/NSHelpManager.h>
#import <AppKit/NSGradient.h>
#import <AppKit/NSGraphics.h>
#import <AppKit/NSGestureRecognizer.h>
#import <AppKit/NSClickGestureRecognizer.h>
#import <AppKit/NSPanGestureRecognizer.h>
#import <AppKit/NSPressGestureRecognizer.h>
#import <AppKit/NSMagnificationGestureRecognizer.h>
#import <AppKit/NSRotationGestureRecognizer.h>
#import <AppKit/NSImage.h>
#import <AppKit/NSImageCell.h>
#import <AppKit/NSImageRep.h>
#import <AppKit/NSImageView.h>
#import <AppKit/NSLayoutConstraint.h>
#import <AppKit/NSLayoutGuide.h>
#import <AppKit/NSNib.h>
#import <AppKit/NSNibLoading.h>
#import <AppKit/NSPrinter.h>
#import <AppKit/NSSpeechRecognizer.h>
#import <AppKit/NSSpeechSynthesizer.h>
#import <AppKit/NSSpellChecker.h>
#import <AppKit/NSSplitView.h>
#import <AppKit/NSSplitViewController.h>
#import <AppKit/NSOpenPanel.h>
#import <AppKit/NSPageLayout.h>
#import <AppKit/NSPanel.h>
#import <AppKit/NSPasteboard.h>
#import <AppKit/NSPasteboardItem.h>
#import <AppKit/NSPopUpButton.h>
#import <AppKit/NSPrintInfo.h>
#import <AppKit/NSPrintOperation.h>
#import <AppKit/NSPrintPanel.h>
#import <AppKit/NSPDFInfo.h>
#import <AppKit/NSPDFPanel.h>
#import <AppKit/NSResponder.h>
#import <AppKit/NSSavePanel.h>
#import <AppKit/NSMediaLibraryBrowserController.h>
#import <AppKit/NSScreen.h>
#import <AppKit/NSScrollView.h>
#import <AppKit/NSScroller.h>
#import <AppKit/NSSegmentedControl.h>
#import <AppKit/NSSegmentedCell.h>
#import <AppKit/NSSharingService.h>
#import <AppKit/NSSlider.h>
#import <AppKit/NSSliderCell.h>
#import <AppKit/NSSpellProtocol.h>
#import <AppKit/NSStackView.h>
#import <AppKit/NSText.h>
#import <AppKit/NSTextField.h>
#import <AppKit/NSTextFieldCell.h>
#import <AppKit/NSText.h>
#import <AppKit/NSTokenField.h>
#import <AppKit/NSTokenFieldCell.h>
#import <AppKit/NSTrackingArea.h>
#import <AppKit/NSUserActivity.h>
#import <AppKit/NSView.h>
#import <AppKit/NSViewController.h>
#import <AppKit/NSWindow.h>
#import <AppKit/NSWindowController.h>
#import <AppKit/NSWorkspace.h>
#import <AppKit/NSRunningApplication.h>
#import <AppKit/NSComboBox.h>
#import <AppKit/NSComboBoxCell.h>
#import <AppKit/NSTableCellView.h>
#import <AppKit/NSTableColumn.h>
#import <AppKit/NSTableHeaderCell.h>
#import <AppKit/NSTableHeaderView.h>
#import <AppKit/NSTableRowView.h>
#import <AppKit/NSTableView.h>
#import <AppKit/NSTableViewRowAction.h>
#import <AppKit/NSOutlineView.h>
#import <AppKit/NSAttributedString.h>
#import <AppKit/NSLayoutManager.h>
#import <AppKit/NSParagraphStyle.h>
#import <AppKit/NSTextStorage.h>
#import <AppKit/NSTextView.h>
#import <AppKit/NSTextContainer.h>
#import <AppKit/NSTextAttachment.h>
#import <AppKit/NSInputManager.h>
#import <AppKit/NSInputServer.h>
#import <AppKit/NSStringDrawing.h>
#import <AppKit/NSRulerMarker.h>
#import <AppKit/NSRulerView.h>
#import <AppKit/NSSecureTextField.h>
#import <AppKit/NSInterfaceStyle.h>
#import <AppKit/NSNibDeclarations.h>
#import <AppKit/NSProgressIndicator.h>
#import <AppKit/NSTabView.h>
#import <AppKit/NSTabViewController.h>
#import <AppKit/NSTabViewItem.h>
#import <AppKit/NSMenuView.h>
#import <AppKit/NSMenuItemCell.h>
#import <AppKit/NSPopUpButtonCell.h>
#import <AppKit/NSAffineTransform.h>
#import <AppKit/NSBezierPath.h>
#import <AppKit/NSPICTImageRep.h>
#import <AppKit/NSStatusBar.h>
#import <AppKit/NSStatusBarButton.h>
#import <AppKit/NSStatusItem.h>
#import <AppKit/NSSound.h>
#import <AppKit/NSMovie.h>
#import <AppKit/NSMovieView.h>
#import <AppKit/NSPDFImageRep.h>
#import <AppKit/NSQuickDrawView.h>
#import <AppKit/NSDrawer.h>
#import <AppKit/NSOpenGL.h>
#import <AppKit/NSOpenGLLayer.h>
#import <AppKit/NSOpenGLView.h>
#import <AppKit/NSApplicationScripting.h>
#import <AppKit/NSDocumentScripting.h>
#import <AppKit/NSTextStorageScripting.h>
#import <AppKit/NSToolbar.h>
#import <AppKit/NSToolbarItem.h>
#import <AppKit/NSToolbarItemGroup.h>
#import <AppKit/NSWindowScripting.h>
#import <AppKit/NSStepper.h>
#import <AppKit/NSStepperCell.h>
#import <AppKit/NSGlyphInfo.h>
#import <AppKit/NSShadow.h>
#import <AppKit/NSATSTypesetter.h>
#import <AppKit/NSGlyphGenerator.h>
#import <AppKit/NSSearchField.h>
#import <AppKit/NSSearchFieldCell.h>
#import <AppKit/NSController.h>
#import <AppKit/NSObjectController.h>
#import <AppKit/NSArrayController.h>
#import <AppKit/NSDictionaryController.h>
#import <AppKit/NSTreeNode.h>
#import <AppKit/NSTreeController.h>
#import <AppKit/NSUserDefaultsController.h>
#import <AppKit/NSKeyValueBinding.h>
#import <AppKit/NSTextList.h>
#import <AppKit/NSTextTable.h>
#import <AppKit/NSDatePickerCell.h>
#import <AppKit/NSDatePicker.h>
#import <AppKit/NSLevelIndicatorCell.h>
#import <AppKit/NSLevelIndicator.h>
#import <AppKit/NSAnimation.h>
#import <AppKit/NSPersistentDocument.h>
#import <AppKit/NSRuleEditor.h>
#import <AppKit/NSPredicateEditor.h>
#import <AppKit/NSPredicateEditorRowTemplate.h>
#import <AppKit/NSPathCell.h>
#import <AppKit/NSPathControl.h>
#import <AppKit/NSPathComponentCell.h>
#import <AppKit/NSPathControlItem.h>
#import <AppKit/NSPageController.h>
#import <AppKit/NSPopover.h>
#import <AppKit/NSTextInputClient.h>
#import <AppKit/NSTextInputContext.h>
#import <AppKit/NSUserInterfaceItemSearching.h>
#import <AppKit/NSUserInterfaceLayout.h>
#import <AppKit/NSTouch.h>
#import <AppKit/NSWindowRestoration.h>
#import <AppKit/NSTextAlternatives.h>
#import <AppKit/NSStoryboard.h>
#import <AppKit/NSStoryboardSegue.h>
#import <AppKit/NSVisualEffectView.h>
#import <AppKit/NSItemProvider.h>
#import <AppKit/NSTitlebarAccessoryViewController.h>
#import <AppKit/NSDataAsset.h>
#import <AppKit/NSAlignmentFeedbackFilter.h>
#import <AppKit/NSHapticFeedback.h>
#import <AppKit/NSPressureConfiguration.h>
                                                                                                                                                                                                                                                                                                                                                                                                   AppKitDefines.h                                                                                     0100644 0001750 0001750 00000003626 12567220725 033664  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	AppKitDefines.h
	Application Kit
	Copyright (c) 1995-2015, Apple Inc.
	All rights reserved.
*/
#ifndef _APPKITDEFINES_H
#define _APPKITDEFINES_H

#import <AvailabilityMacros.h>
#import <Foundation/NSObjCRuntime.h>

#ifndef AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_0
#define AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_0 DEPRECATED_IN_MAC_OS_X_VERSION_10_0_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_1 DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2 DEPRECATED_IN_MAC_OS_X_VERSION_10_2_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3 DEPRECATED_IN_MAC_OS_X_VERSION_10_3_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4 DEPRECATED_IN_MAC_OS_X_VERSION_10_4_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5 DEPRECATED_IN_MAC_OS_X_VERSION_10_5_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6 DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
#define AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7 DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER
#endif

//
//  Platform specific defs for externs
//

//
// For MACH
//

#if defined(__MACH__)

#ifdef __cplusplus
#define APPKIT_EXTERN		extern "C"
#define APPKIT_PRIVATE_EXTERN	__attribute__((visibility("hidden"))) extern "C"
#define APPKIT_PRIVATE          __attribute__((visibility("hidden")))
#else
#define APPKIT_EXTERN		extern
#define APPKIT_PRIVATE_EXTERN	__attribute__((visibility("hidden"))) extern
#define APPKIT_PRIVATE          __attribute__((visibility("hidden")))
#endif

//
// For Windows
//

#endif

#endif // _APPKITDEFINES_H

                                                                                                          AppKitErrors.h                                                                                      0100644 0001750 0001750 00000004506 12567220725 033561  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	AppKitErrors.h
	Application Kit
	Copyright (c) 2004-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>


/* NSError codes for AppKit added errors in NSCocoaErrorDomain.  Foundation error codes can be found in <Foundation/FoundationErrors.h>; CoreData error codes in <CoreData/CoreDataErrors.h>.
*/
enum {
    NSTextReadInapplicableDocumentTypeError = 65806,		// NSAttributedString parsing error
    NSTextWriteInapplicableDocumentTypeError = 66062,		// NSAttributedString generating error

    // Inclusive error range definitions, for checking future error codes
    NSTextReadWriteErrorMinimum = 65792,
    NSTextReadWriteErrorMaximum = 66303,
    
    // Service error codes
    NSServiceApplicationNotFoundError = 66560,			// The service provider could not be found.
    NSServiceApplicationLaunchFailedError = 66561,		// The service providing application could not be launched.  This will typically contain an underlying error with an LS error code (check MacErrors.h for their meanings).
    NSServiceRequestTimedOutError = 66562,			// The service providing application did not open its service listening port in time, or the app didn't respond to the request in time; see the Console log to figure out which (the errors are typically reported the same way to the user).
    NSServiceInvalidPasteboardDataError = 66563,		// The service providing app did not return a pasteboard with any of the promised types, or we couldn't write the data from the pasteboard to the object receiving the returned data.
    NSServiceMalformedServiceDictionaryError = 66564,		// The service dictionary did not contain the necessary keys.  Messages will typically be logged to the console giving more details.
    NSServiceMiscellaneousError = 66800,			// Other errors, representing programmatic mistakes in the service consuming application.  These show a generic error message to the user.
    
    // Inclusive service error range, for checking future error codes
    NSServiceErrorMinimum = 66560,
    NSServiceErrorMaximum = 66817,
    
    
    // Sharing Service Error    
    NSSharingServiceNotConfiguredError = 67072,                // The service is not configured in the Preferences
    
    // Inclusive service error range, for checking future error codes
    NSSharingServiceErrorMinimum = 67072,
    NSSharingServiceErrorMaximum = 67327
};



                                                                                                                                                                                          NSATSTypesetter.h                                                                                   0100644 0001750 0001750 00000016011 12567220725 034147  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSATSTypesetter.h
        Application Kit
        Copyright (c) 2002-2015, Apple Inc.
        All rights reserved.
*/

#import <AppKit/NSTypesetter.h>
#import <AppKit/NSParagraphStyle.h>

NS_ASSUME_NONNULL_BEGIN

NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE
@interface NSATSTypesetter : NSTypesetter {
/* Ivars used for primitive typesetting */
    NSAttributedString *attributedString; // The text backing-store (usually NSTextStorage)

    NSRange paragraphGlyphRange; // The current glyph range being processed

    NSRange paragraphSeparatorGlyphRange; // The current paragraph separator range (the length == 0 at the end of document)

    CGFloat lineFragmentPadding; // The margin on both sides of lines

/* Ivars for the Cocoa Text System interface */
    NSLayoutManager *layoutManager;
    NSArray *textContainers;

/* Cached NSTextContainer settings */
    NSTextContainer *currentTextContainer;
    NSUInteger currentTextContainerIndex;
    NSSize currentTextContainerSize;

/* Cached NSParagraphStyle */
    NSParagraphStyle *currentParagraphStyle;

@private
    void *_atsReserved[8];
    id _private;
}

// Factory methods
+ (NSATSTypesetter *)sharedTypesetter;
@end

@interface NSATSTypesetter (NSPantherCompatibility)
// This interface is deprecated.
// Use -getLineFragmentRect:usedRect:forStartingGlyphAtIndex:proposedRect:lineSpacing:paragraphSpacingBefore:paragraphSpacingAfter:remainingRect: instead
- (NSRect)lineFragmentRectForProposedRect:(NSRect)proposedRect remainingRect:(null_unspecified NSRectPointer)remainingRect NS_DEPRECATED_MAC(10_3, 10_4);
@end

// The following interfaces are moved to the abstract NSTypesetter class

@interface NSATSTypesetter (NSPrimitiveInterface)
/* Privmitive typesetting methods */
// NSLayoutManager attributes
@property BOOL usesFontLeading;
@property NSTypesetterBehavior typesetterBehavior;
@property float hyphenationFactor;

// NSTextContainer attributes
@property CGFloat lineFragmentPadding;

// Screen/printer font mapping
- (NSFont *)substituteFontForFont:(NSFont *)originalFont;

// Tab stops
- (nullable NSTextTab *)textTabForGlyphLocation:(CGFloat)glyphLocation writingDirection:(NSWritingDirection)direction maxLocation:(CGFloat)maxLocation;

// Bidi control
@property BOOL bidiProcessingEnabled; // Controls whether to perform bi-directional processing.  You can disable the layout stage if you know the parapgraph does not need this stage (i.e. the backing-store is in the display order) in -fillAttributesForGlyphsInRange:andParagraphSeparatorRange:.

// Accessors for required paragraph typesetting ivars (attributedString, paragraphGlyphRange, paragraphSeparatorGlyphRange
@property (nullable, assign) NSAttributedString *attributedString; // Note this method does not retain attrString
- (void)setParagraphGlyphRange:(NSRange)paragraphRange separatorGlyphRange:(NSRange)paragraphSeparatorRange;
@property (readonly) NSRange paragraphGlyphRange;
@property (readonly) NSRange paragraphSeparatorGlyphRange;

// layout primitive
- (NSUInteger)layoutParagraphAtPoint:(NSPoint *)lineFragmentOrigin; // lineFragmentOrigin specifies the upper-left corner of line fragment rect.  On return, set to the next origin. The method returns the next glyph index. Usually the index right after paragraph separator but can be inside the paragraph range (i.e. text container exhaustion)

// Line/paragraph spacing
- (CGFloat)lineSpacingAfterGlyphAtIndex:(NSUInteger)glyphIndex withProposedLineFragmentRect:(NSRect)rect;
- (CGFloat)paragraphSpacingBeforeGlyphAtIndex:(NSUInteger)glyphIndex withProposedLineFragmentRect:(NSRect)rect;
- (CGFloat)paragraphSpacingAfterGlyphAtIndex:(NSUInteger)glyphIndex withProposedLineFragmentRect:(NSRect)rect;

/* Cocoa Text System interface methods */

// Friend classes
@property (nullable, readonly, assign) NSLayoutManager *layoutManager;
@property (nullable, readonly, assign) NSTextContainer *currentTextContainer;

// Forces NSLayoutManager to invalidate glyph cache in range when invalidating layout
- (void)setHardInvalidation:(BOOL)flag forGlyphRange:(NSRange)glyphRange;

// This method calculates the line fragment rect/line fragment used rect for blank lines
// theParagraphSeparatorGlyphRange with length == 0 indicates extra line fragment
- (void)getLineFragmentRect:(NSRect *)lineFragmentRect usedRect:(NSRect *)lineFragmentUsedRect forParagraphSeparatorGlyphRange:(NSRange)paragraphSeparatorGlyphRange atProposedOrigin:(NSPoint)lineOrigin;
@end

/* NSLayoutPhaseInterface declares various subclass override points that are invoked if implemented */
@interface NSATSTypesetter (NSLayoutPhaseInterface)
// Called right before setLineFragmentRect:forGlyphRange:usedRect:
- (void)willSetLineFragmentRect:(NSRect *)lineRect forGlyphRange:(NSRange)glyphRange usedRect:(NSRect *)usedRect baselineOffset:(CGFloat *)baselineOffset;

- (BOOL)shouldBreakLineByWordBeforeCharacterAtIndex:(NSUInteger)charIndex;
- (BOOL)shouldBreakLineByHyphenatingBeforeCharacterAtIndex:(NSUInteger)charIndex;

- (float)hyphenationFactorForGlyphAtIndex:(NSUInteger)glyphIndex;
- (UTF32Char)hyphenCharacterForGlyphAtIndex:(NSUInteger)glyphIndex;

- (NSRect)boundingBoxForControlGlyphAtIndex:(NSUInteger)glyphIndex forTextContainer:(NSTextContainer *)textContainer proposedLineFragment:(NSRect)proposedRect glyphPosition:(NSPoint)glyphPosition characterIndex:(NSUInteger)charIndex;
@end

/* NSGlyphStorageInterface declares all primitives interfacing to the glyph storage (usually NSLayoutManager). By overriding all the methods, you can implement an NSATSTypesetter subclass that interacts with custom glyph storage. */
@interface NSATSTypesetter (NSGlyphStorageInterface)
// Glyph/character range mappings
- (NSRange)characterRangeForGlyphRange:(NSRange)glyphRange actualGlyphRange:(nullable NSRangePointer)actualGlyphRange;
- (NSRange)glyphRangeForCharacterRange:(NSRange)charRange actualCharacterRange:(nullable NSRangePointer)actualCharRange;

// Glyph data
- (NSUInteger)getGlyphsInRange:(NSRange)glyphsRange glyphs:(null_unspecified NSGlyph *)glyphBuffer characterIndexes:(null_unspecified NSUInteger *)charIndexBuffer glyphInscriptions:(null_unspecified NSGlyphInscription *)inscribeBuffer elasticBits:(null_unspecified BOOL *)elasticBuffer;

// Layout storage
- (void)setLineFragmentRect:(NSRect)fragmentRect forGlyphRange:(NSRange)glyphRange usedRect:(NSRect)usedRect baselineOffset:(CGFloat)baselineOffset;
- (void)substituteGlyphsInRange:(NSRange)glyphRange withGlyphs:(null_unspecified NSGlyph *)glyphs;
- (void)insertGlyph:(NSGlyph)glyph atGlyphIndex:(NSUInteger)glyphIndex characterIndex:(NSUInteger)characterIndex;
- (void)deleteGlyphsInRange:(NSRange)glyphRange;
- (void)setNotShownAttribute:(BOOL)flag forGlyphRange:(NSRange)glyphRange;
- (void)setDrawsOutsideLineFragment:(BOOL)flag forGlyphRange:(NSRange)glyphRange;
- (void)setLocation:(NSPoint)location withAdvancements:(null_unspecified const CGFloat *)advancements forStartOfGlyphRange:(NSRange)glyphRange;
- (void)setAttachmentSize:(NSSize)attachmentSize forGlyphRange:(NSRange)glyphRange;
- (void)setBidiLevels:(null_unspecified const uint8_t *)levels forGlyphRange:(NSRange)glyphRange;
@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       NSAccessibility.h                                                                                   0100644 0001750 0001750 00000030314 12567220725 034220  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSAccessibility.h
	Application Kit
	Copyright (c) 2001-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/AppKitDefines.h>
#import <AppKit/NSErrors.h>
#import <Foundation/NSGeometry.h>
#import <Foundation/NSObject.h>
#import <AppKit/NSAccessibilityConstants.h>
#import <AppKit/NSAccessibilityProtocols.h>
#import <AppKit/NSAccessibilityElement.h>
#import <AppKit/NSWorkspace.h>

NS_ASSUME_NONNULL_BEGIN

@class NSString, NSArray, NSView;

/*** Accessibility Informal Protocol ***/

@interface NSObject (NSAccessibility)

/* Attribute methods
*/
- (NSArray *)accessibilityAttributeNames NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");
- (nullable id)accessibilityAttributeValue:(NSString *)attribute NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");
- (BOOL)accessibilityIsAttributeSettable:(NSString *)attribute NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");
- (void)accessibilitySetValue:(nullable id)value forAttribute:(NSString *)attribute NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");

/* Parameterized Attribute methods
*/
- (NSArray *)accessibilityParameterizedAttributeNames NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");
- (nullable id)accessibilityAttributeValue:(NSString *)attribute forParameter:(nullable id)parameter NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");;

/* Accessibility action methods
*/
- (NSArray *)accessibilityActionNames NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");
- (nullable NSString *)accessibilityActionDescription:(NSString *)action NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");
- (void)accessibilityPerformAction:(NSString *)action NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");

/* Return YES if the UIElement doesn't show up to the outside world - i.e. its parent should return the UIElement's children as its own - cutting the UIElement out. E.g. NSControls are ignored when they are single-celled.
*/
- (BOOL)accessibilityIsIgnored NS_DEPRECATED_MAC(10_1, 10_10, "Use isAccessibilityElement instead");

/* Returns the deepest descendant of the UIElement hierarchy that contains the point. You can assume the point has already been determined to lie within the receiver. Override this method to do deeper hit testing within a UIElement - e.g. a NSMatrix would test its cells. The point is bottom-left relative screen coordinates.
*/
- (nullable id)accessibilityHitTest:(NSPoint)point;

/* Returns the UI Element that has the focus. You can assume that the search for the focus has already been narrowed down to the receiver. Override this method to do a deeper search with a UIElement - e.g. a NSMatrix would determine if one of its cells has the focus.
*/
@property (nullable, readonly, strong) id accessibilityFocusedUIElement;


/* The following are optional methods to improve performance of accessible objects with large numbers of children or large numbers of UI Elements returned from attributes that return an array (selected children, or visible children, for instance).  The default implementation for these operations will call -accessibilityAttributeValue: to retrieve the entire array of values, and then perform the appropriate operation.  If these methods are implemented, they will be used instead.  For accessibility objects with many children, the results to these methods can sometimes be calculated without generating the entire array of children which can improve performance.
*/

/* Given an accessibility child of an object, return the index of that child in the parent.  If the provided object is not a child of the receiver, this method should return NSNotFound.
*/
- (NSUInteger)accessibilityIndexOfChild:(id)child;

/* Return the count of an accessibility array attribute.
*/
- (NSUInteger)accessibilityArrayAttributeCount:(NSString *)attribute;

/* Return a subarray of values of an accessibility array attribute.  Note this method does not take a range.  The max count is the maximum desired number of items requested by an accessibility client.  This number may be beyond the bounds of your array.
*/
- (NSArray *)accessibilityArrayAttributeValues:(NSString *)attribute index:(NSUInteger)index maxCount:(NSUInteger)maxCount;

/*
 Prior to OS X 10.9, the only accessible objects that could post accessibility notifications were those that inherited from NSView, NSWindow, or NSCell. An application's custom accessible object, subclassed from NSObject, could not post notifications.
 
 In 10.9 and later, an application's custom accessible object may post accessibility notifications if it follows the following guidelines:
 
 - the lifetime of the NSObject must match the lifetime of the corresponding element in the application's visual interface. It is common for a custom accessible object that acts as a proxy for an onscreen UI element to be autoreleased and deallocated very quickly, immediately after the application responds to a single accessibility request. This is not sufficient to support posting notifications, because any notification observers that are registered on the object will be removed as soon as the object is deallocated. Instead, the application must arrange for an accessible object that refers to a specific UI element to remain allocated as long as that UI element is visible.
 
 - the object must post the NSAccessibilityUIElementDestroyed notification at appropriate times, typically when the corresponding UI element in the application's visual interface is removed from the screen, and certainly when the accessible object is deallocated.
 
 - the object must implement -accessibilityNotifiesWhenDestroyed to return YES.
 */
@property (readonly) BOOL accessibilityNotifiesWhenDestroyed NS_AVAILABLE_MAC(10_9);

@end


@interface NSWorkspace (NSWorkspaceAccessibilityDisplay)

/* Get the current accessibility display option for high-contrast UI. If this is true, UI should be presented with high contrast such as utilizing a less subtle color palette or bolder lines. You may listen for NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification to be notified when this changes. */
@property (readonly) BOOL accessibilityDisplayShouldIncreaseContrast NS_AVAILABLE_MAC(10_10);

/* Get the current accessibility display option for differentiate without color. If this is true, UI should not convey information using color alone and instead should use shapes or glyphs to convey information. You may listen for NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification to be notified when this changes. */
@property (readonly) BOOL accessibilityDisplayShouldDifferentiateWithoutColor NS_AVAILABLE_MAC(10_10);

/* Get the current accessibility display option for reduce transparency. If this property's value is true, UI (mainly window) backgrounds should not be semi-transparent; they should be opaque. You may listen for NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification to be notified when this changes. */
@property (readonly) BOOL accessibilityDisplayShouldReduceTransparency NS_AVAILABLE_MAC(10_10);

@end

/* Notification posted to the NSWorkspace notification center when any accessibility display options have changed. */
APPKIT_EXTERN NSString * const NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification NS_AVAILABLE_MAC(10_10);


/*** Accessibility Related Methods ***/

@interface NSObject (NSAccessibilityAdditions)

/* For changing the set of attributes on an instance - as an alternative to sub-classing.
*/
- (BOOL)accessibilitySetOverrideValue:(nullable id)value forAttribute:(NSString *)attribute NS_DEPRECATED_MAC(10_1, 10_10, "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)");

@end

// With a NSView and a relative frame, return the frame in screen coordinates for accessibility
APPKIT_EXTERN NSRect NSAccessibilityFrameInView(NSView *parentView, NSRect frame) NS_AVAILABLE_MAC(10_10);

// With a NSView and a relative point, return the frame in screen coordinates for accessibility
APPKIT_EXTERN NSPoint NSAccessibilityPointInView(NSView *parentView, NSPoint point) NS_AVAILABLE_MAC(10_10);


/* Setting whether the application may have protected content. Protected content is identified by a value of TRUE for the accessibility attribute NSAccessibilityContainsProtectedContentAttribute. If NSAccessibilityMayContainProtectedContent returns NO, then NSAccessibilityContainsProtectedContentAttribute is completely ignored.

    A return value of TRUE indicates success.
 */
APPKIT_EXTERN BOOL NSAccessibilitySetMayContainProtectedContent(BOOL flag);

/* Getting descriptions for standard roles and actions.
*/
APPKIT_EXTERN NSString * __nullable NSAccessibilityRoleDescription(NSString *role, NSString * __nullable subrole);
APPKIT_EXTERN NSString * __nullable NSAccessibilityRoleDescriptionForUIElement(id element);
APPKIT_EXTERN NSString * __nullable NSAccessibilityActionDescription(NSString *action);


/* Error signaling for bad setter value or bad parameter.
*/
APPKIT_EXTERN void NSAccessibilityRaiseBadArgumentException(__null_unspecified id element, NSString * __null_unspecified attribute, __null_unspecified id value) NS_DEPRECATED_MAC(10_1, 10_11, "Exceptions are no longer appropriate for indicating errors in accessibility API. Unexpected values should be handled through appropriate type checking.");


/*** Ignored UIElements Utilities ***/

APPKIT_EXTERN __nullable id NSAccessibilityUnignoredAncestor(id element);
APPKIT_EXTERN __nullable id NSAccessibilityUnignoredDescendant(id element);
APPKIT_EXTERN NSArray *NSAccessibilityUnignoredChildren(NSArray *originalChildren);
APPKIT_EXTERN NSArray *NSAccessibilityUnignoredChildrenForOnlyChild(id originalChild);


/*** Posting Notifications ***/

/* Posts a notification to accessibility client observers.  Note that accessibility notifications are not NSNotifications and do not use the NSNotificationCenter mechanism.  These notifications are received by client processes using the AX API defined in <HIServices/Accessibility.h> including AXUIElement.h.

For all notifications, the observer receives the provided notification string and the AX API representation of the provided element. 

For most notifications, the provided element is checked for observers of the provided notification.

For some notifications, the accessibility parent of the provided element is checked for observers instead.  An example is NSAccessibilityCreatedNotification.  It is impossible for a client to register to observe this notification on a new element, since the element does not exist yet.  So, the function would be called passing in the new element, and the accessibility parent of the element is automatically checked for registered observers.

The following notifications check the accessibility parent of the provided element for observers: NSAccessibilityCreatedNotification, NSAccessibilityWindowCreatedNotification, NSAccessibilityDrawerCreatedNotification, NSAccessibilitySheetCreatedNotification, NSAccessibilityHelpTagCreatedNotification, NSAccessibilityRowExpandedNotification, NSAccessibilityRowCollapsedNotification.

For another set of notifications, the NSApp instance is always the observed element.  An example is NSAccessibilityFocusedUIElementChangedNotification.  The provided element would be the element that now has focus, and the function will automatically check NSApp for registered observers.

The following notifications always check for accessibility observers of NSApp: NSAccessibilityFocusedUIElementChangedNotification, NSAccessibilityFocusedWindowChangedNotification, NSAccessibilityMainWindowChangedNotification.

The rule of thumb is that the affected element should be passed into the function (the newly created element, the newly focused element, the row that was expanded, etc.), and the function will check for observer registrations on the correct element.

*/
APPKIT_EXTERN void NSAccessibilityPostNotification(id element, NSString *notification);

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                    NSAccessibilityConstants.h                                                                          0100644 0001750 0001750 00000111234 12567220725 036116  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSAccessibilityConstants.h
	Application Kit
	Copyright (c) 2001-2015, Apple Inc.
	All rights reserved.
*/
#import <AppKit/AppKitDefines.h>
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/*** Exception Constants ***/

// name for accessibility exception - declared in NSErrors.h
// APPKIT_EXTERN NSString *NSAccessibilityException;

/* userInfo key for error codes in accessibility exceptions
 */
APPKIT_EXTERN NSString *const NSAccessibilityErrorCodeExceptionInfo;


/*** Accessibility Constants ***/

/* Standard attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityRoleAttribute;		//(NSString *) - type, non-localized (e.g. radioButton)
APPKIT_EXTERN NSString *const NSAccessibilityRoleDescriptionAttribute;	//(NSString *) - user readable role (e.g. "radio button")
APPKIT_EXTERN NSString *const NSAccessibilitySubroleAttribute;		//(NSString *) - type, non-localized (e.g. closeButton)
APPKIT_EXTERN NSString *const NSAccessibilityHelpAttribute;		//(NSString *) - instance description (e.g. a tool tip)
APPKIT_EXTERN NSString *const NSAccessibilityValueAttribute;		//(id)         - element's value
APPKIT_EXTERN NSString *const NSAccessibilityMinValueAttribute;		//(id)         - element's min value
APPKIT_EXTERN NSString *const NSAccessibilityMaxValueAttribute;		//(id)         - element's max value
APPKIT_EXTERN NSString *const NSAccessibilityEnabledAttribute;		//(NSNumber *) - (boolValue) responds to user?
APPKIT_EXTERN NSString *const NSAccessibilityFocusedAttribute;		//(NSNumber *) - (boolValue) has keyboard focus?
APPKIT_EXTERN NSString *const NSAccessibilityParentAttribute;		//(id)         - element containing you
APPKIT_EXTERN NSString *const NSAccessibilityChildrenAttribute;		//(NSArray *)  - elements you contain
APPKIT_EXTERN NSString *const NSAccessibilityWindowAttribute;		//(id)         - UIElement for the containing window
APPKIT_EXTERN NSString *const NSAccessibilityTopLevelUIElementAttribute;	//(id)         - UIElement for the containing top level element
APPKIT_EXTERN NSString *const NSAccessibilitySelectedChildrenAttribute;	//(NSArray *)  - child elements which are selected
APPKIT_EXTERN NSString *const NSAccessibilityVisibleChildrenAttribute;	//(NSArray *)  - child elements which are visible
APPKIT_EXTERN NSString *const NSAccessibilityPositionAttribute;		//(NSValue *)  - (pointValue) position in screen coords
APPKIT_EXTERN NSString *const NSAccessibilitySizeAttribute;		//(NSValue *)  - (sizeValue) size
APPKIT_EXTERN NSString *const NSAccessibilityContentsAttribute;		//(NSArray *)  - main elements
APPKIT_EXTERN NSString *const NSAccessibilityTitleAttribute;		//(NSString *) - visible text (e.g. of a push button)
APPKIT_EXTERN NSString *const NSAccessibilityDescriptionAttribute;	//(NSString *) - instance description
APPKIT_EXTERN NSString *const NSAccessibilityShownMenuAttribute;		//(id)         - menu being displayed
APPKIT_EXTERN NSString *const NSAccessibilityValueDescriptionAttribute	//(NSString *)  - text description of value
NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString *const NSAccessibilitySharedFocusElementsAttribute NS_AVAILABLE_MAC(10_10);  //(NSArray *)  - elements that share focus


/* Misc attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityPreviousContentsAttribute;	//(NSArray *)  - main elements
APPKIT_EXTERN NSString *const NSAccessibilityNextContentsAttribute;	//(NSArray *)  - main elements
APPKIT_EXTERN NSString *const NSAccessibilityHeaderAttribute;		//(id)         - UIElement for header.
APPKIT_EXTERN NSString *const NSAccessibilityEditedAttribute;		//(NSNumber *) - (boolValue) is it dirty?
APPKIT_EXTERN NSString *const NSAccessibilityTabsAttribute;		//(NSArray *)  - UIElements for tabs
APPKIT_EXTERN NSString *const NSAccessibilityHorizontalScrollBarAttribute;//(id)       - UIElement for the horizontal scroller
APPKIT_EXTERN NSString *const NSAccessibilityVerticalScrollBarAttribute;//(id)         - UIElement for the vertical scroller
APPKIT_EXTERN NSString *const NSAccessibilityOverflowButtonAttribute;	//(id)         - UIElement for overflow
APPKIT_EXTERN NSString *const NSAccessibilityIncrementButtonAttribute;	//(id)         - UIElement for increment
APPKIT_EXTERN NSString *const NSAccessibilityDecrementButtonAttribute;	//(id)         - UIElement for decrement
APPKIT_EXTERN NSString *const NSAccessibilityFilenameAttribute;		//(NSString *) - filename
APPKIT_EXTERN NSString *const NSAccessibilityExpandedAttribute;		//(NSNumber *) - (boolValue) is expanded?
APPKIT_EXTERN NSString *const NSAccessibilitySelectedAttribute;		//(NSNumber *) - (boolValue) is selected?
APPKIT_EXTERN NSString *const NSAccessibilitySplittersAttribute;	//(NSArray *)  - UIElements for splitters
APPKIT_EXTERN NSString *const NSAccessibilityDocumentAttribute;		//(NSString *) - url as string - for open document
APPKIT_EXTERN NSString *const NSAccessibilityActivationPointAttribute;           //(NSValue *)  - (pointValue)

APPKIT_EXTERN NSString *const NSAccessibilityURLAttribute;		//(NSURL *)    - url
APPKIT_EXTERN NSString *const NSAccessibilityIndexAttribute;		//(NSNumber *)  - (intValue)

APPKIT_EXTERN NSString *const NSAccessibilityRowCountAttribute		//(NSNumber *)  - (intValue) number of rows
NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString *const NSAccessibilityColumnCountAttribute	//(NSNumber *)  - (intValue) number of columns
NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString *const NSAccessibilityOrderedByRowAttribute	//(NSNumber *)  - (boolValue) is ordered by row?
NS_AVAILABLE_MAC(10_5);

APPKIT_EXTERN NSString *const NSAccessibilityWarningValueAttribute	//(id)  - warning value of a level indicator, typically a number
NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityCriticalValueAttribute	//(id)  - critical value of a level indicator, typically a number
NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityPlaceholderValueAttribute	//(NSString *)  - placeholder value of a control such as a text field
NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityContainsProtectedContentAttribute NS_AVAILABLE_MAC(10_9);   // (NSNumber *) - (boolValue) contains protected content?
APPKIT_EXTERN NSString *const NSAccessibilityAlternateUIVisibleAttribute NS_AVAILABLE_MAC(10_10);  //(NSNumber *) - (boolValue)


/* Linkage attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityTitleUIElementAttribute;		//(id)	      - UIElement for the title
APPKIT_EXTERN NSString *const NSAccessibilityServesAsTitleForUIElementsAttribute; //(NSArray *) - UIElements this titles
APPKIT_EXTERN NSString *const NSAccessibilityLinkedUIElementsAttribute;		//(NSArray *) - corresponding UIElements


/* Text-specific attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilitySelectedTextAttribute;		//(NSString *) - selected text
APPKIT_EXTERN NSString *const NSAccessibilitySelectedTextRangeAttribute;	//(NSValue *)  - (rangeValue) range of selected text
APPKIT_EXTERN NSString *const NSAccessibilityNumberOfCharactersAttribute;	//(NSNumber *) - number of characters
APPKIT_EXTERN NSString *const NSAccessibilityVisibleCharacterRangeAttribute;	//(NSValue *)  - (rangeValue) range of visible text
APPKIT_EXTERN NSString *const NSAccessibilitySharedTextUIElementsAttribute;	//(NSArray *)  - text views sharing text
APPKIT_EXTERN NSString *const NSAccessibilitySharedCharacterRangeAttribute;	//(NSValue *)  - (rangeValue) part of shared text in this view
APPKIT_EXTERN NSString *const NSAccessibilityInsertionPointLineNumberAttribute;	//(NSNumber *) - line# containing caret
APPKIT_EXTERN NSString *const NSAccessibilitySelectedTextRangesAttribute	//(NSArray<NSValue *> *) - array of NSValue (rangeValue) ranges of selected text
NS_AVAILABLE_MAC(10_5);


/* Parameterized text-specific attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityLineForIndexParameterizedAttribute;		//(NSNumber *) - line# for char index; param:(NSNumber *)
APPKIT_EXTERN NSString *const NSAccessibilityRangeForLineParameterizedAttribute;		//(NSValue *)  - (rangeValue) range of line; param:(NSNumber *)
APPKIT_EXTERN NSString *const NSAccessibilityStringForRangeParameterizedAttribute;	//(NSString *) - substring; param:(NSValue * - rangeValue)
APPKIT_EXTERN NSString *const NSAccessibilityRangeForPositionParameterizedAttribute;	//(NSValue *)  - (rangeValue) composed char range; param:(NSValue * - pointValue)
APPKIT_EXTERN NSString *const NSAccessibilityRangeForIndexParameterizedAttribute;	//(NSValue *)  - (rangeValue) composed char range; param:(NSNumber *)
APPKIT_EXTERN NSString *const NSAccessibilityBoundsForRangeParameterizedAttribute;	//(NSValue *)  - (rectValue) bounds of text; param:(NSValue * - rangeValue)
APPKIT_EXTERN NSString *const NSAccessibilityRTFForRangeParameterizedAttribute;		//(NSData *)   - rtf for text; param:(NSValue * - rangeValue)
APPKIT_EXTERN NSString *const NSAccessibilityStyleRangeForIndexParameterizedAttribute;	//(NSValue *)  - (rangeValue) extent of style run; param:(NSNumber *)
APPKIT_EXTERN NSString *const NSAccessibilityAttributedStringForRangeParameterizedAttribute; //(NSAttributedString *) - does _not_ use attributes from Appkit/AttributedString.h


/* Text attributed string attributes and constants
 */
APPKIT_EXTERN NSString *const NSAccessibilityFontTextAttribute;			//(NSDictionary *)  - NSAccessibilityFontXXXKey's
APPKIT_EXTERN NSString *const NSAccessibilityForegroundColorTextAttribute;	//CGColorRef
APPKIT_EXTERN NSString *const NSAccessibilityBackgroundColorTextAttribute;	//CGColorRef
APPKIT_EXTERN NSString *const NSAccessibilityUnderlineColorTextAttribute;	//CGColorRef
APPKIT_EXTERN NSString *const NSAccessibilityStrikethroughColorTextAttribute;	//CGColorRef
APPKIT_EXTERN NSString *const NSAccessibilityUnderlineTextAttribute;		//(NSNumber *)	    - underline style
APPKIT_EXTERN NSString *const NSAccessibilitySuperscriptTextAttribute;		//(NSNumber *)	    - superscript>0, subscript<0
APPKIT_EXTERN NSString *const NSAccessibilityStrikethroughTextAttribute;		//(NSNumber *)	    - (boolValue)
APPKIT_EXTERN NSString *const NSAccessibilityShadowTextAttribute;		//(NSNumber *)	    - (boolValue)
APPKIT_EXTERN NSString *const NSAccessibilityAttachmentTextAttribute;		//id - corresponding element
APPKIT_EXTERN NSString *const NSAccessibilityLinkTextAttribute;			//id - corresponding element
APPKIT_EXTERN NSString *const NSAccessibilityAutocorrectedTextAttribute NS_AVAILABLE_MAC(10_7);		//(NSNumber *)	    - (boolValue)

/* Textual list attributes and constants. Examples: unordered or ordered lists in a document.
 */
APPKIT_EXTERN NSString *const NSAccessibilityListItemPrefixTextAttribute    NS_AVAILABLE_MAC(10_11);    // NSAttributedString, the prepended string of the list item. If the string is a common unicode character (e.g. a bullet ), return that unicode character. For lists with images before the text, return a reasonable label of the image.
APPKIT_EXTERN NSString *const NSAccessibilityListItemIndexTextAttribute     NS_AVAILABLE_MAC(10_11);    // NSNumber, integerValue of the line index. Each list item increments the index, even for unordered lists. The first item should have index 0.
APPKIT_EXTERN NSString *const NSAccessibilityListItemLevelTextAttribute     NS_AVAILABLE_MAC(10_11);    // NSNumber, integerValue of the indent level. Each sublist increments the level. The first item should have level 0.

/*
 About MisspelledText attributes for attribute strings:
 
 NSAccessibilityMisspelledTextAttribute was the original attribute to indicate misspelled text. In OS X 10.4, the Cocoa text system added support for NSAccessibilityMarkedMisspelledTextAttribute, which was used to indicate a word that was visibly marked as misspelled (for example, with a red squiggle underneath); the original MisspelledText attribute could also be used on text that was not visibly marked as mispelled (for example, a misspelled word that was currently being edited by the user).
 
 Typically, a screen reader only wants to vocalize what a sighted user could see, and so the MarkedMisspelledText attribute was adopted by VoiceOver to provide feedback to the user about misspelled text. In OS X 10.9, VoiceOver has entirely stopped using the original MisspelledText attribute, and now only checks for MarkedMisspelledText.
 
 When implementing accessibility for a custom text-editing engine, you should generally provide the MarkedMisspelledText attribute in order to support VoiceOver, especially in OS X 10.9 and later. You may optionally also support the MisspelledText attribute for compatibility with other accessibility clients.
 */
APPKIT_EXTERN NSString *const NSAccessibilityMisspelledTextAttribute;		//(NSNumber *)	    - (boolValue)
APPKIT_EXTERN NSString *const NSAccessibilityMarkedMisspelledTextAttribute NS_AVAILABLE_MAC(10_4);	//(NSNumber *) - (boolValue)

APPKIT_EXTERN NSString *const NSAccessibilityFontNameKey;	// required
APPKIT_EXTERN NSString *const NSAccessibilityFontFamilyKey;	// optional
APPKIT_EXTERN NSString *const NSAccessibilityVisibleNameKey;	// optional
APPKIT_EXTERN NSString *const NSAccessibilityFontSizeKey;	// required


/* Window-specific attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityMainAttribute;		//(NSNumber *) - (boolValue) is it the main window?
APPKIT_EXTERN NSString *const NSAccessibilityMinimizedAttribute;	//(NSNumber *) - (boolValue) is window minimized?
APPKIT_EXTERN NSString *const NSAccessibilityCloseButtonAttribute;	//(id) - UIElement for close box (or nil)
APPKIT_EXTERN NSString *const NSAccessibilityZoomButtonAttribute;	//(id) - UIElement for zoom box (or nil)
APPKIT_EXTERN NSString *const NSAccessibilityMinimizeButtonAttribute;	//(id) - UIElement for miniaturize box (or nil)
APPKIT_EXTERN NSString *const NSAccessibilityToolbarButtonAttribute;	//(id) - UIElement for toolbar box (or nil)
APPKIT_EXTERN NSString *const NSAccessibilityProxyAttribute;		//(id) - UIElement for title's icon (or nil)
APPKIT_EXTERN NSString *const NSAccessibilityGrowAreaAttribute;		//(id) - UIElement for grow box (or nil)
APPKIT_EXTERN NSString *const NSAccessibilityModalAttribute;		//(NSNumber *) - (boolValue) is the window modal
APPKIT_EXTERN NSString *const NSAccessibilityDefaultButtonAttribute;	//(id) - UIElement for default button
APPKIT_EXTERN NSString *const NSAccessibilityCancelButtonAttribute;	//(id) - UIElement for cancel button
APPKIT_EXTERN NSString *const NSAccessibilityFullScreenButtonAttribute NS_AVAILABLE_MAC(10_7); //(id) - UIElement for full screen button (or nil)

/* Application-specific attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityMenuBarAttribute;		//(id)         - UIElement for the menu bar
APPKIT_EXTERN NSString *const NSAccessibilityWindowsAttribute;		//(NSArray *)  - UIElements for the windows
APPKIT_EXTERN NSString *const NSAccessibilityFrontmostAttribute;	//(NSNumber *) - (boolValue) is the app active?
APPKIT_EXTERN NSString *const NSAccessibilityHiddenAttribute;		//(NSNumber *) - (boolValue) is the app hidden?
APPKIT_EXTERN NSString *const NSAccessibilityMainWindowAttribute;	//(id)         - UIElement for the main window.
APPKIT_EXTERN NSString *const NSAccessibilityFocusedWindowAttribute;	//(id)         - UIElement for the key window.
APPKIT_EXTERN NSString *const NSAccessibilityFocusedUIElementAttribute;	//(id)         - Currently focused UIElement.
APPKIT_EXTERN NSString *const NSAccessibilityExtrasMenuBarAttribute NS_AVAILABLE_MAC(10_8);    //(id)         - UIElement for the application extras menu bar.

typedef NS_ENUM(NSInteger, NSAccessibilityOrientation) {
    NSAccessibilityOrientationUnknown = 0,
    NSAccessibilityOrientationVertical = 1,
    NSAccessibilityOrientationHorizontal = 2,
} NS_ENUM_AVAILABLE_MAC(10_10);

APPKIT_EXTERN NSString *const NSAccessibilityOrientationAttribute;	//(NSString *) - NSAccessibilityXXXOrientationValue
APPKIT_EXTERN NSString *const NSAccessibilityVerticalOrientationValue;
APPKIT_EXTERN NSString *const NSAccessibilityHorizontalOrientationValue;
APPKIT_EXTERN NSString *const NSAccessibilityUnknownOrientationValue;


APPKIT_EXTERN NSString *const NSAccessibilityColumnTitlesAttribute;	//(NSArray *)  - UIElements for titles

APPKIT_EXTERN NSString *const NSAccessibilitySearchButtonAttribute;	//(id)         - UIElement for search field search btn
APPKIT_EXTERN NSString *const NSAccessibilitySearchMenuAttribute;	//(id)         - UIElement for search field menu
APPKIT_EXTERN NSString *const NSAccessibilityClearButtonAttribute;	//(id)         - UIElement for search field clear btn


/* Table/outline view attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityRowsAttribute;		//(NSArray *)  - UIElements for rows
APPKIT_EXTERN NSString *const NSAccessibilityVisibleRowsAttribute;	//(NSArray *)  - UIElements for visible rows
APPKIT_EXTERN NSString *const NSAccessibilitySelectedRowsAttribute;	//(NSArray *)  - UIElements for selected rows
APPKIT_EXTERN NSString *const NSAccessibilityColumnsAttribute;		//(NSArray *)  - UIElements for columns
APPKIT_EXTERN NSString *const NSAccessibilityVisibleColumnsAttribute;	//(NSArray *)  - UIElements for visible columns
APPKIT_EXTERN NSString *const NSAccessibilitySelectedColumnsAttribute;	//(NSArray *)  - UIElements for selected columns
APPKIT_EXTERN NSString *const NSAccessibilitySortDirectionAttribute;	//(NSString *) - see sort direction values below

/* Cell-based table attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilitySelectedCellsAttribute NS_AVAILABLE_MAC(10_6);	//(NSArray *)  - UIElements for selected cells
APPKIT_EXTERN NSString *const NSAccessibilityVisibleCellsAttribute NS_AVAILABLE_MAC(10_6);	//(NSArray *)  - UIElements for visible cells
APPKIT_EXTERN NSString *const NSAccessibilityRowHeaderUIElementsAttribute NS_AVAILABLE_MAC(10_6);	//(NSArray *)  - UIElements for row headers
APPKIT_EXTERN NSString *const NSAccessibilityColumnHeaderUIElementsAttribute NS_AVAILABLE_MAC(10_6);	//(NSArray *)  - UIElements for column headers

/* Cell-based table parameterized attributes.  The parameter for this attribute is an NSArray containing two NSNumbers, the first NSNumber specifies the column index, the second NSNumber specifies the row index.
 */
APPKIT_EXTERN NSString *const NSAccessibilityCellForColumnAndRowParameterizedAttribute NS_AVAILABLE_MAC(10_6);  // (id) - UIElement for cell at specified row and column

/* Cell attributes.  The index range contains both the starting index, and the index span in a table.
 */
APPKIT_EXTERN NSString *const NSAccessibilityRowIndexRangeAttribute NS_AVAILABLE_MAC(10_6);	//(NSValue *)  - (rangeValue) location and row span
APPKIT_EXTERN NSString *const NSAccessibilityColumnIndexRangeAttribute NS_AVAILABLE_MAC(10_6);   //(NSValue *)  - (rangeValue) location and column span

/* Layout area attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityHorizontalUnitsAttribute NS_AVAILABLE_MAC(10_6);   //(NSString *) - see ruler unit values below
APPKIT_EXTERN NSString *const NSAccessibilityVerticalUnitsAttribute NS_AVAILABLE_MAC(10_6);	    //(NSString *) - see ruler unit values below
APPKIT_EXTERN NSString *const NSAccessibilityHorizontalUnitDescriptionAttribute NS_AVAILABLE_MAC(10_6); //(NSString *)
APPKIT_EXTERN NSString *const NSAccessibilityVerticalUnitDescriptionAttribute NS_AVAILABLE_MAC(10_6);    //(NSString *)

/* Layout area parameterized attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityLayoutPointForScreenPointParameterizedAttribute NS_AVAILABLE_MAC(10_6); //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
APPKIT_EXTERN NSString *const NSAccessibilityLayoutSizeForScreenSizeParameterizedAttribute NS_AVAILABLE_MAC(10_6); //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)
APPKIT_EXTERN NSString *const NSAccessibilityScreenPointForLayoutPointParameterizedAttribute NS_AVAILABLE_MAC(10_6); //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
APPKIT_EXTERN NSString *const NSAccessibilityScreenSizeForLayoutSizeParameterizedAttribute NS_AVAILABLE_MAC(10_6); //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)

/* Layout item attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityHandlesAttribute NS_AVAILABLE_MAC(10_6); //(NSArray *)  - UIElements for handles

/* Sort direction values
 */
APPKIT_EXTERN NSString *const NSAccessibilityAscendingSortDirectionValue;
APPKIT_EXTERN NSString *const NSAccessibilityDescendingSortDirectionValue;
APPKIT_EXTERN NSString *const NSAccessibilityUnknownSortDirectionValue;

typedef NS_ENUM(NSInteger, NSAccessibilitySortDirection) {
    NSAccessibilitySortDirectionUnknown = 0,
    NSAccessibilitySortDirectionAscending = 1,
    NSAccessibilitySortDirectionDescending = 2,
} NS_ENUM_AVAILABLE_MAC(10_10);

/* Outline attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityDisclosingAttribute;	//(NSNumber *) - (boolValue) is disclosing rows?
APPKIT_EXTERN NSString *const NSAccessibilityDisclosedRowsAttribute;	//(NSArray *)  - UIElements for disclosed rows
APPKIT_EXTERN NSString *const NSAccessibilityDisclosedByRowAttribute;	//(id)         - UIElement for disclosing row
APPKIT_EXTERN NSString *const NSAccessibilityDisclosureLevelAttribute;	//(NSNumber *) - indentation level

/* Slider attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityAllowedValuesAttribute;	//(NSArray<NSNumber *> *) - array of allowed values
APPKIT_EXTERN NSString *const NSAccessibilityLabelUIElementsAttribute;	//(NSArray *) - array of label UIElements
APPKIT_EXTERN NSString *const NSAccessibilityLabelValueAttribute;	//(NSNumber *) - value of a label UIElement

/* Matte attributes
 */
// Attributes no longer supported
APPKIT_EXTERN NSString *const NSAccessibilityMatteHoleAttribute NS_DEPRECATED_MAC(10_1, 10_10);		//(NSValue *) - (rect value) bounds of matte hole in screen coords
APPKIT_EXTERN NSString *const NSAccessibilityMatteContentUIElementAttribute NS_DEPRECATED_MAC(10_1, 10_10); //(id) - UIElement clipped by the matte

/* Ruler view attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityMarkerUIElementsAttribute;		//(NSArray *)
APPKIT_EXTERN NSString *const NSAccessibilityMarkerValuesAttribute;		//
APPKIT_EXTERN NSString *const NSAccessibilityMarkerGroupUIElementAttribute;	//(id)
APPKIT_EXTERN NSString *const NSAccessibilityUnitsAttribute;			//(NSString *) - see ruler unit values below
APPKIT_EXTERN NSString *const NSAccessibilityUnitDescriptionAttribute;		//(NSString *)
APPKIT_EXTERN NSString *const NSAccessibilityMarkerTypeAttribute;		//(NSString *) - see ruler marker type values below
APPKIT_EXTERN NSString *const NSAccessibilityMarkerTypeDescriptionAttribute;	//(NSString *)

/* UI element identification attributes
 */
APPKIT_EXTERN NSString *const NSAccessibilityIdentifierAttribute		//(NSString *)
NS_AVAILABLE_MAC(10_7);

/* Ruler marker type values
 */
APPKIT_EXTERN NSString *const NSAccessibilityLeftTabStopMarkerTypeValue;
APPKIT_EXTERN NSString *const NSAccessibilityRightTabStopMarkerTypeValue;
APPKIT_EXTERN NSString *const NSAccessibilityCenterTabStopMarkerTypeValue;
APPKIT_EXTERN NSString *const NSAccessibilityDecimalTabStopMarkerTypeValue;
APPKIT_EXTERN NSString *const NSAccessibilityHeadIndentMarkerTypeValue;
APPKIT_EXTERN NSString *const NSAccessibilityTailIndentMarkerTypeValue;
APPKIT_EXTERN NSString *const NSAccessibilityFirstLineIndentMarkerTypeValue;
APPKIT_EXTERN NSString *const NSAccessibilityUnknownMarkerTypeValue;

typedef NS_ENUM(NSInteger, NSAccessibilityRulerMarkerType) {
    NSAccessibilityRulerMarkerTypeUnknown = 0,
    NSAccessibilityRulerMarkerTypeTabStopLeft = 1,
    NSAccessibilityRulerMarkerTypeTabStopRight = 2,
    NSAccessibilityRulerMarkerTypeTabStopCenter = 3,
    NSAccessibilityRulerMarkerTypeTabStopDecimal = 4,
    NSAccessibilityRulerMarkerTypeIndentHead = 5,
    NSAccessibilityRulerMarkerTypeIndentTail = 6,
    NSAccessibilityRulerMarkerTypeIndentFirstLine = 7
} NS_ENUM_AVAILABLE_MAC(10_10);

/* Ruler unit values
 */
APPKIT_EXTERN NSString *const NSAccessibilityInchesUnitValue;
APPKIT_EXTERN NSString *const NSAccessibilityCentimetersUnitValue;
APPKIT_EXTERN NSString *const NSAccessibilityPointsUnitValue;
APPKIT_EXTERN NSString *const NSAccessibilityPicasUnitValue;
APPKIT_EXTERN NSString *const NSAccessibilityUnknownUnitValue;

typedef NS_ENUM(NSInteger, NSAccessibilityUnits) {
    NSAccessibilityUnitsUnknown = 0,
    NSAccessibilityUnitsInches = 1,
    NSAccessibilityUnitsCentimeters = 2,
    NSAccessibilityUnitsPoints = 3,
    NSAccessibilityUnitsPicas = 4
} NS_ENUM_AVAILABLE_MAC(10_10);

/* Actions
 */
APPKIT_EXTERN NSString *const NSAccessibilityPressAction;
APPKIT_EXTERN NSString *const NSAccessibilityIncrementAction;
APPKIT_EXTERN NSString *const NSAccessibilityDecrementAction;
APPKIT_EXTERN NSString *const NSAccessibilityConfirmAction;
APPKIT_EXTERN NSString *const NSAccessibilityPickAction;
APPKIT_EXTERN NSString *const NSAccessibilityCancelAction;
APPKIT_EXTERN NSString *const NSAccessibilityRaiseAction;
APPKIT_EXTERN NSString *const NSAccessibilityShowMenuAction;
APPKIT_EXTERN NSString *const NSAccessibilityDeleteAction;

/* Actions that allow the developer to present either alternative or original UI. There may be new UI elements that appear. There may be UI elements that disappear. There may be changes to existing UI elements. Or a combination of them. Currently this is typically seen during a mouse hovering event.
 */
APPKIT_EXTERN NSString *const NSAccessibilityShowAlternateUIAction	NS_AVAILABLE_MAC(10_9);
APPKIT_EXTERN NSString *const NSAccessibilityShowDefaultUIAction	NS_AVAILABLE_MAC(10_9);

/* Focus notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilityMainWindowChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityFocusedWindowChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityFocusedUIElementChangedNotification;

/* Application notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilityApplicationActivatedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityApplicationDeactivatedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityApplicationHiddenNotification;
APPKIT_EXTERN NSString *const NSAccessibilityApplicationShownNotification;

/* Window notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilityWindowCreatedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityWindowMovedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityWindowResizedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityWindowMiniaturizedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityWindowDeminiaturizedNotification;

/* Drawer & sheet notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilityDrawerCreatedNotification;
APPKIT_EXTERN NSString *const NSAccessibilitySheetCreatedNotification;

/* Element notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilityUIElementDestroyedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityValueChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityTitleChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityResizedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityMovedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityCreatedNotification;

/* Used when UI changes require the attention of assistive application.  Pass along a user info dictionary with the key NSAccessibilityUIElementsKey and an array of elements that have been added or changed as a result of this layout change.
 */
APPKIT_EXTERN NSString *const NSAccessibilityLayoutChangedNotification	NS_AVAILABLE_MAC(10_9);

/* Misc notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilityHelpTagCreatedNotification;
APPKIT_EXTERN NSString *const NSAccessibilitySelectedTextChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilityRowCountChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilitySelectedChildrenChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilitySelectedRowsChangedNotification;
APPKIT_EXTERN NSString *const NSAccessibilitySelectedColumnsChangedNotification;

APPKIT_EXTERN NSString *const NSAccessibilityRowExpandedNotification		NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityRowCollapsedNotification		NS_AVAILABLE_MAC(10_6);

/* Cell-table notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilitySelectedCellsChangedNotification NS_AVAILABLE_MAC(10_6);

/* Layout area notifications
 */
APPKIT_EXTERN NSString *const NSAccessibilityUnitsChangedNotification NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilitySelectedChildrenMovedNotification NS_AVAILABLE_MAC(10_6);

/* This notification allows an application to request that an announcement be made to the user by an assistive application such as VoiceOver.  The notification requires a user info dictionary with the key NSAccessibilityAnnouncementKey and the announcement as a localized string.  In addition, the key NSAccessibilityAnnouncementPriorityKey should also be used to help an assistive application determine the importance of this announcement.  This notification should be posted for the application element.
 */
APPKIT_EXTERN NSString *const NSAccessibilityAnnouncementRequestedNotification NS_AVAILABLE_MAC(10_7);


/* Roles
 */
APPKIT_EXTERN NSString *const NSAccessibilityUnknownRole;
APPKIT_EXTERN NSString *const NSAccessibilityButtonRole;
APPKIT_EXTERN NSString *const NSAccessibilityRadioButtonRole;
APPKIT_EXTERN NSString *const NSAccessibilityCheckBoxRole;
APPKIT_EXTERN NSString *const NSAccessibilitySliderRole;
APPKIT_EXTERN NSString *const NSAccessibilityTabGroupRole;
APPKIT_EXTERN NSString *const NSAccessibilityTextFieldRole;
APPKIT_EXTERN NSString *const NSAccessibilityStaticTextRole;
APPKIT_EXTERN NSString *const NSAccessibilityTextAreaRole;
APPKIT_EXTERN NSString *const NSAccessibilityScrollAreaRole;
APPKIT_EXTERN NSString *const NSAccessibilityPopUpButtonRole;
APPKIT_EXTERN NSString *const NSAccessibilityMenuButtonRole;
APPKIT_EXTERN NSString *const NSAccessibilityTableRole;
APPKIT_EXTERN NSString *const NSAccessibilityApplicationRole;
APPKIT_EXTERN NSString *const NSAccessibilityGroupRole;
APPKIT_EXTERN NSString *const NSAccessibilityRadioGroupRole;
APPKIT_EXTERN NSString *const NSAccessibilityListRole;
APPKIT_EXTERN NSString *const NSAccessibilityScrollBarRole;
APPKIT_EXTERN NSString *const NSAccessibilityValueIndicatorRole;
APPKIT_EXTERN NSString *const NSAccessibilityImageRole;
APPKIT_EXTERN NSString *const NSAccessibilityMenuBarRole;
APPKIT_EXTERN NSString *const NSAccessibilityMenuRole;
APPKIT_EXTERN NSString *const NSAccessibilityMenuItemRole;
APPKIT_EXTERN NSString *const NSAccessibilityColumnRole;
APPKIT_EXTERN NSString *const NSAccessibilityRowRole;
APPKIT_EXTERN NSString *const NSAccessibilityToolbarRole;
APPKIT_EXTERN NSString *const NSAccessibilityBusyIndicatorRole;
APPKIT_EXTERN NSString *const NSAccessibilityProgressIndicatorRole;
APPKIT_EXTERN NSString *const NSAccessibilityWindowRole;
APPKIT_EXTERN NSString *const NSAccessibilityDrawerRole;
APPKIT_EXTERN NSString *const NSAccessibilitySystemWideRole;
APPKIT_EXTERN NSString *const NSAccessibilityOutlineRole;
APPKIT_EXTERN NSString *const NSAccessibilityIncrementorRole;
APPKIT_EXTERN NSString *const NSAccessibilityBrowserRole;
APPKIT_EXTERN NSString *const NSAccessibilityComboBoxRole;
APPKIT_EXTERN NSString *const NSAccessibilitySplitGroupRole;
APPKIT_EXTERN NSString *const NSAccessibilitySplitterRole;
APPKIT_EXTERN NSString *const NSAccessibilityColorWellRole;
APPKIT_EXTERN NSString *const NSAccessibilityGrowAreaRole;
APPKIT_EXTERN NSString *const NSAccessibilitySheetRole;
APPKIT_EXTERN NSString *const NSAccessibilityHelpTagRole;
APPKIT_EXTERN NSString *const NSAccessibilityMatteRole;
APPKIT_EXTERN NSString *const NSAccessibilityRulerRole;
APPKIT_EXTERN NSString *const NSAccessibilityRulerMarkerRole;
APPKIT_EXTERN NSString *const NSAccessibilityLinkRole;
APPKIT_EXTERN NSString *const NSAccessibilityDisclosureTriangleRole NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString *const NSAccessibilityGridRole		NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString *const NSAccessibilityRelevanceIndicatorRole;
APPKIT_EXTERN NSString *const NSAccessibilityLevelIndicatorRole NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityCellRole NS_AVAILABLE_MAC(10_6); // As found in a cell-based table
APPKIT_EXTERN NSString *const NSAccessibilityPopoverRole NS_AVAILABLE_MAC(10_7);

/* Layout-area roles
 */
APPKIT_EXTERN NSString *const NSAccessibilityLayoutAreaRole NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityLayoutItemRole NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityHandleRole NS_AVAILABLE_MAC(10_6);


/* Subroles
 */
APPKIT_EXTERN NSString *const NSAccessibilityUnknownSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityCloseButtonSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityZoomButtonSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityMinimizeButtonSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityToolbarButtonSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityTableRowSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityOutlineRowSubrole;
APPKIT_EXTERN NSString *const NSAccessibilitySecureTextFieldSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityStandardWindowSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityDialogSubrole;
APPKIT_EXTERN NSString *const NSAccessibilitySystemDialogSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityFloatingWindowSubrole;
APPKIT_EXTERN NSString *const NSAccessibilitySystemFloatingWindowSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityIncrementArrowSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityDecrementArrowSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityIncrementPageSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityDecrementPageSubrole;
APPKIT_EXTERN NSString *const NSAccessibilitySearchFieldSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityTextAttachmentSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityTextLinkSubrole;
APPKIT_EXTERN NSString *const NSAccessibilityTimelineSubrole			NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString *const NSAccessibilitySortButtonSubrole			NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityRatingIndicatorSubrole		NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityContentListSubrole			NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityDefinitionListSubrole		NS_AVAILABLE_MAC(10_6);
APPKIT_EXTERN NSString *const NSAccessibilityFullScreenButtonSubrole		NS_AVAILABLE_MAC(10_7);
APPKIT_EXTERN NSString *const NSAccessibilityToggleSubrole                      NS_AVAILABLE_MAC(10_9);
APPKIT_EXTERN NSString *const NSAccessibilitySwitchSubrole                      NS_AVAILABLE_MAC(10_9);
APPKIT_EXTERN NSString *const NSAccessibilityDescriptionListSubrole		NS_AVAILABLE_MAC(10_9);



/* This function allows an accessibility notification to be posted with a user info dictionary.  The user info dictionary can be nil.  Valid contents of the user info dictionary are limited to classes which can be returned to an accessibility client.  That list currently includes NSString, NSNumber, NSArray, NSValues of points, ranges, sizes, rects, and valid NSAccessibility objects.  Most accessibility notifications do not require a user info dictionary.
 */
APPKIT_EXTERN void NSAccessibilityPostNotificationWithUserInfo(id element, NSString *notification, NSDictionary *userInfo) NS_AVAILABLE_MAC(10_7);


/* Below are keys used for the user info dictionary of the NSAccessibilityPostNotificationWithUserInfo API */

/* Key used in the user info dictionary for notifications.  The value is an array of elements that is associated with the notification.  For example, a NSAccessibilityLayoutChangedNotification should include an array of elements that have been added/changed using this key.
 */
APPKIT_EXTERN NSString *const NSAccessibilityUIElementsKey		NS_AVAILABLE_MAC(10_9);

/* Key used in the user info dictionary for any relevant notification.  This gives the assistive application client an opportunity to determine how to handle the corresponding notification based on the priority.  For example, a developer should pass the priority key for NSAccessibilityAnnouncementRequestedNotification.  Then clients such as VoiceOver can decide to speak the announcement immediately or after the current speech is completed based on the priority level.  This key is required for NSAccessibilityAnnouncementRequestedNotification.  The NSAccessibilityLayoutChangedNotification is another example where priority can help assistive applications determine how to handle the UI change.
 */
APPKIT_EXTERN NSString *const NSAccessibilityPriorityKey		NS_AVAILABLE_MAC(10_9);

/* Key used in the user info dictionary sent with the NSAccessibilityAnnouncementRequestedNotification.  The value for the announcement should be a localized string.  This should generally be used in conjunction with the NSAccessibilityPriorityKey to help assistive applications determine the importance of this announcement.
 */
APPKIT_EXTERN NSString *const NSAccessibilityAnnouncementKey            NS_AVAILABLE_MAC(10_7);


/* System defined priority levels.  This priority level should be included for every NSAccessibilityAnnouncementRequestedNotification.
 */
typedef NS_ENUM(NSInteger, NSAccessibilityPriorityLevel) {
    NSAccessibilityPriorityLow = 10,
    NSAccessibilityPriorityMedium = 50,
    NSAccessibilityPriorityHigh = 90
} NS_ENUM_AVAILABLE_MAC(10_9);


/* Deprecated
 */
APPKIT_EXTERN NSString *const NSAccessibilitySortButtonRole	NS_DEPRECATED_MAC(10_4, 10_6);

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                    NSAccessibilityElement.h                                                                            0100644 0001750 0001750 00000002133 12567220725 035530  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSAccessibilityElement.h
	Application Kit
	Copyright (c) 2013-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/Foundation.h>
#import <AppKit/NSAccessibility.h>

/* An NSAccessibilityElement is used to convey information regarding onscreen UI through the  accessibility API for UI that may not already have a single backing object. For example, if a single NSView subclass draws 4 buttons, it would vend 4 NSAccessibilityElements as accessibilityChildren. Note that as long as the UI is around, the vendor of NSAccessibilityElements must maintain ownership of the NSAccessibilityElements. */

NS_ASSUME_NONNULL_BEGIN

NS_CLASS_AVAILABLE(10_10, NA)
@interface NSAccessibilityElement : NSObject <NSAccessibility>
{
    id _private;
}

+ (id)accessibilityElementWithRole:(NSString *)role frame:(NSRect)frame label:(nullable NSString *)label parent:(nullable id)parent;
- (void)accessibilityAddChildElement:(NSAccessibilityElement *)childElement;

// Accessibility frame in the cordinate system of the accessibility parent
@property NSRect accessibilityFrameInParentSpace;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                     NSAccessibilityProtocols.h                                                                          0100644 0001750 0001750 00000103076 12567220725 036133  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
 NSAccessibilityProtocols.h
 Application Kit
 Copyright (c) 2013-2015, Apple Inc.
 All rights reserved.
 */

#import <Foundation/Foundation.h>
#import <AppKit/NSAccessibilityConstants.h>


NS_ASSUME_NONNULL_BEGIN

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityElement <NSObject>
@required
- (NSRect)accessibilityFrame;
- (nullable id)accessibilityParent;

@optional
- (BOOL)isAccessibilityFocused;
- (NSString *)accessibilityIdentifier;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityGroup <NSAccessibilityElement>
@end

#pragma mark Buttons

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityButton <NSAccessibilityElement>
@required
- (nullable NSString *)accessibilityLabel;
- (BOOL)accessibilityPerformPress;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilitySwitch <NSAccessibilityButton>
// Post NSAccessibilityValueChangedNotification when the value changes

@required
- (nullable NSString *)accessibilityValue;

@optional
- (BOOL)accessibilityPerformIncrement;
- (BOOL)accessibilityPerformDecrement;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityRadioButton <NSAccessibilityButton>
// NSAccessibilityValueChangedNotification should be posted whenever accessibilityValue changes

@required
// Return @YES if selected, or @NO if not selected
- (nullable NSNumber *)accessibilityValue;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityCheckBox <NSAccessibilityButton>
// NSAccessibilityValueChangedNotification should be posted whenever accessibilityValue changes

@required
// Return @YES if checked, or @NO if unchecked
- (nullable NSNumber *)accessibilityValue;
@end

#pragma mark Text
NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityStaticText <NSAccessibilityElement>
@required
- (nullable NSString *)accessibilityValue;

@optional
- (nullable NSAttributedString *)accessibilityAttributedStringForRange:(NSRange)range;
- (NSRange)accessibilityVisibleCharacterRange;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityNavigableStaticText <NSAccessibilityStaticText>
@required
- (nullable NSString *)accessibilityStringForRange:(NSRange)range;
- (NSInteger)accessibilityLineForIndex:(NSInteger)index;
- (NSRange)accessibilityRangeForLine:(NSInteger)lineNumber;

// Frame is in screen coordinates. See NSAccessibilityFrameInView()
- (NSRect)accessibilityFrameForRange:(NSRange)range;
@end

#pragma mark Miscellaneous
NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityProgressIndicator <NSAccessibilityGroup>
@required
- (nullable NSNumber *)accessibilityValue;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityStepper <NSAccessibilityElement>
@required
- (nullable NSString *)accessibilityLabel;
- (BOOL)accessibilityPerformIncrement;
- (BOOL)accessibilityPerformDecrement;
@optional
// Value is a NSString or a NSNumber
- (nullable id)accessibilityValue;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilitySlider <NSAccessibilityElement>
@required
- (nullable NSString *)accessibilityLabel;
// Value is a NSString or a NSNumber
- (nullable id)accessibilityValue;
- (BOOL)accessibilityPerformIncrement;
- (BOOL)accessibilityPerformDecrement;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityImage <NSAccessibilityElement>
@required
- (nullable NSString *)accessibilityLabel;
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityContainsTransientUI <NSAccessibilityElement>
@required
- (BOOL)accessibilityPerformShowAlternateUI;
- (BOOL)accessibilityPerformShowDefaultUI;
- (BOOL)isAccessibilityAlternateUIVisible;
@end

@protocol NSAccessibilityRow;

#pragma mark Tables, Lists, Outlines
NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityTable <NSAccessibilityGroup>
@required
- (nullable NSString *)accessibilityLabel;

// An array of accessibility row elements
- (nullable NSArray<id<NSAccessibilityRow>> *)accessibilityRows;

@optional
// For tables that have a selection
// Make sure to post a selected-rows-changed notification when appropriate
// NSAccessibilityPostNotification(table, NSAccessibilitySelectedRowsChangedNotification);
- (nullable NSArray<id<NSAccessibilityRow>> *)accessibilitySelectedRows;
- (void)setAccessibilitySelectedRows:(NSArray<id<NSAccessibilityRow>> *)selectedRows;

// Advanced table accessibility
- (nullable NSArray<id<NSAccessibilityRow>> *)accessibilityVisibleRows;
- (nullable NSArray *)accessibilityColumns;
- (nullable NSArray *)accessibilityVisibleColumns;
- (nullable NSArray *)accessibilitySelectedColumns;
- (nullable NSString *)accessibilityHeaderGroup;
- (nullable NSArray *)accessibilitySelectedCells;
- (nullable NSArray *)accessibilityVisibleCells;
- (nullable NSArray *)accessibilityRowHeaderUIElements;
- (nullable NSArray *)accessibilityColumnHeaderUIElements;

@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityOutline <NSAccessibilityTable>
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityList <NSAccessibilityTable>
@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityRow <NSAccessibilityGroup>
@required
- (NSInteger)accessibilityIndex;

@optional
- (NSInteger)accessibilityDisclosureLevel;
@end

#pragma mark Layout Area (Canvas)
NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityLayoutArea <NSAccessibilityGroup>
@required
- (NSString *)accessibilityLabel;
// All of the layoutItem children
- (nullable NSArray *)accessibilityChildren;

// Selected layoutItem children
- (nullable NSArray *)accessibilitySelectedChildren;

// The focused layoutItem
- (id)accessibilityFocusedUIElement;

@end

NS_PROTOCOL_REQUIRES_EXPLICIT_IMPLEMENTATION
@protocol NSAccessibilityLayoutItem <NSAccessibilityGroup>

@optional
// For layout items that can be moved
- (void)setAccessibilityFrame:(NSRect)frame;

@end


// The complete accessibility protocol
@protocol NSAccessibility <NSObject>
@required

#pragma mark General
// Return YES if the UIElement should be exposed
@property (getter = isAccessibilityElement) BOOL accessibilityElement NS_AVAILABLE_MAC(10_10);

// The frame of the UIElement in screen coordinates. See NSAccessibilityFrameInView()
// Invokes when clients request NSAccessibilitySizeAttribute or NSAccessibilityPositionAttribute
@property NSRect accessibilityFrame NS_AVAILABLE_MAC(10_10);

// Returns YES if the element is focused (generally, accessibilityFocused is equivilent to the
// UIElement with the focus ring or selection)
// Invokes when clients request NSAccessibilityFocusedAttribute
@property (getter = isAccessibilityFocused) BOOL accessibilityFocused NS_AVAILABLE_MAC(10_10);

// Activation point for the UIElement, in screen coordinates. See NSAccessibilityPointInView()
@property NSPoint accessibilityActivationPoint NS_AVAILABLE_MAC(10_10);

// UIElement for the containing top level element
// Invokes when clients request NSAccessibilityTopLevelUIElementAttribute
@property (nullable, weak) id accessibilityTopLevelUIElement NS_AVAILABLE_MAC(10_10);

// URL of the UIElement
// Invokes when clients request NSAccessibilityURLAttribute
@property (nullable, copy) NSURL *accessibilityURL NS_AVAILABLE_MAC(10_10);

// Value of the UIElement
// Invokes when clients request NSAccessibilityValueAttribute
@property (nullable, strong) id accessibilityValue NS_AVAILABLE_MAC(10_10);

// Human-readable description of value
// Invokes when clients request NSAccessibilityValueDescriptionAttribute
@property (nullable, copy) NSString *accessibilityValueDescription NS_AVAILABLE_MAC(10_10);

// Array of child UIElement which are visible
// Invokes when clients request NSAccessibilityVisibleChildrenAttribute
@property (nullable, copy) NSArray *accessibilityVisibleChildren NS_AVAILABLE_MAC(10_10);

// Sub-role, non - localized (e.g. NSAccessibilityCloseButtonSubrole)
// Invokes when clients request NSAccessibilitySubroleAttribute
@property (nullable, copy) NSString *accessibilitySubrole NS_AVAILABLE_MAC(10_10);

// Visible text on the UIElement
// Invokes when clients request NSAccessibilityTitleAttribute
@property (nullable, copy) NSString *accessibilityTitle NS_AVAILABLE_MAC(10_10);

// UIElement for the title
// Invokes when clients request NSAccessibilityTitleUIElementAttribute
@property (nullable, weak) id accessibilityTitleUIElement NS_AVAILABLE_MAC(10_10);

// Next content UIElement
// Invokes when clients request NSAccessibilityNextContentsAttribute
@property (nullable, copy) NSArray *accessibilityNextContents NS_AVAILABLE_MAC(10_10);

// UIElement orientation
// Invokes when clients request NSAccessibilityOrientationAttribute
@property NSAccessibilityOrientation accessibilityOrientation NS_AVAILABLE_MAC(10_10);

// UIElement for overflow
// Invokes when clients request NSAccessibilityOverflowButtonAttribute
@property (nullable, strong) id accessibilityOverflowButton NS_AVAILABLE_MAC(10_10);

// Element containing this UIElement
// Invokes when clients request NSAccessibilityParentAttribute
@property (nullable, weak) id accessibilityParent NS_AVAILABLE_MAC(10_10);

// Placeholder value of a control such as a text field
// Invokes when clients request NSAccessibilityPlaceholderValueAttribute
@property (nullable, copy) NSString *accessibilityPlaceholderValue NS_AVAILABLE_MAC(10_10);

// Previous content UIElement.
// Invokes when clients request NSAccessibilityPreviousContentsAttribute
@property (nullable, copy) NSArray *accessibilityPreviousContents NS_AVAILABLE_MAC(10_10);

// Role, non - localized (e.g. NSAccessibilityRadioButtonRole)
// Invokes when clients request NSAccessibilityRoleAttribute
@property (nullable, copy) NSString *accessibilityRole NS_AVAILABLE_MAC(10_10);

// Human readable role description (e.g. "radio button");
// Invokes when clients request NSAccessibilityRoleDescriptionAttribute
@property (nullable, copy) NSString *accessibilityRoleDescription NS_AVAILABLE_MAC(10_10);

// UIElement for search field search button
// Invokes when clients request NSAccessibilitySearchButtonAttribute
@property (nullable, strong) id accessibilitySearchButton NS_AVAILABLE_MAC(10_10);

// UIElement for search field menu
// Invokes when clients request NSAccessibilitySearchMenuAttribute
@property (nullable, strong) id accessibilitySearchMenu NS_AVAILABLE_MAC(10_10);

// Returns YES if the UIElement is selected
// Invokes when clients request NSAccessibilitySelectedAttribute
@property (getter = isAccessibilitySelected) BOOL accessibilitySelected NS_AVAILABLE_MAC(10_10);

// Array of selected child UIElements
// Invokes when clients request NSAccessibilitySelectedChildrenAttribute
@property (nullable, copy) NSArray *accessibilitySelectedChildren NS_AVAILABLE_MAC(10_10);

// Array of UIElements that this titles
// Invokes when clients request NSAccessibilityServesAsTitleForUIElementsAttribute
@property (nullable, copy) NSArray *accessibilityServesAsTitleForUIElements NS_AVAILABLE_MAC(10_10);

// Menu being displayed for the UIElement
// Invokes when clients request NSAccessibilityShownMenuAttribute
@property (nullable, strong) id accessibilityShownMenu NS_AVAILABLE_MAC(10_10);

// The UIElement's minimum value
// Invokes when clients request NSAccessibilityMinValueAttribute
@property (nullable, strong) id accessibilityMinValue NS_AVAILABLE_MAC(10_10);

// The UIElement's maximum value
// Invokes when clients request NSAccessibilityMaxValueAttribute
@property (nullable, strong) id accessibilityMaxValue NS_AVAILABLE_MAC(10_10);

// Corresponding UIElements
// Invokes when clients request NSAccessibilityLinkedUIElementsAttribute
@property (nullable, copy) NSArray *accessibilityLinkedUIElements NS_AVAILABLE_MAC(10_10);

// UIElement for the containing window
// Invokes when clients request NSAccessibilityWindowAttribute
@property (nullable, weak) id accessibilityWindow NS_AVAILABLE_MAC(10_10);

// Unique identifier for the UIElement
// Invokes when clients request NSAccessibilityIdentifierAttribute
@property (nullable, copy) NSString *accessibilityIdentifier NS_AVAILABLE_MAC(10_10);

// Instance description (e.g. a tool tip)
// Invokes when clients request NSAccessibilityHelpAttribute
@property (nullable, copy) NSString *accessibilityHelp NS_AVAILABLE_MAC(10_10);

// Filename of the underlying asset
// Invokes when clients request NSAccessibilityFilenameAttribute
@property (nullable, copy) NSString *accessibilityFilename NS_AVAILABLE_MAC(10_10);

// Returns YES if the UIElement is expanded
// Invokes when clients request NSAccessibilityExpandedAttribute
@property (getter = isAccessibilityExpanded) BOOL accessibilityExpanded NS_AVAILABLE_MAC(10_10);

// Returns YES if the UIElement has been edited
// Invokes when clients request NSAccessibilityEditedAttribute
@property (getter = isAccessibilityEdited) BOOL accessibilityEdited NS_AVAILABLE_MAC(10_10);

// Returns YES if the element responds to user events
// Invokes when clients request NSAccessibilityEnabledAttribute
@property (getter = isAccessibilityEnabled) BOOL accessibilityEnabled NS_AVAILABLE_MAC(10_10);

// Array of UIElements that represent children of the current UIElement
// Invokes when clients request NSAccessibilityChildrenAttribute
@property (nullable, copy) NSArray *accessibilityChildren NS_AVAILABLE_MAC(10_10);

// UIElement for search field clear button
// Invokes when clients request NSAccessibilityClearButtonAttribute
@property (nullable, strong) id accessibilityClearButton NS_AVAILABLE_MAC(10_10);

// UIElement for cancel button
// Invokes when clients request NSAccessibilityCancelButtonAttribute
@property (nullable, strong) id accessibilityCancelButton NS_AVAILABLE_MAC(10_10);

// Returns YES if the UIElement contains protected content
// Invokes when clients request NSAccessibilityContainsProtectedContentAttribute
@property (getter = isAccessibilityProtectedContent) BOOL accessibilityProtectedContent NS_AVAILABLE_MAC(10_10);

// Array of primary content elements
// Invokes when clients request NSAccessibilityContentsAttribute
@property (nullable, copy) NSArray *accessibilityContents NS_AVAILABLE_MAC(10_10);

// Description of UIElement
// Invokes when clients request NSAccessibilityDescriptionAttribute
@property (nullable, copy) NSString *accessibilityLabel NS_AVAILABLE_MAC(10_10);

// Returns YES if the element is has been triggered to display alternate UIs
// Invokes when clients request NSAccessibilityAlternateUIVisibleAttribute
@property (getter = isAccessibilityAlternateUIVisible) BOOL accessibilityAlternateUIVisible NS_AVAILABLE_MAC(10_10);

// Array of elements with which this element shares keyboard focus
// Invokes when clients request NSAccessibilitySharedFocusElementsAttribute
@property (nullable, copy) NSArray *accessibilitySharedFocusElements NS_AVAILABLE_MAC(10_10);

#pragma mark Application

// Returns YES if the element is focused (generally, accessibilityFocused is equivalent to the
// to the UIElement with the focus ring or selection)
// Invokes when clients request NSAccessibilityFocusedUIElementAttribute
@property (nullable, strong) id accessibilityApplicationFocusedUIElement NS_AVAILABLE_MAC(10_10);

// UIElement for the main window.
// Invokes when clients request NSAccessibilityMainWindowAttribute
@property (nullable, strong) id accessibilityMainWindow NS_AVAILABLE_MAC(10_10);

// Returns YES if the app hidden
// Invokes when clients request NSAccessibilityHiddenAttribute
@property (getter = isAccessibilityHidden) BOOL accessibilityHidden NS_AVAILABLE_MAC(10_10);

// Returns YES if the app is active
// Invokes when clients request NSAccessibilityFrontmostAttribute
@property (getter = isAccessibilityFrontmost) BOOL accessibilityFrontmost NS_AVAILABLE_MAC(10_10);

// UIElement for the key window.
// Invokes when clients request NSAccessibilityFocusedWindowAttribute
@property (nullable, strong) id accessibilityFocusedWindow NS_AVAILABLE_MAC(10_10);

// Array of UIElements for the windows
// Invokes when clients request NSAccessibilityWindowsAttribute
@property (nullable, copy) NSArray *accessibilityWindows NS_AVAILABLE_MAC(10_10);

// UIElement for the application extras menu bar.
// Invokes when clients request NSAccessibilityExtrasMenuBarAttribute
@property (nullable, weak) id accessibilityExtrasMenuBar NS_AVAILABLE_MAC(10_10);

// UIElement for the menu bar
// Invokes when clients request NSAccessibilityMenuBarAttribute
@property (nullable, weak) id accessibilityMenuBar NS_AVAILABLE_MAC(10_10);

#pragma mark Browser
// Array of UIElements for titles
// Invokes when clients request NSAccessibilityColumnTitlesAttribute
@property (nullable, copy) NSArray *accessibilityColumnTitles NS_AVAILABLE_MAC(10_10);

#pragma mark Grid
// Returns a BOOL indicating whether the children are ordered row major, or column major.
// Invokes when clients request NSAccessibilityOrderedByRowAttribute
@property (getter = isAccessibilityOrderedByRow) BOOL accessibilityOrderedByRow NS_AVAILABLE_MAC(10_10);

#pragma mark Layout area
// Horizontal units
// Invokes when clients request NSAccessibilityHorizontalUnitsAttribute
@property NSAccessibilityUnits accessibilityHorizontalUnits NS_AVAILABLE_MAC(10_10);

// Vertical units
// Invokes when clients request NSAccessibilityVerticalUnitsAttribute
@property NSAccessibilityUnits accessibilityVerticalUnits NS_AVAILABLE_MAC(10_10);

// Human-readable description of the horizontal units
// Invokes when clients request NSAccessibilityHorizontalUnitDescriptionAttribute
@property (nullable, copy) NSString *accessibilityHorizontalUnitDescription NS_AVAILABLE_MAC(10_10);

// Human-readable description of the vertical units
// Invokes when clients request NSAccessibilityVerticalUnitDescriptionAttribute
@property (nullable, copy) NSString *accessibilityVerticalUnitDescription NS_AVAILABLE_MAC(10_10);

// Layout point from screen point
// Invokes when clients request NSAccessibilityLayoutPointForScreenPointParameterizedAttribute
- (NSPoint)accessibilityLayoutPointForScreenPoint:(NSPoint)point NS_AVAILABLE_MAC(10_10);

// Layout size from screen size
// Invokes when clients request NSAccessibilityLayoutSizeForScreenSizeParameterizedAttribute
- (NSSize)accessibilityLayoutSizeForScreenSize:(NSSize)size NS_AVAILABLE_MAC(10_10);

// Screen point from layout point
// Invokes when clients request NSAccessibilityScreenPointForLayoutPointParameterizedAttribute
- (NSPoint)accessibilityScreenPointForLayoutPoint:(NSPoint)point NS_AVAILABLE_MAC(10_10);

// Screen size from layout size
// Invokes when clients request NSAccessibilityScreenSizeForLayoutSizeParameterizedAttribute
- (NSSize)accessibilityScreenSizeForLayoutSize:(NSSize)size NS_AVAILABLE_MAC(10_10);

#pragma mark Layout item
// UIElements for handles
// Invokes when clients request NSAccessibilityHandlesAttribute
@property (nullable, copy) NSArray *accessibilityHandles NS_AVAILABLE_MAC(10_10);

#pragma mark Level indicator
// Warning value of a level indicator, typically a number
// Invokes when clients request NSAccessibilityWarningValueAttribute
@property (nullable, strong) id accessibilityWarningValue NS_AVAILABLE_MAC(10_10);

// Critical value of a level indicator, typically a number
// Invokes when clients request NSAccessibilityCriticalValueAttribute
@property (nullable, strong) id accessibilityCriticalValue NS_AVAILABLE_MAC(10_10);

#pragma mark Outline
// Returns true if sub-rows are visible
// Invokes when clients request NSAccessibilityDisclosingAttribute
@property (getter = isAccessibilityDisclosed) BOOL accessibilityDisclosed NS_AVAILABLE_MAC(10_10);

// UIElement for disclosing row
// Invokes when clients request NSAccessibilityDisclosedByRowAttribute
@property (nullable, weak) id accessibilityDisclosedByRow NS_AVAILABLE_MAC(10_10);

// Array of UIElements for disclosed rows of the current ruw (ie, sub-rows)
// Invokes when clients request NSAccessibilityDisclosedRowsAttribute
@property (nullable, strong) id accessibilityDisclosedRows NS_AVAILABLE_MAC(10_10);

// Indentation level
// Invokes when clients request NSAccessibilityDisclosureLevelAttribute
@property NSInteger accessibilityDisclosureLevel NS_AVAILABLE_MAC(10_10);

#pragma mark Ruler
// Invokes when clients request NSAccessibilityMarkerUIElementsAttribute
@property (nullable, copy) NSArray *accessibilityMarkerUIElements NS_AVAILABLE_MAC(10_10);

// Invokes when clients request NSAccessibilityMarkerValuesAttribute
@property (nullable, strong) id accessibilityMarkerValues NS_AVAILABLE_MAC(10_10);

// Invokes when clients request NSAccessibilityMarkerGroupUIElementAttribute
@property (nullable, strong) id accessibilityMarkerGroupUIElement NS_AVAILABLE_MAC(10_10);

// Ruler units
// Invokes when clients request NSAccessibilityUnitsAttribute
@property NSAccessibilityUnits accessibilityUnits NS_AVAILABLE_MAC(10_10);

// Human-readable description of the ruler units
// Invokes when clients request NSAccessibilityUnitDescriptionAttribute
@property (nullable, copy) NSString *accessibilityUnitDescription NS_AVAILABLE_MAC(10_10);

// Marker type
// Invokes when clients request NSAccessibilityMarkerTypeAttribute
@property NSAccessibilityRulerMarkerType accessibilityRulerMarkerType NS_AVAILABLE_MAC(10_10);

// Human-readable description of the marker type
// Invokes when clients request NSAccessibilityMarkerTypeDescriptionAttribute
@property (nullable, copy) NSString *accessibilityMarkerTypeDescription NS_AVAILABLE_MAC(10_10);

#pragma mark Scrollable region
// UIElement for the horizontal scroller
// Invokes when clients request NSAccessibilityHorizontalScrollBarAttribute
@property (nullable, strong) id accessibilityHorizontalScrollBar NS_AVAILABLE_MAC(10_10);

// UIElement for the vertical scroller
// Invokes when clients request NSAccessibilityVerticalScrollBarAttribute
@property (nullable, strong) id accessibilityVerticalScrollBar NS_AVAILABLE_MAC(10_10);

#pragma mark Slider
// Array of allowed values
// Invokes when clients request NSAccessibilityAllowedValuesAttribute
@property (nullable, copy) NSArray<NSNumber *> *accessibilityAllowedValues NS_AVAILABLE_MAC(10_10);

// Array of label UIElements
// Invokes when clients request NSAccessibilityLabelUIElementsAttribute
@property (nullable, copy) NSArray *accessibilityLabelUIElements NS_AVAILABLE_MAC(10_10);

// Value of a label UIElement
// Invokes when clients request NSAccessibilityLabelValueAttribute
@property float accessibilityLabelValue NS_AVAILABLE_MAC(10_10);

#pragma mark Splitter
// UIElements for splitters
// Invokes when clients request NSAccessibilitySplittersAttribute
@property (nullable, copy) NSArray *accessibilitySplitters NS_AVAILABLE_MAC(10_10);

#pragma mark Stepper
// UIElement for the decrement button
// Invokes when clients request NSAccessibilityDecrementButtonAttribute
@property (nullable, strong) id accessibilityDecrementButton NS_AVAILABLE_MAC(10_10);

// UIElement for the increment button
// Invokes when clients request NSAccessibilityIncrementButtonAttribute
@property (nullable, strong) id accessibilityIncrementButton NS_AVAILABLE_MAC(10_10);

#pragma mark Tab view
// UIElements for tabs
// Invokes when clients request NSAccessibilityTabsAttribute
@property (nullable, copy) NSArray *accessibilityTabs NS_AVAILABLE_MAC(10_10);

#pragma mark Table/Outline
// UIElement for header
// Invokes when clients request NSAccessibilityHeaderAttribute
@property (nullable, strong) id accessibilityHeader NS_AVAILABLE_MAC(10_10);

// Number of columns
// Invokes when clients request NSAccessibilityColumnCountAttribute
@property NSInteger accessibilityColumnCount NS_AVAILABLE_MAC(10_10);

// Number of rows
// Invokes when clients request NSAccessibilityRowCountAttribute
@property NSInteger accessibilityRowCount NS_AVAILABLE_MAC(10_10);

// Index of the current UIElement (row index for a row, column index for a column)
// Invokes when clients request NSAccessibilityIndexAttribute
@property NSInteger accessibilityIndex NS_AVAILABLE_MAC(10_10);

// Array of UIElements for columns
// Invokes when clients request NSAccessibilityColumnsAttribute
@property (nullable, copy) NSArray *accessibilityColumns NS_AVAILABLE_MAC(10_10);

// Array of UIElements for rows
// Invokes when clients request NSAccessibilityRowsAttribute
@property (nullable, copy) NSArray *accessibilityRows NS_AVAILABLE_MAC(10_10);

// Array of UIElements for visible rows
// Invokes when clients request NSAccessibilityVisibleRowsAttribute
@property (nullable, copy) NSArray *accessibilityVisibleRows NS_AVAILABLE_MAC(10_10);

// Array of UIElements for selected rows
// Invokes when clients request NSAccessibilitySelectedRowsAttribute
@property (nullable, copy) NSArray *accessibilitySelectedRows NS_AVAILABLE_MAC(10_10);

// Array of UIElements for visible columns
// Invokes when clients request NSAccessibilityVisibleColumnsAttribute
@property (nullable, copy) NSArray *accessibilityVisibleColumns NS_AVAILABLE_MAC(10_10);

// Array of UIElements for selected columns
// Invokes when clients request NSAccessibilitySelectedColumnsAttribute
@property (nullable, copy) NSArray *accessibilitySelectedColumns NS_AVAILABLE_MAC(10_10);

// Sort direction
// Invokes when clients request NSAccessibilitySortDirectionAttribute
@property NSAccessibilitySortDirection accessibilitySortDirection NS_AVAILABLE_MAC(10_10);

#pragma mark Table (cell based)
// Array of UIElements for row headers
// Invokes when clients request NSAccessibilityRowHeaderUIElementsAttribute
@property (nullable, copy) NSArray *accessibilityRowHeaderUIElements NS_AVAILABLE_MAC(10_10);

// Array of UIElements for selected cells
// Invokes when clients request NSAccessibilitySelectedCellsAttribute
@property (nullable, copy) NSArray *accessibilitySelectedCells NS_AVAILABLE_MAC(10_10);

// Array of UIElements for visible cells
// Invokes when clients request NSAccessibilityVisibleCellsAttribute
@property (nullable, copy) NSArray *accessibilityVisibleCells NS_AVAILABLE_MAC(10_10);

// Array of UIElements for column headers
// Invokes when clients request NSAccessibilityColumnHeaderUIElementsAttribute
@property (nullable, copy) NSArray *accessibilityColumnHeaderUIElements NS_AVAILABLE_MAC(10_10);

// UIElement for cell at specified row and column
// Invokes when clients request NSAccessibilityCellForColumnAndRowParameterizedAttribute
- (nullable id)accessibilityCellForColumn:(NSInteger)column row:(NSInteger)row NS_AVAILABLE_MAC(10_10);

#pragma mark Table cell
// Cell location and row span
// Invokes when clients request NSAccessibilityRowIndexRangeAttribute
@property NSRange accessibilityRowIndexRange NS_AVAILABLE_MAC(10_10);

// Cell location and column span
// Invokes when clients request NSAccessibilityColumnIndexRangeAttribute
@property NSRange accessibilityColumnIndexRange NS_AVAILABLE_MAC(10_10);

#pragma mark Text
// Line number containing caret
// Invokes when clients request NSAccessibilityInsertionPointLineNumberAttribute
@property NSInteger accessibilityInsertionPointLineNumber NS_AVAILABLE_MAC(10_10);

// Part of shared text in this view
// Invokes when clients request NSAccessibilitySharedCharacterRangeAttribute
@property NSRange accessibilitySharedCharacterRange NS_AVAILABLE_MAC(10_10);

// Text views sharing text
// Invokes when clients request NSAccessibilitySharedTextUIElementsAttribute
@property (nullable, copy) NSArray *accessibilitySharedTextUIElements NS_AVAILABLE_MAC(10_10);

// Range of visible text
// Invokes when clients request NSAccessibilityVisibleCharacterRangeAttribute
@property NSRange accessibilityVisibleCharacterRange NS_AVAILABLE_MAC(10_10);

// Number of characters
// Invokes when clients request NSAccessibilityNumberOfCharactersAttribute
@property NSInteger accessibilityNumberOfCharacters NS_AVAILABLE_MAC(10_10);

// String of selected text
// Invokes when clients request NSAccessibilitySelectedTextAttribute
@property (nullable, copy) NSString *accessibilitySelectedText NS_AVAILABLE_MAC(10_10);

// Range of selected text
// Invokes when clients request NSAccessibilitySelectedTextRangeAttribute
@property NSRange accessibilitySelectedTextRange NS_AVAILABLE_MAC(10_10);

// Array of NSValue (rangeValue) ranges of selected text
// Invokes when clients request NSAccessibilitySelectedTextRangesAttribute
@property (nullable, copy) NSArray<NSValue *> *accessibilitySelectedTextRanges NS_AVAILABLE_MAC(10_10);

// Attributed string for a provided range.
// does _not_ use attributes from Appkit/AttributedString.h
// Invokes when clients request NSAccessibilityAttributedStringForRangeParameterizedAttribute
- (nullable NSAttributedString *)accessibilityAttributedStringForRange:(NSRange)range NS_AVAILABLE_MAC(10_10);

// Range for the provided line number
// Invokes when clients request NSAccessibilityRangeForLineParameterizedAttribute
- (NSRange)accessibilityRangeForLine:(NSInteger)line NS_AVAILABLE_MAC(10_10);

// String for the provided range
// Invokes when clients request NSAccessibilityStringForRangeParameterizedAttribute
- (nullable NSString *)accessibilityStringForRange:(NSRange)range NS_AVAILABLE_MAC(10_10);

// Composed character range for the character at the provided point
// Invokes when clients request NSAccessibilityRangeForPositionParameterizedAttribute
- (NSRange)accessibilityRangeForPosition:(NSPoint)point NS_AVAILABLE_MAC(10_10);

// Composed character range for the provided index
// Invokes when clients request NSAccessibilityRangeForIndexParameterizedAttribute
- (NSRange)accessibilityRangeForIndex:(NSInteger)index NS_AVAILABLE_MAC(10_10);

// Frame of text in the provided range (in screen coordinates.) See NSAccessibilityFrameInView()
// Invokes when clients request NSAccessibilityBoundsForRangeParameterizedAttribute
- (NSRect)accessibilityFrameForRange:(NSRange)range NS_AVAILABLE_MAC(10_10);

// RTF data for text in the provided range
// Invokes when clients request NSAccessibilityRTFForRangeParameterizedAttribute
- (nullable NSData *)accessibilityRTFForRange:(NSRange)range NS_AVAILABLE_MAC(10_10);

// Extent of style run at the provided index
// Invokes when clients request NSAccessibilityStyleRangeForIndexParameterizedAttribute
- (NSRange)accessibilityStyleRangeForIndex:(NSInteger)index NS_AVAILABLE_MAC(10_10);

// Line number for character index
// Invokes when clients request NSAccessibilityLineForIndexParameterizedAttribute
- (NSInteger)accessibilityLineForIndex:(NSInteger)index NS_AVAILABLE_MAC(10_10);

#pragma mark Window
// UIElement for toolbar box (or nil)
// Invokes when clients request NSAccessibilityToolbarButtonAttribute
@property (nullable, strong) id accessibilityToolbarButton NS_AVAILABLE_MAC(10_10);

// Is the window modal
// Invokes when clients request NSAccessibilityModalAttribute
@property (getter = isAccessibilityModal) BOOL accessibilityModal NS_AVAILABLE_MAC(10_10);

// UIElement for title's icon (or nil)
// Invokes when clients request NSAccessibilityProxyAttribute
@property (nullable, strong) id accessibilityProxy NS_AVAILABLE_MAC(10_10);

// Returns YES if this is it the main window
// Invokes when clients request NSAccessibilityMainAttribute
@property (getter = isAccessibilityMain) BOOL accessibilityMain NS_AVAILABLE_MAC(10_10);

// UIElement for full screen button
// Invokes when clients request NSAccessibilityFullScreenButtonAttribute
@property (nullable, strong) id accessibilityFullScreenButton NS_AVAILABLE_MAC(10_10);

// UIElement for grow box
// Invokes when clients request NSAccessibilityGrowAreaAttribute
@property (nullable, strong) id accessibilityGrowArea NS_AVAILABLE_MAC(10_10);

// URL for open document
// Invokes when clients request NSAccessibilityDocumentAttribute
@property (nullable, copy) NSString *accessibilityDocument NS_AVAILABLE_MAC(10_10);

// UIElement for default button
// Invokes when clients request NSAccessibilityDefaultButtonAttribute
@property (nullable, strong) id accessibilityDefaultButton NS_AVAILABLE_MAC(10_10);

// UIElement for close button
// Invokes when clients request NSAccessibilityCloseButtonAttribute
@property (nullable, strong) id accessibilityCloseButton NS_AVAILABLE_MAC(10_10);

// UIElement for zoom button
// Invokes when clients request NSAccessibilityZoomButtonAttribute
@property (nullable, strong) id accessibilityZoomButton NS_AVAILABLE_MAC(10_10);

// UIElement for minimize button
// Invokes when clients request NSAccessibilityMinimizeButtonAttribute
@property (nullable, strong) id accessibilityMinimizeButton NS_AVAILABLE_MAC(10_10);

// Returns YES if the window minimized
// Invokes when clients request NSAccessibilityMinimizedAttribute
@property (getter = isAccessibilityMinimized) BOOL accessibilityMinimized NS_AVAILABLE_MAC(10_10);

#pragma mark Actions
// Invokes when clients perform NSAccessibilityCancelAction
- (BOOL)accessibilityPerformCancel NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityConfirmAction
- (BOOL)accessibilityPerformConfirm NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityDecrementAction
- (BOOL)accessibilityPerformDecrement NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityDeleteAction
- (BOOL)accessibilityPerformDelete NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityIncrementAction
- (BOOL)accessibilityPerformIncrement NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityPickAction
- (BOOL)accessibilityPerformPick NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityPressAction
- (BOOL)accessibilityPerformPress NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityRaiseAction
- (BOOL)accessibilityPerformRaise NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityShowAlternateUIAction
- (BOOL)accessibilityPerformShowAlternateUI NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityShowDefaultUIAction
- (BOOL)accessibilityPerformShowDefaultUI NS_AVAILABLE_MAC(10_10);

// Invokes when clients perform NSAccessibilityShowMenuAction
- (BOOL)accessibilityPerformShowMenu NS_AVAILABLE_MAC(10_10);

#pragma mark Allowed Selectors
// Returns YES if accessibility clients should be able to invoke the provided selector
- (BOOL)isAccessibilitySelectorAllowed:(SEL)selector NS_AVAILABLE_MAC(10_10);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  NSActionCell.h                                                                                      0100644 0001750 0001750 00000001411 12567220725 033442  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSActionCell.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSCell.h>

NS_ASSUME_NONNULL_BEGIN

@interface NSActionCell : NSCell
{
    /*All instance variables are private*/
    NSInteger	_tag;        
    id		_target;     
    SEL		_action;     
    id		_controlView; // this was always private, but it isn't used for storage of the control view now either.  Please use the accessors -[NSCell controlView] and -[NSCell setControlView:].      
}

@property (nullable, weak) id target; // Target is weak for zeroing-weak compatible objects in apps linked on 10.10 or later. Otherwise the behavior of this property is 'assign.
@property (nullable) SEL action;
@property NSInteger tag;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                       NSAffineTransform.h                                                                                 0100644 0001750 0001750 00000000704 12567220725 034515  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSAffineTransform.h
        Application Kit
        Copyright (c) 1997-2015, Apple Inc.
        All rights reserved.
*/

#import <Foundation/NSAffineTransform.h>

NS_ASSUME_NONNULL_BEGIN

@class NSBezierPath;

@interface NSAffineTransform (NSAppKitAdditons)
// Transform a path
- (NSBezierPath *)transformBezierPath:(NSBezierPath *)aPath;

// Setting a transform in NSGraphicsContext
- (void)set;
- (void)concat;
@end

NS_ASSUME_NONNULL_END
                                                            NSAlert.h                                                                                           0100644 0001750 0001750 00000022005 12567220725 032476  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSAlert.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <AppKit/NSApplication.h>
#import <AppKit/NSGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@class NSTextField, NSPanel, NSWindow, NSImage, NSButton, NSError;
@protocol NSAlertDelegate;


/* The default alert style is NSWarningAlertStyle.  NSCriticalAlertStyle should be reserved for critical alerts and will cause the icon to be badged with a caution icon.
*/
typedef NS_ENUM(NSUInteger, NSAlertStyle) {
    NSWarningAlertStyle = 0,
    NSInformationalAlertStyle = 1,
    NSCriticalAlertStyle = 2
};

@interface NSAlert : NSObject
{
    @private
    /*All instance variables are private*/
    NSTextField *_informationField;
    id  _first;
    id  _second;
    id  _third;
    NSArray *_buttons;
    NSPanel *_panel;
    id  _messageField;
    id  _imageView;
    NSSize _minButtonSize;
    CGFloat _buttonSpacing;
    CGFloat _buttonPadding;
    CGFloat _messagePadding;
    CGFloat _buttonSpacingMaxX;
    CGFloat _buttonSpacingY;
    id _modalDelegate;
    NSWindow *_docWindow;
    SEL _didEndSelector;
    SEL _didDismissSelector;
    NSImage *_unbadgedImage;
    NSSize _defaultPanelSize;
    id _helpButton;
    id _delegate;
    NSAlertStyle _alertStyle;
    id _helpAnchor;
    BOOL _layoutDone;
    BOOL _showsHelp;
    BOOL _showsSuppressionButton;
    BOOL reserved;
    id _suppressionButton;
    id _accessoryView;
}


/* Given an NSError, create an NSAlert that can be used to present the error to the user. The error's localized description, recovery suggestion, and recovery options will be used to set the alert's message text, informative text, and button titles, respectively.
*/
+ (NSAlert *)alertWithError:(NSError *)error;


/* This method is deprecated in 10.9 and will be formally deprecated in the following release.
 This was intended for use by apps migrating from the C-based API.  This uses alternate return codes that were compatible with this C-based API, but not with modern alerts, see NSAlertDefaultReturn, etc. in NSPanel.h
 Alerts should be created with the -init method and setting properties.
 */
+ (NSAlert *)alertWithMessageText:(nullable NSString *)message defaultButton:(nullable NSString *)defaultButton alternateButton:(nullable NSString *)alternateButton otherButton:(nullable NSString *)otherButton informativeTextWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(5,6) NS_DEPRECATED_MAC(10_3, 10_10, "Use -init instead");


@property (copy) NSString *messageText;
@property (copy) NSString *informativeText;

/* customize the icon.  By default uses the image named NSApplicationIcon.
*/
@property (null_resettable, strong) NSImage *icon;

/* customize the buttons in the alert panel.  Buttons are added from right to left (for left to right languages).
*/
- (NSButton *)addButtonWithTitle:(NSString *)title;
/* get the buttons, where the rightmost button is at index 0.
*/
@property (readonly, copy) NSArray<NSButton *> *buttons;

/* These are additional NSModalResponse values used by NSAlert's -runModal and -beginSheetModalForWindow:completionHandler:.
 
   By default, NSAlert return values are position dependent, with this mapping:
       first (rightmost) button = NSAlertFirstButtonReturn
       second button = NSAlertSecondButtonReturn
       third button = NSAlertThirdButtonReturn
       buttonPosition 3+x = NSAlertThirdButtonReturn + x
 
   Note that these return values do not apply to an NSAlert created via +alertWithMessageText:defaultButton:alternateButton:otherButton:informativeTextWithFormat:, which instead uses the same return values as NSRunAlertPanel.  See NSAlertDefaultReturn, etc. in NSPanel.h
*/
enum {
	NSAlertFirstButtonReturn	= 1000,
	NSAlertSecondButtonReturn	= 1001,
	NSAlertThirdButtonReturn	= 1002
};

/* In order to customize a return value for a button:
   setTag:(NSInteger)tag;	setting a tag on a button will cause that tag to be the button's return value
   
   Note that we reserve the use of the tag for this purpose.  We also reserve the use of the target and the action.
   
   By default, the first button has a key equivalent of return which implies a pulsing default button, the button named "Cancel", if any, has a key equivalent of escape, and the button named "Don't Save", if any, has a key equivalent of cmd-d.  The following methods can be used to customize key equivalents:
   setKeyEquivalent:(NSString *)charCode:
   setKeyEquivalentModifierMask:(NSUInt)mask;
*/


/* -setShowsHelp:YES adds a help button to the alert panel. When the help button is pressed, the delegate is first consulted.  If the delegate does not implement alertShowHelp: or returns NO, then -[NSHelpManager openHelpAnchor:inBook:] is called with a nil book and the anchor specified by -setHelpAnchor:, if any.  An exception will be raised if the delegate returns NO and there is no help anchor set.
*/
@property BOOL showsHelp;

@property (nullable, copy) NSString *helpAnchor;

@property NSAlertStyle alertStyle;

@property (nullable, assign) id<NSAlertDelegate> delegate;

/* -setShowsSuppressionButton: indicates whether or not the alert should contain a suppression checkbox.  The default is NO.  This checkbox is typically used to give the user an option to not show this alert again.  If shown, the suppression button will have a default localized title similar to @"Do not show this message again".  You can customize this title using [[alert suppressionButton] setTitle:].  When the alert is dismissed, you can get the state of the suppression button, using [[alert suppressionButton] state] and store the result in user defaults, for example.  This setting can then be checked before showing the alert again.  By default, the suppression button is positioned below the informative text, and above the accessory view (if any) and the alert buttons, and left-aligned with the informative text.  However do not count on the placement of this button, since it might be moved if the alert panel user interface is changed in the future. If you need a checkbox for purposes other than suppression text, it is recommended you create your own using an accessory view.
*/
@property BOOL showsSuppressionButton NS_AVAILABLE_MAC(10_5);

/* -suppressionButton returns a suppression button which may be customized, including the title and the initial state.  You can also use this method to get the state of the button after the alert is dismissed, which may be stored in user defaults and checked before showing the alert again.  In order to show the suppression button in the alert panel, you must call -setShowsSuppressionButton:YES.
*/
@property (nullable, readonly, strong) NSButton *suppressionButton NS_AVAILABLE_MAC(10_5);


/* -setAccessoryView: sets the accessory view displayed in the alert panel.  By default, the accessory view is positioned below the informative text and the suppression button (if any) and above the alert buttons, left-aligned with the informative text.  If you want to customize the location of the accessory view, you must first call -layout.  See the discussion of -layout for more information.
*/
@property (nullable, strong) NSView *accessoryView NS_AVAILABLE_MAC(10_5);

/* -layout can be used to indicate that the alert panel should do immediate layout, overriding the default behavior of laying out lazily just before showing panel.  You should only call this method if you want to do your own custom layout after it returns.  You should call this method only after you have finished with NSAlert customization, including setting message and informative text, and adding buttons and an accessory view if needed.  You can make layout changes after this method returns, in particular to adjust the frame of an accessory view.  Note that the standard layout of the alert may change in the future, so layout customization should be done with caution.
*/
- (void)layout NS_AVAILABLE_MAC(10_5);


/* Run the alert as an application-modal panel and return the result.
*/
- (NSModalResponse)runModal;

/* This method is deprecated in 10.9 and will be formally deprecated in the following release.
 -beginSheetModalForWindow:completionHandler: should be used instead.
 */
- (void)beginSheetModalForWindow:(NSWindow *)window modalDelegate:(nullable id)delegate didEndSelector:(nullable SEL)didEndSelector contextInfo:(nullable void *)contextInfo NS_DEPRECATED_MAC(10_3, 10_10, "Use -beginSheetModalForWindow:completionHandler: instead");

/* Begins a sheet on the doc window using NSWindow's sheet API.
   If the alert has an alertStyle of NSCriticalAlertStyle, it will be shown as a "critical" sheet; it will otherwise be presented as a normal sheet.
 */
- (void)beginSheetModalForWindow:(NSWindow *)sheetWindow completionHandler:(void (^ __nullable)(NSModalResponse returnCode))handler NS_AVAILABLE_MAC(10_9);

/* return the application-modal panel or the document-modal sheet corresponding to this alert.
*/
@property (readonly, strong) NSWindow *window;

@end

@protocol NSAlertDelegate <NSObject>
@optional
/* the delegate should implement this if custom help behavior is required.
*/
- (BOOL)alertShowHelp:(NSAlert *)alert;
@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           NSAlignmentFeedbackFilter.h                                                                         0100644 0001750 0001750 00000005225 12567220726 036126  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
 NSAlignmentFeedbackFilter.h
 Application Kit
 Copyright (c) 2015, Apple Inc.
 All rights reserved.
 */

#import <Foundation/Foundation.h>
#import <AppKit/NSEvent.h>
#import <AppKit/NSHapticFeedback.h>

@class NSPanGestureRecognizer;
@class NSView;

@protocol NSAlignmentFeedbackToken <NSObject>
@end

NS_ASSUME_NONNULL_BEGIN

NS_CLASS_AVAILABLE(10_11, NA)
@interface NSAlignmentFeedbackFilter : NSObject

/*  The event mask indicating which event types the filter accepts. Suitable for use in tracking loops.
 */
+ (NSEventMask)inputEventMask;

/*  Input a new event matching +inputEventMask.
 */
- (void)updateWithEvent:(NSEvent *)event;

/*  Input events from a pan gesture recognizer. Use this instead of -updateWithEvent: if your event handling uses gesture recognizers.
 */
- (void)updateWithPanRecognizer:(NSPanGestureRecognizer *)panRecognizer;

/*  Prepare haptic feedback for object movement due to alignment from one location to another. Returns a context object which may be performed later, or nil if no alignment should be performed. previousPoint must be the last location which the user saw the object at. alignedPoint must be the latest location if the alignment is allowed. defaultPoint must be the location which the item will be at if the alignment does not take effect. To prevent unnecessary haptic feedback to the user, it's important that the correct three locations are used.
 */
- (nullable id<NSAlignmentFeedbackToken>)alignmentFeedbackTokenForMovementInView:(nullable NSView *)view previousPoint:(NSPoint)previousPoint alignedPoint:(NSPoint)alignedPoint defaultPoint:(NSPoint)defaultPoint;

/*  Same as alignmentFeedbackTokenForMovementInView:previousPoint:alignedPoint:defaultPoint:, except that it ignores any vertical movement.
 */
- (nullable id<NSAlignmentFeedbackToken>)alignmentFeedbackTokenForHorizontalMovementInView:(nullable NSView *)view previousX:(CGFloat)previousX alignedX:(CGFloat)alignedX defaultX:(CGFloat)defaultX;

/*  Same as alignmentFeedbackTokenForMovementInView:previousPoint:alignedPoint:defaultPoint:, except that it ignores any horizontal movement.
 */
- (nullable id<NSAlignmentFeedbackToken>)alignmentFeedbackTokenForVerticalMovementInView:(nullable NSView *)view previousY:(CGFloat)previousY alignedY:(CGFloat)alignedY defaultY:(CGFloat)defaultY;

/*  Performs haptic feedback described by one or more alignment feedback tokens, typically at most one per dimension. This should be called immediately before the updated location will be presented to the user.
 */
- (void)performFeedback:(NSArray<id<NSAlignmentFeedbackToken>> *)alignmentFeedbackTokens performanceTime:(NSHapticFeedbackPerformanceTime)performanceTime;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                           NSAnimation.h                                                                                       0100644 0001750 0001750 00000022005 12567220725 033346  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSAnimation.h
    Application Kit
    Copyright (c) 2004-2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/AppKitDefines.h>
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@class NSGraphicsContext, NSString, NSDisplayLink;
@protocol NSAnimationDelegate;

typedef NS_ENUM(NSUInteger, NSAnimationCurve) {
    NSAnimationEaseInOut,       // default
    NSAnimationEaseIn,
    NSAnimationEaseOut,
    NSAnimationLinear
};

typedef NS_ENUM(NSUInteger, NSAnimationBlockingMode) {
    NSAnimationBlocking,
    NSAnimationNonblocking,
    NSAnimationNonblockingThreaded
};

typedef float NSAnimationProgress;

APPKIT_EXTERN NSString * NSAnimationProgressMarkNotification; // has single entry in user info dictionary
APPKIT_EXTERN NSString * NSAnimationProgressMark; // NSNumber(float) with NSAnimationProgress

@interface NSAnimation : NSObject <NSCopying, NSCoding> {
  @private
    NSTimeInterval       _duration;
    NSAnimationProgress  _currentProgress;
    float                 _framesPerSecond;
    id                   _delegate;
    NSDisplayLink       *_displayLink;
    NSTimeInterval       _startTime;
    NSMutableArray      *_progressMarks;
    NSAnimation         *_startAnimation;
    NSAnimation         *_stopAnimation;
    int                  _nextProgressMark;
    struct __aFlags {
	unsigned int delegateAnimationShouldStart:1;
	unsigned int delegateAnimationDidStop:1;
	unsigned int delegateAnimationDidEnd:1;
	unsigned int delegateAnimationValueForProgress:1;
	unsigned int delegateAnimationDidReachProgressMark:1;
	unsigned int animating:1;
	unsigned int blocking:1;
        unsigned int sendProgressAllTheTime:1;
	unsigned int reserved:24;
    } _aFlags;
    struct __aSettings {
	unsigned int animationCurve:8;
	unsigned int animationBlockingMode:2;
	unsigned int reserved:22;
    } _aSettings;
    NSRunLoop *_scheduledRunLoop;
    NSInteger _reserved2;
    NSInteger _reserved3;
    NSInteger _reserved4;
}

- (instancetype)initWithDuration:(NSTimeInterval)duration animationCurve:(NSAnimationCurve)animationCurve;

- (void)startAnimation;
- (void)stopAnimation;
@property (getter=isAnimating, readonly) BOOL animating;

@property NSAnimationProgress currentProgress;

@property NSTimeInterval duration;

@property NSAnimationBlockingMode animationBlockingMode;

@property float frameRate;

@property NSAnimationCurve animationCurve;

@property (readonly) float currentValue;

@property (nullable, assign) id<NSAnimationDelegate> delegate;

@property (copy) NSArray<NSNumber *> *progressMarks;

- (void)addProgressMark:(NSAnimationProgress)progressMark;
- (void)removeProgressMark:(NSAnimationProgress)progressMark;

- (void)startWhenAnimation:(NSAnimation *)animation reachesProgress:(NSAnimationProgress)startProgress;
- (void)stopWhenAnimation:(NSAnimation *)animation reachesProgress:(NSAnimationProgress)stopProgress;

- (void)clearStartAnimation;
- (void)clearStopAnimation;

@property (nullable, readonly, copy) NSArray<NSString *> *runLoopModesForAnimating;

@end

@protocol NSAnimationDelegate <NSObject>
@optional
- (BOOL)animationShouldStart:(NSAnimation *)animation;
- (void)animationDidStop:(NSAnimation *)animation;
- (void)animationDidEnd:(NSAnimation *)animation;
- (float)animation:(NSAnimation *)animation valueForProgress:(NSAnimationProgress)progress;
- (void)animation:(NSAnimation *)animation didReachProgressMark:(NSAnimationProgress)progress;
@end

/*-----------------------------------------------------------------------------------------*/

APPKIT_EXTERN NSString * NSViewAnimationTargetKey;       // NSWindow* or NSView* (required)
APPKIT_EXTERN NSString * NSViewAnimationStartFrameKey;   // NSValue*(NSRect) (optional)
APPKIT_EXTERN NSString * NSViewAnimationEndFrameKey;     // NSValue*(NSRect) (optional)
APPKIT_EXTERN NSString * NSViewAnimationEffectKey;       // NSString*(effect strings) (optional)
APPKIT_EXTERN NSString * NSViewAnimationFadeInEffect;
APPKIT_EXTERN NSString * NSViewAnimationFadeOutEffect;

@interface NSViewAnimation : NSAnimation {
  @private
    NSArray                *_viewAnimations;
    id                      _viewAnimationInfo;
    id                      _windowAnimationInfo;
    NSUInteger                  _reserved4a;
    NSUInteger                  _reserved4b;
    NSUInteger                  _reserved4c;
    struct __vaFlags {
	unsigned int reserved:32;
    }                       _vaFlags;    
    NSUInteger                  _reserved5;
    NSUInteger                  _reserved6;
    NSUInteger                  _reserved7;
    NSUInteger                  _reserved8;    
}

- (instancetype)initWithViewAnimations:(NSArray<NSDictionary<NSString *, id> *> *)viewAnimations;

@property (copy) NSArray<NSDictionary<NSString *, id> *> *viewAnimations;

@end


@protocol NSAnimatablePropertyContainer

/* Returns a proxy object for the receiver that can be used to initiate implied animation of property changes. An object's "animator" should be treated as if it was the object itself, and may be passed to any code that accepts the object as a parameter. Sending of KVC-compliant "set" messages to the proxy will trigger animation for automatically animated properties of its target object, if the active NSAnimationContext in the current thread has a duration value greater than zero, and an animation to use for the property key is found by the -animationForKey: search mechanism defined below. An object's automatically animated properties are those for which [theObject animationForKey:] finds and returns an CAAnimation instead of nil, often because [[theObject class] defaultAnimationForKey:] specifies a default animation for the key.

It's perfectly valid to set a new value for a property for which an animation is currently in progress; this simply sets a new target value for that property, with animation to the new target proceeding from whatever current value the property has reached. An in-flight property animation can be stopped by setting a new value for the property with 0.0 as the surrounding NSAnimationContext's duration value.
*/
- (instancetype)animator NS_AVAILABLE_MAC(10_5);

/* An animatable property container's optional "animations" dictionary maps NSString keys to CAAnimation values. When an occurrence matching the key fires for the view, -animationForKey: first looks in this dictionary for an animation to execute in response. Typically, the key will name a property of the object whose value has just changed, but it may instead specify a special event trigger (NSAnimationTriggerOrderIn or NSAnimationTriggerOrderOut).
*/
@property (readwrite, copy) NSDictionary<NSString *, id> *animations NS_AVAILABLE_MAC(10_5);

/* When the occurrence specified by "key" fires for an object, this method is consulted to find the animation, if any, that should be performed in response. Like its counterpart, -[CALayer actionForKey:], this method is a funnel point that defines the order in which the search for an animation proceeds, and is not one that clients would typically need to override. It first checks the receiver's "animations" dictionary, then falls back to  +defaultAnimationForKey: for the receiver's class.
*/
- (nullable id)animationForKey:(NSString *)key NS_AVAILABLE_MAC(10_5);

/* As described above, -animationForKey: consults this class method when its search of an instance's "animations" dictionary doesn't turn up an animation to use for a given property change.

An animatable property container should implement +defaultAnimationForKey: to return a default animation to be performed for each key that it wants to make auto-animatable, where "key" usually names a property of the receiver, but can also specify a special animation trigger (NSAnimationTriggerOrderIn or NSAnimationTriggerOrderOut).

A developer implementing a custom view subclass, for example, can enable automatic animation the subclass' added properties by overriding this method, and having it return the desired default CAAnimation to use for each of the property keys of interest. The override should defer to super for any keys it doesn't specifically handle, facilitating inheritance of default animation specifications.

The full set of available CAAnimation classes can be found in QuartzCore/CAAnimation.h.  Useful concrete animation classes are CABasicAnimation, CAKeyframeAnimation, CAAnimationGroup, and CATransition, all of which can be instantiated with default parameters by sending the class an +animation message.

@implementation MyView
+ (id)defaultAnimationForKey:(NSString *)key {
    if ([key isEqualToString:@"borderColor"]) {
        // By default, animate border color changes with simple linear interpolation to the new color value.
        return [CABasicAnimation animation];
    } else {
        // Defer to super's implementation for any keys we don't specifically handle.
        return [super defaultAnimationForKey:key];
    }
}
@end
*/
+ (nullable id)defaultAnimationForKey:(NSString *)key NS_AVAILABLE_MAC(10_5);

@end /* @protocol NSAnimatablePropertyContainer */

APPKIT_EXTERN NSString * NSAnimationTriggerOrderIn NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString * NSAnimationTriggerOrderOut NS_AVAILABLE_MAC(10_5);

NS_ASSUME_NONNULL_END


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           NSAnimationContext.h                                                                                0100644 0001750 0001750 00000002762 12567220726 034724  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSAnimationContext.h
    Application Kit
    Copyright (c) 2006-2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/AppKitDefines.h>
#import <Foundation/NSObject.h>
#import <Foundation/NSDate.h>

NS_ASSUME_NONNULL_BEGIN

@class CAMediaTimingFunction;

NS_CLASS_AVAILABLE(10_5, NA)
@interface NSAnimationContext : NSObject {
@private
#if !__LP64__
    NSTimeInterval _duration;
    id _reserved[4];
    unsigned int _allowsImplicitAnimation:1;
    unsigned int _isImplicitContext:1;
    unsigned int __reserved:30;
#endif
}

+ (void)runAnimationGroup:(void (^)(NSAnimationContext * context))changes completionHandler:(nullable void (^)(void))completionHandler NS_AVAILABLE_MAC(10_7);

+ (void)beginGrouping;
+ (void)endGrouping;

+ (NSAnimationContext *)currentContext;

@property NSTimeInterval duration;
@property (nullable, strong) CAMediaTimingFunction *timingFunction NS_AVAILABLE_MAC(10_7);

@property (nullable, copy) void (^completionHandler)(void) NS_AVAILABLE_MAC(10_7);

/* Determine if animations are enabled or not. Using the -animator proxy will automatically set allowsImplicitAnimation to YES. When YES, other properties can implicitly animate along with the initially changed property. For instance, calling [[view animator] setFrame:frame] will allow subviews to also animate their frame positions. This is only applicable when layer backed on Mac OS 10.8 and later. The default value is NO.
 */
@property BOOL allowsImplicitAnimation NS_AVAILABLE_MAC(10_8);

@end

NS_ASSUME_NONNULL_END
              NSAppearance.h                                                                                      0100644 0001750 0001750 00000004707 12567220727 033501  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSAppearance.h
        Application Kit
        Copyright (c) 2011-2015, Apple Inc.
        All rights reserved.
*/

#import <AppKit/AppKitDefines.h>
#import <Foundation/NSObject.h>

NS_ASSUME_NONNULL_BEGIN

@class NSString, NSBundle;

NS_CLASS_AVAILABLE_MAC(10_9)
@interface NSAppearance : NSObject <NSCoding> {
@private
    NSString *_name;
    NSBundle *_bundle;
    void *_private;
    id _reserved;
    id _auxiliary;
#if !__LP64__
    id _extra[2];
#endif
}

@property (readonly, copy) NSString *name NS_AVAILABLE_MAC(10_9);

// Setting and identifying the current appearance in the thread.
+ (NSAppearance *)currentAppearance;
+ (void)setCurrentAppearance:(nullable NSAppearance *)appearance; // nil is valid and indicates the default appearance.

/* Finds and returns an NSAppearance based on the name. 
 For standard appearances such as NSAppearanceNameAqua, a built-in appearance is returned.
 For other names, the main bundle is searched.
 */
+ (nullable NSAppearance *)appearanceNamed:(NSString *)name;

/* Creates an NSAppearance by searching the specified bundle for a file with the specified name (without path extension).
    If bundle is nil, the main bundle is assumed.
 */
- (nullable instancetype)initWithAppearanceNamed:(NSString *)name bundle:(nullable NSBundle *)bundle;

/* Query allowsVibrancy to see if the given appearance actually needs vibrant drawing. You may want to draw differently if the current apperance is vibrant.
 */
@property (readonly) BOOL allowsVibrancy NS_AVAILABLE_MAC(10_10);

@end

#pragma mark -
#pragma mark Standard Appearances

APPKIT_EXTERN NSString * const NSAppearanceNameAqua NS_AVAILABLE_MAC(10_9);
APPKIT_EXTERN NSString * const NSAppearanceNameLightContent NS_DEPRECATED_MAC(10_9, 10_10, "Light content should use the default Aqua apppearance.");

/* The following two Vibrant appearances should only be set on an NSVisualEffectView, or one of its container subviews.
 */
APPKIT_EXTERN NSString * const NSAppearanceNameVibrantDark NS_AVAILABLE_MAC(10_10);
APPKIT_EXTERN NSString * const NSAppearanceNameVibrantLight NS_AVAILABLE_MAC(10_10);

#pragma mark -

@protocol NSAppearanceCustomization <NSObject>
@required

@property (nullable, strong) NSAppearance *appearance NS_AVAILABLE_MAC(10_9);

/* This returns the appearance that would be used when drawing the receiver, taking inherited appearances into account.
 */
@property (readonly, strong) NSAppearance *effectiveAppearance NS_AVAILABLE_MAC(10_9);

@end

NS_ASSUME_NONNULL_END
                                                         NSAppleScriptExtensions.h                                                                           0100644 0001750 0001750 00000001245 12567220725 035740  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSAppleScriptExtensions.h
	Application Kit
	Copyright (c) 2002-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSAppleScript.h>

NS_ASSUME_NONNULL_BEGIN

@class NSAttributedString;



@interface NSAppleScript(NSExtensions)

// Return the syntax-highlighted source code of the script if the script has been compiled and its source code is available, nil otherwise.  It is possible for an NSAppleScript that has been instantiated with -initWithContentsOfURL:error: to be a script for which the source code is not available, but is nonetheless executable.
@property (nullable, readonly, strong) NSAttributedString *richTextSource;

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                           NSApplication.h                                                                                     0100644 0001750 0001750 00000077663 12567220725 033716  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSApplication.h
    Application Kit
    Copyright (c) 1994-2015, Apple Inc.
    All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <AppKit/NSResponder.h>
#import <AppKit/AppKitDefines.h>
#import <AppKit/NSUserInterfaceValidation.h>
#import <AppKit/NSRunningApplication.h>
#import <AppKit/NSUserInterfaceLayout.h>

NS_ASSUME_NONNULL_BEGIN

@class NSDate, NSDictionary, NSError, NSException, NSNotification;
@class NSGraphicsContext, NSImage, NSPasteboard, NSWindow;
@class NSDockTile;
@class NSUserActivity;
@protocol NSApplicationDelegate;

/* The version of the AppKit framework */
APPKIT_EXTERN const double NSAppKitVersionNumber;

#define NSAppKitVersionNumber10_0 577
#define NSAppKitVersionNumber10_1 620
#define NSAppKitVersionNumber10_2 663
#define NSAppKitVersionNumber10_2_3 663.6
#define NSAppKitVersionNumber10_3 743
#define NSAppKitVersionNumber10_3_2 743.14
#define NSAppKitVersionNumber10_3_3 743.2
#define NSAppKitVersionNumber10_3_5 743.24
#define NSAppKitVersionNumber10_3_7 743.33
#define NSAppKitVersionNumber10_3_9 743.36
#define NSAppKitVersionNumber10_4 824
#define NSAppKitVersionNumber10_4_1 824.1
#define NSAppKitVersionNumber10_4_3 824.23
#define NSAppKitVersionNumber10_4_4 824.33
#define NSAppKitVersionNumber10_4_7 824.41
#define NSAppKitVersionNumber10_5 949
#define NSAppKitVersionNumber10_5_2 949.27
#define NSAppKitVersionNumber10_5_3 949.33
#define NSAppKitVersionNumber10_6 1038
#define NSAppKitVersionNumber10_7 1138
#define NSAppKitVersionNumber10_7_2 1138.23
#define NSAppKitVersionNumber10_7_3 1138.32
#define NSAppKitVersionNumber10_7_4 1138.47
#define NSAppKitVersionNumber10_8 1187
#define NSAppKitVersionNumber10_9 1265
#define NSAppKitVersionNumber10_10 1343
#define NSAppKitVersionNumber10_10_2 1344
#define NSAppKitVersionNumber10_10_3 1347
#define NSAppKitVersionNumber10_10_4 1348
#define NSAppKitVersionNumber10_10_5 1348
#define NSAppKitVersionNumber10_10_Max 1349

/* Modes passed to NSRunLoop */
APPKIT_EXTERN NSString *NSModalPanelRunLoopMode;
APPKIT_EXTERN NSString *NSEventTrackingRunLoopMode;


/* Pre-defined return values for -runModalFor: and -runModalSession:. The system also reserves all values below these. Other values can be used. */
enum {
    NSModalResponseStop                 = (-1000), // Also used as the default response for sheets
    NSModalResponseAbort                = (-1001),
    NSModalResponseContinue             = (-1002),
} NS_ENUM_AVAILABLE_MAC(10_9);
typedef NSInteger NSModalResponse NS_AVAILABLE_MAC(10_9);


/* used with NSRunLoop's performSelector:target:argument:order:modes: */
enum {
    NSUpdateWindowsRunLoopOrdering		= 500000
};

typedef NS_OPTIONS(NSUInteger, NSApplicationPresentationOptions) {
/* Flags that comprise an application's presentationOptions */
    NSApplicationPresentationDefault                    = 0,
    NSApplicationPresentationAutoHideDock               = (1 <<  0),    // Dock appears when moused to
    NSApplicationPresentationHideDock                   = (1 <<  1),    // Dock is entirely unavailable

    NSApplicationPresentationAutoHideMenuBar            = (1 <<  2),    // Menu Bar appears when moused to
    NSApplicationPresentationHideMenuBar                = (1 <<  3),    // Menu Bar is entirely unavailable

    NSApplicationPresentationDisableAppleMenu           = (1 <<  4),    // all Apple menu items are disabled
    NSApplicationPresentationDisableProcessSwitching    = (1 <<  5),    // Cmd+Tab UI is disabled
    NSApplicationPresentationDisableForceQuit           = (1 <<  6),    // Cmd+Opt+Esc panel is disabled
    NSApplicationPresentationDisableSessionTermination  = (1 <<  7),    // PowerKey panel and Restart/Shut Down/Log Out disabled
    NSApplicationPresentationDisableHideApplication     = (1 <<  8),    // Application "Hide" menu item is disabled
    NSApplicationPresentationDisableMenuBarTransparency = (1 <<  9),     // Menu Bar's transparent appearance is disabled

    NSApplicationPresentationFullScreen NS_ENUM_AVAILABLE_MAC(10_7) = (1 << 10),                     // Application is in fullscreen mode
    NSApplicationPresentationAutoHideToolbar NS_ENUM_AVAILABLE_MAC(10_7) = (1 << 11)                 // Fullscreen window toolbar is detached from window and hides/shows with autoHidden menuBar.  May be used only when both NSApplicationPresentationFullScreen and NSApplicationPresentationAutoHideMenuBar are also set
    
} NS_ENUM_AVAILABLE_MAC(10_6);

typedef NS_OPTIONS(NSUInteger, NSApplicationOcclusionState) {
    // If set, at least part of any window owned by this application is visible. If not set, all parts of all windows owned by this application are completely occluded. The menu bar does not count as a window owned by this application, so if only the menu bar is showing then the application is considered not visible. Status items, however, have windows owned by your application. If the status item is present in the menu bar, your application will be considered visible as long as the menu bar is visible.
    NSApplicationOcclusionStateVisible = 1UL << 1,
} NS_ENUM_AVAILABLE_MAC(10_9);

/* Information used by the system during modal sessions */
typedef struct _NSModalSession *NSModalSession;
// threading information
typedef struct NSThreadPrivate _NSThreadPrivate;

@interface NSApplication : NSResponder <NSUserInterfaceValidations, NSAccessibilityElement, NSAccessibility>
{
    /*All instance variables are private*/
    NSEvent            *_currentEvent;
    id     		_windowList;
    id                  _keyWindow;
    id                  _mainWindow;
    id                  _delegate;
    id            	*_hiddenList;
    int                 _hiddenCount;
    NSInteger               _context;
    void		*_appleEventSuspensionID;
    __weak id			_previousKeyWindow;
    short               _unusedApp;
    short               _running;
    struct __appFlags {
	unsigned int        _hidden:1;
	unsigned int        _appleEventActivationInProgress:1;
	unsigned int        _active:1;
	unsigned int        _hasBeenRun:1;
	unsigned int        _doingUnhide:1;
	unsigned int	    _delegateReturnsValidRequestor:1;
	unsigned int	    _deactPending:1;
	unsigned int        _invalidState:1;
	unsigned int        _invalidEvent:1;
	unsigned int        _postedWindowsNeedUpdateNote:1;
        unsigned int        _wantsToActivate:1;
        unsigned int        _doingHide:1;
	unsigned int	    _dontSendShouldTerminate:1;
        unsigned int        _ignoresFullScreen:1;
        unsigned int        _finishedLaunching:1;
        unsigned int	    _hasEventDelegate:1;
        unsigned int        _appDying:1;
        unsigned int        _didNSOpenOrPrint:1;
        unsigned int	    _inDealloc:1;
        unsigned int	    _pendingDidFinish:1;
        unsigned int	    _hasKeyFocus:1;
        unsigned int	    _panelsNonactivating:1;
        unsigned int	    _hiddenOnLaunch:1;
        unsigned int	    _openStatus:2;
        unsigned int	    _batchOrdering:1;
        unsigned int        _waitingForTerminationReply:1;
        unsigned int        _windowMoveDisabled:1;
        unsigned int        _enumeratingMemoryPressureHandlers:1;
        unsigned int        _didTryRestoringPersistentState:1;
        unsigned int        _reservedN:1;
        unsigned int        _mightBeSwitching:1;
    }                   _appFlags;
    id                  _mainMenu;
    id                  _appIcon;
    void                *_unused;
    id                  _eventDelegate;
    _NSThreadPrivate     *_threadingSupport;
}

APPKIT_EXTERN __kindof NSApplication * __null_unspecified NSApp;

+ (__kindof NSApplication *)sharedApplication;
@property (nullable, assign) id<NSApplicationDelegate> delegate;
@property (nullable, readonly, strong) NSGraphicsContext *context;
- (void)hide:(nullable id)sender;
- (void)unhide:(nullable id)sender;
- (void)unhideWithoutActivation;
- (nullable NSWindow *)windowWithWindowNumber:(NSInteger)windowNum;
@property (nullable, readonly, assign) NSWindow *mainWindow;
@property (nullable, readonly, assign) NSWindow *keyWindow;
@property (getter=isActive, readonly) BOOL active;
@property (getter=isHidden, readonly) BOOL hidden;
@property (getter=isRunning, readonly) BOOL running;
- (void)deactivate;
- (void)activateIgnoringOtherApps:(BOOL)flag;

- (void)hideOtherApplications:(nullable id)sender;
- (void)unhideAllApplications:(nullable id)sender;

- (void)finishLaunching;
- (void)run;
- (NSInteger)runModalForWindow:(NSWindow *)theWindow;
- (void)stop:(nullable id)sender;
- (void)stopModal;
- (void)stopModalWithCode:(NSInteger)returnCode;
- (void)abortModal;
@property (nullable, readonly, strong) NSWindow *modalWindow;
- (NSModalSession)beginModalSessionForWindow:(NSWindow *)theWindow NS_RETURNS_INNER_POINTER;
- (NSInteger)runModalSession:(NSModalSession)session;
- (void)endModalSession:(NSModalSession)session;
- (void)terminate:(nullable id)sender;

typedef NS_ENUM(NSUInteger, NSRequestUserAttentionType) {
      NSCriticalRequest = 0,
      NSInformationalRequest = 10
};

// inform the user that this application needs attention - call this method only if your application is not already active
- (NSInteger)requestUserAttention:(NSRequestUserAttentionType)requestType;
- (void)cancelUserAttentionRequest:(NSInteger)request;


- (nullable NSEvent *)nextEventMatchingMask:(NSUInteger)mask untilDate:(nullable NSDate *)expiration inMode:(NSString *)mode dequeue:(BOOL)deqFlag;
- (void)discardEventsMatchingMask:(NSUInteger)mask beforeEvent:(nullable NSEvent *)lastEvent;
- (void)postEvent:(NSEvent *)event atStart:(BOOL)flag;
@property (nullable, readonly, strong) NSEvent *currentEvent;

- (void)sendEvent:(NSEvent *)theEvent;
- (void)preventWindowOrdering;
- (nullable NSWindow *)makeWindowsPerform:(SEL)aSelector inOrder:(BOOL)flag;
@property (readonly, copy) NSArray<NSWindow *> *windows;
- (void)setWindowsNeedUpdate:(BOOL)needUpdate;
- (void)updateWindows;

@property (nullable, strong) NSMenu *mainMenu;

/* Set or get the Help menu for the app.  If a non-nil menu is set as the Help menu, Spotlight for Help will be installed in it; otherwise AppKit will install Spotlight for Help into a menu of its choosing (and that menu is not returned from -helpMenu).  If you wish to completely suppress Spotlight for Help, you can set a menu that does not appear in the menu bar.  NSApplication retains its Help menu and releases it when a different menu is set.
 
 */
@property (nullable, strong) NSMenu *helpMenu NS_AVAILABLE_MAC(10_6);

@property (null_resettable, strong) NSImage *applicationIconImage;

/* Returns the activation policy of the application.
 */
- (NSApplicationActivationPolicy)activationPolicy NS_AVAILABLE_MAC(10_6);

/* Attempts to modify the application's activation policy.  In OS X 10.9, any policy may be set; prior to 10.9, the activation policy may be changed to NSApplicationActivationPolicyProhibited or NSApplicationActivationPolicyRegular, but may not be changed to NSApplicationActivationPolicyAccessory.  This returns YES if setting the activation policy is successful, and NO if not.
 */
- (BOOL)setActivationPolicy:(NSApplicationActivationPolicy)activationPolicy NS_AVAILABLE_MAC(10_6);


@property (readonly, strong) NSDockTile *dockTile NS_AVAILABLE_MAC(10_5);

- (BOOL)sendAction:(SEL)theAction to:(nullable id)theTarget from:(nullable id)sender;
- (nullable id)targetForAction:(SEL)theAction;
- (nullable id)targetForAction:(SEL)theAction to:(nullable id)theTarget from:(nullable id)sender;
- (BOOL)tryToPerform:(SEL)anAction with:(nullable id)anObject;
- (nullable id)validRequestorForSendType:(NSString *)sendType returnType:(NSString *)returnType;

- (void)reportException:(NSException *)theException;
+ (void)detachDrawingThread:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;

/*  If an application delegate returns NSTerminateLater from -applicationShouldTerminate:, -replyToApplicationShouldTerminate: must be called with YES or NO once the application decides if it can terminate */
- (void)replyToApplicationShouldTerminate:(BOOL)shouldTerminate;

typedef NS_ENUM(NSUInteger, NSApplicationDelegateReply) {
    NSApplicationDelegateReplySuccess = 0,
    NSApplicationDelegateReplyCancel = 1,
    NSApplicationDelegateReplyFailure = 2
};

/* If an application delegate encounters an error while handling -application:openFiles: or -application:printFiles:, -replyToOpenOrPrint: should be called with NSApplicationDelegateReplyFailure.  If the user cancels the operation, NSApplicationDelegateReplyCancel should be used, and if the operation succeeds, NSApplicationDelegateReplySuccess should be used */
- (void)replyToOpenOrPrint:(NSApplicationDelegateReply)reply;

/* Opens the character palette
*/
- (void)orderFrontCharacterPalette:(nullable id)sender;

/* Gets or sets the presentationOptions that should be in effect for the system when this application is the active application.  Only certain combinations of NSApplicationPresentationOptions flags are allowed, as detailed in the AppKit Release Notes and the reference documentation for -setPresentationOptions:.  When given an invalid combination of option flags, -setPresentationOptions: raises an exception.
*/
@property NSApplicationPresentationOptions presentationOptions NS_AVAILABLE_MAC(10_6);

/* Returns the set of application presentation options that are currently in effect for the system.  These are the presentation options that have been put into effect by the currently active application.
*/
@property (readonly) NSApplicationPresentationOptions currentSystemPresentationOptions NS_AVAILABLE_MAC(10_6);

@property (readonly) NSApplicationOcclusionState occlusionState NS_AVAILABLE_MAC(10_9);

@end

@interface NSApplication(NSWindowsMenu)
@property (nullable, strong) NSMenu *windowsMenu;
- (void)arrangeInFront:(nullable id)sender;
- (void)removeWindowsItem:(NSWindow *)win;
- (void)addWindowsItem:(NSWindow *)win title:(NSString *)aString filename:(BOOL)isFilename;
- (void)changeWindowsItem:(NSWindow *)win title:(NSString *)aString filename:(BOOL)isFilename;
- (void)updateWindowsItem:(NSWindow *)win;
- (void)miniaturizeAll:(nullable id)sender;
@end

@interface NSApplication(NSFullKeyboardAccess)
/* Use this method to get the status of Full Keyboard Access, as configured in the Keyboard preference pane. You may use this status to implement your own key loop or to implement in-control tabbing behavior similar to NSTableView. Because of the nature of the preference storage, you will not be notified of changes to the key if you attempt to observe it via key-value observing; however, calling this method is fairly inexpensive, so you should always call it when you need the underlying value instead of caching it.
 */
@property (getter=isFullKeyboardAccessEnabled, readonly) BOOL fullKeyboardAccessEnabled NS_AVAILABLE_MAC(10_6);
@end

// return values for -applicationShouldTerminate:
typedef NS_ENUM(NSUInteger, NSApplicationTerminateReply) {
        NSTerminateCancel = 0,
        NSTerminateNow = 1, 
        NSTerminateLater = 2
};

// return values for -application:printFiles:withSettings:showPrintPanels:.
typedef NS_ENUM(NSUInteger, NSApplicationPrintReply) {
    NSPrintingCancelled = 0,
    NSPrintingSuccess = 1, 
    NSPrintingFailure = 3,
    NSPrintingReplyLater = 2
};

@protocol NSApplicationDelegate <NSObject>
@optional
/* 
    Allowable return values are:
        NSTerminateNow - it is ok to proceed with termination
        NSTerminateCancel - the application should not be terminated
        NSTerminateLater - it may be ok to proceed with termination later.  The application must call -replyToApplicationShouldTerminate: with YES or NO once the answer is known
            this return value is for delegates who need to provide document modal alerts (sheets) in order to decide whether to quit.
*/
- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender;
- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;
- (void)application:(NSApplication *)sender openFiles:(NSArray<NSString *> *)filenames;
- (BOOL)application:(NSApplication *)sender openTempFile:(NSString *)filename;
- (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender;
- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;
- (BOOL)application:(id)sender openFileWithoutUI:(NSString *)filename;
- (BOOL)application:(NSApplication *)sender printFile:(NSString *)filename;
- (NSApplicationPrintReply)application:(NSApplication *)application printFiles:(NSArray<NSString *> *)fileNames withSettings:(NSDictionary<NSString *, id> *)printSettings showPrintPanels:(BOOL)showPrintPanels;
- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender;
- (BOOL)applicationShouldHandleReopen:(NSApplication *)sender hasVisibleWindows:(BOOL)flag;
- (nullable NSMenu *)applicationDockMenu:(NSApplication *)sender;
- (NSError *)application:(NSApplication *)application willPresentError:(NSError *)error;

- (void)application:(NSApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken NS_AVAILABLE_MAC(10_7);
- (void)application:(NSApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error NS_AVAILABLE_MAC(10_7);
- (void)application:(NSApplication *)application didReceiveRemoteNotification:(NSDictionary<NSString *, id> *)userInfo NS_AVAILABLE_MAC(10_7);

/* Method called by -[NSApplication encodeRestorableStateWithCoder:] to give the delegate a chance to encode any additional state into the NSCoder. If the restorable state managed by the delegate changes, you must call -[NSApplication invalidateRestorableState] so that it will be re-encoded. See the header NSWindowRestoration.h for more information.
*/
- (void)application:(NSApplication *)app willEncodeRestorableState:(NSCoder *)coder NS_AVAILABLE_MAC(10_7);

/* Method called by -[NSApplication restoreStateWithCoder:] to give the delegate a chance to restore its own state, which it may decode from the NSCoder. See the header NSWindowRestoration.h for more information.
*/
- (void)application:(NSApplication *)app didDecodeRestorableState:(NSCoder *)coder NS_AVAILABLE_MAC(10_7);

/* NSUserActivity support:
 */

/*
 
 This will be called on the main thread as soon as the user indicates they want to continue an activity in your application. The NSUserActivity object may not be available instantly, so use this as an opportunity to show the user that an activity will be continued shortly. Return YES to indicate that you are doing so. Return NO (or leave it unimplemented) and AppKit/UIKit will put up a default UI.
 
 For each application:willContinueUserActivityWithType: invocation, you are guaranteed to get exactly one invocation of application:continueUserActivity:restorationHandler: on success, or application:didFailToContinueUserActivityWithType:error: if an error was encountered.
 */
- (BOOL)application:(NSApplication *)application willContinueUserActivityWithType:(NSString *)userActivityType NS_AVAILABLE_MAC(10_10);

/*
 This will be called on the main thread after the NSUserActivity object is available. Use the data you stored in the NSUserActivity object to re-create what the user was doing. Return YES to indicate that the activity was handled. Return NO (or leave it unimplemented) and AppKit will attempt to continue the user activity.
 
 You should create/fetch any restorable objects associated with the user activity, and pass them to the restorationHandler. They will then get the above restoreUserActivityState: method invoked with the user activity. Invoking the restorationHandler is optional. It may be copied and invoked later, but must be invoked on the main thread.
 
 If this user activity was created automatically by having NSUbiquitousDocumentUserActivityType in a CFBundleDocumentTypes entry, AppKit can automatically restore the NSUserActivity on OS X if NO is returned, or this method is unimplemented. It will do so by creating a document of the appropriate type using the URL stored in the userInfo under the NSUserActivityDocumentURLKey. The document will have restoreUserActivity: called on it.
 */
- (BOOL)application:(NSApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray *restorableObjects))restorationHandler NS_AVAILABLE_MAC(10_10);

/* There are instances where continuing a NSUserActivity may fail. This will get called on the main thread if it does so. If it is unimplemented, AppKit will present the error. */
- (void)application:(NSApplication *)application didFailToContinueUserActivityWithType:(NSString *)userActivityType error:(NSError *)error NS_AVAILABLE_MAC(10_10);

/* This will be called on the main thread when a user activity managed by AppKit/UIKit has been updated. You should use this as a last chance to add additional data to the userActivity. */
- (void)application:(NSApplication *)application didUpdateUserActivity:(NSUserActivity *)userActivity NS_AVAILABLE_MAC(10_10);

/* Notifications:
 */
- (void)applicationWillFinishLaunching:(NSNotification *)notification;
- (void)applicationDidFinishLaunching:(NSNotification *)notification;
- (void)applicationWillHide:(NSNotification *)notification;
- (void)applicationDidHide:(NSNotification *)notification;
- (void)applicationWillUnhide:(NSNotification *)notification;
- (void)applicationDidUnhide:(NSNotification *)notification;
- (void)applicationWillBecomeActive:(NSNotification *)notification;
- (void)applicationDidBecomeActive:(NSNotification *)notification;
- (void)applicationWillResignActive:(NSNotification *)notification;
- (void)applicationDidResignActive:(NSNotification *)notification;
- (void)applicationWillUpdate:(NSNotification *)notification;
- (void)applicationDidUpdate:(NSNotification *)notification;
- (void)applicationWillTerminate:(NSNotification *)notification;
- (void)applicationDidChangeScreenParameters:(NSNotification *)notification;
- (void)applicationDidChangeOcclusionState:(NSNotification *)notification NS_AVAILABLE_MAC(10_9);

@end

@interface NSApplication(NSServicesMenu)
@property (nullable, strong) NSMenu *servicesMenu;
- (void)registerServicesMenuSendTypes:(NSArray<NSString *> *)sendTypes returnTypes:(NSArray<NSString *> *)returnTypes;
@end

@protocol NSServicesMenuRequestor <NSObject>
@optional
- (BOOL)writeSelectionToPasteboard:(NSPasteboard *)pboard types:(NSArray<NSString *> *)types;
- (BOOL)readSelectionFromPasteboard:(NSPasteboard *)pboard;
@end

@interface NSApplication(NSServicesHandling)
@property (nullable, strong) id servicesProvider;
@end

@interface NSApplication(NSStandardAboutPanel)
- (void)orderFrontStandardAboutPanel:(nullable id)sender;
- (void)orderFrontStandardAboutPanelWithOptions:(NSDictionary<NSString *, id> *)optionsDictionary;


/* Optional keys in optionsDictionary:

@"Credits": NSAttributedString displayed in the info area of the panel. If
not specified, contents obtained from "Credits.rtf" in [NSBundle mainBundle];
if not available, blank.

@"ApplicationName": NSString displayed in place of the default app name. If
not specified, uses the value of CFBundleName (localizable). Fallback is [[NSProcessInfo processInfo] processName].

@"ApplicationIcon": NSImage displayed in place of NSApplicationIcon. If not
specified, use [NSImage imageNamed:@"NSApplicationIcon"]; if not available, generic icon.

@"Copyright": NSString containing the copyright string. If not specified,
obtain from the value of NSHumanReadableCopyright (localizable) in infoDictionary; if not available, leave blank.

@"Version": NSString containing the build version number of the application
("58.4", "1.2d3"); displayed as "Version 58.4" or "Version 1.0 (58.4) depending on the presence of ApplicationVersion. 
If not specified, obtain from the CFBundleVersion key in infoDictionary; if not specified or empty string, leave blank.

@"ApplicationVersion": NSString displayed as the marketing version  ("1.0", "Mac OS X", "3", "WebObjects 3.5", ...), before the build version.
If not specified, obtain from CFBundleShortVersionString key in infoDictionary. Prefixed with word "Version" if it looks like a number.
*/

@end

/* Bi-directional User Interface
*/

@interface NSApplication (NSApplicationLayoutDirection)
@property (readonly) NSUserInterfaceLayoutDirection userInterfaceLayoutDirection NS_AVAILABLE_MAC(10_6); // Returns the application-wide user interface layout direction.
@end

@interface NSApplication (NSRestorableUserInterface)

/* Disable or reenable relaunching this app on login, if the app was running at the time the user logged out.  These methods increment and decrement a counter respectively; if the counter is 0 at the time the user logs out, then the app may be relaunched when the user logs back in.  The counter is initially zero, so by default apps are relaunched.
 
 If your app should not be relaunched because it launches via some other mechanism (e.g. launchd), then the recommended usage is to call [NSApp disableRelaunchOnLogin] once, and never pair it with an -enable call.
 
 If your app should not be relaunched because it triggers a restart (e.g. an installer), then the recommended usage is to call [NSApp disableRelaunchOnLogin] immediately before you attempt to trigger a restart, and [NSApp enableRelaunchOnLogin] immediately after.  This is because the user may cancel restarting; if the user later restarts for another reason, then your app should be brought back.
 
 These methods are thread safe.
 */
- (void)disableRelaunchOnLogin NS_AVAILABLE_MAC(10_7);
- (void)enableRelaunchOnLogin NS_AVAILABLE_MAC(10_7);
@end

typedef NS_OPTIONS(NSUInteger, NSRemoteNotificationType) {
    NSRemoteNotificationTypeNone NS_ENUM_AVAILABLE_MAC(10_7)    = 0,
    NSRemoteNotificationTypeBadge NS_ENUM_AVAILABLE_MAC(10_7)   = 1 << 0,
    NSRemoteNotificationTypeSound NS_ENUM_AVAILABLE_MAC(10_8)   = 1 << 1,
    NSRemoteNotificationTypeAlert NS_ENUM_AVAILABLE_MAC(10_8)   = 1 << 2,
};


@interface NSApplication (NSRemoteNotifications)
- (void)registerForRemoteNotificationTypes:(NSRemoteNotificationType)types NS_AVAILABLE_MAC(10_7);
- (void)unregisterForRemoteNotifications NS_AVAILABLE_MAC(10_7);

@property (readonly) NSRemoteNotificationType enabledRemoteNotificationTypes NS_AVAILABLE_MAC(10_7);
@end

/* An Application's startup function */

APPKIT_EXTERN int NSApplicationMain(int argc, const char *argv[]);

/* NSApplicationLoad should be called when loading a Cocoa bundle in a Carbon app in order to initialize NSApplication and other Cocoa objects.  Redundant calls are ignored.
*/  
APPKIT_EXTERN BOOL NSApplicationLoad(void);

/* NSShowsServicesMenuItem() always returns YES. */
APPKIT_EXTERN BOOL NSShowsServicesMenuItem(NSString *itemName);

/* NSSetShowsServicesMenuItem() has no effect, and always returns 0. */
APPKIT_EXTERN NSInteger NSSetShowsServicesMenuItem(NSString *itemName, BOOL enabled);

/* NSUpdateDynamicServices() causes the services information for the system to be updated.  This will only be necessary if your program adds dynamic services to the system (i.e. services not found in mach-o segments of executables).
*/
APPKIT_EXTERN void NSUpdateDynamicServices(void);
APPKIT_EXTERN BOOL NSPerformService(NSString *itemName, NSPasteboard * __nullable pboard);

APPKIT_EXTERN void NSRegisterServicesProvider(id __nullable provider, NSString *name); // apps should use -setServicesProvider
APPKIT_EXTERN void NSUnregisterServicesProvider(NSString *name);

/* Notifications */
APPKIT_EXTERN NSString *NSApplicationDidBecomeActiveNotification;
APPKIT_EXTERN NSString *NSApplicationDidHideNotification;
APPKIT_EXTERN NSString *NSApplicationDidFinishLaunchingNotification;
APPKIT_EXTERN NSString *NSApplicationDidResignActiveNotification;
APPKIT_EXTERN NSString *NSApplicationDidUnhideNotification;
APPKIT_EXTERN NSString *NSApplicationDidUpdateNotification;
APPKIT_EXTERN NSString *NSApplicationWillBecomeActiveNotification;
APPKIT_EXTERN NSString *NSApplicationWillHideNotification;
APPKIT_EXTERN NSString *NSApplicationWillFinishLaunchingNotification;
APPKIT_EXTERN NSString *NSApplicationWillResignActiveNotification;
APPKIT_EXTERN NSString *NSApplicationWillUnhideNotification;
APPKIT_EXTERN NSString *NSApplicationWillUpdateNotification;
APPKIT_EXTERN NSString *NSApplicationWillTerminateNotification;
APPKIT_EXTERN NSString *NSApplicationDidChangeScreenParametersNotification;

/* User info keys for NSApplicationDidFinishLaunchingNotification */

/* The following key is present in the userInfo of NSApplicationDidFinishLaunchingNotification.  Its value is an NSNumber containing a bool.  It will be NO if the app was launched to open or print a file, to perform a Service, if the app had saved state that will be restored, or if the app launch was in some other sense not a "default" launch.  Otherwise its value will be YES.
 */
APPKIT_EXTERN NSString * const NSApplicationLaunchIsDefaultLaunchKey NS_AVAILABLE_MAC(10_7);

/* The following key is present in the userInfo of NSApplicationDidFinishLaunchingNotification. It will be present if your application was launched because a user activated a notification in the Notification Center. Its value is an NSUserNotification object. */
APPKIT_EXTERN NSString * const NSApplicationLaunchUserNotificationKey NS_AVAILABLE_MAC(10_8);

/* Deprecated Keys for NSApplicationDidFinishLaunchingNotification */
/* NSApplicationLaunchRemoteNotificationKey is unimplemented.  Please use NSApplicationLaunchUserNotificationKey to get the NSUserNotification object.  The NSUserNotification object has an isRemote property to indicate whether this application was launched as a result of a remote notification */
APPKIT_EXTERN NSString * const NSApplicationLaunchRemoteNotificationKey NS_DEPRECATED_MAC(10_7, 10_8);

/* Upon receiving this notification, you can query the NSApplication for its occlusion state. Note that this only notifies about changes in the state of the occlusion, not when the occlusion region changes. You can use this notification to increase responsiveness and save power, by halting any expensive calculations that the user can not see. */
APPKIT_EXTERN NSString * const NSApplicationDidChangeOcclusionStateNotification NS_AVAILABLE_MAC(10_9);


/* Deprecated Methods */
@interface NSApplication (NSDeprecated)

/*
 ** runModalForWindow:relativeToWindow: was deprecated in Mac OS 10.0.  
 ** Please use -[NSWindow beginSheet:completionHandler:] instead
 */
- (NSInteger)runModalForWindow:(null_unspecified NSWindow *)theWindow relativeToWindow:(null_unspecified NSWindow *)docWindow NS_DEPRECATED_MAC(10_0, 10_0);

/* 
 ** beginModalSessionForWindow:relativeToWindow: was deprecated in Mac OS 10.0.
 ** Please use -[NSWindow beginSheet:completionHandler:] instead
 */
- (NSModalSession)beginModalSessionForWindow:(null_unspecified NSWindow *)theWindow relativeToWindow:(null_unspecified NSWindow *)docWindow NS_RETURNS_INNER_POINTER NS_DEPRECATED_MAC(10_0, 10_0);

// -application:printFiles: was deprecated in Mac OS 10.4. Implement application:printFiles:withSettings:showPrintPanels: in your application delegate instead.
- (void)application:(null_unspecified NSApplication *)sender printFiles:(null_unspecified NSArray<NSString *> *)filenames NS_DEPRECATED_MAC(10_3, 10_4);

/* These constants are deprecated in 10.9 and will be formally deprecated in the following release */
enum {
    NSRunStoppedResponse NS_ENUM_DEPRECATED_MAC(10_0, 10_10, "Use NSModalResponseStop instead") = (-1000),
    NSRunAbortedResponse NS_ENUM_DEPRECATED_MAC(10_0, 10_10, "Use NSModalResponseAbort instead") = (-1001),
    NSRunContinuesResponse NS_ENUM_DEPRECATED_MAC(10_0, 10_10, "Use NSModalResponseContinue instead") = (-1002)
};

/* These methods are deprecated in 10.9 and will be formally deprecated in the following release.
 NSWindow's -beginSheet:completionHandler: and -endSheet:returnCode: should be used instead.
 NSApplication's -beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo: will continue to work as it previously did, leaking contextInfo and failing when there is already an existing sheet.
 */
- (void)beginSheet:(NSWindow *)sheet modalForWindow:(NSWindow *)docWindow modalDelegate:(nullable id)modalDelegate didEndSelector:(nullable SEL)didEndSelector contextInfo:(null_unspecified void *)contextInfo NS_DEPRECATED_MAC(10_0, 10_10, "Use -[NSWindow beginSheet:completionHandler:] instead");
- (void)endSheet:(NSWindow *)sheet NS_DEPRECATED_MAC(10_0, 10_10, "Use -[NSWindow endSheet:] instead");
- (void)endSheet:(NSWindow *)sheet returnCode:(NSInteger)returnCode NS_DEPRECATED_MAC(10_0, 10_10, "Use -[NSWindow endSheet:returnCode:] instead");


@end

NS_ASSUME_NONNULL_END
                                                                             NSApplicationScripting.h                                                                            0100644 0001750 0001750 00000003017 12567220725 035557  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSApplicationScripting.h
        AppKit Framework
        Copyright (c) 1997-2015, Apple Inc.
        All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <AppKit/NSApplication.h>

NS_ASSUME_NONNULL_BEGIN

@class NSDocument, NSWindow;

@interface NSApplication(NSScripting)

// A key value coding compliant get-accessor for the orderedDocuments to-many-relationship declared in Cocoa's definition of the Standard Suite.  Return an array of currently open scriptable documents, in a predictable order that will be meaningful to script writers.  NSApplication's implementation of this method returns pointers to all NSDocuments in the front-to-back order of each document's frontmost window.  NSDocuments that have no associated windows are at the end of the array.
@property (readonly, copy) NSArray<NSDocument *> *orderedDocuments;

// A key value coding compliant get-accessor for the orderedWindows to-many-relationship declared in Cocoa's definition of the Standard Suite.  Return an array of currently open scriptable windows, including hidden windows, but typically not includings things like panels.
@property (readonly, copy) NSArray<NSWindow *> *orderedWindows;

@end

@interface NSObject(NSApplicationScriptingDelegation)

// Return YES if the receiving delegate object can respond to key value coding messages for a specific keyed attribute, to-one relationship, or to-many relationship.  Return NO otherwise.
- (BOOL)application:(NSApplication *)sender delegateHandlesKey:(NSString *)key;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 NSArrayController.h                                                                                 0100644 0001750 0001750 00000014517 12567220725 034562  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSArrayController.h
	Application Kit
	Copyright (c) 2002-2015, Apple Inc.
	All rights reserved.
 */

#import <AppKit/NSObjectController.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSPredicate.h>


NS_ASSUME_NONNULL_BEGIN

@class NSIndexSet, NSMutableIndexSet, NSSortDescriptor;

@interface NSArrayController : NSObjectController {
@private
    void *_reserved4;
    id _rearrangementExtensions;
    NSMutableArray *_temporaryWorkObjects;
    struct __arrayControllerFlags {
        unsigned int _avoidsEmptySelection:1;
        unsigned int _preservesSelection:1;
        unsigned int _selectsInsertedObjects:1;
        unsigned int _alwaysUsesMultipleValuesMarker:1;
        unsigned int _refreshesAllModelObjects:1;
        unsigned int _filterRestrictsInsertion:1;
        unsigned int _overridesArrangeObjects:1;
        unsigned int _overridesDidChangeArrangementCriteria:1;
        unsigned int _explicitlyCannotInsert:1;
        unsigned int _generatedEmptyArray:1;
        unsigned int _isObservingKeyPathsThroughArrangedObjects:1;
        unsigned int _arrangedObjectsIsMutable:1;
        unsigned int _clearsFilterPredicateOnInsertion:1;
        unsigned int _skipSortingAfterFetch:1;
        unsigned int _automaticallyRearrangesObjects:1;
        unsigned int _reservedArrayController:17;
    } _arrayControllerFlags;
    NSUInteger _observedIndexHint;
    NSMutableIndexSet *_selectionIndexes;
    NSMutableArray *_objects;
    NSIndexSet *_cachedSelectedIndexes;
    NSArray *_cachedSelectedObjects;
    NSArray *_arrangedObjects;
}

- (void)rearrangeObjects;    // triggers rearranging the content objects for the user interface, including sorting and filtering; subclasses can override and invoke this method if any parameter that affects the arranged objects changes

@property BOOL automaticallyRearrangesObjects NS_AVAILABLE_MAC(10_5);   // default: NO

@property (nullable, readonly, copy) NSArray<NSString *> *automaticRearrangementKeyPaths NS_AVAILABLE_MAC(10_5);    // computes the array of key paths that trigger automatic rearranging from the sort descriptors and filter predicates; subclasses may override this method to customize the default behavior (for example if additional arrangement criteria are used in custom implementations of -rearrangeObjects)
- (void)didChangeArrangementCriteria NS_AVAILABLE_MAC(10_5);    // invoked by the controller itself when any criteria for arranging objects change (sort descriptors or filter predicates) to reset the key paths for automatic rearranging; subclasses should invoke this method if additional arrangement criteria are used in custom implementations of -rearrangeObjects and those criteria change

@property (copy) NSArray<NSSortDescriptor *> *sortDescriptors;

@property (nullable, strong) NSPredicate *filterPredicate;

/* Indicates whether the controller should nil out its filter predicate before inserting (or adding) new objects. When set to yes, this eliminates the problem of inserting a new object into the array that would otherwise immediately be filtered out of the array of arranged objects.
*/
@property BOOL clearsFilterPredicateOnInsertion; // default: YES

- (NSArray *)arrangeObjects:(NSArray *)objects;    // returns objects to be arranged in the user interface for the content object array objects - method can be overridden to use a different kind of sort mechanism or to filter the display objects
@property (readonly, strong) id arrangedObjects;     // array of all displayed objects (after sorting and potentially filtering)

@property BOOL avoidsEmptySelection;   // default: YES
@property BOOL preservesSelection;   // default: YES
@property BOOL selectsInsertedObjects;    // default: YES

/* Indicates whether the controller should indicate all multiple selections through the NSMultipleValuesMarker, whether the selected values are equal or not (by default, the controller will only use the NSMultipleValuesMarker if the selected objects actually have different values) - this may act as a performance enhancement in certain applications.
*/
@property BOOL alwaysUsesMultipleValuesMarker;

/* All selection modification methods returning a BOOL indicate through that flag whether changing the selection was successful (changing the selection might trigger an commitEditing call which fails and thus deny's the selection change).
*/
- (BOOL)setSelectionIndexes:(NSIndexSet *)indexes;    // to deselect all: empty index set, to select all: index set with indexes [0...count - 1]
@property (readonly, copy) NSIndexSet *selectionIndexes;
- (BOOL)setSelectionIndex:(NSUInteger)index;
@property (readonly) NSUInteger selectionIndex;
- (BOOL)addSelectionIndexes:(NSIndexSet *)indexes;
- (BOOL)removeSelectionIndexes:(NSIndexSet *)indexes;

- (BOOL)setSelectedObjects:(NSArray *)objects;
@property (null_unspecified, readonly, copy) NSArray *selectedObjects;
- (BOOL)addSelectedObjects:(NSArray *)objects;
- (BOOL)removeSelectedObjects:(NSArray *)objects;

- (void)add:(nullable id)sender;    // overridden to add a new object to the content objects and to the arranged objects
- (void)remove:(nullable id)sender;    // overridden to remove the selected objects
- (void)insert:(nullable id)sender;
@property (readonly) BOOL canInsert;    // can be used in bindings controlling the enabling of buttons, for example
- (void)selectNext:(nullable id)sender;
- (void)selectPrevious:(nullable id)sender;
@property (readonly) BOOL canSelectNext;
@property (readonly) BOOL canSelectPrevious;

- (void)addObject:(id)object;    // overridden to add to the content objects and to the arranged objects if all filters currently applied are matched
- (void)addObjects:(NSArray *)objects;
- (void)insertObject:(id)object atArrangedObjectIndex:(NSUInteger)index;    // inserts into the content objects and the arranged objects (as specified by index in the arranged objects) - will raise an exception if the object does not match all filters currently applied
- (void)insertObjects:(NSArray *)objects atArrangedObjectIndexes:(NSIndexSet *)indexes;
- (void)removeObjectAtArrangedObjectIndex:(NSUInteger)index;    // removes from the content objects and the arranged objects (as specified by index in the arranged objects)
- (void)removeObjectsAtArrangedObjectIndexes:(NSIndexSet *)indexes;
- (void)removeObject:(id)object;    // removes from the content objects and the arranged objects (if currently contained)
- (void)removeObjects:(NSArray *)objects;

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                 NSAttributedString.h                                                                                0100644 0001750 0001750 00000074267 12567220725 034746  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSAttributedString.h
        Copyright (c) 1994-2015, Apple Inc.
        All rights reserved.
 
        This file defines Application Kit extensions to NSAttributedString and NSMutableAttributedString.
*/

#import <Foundation/NSAttributedString.h>
#import <AppKit/NSFontManager.h>
#import <AppKit/NSText.h>
#import <AppKit/NSPasteboard.h>
#import <AppKit/AppKitDefines.h>
@class NSTextBlock, NSTextTable, NSTextList;
@class NSFileWrapper;
@class NSURL;

NS_ASSUME_NONNULL_BEGIN
/************************ Attributes ************************/

// Predefined character attributes for text. If the key is not in the dictionary, then use the default values as described below.
APPKIT_EXTERN NSString *  NSFontAttributeName NS_AVAILABLE(10_0, 6_0);                // NSFont, default Helvetica(Neue) 12
APPKIT_EXTERN NSString *  NSParagraphStyleAttributeName NS_AVAILABLE(10_0, 6_0);      // NSParagraphStyle, default defaultParagraphStyle
APPKIT_EXTERN NSString *  NSForegroundColorAttributeName NS_AVAILABLE(10_0, 6_0);     // NSColor, default blackColor
APPKIT_EXTERN NSString *  NSBackgroundColorAttributeName NS_AVAILABLE(10_0, 6_0);     // NSColor, default nil: no background
APPKIT_EXTERN NSString *  NSLigatureAttributeName NS_AVAILABLE(10_0, 6_0);            // NSNumber containing integer, default 1: default ligatures, 0: no ligatures
APPKIT_EXTERN NSString *  NSKernAttributeName NS_AVAILABLE(10_0, 6_0);                // NSNumber containing floating point value, in points; amount to modify default kerning. 0 means kerning is disabled.
APPKIT_EXTERN NSString *  NSStrikethroughStyleAttributeName NS_AVAILABLE(10_0, 6_0);  // NSNumber containing integer, default 0: no strikethrough
APPKIT_EXTERN NSString *  NSUnderlineStyleAttributeName NS_AVAILABLE(10_0, 6_0);      // NSNumber containing integer, default 0: no underline
APPKIT_EXTERN NSString *  NSStrokeColorAttributeName NS_AVAILABLE(10_0, 6_0);         // NSColor, default nil: same as foreground color
APPKIT_EXTERN NSString *  NSStrokeWidthAttributeName NS_AVAILABLE(10_0, 6_0);         // NSNumber containing floating point value, in percent of font point size, default 0: no stroke; positive for stroke alone, negative for stroke and fill (a typical value for outlined text would be 3.0)
APPKIT_EXTERN NSString *  NSShadowAttributeName NS_AVAILABLE(10_0, 6_0);              // NSShadow, default nil: no shadow
APPKIT_EXTERN NSString *const NSTextEffectAttributeName NS_AVAILABLE(10_10, 7_0);          // NSString, default nil: no text effect

APPKIT_EXTERN NSString *  NSAttachmentAttributeName NS_AVAILABLE(10_0, 7_0);          // NSTextAttachment, default nil
APPKIT_EXTERN NSString *  NSLinkAttributeName NS_AVAILABLE(10_0, 7_0);                // NSURL (preferred) or NSString
APPKIT_EXTERN NSString *  NSBaselineOffsetAttributeName NS_AVAILABLE(10_0, 7_0);      // NSNumber containing floating point value, in points; offset from baseline, default 0
APPKIT_EXTERN NSString *  NSUnderlineColorAttributeName NS_AVAILABLE(10_0, 7_0);      // NSColor, default nil: same as foreground color
APPKIT_EXTERN NSString *  NSStrikethroughColorAttributeName NS_AVAILABLE(10_0, 7_0);  // NSColor, default nil: same as foreground color
APPKIT_EXTERN NSString *  NSObliquenessAttributeName NS_AVAILABLE(10_0, 7_0);         // NSNumber containing floating point value; skew to be applied to glyphs, default 0: no skew
APPKIT_EXTERN NSString *  NSExpansionAttributeName NS_AVAILABLE(10_0, 7_0);           // NSNumber containing floating point value; log of expansion factor to be applied to glyphs, default 0: no expansion

APPKIT_EXTERN NSString *  NSWritingDirectionAttributeName NS_AVAILABLE(10_6, 7_0);    // NSArray of NSNumbers representing the nested levels of writing direction overrides as defined by Unicode LRE, RLE, LRO, and RLO characters.  The control characters can be obtained by masking NSWritingDirection and NSTextWritingDirection values.  LRE: NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE: NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO: NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO: NSWritingDirectionRightToLeft|NSWritingDirectionOverride,

APPKIT_EXTERN NSString *  NSVerticalGlyphFormAttributeName NS_AVAILABLE(10_7, 6_0);   // An NSNumber containing an integer value.  0 means horizontal text.  1 indicates vertical text.  If not specified, it could follow higher-level vertical orientation settings.  Currently on iOS, it's always horizontal.  The behavior for any other value is undefined.

APPKIT_EXTERN NSString *NSCursorAttributeName; // NSCursor, default IBeamCursor
APPKIT_EXTERN NSString *NSToolTipAttributeName; // NSString, default nil: no tooltip

APPKIT_EXTERN NSString *NSMarkedClauseSegmentAttributeName; // Clause segment index NSNumber (intValue). This attribute is used in marked text indicating clause segments

APPKIT_EXTERN NSString *NSTextAlternativesAttributeName NS_AVAILABLE_MAC(10_8); // An NSTextAlternatives object.  Used primarily as a temporary attribute, with primaryString equal to the substring for the range to which it is attached, and alternativeStrings representing alternatives for that string that may be presented to the user.

APPKIT_EXTERN NSString *NSSpellingStateAttributeName;  // NSSpellingStateAttributeName is used and recognized only as a temporary attribute (see NSLayoutManager.h).  It indicates that spelling and/or grammar indicators should be shown for the specified characters, default 0: no spelling or grammar indicator


APPKIT_EXTERN NSString *NSSuperscriptAttributeName; // NSNumber containing integer, default 0
APPKIT_EXTERN NSString *NSGlyphInfoAttributeName;  // NSGlyphInfo specifying glyph for the associated attribute range


/************************ Attribute values ************************/
// This defines currently supported values for NSUnderlineStyleAttributeName and NSStrikethroughStyleAttributeName. NSUnderlineStyle*, NSUnderlinePattern*, and NSUnderlineByWord are or'ed together to produce an underline style.
typedef NS_ENUM(NSInteger, NSUnderlineStyle) {
    NSUnderlineStyleNone                                    = 0x00,
    NSUnderlineStyleSingle                                  = 0x01,
    NSUnderlineStyleThick NS_ENUM_AVAILABLE(10_0, 7_0)      = 0x02,
    NSUnderlineStyleDouble NS_ENUM_AVAILABLE(10_0, 7_0)     = 0x09,

    NSUnderlinePatternSolid NS_ENUM_AVAILABLE(10_0, 7_0)      = 0x0000,
    NSUnderlinePatternDot NS_ENUM_AVAILABLE(10_0, 7_0)        = 0x0100,
    NSUnderlinePatternDash NS_ENUM_AVAILABLE(10_0, 7_0)       = 0x0200,
    NSUnderlinePatternDashDot NS_ENUM_AVAILABLE(10_0, 7_0)    = 0x0300,
    NSUnderlinePatternDashDotDot NS_ENUM_AVAILABLE(10_0, 7_0) = 0x0400,

    NSUnderlineByWord NS_ENUM_AVAILABLE(10_0, 7_0)            = 0x8000
} NS_ENUM_AVAILABLE(10_0, 6_0);

// NSWritingDirectionFormatType values used by NSWritingDirectionAttributeName. It is or'ed with either NSWritingDirectionLeftToRight or NSWritingDirectionRightToLeft. Can specify the formatting controls defined by Unicode Bidirectional Algorithm.
typedef NS_ENUM(NSInteger, NSWritingDirectionFormatType) {
    NSWritingDirectionEmbedding     = (0 << 1),
    NSWritingDirectionOverride      = (1 << 1)
} NS_ENUM_AVAILABLE(10_11, 9_0);

// NSTextEffectAttributeName values
APPKIT_EXTERN NSString *const NSTextEffectLetterpressStyle NS_AVAILABLE(10_10, 7_0);

// Flag values supported for NSSpellingStateAttributeName as of Mac OS X version 10.5.  Prior to 10.5, any non-zero value caused the spelling indicator to be shown.
enum {
    NSSpellingStateSpellingFlag NS_ENUM_AVAILABLE_MAC(10_5) = (1 << 0),
    NSSpellingStateGrammarFlag NS_ENUM_AVAILABLE_MAC(10_5)  = (1 << 1)
};

/************************ Attribute fixing ************************/

@interface NSMutableAttributedString (NSAttributedStringAttributeFixing)
// This method fixes attribute inconsistencies inside range.  It ensures NSFontAttributeName covers the characters, NSParagraphStyleAttributeName is only changing at paragraph boundaries, and NSTextAttachmentAttributeName is assigned to NSAttachmentCharacter.  NSTextStorage automatically invokes this method via -ensureAttributesAreFixedInRange:.
- (void)fixAttributesInRange:(NSRange)range NS_AVAILABLE(10_0, 7_0);

- (void)fixFontAttributeInRange:(NSRange)range;
- (void)fixParagraphStyleAttributeInRange:(NSRange)range;
- (void)fixAttachmentAttributeInRange:(NSRange)range;
@end


/************************ Document formats ************************/

// Supported document types for the NSDocumentTypeDocumentAttribute key in the document attributes dictionary.
APPKIT_EXTERN NSString *  NSPlainTextDocumentType NS_AVAILABLE(10_0, 7_0);
APPKIT_EXTERN NSString *  NSRTFTextDocumentType NS_AVAILABLE(10_0, 7_0);
APPKIT_EXTERN NSString *  NSRTFDTextDocumentType NS_AVAILABLE(10_0, 7_0);
APPKIT_EXTERN NSString *  NSHTMLTextDocumentType NS_AVAILABLE(10_0, 7_0);
APPKIT_EXTERN NSString * NSMacSimpleTextDocumentType;
APPKIT_EXTERN NSString * NSDocFormatTextDocumentType;
APPKIT_EXTERN NSString * NSWordMLTextDocumentType;
APPKIT_EXTERN NSString * NSWebArchiveTextDocumentType;
APPKIT_EXTERN NSString * NSOfficeOpenXMLTextDocumentType NS_AVAILABLE_MAC(10_5);
APPKIT_EXTERN NSString * NSOpenDocumentTextDocumentType  NS_AVAILABLE_MAC(10_5);

// Keys for NSLayoutOrientationSectionsAttribute.
APPKIT_EXTERN NSString *  NSTextLayoutSectionOrientation NS_AVAILABLE(10_7, 7_0); // NSNumber containing NSTextLayoutOrientation value. default: NSTextLayoutOrientationHorizontal
APPKIT_EXTERN NSString *  NSTextLayoutSectionRange NS_AVAILABLE(10_7, 7_0); // NSValue containing NSRange representing a character range. default: a range covering the whole document


// Keys for options and document attributes dictionaries.  They are in and out document properties used by both read/write methods.

APPKIT_EXTERN NSString *  NSDocumentTypeDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"DocumentType", one of the document types declared above.  For reader methods, this key in options can specify the document type for interpreting the contents.  Upon return, the document attributes can contain this key for indicating the actual format used to read the contents.  For write methods, this key specifies the format for generating the data.

APPKIT_EXTERN NSString *NSConvertedDocumentAttribute;  // @"Converted", NSNumber containing integer; if missing, or 0, the file was originally in the format specified by document type; if negative, the file was originally in the format specified by document type, but the conversion to NSAttributedString may have been lossy; if 1 or more, it was converted to the specified type by a filter service
APPKIT_EXTERN NSString *NSCocoaVersionDocumentAttribute;  // @"CocoaRTFVersion", NSNumber containing integer.  Stores the version of Cocoa the file was created with.  NSNumber containing float.  Absence of this value indicates file not labelled as being created by Cocoa or its predecessors.  Values less than 100 are pre-Mac OS X; 100 is Mac OS X 10.0 and 10.1; 102 is Mac OS X 10.2 and 10.3; values greater than 102 correspond to values of NSAppKitVersionNumber on 10.4 and later systems.
APPKIT_EXTERN NSString *NSFileTypeDocumentAttribute     NS_AVAILABLE_MAC(10_6);  // NSString indicating which document type was used to interpret the document, specified as a UTI; for reading, this is available along with NSDocumentTypeDocumentAttribute, but for writing the two are mutually exclusive

APPKIT_EXTERN NSString *NSTitleDocumentAttribute;  // NSString containing document title
APPKIT_EXTERN NSString *NSCompanyDocumentAttribute;  // NSString containing company or organization name
APPKIT_EXTERN NSString *NSCopyrightDocumentAttribute;  // NSString containing document copyright info
APPKIT_EXTERN NSString *NSSubjectDocumentAttribute;  // NSString containing subject of document
APPKIT_EXTERN NSString *NSAuthorDocumentAttribute;  // NSString containing author name (not necessarily same as "last editor," see below)
APPKIT_EXTERN NSString *NSKeywordsDocumentAttribute;  // NSArray of NSString, containing keywords
APPKIT_EXTERN NSString *NSCommentDocumentAttribute;  // NSString containing document comments
APPKIT_EXTERN NSString *NSEditorDocumentAttribute;  // NSString containing name of person who last edited the document
APPKIT_EXTERN NSString *NSCreationTimeDocumentAttribute;  // NSDate containing the creation date of the document; note that this is not the file system creation date of the file, but of the document, as stored in the document
APPKIT_EXTERN NSString *NSModificationTimeDocumentAttribute;  // NSDate containing the modification date of the document contents
APPKIT_EXTERN NSString *NSManagerDocumentAttribute      NS_AVAILABLE_MAC(10_5);  // NSString containing name of the author's manager
APPKIT_EXTERN NSString *NSCategoryDocumentAttribute     NS_AVAILABLE_MAC(10_6);  // NSString containing the document category

// NSPlainTextDocumentType document attributes
APPKIT_EXTERN NSString *  NSCharacterEncodingDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"CharacterEncoding", NSNumber containing integer specifying NSStringEncoding for the file; default for plain text is the default encoding.  This key in options can specify the string encoding for reading the data.  Upon return, the document attributes can contain the actual encoding used.  For writing methods, this value is used for generating the plain text data.
APPKIT_EXTERN NSString *  NSDefaultAttributesDocumentAttribute NS_AVAILABLE(10_11, 7_0);  // @"DefaultAttributes", NSDictionary containing attributes to be applied to plain files.  Used by reader methods.  This key in options can specify the default attributes applied to the entire document contents.  The document attributes can contain this key indicating the actual attributes used.


// NSRTFTextDocumentType and NSRTFDTextDocumentType document attributes
// Document dimension
// They are document attributes used by read/write methods.
APPKIT_EXTERN NSString *  NSPaperSizeDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"PaperSize", NSValue containing NSSize (in points)
APPKIT_EXTERN NSString *NSLeftMarginDocumentAttribute;  // @"LeftMargin", NSNumber containing floating point value (in points)
APPKIT_EXTERN NSString *NSRightMarginDocumentAttribute;  // @"RightMargin", NSNumber containing floating point value (in points)
APPKIT_EXTERN NSString *NSTopMarginDocumentAttribute;  // @"TopMargin", NSNumber containing floating point value (in points)
APPKIT_EXTERN NSString *NSBottomMarginDocumentAttribute;  // @"BottomMargin", NSNumber containing floating point value (in points)

APPKIT_EXTERN NSString *  NSViewSizeDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"ViewSize", NSValue containing NSSize (in points)
APPKIT_EXTERN NSString *  NSViewZoomDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"ViewZoom", NSNumber containing floating point value (100 == 100% zoom)
APPKIT_EXTERN NSString *  NSViewModeDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"ViewMode", NSNumber containing integer; 0 = normal; 1 = page layout

// Document settings
// They are document attributes used by read/write methods.
APPKIT_EXTERN NSString *  NSReadOnlyDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"ReadOnly", NSNumber containing integer; if missing, or 0 or negative, not readonly; 1 or more, readonly. Note that this has nothing to do with the file system protection on the file, but instead, on how the file should be displayed to the user
APPKIT_EXTERN NSString *  NSBackgroundColorDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"BackgroundColor", NSColor, representing the document-wide page background color
APPKIT_EXTERN NSString *  NSHyphenationFactorDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"HyphenationFactor", NSNumber containing floating point value (0=off, 1=full hyphenation)
APPKIT_EXTERN NSString *  NSDefaultTabIntervalDocumentAttribute NS_AVAILABLE(10_0, 7_0);  // @"DefaultTabInterval", NSNumber containing floating point value, representing the document-wide default tab stop interval, in points
APPKIT_EXTERN NSString *  NSTextLayoutSectionsAttribute NS_AVAILABLE(10_7, 7_0);  // NSArray of dictionaries.  Each dictionary describing a layout orientation section.  The dictionary can have two attributes: NSTextLayoutSectionOrientation and NSTextLayoutSectionRange.  When there is a gap between sections, it's assumed to have NSTextLayoutOrientationHorizontal.

// NSHTMLTextDocumentType document attributes
// Additional document attributes added in 10.4, for HTML writing only.  These provide control over the form of generated HTML.  NSExcludedElementsDocumentAttribute allows control over the tags used.  The recognized values in the NSExcludedElementsDocumentAttribute array are (case-insensitive) HTML tags, plus DOCTYPE (representing a doctype declaration) and XML (representing an XML declaration).  By default, if this attribute is not present, the excluded elements will be those deprecated in HTML 4 (APPLET, BASEFONT, CENTER, DIR, FONT, ISINDEX, MENU, S, STRIKE, and U) plus XML.  If XML is on the list, HTML forms will be used; if XML is not on the list, XHTML forms will be used where there is a distinction.  Either NSCharacterEncodingDocumentAttribute or NSTextEncodingNameDocumentAttribute may be used to control the encoding used for generated HTML; character entities will be used for characters not representable in the specified encoding.  Finally, NSPrefixSpacesDocumentAttribute allows some control over formatting.
APPKIT_EXTERN NSString *NSExcludedElementsDocumentAttribute;  // for HTML writing only; NSArray containing NSStrings, representing HTML elements not to be used in generated HTML
APPKIT_EXTERN NSString *NSTextEncodingNameDocumentAttribute;  // for HTML writing only; NSString containing the name, IANA or otherwise, of a text encoding to be used; mutually exclusive with NSCharacterEncodingDocumentAttribute
APPKIT_EXTERN NSString *NSPrefixSpacesDocumentAttribute;  // for HTML writing only; NSNumber containing integer, default 0, representing the number of spaces per level by which to indent certain nested HTML elements

// The following are keys for various options that can be specified in the options dictionaries for the text import APIs below.  Except for NSTextSizeMultiplierDocumentOption and NSFileTypeDocumentOption, the values have been recognized for some time, but the actual identifier shown below was added in 10.4. If you want your app to run on earlier systems, you need to continue using the actual string value that these identifiers represent. The actual string value is specified in the comments below.
APPKIT_EXTERN NSString *NSDocumentTypeDocumentOption           ;  // @"DocumentType", NSString indicating a document type to be forced when loading the document, specified as one of the NSDocumentTypeDocumentAttribute constants listed above
APPKIT_EXTERN NSString *NSDefaultAttributesDocumentOption      ;  // @"DefaultAttributes", for plain text only; NSDictionary containing attributes to be applied to plain files
APPKIT_EXTERN NSString *NSCharacterEncodingDocumentOption      ;  // @"CharacterEncoding", for plain text and HTML; NSNumber containing integer specifying NSStringEncoding to be used to interpret the file
APPKIT_EXTERN NSString *NSTextEncodingNameDocumentOption       ;  // @"TextEncodingName", for HTML only; NSString containing a name, IANA or otherwise, specifying an encoding to be used to interpret the file; mutually exclusive with NSCharacterEncodingDocumentOption
APPKIT_EXTERN NSString *NSBaseURLDocumentOption                ;  // @"BaseURL", for HTML only; NSURL containing a URL to be treated as the base URL for the document
APPKIT_EXTERN NSString *NSTimeoutDocumentOption                ;  // @"Timeout", for HTML only; NSNumber containing floating point value; time in seconds to wait for a document to finish loading; if not present or not positive, a default timeout will be used
APPKIT_EXTERN NSString *NSWebPreferencesDocumentOption         ;  // @"WebPreferences", for HTML only; WebPreferences; specifies a WebPreferences object describing a set of preferences; if not present, a default set of preferences will be used
APPKIT_EXTERN NSString *NSWebResourceLoadDelegateDocumentOption;  // @"WebResourceLoadDelegate", for HTML only; NSObject; specifies an object to serve as the WebResourceLoadDelegate; if not present, a default delegate will be used that will permit the loading of subsidiary resources but will not respond to authentication challenges
APPKIT_EXTERN NSString *NSTextSizeMultiplierDocumentOption     ;  // for HTML only; NSNumber containing floating point value, default 1.0; specifies a scale factor for font sizes, corresponding to WebView's textSizeMultiplier
APPKIT_EXTERN NSString *NSFileTypeDocumentOption                NS_AVAILABLE_MAC(10_6);  // NSString indicating a document type to be forced when loading the document, specified as a UTI string; mutually exclusive with NSDocumentTypeDocumentOption

// In Mac OS X 10.4 and later, WebKit is always used for HTML documents, and all of the above options are recognized.  In Mac OS X 10.3, there is an additional options key, @"UseWebKit" (NSNumber containing integer; if present and positive, specifies that WebKit-based HTML importing is to be used).  In Mac OS X 10.3, the Timeout, WebPreferences, and WebResourceLoadDelegate options are recognized only when WebKit-based HTML importing is used.


@interface NSAttributedString (NSAttributedStringDocumentFormats)
// Methods initializing the receiver contents with an external document data.  options specify document attributes for interpreting the document contents.  NSDocumentTypeDocumentAttribute, NSCharacterEncodingDocumentAttribute, and NSDefaultAttributesDocumentAttribute are supported options key.  When they are not specified, these methods will examine the data and do their best to detect the appropriate attributes.  If dict is non-NULL, it will return a dictionary with various document-wide attributes accessible via NS...DocumentAttribute keys.
- (nullable instancetype)initWithURL:(NSURL *)url options:(NSDictionary<NSString *, id> *)options documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict error:(NSError **)error NS_AVAILABLE(10_11, 9_0);
- (nullable instancetype)initWithData:(NSData *)data options:(NSDictionary<NSString *, id> *)options documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict error:(NSError **)error NS_AVAILABLE(10_0, 7_0);

// Generates an NSData object for the receiver contents in range.  It requires a document attributes dict specifying at least the NSDocumentTypeDocumentAttribute to determine the format to be written.
- (nullable NSData *)dataFromRange:(NSRange)range documentAttributes:(NSDictionary<NSString *, id> *)dict error:(NSError **)error NS_AVAILABLE(10_0, 7_0);

// Returns an NSFileWrapper object for the receiver contents in range.  It requires a document attributes dict specifying at least the NSDocumentTypeDocumentAttribute to determine the format to be written.  The method returns a directory file wrapper for those document types represented by a file package such as NSRTFDTextDocumentType; otherwise, it returns a regular-file file wrapper.
- (nullable NSFileWrapper *)fileWrapperFromRange:(NSRange)range documentAttributes:(NSDictionary<NSString *, id> *)dict error:(NSError **)error NS_AVAILABLE(10_0, 7_0);

- (nullable instancetype)initWithRTF:(NSData *)data documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict;
- (nullable instancetype)initWithRTFD:(NSData *)data documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict;
- (nullable instancetype)initWithHTML:(NSData *)data documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict;
- (nullable instancetype)initWithHTML:(NSData *)data baseURL:(NSURL *)base documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict;
- (nullable instancetype)initWithDocFormat:(NSData *)data documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict;
- (nullable instancetype)initWithHTML:(NSData *)data options:(NSDictionary *)options documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict;
- (nullable instancetype)initWithRTFDFileWrapper:(NSFileWrapper *)wrapper documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict;
- (nullable NSData *)RTFFromRange:(NSRange)range documentAttributes:(NSDictionary<NSString *, id> *)dict;
- (nullable NSData *)RTFDFromRange:(NSRange)range documentAttributes:(NSDictionary<NSString *, id> *)dict;
- (nullable NSFileWrapper *)RTFDFileWrapperFromRange:(NSRange)range documentAttributes:(NSDictionary<NSString *, id> *)dict;
- (nullable NSData *)docFormatFromRange:(NSRange)range documentAttributes:(NSDictionary<NSString *, id> *)dict;
@end

@interface NSMutableAttributedString (NSMutableAttributedStringDocumentFormats)
// Methods replacing the receiver contents with an external document data.  options specify document attributes for interpreting the document contents.  NSDocumentTypeDocumentAttribute, NSCharacterEncodingDocumentAttribute, and NSDefaultAttributesDocumentAttribute are supported options key.  When they are not specified, these methods will examine the data and do their best to detect the appropriate attributes.  If dict is non-NULL, it will return a dictionary with various document-wide attributes accessible via NS...DocumentAttribute keys.
- (BOOL)readFromURL:(NSURL *)url options:(NSDictionary<NSString *, id> *)opts documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict error:(NSError **)error  NS_AVAILABLE(10_11, 9_0);
- (BOOL)readFromData:(NSData *)data options:(NSDictionary<NSString *, id> *)opts documentAttributes:(NSDictionary<NSString *, id> * __nullable * __nullable)dict error:(NSError **)error NS_AVAILABLE(10_0, 7_0);
@end


/************************ Misc methods ************************/
@interface NSAttributedString (NSAttributedStringKitAdditions)
// Attributes which should be copied/pasted with "copy font".
- (NSDictionary<NSString *, id> *)fontAttributesInRange:(NSRange)range;

// Attributes which should be copied/pasted with "copy ruler".
- (NSDictionary<NSString *, id> *)rulerAttributesInRange:(NSRange)range;

// Returns YES if the receiver contains a property configured (NSAttachmentAttributeName with NSAttachmentCharacter) in range
- (BOOL)containsAttachmentsInRange:(NSRange)range NS_AVAILABLE(10_11, 9_0);

// Returns NSNotFound if no line break location found in the specified range; otherwise returns the index of the first character that should go on the NEXT line.
- (NSUInteger)lineBreakBeforeIndex:(NSUInteger)location withinRange:(NSRange)aRange;
- (NSUInteger)lineBreakByHyphenatingBeforeIndex:(NSUInteger)location withinRange:(NSRange)aRange;

- (NSRange)doubleClickAtIndex:(NSUInteger)location;
- (NSUInteger)nextWordFromIndex:(NSUInteger)location forward:(BOOL)isForward;


// Convenience methods for calculating the range of an individual text block, range of an entire table, range of a list, and the index within a list.
- (NSRange)rangeOfTextBlock:(NSTextBlock *)block atIndex:(NSUInteger)location;
- (NSRange)rangeOfTextTable:(NSTextTable *)table atIndex:(NSUInteger)location;
- (NSRange)rangeOfTextList:(NSTextList *)list atIndex:(NSUInteger)location;
- (NSInteger)itemNumberInTextList:(NSTextList *)list atIndex:(NSUInteger)location;
@end

@interface NSAttributedString (NSAttributedStringPasteboardAdditions)  <NSPasteboardReading, NSPasteboardWriting>
// Methods to determine what types can be loaded as NSAttributedStrings.
+ (NSArray<NSString *> *)textTypes NS_AVAILABLE_MAC(10_5);
+ (NSArray<NSString *> *)textUnfilteredTypes NS_AVAILABLE_MAC(10_5);
@end

@interface NSMutableAttributedString (NSMutableAttributedStringKitAdditions)
- (void)superscriptRange:(NSRange)range;
- (void)subscriptRange:(NSRange)range;
- (void)unscriptRange:(NSRange)range;
- (void)applyFontTraits:(NSFontTraitMask)traitMask range:(NSRange)range;
- (void)setAlignment:(NSTextAlignment)alignment range:(NSRange)range;
- (void)setBaseWritingDirection:(NSWritingDirection)writingDirection range:(NSRange)range;
@end

/************************ Deprecated ************************/
APPKIT_EXTERN NSString *NSCharacterShapeAttributeName NS_DEPRECATED_MAC(10_0, 10_11, "This attribute is bound to a specific implementation of ATS feature and not generically supported by wide range of fonts. The majority of characters accessed through this API are now encoded in the Unicode standard. Use the CTFont feature API for fine control over character shape choices.");
APPKIT_EXTERN NSString *NSUsesScreenFontsDocumentAttribute NS_DEPRECATED_MAC(10_8, 10_11);


enum {
    NSNoUnderlineStyle NS_ENUM_DEPRECATED_MAC(10_0, 10_9, "Use NSUnderlineStyleNone instead") = 0,
    NSSingleUnderlineStyle NS_ENUM_DEPRECATED_MAC(10_0, 10_9, "Use NSUnderlineStyleSingle instead")
};

APPKIT_EXTERN NSUInteger NSUnderlineStrikethroughMask NS_DEPRECATED_MAC(10_0, 10_9, "Use NSStrikethroughStyleAttributeName instead");
APPKIT_EXTERN NSUInteger NSUnderlineByWordMask NS_DEPRECATED_MAC(10_0, 10_11, "Use NSUnderlineByWord instead");

@interface NSAttributedString(NSDeprecatedKitAdditions)
// This property is soft deprecated starting with OS X 10.11. It will be officially deprecated in a future release. Use -containsAttachmentsInRange: instead
@property (readonly) BOOL containsAttachments;

+ (NSArray *)textFileTypes NS_DEPRECATED_MAC(10_1, 10_5);
+ (NSArray *)textPasteboardTypes NS_DEPRECATED_MAC(10_1, 10_5);
+ (NSArray *)textUnfilteredFileTypes NS_DEPRECATED_MAC(10_1, 10_5);
+ (NSArray *)textUnfilteredPasteboardTypes NS_DEPRECATED_MAC(10_1, 10_5);

- (nullable instancetype)initWithURL:(NSURL *)url documentAttributes:(NSDictionary* __nullable * __nullable)dict NS_DEPRECATED_MAC(10_0, 10_11, "Use -initWithURL:options:documentAttributes:error: instead");
- (nullable instancetype)initWithPath:(NSString *)path documentAttributes:(NSDictionary* __nullable * __nullable)dict NS_DEPRECATED_MAC(10_0, 10_11, "Use -initWithURL:options:documentAttributes:error: instead");

- (nullable NSURL *)URLAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)effectiveRange NS_DEPRECATED_MAC(10_5, 10_11, "Use NSDataDetector instead");
@end

@interface NSMutableAttributedString (NSDeprecatedKitAdditions)
- (BOOL)readFromURL:(NSURL *)url options:(NSDictionary *)options documentAttributes:(NSDictionary* __nullable * __nullable)dict NS_DEPRECATED_MAC(10_0, 10_11, "Use -readFromURL:options:documentAttributes:error: instead");
- (BOOL)readFromData:(NSData *)data options:(NSDictionary *)options documentAttributes:(NSDictionary* __nullable * __nullable)dict NS_DEPRECATED_MAC(10_0, 10_11, "Use -readFromData:options:documentAttributes:error: instead");
@end
NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                         NSBezierPath.h                                                                                      0100644 0001750 0001750 00000014065 12567220725 033473  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSBezierPath.h
        Application Kit
        Copyright (c) 1997-2015, Apple Inc.
        All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSGeometry.h>
#import <AppKit/NSFont.h>

NS_ASSUME_NONNULL_BEGIN

@class NSAffineTransform;

typedef NS_ENUM(NSUInteger, NSLineCapStyle) {
    NSButtLineCapStyle = 0,
    NSRoundLineCapStyle = 1,
    NSSquareLineCapStyle = 2
};

typedef NS_ENUM(NSUInteger, NSLineJoinStyle) {
    NSMiterLineJoinStyle = 0,
    NSRoundLineJoinStyle = 1,
    NSBevelLineJoinStyle = 2
};

typedef NS_ENUM(NSUInteger, NSWindingRule) {
    NSNonZeroWindingRule = 0,
    NSEvenOddWindingRule = 1
};

typedef NS_ENUM(NSUInteger, NSBezierPathElement) {
    NSMoveToBezierPathElement,
    NSLineToBezierPathElement,
    NSCurveToBezierPathElement,
    NSClosePathBezierPathElement
};

@interface NSBezierPath : NSObject <NSCopying, NSCoding>
{
    @private
    NSInteger _elementCount;
    NSInteger _elementMax;
    struct PATHSEGMENT *_head;
    NSInteger _lastSubpathIndex;
    void *_extraSegments;
    CGFloat _lineWidth;
    NSRect _controlPointBounds;
    CGFloat _miterLimit;
    CGFloat _flatness;
    CGFloat *_dashedLinePattern;
    NSUInteger _dashedLineCount;
    CGFloat _dashedLinePhase;
    void *_path;
    NSInteger _extraSegmentCount;
    NSInteger _extraSegmentMax;
#if !__LP64__    
    id _private[2];
#endif
    struct {
        unsigned int _flags:8;
        unsigned int _pathState:2;

        unsigned int _unused:22;
    } _bpFlags;
}

// Creating common paths.

+ (NSBezierPath *)bezierPath;
+ (NSBezierPath *)bezierPathWithRect:(NSRect)rect;
+ (NSBezierPath *)bezierPathWithOvalInRect:(NSRect)rect;
+ (NSBezierPath *)bezierPathWithRoundedRect:(NSRect)rect xRadius:(CGFloat)xRadius yRadius:(CGFloat)yRadius NS_AVAILABLE_MAC(10_5);

// Immediate mode drawing of common paths.

+ (void)fillRect:(NSRect)rect;
+ (void)strokeRect:(NSRect)rect;
+ (void)clipRect:(NSRect)rect;
+ (void)strokeLineFromPoint:(NSPoint)point1 toPoint:(NSPoint)point2;
+ (void)drawPackedGlyphs:(const char *)packedGlyphs atPoint:(NSPoint)point;

// Default path rendering parameters.

+ (void)setDefaultMiterLimit:(CGFloat)limit;
+ (CGFloat)defaultMiterLimit;
+ (void)setDefaultFlatness:(CGFloat)flatness;
+ (CGFloat)defaultFlatness;

+ (void)setDefaultWindingRule:(NSWindingRule)windingRule;
+ (NSWindingRule)defaultWindingRule;
+ (void)setDefaultLineCapStyle:(NSLineCapStyle)lineCapStyle;
+ (NSLineCapStyle)defaultLineCapStyle;
+ (void)setDefaultLineJoinStyle:(NSLineJoinStyle)lineJoinStyle;
+ (NSLineJoinStyle)defaultLineJoinStyle;
+ (void)setDefaultLineWidth:(CGFloat)lineWidth;
+ (CGFloat)defaultLineWidth;

// Path construction.

- (void)moveToPoint:(NSPoint)point;
- (void)lineToPoint:(NSPoint)point;
- (void)curveToPoint:(NSPoint)endPoint
       controlPoint1:(NSPoint)controlPoint1
       controlPoint2:(NSPoint)controlPoint2;
- (void)closePath;

- (void)removeAllPoints;

// Relative path construction.

- (void)relativeMoveToPoint:(NSPoint)point;
- (void)relativeLineToPoint:(NSPoint)point;
- (void)relativeCurveToPoint:(NSPoint)endPoint
	       controlPoint1:(NSPoint)controlPoint1
	       controlPoint2:(NSPoint)controlPoint2;

// Path rendering parameters.

@property CGFloat lineWidth;
@property NSLineCapStyle lineCapStyle;
@property NSLineJoinStyle lineJoinStyle;
@property NSWindingRule windingRule;
@property CGFloat miterLimit;
@property CGFloat flatness;
- (void)getLineDash:(nullable CGFloat *)pattern count:(nullable NSInteger *)count phase:(nullable CGFloat *)phase;
- (void)setLineDash:(nullable const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase;

// Path operations.

- (void)stroke;
- (void)fill;
- (void)addClip;
- (void)setClip;

// Path modifications.

@property (readonly, copy) NSBezierPath *bezierPathByFlatteningPath;
@property (readonly, copy) NSBezierPath *bezierPathByReversingPath;

// Applying transformations.

- (void)transformUsingAffineTransform:(NSAffineTransform *)transform;

// Path info

@property (getter=isEmpty, readonly) BOOL empty;
@property (readonly) NSPoint currentPoint;
@property (readonly) NSRect controlPointBounds;
@property (readonly) NSRect bounds;

// Elements.

@property (readonly) NSInteger elementCount;

// `points' should contain space for at least three points.  `points'
// may be NULL.  In the case of NSCurveToBezierPathElement, the order
// of the points is controlPoint1 (points[0]), controlPoint2 (points[1]),
// endPoint (points[2]).
- (NSBezierPathElement)elementAtIndex:(NSInteger)index
		     associatedPoints:(nullable NSPointArray)points;
// As above with points == NULL.
- (NSBezierPathElement)elementAtIndex:(NSInteger)index;
- (void)setAssociatedPoints:(nullable NSPointArray)points atIndex:(NSInteger)index;

// Appending common paths

- (void)appendBezierPath:(NSBezierPath *)path;
- (void)appendBezierPathWithRect:(NSRect)rect;
- (void)appendBezierPathWithPoints:(NSPointArray)points count:(NSInteger)count;
- (void)appendBezierPathWithOvalInRect:(NSRect)rect;
- (void)appendBezierPathWithArcWithCenter:(NSPoint)center radius:(CGFloat)radius
			       startAngle:(CGFloat)startAngle
				 endAngle:(CGFloat)endAngle
				clockwise:(BOOL)clockwise;
// As above with clockwise == NO. */	
- (void)appendBezierPathWithArcWithCenter:(NSPoint)center radius:(CGFloat)radius
			       startAngle:(CGFloat)startAngle
				 endAngle:(CGFloat)endAngle;
- (void)appendBezierPathWithArcFromPoint:(NSPoint)point1
				 toPoint:(NSPoint)point2
				  radius:(CGFloat)radius;
- (void)appendBezierPathWithGlyph:(NSGlyph)glyph inFont:(NSFont *)font;
- (void)appendBezierPathWithGlyphs:(NSGlyph *)glyphs count:(NSInteger)count
			    inFont:(NSFont *)font;
- (void)appendBezierPathWithPackedGlyphs:(const char *)packedGlyphs;
// Appends paths for a rounded rectangle.
- (void)appendBezierPathWithRoundedRect:(NSRect)rect xRadius:(CGFloat)xRadius yRadius:(CGFloat)yRadius NS_AVAILABLE_MAC(10_5);

// Hit detection.
- (BOOL)containsPoint:(NSPoint)point;
@end

@interface NSBezierPath (NSBezierPathDeprecated)
- (BOOL)cachesBezierPath NS_DEPRECATED_MAC(10_0, 10_0);
- (void)setCachesBezierPath:(BOOL)flag NS_DEPRECATED_MAC(10_0, 10_0);
@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                                                                                                                                           NSBitmapImageRep.h                                                                                  0100644 0001750 0001750 00000020775 12567220725 034271  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSBitmapImageRep.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <AppKit/NSImageRep.h>
#import <ApplicationServices/ApplicationServices.h>

NS_ASSUME_NONNULL_BEGIN

@class CIImage;
@class NSColor;
@class NSColorSpace;

typedef NS_ENUM(NSUInteger, NSTIFFCompression) {
    NSTIFFCompressionNone		= 1,
    NSTIFFCompressionCCITTFAX3		= 3,		/* 1 bps only */
    NSTIFFCompressionCCITTFAX4		= 4,		/* 1 bps only */
    NSTIFFCompressionLZW		= 5,
    NSTIFFCompressionJPEG		= 6,		/* No longer supported for input or output */
    NSTIFFCompressionNEXT		= 32766,	/* Input only */
    NSTIFFCompressionPackBits		= 32773,
    NSTIFFCompressionOldJPEG		= 32865		/* No longer supported for input or output */
};

typedef NS_ENUM(NSUInteger, NSBitmapImageFileType) {
    NSTIFFFileType,
    NSBMPFileType,
    NSGIFFileType,
    NSJPEGFileType,
    NSPNGFileType,
    NSJPEG2000FileType
};

typedef NS_ENUM(NSInteger, NSImageRepLoadStatus) {
    NSImageRepLoadStatusUnknownType     = -1, // not enough data to determine image format. please feed me more data
    NSImageRepLoadStatusReadingHeader   = -2, // image format known, reading header. not yet valid. more data needed
    NSImageRepLoadStatusWillNeedAllData = -3, // can't read incrementally. will wait for complete data to become avail.
    NSImageRepLoadStatusInvalidData     = -4, // image decompression encountered error.
    NSImageRepLoadStatusUnexpectedEOF   = -5, // ran out of data before full image was decompressed.
    NSImageRepLoadStatusCompleted       = -6  // all is well, the full pixelsHigh image is valid.
};

typedef NS_OPTIONS(NSUInteger, NSBitmapFormat) {
    NSAlphaFirstBitmapFormat            = 1 << 0,       // 0 means is alpha last (RGBA, CMYKA, etc.)
    NSAlphaNonpremultipliedBitmapFormat = 1 << 1,       // 0 means is premultiplied
    NSFloatingPointSamplesBitmapFormat  = 1 << 2,	// 0 is integer
    
    NS16BitLittleEndianBitmapFormat NS_ENUM_AVAILABLE_MAC(10_10) = (1 << 8),
    NS32BitLittleEndianBitmapFormat NS_ENUM_AVAILABLE_MAC(10_10) = (1 << 9),
    NS16BitBigEndianBitmapFormat NS_ENUM_AVAILABLE_MAC(10_10) = (1 << 10),
    NS32BitBigEndianBitmapFormat NS_ENUM_AVAILABLE_MAC(10_10) = (1 << 11)
};

APPKIT_EXTERN NSString *NSImageCompressionMethod;	// TIFF input/output (NSTIFFCompression in NSNumber)
APPKIT_EXTERN NSString *NSImageCompressionFactor;	// TIFF/JPEG input/output (float in NSNumber)
APPKIT_EXTERN NSString *NSImageDitherTransparency;	// GIF output (BOOL in NSNumber)
APPKIT_EXTERN NSString *NSImageRGBColorTable;		// GIF input/output (packed RGB in NSData)
APPKIT_EXTERN NSString *NSImageInterlaced;		// PNG output (BOOL in NSNumber)
APPKIT_EXTERN NSString *NSImageColorSyncProfileData;	// TIFF,GIF input/output (NSData)
APPKIT_EXTERN NSString *NSImageFrameCount;	// GIF input (int in NSNumber) (read-only)
APPKIT_EXTERN NSString *NSImageCurrentFrame;	// GIF input (int in NSNumber)
APPKIT_EXTERN NSString *NSImageCurrentFrameDuration;	// GIF input (float in NSNumber) (read-only)
APPKIT_EXTERN NSString *NSImageLoopCount            ;	// GIF input (int in NSNumber) (read-only)
APPKIT_EXTERN NSString *NSImageGamma                ;	// PNG input/output (float in NSNumber)
APPKIT_EXTERN NSString *NSImageProgressive          ;	// JPEG input/output (BOOL in NSNumber)
APPKIT_EXTERN NSString *NSImageEXIFData             ;	// JPEG input/output (NSDictionary)
APPKIT_EXTERN NSString *NSImageFallbackBackgroundColor  NS_AVAILABLE_MAC(10_5); // JPEG output (NSColor)

@interface NSBitmapImageRep : NSImageRep <NSSecureCoding> {
    /*All instance variables are private*/
    struct __bitmapRepFlags {
        unsigned int bitsPerPixel:8;	
	unsigned int isPlanar:1;
	unsigned int explicitPlanes:1;
	unsigned int imageSourceIsIndexed:1;
	unsigned int dataLoaded:1;
        unsigned int colorModel:4;
        unsigned int tierTwoInfoIsLoaded:1;
        unsigned int respectO:1;
        unsigned int compressionFactor:14;
        unsigned int imageNumber:8;
        unsigned int bitmapFormat:3;
        unsigned int cgImageIsPrimary:1;
	unsigned int compression:20;
    } _moreRepFlags;
    unsigned int _bytesPerRow;
    volatile id _dataObj;
    NSData *_tiffData;
    id _properties;
}

- (nullable instancetype)initWithFocusedViewRect:(NSRect)rect;

- (nullable instancetype)initWithBitmapDataPlanes:(unsigned char *__nullable *__nullable)planes pixelsWide:(NSInteger)width pixelsHigh:(NSInteger)height bitsPerSample:(NSInteger)bps samplesPerPixel:(NSInteger)spp hasAlpha:(BOOL)alpha isPlanar:(BOOL)isPlanar colorSpaceName:(NSString *)colorSpaceName bytesPerRow:(NSInteger)rBytes bitsPerPixel:(NSInteger)pBits;
- (nullable instancetype)initWithBitmapDataPlanes:(unsigned char *__nullable *__nullable)planes pixelsWide:(NSInteger)width pixelsHigh:(NSInteger)height bitsPerSample:(NSInteger)bps samplesPerPixel:(NSInteger)spp hasAlpha:(BOOL)alpha isPlanar:(BOOL)isPlanar colorSpaceName:(NSString *)colorSpaceName  bitmapFormat:(NSBitmapFormat)bitmapFormat bytesPerRow:(NSInteger)rBytes bitsPerPixel:(NSInteger)pBits;
- (instancetype)initWithCGImage:(CGImageRef)cgImage NS_AVAILABLE_MAC(10_5);
- (instancetype)initWithCIImage:(CIImage *)ciImage NS_AVAILABLE_MAC(10_5);

+ (NSArray<NSImageRep *> *)imageRepsWithData:(NSData *)data;	/* some file formats can contain multiple images */

+ (nullable instancetype)imageRepWithData:(NSData *)data;	/* Convenience of initWithData: */
- (nullable instancetype)initWithData:(NSData *)data;

@property (nullable, readonly) unsigned char *bitmapData NS_RETURNS_INNER_POINTER;
- (void)getBitmapDataPlanes:(unsigned char *__nullable *__nonnull)data;

@property (getter=isPlanar, readonly) BOOL planar;
@property (readonly) NSInteger samplesPerPixel;
@property (readonly) NSInteger bitsPerPixel;
@property (readonly) NSInteger bytesPerRow;
@property (readonly) NSInteger bytesPerPlane;
@property (readonly) NSInteger numberOfPlanes;
@property (readonly) NSBitmapFormat bitmapFormat;

- (void)getCompression:(nullable NSTIFFCompression *)compression factor:(nullable float *)factor;
- (void)setCompression:(NSTIFFCompression)compression factor:(float)factor;

@property (nullable, readonly, copy) NSData *TIFFRepresentation;
- (nullable NSData *)TIFFRepresentationUsingCompression:(NSTIFFCompression)comp factor:(float)factor;

+ (nullable NSData *)TIFFRepresentationOfImageRepsInArray:(NSArray<NSImageRep *> *)array;
+ (nullable NSData *)TIFFRepresentationOfImageRepsInArray:(NSArray<NSImageRep *> *)array usingCompression:(NSTIFFCompression)comp factor:(float)factor;

+ (void)getTIFFCompressionTypes:(const NSTIFFCompression * __nullable * __nonnull)list count:(NSInteger *)numTypes;
+ (nullable NSString *)localizedNameForTIFFCompressionType:(NSTIFFCompression)compression;
- (BOOL)canBeCompressedUsing:(NSTIFFCompression)compression;

/* Support for colorization of grayscale images.  Maps the image such that:
Gray value of midPoint -> midPointColor, black -> shadowColor, white -> lightColor.
Works on images with 8-bit SPP; thus either 8-bit gray or 24-bit color (with optional alpha).
*/
- (void)colorizeByMappingGray:(CGFloat)midPoint toColor:(nullable NSColor *)midPointColor blackMapping:(nullable NSColor *)shadowColor whiteMapping:(nullable NSColor *)lightColor;

- (instancetype)initForIncrementalLoad;
- (NSInteger)incrementalLoadFromData:(NSData*)data complete:(BOOL)complete;

- (void)setColor:(NSColor*)color atX:(NSInteger)x y:(NSInteger)y;
- (nullable NSColor *)colorAtX:(NSInteger)x y:(NSInteger)y;

- (void)getPixel:(NSUInteger[])p atX:(NSInteger)x y:(NSInteger)y;
- (void)setPixel:(NSUInteger[])p atX:(NSInteger)x y:(NSInteger)y;

@property (nullable, readonly) CGImageRef CGImage NS_AVAILABLE_MAC(10_5);


@property (readonly, strong) NSColorSpace *colorSpace NS_AVAILABLE_MAC(10_6);

- (nullable NSBitmapImageRep *)bitmapImageRepByConvertingToColorSpace:(NSColorSpace *)targetSpace renderingIntent:(NSColorRenderingIntent)renderingIntent NS_AVAILABLE_MAC(10_6);
- (nullable NSBitmapImageRep *)bitmapImageRepByRetaggingWithColorSpace:(NSColorSpace *)newSpace NS_AVAILABLE_MAC(10_6);

@end


@interface NSBitmapImageRep (NSBitmapImageFileTypeExtensions)

+ (nullable NSData *)representationOfImageRepsInArray:(NSArray<NSImageRep *> *)imageReps usingType:(NSBitmapImageFileType)storageType properties:(NSDictionary<NSString *, id> *)properties;

- (nullable NSData *)representationUsingType:(NSBitmapImageFileType)storageType properties:(NSDictionary<NSString *, id> *)properties;

- (void)setProperty:(NSString *)property withValue:(nullable id)value;
- (nullable id)valueForProperty:(NSString *)property;

@end

NS_ASSUME_NONNULL_END
   NSBox.h                                                                                             0100644 0001750 0001750 00000006577 12567220725 032177  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSBox.h
    Application Kit
    Copyright (c) 1994-2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/NSView.h>

NS_ASSUME_NONNULL_BEGIN

@class NSFont;

typedef NS_ENUM(NSUInteger, NSTitlePosition) {
    NSNoTitle				= 0,
    NSAboveTop				= 1,
    NSAtTop				= 2,
    NSBelowTop				= 3,
    NSAboveBottom			= 4,
    NSAtBottom				= 5,
    NSBelowBottom			= 6
};

typedef NS_ENUM(NSUInteger, NSBoxType) {
    NSBoxPrimary	= 0,	// group subviews with a standard look. default
    NSBoxSecondary	= 1,    // same as primary since 10.3
    NSBoxSeparator	= 2,    // vertical or horizontal separtor line.  Not used with subviews.
    NSBoxOldStyle	= 3,    // 10.2 and earlier style boxes
    NSBoxCustom	NS_ENUM_AVAILABLE_MAC(10_5)	= 4     // draw based entirely on user parameters, not human interface guidelines
};

@interface NSBox : NSView
{
    /* All instance variables are private */
    id                  _titleCell;
    id                  _contentView;
    NSSize              _offsets;
    NSRect              _borderRect;
    NSRect              _titleRect;
    struct __bFlags {
        NSBorderType borderType:2;
        NSTitlePosition titlePosition:3;
        unsigned int backgroundTransparent:1;
        unsigned int orientation:2;
        unsigned int needsTile:1;
        unsigned int transparent:1;
        unsigned int colorAltInterpretation:1;
        unsigned int boxType:3;
        unsigned int useSuperAddSubview:1;
        unsigned int _RESERVED:17;
    } _bFlags;
    id _unused;
}

@property NSBorderType borderType;
@property NSTitlePosition titlePosition;
@property NSBoxType boxType;
@property (copy) NSString *title;
@property (strong) NSFont *titleFont;
@property (readonly) NSRect borderRect;
@property (readonly) NSRect titleRect;
@property (readonly, strong) id titleCell;
- (void)sizeToFit;
@property NSSize contentViewMargins;
- (void)setFrameFromContentFrame:(NSRect)contentFrame;

/* Get and set the content view for the box. Note that subviews added to the NSBox will be really added as subviews of the contentView.
 */
@property (nullable, assign) __kindof NSView *contentView;

/* Transparent boxes do not draw anything.  Subview drawing is unaffected.  The 'transparent' property corresponds to the binding 'NSTransparentBinding'.
 */
@property (getter=isTransparent) BOOL transparent NS_AVAILABLE_MAC(10_5);

/* For boxType == NSBoxCustom: Get and set the border width of the box. The default value is 1.0.
 */
@property CGFloat borderWidth NS_AVAILABLE_MAC(10_5);

/* For boxType == NSBoxCustom: Get and set the corner radius of the box. The default value is 0.0 (no corner radius).
 */
@property CGFloat cornerRadius NS_AVAILABLE_MAC(10_5);

/* For boxType == NSBoxCustom: Get and set the border color the box. The default value is black with some alpha, and may vary release-to-release.
 */
@property (copy) NSColor *borderColor NS_AVAILABLE_MAC(10_5);

/* For boxType == NSBoxCustom: Get and set the fill (background) color the box. The default value is NSColor.clearColor.
 */
@property (copy) NSColor *fillColor NS_AVAILABLE_MAC(10_5);

@end

@interface NSBox(NSDeprecated)

/* Mnemonics are deprecated in 10.8. Historically they have not done anything. For compatability, this method still calls setTitle: with the ampersand stripped from it.
 */
- (void)setTitleWithMnemonic:(null_unspecified NSString *)stringWithAmpersand NS_DEPRECATED_MAC(10_0, 10_8);

@end

NS_ASSUME_NONNULL_END

                                                                                                                                 NSBrowser.h                                                                                         0100644 0001750 0001750 00000106667 12567220725 033073  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSBrowser.h
    Application Kit
    Copyright (c) 1994-2015, Apple Inc.
    All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <AppKit/NSControl.h>
#import <AppKit/NSDragging.h>
#import <AppKit/NSViewController.h>

#define NSAppKitVersionNumberWithContinuousScrollingBrowser 680.0
#define NSAppKitVersionNumberWithColumnResizingBrowser      685.0

NS_ASSUME_NONNULL_BEGIN

@class NSMatrix, NSScroller, NSIndexSet;
@protocol NSBrowserDelegate;

typedef struct __Brflags {
#ifdef __BIG_ENDIAN__
    unsigned int        allowsMultipleSelection:1;
    unsigned int        allowsBranchSelection:1;
    unsigned int        reuseColumns:1;
    unsigned int        isTitled:1;
    unsigned int        titleFromPrevious:1;
    unsigned int        separateColumns:1;
    unsigned int        delegateImplementsWillDisplayCell:1;
    unsigned int        delegateSetsTitles:1;
    unsigned int        delegateSelectsCellsByString:1;
    unsigned int        delegateDoesNotCreateRowsInMatrix:1;
    unsigned int        delegateValidatesColumns:1;
    unsigned int        acceptArrowKeys:1;
    unsigned int        dontDrawTitles:1;
    unsigned int        sendActionOnArrowKeys:1;
    unsigned int        prohibitEmptySel:1;
    unsigned int        hasHorizontalScroller:1;
    unsigned int        time:1;
    unsigned int        allowsIncrementalSearching:1;
    unsigned int        delegateSelectsCellsByRow:1;
    unsigned int        disableCompositing:6;
    unsigned int        refusesFirstResponder:1;
    unsigned int	acceptsFirstMouse:1;
    unsigned int	actionNeedsToBeSent:1;
    unsigned int        usesSmallSizeTitleFont:1;
    unsigned int	usesSmallScrollers:1;
    unsigned int	prefersAllColumnUserResizing:1;
    unsigned int        firstVisibleCalculationDisabled:1;
#else
    unsigned int        firstVisibleCalculationDisabled:1;
    unsigned int 	prefersAllColumnUserResizing:1;
    unsigned int	usesSmallScrollers:1;
    unsigned int        usesSmallSizeTitleFont:1;
    unsigned int	actionNeedsToBeSent:1;
    unsigned int	acceptsFirstMouse:1;
    unsigned int        refusesFirstResponder:1;
    unsigned int        disableCompositing:6;
    unsigned int        delegateSelectsCellsByRow:1;
    unsigned int        allowsIncrementalSearching:1;
    unsigned int        time:1;
    unsigned int        hasHorizontalScroller:1;
    unsigned int        prohibitEmptySel:1;
    unsigned int        sendActionOnArrowKeys:1;
    unsigned int        dontDrawTitles:1;
    unsigned int        acceptArrowKeys:1;
    unsigned int        delegateValidatesColumns:1;
    unsigned int        delegateDoesNotCreateRowsInMatrix:1;
    unsigned int        delegateSelectsCellsByString:1;
    unsigned int        delegateSetsTitles:1;
    unsigned int        delegateImplementsWillDisplayCell:1;
    unsigned int        separateColumns:1;
    unsigned int        titleFromPrevious:1;
    unsigned int        isTitled:1;
    unsigned int        reuseColumns:1;
    unsigned int        allowsBranchSelection:1;
    unsigned int        allowsMultipleSelection:1;
#endif
} _Brflags;


typedef NS_ENUM(NSUInteger, NSBrowserColumnResizingType) {
/* Column sizes are fixed and set by developer.     
 */
    NSBrowserNoColumnResizing = 0,
    
/* No user resizing. Columns grow as window grows.  
 */
    NSBrowserAutoColumnResizing = 1,
    
/* Columns fixed as window grows.  User can resize. 
 */
    NSBrowserUserColumnResizing = 2,
};



/* In drag and drop, used to specify the drop operation from inside the delegate method browser:validateDrop:proposedRow:column:dropOperation. See the delegate method description for more information.
 */
typedef NS_ENUM(NSUInteger, NSBrowserDropOperation) { 
    NSBrowserDropOn,
    NSBrowserDropAbove,
} NS_ENUM_AVAILABLE_MAC(10_5);


@interface NSBrowser : NSControl
{
    /* All instance variables are private */
    id                  _nsreserved2;
    SEL                 _nsreserved3;
    id                  _delegate;
    SEL                 _doubleAction;
    Class               _matrixClass;
    id                  _cellPrototype;
    NSSize		_columnSize;
    short		_numberOfVisibleColumns;
    short		_minColumnWidth;
    short		_firstVisibleColumn;
    short		_maxVisibleColumns;
    NSMutableArray	*_titles;
    NSString		*_pathSeparator;
    NSMutableArray	*_columns;
    id                  _brAuxiliaryStorage;
    NSString		*_firstColumnTitle;
    NSScroller		*_scroller;
    _Brflags            _brflags;
}

+ (Class)cellClass;

- (void)loadColumnZero;
@property (getter=isLoaded, readonly) BOOL loaded;

@property (nullable) SEL doubleAction;
- (void)setCellClass:(Class)factoryId;
@property (null_resettable, strong) id /* NSCell * */ cellPrototype;
@property (nullable, assign) id<NSBrowserDelegate> delegate;
@property BOOL reusesColumns;

@property BOOL hasHorizontalScroller;
@property BOOL autohidesScroller NS_AVAILABLE_MAC(10_6);
@property BOOL separatesColumns;
@property (getter=isTitled) BOOL titled;
@property CGFloat minColumnWidth;

@property NSInteger maxVisibleColumns;

@property BOOL allowsMultipleSelection;
@property BOOL allowsBranchSelection;
@property BOOL allowsEmptySelection;
@property BOOL takesTitleFromPreviousColumn;

@property BOOL sendsActionOnArrowKeys;

/* Returns the item at the given index path. This method can only be used if the delegate implements the item data source methods. The indexPath must be displayable in the browser.
 */
- (nullable id)itemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_6);

/* Returns the item located at 'row' in 'column'.
 */
- (nullable id)itemAtRow:(NSInteger)row inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_6);

/* Returns the index path of the item whose children are displayed in the given column. This method can only be used if the delegate implements the item data source methods.
 */
- (NSIndexPath *)indexPathForColumn:(NSInteger)column NS_AVAILABLE_MAC(10_6);

/* Returns whether the given item is a leaf item. This method can only be used if the delegate implements the item data source methods.
 */
- (BOOL)isLeafItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

/* Updates a particular set of rows in 'column'. For rows that are visible, appropriate dataSource and delegate methods will be called and the row will be redrawn. For browsers that support variable row heights, the row height will not be re-queried from the delegate. This method can only be used if the delegate implements the item data source methods.
*/
- (void)reloadDataForRowIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_6);

/* Returns the item that contains all children located in 'column'. In other words, it is the parent item for that column.
 */
- (nullable id)parentForItemsInColumn:(NSInteger)column NS_AVAILABLE_MAC(10_6);

/* Scrolls 'row' to be visible within 'column'. 'column' will not be scrolled visible. To scroll 'column' to visible, first call -[browser scrollColumnToVisible:column].
 */
- (void)scrollRowToVisible:(NSInteger)row inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_6);

- (void)setTitle:(NSString *)aString ofColumn:(NSInteger)column;
- (nullable NSString *)titleOfColumn:(NSInteger)column;
@property (copy) NSString *pathSeparator;
- (BOOL)setPath:(NSString *)path;
- (NSString *)path;
- (NSString *)pathToColumn:(NSInteger)column;

/* Returns the column and row clicked on to display a context menu. These methods will return -1 when no menu is active.
 */
@property (readonly) NSInteger clickedColumn NS_AVAILABLE_MAC(10_6);
@property (readonly) NSInteger clickedRow NS_AVAILABLE_MAC(10_6);

@property (readonly) NSInteger selectedColumn;

/* For the item based browser, selectedCell returns the prepared cell at the selected row in the selected column.
 */
@property (nullable, readonly, strong) id selectedCell;
- (nullable id)selectedCellInColumn:(NSInteger)column;

/* For the item based browser, selectedCells returns a copy of all prepared cells in the selected row in the selected column
 */
@property (nullable, readonly, copy) NSArray<NSCell *> *selectedCells;

- (void)selectRow:(NSInteger)row inColumn:(NSInteger)column;

- (NSInteger)selectedRowInColumn:(NSInteger)column;

/* Returns the index path of the item selected in the browser, or nil if there is no selection. The setter sets the browser's selection to the item at path. Throws an exception if the path is invalid. This method can only be used if the delegate implements the item data source methods.
 */
@property (copy) NSIndexPath *selectionIndexPath NS_AVAILABLE_MAC(10_6);

/* Returns the index paths of all items selected in the browser. The setter sets the browser's selection to the specified index paths. Throws an exception if any of the paths are invalid. This method can only be used if the delegate implements the item data source methods.
 */
@property (copy) NSArray<NSIndexPath *> *selectionIndexPaths NS_AVAILABLE_MAC(10_6);

/* Sets the selected row 'indexes' in the matrix located at 'column'. 
 */
- (void)selectRowIndexes:(NSIndexSet *)indexes inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_5);

/* Returns the selected cell indexes in the matrix located at 'column'. 
 */
- (nullable NSIndexSet *)selectedRowIndexesInColumn:(NSInteger)column NS_AVAILABLE_MAC(10_5);

- (void)reloadColumn:(NSInteger)column;
- (void)validateVisibleColumns;
- (void)scrollColumnsRightBy:(NSInteger)shiftAmount;
- (void)scrollColumnsLeftBy:(NSInteger)shiftAmount;
- (void)scrollColumnToVisible:(NSInteger)column;

/* Returns the last loaded column. This is equal to the total number of columns minus 1. When setting. 'column' must be equal to or less than -lastColumn. To add more columns, use -addColumn.
 */
@property NSInteger lastColumn;

/* Adds a column at the end. To remove columns, use -setLastColumn:
 */
- (void)addColumn;

@property (readonly) NSInteger numberOfVisibleColumns;
@property (readonly) NSInteger firstVisibleColumn;
@property (readonly) NSInteger lastVisibleColumn;


- (nullable id)loadedCellAtRow:(NSInteger)row column:(NSInteger)col;
- (void)selectAll:(nullable id)sender;
- (void)tile;
- (void)doClick:(nullable id)sender;
- (void)doDoubleClick:(nullable id)sender;
- (BOOL)sendAction;

- (NSRect)titleFrameOfColumn:(NSInteger)column;
- (void)drawTitleOfColumn:(NSInteger)column inRect:(NSRect)aRect;
@property (readonly) CGFloat titleHeight;
- (NSRect)frameOfColumn:(NSInteger)column;
- (NSRect)frameOfInsideOfColumn:(NSInteger)column;

/* Returns the frame of the row at 'row' / 'column' including the area for the expandable arrow. The returned NSRect is in the NSBrowser coordinate space.
*/
- (NSRect)frameOfRow:(NSInteger)row inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_6);

/* Finds the row and column located at 'point', returning YES if both can be found. If a row does not exist at 'point', then -1 is set for the row. If a column does not exist at 'point', then -1 is set for the column. 'point' is expected to be in the NSBrowser's coordinate system.
*/
- (BOOL)getRow:(nullable NSInteger *)row column:(nullable NSInteger *)column forPoint:(NSPoint)point NS_AVAILABLE_MAC(10_6);

/* These methods convert between column width (the column's scrollview), and the content width (the matrix in the scrollview).  For example, to guarantee that 16 pixels of your browser cell are always visible, call [browser setMinColumnWidth:[browser columnWidthForColumnContentWidth:16]] 
*/
- (CGFloat)columnWidthForColumnContentWidth:(CGFloat)columnContentWidth;
- (CGFloat)columnContentWidthForColumnWidth:(CGFloat)columnWidth;

/* Default is NSBrowserAutoColumnResizing.  This setting is persistent. 
 */
@property NSBrowserColumnResizingType columnResizingType;

/* Default is NO.  This setting is persistent.  This setting only applies to NSBrowserUserColumnResizing type browsers.  If YES, the browser defaults to resizing all columns simultaneously, otherwise it defaults to single column resizing. Holding down the option key while resizing switches the type of resizing used. 
 */
@property BOOL prefersAllColumnUserResizing;

/* setWidth:ofColumn: does nothing if columnResizingType is NSBrowserAutoColumnResizing.  Otherwise, Sets the width of the specified column.  Due to binary compatibility constraints, you may still set the default width for new columns by passing a columnIndex of -1; you are encouraged to use -setDefaultColumnWidth: instead.  NSBrowserColumnConfigurationDidChangeNotification will be posted (not immediately) if necessary.  The receiver will autosave its column configuration if necessary. 
 */
- (void)setWidth:(CGFloat)columnWidth ofColumn:(NSInteger)columnIndex;
- (CGFloat)widthOfColumn:(NSInteger)column;

/* Get and set the rowHeight. The value must be greater than 0. Calling -setRowHeight: with a non-pixel aligning (fractional) value will be forced to a pixel aligning (integral) value. For variable row height browsers (ones that have the delegate implement -browser:heightOfRow:column:), -rowHeight will be used to draw alternating rows past the last row in each browser column. The default value is 17.0. Note: The rowHeight methods are only valid when using the item delegate methods introduced in Mac OS 10.6. (see NSObject(NSBrowserDelegate)). An exception is thrown if using the older matrix delegate methods 
 */
@property CGFloat rowHeight NS_AVAILABLE_MAC(10_6);

/* If the delegate implements -browser:heightOfRow:inColumn:, this method immediately re-tiles the browser columns using row heights it provides.
*/
- (void)noteHeightOfRowsWithIndexesChanged:(NSIndexSet *)indexSet inColumn:(NSInteger)columnIndex NS_AVAILABLE_MAC(10_6);


/* Persistently sets the default width for new columns which don't otherwise have initial width from either defaults or the delegate. This method replaces -setWidth:ofColumn: with a columnIndex of -1. 
 */
- (void)setDefaultColumnWidth:(CGFloat)columnWidth NS_AVAILABLE_MAC(10_6);
- (CGFloat)defaultColumnWidth NS_AVAILABLE_MAC(10_6);

/* Sets the name used to automatically save the receivers column configuration.  This setting is persistent.  If name is different from the current name, this method also reads in the saved column configuration for the new name and applies the values to the browser.  Column configuration is defined as an array of column content widths.  One width is saved for each level the user has reached.  That is, browser saves column width based on depth, not based on unique paths.  To do more complex column persistence, you should register for NSBrowserColumnConfigurationDidChangeNotifications and handle persistence yourself. 
 */
@property (copy) NSString *columnsAutosaveName;

/* Removes the column data stored under name from the applications user defaults. 
 */
+ (void)removeSavedColumnsWithAutosaveName:(NSString *)name;


#pragma mark -
#pragma mark **** Drag and Drop Support ****

/* The return value indicates whether the receiver can attempt to initiate a drag for the given event. You can override this method and return NO to disallow initiating drags at the location in the given event. By default, the method will return YES if rowIndexes contains at least one item, and each item is enabled. If the equivalent delegate method is present, it will be preferred over this method, and you can safely call this method from your delegate. 
 */
- (BOOL)canDragRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column withEvent:(NSEvent *)event NS_AVAILABLE_MAC(10_5);

/* This method computes and returns an image to use for dragging. You can override this to return a custom drag image, or call it to get the default drag image from the delegate method. 'rowIndexes' are the indexes of the cells being dragged in matrix 'column'. 'event' is a reference to the mouse down event that began the drag. 'dragImageOffset' is an in/out parameter. This method will be called with dragImageOffset set to NSZeroPoint, but it can be modified to re-position the returned image. A dragImageOffset of NSZeroPoint will cause the image to be centered under the mouse. By default, an image will be created that contain the visible cells within 'rowIndexes'. If the equivalent delegate method is present, it will be preferred over this method, and you can safely call this method from your delegate. 
 */
- (nullable NSImage *)draggingImageForRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column withEvent:(NSEvent *)event offset:(nullable NSPointPointer)dragImageOffset NS_AVAILABLE_MAC(10_5);

/* Configures the value returned from -draggingSourceOperationMaskForLocal:. An isLocal value of YES indicates that 'mask' applies when the destination object is in the same application. By default, NSDragOperationEvery will be returned. An isLocal value of NO indicates that 'mask' applies when the destination object in an application outside the receiver's application. By default, NSDragOperationNone is returned. NSBrowser will save the values you set for each isLocal setting. You typically will invoke this method, and not override it. 
 */
- (void)setDraggingSourceOperationMask:(NSDragOperation)mask forLocal:(BOOL)isLocal NS_AVAILABLE_MAC(10_5);

#pragma mark -

/* Allow type selection in this NSBrowser. The default for 'allowsTypeSelect' is YES.
 */
@property BOOL allowsTypeSelect NS_AVAILABLE_MAC(10_5);

/* The background color to be drawn. By default, it will be set [NSColor whiteColor]. You can use [NSColor clearColor] to make the background transparent. NSBrowser will return YES from isOpaque if the backgroundColor has an alphaComponent of 1.0 and it doesn't have a title, otherwise, it will return NO. Calling setBackgroundColor: will cause all NSMatrix instances have setDrawsBackground:NO be called in order for the NSBrowser's background color to show through. When drawing with the background color, NSCompositeSourceOver is used for the compositing operation.
 */
@property (strong) NSColor *backgroundColor NS_AVAILABLE_MAC(10_5);

/* Begins editing the item at the specified path. theEvent may be nil if programatically editing. The cell's contents will be selected if select is YES. Overriding this method will not affect the editing behavior of the browser.
 */
- (void)editItemAtIndexPath:(NSIndexPath *)indexPath withEvent:(NSEvent *)theEvent select:(BOOL)select NS_AVAILABLE_MAC(10_6);

@end

#pragma mark -
#pragma mark **** Notifications ****

/* The -object in the NSNotification is the browser whose column sizes need to be persisted. There is no userInfo.
 */
APPKIT_EXTERN NSString * NSBrowserColumnConfigurationDidChangeNotification;

#pragma mark -
#pragma mark **** Delegate methods ****

@protocol NSBrowserDelegate <NSObject>
@optional

/* As of Mac OS X 10.6, browser has two different mechanisms for populating columns. You may implement either the matrix or item delegate methods listed below. Many newer features of the browser are only available if you implement the item delegate methods. */

/* Implement one of the following two methods to populate the browser's columns with instances of NSMatrix.
   Note: the matrix based NSBrowser is deprecated in Mac OS 10.10.  New code should use the item based interface.
 */
/* Called by the browser to determine the number of rows in the given column. The delegate will be called with -browser:willDisplayCell:atRow:column: before displaying each cell, giving it a chance to fill in the NSBrowserCell properties.
 */
- (NSInteger)browser:(NSBrowser *)sender numberOfRowsInColumn:(NSInteger)column;

/* Called by the browser to fill in the matrix with populated NSBrowserCells.
 */
- (void)browser:(NSBrowser *)sender createRowsForColumn:(NSInteger)column inMatrix:(NSMatrix *)matrix;

#pragma mark -

/* Alternatively, implement all of the following methods, patterned after NSOutlineView's data source methods. Note that browsers with delegates implementing these methods do not use NSMatrix to populate columns; the implementation is private. The item parameter passed to each of these methods will be nil if the browser is querying about the root of the tree, unless -rootItemForBrowser: is implemented.
*/

/* Return the number of children of the given item. */
- (NSInteger)browser:(NSBrowser *)browser numberOfChildrenOfItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

/* Return the indexth child of item. You may expect that index is never equal to or greater to the number of children of item as reported by -browser:numberOfChildrenOfItem:.
 */
- (id)browser:(NSBrowser *)browser child:(NSInteger)index ofItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

/* Return whether item should be shown as a leaf item; that is, an item that can not be expanded into another column. Returning NO does not prevent you from returning 0 from -browser:numberOfChildrenOfItem:.
 */
- (BOOL)browser:(NSBrowser *)browser isLeafItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

/* Return the object value passed to the cell displaying item.
 */
- (nullable id)browser:(NSBrowser *)browser objectValueForItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

/* Optional - Variable Row Heights
    Implement this method to support varying row heights per column.  The height returned by this method should not include intercell spacing and must be greater than zero.  NSBrowser may cache the values this method returns.  So if you would like to change a row's height make sure to invalidate the row height by calling -noteHeightOfRowsWithIndexesChanged:inColumn:.
*/
- (CGFloat)browser:(NSBrowser *)browser heightOfRow:(NSInteger)row inColumn:(NSInteger)columnIndex NS_AVAILABLE_MAC(10_6);

#pragma mark -

/* Optional - Alternate root item. 
 By default, NSBrowser uses 'nil' to identify the root item. It can optionally use a different root item provided by this delegate method. To reload the rootItem that was previously set, call -loadColumnZero, and NSBrowser will call -rootItemForBrowser: again.
 */
- (nullable id)rootItemForBrowser:(NSBrowser *)browser NS_AVAILABLE_MAC(10_6);

/* Optional - editing support.
 Implement this method to support editing of browser items. The browser will pass back the object value from the cell displaying item.
 */
- (void)browser:(NSBrowser *)browser setObjectValue:(nullable id)object forItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

/* Optional - editing support.
 Implement this method to control whether the browser may start an editing session for item.
 */
- (BOOL)browser:(NSBrowser *)browser shouldEditItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

#pragma mark -

/* Optional - display support.
 Called by the browser before displaying a cell at the given location.
 */
- (void)browser:(NSBrowser *)sender willDisplayCell:(id)cell atRow:(NSInteger)row column:(NSInteger)column;

- (nullable NSString *)browser:(NSBrowser *)sender titleOfColumn:(NSInteger)column;

/* Called by the browser when selecting cells by title, either from -setPath:, or when recomputing the selection after -reloadColumn:. Return NO if a matching cell could not be found.
 */
- (BOOL)browser:(NSBrowser *)sender selectCellWithString:(NSString *)title inColumn:(NSInteger)column;

/* Called by the browser when selecting a cell using -selectRow:inColumn:. Return NO if a matching cell could not be found.
 */
- (BOOL)browser:(NSBrowser *)sender selectRow:(NSInteger)row inColumn:(NSInteger)column;

/* Called by the browser from -validateVisibleColumns to determine whether the currently-displayed columns are valid. Returning NO will prompt the browser to call -reloadColumn:.
 */
- (BOOL)browser:(NSBrowser *)sender isColumnValid:(NSInteger)column;

- (void)browserWillScroll:(NSBrowser *)sender;
- (void)browserDidScroll:(NSBrowser *)sender;

/*
 * Delegate methods used by resizable column browsers.
 */

/* Optional for browsers with resize type NSBrowserNoColumnResizing, and NSBrowserUserColumnResizing.
 This method is used for both constraining column resize, and determining a columns initial size.  If 'forUserResize' is NO, this method should return the initial width for a newly added column.  If 'forUserResize' is YES, this method can be used to constrain resizing on a per-column basis.  (Currently per-column constraining is only implemented for single column resize).
 */
- (CGFloat)browser:(NSBrowser *)browser shouldSizeColumn:(NSInteger)columnIndex forUserResize:(BOOL)forUserResize toWidth:(CGFloat)suggestedWidth;

/* Optional for browsers with resize type NSBrowserUserColumnResizing only.
 This method returns the "ideal" width for a column.  This method is used when performing a "right-size-each" or "right-size-one" operation.  If columnIndex is -1, the result is used for a "right-size-all-simultaneous" operation.  In this case, you should return a best uniform right size for all column (every column will be set to this size).  You can opt out on a per column basis by returning -1 for that column. It is assumed that the implementation may be expensive, so it will be called only when necessary.  (See documentation for definitions of right-size one/each/all). 
 */
- (CGFloat)browser:(NSBrowser *)browser sizeToFitWidthOfColumn:(NSInteger)columnIndex;

/* Optional and used for browsers with resize type NSBrowserUserColumnResizing only.
 This method is intended to be used by clients wishing to implement their own column width persistence.  It is called when the width of any browser columns has changed.  User column resizing will cause a single notification to be posted when the user is finished resizing.  (See NSBrowserColumnConfigurationDidChangeNotification for more information.)  
 */
- (void)browserColumnConfigurationDidChange:(NSNotification *)notification;

/* Optional - Expansion ToolTip support.
    Implement this method and return NO to prevent an expansion tooltip from appearing for a particular cell at 'row' in 'column'. See NSCell.h for more information on expansion tool tips. 
 */
- (BOOL)browser:(NSBrowser *)browser shouldShowCellExpansionForRow:(NSInteger)row column:(NSInteger)column NS_AVAILABLE_MAC(10_5);


#pragma mark -
#pragma mark **** Optional Drag and Drop Support Methods ****

#pragma mark ** Dragging Source Methods **

/* This method is called after it has been determined that a drag should begin, but before the drag has been started.  To refuse the drag, return NO. To start a drag, declared the pasteboard types that you support with [pasteboard declareTypes:owner:], place your data on the pasteboard, and return YES from the method. The drag image and other drag related information will be set up and provided by the view once this call returns with YES. You need to implement this method for your browser to be a drag source. 
 */
- (BOOL)browser:(NSBrowser *)browser writeRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column toPasteboard:(NSPasteboard *)pasteboard NS_AVAILABLE_MAC(10_5);

/* The delegate can support file promise drags by adding NSFilesPromisePboardType to the pasteboard in browser:writeRowsWithIndexes:inColumn:toPasteboard:. NSBrowser implements -namesOfPromisedFilesDroppedAtDestination: to return the results of this data source method.  This method should returns an array of filenames for the created files (filenames only, not full paths).  The URL represents the drop location.  For more information on file promise dragging, see documentation on the NSDraggingSource protocol and -namesOfPromisedFilesDroppedAtDestination:. You do not need to implement this method for your browser to be a drag source.
 */
- (NSArray<NSString *> *)browser:(NSBrowser *)browser namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination forDraggedRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_5);

/* The delegate can control if some particular rows can be dragged or not for a particular event. You do not need to implement this method for your browser to be a drag source. 
 */
- (BOOL)browser:(NSBrowser *)browser canDragRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column withEvent:(NSEvent *)event NS_AVAILABLE_MAC(10_5);

/* Allows the delegate to compute a dragging image for the particular cells being dragged. 'rowIndexes' are the indexes of the cells being dragged in the matrix in 'column'. 'event' is a reference to the mouse down event that began the drag. 'dragImageOffset' is an in/out parameter. This method will be called with dragImageOffset set to NSZeroPoint, but it can be modified to re-position the returned image.  A dragImageOffset of NSZeroPoint will cause the image to be centered under the mouse. You can safely call [browser dragImageForRowsWithIndexes:inColumn:withEvent:offset:] from inside this method. You do not need to implement this method for your browser to be a drag source. You can safely call the corresponding NSBrowser method.
 */
- (nullable NSImage *)browser:(NSBrowser *)browser draggingImageForRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column withEvent:(NSEvent *)event offset:(NSPointPointer)dragImageOffset NS_AVAILABLE_MAC(10_5);

#pragma mark ** Dragging Destination Methods **

/* This method is used by the browser to determine a valid drop target. Based on the mouse position, the browser will suggest a proposed row, column and dropOperation. These values are in/out parameters and can be changed by the delegate to retarget the drop operation. The dropOperation suggested will be NSBrowserDropOn if the drag location is closer to the middle of a row. If it is closer to being between two rows, it will be NSBrowserDropAbove, indicating a drop above 'row' and below 'row - 1'. This method must return a value that indicates which dragging operation the data source will perform. It must return something other than NSDragOperationNone to accept the drop.

    To retarget a drop and specify a drop on row 2 (with the first visual row being row 0), one would set *row=2, and set *dropOperation=NSBrowserDropOn. To specify a drop below the last row, one would specify *row=[browser numberOfRows], and *dropOperation=NSBrowserDropAbove. To specify a drop on the entire column, you will specify *row=-1, and *dropOperation=NSBrowserDropOn. To specify a drop between rows 2 and 3, one would set *row=3 and *dropOperation=NSBrowserDropAbove.

    Note: to receive drag messages, you must first call [NSBrowser registerForDraggedTypes:] for the drag types you want to support (typically this is done in awakeFromNib). You must implement this method for your browser to be a drag destination. 
*/
- (NSDragOperation)browser:(NSBrowser *)browser validateDrop:(id <NSDraggingInfo>)info proposedRow:(NSInteger *)row column:(NSInteger *)column  dropOperation:(NSBrowserDropOperation *)dropOperation NS_AVAILABLE_MAC(10_5);

/* This method is called when the mouse is released over a browser that previously decided to allow a drop via the above validateDrop method.  The delegate should incorporate the data from the dragging pasteboard at this time. You must implement this method for your browser to be a drag destination.
*/
- (BOOL)browser:(NSBrowser *)browser acceptDrop:(id <NSDraggingInfo>)info atRow:(NSInteger)row column:(NSInteger)column dropOperation:(NSBrowserDropOperation)dropOperation NS_AVAILABLE_MAC(10_5);

#pragma mark -

#pragma mark **** Type Select Support ****

/* Optional - Type select support
    Implement this method if you want to control the string that is used for type selection. You may want to change what is searched for based on what is displayed, or simply return an empty string for that row and/or column to not be searched. You can also return 'nil' if the cell does not contain any text. By default, all cells with text in them are searched. The default value when this delegate method is not implemented is the stringValue for the cell at that location.
 */
- (NSString *)browser:(NSBrowser *)browser typeSelectStringForRow:(NSInteger)row inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_5);

/* Optional - Type select support
    Implement this method if you would like to prevent a type select from happening based on the current event and current search string. Generally, this will be called from keyDown: and the event will be a key event. The search string will be nil if no type select has began. 
 */
- (BOOL)browser:(NSBrowser *)browser shouldTypeSelectForEvent:(NSEvent *)event withCurrentSearchString:(nullable NSString *)searchString NS_AVAILABLE_MAC(10_5);

/* Optional - Type select support
    Implement this method if you want to control how type selection works. Return the first row that matches searchString from within the range of startRow to endRow. It is possible for endRow to be less than startRow if the search will wrap. Return -1 when there is no match. Include startRow as a possible match, but do not include endRow. It is not necessary to implement this method in order to support type select.
 */
- (NSInteger)browser:(NSBrowser *)browser nextTypeSelectMatchFromRow:(NSInteger)startRow toRow:(NSInteger)endRow inColumn:(NSInteger)column forString:(nullable NSString *)searchString NS_AVAILABLE_MAC(10_5);

#pragma mark -

/* Optional - Preview column support
    Implement this method to provide a preview column for leaf items. Return nil to suppress the preview column. The controller's representedObject will be set to the browser's selected leaf item. This method is only called if the delegate implements the item data source methods.
 */
- (nullable NSViewController *)browser:(NSBrowser *)browser previewViewControllerForLeafItem:(id)item NS_AVAILABLE_MAC(10_6);

/* Optional - Column header support
    Implement this method to provide a header view for columns. Return nil to omit the header view. The controller's representedObject will be set to the column's item. This method is only called if the delegate implements the item data source methods.
 */
- (nullable NSViewController *)browser:(NSBrowser *)browser headerViewControllerForItem:(nullable id)item NS_AVAILABLE_MAC(10_6);

/* Optional - Notification when the lastColumn changes.
 */
- (void)browser:(NSBrowser *)browser didChangeLastColumn:(NSInteger)oldLastColumn toColumn:(NSInteger)column;

/* Optional - Return a set of new indexes to select when the user changes the selection with the keyboard or mouse. This method may be called multiple times with one new index added to the existing selection to find out if a particular index can be selected when the user is extending the selection with the keyboard or mouse. Note that 'proposedSelectionIndexes' will contain the entire newly suggested selection, and you can return the exsiting selection to avoid changing the selection. This method only works for item-based NSBrowsers.
 */
- (NSIndexSet *)browser:(NSBrowser *)browser selectionIndexesForProposedSelection:(NSIndexSet *)proposedSelectionIndexes inColumn:(NSInteger)column NS_AVAILABLE_MAC(10_6);

@end

#pragma mark -
#pragma mark **** Deprecated Methods ****

@interface NSBrowser(NSDeprecated)

/* This property has been non-functional since before 10.0.
 */
- (void)setAcceptsArrowKeys:(BOOL)flag NS_DEPRECATED_MAC(10_0, 10_6);
- (BOOL)acceptsArrowKeys NS_DEPRECATED_MAC(10_0, 10_6);

/* Use of -displayColumn: is deprecated in 10.3.  Use setNeedsDisplayInRect: instead.
 */
- (void)displayColumn:(NSInteger)column NS_DEPRECATED_MAC(10_0, 10_3);

/* Use of -displayAllColumns; is deprecated in 10.3.  Use setNeedsDisplay/InRect: instead.
 */
- (void)displayAllColumns NS_DEPRECATED_MAC(10_0, 10_3);

/* Use of -scrollViaScroller: is deprecated in 10.3.  Continuous scrolling no longer requires this functionality.
 */
- (void)scrollViaScroller:(null_unspecified NSScroller *)sender NS_DEPRECATED_MAC(10_0, 10_3);

/* Use of -updateScroller is deprecated in 10.3.  Continuous scrolling no longer requires this functionality.
 */
- (void)updateScroller NS_DEPRECATED_MAC(10_0, 10_3);

/* Matrix based NSBrowser is deprecated in 10.10.
 */
- (void)setMatrixClass:(Class)factoryId  NS_DEPRECATED_MAC(10_0, 10_10, "Use the item based NSBrowser instead");
- (Class)matrixClass  NS_DEPRECATED_MAC(10_0, 10_10, "Use the item based NSBrowser instead");
- (NSInteger)columnOfMatrix:(NSMatrix *)matrix  NS_DEPRECATED_MAC(10_0, 10_10, "Use the item based NSBrowser instead");
- (nullable NSMatrix *)matrixInColumn:(NSInteger)column  NS_DEPRECATED_MAC(10_0, 10_10, "Use the item based NSBrowser instead");

@end

NS_ASSUME_NONNULL_END
                                                                         NSBrowserCell.h                                                                                     0100644 0001750 0001750 00000001113 12567220725 033647  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSBrowserCell.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSCell.h>

NS_ASSUME_NONNULL_BEGIN

@class NSImage;

@interface NSBrowserCell : NSCell

+ (nullable NSImage *)branchImage;
+ (nullable NSImage *)highlightedBranchImage;

- (nullable NSColor *)highlightColorInView:(NSView *)controlView;

@property (getter=isLeaf) BOOL leaf;
@property (getter=isLoaded) BOOL loaded;
- (void)reset;
- (void)set;
@property (nullable, strong) NSImage *image;
@property (nullable, strong) NSImage *alternateImage;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                     NSButton.h                                                                                          0100644 0001750 0001750 00000004310 12567220725 032701  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSButton.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSControl.h>
#import <AppKit/NSButtonCell.h>
#import <AppKit/NSUserInterfaceValidation.h>

NS_ASSUME_NONNULL_BEGIN

@class NSSound;

@interface NSButton : NSControl <NSUserInterfaceValidations, NSAccessibilityButton>

@property (copy) NSString *title;
@property (copy) NSString *alternateTitle;
@property (nullable, strong) NSImage *image;
@property (nullable, strong) NSImage *alternateImage;
@property NSCellImagePosition imagePosition;
- (void)setButtonType:(NSButtonType)aType;
@property NSInteger state;
@property (getter=isBordered) BOOL bordered;
@property (getter=isTransparent) BOOL transparent;
- (void)setPeriodicDelay:(float)delay interval:(float)interval;
- (void)getPeriodicDelay:(float *)delay interval:(float *)interval;
@property (copy) NSString *keyEquivalent;
@property NSUInteger keyEquivalentModifierMask;
- (void)highlight:(BOOL)flag;
- (BOOL)performKeyEquivalent:(NSEvent *)key;

@property (getter=isSpringLoaded) BOOL springLoaded NS_AVAILABLE_MAC(10_10_3); // sends action on deep-press or extended hover while dragging. Defaults to NO.
@property NSInteger maxAcceleratorLevel NS_AVAILABLE_MAC(10_10_3);	// Configures the maximum allowed level for an NSMultiLevelAcceleratorButton, allowed values range from [1,5]. Defaults to 2.

@end

@interface NSButton(NSButtonAttributedStringMethods)
@property (copy) NSAttributedString *attributedTitle;
@property (copy) NSAttributedString *attributedAlternateTitle;
@end

@interface NSButton(NSButtonBezelStyles)
@property NSBezelStyle bezelStyle;
@end

@interface NSButton(NSButtonMixedState)
@property BOOL allowsMixedState;
- (void)setNextState;
@end

@interface NSButton(NSButtonBorder)
@property BOOL showsBorderOnlyWhileMouseInside;
@end

@interface NSButton (NSButtonSoundExtensions)
@property (nullable, strong) NSSound *sound;
@end


@interface NSButton(NSKeyboardUI)

/* On 10.8, this method still will call setTitle: with the ampersand stripped from stringWithAmpersand, but does nothing else. Use setTitle directly.
 */
- (void)setTitleWithMnemonic:(null_unspecified NSString *)stringWithAmpersand NS_DEPRECATED_MAC(10_0, 10_8);

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                        NSButtonCell.h                                                                                      0100644 0001750 0001750 00000021331 12567220725 033503  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSButtonCell.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSActionCell.h>

NS_ASSUME_NONNULL_BEGIN

@class NSAttributedString, NSFont, NSImage, NSSound;

typedef NS_ENUM(NSUInteger, NSButtonType) {
    NSMomentaryLightButton		= 0,	// was NSMomentaryPushButton
    NSPushOnPushOffButton		= 1,
    NSToggleButton			= 2,
    NSSwitchButton			= 3,
    NSRadioButton			= 4,
    NSMomentaryChangeButton		= 5,
    NSOnOffButton			= 6,
    NSMomentaryPushInButton		= 7,	// was NSMomentaryLight
    NSAcceleratorButton NS_ENUM_AVAILABLE_MAC(10_10_3)			= 8,
    NSMultiLevelAcceleratorButton NS_ENUM_AVAILABLE_MAC(10_10_3)	= 9,
    
    /* These constants were accidentally reversed so that NSMomentaryPushButton lit and
       NSMomentaryLight pushed. These names are now deprecated */
    NSMomentaryPushButton NS_ENUM_DEPRECATED_MAC(10_0, 10_9)    = 0, // NSMomentaryLightButton should be used instead
    NSMomentaryLight NS_ENUM_DEPRECATED_MAC(10_0, 10_9)         = 7 // NSMomentaryPushInButton should be used instead
};

typedef NS_ENUM(NSUInteger, NSBezelStyle) {
    NSRoundedBezelStyle          = 1,
    NSRegularSquareBezelStyle    = 2,
    NSThickSquareBezelStyle      = 3,
    NSThickerSquareBezelStyle    = 4,
    NSDisclosureBezelStyle       = 5,
    NSShadowlessSquareBezelStyle = 6,
    NSCircularBezelStyle         = 7,
    NSTexturedSquareBezelStyle   = 8,
    NSHelpButtonBezelStyle       = 9,
    NSSmallSquareBezelStyle       = 10,
    NSTexturedRoundedBezelStyle   = 11,
    NSRoundRectBezelStyle         = 12,
    NSRecessedBezelStyle          = 13,
    NSRoundedDisclosureBezelStyle = 14,
    // The inline bezel style contains a solid round-rect border background. It can be used to create an "unread" indicator in an outline view, or another inline button in a tableview, such as a stop progress button in a download panel. Use text for an unread indicator, and a template image for other buttons.
    NSInlineBezelStyle NS_ENUM_AVAILABLE_MAC(10_7) = 15,
    
    NSSmallIconButtonBezelStyle NS_ENUM_DEPRECATED_MAC(10_0, 10_0) = 2 // This bezel style is obsolete and should not be used.
};

typedef struct __BCFlags {
#ifdef __BIG_ENDIAN__
    unsigned int        pushIn:1;
    unsigned int        changeContents:1;
    unsigned int        changeBackground:1;
    unsigned int        changeGray:1;
    unsigned int        lightByContents:1;
    unsigned int        lightByBackground:1;
    unsigned int        lightByGray:1;
    unsigned int        drawing:1;
    unsigned int        bordered:1;
    unsigned int        imageOverlaps:1;
    unsigned int        horizontal:1;
    unsigned int        bottomOrLeft:1;
    unsigned int        imageAndText:1;
    unsigned int        imageSizeDiff:1;
    unsigned int        hasKeyEquivalentInsteadOfImage:1;
    unsigned int        inIntermediateDisclosure:1;
    unsigned int        transparent:1;
    unsigned int        inset:2;
    unsigned int        doesNotDimImage:1;
    unsigned int        suppressAXValueChangeNote:1;
    unsigned int        isDrawingDisclosure:1;
    unsigned int        hasTitleTextField:1;
    unsigned int        useButtonImageSource:1;
    unsigned int        isDrawingFocus:1;
    unsigned int        allowTitleTightening:1;
    unsigned int        __reserved:6;
#else
    unsigned int        __reserved:6;
    unsigned int        allowTitleTightening:1;
    unsigned int        isDrawingFocus:1;
    unsigned int        useButtonImageSource:1;
    unsigned int        hasTitleTextField:1;
    unsigned int        isDrawingDisclosure:1;
    unsigned int        suppressAXValueChangeNote:1;
    unsigned int        doesNotDimImage:1;
    unsigned int        inset:2;
    unsigned int        transparent:1;
    unsigned int        inIntermediateDisclosure:1;
    unsigned int        hasKeyEquivalentInsteadOfImage:1;
    unsigned int        imageSizeDiff:1;
    unsigned int        imageAndText:1;
    unsigned int        bottomOrLeft:1;
    unsigned int        horizontal:1;
    unsigned int        imageOverlaps:1;
    unsigned int        bordered:1;
    unsigned int        drawing:1;
    unsigned int        lightByGray:1;
    unsigned int        lightByBackground:1;
    unsigned int        lightByContents:1;
    unsigned int        changeGray:1;
    unsigned int        changeBackground:1;
    unsigned int        changeContents:1;
    unsigned int        pushIn:1;
#endif
} _BCFlags;

typedef struct __BCFlags2 {
#ifdef __BIG_ENDIAN__
    unsigned int	keyEquivalentModifierMask:24;
    unsigned int	imageScaling:2;
    unsigned int	bezelStyle2:1;
    unsigned int	mouseInside:1;
    unsigned int	showsBorderOnlyWhileMouseInside:1;
    unsigned int	bezelStyle:3;
#else
    unsigned int	bezelStyle:3;
    unsigned int	showsBorderOnlyWhileMouseInside:1;
    unsigned int	mouseInside:1;
    unsigned int	bezelStyle2:1;
    unsigned int	imageScaling:2;
    unsigned int	keyEquivalentModifierMask:24;
#endif
} _BCFlags2;

@interface NSButtonCell : NSActionCell
{
    /*All instance variables are private*/
    NSString	       *_altContents;
    id			_sound;
    NSString	       *_keyEquivalent;
    _BCFlags2		_bcFlags2;
    unsigned short	_periodicDelay;
    unsigned short	_periodicInterval;
    _BCFlags            _bcFlags;
    NSImage            *_normalImage;
    id                  _alternateImageOrKeyEquivalentFont;
}


@property (null_resettable, copy) NSString *title;
@property (copy) NSString *alternateTitle;

@property (nullable, strong) NSImage *alternateImage;
@property NSCellImagePosition imagePosition;
@property NSImageScaling imageScaling NS_AVAILABLE_MAC(10_5);

@property NSCellStyleMask highlightsBy;
@property NSCellStyleMask showsStateBy;
- (void)setButtonType:(NSButtonType)aType;
@property (getter=isOpaque, readonly) BOOL opaque;
@property (getter=isTransparent) BOOL transparent;
- (void)setPeriodicDelay:(float)delay interval:(float)interval;
- (void)getPeriodicDelay:(float *)delay interval:(float *)interval;
@property (copy) NSString *keyEquivalent;
@property NSUInteger keyEquivalentModifierMask;
@property (nullable, strong) NSFont *keyEquivalentFont;
- (void)setKeyEquivalentFont:(NSString *)fontName size:(CGFloat)fontSize;
- (void)performClick:(nullable id)sender; // Significant NSCell override, actually clicks itself.

- (void)drawImage:(NSImage*)image withFrame:(NSRect)frame inView:(NSView*)controlView;
- (NSRect)drawTitle:(NSAttributedString*)title withFrame:(NSRect)frame inView:(NSView*)controlView;
- (void)drawBezelWithFrame:(NSRect)frame inView:(NSView*)controlView;

@end

// NSGradientType :
//
// A concave gradient is darkest in the top left corner, 
// a convex gradient is darkest in the bottom right corner.
//
// Weak versus strong is how much contrast exists between
// the colors used in opposite corners
typedef NS_ENUM(NSUInteger, NSGradientType) {
    NSGradientNone          = 0,
    NSGradientConcaveWeak   = 1,
    NSGradientConcaveStrong = 2,
    NSGradientConvexWeak    = 3,
    NSGradientConvexStrong  = 4
};

@interface NSButtonCell(NSButtonCellExtensions)

// NOTE: gradientType is not used
@property NSGradientType gradientType;

// When disabled, the image and text of an NSButtonCell are normally dimmed with gray.
// Radio buttons and switches use (imageDimsWhenDisabled == NO) so only their text is dimmed.
@property BOOL imageDimsWhenDisabled;

@property BOOL showsBorderOnlyWhileMouseInside;

- (void)mouseEntered:(NSEvent*)event;
- (void)mouseExited:(NSEvent*)event;

@property (nullable, copy) NSColor *backgroundColor;

@end

@interface NSButtonCell(NSButtonCellAttributedStringMethods)
@property (copy) NSAttributedString *attributedTitle;
@property (copy) NSAttributedString *attributedAlternateTitle;
@end

@interface NSButtonCell(NSButtonCellBezelStyles)

@property NSBezelStyle bezelStyle;

@end

@interface NSButtonCell (NSButtonCellSoundExtensions)
@property (nullable, strong) NSSound *sound;
@end

/* In 10.8 and higher, all the *Mnemonic* methods are deprecated. On MacOS they have typically not been used.
 */
@interface NSButtonCell(NSKeyboardUI)

/* On 10.8, these two methods still will call setTitle: (or setAlternateTitle:) with the ampersand stripped from stringWithAmpersand, but does nothing else. Use setTitle directly.
 */
- (void)setTitleWithMnemonic:(null_unspecified NSString *)stringWithAmpersand NS_DEPRECATED_MAC(10_0, 10_8);
- (void)setAlternateTitleWithMnemonic:(null_unspecified NSString *)stringWithAmpersand NS_DEPRECATED_MAC(10_0, 10_8);

/* This method no longer does anything and should not be called.
 */
- (void)setAlternateMnemonicLocation:(NSUInteger)location NS_DEPRECATED_MAC(10_0, 10_8);

/* On 10.8, alternateMnemonicLocation now always returns NSNotFound.
 */
- (NSUInteger)alternateMnemonicLocation NS_DEPRECATED_MAC(10_0, 10_8);

- (null_unspecified NSString *)alternateMnemonic NS_DEPRECATED_MAC(10_0, 10_8);
@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                       NSCIImageRep.h                                                                                      0100644 0001750 0001750 00000001570 12567220725 033340  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSCIImageRep.h
        Application Kit
        Copyright (c) 2003-2015, Apple Inc.
        All rights reserved.
*/

#import <AppKit/NSImageRep.h>
#import <AppKit/NSGraphics.h>
#import <QuartzCore/CIImage.h>


NS_ASSUME_NONNULL_BEGIN

@class NSBitmapImageRep;

@interface NSCIImageRep : NSImageRep
{
    CIImage *_ciImage;
}
+ (instancetype)imageRepWithCIImage:(CIImage *)image;
- (instancetype)initWithCIImage:(CIImage *)image;
@property (readonly, strong) CIImage *CIImage;
@end

@interface CIImage (NSAppKitAdditions)
- (nullable instancetype)initWithBitmapImageRep:(NSBitmapImageRep *)bitmapImageRep;

- (void)drawInRect:(NSRect)rect fromRect:(NSRect)fromRect operation:(NSCompositingOperation)op fraction:(CGFloat)delta;
- (void)drawAtPoint:(NSPoint)point fromRect:(NSRect)fromRect operation:(NSCompositingOperation)op fraction:(CGFloat)delta;
@end

NS_ASSUME_NONNULL_END

                                                                                                                                        NSCachedImageRep.h                                                                                  0100644 0001750 0001750 00000001665 12567220725 034221  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSCachedImageRep.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSImageRep.h>
#import <AppKit/NSGraphics.h>

@class NSWindow;

// this entire class is deprecated.  Please see the 10.6 AppKit release notes for more information.
NS_CLASS_DEPRECATED_MAC(10_0, 10_6)
@interface NSCachedImageRep : NSImageRep {
    /*All instance variables are private*/
    NSPoint _origin;
    NSWindow *_window;
    __strong void *_cache;
}

/* References the specified rect within the window; the window is retained */
- (id)initWithWindow:(NSWindow *)win rect:(NSRect)rect NS_DEPRECATED_MAC(10_0, 10_6);

/* Creates a location in some window. Will be freed when rep is freed */
- (id)initWithSize:(NSSize)size depth:(NSWindowDepth)depth separate:(BOOL)flag alpha:(BOOL)alpha NS_DEPRECATED_MAC(10_0, 10_6);

- (NSWindow *)window NS_DEPRECATED_MAC(10_0, 10_6);
- (NSRect)rect NS_DEPRECATED_MAC(10_0, 10_6);

@end
                                                                           NSCell.h                                                                                            0100644 0001750 0001750 00000051246 12567220725 032317  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSCell.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSGeometry.h>
#import <AppKit/NSText.h>
#import <AppKit/NSParagraphStyle.h>
#import <AppKit/NSApplication.h>
#import <AppKit/NSUserInterfaceItemIdentification.h>
#import <AppKit/NSAccessibilityProtocols.h>

NS_ASSUME_NONNULL_BEGIN

@class NSAttributedString, NSEvent, NSFont, NSFormatter, NSImage, NSMenu, NSText, NSView, NSTextView, NSDraggingImageComponent;

typedef NS_ENUM(NSUInteger, NSCellType) {
    NSNullCellType			= 0,
    NSTextCellType			= 1,
    NSImageCellType			= 2
};


typedef NS_ENUM(NSUInteger, NSCellAttribute) {
    NSCellDisabled			= 0,
    NSCellState				= 1,
    NSPushInCell			= 2,
    NSCellEditable			= 3,
    NSChangeGrayCell			= 4,
    NSCellHighlighted			= 5,
    NSCellLightsByContents		= 6,
    NSCellLightsByGray			= 7,
    NSChangeBackgroundCell		= 8,
    NSCellLightsByBackground		= 9,
    NSCellIsBordered			= 10,
    NSCellHasOverlappingImage		= 11,
    NSCellHasImageHorizontal		= 12,
    NSCellHasImageOnLeftOrBottom	= 13,
    NSCellChangesContents		= 14,
    NSCellIsInsetButton		= 15,
    NSCellAllowsMixedState		= 16
};


typedef NS_ENUM(NSUInteger, NSCellImagePosition) {
    NSNoImage				= 0,
    NSImageOnly				= 1,
    NSImageLeft				= 2,
    NSImageRight			= 3,
    NSImageBelow			= 4,
    NSImageAbove			= 5,
    NSImageOverlaps			= 6
};


typedef NS_ENUM(NSUInteger, NSImageScaling) {
    NSImageScaleProportionallyDown = 0, // Scale image down if it is too large for destination. Preserve aspect ratio.
    NSImageScaleAxesIndependently,      // Scale each dimension to exactly fit destination. Do not preserve aspect ratio.
    NSImageScaleNone,                   // Do not scale.
    NSImageScaleProportionallyUpOrDown, // Scale image to maximum possible dimensions while (1) staying within destination area (2) preserving aspect ratio
    
    NSScaleProportionally NS_ENUM_DEPRECATED_MAC(10_0, 10_10, "Use NSImageScaleProportionallyDown instead") = 0,
    NSScaleToFit NS_ENUM_DEPRECATED_MAC(10_0, 10_10, "Use NSImageScaleAxesIndependently instead"),
    NSScaleNone NS_ENUM_DEPRECATED_MAC(10_0, 10_10, "Use NSImageScaleNone instead")
} NS_ENUM_AVAILABLE_MAC(10_5);


enum {
    NSMixedState = -1,
    NSOffState   =  0,
    NSOnState    =  1
};
typedef NSInteger NSCellStateValue;


/* ButtonCell highlightsBy and showsStateBy mask */
typedef NS_OPTIONS(NSUInteger, NSCellStyleMask) {
    NSNoCellMask			= 0,
    NSContentsCellMask			= 1,
    NSPushInCellMask			= 2,
    NSChangeGrayCellMask		= 4,
    NSChangeBackgroundCellMask		= 8
};

typedef NS_ENUM(NSUInteger, NSControlTint) {
    NSDefaultControlTint  = 0,	// system 'default'
    NSBlueControlTint     = 1,
    NSGraphiteControlTint = 6,
    NSClearControlTint    = 7
};


typedef NS_ENUM(NSUInteger, NSControlSize) {
    NSRegularControlSize,
    NSSmallControlSize, 
    NSMiniControlSize
};

typedef struct __CFlags {
    unsigned int        state:1;
    unsigned int        highlighted:1;
    unsigned int        disabled:1;
    unsigned int        editable:1;
    NSCellType          type:2;
    unsigned int        vCentered:1;
    unsigned int        hCentered:1;
    unsigned int        bordered:1;
    unsigned int        bezeled:1;
    unsigned int        selectable:1;
    unsigned int        scrollable:1;
    unsigned int        continuous:1;
    unsigned int        actOnMouseDown:1;
    unsigned int        isLeaf:1;
    unsigned int        invalidObjectValue:1;
    unsigned int        invalidFont:1;
    NSLineBreakMode     lineBreakMode:3;
    unsigned int        weakTargetHelperFlag:1;
    unsigned int        allowsAppearanceEffects:1;
    unsigned int        singleLineMode:1;
    unsigned int        actOnMouseDragged:1;
    unsigned int        isLoaded:1;
    unsigned int        truncateLastLine:1;
    unsigned int        dontActOnMouseUp:1;
    unsigned int        isWhite:1;
    unsigned int        useUserKeyEquivalent:1;
    unsigned int        showsFirstResponder:1;
    unsigned int        focusRingType:2;
    unsigned int        wasSelectable:1;
    unsigned int        hasInvalidObject:1;
    unsigned int        allowsEditingTextAttributes:1;
    unsigned int        importsGraphics:1;
    NSTextAlignment     alignment:3;
    unsigned int        layoutDirectionRTL:1;
    unsigned int        backgroundStyle:3;
    unsigned int        cellReserved2:4;
    unsigned int        refusesFirstResponder:1;
    unsigned int        needsHighlightedText:1;
    unsigned int        dontAllowsUndo:1;
    unsigned int        currentlyEditing:1;
    unsigned int        allowsMixedState:1;
    unsigned int        inMixedState:1;
    unsigned int        sendsActionOnEndEditing:1;
    unsigned int        inSendAction:1;
    unsigned int        menuWasSet:1;
    unsigned int        controlTint:3;
    unsigned int        controlSize:2;
    unsigned int        branchImageDisabled:1;
    unsigned int        drawingInRevealover:1;
    unsigned int        needsHighlightedTextHint:1;
} _CFlags;


@interface NSCell : NSObject <NSCopying, NSCoding, NSUserInterfaceItemIdentification, NSAccessibilityElement, NSAccessibility>
{
    /*All instance variables are private*/
    id _contents;
    _CFlags _cFlags;
@private
    // This variable should *only* be accessed through the following methods:
    // setImage:, image, setFont:, and font
    id _support;
}


+ (BOOL)prefersTrackingUntilMouseUp;


- (instancetype)initTextCell:(NSString *)aString;
- (instancetype)initImageCell:(nullable NSImage *)image;

@property (nullable, assign) NSView *controlView; // Must be an NSControl subclass, non-control view subclasses not allowed!
@property NSCellType type;
@property NSInteger state;
@property (nullable, weak) id target; // Target is weak for zeroing-weak compatible objects in apps linked on 10.10 or later. Otherwise the behavior of this property is 'assign'.
@property (nullable) SEL action;
@property NSInteger tag;
@property (copy) NSString *title;
@property (getter=isOpaque, readonly) BOOL opaque;
@property (getter=isEnabled) BOOL enabled;
- (NSInteger)sendActionOn:(NSInteger)mask;
@property (getter=isContinuous) BOOL continuous;
@property (getter=isEditable) BOOL editable;
@property (getter=isSelectable) BOOL selectable;
@property (getter=isBordered) BOOL bordered;
@property (getter=isBezeled) BOOL bezeled;
@property (getter=isScrollable) BOOL scrollable; /* If YES, sets wraps to NO */
@property (getter=isHighlighted) BOOL highlighted;
@property NSTextAlignment alignment;
@property BOOL wraps;    /* If YES, sets scrollable to NO */
@property (nullable, strong) NSFont *font;
@property (readonly, copy) NSString *keyEquivalent;
@property (nullable, strong) __kindof NSFormatter *formatter;
@property (nullable, copy) id /* id <NSCopying> */ objectValue;
@property (readonly) BOOL hasValidObjectValue;
@property (copy) NSString *stringValue;
- (NSComparisonResult)compare:(id)otherCell;
@property int intValue;
@property float floatValue;
@property double doubleValue;
- (void)takeIntValueFrom:(nullable id)sender;
- (void)takeFloatValueFrom:(nullable id)sender;
- (void)takeDoubleValueFrom:(nullable id)sender;
- (void)takeStringValueFrom:(nullable id)sender;
- (void)takeObjectValueFrom:(nullable id)sender;
@property (nullable, strong) NSImage *image;
@property NSControlTint controlTint;
@property NSControlSize controlSize;
@property (nullable, strong) id representedObject;
- (NSInteger)cellAttribute:(NSCellAttribute)aParameter;
- (void)setCellAttribute:(NSCellAttribute)aParameter to:(NSInteger)value;
- (NSRect)imageRectForBounds:(NSRect)theRect;
- (NSRect)titleRectForBounds:(NSRect)theRect;
- (NSRect)drawingRectForBounds:(NSRect)theRect;
@property (readonly) NSSize cellSize;
- (NSSize)cellSizeForBounds:(NSRect)aRect;
- (NSColor *)highlightColorWithFrame:(NSRect)cellFrame inView:(NSView *)controlView;
- (void)calcDrawInfo:(NSRect)aRect;
- (NSText *)setUpFieldEditorAttributes:(NSText *)textObj;
- (void)drawInteriorWithFrame:(NSRect)cellFrame inView:(NSView *)controlView;
- (void)drawWithFrame:(NSRect)cellFrame inView:(NSView *)controlView;
- (void)highlight:(BOOL)flag withFrame:(NSRect)cellFrame inView:(NSView *)controlView;
@property (readonly) NSInteger mouseDownFlags;
- (void)getPeriodicDelay:(float *)delay interval:(float *)interval;
- (BOOL)startTrackingAt:(NSPoint)startPoint inView:(NSView *)controlView;
- (BOOL)continueTracking:(NSPoint)lastPoint at:(NSPoint)currentPoint inView:(NSView *)controlView;
- (void)stopTracking:(NSPoint)lastPoint at:(NSPoint)stopPoint inView:(NSView *)controlView mouseIsUp:(BOOL)flag;
- (BOOL)trackMouse:(NSEvent *)theEvent inRect:(NSRect)cellFrame ofView:(NSView *)controlView untilMouseUp:(BOOL)flag;
- (void)editWithFrame:(NSRect)aRect inView:(NSView *)controlView editor:(NSText *)textObj delegate:(nullable id)anObject event:(NSEvent *)theEvent;
- (void)selectWithFrame:(NSRect)aRect inView:(NSView *)controlView editor:(NSText *)textObj delegate:(nullable id)anObject start:(NSInteger)selStart length:(NSInteger)selLength;
- (void)endEditing:(NSText *)textObj;
- (void)resetCursorRect:(NSRect)cellFrame inView:(NSView *)controlView;

@property (nullable, strong) NSMenu *menu;
- (nullable NSMenu *)menuForEvent:(NSEvent *)event inRect:(NSRect)cellFrame ofView:(NSView *)view;
+ (nullable NSMenu *)defaultMenu;

@property BOOL sendsActionOnEndEditing;

@property NSWritingDirection baseWritingDirection;

@property NSLineBreakMode lineBreakMode;

@property BOOL allowsUndo;

@property NSInteger integerValue NS_AVAILABLE_MAC(10_5);
- (void)takeIntegerValueFrom:(nullable id)sender NS_AVAILABLE_MAC(10_5);

/* Truncates and adds the ellipsis character to the last visible line if the text doesn't fit into the cell bounds. The setting is ignored if -lineBreakMode is neither NSLineBreakByWordWrapping nor NSLineBreakByCharWrapping.
 */
@property BOOL truncatesLastVisibleLine NS_AVAILABLE_MAC(10_5);

/* Bi-directional User Interface. It specifies the general UI layout flow directions.
*/
@property NSUserInterfaceLayoutDirection userInterfaceLayoutDirection NS_AVAILABLE_MAC(10_6);

/* Returns a custom field editor for editing inside aControlView. This is an override point for NSCell subclasses designed to work with its own custom field editor. This message is sent to the selected cell of aControlView in -[NSWindow fieldEditor:forObject:]. Returning non-nil from this method indicates skipping the standard field editor querying processes including -windowWillReturnFieldEditor:toObject: delegation. The default NSCell implementation returns nil. The field editor returned from this method should have isFieldEditor == YES.
 */
- (nullable NSTextView *)fieldEditorForView:(NSView *)aControlView NS_AVAILABLE_MAC(10_6);

/* Tells the text cell to layout/render its content in single-line. If YES, the cell ignores the return value from -wraps, interprets NSLineBreakByWordWrapping and NSLineBreakByCharWrapping from -lineBreakMode as NSLineBreakByClipping, and configures the field editor to ignore key binding commands that insert paragraph/line separators. Also, the field editor bound to a single line cell filters paragraph/line separator insertion from user actions. Cells in the single line mode use the fixed baseline layout. The text baseline position is determined solely by the control size regardless of content font style/size.
 */
@property BOOL usesSingleLineMode NS_AVAILABLE_MAC(10_6);

/* Multi-image Drag Support. The default implementation will return an array of up to two NSDraggingImageComponent instances -- one for the image portion and another for the text portion (if appropriate). This method can be subclassed and overridden to provide a custom set of NSDraggingImageComponents to create the drag image for the cell. This method is generally used by NSTableView/NSOutlineView.
 */
- (NSArray<NSDraggingImageComponent *> *)draggingImageComponentsWithFrame:(NSRect)frame inView:(NSView *)view NS_AVAILABLE_MAC(10_7);

@end

@interface NSCell(NSKeyboardUI)
@property BOOL refusesFirstResponder;
@property (readonly) BOOL acceptsFirstResponder;
@property BOOL showsFirstResponder;

- (void)performClick:(nullable id)sender;

@property NSFocusRingType focusRingType;
+ (NSFocusRingType)defaultFocusRingType;

- (void)drawFocusRingMaskWithFrame:(NSRect)cellFrame inView:(NSView *)controlView NS_AVAILABLE_MAC(10_7);
- (NSRect)focusRingMaskBoundsForFrame:(NSRect)cellFrame inView:(NSView *)controlView NS_AVAILABLE_MAC(10_7);

@property (readonly) BOOL wantsNotificationForMarkedText; // If the receiver returns YES, the field editor initiated by it posts text change notifications (i.e. NSTextDidChangeNotification) while editing marked text; otherwise, they are delayed until the marked text confirmation. The NSCell's implementation returns NO.
@end

@interface NSCell(NSCellAttributedStringMethods)
@property (copy) NSAttributedString *attributedStringValue;
/* These methods determine whether the user can modify text attributes and import graphics in a rich cell.  Note that whatever these flags are, cells can still contain attributed text if programmatically set. */
@property BOOL allowsEditingTextAttributes;       /* If NO, also clears setImportsGraphics: */
@property BOOL importsGraphics;                   /* If YES, also sets setAllowsEditingTextAttributes: */
@end

@interface NSCell(NSCellMixedState)	/* allow button to have mixed state value*/
@property BOOL allowsMixedState;
@property (readonly) NSInteger nextState;			/* get next state state in cycle */
- (void)setNextState;			/* toggle/cycle through states */
@end

APPKIT_EXTERN NSString * NSControlTintDidChangeNotification; /* sent after user changes control tint preference */

/* Cell Hit testing support */

typedef NS_OPTIONS(NSUInteger, NSCellHitResult) {
    // An empty area, or did not hit in the cell
    NSCellHitNone = 0,
    // A content area in the cell
    NSCellHitContentArea = 1 << 0,
    // An editable text area of the cell
    NSCellHitEditableTextArea = 1 << 1,
    // A trackable area in the cell
    NSCellHitTrackableArea = 1 << 2,
} NS_ENUM_AVAILABLE_MAC(10_5);

@interface NSCell(NSCellHitTest)
/* Return hit testing information for the cell. Use a bit-wise mask to look for a specific value when calling the method. Generally, this should be overridden by custom NSCell subclasses to return the correct result. Currently, it is called by some multi-cell views, such as NSTableView.

    By default, NSCell will look at the cell type and do the following:

    NSImageCellType: 
        If the image exists, and the event point is in the image return NSCellHitContentArea, else NSCellHitNone.

    NSTextCellType (also applies to NSTextFieldCell): 
        If there is text:
            If the event point hits in the text, return NSCellHitContentArea. Additionally, if the cell is enabled return NSCellHitContentArea | NSCellHitEditableTextArea.
        If there is not text:
            Returns NSCellHitNone.

    NSNullCellType (this is the default that applies to non text or image cells who don't override hitTestForEvent:):
        Return NSCellHitContentArea by default.
        If the cell not disabled, and it would track, return NSCellHitContentArea | NSCellHitTrackableArea.
*/
- (NSCellHitResult)hitTestForEvent:(NSEvent *)event inRect:(NSRect)cellFrame ofView:(NSView *)controlView NS_AVAILABLE_MAC(10_5);
@end

@interface NSCell(NSCellExpansion)
/*  Allows the cell to return an expansion cell frame if cellFrame is too small for the entire contents in the view. When the mouse is hovered over the cell in certain controls, the full cell contents will be shown in a special floating tool tip view. If the frame is not too small, return an empty rect, and no expansion tool tip view will be shown. By default, NSCell returns NSZeroRect, while some subclasses (such as NSTextFieldCell) will return the proper frame when required. 
*/
- (NSRect)expansionFrameWithFrame:(NSRect)cellFrame inView:(NSView *)view NS_AVAILABLE_MAC(10_5);

/* Allows the cell to perform custom expansion tool tip drawing. Note that the view may be different from the original view that the cell appeared in. By default, NSCell simply calls drawWithFrame:inView:.
*/
- (void)drawWithExpansionFrame:(NSRect)cellFrame inView:(NSView *)view NS_AVAILABLE_MAC(10_5);
@end

typedef NS_ENUM(NSInteger, NSBackgroundStyle) {
    NSBackgroundStyleLight = 0,	// The background is a light color. Dark content contrasts well with this background.
    NSBackgroundStyleDark,	// The background is a dark color. Light content contrasts well with this background.
    NSBackgroundStyleRaised,	// The background is intended to appear higher than the content drawn on it. Content might need to be inset.
    NSBackgroundStyleLowered	// The background is intended to appear lower than the content drawn on it. Content might need to be embossed.
} NS_ENUM_AVAILABLE_MAC(10_5);

@interface NSCell (NSCellBackgroundStyle)

/* Describes the surface the cell is drawn onto in -[NSCell drawWithFrame:inView:]. A control typically sets this before it asks the cell to draw. A cell may draw differently based on background characteristics. For example, a tableview drawing a cell in a selected row might call [cell setBackgroundStyle:NSBackgroundStyleDark]. A text cell might decide to render its text white as a result. A rating-style level indicator might draw its stars white instead of gray.
 */
@property NSBackgroundStyle backgroundStyle NS_AVAILABLE_MAC(10_5);


/* Describes the surface drawn onto in -[NSCell drawInteriorWithFrame:inView:]. This is often the same as the backgroundStyle, but a button that draws a bezel would have a different interiorBackgroundStyle.  
 
 This is both an override point and a useful method to call. A button that draws a custom bezel would override this to describe that surface. A cell that has custom interior drawing might query this method to help pick an image that looks good on the cell. Calling this method gives you some independence from changes in framework art style.
 */
@property (readonly) NSBackgroundStyle interiorBackgroundStyle NS_AVAILABLE_MAC(10_5);

@end


@interface NSCell (NSDeprecated)

// Use formatters instead.  See -[NSCell formatter] and -[NSCell setFormatter:].
- (NSInteger)entryType NS_DEPRECATED_MAC(10_0, 10_0);
- (void)setEntryType:(NSInteger)aType NS_DEPRECATED_MAC(10_0, 10_0);
- (BOOL)isEntryAcceptable:(NSString *)aString NS_DEPRECATED_MAC(10_0, 10_0);
- (void)setFloatingPointFormat:(BOOL)autoRange left:(NSUInteger)leftDigits right:(NSUInteger)rightDigits NS_DEPRECATED_MAC(10_0, 10_0);

/* In 10.8 and higher, all the *Mnemonic* methods are deprecated. On MacOS they have typically not been used.
 */
- (void)setMnemonicLocation:(NSUInteger)location NS_DEPRECATED_MAC(10_0, 10_8);
- (NSUInteger)mnemonicLocation NS_DEPRECATED_MAC(10_0, 10_8);
- (NSString *)mnemonic NS_DEPRECATED_MAC(10_0, 10_8);
- (void)setTitleWithMnemonic:(NSString *)stringWithAmpersand NS_DEPRECATED_MAC(10_0, 10_8);

@end


/* Draw an image from two end caps and a fill.  The end caps are scaled proportionally to match the thickness of the destination frame.  In the horizontal case, the startCap is drawn into the left part of the destination, the endCap is drawn into the right part of the destination, and the fill is tiled over the remaining area.  The caps and the fill should all be the same height.  The vertical case is similar.  
 
 This is an appropriate way to draw the bezel of a button that can be resized in one dimension.
 */
APPKIT_EXTERN void NSDrawThreePartImage(NSRect frame, NSImage * __nullable startCap, NSImage * __nullable centerFill, NSImage * __nullable endCap, BOOL vertical, NSCompositingOperation op, CGFloat alphaFraction, BOOL flipped) NS_AVAILABLE_MAC(10_5);

/* Draw an image from nine pieces.  When drawn, the destination rect is partitioned into nine rectangular regions: the corner pieces are the natural size of the corner images, the edge pieces are the natural size of the edge fill images in the direction perpendicular to the edge and flush with the corners.  The center rect fills the remaining space.  The supplied images and fills are drawn into the corresponding regions, with fill images tiled at their natural dimensions.  Images that share a border should have the same thickness in that dimension.  
 
 This method is appropriate for the bezel of a control, like a box, that can be resized in both dimensions.
 */
APPKIT_EXTERN void NSDrawNinePartImage(NSRect frame, NSImage * topLeftCorner, NSImage * topEdgeFill, NSImage * topRightCorner, NSImage * leftEdgeFill, NSImage * centerFill, NSImage * rightEdgeFill, NSImage * bottomLeftCorner, NSImage * bottomEdgeFill, NSImage * bottomRightCorner, NSCompositingOperation op, CGFloat alphaFraction, BOOL flipped) NS_AVAILABLE_MAC(10_5);

enum {
    NSAnyType				= 0,
    NSIntType				= 1,
    NSPositiveIntType			= 2,
    NSFloatType				= 3,
    NSPositiveFloatType		= 4,
    NSDoubleType			= 6,
    NSPositiveDoubleType		= 7
} NS_ENUM_DEPRECATED_MAC(10_0, 10_10, "Use formatters instead");

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                          NSClickGestureRecognizer.h                                                                          0100644 0001750 0001750 00000002056 12567220726 036050  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSClickGestureRecognizer.h
    Application Kit
    Copyright (c) 2013-2015, Apple Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>
#import <AppKit/NSGestureRecognizer.h>

NS_ASSUME_NONNULL_BEGIN

NS_CLASS_AVAILABLE(10_10, NA)
@interface NSClickGestureRecognizer : NSGestureRecognizer <NSCoding> {
@private
    NSInteger _flags;
    NSPoint _location;
    NSUInteger _buttonMask;
    NSInteger _numberOfClicksRequired;
    NSInteger _currentButtonCount;
    NSInteger _activeButtonCount;
    NSInteger _currentClickCount;
    id _reserved0;
#ifndef __OBJC2__
    NSInteger _reserved1;
#endif
}

/* bitfield of the button(s) required to recognize this click where bit 0 is the primary button, 1 is the secondary button, etc...
   NSClickGestureRecognizer dynamically returns YES to delay primary, secondary and other mouse events depending on this value.
*/
@property NSUInteger buttonMask; // Defaults to 0x1

/* the number of clicks required to match */
@property NSInteger numberOfClicksRequired; // Defaults to 1

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  NSClipView.h                                                                                        0100644 0001750 0001750 00000007556 12567220725 033167  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSClipView.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSView.h>

#ifndef NSEDGEINSETS_DEFINED
#import <AppKit/NSLayoutConstraint.h>
#endif

NS_ASSUME_NONNULL_BEGIN

@class NSColor, NSNotification;

@interface NSClipView : NSView
{
    /*All instance variables are private*/
    NSColor             *_backgroundColor;
    NSView              *_docView;
    NSRect              _docRect;
    NSRect              _oldDocFrame;
    NSCursor            *_cursor;
    id                  _scrollAnimationHelper;
    struct __cvFlags {
	unsigned int        __unused:1;
	unsigned int        onlyUncovered:1;
	unsigned int        reflectScroll:1;
	unsigned int        usedByCell:1;
	unsigned int	    scrollClipTo:1;
	unsigned int	    noCopyOnScroll:1;
        unsigned int        drawsBackground:1;
        unsigned int        scrollInProgress:1;
        unsigned int        skipRemoveSuperviewCheck:1;
        unsigned int        animateCurrentScroll:1;
        unsigned int        canAnimateScrolls:1;
        unsigned int	    nextScrollRelativeToCurrentPosition:1;
        unsigned int        viewBoundsChangedOverridden:1;
        unsigned int        viewFrameChangedOverridden:1;
        unsigned int        documentViewAlignment:4;
        unsigned int        redrawnWhileScrolling:1;
        unsigned int        dontConstrainScroll:1;
        unsigned int        lastAtEdgesState:4;
        unsigned int        showOverlayScrollersForScrollStep:1;
        unsigned int        scrollerKnobFlashSpecifier:2;
        unsigned int        drawsContentShadow:1;
        unsigned int        dontConstrainBoundsChange:1;
        unsigned int        isScrollDueToUserAction:1;
        unsigned int        hasOverlappingViews:1;
        unsigned int        automaticallyCalculateContentSize:1;
    } _cvFlags;
}

@property (copy) NSColor *backgroundColor;
@property BOOL drawsBackground;
@property (nullable, assign) id /* NSView * */ documentView;
@property (readonly) NSRect documentRect;
@property (nullable, strong) NSCursor *documentCursor;
@property (readonly) NSRect documentVisibleRect;
- (void)viewFrameChanged:(NSNotification *)notification;
- (void)viewBoundsChanged:(NSNotification *)notification;
@property BOOL copiesOnScroll;
- (BOOL)autoscroll:(NSEvent *)theEvent;
- (void)scrollToPoint:(NSPoint)newOrigin;

/* This is used to constrain the bounds of the clip view under magnification and scrolling. This also comes with the deprecation of -constrainScrollPoint:. The logic of an existing -constrainScrollPoint: can be moved to -constrainBoundsRect: by adjusting the proposedBound's origin (as opposed to 'newOrigin').
 
 To preserve compatibility, if a subclass overrides -constrainScrollPoint:, the default behavior of -constrainBoundsRect: will be to use that -constrainScrollPoint: to adjust the proposedBound's origin, and to not change the size.
 */
- (NSRect)constrainBoundsRect:(NSRect)proposedBounds NS_AVAILABLE_MAC(10_9);

/* The distance that the content view is inset from the enclosing scroll view.
   Note: animate with [self animator]
*/
@property NSEdgeInsets contentInsets NS_AVAILABLE_MAC(10_10);

/* When YES, and used as the contentView of an NSScrollView, the clip view will automatically account for other scroll view subviews such as rulers and headers. Defaults to YES.
*/
@property BOOL automaticallyAdjustsContentInsets NS_AVAILABLE_MAC(10_10);

@end

@interface NSClipView(NSDeprecated)
// -[NSClipView constrainScrollPoint:] will be formally deprecated in an upcoming release. -[NSClipView constrainBoundsRect:] should be used instead.
- (NSPoint)constrainScrollPoint:(NSPoint)newOrigin NS_DEPRECATED_MAC(10_0, 10_10, "Use -constrainBoundsRect: instead");
@end

@interface NSView(NSClipViewSuperview)
- (void)reflectScrolledClipView:(NSClipView *)aClipView;
- (void)scrollClipView:(NSClipView *)aClipView toPoint:(NSPoint)aPoint;
@end

NS_ASSUME_NONNULL_END
                                                                                                                                                  NSCollectionView.h                                                                                  0100644 0001750 0001750 00000165312 12567220726 034367  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSCollectionView.h
    Application Kit
    Copyright (c) 2005-2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/NSView.h>
#import <AppKit/NSViewController.h>
#import <AppKit/NSDragging.h>
#import <Foundation/NSArray.h>

typedef NS_ENUM(NSInteger, NSCollectionViewDropOperation) {
    NSCollectionViewDropOn = 0,
    NSCollectionViewDropBefore = 1,
} NS_ENUM_AVAILABLE_MAC(10_6);

typedef NS_ENUM(NSInteger, NSCollectionViewItemHighlightState) {
    NSCollectionViewItemHighlightNone = 0,
    NSCollectionViewItemHighlightForSelection = 1,
    NSCollectionViewItemHighlightForDeselection = 2,
    NSCollectionViewItemHighlightAsDropTarget = 3,
} NS_ENUM_AVAILABLE_MAC(10_11);

/* Used with NSCollectionView's -selectItemsAtIndexPaths:scrollPosition: and -scrollToItemsAtIndexPaths:scrollPosition: to specify how the bounding box of the specified items should be positioned within the CollectionView's visibleRect.  NSCollectionView will try to satisfy this request as closely as feasible, while staying within the enclosing ClipView's scrollable range.
*/
typedef NS_OPTIONS(NSUInteger, NSCollectionViewScrollPosition) {
    NSCollectionViewScrollPositionNone                 = 0,
    
    /* The vertical positions are mutually exclusive to each other, but are bitwise or-able with the horizontal scroll positions.  Combining positions from the same grouping (horizontal or vertical) will result in an NSInvalidArgumentException.
    */
    NSCollectionViewScrollPositionTop                   = 1 << 0,
    NSCollectionViewScrollPositionCenteredVertically    = 1 << 1,
    NSCollectionViewScrollPositionBottom                = 1 << 2,
    NSCollectionViewScrollPositionNearestHorizontalEdge = 1 << 9, /* Nearer of Top,Bottom */
    
    /* Likewise, the horizontal positions are mutually exclusive to each other.
    */
    NSCollectionViewScrollPositionLeft                 = 1 << 3,
    NSCollectionViewScrollPositionCenteredHorizontally = 1 << 4,
    NSCollectionViewScrollPositionRight                = 1 << 5,
    NSCollectionViewScrollPositionLeadingEdge          = 1 << 6, /* Left if LTR, Right if RTL */
    NSCollectionViewScrollPositionTrailingEdge         = 1 << 7, /* Right if LTR, Left, if RTL */
    NSCollectionViewScrollPositionNearestVerticalEdge  = 1 << 8, /* Nearer of Leading,Trailing */
};

@class NSCollectionView, NSCollectionViewLayout, NSCollectionViewLayoutAttributes, NSCollectionViewTransitionLayout, NSDraggingImageComponent, NSImageView, NSIndexSet, NSMutableIndexSet, NSNib, NSTextField;
@protocol NSCollectionViewDataSource, NSCollectionViewDelegate;

NS_ASSUME_NONNULL_BEGIN

/* NSCollectionViewElement declares functionality shared by (1) NSCollectionViewItems and (2) "supplementary" or "decoration" views that can be added to an NSCollectionView.  Each such reusable entity has the ability to be reset to its initial state by being sent -prepareForReuse, the ability to take size, position, and other state from an NSCollectionViewLayoutAttributes instance, and the ability to respond to transitions from one layout to another.  Note that, since these methods are all optional and invoked only when found to be present, all existing NSView classes can be considered conforming, and are therefore eligible to be used a supplementary and decorative views.  NSView and NSCollectionViewElement both conform to NSUserInterfaceItemIdentification, which provides an "identifier" property that CollectionView uses to track an item or supplementary/decoration view's kind.
 */
@protocol NSCollectionViewElement <NSObject, NSUserInterfaceItemIdentification>
@optional

/* Called by the NSCollectionView before the instance is returned from the reuse queue.  Subclassers must call super.  NSCollectionViewItem's implementation of this method sends -prepareForReuse to the ViewController's view.
 */
- (void)prepareForReuse NS_AVAILABLE_MAC(10_11);

/* Classes that want to support custom layout attributes specific to a given NSCollectionViewLayout subclass can apply them here.  This allows the view to work in conjunction with a layout class that returns a custom subclass of NSCollectionViewLayoutAttributes from -layoutAttributesForItem: or the corresponding layoutAttributesForHeader/Footer methods.  -applyLayoutAttributes: is then called after the view is added to the collection view and just before the view is returned from the reuse queue.  Note that -applyLayoutAttributes: is only called when attributes change, as defined by -isEqual:.
 */
- (void)applyLayoutAttributes:(NSCollectionViewLayoutAttributes *)layoutAttributes NS_AVAILABLE_MAC(10_11);

/* Override points for participating in layout transitions.  These messages are sent to a reusable part before and after the transition to a new layout occurs.
 */
- (void)willTransitionFromLayout:(NSCollectionViewLayout *)oldLayout toLayout:(NSCollectionViewLayout *)newLayout NS_AVAILABLE_MAC(10_11);
- (void)didTransitionFromLayout:(NSCollectionViewLayout *)oldLayout toLayout:(NSCollectionViewLayout *)newLayout NS_AVAILABLE_MAC(10_11);

/* Invoked when present to give a reusable entity the opportunity to make any desired final adjustments to its layout.
 */
- (NSCollectionViewLayoutAttributes *)preferredLayoutAttributesFittingAttributes:(NSCollectionViewLayoutAttributes *)layoutAttributes NS_AVAILABLE_MAC(10_11);

@end

/* An NSCollectionViewItem associates a visual representation (view subtree) with a representedObject of arbitrary type.  It also tracks whether the representedObject is part of the enclosing NSCollectionView's current selection.  Note that NSCollectionViewItem inherits some useful properties -- in particular, "representedObject" and "view" -- from NSViewController.
*/

NS_CLASS_AVAILABLE_MAC(10_5)
@interface NSCollectionViewItem : NSViewController <NSCopying, NSCollectionViewElement> {
@private
    NSCollectionView *_collectionView;
    struct {
        unsigned int isSelected:1;
        unsigned int suppressSelectionChangedNotification:1;
        unsigned int connectionsCopied:1;
        unsigned int highlightState:2;
        unsigned int wasDequeued:1;
        unsigned int stayHiddenAwaitingReuse:1;
        unsigned int stayHiddenAfterReuse:1;
        unsigned int updateAnimationCount:16;
        unsigned int dragging:1;
        unsigned int reserved:7;
    } _cviFlags;
    NSData *_cachedArchive;
    id _reserved2;
}

/* Non-retained backlink to the containing CollectionView.
*/
@property (readonly) NSCollectionView *collectionView;

/* Whether the item is part of its collectionView's current selection.
*/
@property (getter=isSelected) BOOL selected;

/* Whether the item should be shown as highlighted for proposed selection, deselection, as a drop target, or not highlighted.
*/
@property NSCollectionViewItemHighlightState highlightState NS_AVAILABLE_MAC(10_11);

/* Convenience outlet to the item's primary NSImageView (if any).
*/
@property (nullable, assign) IBOutlet NSImageView *imageView NS_AVAILABLE_MAC(10_7);

/* Convenience outlet to the item's primary NSTextField (if any).
*/
@property (nullable, assign) IBOutlet NSTextField *textField NS_AVAILABLE_MAC(10_7);

/* Multi-image drag and drop support. The default implementation will return an array of up to two NSDraggingImageComponent instances -- one for the imageView and another for the textField (if not nil). This methods can be subclassed and overridden to provide a custom set of NSDraggingImageComponents to create the drag image. Note: the component frames are relative to a coordinate system that has its origin at the bottom left, so you need to take into account the flippedness of your view when computing the component frames.
*/
@property (readonly) NSArray<NSDraggingImageComponent *> *draggingImageComponents NS_AVAILABLE_MAC(10_7);

@end

    
/* An NSCollectionView presents an ordered collection of items, with flexible, customizable appearance and layout.  The user may be permitted to select items, and/or drag items into and out of the CollectionView.
*/
NS_CLASS_AVAILABLE_MAC(10_5)
@interface NSCollectionView : NSView <NSDraggingSource, NSDraggingDestination> {
@private
    NSArray *_content;
    NSMutableIndexSet *_selectionIndexes;
    NSCollectionViewItem *_itemPrototype;
    NSSize _minItemSize;
    NSSize _maxItemSize;
    NSUInteger _maxGridRows;
    NSUInteger _maxGridColumns;
    NSArray *_backgroundColors;
    NSMutableArray *_displayedItems;
    NSTimeInterval _animationDuration;
    struct {
        unsigned int isFirstResponder:1;
        unsigned int invalidateItemViews:1;
        unsigned int selectable:1;
        unsigned int allowsMultipleSelection:1;
        unsigned int avoidsEmptySelection:1;
        unsigned int superviewIsClipView:1;
        unsigned int needsUpdateGrid:1;
        unsigned int needsUpdateBackground:1;
        unsigned int gridSettingsNeedUpdate:1;
        unsigned int guardSetFrameSize:1;
        unsigned int canDisplayItems:1;
        unsigned int animateForDrag:1;
        unsigned int unarchiving:1;
        unsigned int observingScroll:1;
        unsigned int scheduledResize:1;
        unsigned int isOpaque:1;
        unsigned int observingClipFrameChanges:1;
        unsigned int reserved:15;
    } _cvFlags;
    id _delegate;
    NSMutableArray *_backgroundLayers;
    NSSize _storedFrameSize;
    NSNib *_cachedNib;
    BOOL *_animTimerCancel;
    NSArray *_removedItems;
    NSArray *_addedItems;
    NSIndexSet *_addedItemIndexes;
    BOOL *_resizeTimerCancel;
    
    NSIndexSet *_draggedIndexes;
    NSDragOperation _draggingSourceOperationMaskForLocal;
    NSDragOperation _draggingSourceOperationMaskForNonLocal;
    NSInteger _currentDropIndex;
    NSInteger _currentDropSpaceIndex;
    NSInteger _shiftRow;
    NSDragOperation _currentDragOperation;
    NSCollectionViewDropOperation _currentDropOperation;
    id _draggingInfo;
    BOOL *_dragTimerCancel;
    
    id _private;
    void *_reserved[13];
}

#pragma mark *** Data Source / Model Objects ***

/* A non-retained data source object, that the CollectionView will consult to obtain information about the model objects to be represented and the number of sections to divide them among, and to make (recycle or instantiate) items and supplementary views.  See the NSCollectionViewDataSource protocol, declared below, for the methods this delegate should implement.

Defaults to nil, which makes the CollectionView look to its "content" property or NSContentBinding for model object information.  The "content" property should only be used with the default "Grid" collectionViewLayout and legacy -newItemForRepresentedObject: / itemPrototype mechanisms for instantiating items.

To get the new capabilities and behaviors, and use the new NSCollectionView APIs added in OS X 10.11, you must specify a dataSource.  Setting dataSource != nil causes the CollectionView to empty its "content" array, and attempting to set "content" to a non-empty array while dataSource != nil is considered a programming error that will cause an exception to be raised.
*/
@property (nullable, weak) id<NSCollectionViewDataSource> dataSource NS_AVAILABLE_MAC(10_11);

/* The array of model objects that will be shown as "items" in this CollectionView.  The objects may be of any type(s).  If you prefer not to give the CollectionView a "dataSource", you can set its "content" property explicitly, or bind the CollectionView's NSContentBinding to an NSArrayController's arrangedObjects property, to provide the CollectionView with its model objects.  A CollectionView whose content is provided in this way cannot have more than one section.

Each corresponding "item" instantiated by the CollectionView will have its representedObject property wired to the corresponding model object from this "content" array.  Attempts to set "content" to nil are ignored on OS X 10.10 and earlier.  On OS X 10.11 and later, setting "content" to nil raises an exception.  (Set "content" to an empty NSArray instead, if you want to empty the CollectionView.)
*/
@property (copy) NSArray<id> *content;

/* Call this method to reload all of the items in the collection view.  This causes the collection view to discard any currently visible items and redisplay them.  For efficiency, the collection view only displays those items and supplementary views that are visible.  If the collection data shrinks as a result of the reload, the collection view adjusts its scroll position accordingly.  You should not call this method in the middle of animation blocks where items are being inserted or deleted.  Insertions and deletions automatically cause the tables data to be updated appropriately.
*/
- (void)reloadData NS_AVAILABLE_MAC(10_11);


#pragma mark *** Delegate ***

/* An optional, non-retained delegate object, that will have the opportunity to influence the CollectionView's drag-and-drop, selection, highlighting, and layout transitioning behaviors.  See the NSCollectionViewDelegate protocol, declared below, for the methods this delegate may implement.  Defaults to nil, which leaves the CollectionView to determine its own behaviors.
*/
@property (nullable, assign) id<NSCollectionViewDelegate> delegate;


#pragma mark *** Decoration ***

@property (nullable, strong) NSView *backgroundView NS_AVAILABLE_MAC(10_11); // will be automatically resized to track the size of the collection view and placed behind all items and supplementary views.


#pragma mark *** Layout ***

/* The layout object that determines how the NSCollectionView's items will be sized and positioned.  Defaults to an instance of NSCollectionViewGridLayout whose maxNumberOfRows, maxNumberOfColumns, minItemSize, maxItemSize, and backgroundColors properties mirror the NSCollectionView's.  Replace this object, or change the values of its parameters, to change the layout.  collectionViewLayout may be set to nil for an NSCollectionView that is not using the dataSource-based API.

To get an animated transition to the new layout, use [[collectionView animator] setCollectionViewLayout:].  You can use NSAnimationContext's completionHandler provisions to notify you when the transition is complete.
*/
@property (nullable, strong) NSCollectionViewLayout *collectionViewLayout NS_AVAILABLE_MAC(10_11);

/* Returns the layout information for the item at the specified index path (or nil if no such item exists).  Use this method to retrieve the layout information for a particular item.  You should always use this method instead of querying the layout object directly.
*/
- (nullable NSCollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Returns the layout information for the specified supplementary view.

Use this method to retrieve the layout information for a particular supplementary view. You should always use this method instead of querying the layout object directly.
*/
- (nullable NSCollectionViewLayoutAttributes *)layoutAttributesForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Returns the frame calculated by the receiver where it intends to place the subview for the NSCollectionViewItem at the given index. You can use this method in the draggingImage methods to determine which views are in the visible portion of the enclosing scroll view. Overriding this method will have no effect on the receiver's subview layout. For apps that target OS X 10.11 and later, you may want to use -layoutAttributesForItemAtIndexPath: instead, which provides more than just the item's frame. This method raises an exception if invoked for a CollectionView that has more than one section. Use -layoutAttributesForItemAtIndexPath: instead.
*/
- (NSRect)frameForItemAtIndex:(NSUInteger)index NS_AVAILABLE_MAC(10_6);

/* Returns the frame calculated by the receiver where it would place a subview for an NSCollectionViewItem at the given index in a collection with the given number of items. You should use this method when updating NSDraggingItem frames when your collection is a drag destination. You should not use -frameForItemAtIndex:, since a drag and drop operation may change the number of items in the collection, which affects the layout of the item views. This method raises an exception if invoked for a CollectionView that has more than one section. Use -layoutAttributesForItemAtIndexPath: instead.
*/
- (NSRect)frameForItemAtIndex:(NSUInteger)index withNumberOfItems:(NSUInteger)numberOfItems NS_AVAILABLE_MAC(10_7);

/* The following properties pertain only to NSCollectionViewGridLayout, and will be deprecated in a future release.  When you set collectionViewLayout to point to an instance of this class (or a subclass), these NSCollectionView properties take on the corresponding property values of the NSCollectionViewGridLayout.  When collectionViewLayout points to any other kind of layout object, these properties remember the values they are given, but they don't affect item layout or display.  When targeting OS X 10.11 and later, it's recommended that you reference the corresponding NSCollectionViewGridLayout properties instead.
*/
@property NSUInteger maxNumberOfRows;       // default: 0, which means no limit
@property NSUInteger maxNumberOfColumns;    // default: 0, which means no limit
@property NSSize minItemSize;               // default: (0; 0)
@property NSSize maxItemSize;               // default: (0; 0), which means no limit
@property (null_resettable, copy) NSArray<NSColor *> *backgroundColors; // passing nil resets the background colors back to the default


#pragma mark *** Section and Item Counts ***

/* The number of sections displayed by the collection view.
*/
@property(readonly) NSInteger numberOfSections NS_AVAILABLE_MAC(10_11);

/* Returns the number of items in the specified "section".
*/
- (NSInteger)numberOfItemsInSection:(NSInteger)section NS_AVAILABLE_MAC(10_11);

#pragma mark *** Selection State ***

/* Whether the CollectionView is its window's current firstResponder.  This bindable property is useful for determining appropriate appearance for selected items.
 */
@property (getter=isFirstResponder, readonly) BOOL firstResponder;

/* Whether the user can select items in the CollectionView.  Defaults to NO.  Changing this from YES to NO clears the CollectionView's current selection (if any), causing selectionIndexes to become an empty index set.
 */
@property (getter=isSelectable) BOOL selectable;

/* Whether the CollectionView allows its selection to become empty.  Defaults to YES.  When this is set to NO and "selectable" is YES, the CollectionView will attempt to always leave at least one item selected, when the CollectionView has at least one item.
 */
@property BOOL allowsEmptySelection NS_AVAILABLE_MAC(10_11);

/* Whether the user can simultaneously select multiple items in the CollectionView.  Defaults to NO, which means only one item at a time (or none) may be selected.  Changing this from YES to NO causes the CollectionView's selection to be reduced to the selected item with the lowest index in the section with the lowest index, if more than one item was selected.
 */
@property BOOL allowsMultipleSelection;

/* (Soft-Deprecated)  The indexes of the items that are currently "selected", indicating that user operations should target the "content" objects having these indexes.  Getting or setting this property raises an exception on 10.11 and later, if the CollectionView has more than one section.  Use "selectionIndexPaths" instead.
 */
@property (copy) NSIndexSet *selectionIndexes;

/* A set of of NSIndexPath values, that identify the currently selected items by (section,indexInSection).  When using the new NSCollectionView APIs on 10.11 and later, use this property instead of "selectionIndexes".  You can change the set of selected items by setting this property.  To request an animated transition of affected items between their selected and deselected appearances, you can set this property via the CollectionView's "animator" proxy: [[collectionView animator] setSelectionIndexPaths:newIndexPaths].  CollectionView will raise an exception if any of the given indexPaths is out-of-bounds.  This property is Key-Value Observable.
 */
@property (copy) NSSet<NSIndexPath *> *selectionIndexPaths NS_AVAILABLE_MAC(10_11);

/* Adds the specified items to the selection, and optionally scrolls their bounding box into view according to the value of "scrollPosition".  This method does not cause any selection-related delegate methods to be invoked.
 
 To animate the scroll (if any) and the view property changes that indicate selected state, use [[collectionView animator] selectItemsAtIndexPaths:scrollPosition:].
 */
- (void)selectItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths scrollPosition:(NSCollectionViewScrollPosition)scrollPosition NS_AVAILABLE_MAC(10_11);

/* Removes the specified items from the selection, potentially in an animated way.  This method does not cause any selection-related delegate methods to be invoked.
 
 To animate the view property changes that indicate deselected state, use [[collectionView animator] deselectItemsAtIndexPaths:].
 */
- (void)deselectItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Selects all of the CollectionView's items, if and only if it is "selectable" and it "allowsMultipleSelection", and notifies the CollectionView's delegate about any newly selected items.  If either "selectable" or "allowsMultipleSelection" is NO, this action silently does nothing (and its associated user interface item does not validate).
 */
- (IBAction)selectAll:(nullable id)sender;

/* Clears the CollectionView's selection (if any), if and only if it is "selectable", and notifies the CollectionView's delegate about any newly deselected items.  If "selectable" is NO, this action silently does nothing (and its associated user interface item does not validate).
 */
- (IBAction)deselectAll:(nullable id)sender;


/* For each item identifier that the collection view will use, register either a nib or class from which to instantiate an item, or provide a nib file or class whose name matches the identifier you plan to use.  If a nib is registered, it must contain exactly one top-level NSCollectionViewItem.  If a class is registered instead of a nib, it will be instantiated via alloc/init.
 */
- (void)registerClass:(nullable Class)itemClass forItemWithIdentifier:(NSString *)identifier NS_AVAILABLE_MAC(10_11);
- (void)registerNib:(nullable NSNib *)nib forItemWithIdentifier:(NSString *)identifier NS_AVAILABLE_MAC(10_11);

/* For each supplementary view identifier that the collection view will use, register either a nib or class from which to instantiate a view, or provide a nib file or class whose name matches the identifier you plan to use.  If a nib is registered, it must contain exactly one top-level view, that conforms to the NSCollectionViewElement protocol.  If a class is registered instead of a nib, it will be instantiated via alloc/initWithFrame:.
 */
- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)kind withIdentifier:(NSString *)identifier NS_AVAILABLE_MAC(10_11);
- (void)registerNib:(nullable NSNib *)nib forSupplementaryViewOfKind:(NSString *)kind withIdentifier:(NSString *)identifier NS_AVAILABLE_MAC(10_11);

/* Call this method from your data source object when asked to provide a new item for the collection view.  This method dequeues an existing item if one is available or creates a new one based on the nib file or class you previously registered.  If you have not registered a nib file or class for the given identifier, CollectionView will try to load a nib file named identifier.nib, or (failing that) find and instantiate an NSCollectionViewItem subclass named "identifier".
 
 If you a new item must be created from a class, this method initializes the item by invoking its -init method.  For nib-based items, this method loads the item from the provided nib file.  If an existing item was available for reuse, this method invokes the item's -prepareForReuse method instead.
 */
- (__kindof NSCollectionViewItem *)makeItemWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Call this method from your data source object when asked to provide a new supplementary view for the collection view.  This method dequeues an existing view if one is available or creates a new one based on the nib file or class you previously registered.  If you have not registered a nib file or class for the given identifier, CollectionView will try to load a nib file named identifier.nib, or (failing that) find and instantiate an NSView subclass named "identifier".
 
 If a new view must be created from a class, this method initializes the view by invoking its -initWithFrame: method. For nib-based views, this method loads the view from the provided nib file.  If an existing view was available for reuse, this method invokes the view's -prepareForReuse method instead.
 */
- (__kindof NSView *)makeSupplementaryViewOfKind:(NSString *)elementKind withIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* (Soft-Deprecated)  Invoked by a dataSource-less NSCollectionView when it needs a new item to represent the given model "object" (which is presumed to be a member of the CollectionView's "content" array).  Instantiates and returns a non-autoreleased item whose "representedObject" has been set to point to the given "object".  NSCollectionView's implementation of this method makes a copy of the CollectionView's itemPrototype (raising an exception if itemPrototype is nil).  You can override this method to customize the returned item or its view subtree however you wish, calling up to super first to obtain it.  Or, you can replace super's implementation entirely, to instantiate whatever kind of item you wish, potentially based on the type or properties of the given model "object".  The item returned from this factory method should NOT be autoreleased.
 
 It is considered a programming error to send this message to an NSCollectionView that has a dataSource; an exception will be raised.  Use -makeItemWithIdentifier:forIndexPath: instead, from the dataSource's -collectionView:itemForRepresentedObjectAtIndexPath: method.
 */
- (NSCollectionViewItem *)newItemForRepresentedObject:(id)object;

/* (Soft-Deprecated)  A prototype NSCollectionViewItem that a dataSource-less NSCollectionView should clone to produce new items.  When not using a dataSource, you must either specify an itemPrototype, or override -newItemForRepresentedObject:, for the CollectionView to be able to create and display items.
 
 It is considered a programming error to send this message to an NSCollectionView that has a dataSource; an exception will be raised.  Use -registerNib:forItemWithIdentifier: or -registerClass:forItemWithIdentifier: instead.
 */
@property (nullable, strong) NSCollectionViewItem *itemPrototype;


#pragma mark *** Finding Items ***

/* (Soft-Deprecated)  Returns the NSCollectionViewItem associated with the represented object at the given index.  Sending this to a CollectionView that has more than one section raises an exception.  Use -itemAtIndexPath: instead.
*/
- (nullable NSCollectionViewItem *)itemAtIndex:(NSUInteger)index NS_AVAILABLE_MAC(10_6);

/* Returns the NSCollectionViewItem associated with the represented object at the given indexPath.
*/
- (nullable NSCollectionViewItem *)itemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Returns the NSCollectionViewItems that the CollectionView has instantiated and is managing as currently active. Each such item is associated with an item indexPath, and its view is part of the currently displayed view hierarchy. Note that this list may include items whose views fall outside the CollectionView's current visibleRect (for example, recently visible items that have been scrolled out of view, or items that the CollectionView anticipates may soon be visible). To determine which of these items may actually be visible to the user, test each item.view.frame for intersection with the CollectionView's visibleRect.
*/
- (NSArray<NSCollectionViewItem *> *)visibleItems NS_AVAILABLE_MAC(10_11);

/* Returns the index paths of the items that are currently displayed by the CollectionView. Note that these indexPaths correspond to the same items as "visibleItems", and thus may include items whose views fall outside the CollectionView's current "visibleRect".
*/
- (NSSet<NSIndexPath *> *)indexPathsForVisibleItems NS_AVAILABLE_MAC(10_11);

/* Returns the index path of the specified item (or nil if the specified item is not in the collection view).
*/
- (nullable NSIndexPath *)indexPathForItem:(NSCollectionViewItem *)item NS_AVAILABLE_MAC(10_11);

/* Returns the index path of the item at the specified point in the collection view.
 
 This method relies on the layout information provided by the associated layout object to determine which item contains the point.  It does not take opacity of the item's displayed content at that point into account.
*/
- (nullable NSIndexPath *)indexPathForItemAtPoint:(NSPoint)point NS_AVAILABLE_MAC(10_11);


#pragma mark *** Finding Supplementary Views ***

/* Returns the supplementary view (if any) of the given elementKind that's associated with the given indexPath.  Returns nil if no such supplementary view is currently instantiated.
 */
- (nullable NSView<NSCollectionViewElement> *)supplementaryViewForElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Returns the supplementary views that the CollectionView has instantiated and is managing as currently active.  Each such supplementary view is associated with an indexPath, and is part of the currently displayed view hierarchy.  Note that this list may include supplementary views that fall outside the CollectionView's current visibleRect (for example, recently visible section header or footer views that have been scrolled out of view, or section header or footer views that the CollectionView anticipates may soon be visible). To determine which of these views may actually be visible to the user, test each view.frame for intersection with the CollectionView's visibleRect.
 */
- (NSArray<NSView<NSCollectionViewElement> *> *)visibleSupplementaryViewsOfKind:(NSString *)elementKind NS_AVAILABLE_MAC(10_11);

/* Returns the index paths of the supplementary views of the given elementKind that are currently displayed by the CollectionView.  Note that these indexPaths correspond to the same supplementary views that "visibleSupplementaryViewsOfKind:" reports, and thus may include supplementary views that fall outside the CollectionView's current "visibleRect".
 */
- (NSSet<NSIndexPath *> *)indexPathsForVisibleSupplementaryElementsOfKind:(NSString *)elementKind NS_AVAILABLE_MAC(10_11);


#pragma mark *** Modifying Items and Sections ***

/* Use the following methods to communicate imminent model changes to a dataSource-based CollectionView.  Their function is similar to that of NSOutlineView's insert/move/remove methods.

When invoking any of these methods, you can request an animated instead of immediate layout update by messaging the CollectionView's animator.  For example: [[collectionView animator] insertItemsAtIndexPaths:indexPaths]
*/

/* Use this method to insert one or more sections into the collection view. This method adds the sections, and it is up to your data source to report the number of items in each section when asked for the information. The collection view then uses that information to get updated layout attributes for the newly inserted sections and items. If the insertions cause a change in the collection views visible content, those changes are animated into place.

You can also call this method from a block passed to the performBatchUpdates:completionHandler: method when you want to animate multiple separate changes into place at the same time. See the description of that method for more information.

Raises an exception if "sections" is nil.
*/
- (void)insertSections:(NSIndexSet *)sections NS_AVAILABLE_MAC(10_11);

/* Use this method to remove the sections and their items from the collection view. You might do this when you remove the sections from your data source object or in response to user interactions with the collection view. The collection view updates the layout of the remaining sections and items to account for the deletions, animating the remaining items into position as needed.

You can also call this method from a block passed to the performBatchUpdates:completionHandler: method when you want to animate multiple separate changes into place at the same time. See the description of that method for more information.

Raises an exception if "sections" is nil.
*/
- (void)deleteSections:(NSIndexSet *)sections NS_AVAILABLE_MAC(10_11);

/* Call this method to selectively reload only the objects in the specified sections. This causes the collection view to discard any items associated with those objects and redisplay them.

Raises an exception if "sections" is nil.
*/
- (void)reloadSections:(NSIndexSet *)sections NS_AVAILABLE_MAC(10_11);

/* Use this method to reorganize existing sections and their contained items. You might do this when you rearrange sections within your data source object or in response to user interactions with the collection view. The collection view updates the layout as needed to account for the move, animating new views into position as needed.

You can also call this method from a block passed to the performBatchUpdates:completionHandler: method when you want to animate multiple separate changes into place at the same time. See the description of that method for more information.
*/
- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection NS_AVAILABLE_MAC(10_11);

/* Call this method to insert one or more new items into the collection view. You might do this when your data source object receives data for new items or in response to user interactions with the collection view. The collection view gets the layout information for the new items as part of calling this method. And if the layout information indicates that the items should appear onscreen, the collection view asks your data source to provide the appropriate views, animating them into position as needed.

You can also call this method from a block passed to the performBatchUpdates:completionHandler: method when you want to animate multiple separate changes into place at the same time. See the description of that method for more information.

Raises an exception if "indexPaths" is nil.
*/
- (void)insertItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Use this method to remove items from the collection view. You might do this when you remove the represented objects from your data source object or in response to user interactions with the collection view. The collection view updates the layout of the remaining items to account for the deletions, animating the remaining items into position as needed.

You can also call this method from a block passed to the performBatchUpdates:completionHandler: method when you want to animate multiple separate changes into place at the same time. See the description of that method for more information.

Raises an exception if "indexPaths" is nil.
*/
- (void)deleteItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Call this method to selectively reload only the specified objects. This causes the collection view to discard any items associated with those objects and redisplay them.

Raises an exception if "indexPaths" is nil.
*/
- (void)reloadItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Use this method to reorganize existing data items. You might do this when you rearrange the represented objects within your data source object or in response to user interactions with the collection view. You can move items between sections or within the same section. The collection view updates the layout as needed to account for the move, animating items into position as needed.

You can also call this method from a block passed to the performBatchUpdates:completionHandler: method when you want to animate multiple separate changes into place at the same time. See the description of that method for more information.

Raises an exception if "indexPath" or "newIndexPath" is nil.
*/
- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath NS_AVAILABLE_MAC(10_11);

/* Animates multiple insert, delete, reload, and move operations as a group.

You can use this method in cases where you want to make multiple changes to the collection view in one single animated operation, as opposed to in several separate animations. You might use this method to insert, delete, reload or move items or use it to change the layout parameters associated with one or more items. Use the block passed in the "updates" parameter to specify all of the operations you want to perform.

Deletes are processed before inserts in batch operations. This means the indexes for the insertions are processed relative to the indexes of the state before the batch operation, and the indexes for the deletions are processed relative to the indexes of the state after all the insertions in the batch operation.

Invocations of this method can be nested.
*/
- (void)performBatchUpdates:(void (^__nullable)(void))updates completionHandler:(void (^__nullable)(BOOL finished))completionHandler NS_AVAILABLE_MAC(10_11);


#pragma mark *** Scrolling ***

/* Scrolls the collection view contents until the bounding box of the specified items is visible.  The final position of that bounding box within the scrollable area is determined by "scrollPosition".

To request an animated scroll, use [[collectionView animator] scrollToItemsAtIndexPaths:scrollPosition:].  You can use NSAnimationContext's completionHandler provisions to notify you when the animated scroll has finished.
*/
- (void)scrollToItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths scrollPosition:(NSCollectionViewScrollPosition)scrollPosition NS_AVAILABLE_MAC(10_11);


#pragma mark *** Drag and Drop ***

/* Configures the value returned from -draggingSourceOperationMaskForLocal:. An isLocal value of YES indicates that 'dragOperationMask' applies when the destination object is in the same application. By default, NSDragOperationEvery will be returned. An isLocal value of NO indicates that 'dragOperationMask' applies when the destination object is in an application outside the receiver's application. By default, NSDragOperationNone is returned. NSCollectionView will save the values you set for each isLocal setting. You typically will invoke this method, and not override it.
*/
- (void)setDraggingSourceOperationMask:(NSDragOperation)dragOperationMask forLocal:(BOOL)localDestination NS_AVAILABLE_MAC(10_6);

/* This method computes and returns an image to use for dragging. You can override this to return a custom drag image, or call it from the delegate method to get the default drag image. 'indexPaths' contains the NSIndexPaths of the items being dragged. 'event' is a reference to the mouse down event that began the drag. 'dragImageOffset' is an in/out parameter. This method will be called with dragImageOffset set to NSZeroPoint, but it can be modified to re-position the returned image. A dragImageOffset of NSZeroPoint will cause the image to be centered under the mouse. By default, an image will be created that contains a rendering of the visible portions of the views for each item. If the delegate implements the equivalent delegate method, it will be preferred over this method.
*/
- (NSImage *)draggingImageForItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths withEvent:(NSEvent *)event offset:(NSPointPointer)dragImageOffset NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
/* This is an older variant of -draggingImageForItemsAtIndexPaths:withEvent:offset:.  It assumes all of the indexes are in section 0.  New code should use -draggingImageForItemsAtIndexPaths:withEvent:offset: instead.
*/
- (NSImage *)draggingImageForItemsAtIndexes:(NSIndexSet *)indexes withEvent:(NSEvent *)event offset:(NSPointPointer)dragImageOffset NS_AVAILABLE_MAC(10_6);

@end


@protocol NSCollectionViewDataSource <NSObject>
@required

/* Asks the data source for the number of items in the specified section.
 */
- (NSInteger)collectionView:(NSCollectionView *)collectionView numberOfItemsInSection:(NSInteger)section NS_AVAILABLE_MAC(10_11);

/* Asks the data source to provide an NSCollectionViewItem for the specified represented object.

Your implementation of this method is responsible for creating, configuring, and returning the appropriate item for the given represented object.  You do this by sending -makeItemWithIdentifier:forIndexPath: method to the collection view and passing the identifier that corresponds to the item type you want.  Upon receiving the item, you should set any properties that correspond to the data of the corresponding model object, perform any additional needed configuration, and return the item.

You do not need to set the location of the item's view inside the collection views bounds. The collection view sets the location of each item automatically using the layout attributes provided by its layout object.

This method must always return a valid item instance.
*/
- (NSCollectionViewItem *)collectionView:(NSCollectionView *)collectionView itemForRepresentedObjectAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

@optional

/* Asks the data source for the number of sections in the collection view.

If you do not implement this method, the collection view assumes it has only one section.
*/
- (NSInteger)numberOfSectionsInCollectionView:(NSCollectionView *)collectionView NS_AVAILABLE_MAC(10_11);

/* Asks the data source to provide a view for the specified supplementary element.

Your implementation of this method is responsible for creating, configuring, and returning an appropriate view.  You do this by sending -makeSupplementaryViewOfKind:withIdentifier:forIndexPath: to the collection view and passing the identifier that corresponds to the supplementary view type you want.  Upon receiving the view, you should set any desired appearance properties, perform any additional needed configuration, and return the item.

You do not need to set the location of the view inside the collection views bounds. The collection view sets the location of each supplementary view automatically using the layout attributes provided by its layout object.

This method must always return a valid view.
*/
- (NSView *)collectionView:(NSCollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;

@end


@protocol NSCollectionViewDelegate <NSObject>
@optional

/* Drag and drop support */

/* To enable dealing with (section,item) NSIndexPaths now that NSCollectionView supports sections, many of the drag-and-drop delegate methods have been replaced with new versions that take NSIndexPath and array-of-NSIndexPath parameters.  In each such case, NSCollectionView will look for and invoke the newer method first.  If the delegate doesn't respond to the newer version, NSCollectionView will look for the old method, provided that the NSCollectionView has only a single section.  The old methods will not be invoked for a multi-section NSCollectionView.
*/

/* The return value indicates whether the collection view can attempt to initiate a drag for the given event and items. If the delegate does not implement this method, the collection view will act as if it returned YES.
*/
- (BOOL)collectionView:(NSCollectionView *)collectionView canDragItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths withEvent:(NSEvent *)event NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (BOOL)collectionView:(NSCollectionView *)collectionView canDragItemsAtIndexes:(NSIndexSet *)indexes withEvent:(NSEvent *)event NS_AVAILABLE_MAC(10_6);

/* This method is called after it has been determined that a drag should begin, but before the drag has been started. To refuse the drag, return NO. To start the drag, declare the pasteboard types that you support with -[NSPasteboard declareTypes:owner:], place your data for the items at the given index paths on the pasteboard, and return YES from the method. The drag image and other drag related information will be set up and provided by the view once this call returns YES. You need to implement this method, or -collectionView:pasteboardWriterForItemAtIndexPath:, for your collection view to be a drag source.
*/
- (BOOL)collectionView:(NSCollectionView *)collectionView writeItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths toPasteboard:(NSPasteboard *)pasteboard NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (BOOL)collectionView:(NSCollectionView *)collectionView writeItemsAtIndexes:(NSIndexSet *)indexes toPasteboard:(NSPasteboard *)pasteboard NS_AVAILABLE_MAC(10_6);

/* The delegate can support file promise drags by adding NSFilesPromisePboardType to the pasteboard in -collectionView:writeItemsAtIndexPaths:toPasteboard:. NSCollectionView implements -namesOfPromisedFilesDroppedAtDestination: to return the results of this delegate method. This method should return an array of filenames (not full paths) for the created files. The URL represents the drop location. For more information on file promise dragging, see documentation for the NSDraggingSource protocol and -namesOfPromisedFilesDroppedAtDestination:. You do not need to implement this method for your collection view to be a drag source.
*/
- (NSArray<NSString *> *)collectionView:(NSCollectionView *)collectionView namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropURL forDraggedItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (NSArray<NSString *> *)collectionView:(NSCollectionView *)collectionView namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropURL forDraggedItemsAtIndexes:(NSIndexSet *)indexes NS_AVAILABLE_MAC(10_6);

/* Allows the delegate to construct a custom dragging image for the items being dragged. 'indexPaths' contains the (section,item) identification of the items being dragged. 'event' is a reference to the  mouse down event that began the drag. 'dragImageOffset' is an in/out parameter. This method will be called with dragImageOffset set to NSZeroPoint, but it can be modified to re-position the returned image. A dragImageOffset of NSZeroPoint will cause the image to be centered under the mouse. You can safely call -[NSCollectionView draggingImageForItemsAtIndexPaths:withEvent:offset:] from within this method. You do not need to implement this method for your collection view to be a drag source.
*/
- (NSImage *)collectionView:(NSCollectionView *)collectionView draggingImageForItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths withEvent:(NSEvent *)event offset:(NSPointPointer)dragImageOffset NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (NSImage *)collectionView:(NSCollectionView *)collectionView draggingImageForItemsAtIndexes:(NSIndexSet *)indexes withEvent:(NSEvent *)event offset:(NSPointPointer)dragImageOffset NS_AVAILABLE_MAC(10_6);

/* This method is used by the collection view to determine a valid drop target. Based on the mouse position, the collection view will suggest a proposed (section,item) index path and drop operation. These values are in/out parameters and can be changed by the delegate to retarget the drop operation. The collection view will propose NSCollectionViewDropOn when the dragging location is closer to the middle of the item than either of its edges. Otherwise, it will propose NSCollectionViewDropBefore. You may override this default behavior by changing proposedDropOperation or proposedDropIndexPath. This method must return a value that indicates which dragging operation the data source will perform. It must return something other than NSDragOperationNone to accept the drop.

Note: to receive drag messages, you must first send -registerForDraggedTypes: to the collection view with the drag types you want to support (typically this is done in -awakeFromNib). You must implement this method for your collection view to be a drag destination.

Multi-image drag and drop: You can set draggingFormation, animatesToDestination, numberOfValidItemsForDrop within this method.
*/
- (NSDragOperation)collectionView:(NSCollectionView *)collectionView validateDrop:(id <NSDraggingInfo>)draggingInfo proposedIndexPath:(NSIndexPath * __nonnull * __nonnull)proposedDropIndexPath dropOperation:(NSCollectionViewDropOperation *)proposedDropOperation NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (NSDragOperation)collectionView:(NSCollectionView *)collectionView validateDrop:(id <NSDraggingInfo>)draggingInfo proposedIndex:(NSInteger *)proposedDropIndex dropOperation:(NSCollectionViewDropOperation *)proposedDropOperation NS_AVAILABLE_MAC(10_6);

/* This method is called when the mouse is released over a collection view that previously decided to allow a drop via the above validateDrop method. At this time, the delegate should incorporate the data from the dragging pasteboard and update the collection view's contents. You must implement this method for your collection view to be a drag destination.

Multi-image drag and drop: If draggingInfo.animatesToDestination is set to YES, you should enumerate and update the dragging items with the proper image components and frames so that they dragged images animate to the proper locations.
*/
- (BOOL)collectionView:(NSCollectionView *)collectionView acceptDrop:(id <NSDraggingInfo>)draggingInfo indexPath:(NSIndexPath *)indexPath dropOperation:(NSCollectionViewDropOperation)dropOperation NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (BOOL)collectionView:(NSCollectionView *)collectionView acceptDrop:(id <NSDraggingInfo>)draggingInfo index:(NSInteger)index dropOperation:(NSCollectionViewDropOperation)dropOperation NS_AVAILABLE_MAC(10_6);


/* Multi-image drag and drop */

/* Dragging Source Support - Required for multi-image drag and drop. Return a custom object that implements NSPasteboardWriting (or simply use NSPasteboardItem), or nil to prevent dragging for the item. For each valid item returned, NSCollectionView will create an NSDraggingItem with the draggingFrame equal to the frame of the item view at the given index path and components from -[NSCollectionViewItem draggingItem]. If this method is implemented, then -collectionView:writeItemsAtIndexPaths:toPasteboard: and -collectionView:draggingImageForItemsAtIndexPaths:withEvent:offset: will not be called.
*/
- (nullable id <NSPasteboardWriting>)collectionView:(NSCollectionView *)collectionView pasteboardWriterForItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (nullable id <NSPasteboardWriting>)collectionView:(NSCollectionView *)collectionView pasteboardWriterForItemAtIndex:(NSUInteger)index;

/* Dragging Source Support - Optional. Implement this method to know when the dragging session is about to begin and to potentially modify the dragging session.
*/
- (void)collectionView:(NSCollectionView *)collectionView draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint forItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Old Form (Single Section Only) */
- (void)collectionView:(NSCollectionView *)collectionView draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint forItemsAtIndexes:(NSIndexSet *)indexes;

/* Dragging Source Support - Optional. Implement this method to know when the dragging session has ended. This delegate method can be used to know when the dragging source operation ended at a specific location, such as the trash (by checking for an operation of NSDragOperationDelete).
*/
- (void)collectionView:(NSCollectionView *)collectionView draggingSession:(NSDraggingSession *)session endedAtPoint:(NSPoint)screenPoint dragOperation:(NSDragOperation)operation;

/* Dragging Destination Support - Required for multi-image drag and drop. Implement this method to update dragging items as they are dragged over the view. Typically this will involve calling [draggingInfo enumerateDraggingItemsWithOptions:forView:classes:searchOptions:usingBlock:] and setting the draggingItem's imageComponentsProvider to a proper image based on the NSDraggingItem's -item value.
*/
- (void)collectionView:(NSCollectionView *)collectionView updateDraggingItemsForDrag:(id <NSDraggingInfo>)draggingInfo;


#pragma mark *** Selection and Highlighting ***

/* Sent during interactive selection or dragging, to inform the delegate that the CollectionView would like to change the "highlightState" property of the items at the specified "indexPaths" to the specified "highlightState".  In addition to optionally reacting to the proposed change, you can approve it (by returning "indexPaths" as-is), or selectively refuse some or all of the proposed highlightState changes (by returning a modified autoreleased mutableCopy of indexPaths, or an empty indexPaths instance).  Refusing a proposed highlightState change for an item will suppress the associated action for that item (selection change or eligibility to be a drop target).
*/
- (NSSet<NSIndexPath *> *)collectionView:(NSCollectionView *)collectionView shouldChangeItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths toHighlightState:(NSCollectionViewItemHighlightState)highlightState NS_AVAILABLE_MAC(10_11);

/* Sent during interactive selection or dragging, to inform the delegate that the CollectionView has changed the "highlightState" property of the items at the specified "indexPaths" to the specified "highlightState". */
- (void)collectionView:(NSCollectionView *)collectionView didChangeItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths toHighlightState:(NSCollectionViewItemHighlightState)highlightState NS_AVAILABLE_MAC(10_11);

/* Sent during interactive selection, to inform the delegate that the CollectionView would like to select the items at the specified "indexPaths".  In addition to optionally reacting to the proposed change, you can approve it (by returning "indexPaths" as-is), or selectively refuse some or all of the proposed selection changes (by returning a modified autoreleased mutableCopy of indexPaths, or an empty indexPaths instance).
*/
- (NSSet<NSIndexPath *> *)collectionView:(NSCollectionView *)collectionView shouldSelectItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Sent during interactive selection, to inform the delegate that the CollectionView would like to de-select the items at the specified "indexPaths".  In addition to optionally reacting to the proposed change, you can approve it (by returning "indexPaths" as-is), or selectively refuse some or all of the proposed selection changes (by returning a modified autoreleased mutableCopy of indexPaths, or an empty indexPaths instance). */
- (NSSet<NSIndexPath *> *)collectionView:(NSCollectionView *)collectionView shouldDeselectItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Sent at the end of interactive selection, to inform the delegate that the CollectionView has selected the items at the specified "indexPaths".
*/
- (void)collectionView:(NSCollectionView *)collectionView didSelectItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Sent at the end of interactive selection, to inform the delegate that the CollectionView has de-selected the items at the specified "indexPaths".
*/
- (void)collectionView:(NSCollectionView *)collectionView didDeselectItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);


#pragma mark *** Display Notification ***

/* Sent to notify the delegate that the CollectionView is about to add an NSCollectionViewItem.  The indexPath identifies the object that the item represents.
*/
- (void)collectionView:(NSCollectionView *)collectionView willDisplayItem:(NSCollectionViewItem *)item forRepresentedObjectAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Sent to notify the delegate that the CollectionView is about to add a supplementary view (e.g. a section header or footer view).  Each NSCollectionViewLayout class defines its own possible values and associated meanings for "elementKind".  (For example, NSCollectionViewFlowLayout declares NSCollectionElementKindSectionHeader and NSCollectionElementKindSectionFooter.)
*/
- (void)collectionView:(NSCollectionView *)collectionView willDisplaySupplementaryView:(NSView *)view forElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Sent to notify the delegate that the CollectionView is no longer displaying the given NSCollectionViewItem instance.  This happens when the model changes, or when an item is scrolled out of view.  You should perform any actions necessary to help decommission the item (such as releasing expensive resources).  The CollectionView may retain the item instance and later reuse it to represent the same or a different model object.
*/
- (void)collectionView:(NSCollectionView *)collectionView didEndDisplayingItem:(NSCollectionViewItem *)item forRepresentedObjectAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Sent to notify the delegate that the CollectionView is no longer displaying the given supplementary view. This happens when the model changes, or when a supplementary view is scrolled out of view. You should perform any actions necessary to help decommission the view (such as releasing expensive resources). The CollectionView may retain the view and later reuse it. */
- (void)collectionView:(NSCollectionView *)collectionView didEndDisplayingSupplementaryView:(NSView *)view forElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);


#pragma mark *** Layout Transition Support ***

/* Sent when the CollectionView switches to a different layout, to allow the delegate to provide a custom transition if desired.
*/
- (NSCollectionViewTransitionLayout *)collectionView:(NSCollectionView *)collectionView transitionLayoutForOldLayout:(NSCollectionViewLayout *)fromLayout newLayout:(NSCollectionViewLayout *)toLayout NS_AVAILABLE_MAC(10_11);

@end

@interface NSIndexPath (NSCollectionViewAdditions)

+ (NSIndexPath *)indexPathForItem:(NSInteger)item inSection:(NSInteger)section NS_AVAILABLE_MAC(10_11);

@property (readonly) NSInteger item NS_AVAILABLE_MAC(10_11);
@property (readonly) NSInteger section NS_AVAILABLE_MAC(10_11);

@end

@interface NSSet (NSCollectionViewAdditions)

/* Creates and returns a set that contains a single given NSIndexPath.
 */
+ (instancetype)setWithCollectionViewIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_MAC(10_11);

/* Creates and returns a set containing a uniqued collection of the NSIndexPaths contained in a given array.
 */
+ (instancetype)setWithCollectionViewIndexPaths:(NSArray<NSIndexPath *> *)indexPaths NS_AVAILABLE_MAC(10_11);

/* Executes the given block for each NSIndexPath in the set.  The index paths are enumerated in the order defined by NSIndexPath's -compare: method.  For CollectionView item index paths, this means all index paths in section 0, in ascending order, followed by all index paths in section 1, and so on.  You may pass the NSEnumerationReverse option to enumerate in the reverse order.  Set *stop = YES if desired, to halt the enumeration early.
 */
- (void)enumerateIndexPathsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(NSIndexPath *indexPath, BOOL *stop))block NS_AVAILABLE_MAC(10_11);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                      NSCollectionViewFlowLayout.h                                                                        0100644 0001750 0001750 00000010602 12567220726 036404  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSCollectionViewFlowLayout.h
    Application Kit
    Copyright (c) 2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/NSCollectionView.h>
#import <AppKit/NSCollectionViewLayout.h>

typedef NS_ENUM(NSInteger, NSCollectionViewScrollDirection) {
    NSCollectionViewScrollDirectionVertical,
    NSCollectionViewScrollDirectionHorizontal
} NS_ENUM_AVAILABLE_MAC(10_11);

NS_ASSUME_NONNULL_BEGIN

APPKIT_EXTERN NSString *const NSCollectionElementKindSectionHeader NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN NSString *const NSCollectionElementKindSectionFooter NS_AVAILABLE_MAC(10_11);

NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewFlowLayoutInvalidationContext : NSCollectionViewLayoutInvalidationContext
#ifndef __OBJC2__
{
@private
    struct {
        unsigned int invalidateDelegateMetrics:1;
        unsigned int invalidateAttributes:1;
    } _flowLayoutInvalidationFlags;
}
#endif

@property BOOL invalidateFlowLayoutDelegateMetrics; // if set to NO, flow layout will not requery the collection view delegate for size information etc.
@property BOOL invalidateFlowLayoutAttributes; // if set to NO, flow layout will keep all layout information, effectively not invalidating - useful for a subclass which invalidates only a piece of itself

@end

@protocol NSCollectionViewDelegateFlowLayout <NSCollectionViewDelegate>
@optional

- (NSSize)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath;
- (NSEdgeInsets)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout*)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;
- (CGFloat)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout*)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section;
- (CGFloat)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout*)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section;
- (NSSize)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;
- (NSSize)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout*)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section;

@end

NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewFlowLayout : NSCollectionViewLayout
#ifndef __OBJC2__
{
@package
    struct {
        unsigned int delegateSizeForItem:1;
        unsigned int delegateReferenceSizeForHeader:1;
        unsigned int delegateReferenceSizeForFooter:1;
        unsigned int delegateInsetForSection:1;
        unsigned int delegateInteritemSpacingForSection:1;
        unsigned int delegateLineSpacingForSection:1;
        unsigned int delegateAlignmentOptions:1;
        unsigned int layoutDataIsValid:1;
        unsigned int delegateInfoIsValid:1;
        unsigned int roundsToScreenScale:1;
    } _gridLayoutFlags;
    
    CGFloat _interitemSpacing;
    CGFloat _lineSpacing;
    
    CGSize _itemSize; // for the cases the delegate method is not implemented
    CGSize _estimatedItemSize;
    CGSize _headerReferenceSize;
    CGSize _footerReferenceSize;
    NSEdgeInsets _sectionInset;
    
    id _data;
    CGSize _currentLayoutSize;
    
    NSMutableDictionary* _insertedItemsAttributesDict;
    NSMutableDictionary* _insertedSectionHeadersAttributesDict;
    NSMutableDictionary* _insertedSectionFootersAttributesDict;
    NSMutableDictionary* _deletedItemsAttributesDict;
    NSMutableDictionary* _deletedSectionHeadersAttributesDict;
    NSMutableDictionary* _deletedSectionFootersAttributesDict;
    
    NSCollectionViewScrollDirection _scrollDirection;
    NSDictionary *_rowAlignmentsOptionsDictionary;
    
    CGPoint _contentOffsetAdjustment;
    CGSize _contentSizeAdjustment;
    
    NSMutableArray* _indexPathsToValidate;
}
#endif

@property CGFloat minimumLineSpacing;
@property CGFloat minimumInteritemSpacing;
@property NSSize itemSize;
@property NSSize estimatedItemSize; // defaults to NSZeroSize - setting a non-zero size enables cells that self-size via -preferredLayoutAttributesFittingAttributes:
@property NSCollectionViewScrollDirection scrollDirection; // default is NSCollectionViewScrollDirectionVertical
@property NSSize headerReferenceSize;
@property NSSize footerReferenceSize;
@property NSEdgeInsets sectionInset;

@end

NS_ASSUME_NONNULL_END
                                                                                                                              NSCollectionViewGridLayout.h                                                                        0100644 0001750 0001750 00000007523 12567220726 036372  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSCollectionViewGridLayout.h
    Application Kit
    Copyright (c) 2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/NSCollectionViewLayout.h>

@class NSColor;

NS_ASSUME_NONNULL_BEGIN

/* NSCollectionView's default "Grid" layout, which matches NSCollectionView's layout behavior on OS X 10.5 through 10.10.  When you create a new NSCollectionView, its collectionViewLayout property defaults to an instance of NSCollectionViewGridLayout.
*/
NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewGridLayout : NSCollectionViewLayout
#ifndef __OBJC2__
{
@private
    NSUInteger _maxGridRows;
    NSUInteger _maxGridColumns;
    NSSize _minItemSize;
    NSSize _maxItemSize;
    NSEdgeInsets _margins;
    CGFloat _minimumInteritemSpacing;
    CGFloat _minimumLineSpacing;
    NSArray *_backgroundColors;
    id _glReserved[22];
}
#endif

#pragma mark *** Margins and Inter-Item Spacing ***

/* The amount of empty space to leave between the edges of the CollectionView's frame and the items within it.  Items will be laid out in the rectangle that remains after margins have been subtracted.  Defaults to NSEdgeInsetsZero.
*/
@property NSEdgeInsets margins;

/* For a vertically scrolling grid, this value represents the minimum spacing between items in the same row.  For a horizontally scrolling grid, this value represents the minimum spacing between items in the same column. This spacing is used to compute how many items can fit in a single line, but after the number of items is determined, the actual spacing may possibly be adjusted upward.  Defaults to 0 for a Grid layout.
*/
@property CGFloat minimumInteritemSpacing;

/* For a vertically scrolling grid, this value represents the minimum spacing between successive rows.  For a horizontally scrolling grid, this value represents the minimum spacing between successive columns.  This spacing is not applied to the space between the header and the first line or between the last line and the footer.  Defaults to 0 for a Grid layout.
*/
@property CGFloat minimumLineSpacing;


#pragma mark *** Grid Parameters ***

/* The largest number of item rows to attempt to fit in the CollectionView's visible area (if enclosed in a ScrollView).  Defaults to 0, which is interpreted to mean there should be no limit other than minimumItemSize.height.
*/
@property NSUInteger maximumNumberOfRows;

/* The largest number of item columns to attempt to fit in the CollectionView's visible area (if enclosed in a ScrollView).  Defaults to 0, which is interpreted to mean there should be no limit other than minimumItemSize.width.
*/
@property NSUInteger maximumNumberOfColumns;


#pragma mark *** Item Size Limits ***

/* The smallest allowed dimensions for an item's root view.  Defaults to NSZeroSize, which makes the layout attempt to infer minimum dimensions from the provided itemPrototype's view's frame size.
*/
@property NSSize minimumItemSize;

/* The largest allowed dimensions for an item's root view.  Defaults to NSZeroSize, which makes the layout attempt to infer maximum dimensions from the provided itemPrototype's view's frame size.
*/
@property NSSize maximumItemSize;


#pragma mark *** Background Appearance ***

/* The colors with which to fill the background.  Defaults to nil.  Setting this to nil causes a default background color to be used.  Setting it to an empty array causes the CollectionView to draw no background fill.  Setting it to a single-NSColor array causes the entire CollectionView to be drawn with the given background fill color.  For CollectionViews using the old, pre-10.11 API: Setting it to an array of (N >= 2) colors causes the CollectionView to use them in sequence, applying color (index % N) behind the item at "index.  For new, 10.11-and-later NSCollectionViews, colors after the first are ignored.
*/
@property (null_resettable, copy) NSArray<NSColor *> *backgroundColors;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                             NSCollectionViewLayout.h                                                                            0100644 0001750 0001750 00000040400 12567220725 035552  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSCollectionViewLayout.h
    Application Kit
    Copyright (c) 2015, Apple Inc.
    All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSGeometry.h>
#import <AppKit/AppKitDefines.h>

/* The NSCollectionViewLayout class is provided as an abstract class for subclassing to define custom collection layouts.  Defining a custom layout is an advanced operation intended for applications with complex needs.
*/

typedef NS_ENUM(NSInteger, NSCollectionElementCategory) {
    NSCollectionElementCategoryItem,
    NSCollectionElementCategorySupplementaryView,
    NSCollectionElementCategoryDecorationView,
    NSCollectionElementCategoryInterItemGap
} NS_ENUM_AVAILABLE_MAC(10_11);

@class NSIndexPath;

NS_ASSUME_NONNULL_BEGIN

/* The elementKind used to identify an inter-item gap (for use in indicating a drop target).  A client can customize the default look of the inter-item gap drop target indicator by registering a supplementary view nib or class for this elementKind.
*/
APPKIT_EXTERN NSString *const NSCollectionElementKindInterItemGapIndicator NS_AVAILABLE_MAC(10_11);

@class NSCollectionViewLayoutAttributes;
@class NSCollectionView;
@class NSNib;

NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewLayoutAttributes : NSObject <NSCopying>
#ifndef __OBJC2__
{
@private
    NSString* _elementKind;
    NSString* _reuseIdentifier;
    NSPoint _center;
    NSSize _size;
    NSRect _frame;
    CGFloat _alpha;
    CGFloat _reserved2[16];
    NSIndexPath* _indexPath;
    NSString *_isCloneString;
    struct {
        unsigned int isCellKind:1;
        unsigned int isDecorationView:1;
        unsigned int isHidden:1;
        unsigned int isClone:1;
        unsigned int isInterItemGap:1;
        unsigned int reserved:27;
    } _layoutFlags;
    NSInteger _zIndex;
    id _reserved[32];
}
#endif

@property NSRect frame;
@property NSSize size;
@property CGFloat alpha;
@property NSInteger zIndex; // default is 0
@property (getter=isHidden) BOOL hidden; // As an optimization, NSCollectionView might not create a view for items whose hidden attribute is YES
@property (nullable, strong) NSIndexPath *indexPath;

@property (readonly) NSCollectionElementCategory representedElementCategory;
@property (nullable, readonly) NSString *representedElementKind; // nil when representedElementCategory is NSCollectionElementCategoryItem

+ (instancetype)layoutAttributesForItemWithIndexPath:(NSIndexPath *)indexPath;
+ (instancetype)layoutAttributesForInterItemGapBeforeIndexPath:(NSIndexPath *)indexPath;
+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;
+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath*)indexPath;

@end

typedef NS_ENUM(NSInteger, NSCollectionUpdateAction) {
    NSCollectionUpdateActionInsert,
    NSCollectionUpdateActionDelete,
    NSCollectionUpdateActionReload,
    NSCollectionUpdateActionMove,
    NSCollectionUpdateActionNone
} NS_ENUM_AVAILABLE_MAC(10_11);

NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewUpdateItem : NSObject
#ifndef __OBJC2__
{
@private
    NSIndexPath* _initialIndexPath;
    NSIndexPath* _finalIndexPath;
    NSCollectionUpdateAction _updateAction;
    id _gap;
    id _reserved[11];
}
#endif

@property (nullable, readonly) NSIndexPath *indexPathBeforeUpdate; // nil for NSCollectionUpdateActionInsert
@property (nullable, readonly) NSIndexPath *indexPathAfterUpdate; // nil for NSCollectionUpdateActionDelete
@property (readonly) NSCollectionUpdateAction updateAction;

@end

NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewLayoutInvalidationContext : NSObject
#ifndef __OBJC2__
{
@private
    NSMutableSet* _invalidatedItemIndexPaths;
    NSMutableDictionary* _invalidatedSupplementaryIndexPaths;
    NSMutableDictionary* _invalidatedDecorationIndexPaths;
    NSArray* _updateItems;
    
    CGPoint _contentOffsetAdjustment;
    CGSize _contentSizeAdjustment;
    
    struct {
        unsigned int invalidateDataSource:1;
        unsigned int invalidateEverything:1;
        unsigned int reserved:30;
    } _invalidationContextFlags;
    id _reserved[6];
}
#endif

@property (readonly) BOOL invalidateEverything; // set to YES when invalidation occurs because the collection view is sent -reloadData
@property (readonly) BOOL invalidateDataSourceCounts; // if YES, the layout should requery section and item counts from the collection view - set to YES when the collection view is sent -reloadData and when items are inserted or deleted

- (void)invalidateItemsAtIndexPaths:(NSSet<NSIndexPath *> *)indexPaths;
- (void)invalidateSupplementaryElementsOfKind:(NSString *)elementKind atIndexPaths:(NSSet<NSIndexPath *> *)indexPaths;
- (void)invalidateDecorationElementsOfKind:(NSString *)elementKind atIndexPaths:(NSSet<NSIndexPath *> *)indexPaths;
@property (nullable, readonly) NSSet<NSIndexPath *> *invalidatedItemIndexPaths;
@property (nullable, readonly) NSDictionary<NSString *, NSSet<NSIndexPath *> *> *invalidatedSupplementaryIndexPaths; // keys are element kind strings - values are NSSet<NSIndexPath *>
@property (nullable, readonly) NSDictionary<NSString *, NSSet<NSIndexPath *> *> *invalidatedDecorationIndexPaths; // keys are element kind strings - values are NSSet<NSIndexPath *>

@property NSPoint contentOffsetAdjustment; // delta to be applied to the collection view's current contentOffset - default is NSZeroPoint
@property NSSize contentSizeAdjustment; // delta to be applied to the current content size - default is NSZeroSize

@end

/* The NSCollectionViewLayout class is provided as an abstract class for subclassing to define custom collection layouts.  Defining a custom layout is an advanced operation intended for applications with complex needs.
*/
NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewLayout : NSObject <NSCoding>
#ifndef __OBJC2__
{
@package
    CGSize _collectionViewBoundsSize;
    NSMutableDictionary* _initialAnimationLayoutAttributesDict;
    NSMutableDictionary* _finalAnimationLayoutAttributesDict;
    NSMutableDictionary* _deletedSupplementaryIndexPathsDict;
    NSMutableDictionary* _insertedSupplementaryIndexPathsDict;
    NSMutableDictionary* _deletedDecorationIndexPathsDict;
    NSMutableDictionary* _insertedDecorationIndexPathsDict;
    NSMutableIndexSet* _deletedSectionsSet;
    NSMutableIndexSet* _insertedSectionsSet;
    
    NSMutableDictionary* _decorationViewClassDict;
    NSMutableDictionary* _decorationViewNibDict;
    NSMutableDictionary* _decorationViewExternalObjectsTables;
    
    NSCollectionViewLayout* _transitioningFromLayout;
    NSCollectionViewLayout* _transitioningToLayout;
    
    NSCollectionViewLayoutInvalidationContext* _invalidationContext;
    
    CGRect _frame;
    NSIndexSet* _sections;
    NSIndexSet* _items;
    NSArray* _elementKinds;
    NSCollectionViewLayout* _siblingLayout;
    CGPoint _layoutOffset;
    NSUInteger _layoutOffsetEdges;
    
    struct {
        unsigned int inTransitionFromTransitionLayout:1;
        unsigned int inTransitionToTransitionLayout:1;
        unsigned int prepared:1;
        unsigned int reserved:29;
    } _layoutFlags;
    id _reserved[3];
}
#endif

/* Methods in this class are meant to be overridden and will be called by its collection view to gather layout information.  To get the truth on the current state of the collection view, call methods on NSCollectionView rather than these.
*/

@property (nullable, readonly, weak) NSCollectionView *collectionView;

/* Call -invalidateLayout to indicate that the collection view needs to requery the layout information.  Subclasses must always call super if they override.
*/
- (void)invalidateLayout;
- (void)invalidateLayoutWithContext:(NSCollectionViewLayoutInvalidationContext *)context;

- (void)registerClass:(nullable Class)viewClass forDecorationViewOfKind:(NSString *)elementKind;
- (void)registerNib:(nullable NSNib *)nib forDecorationViewOfKind:(NSString *)elementKind;

@end

@interface NSCollectionViewLayout (NSSubclassingHooks)

+ (Class)layoutAttributesClass; // override this method to provide a custom class to be used when instantiating instances of NSCollectionViewLayoutAttributes

+ (Class)invalidationContextClass; // override this method to provide a custom class to be used for invalidation contexts

/* The collection view calls -prepareLayout once at its first layout as the first message to the layout instance.  The collection view calls -prepareLayout again after layout is invalidated and before requerying the layout information.  Subclasses should always call super if they override.
*/
- (void)prepareLayout;

/* NSCollectionView calls these four methods to determine the layout information.  Implement -layoutAttributesForElementsInRect: to return layout attributes for for supplementary or decoration views, or to perform layout in an as-needed-on-screen fashion. Additionally, all layout subclasses should implement -layoutAttributesForItemAtIndexPath: to return layout attributes instances on demand for specific index paths.  If the layout supports any supplementary or decoration view types, it should also implement the respective atIndexPath: methods for those types.
*/
- (NSArray<__kindof NSCollectionViewLayoutAttributes *> *)layoutAttributesForElementsInRect:(NSRect)rect; // return an array layout attributes instances for all the views in the given rect
- (nullable NSCollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;
- (nullable NSCollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath;
- (nullable NSCollectionViewLayoutAttributes *)layoutAttributesForDecorationViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath;

/* Returns an NSCollectionViewLayoutAttributes instance that identifies an appropriate proposed drop target from the given hover point.  If the point is between items, the returned layout attributes may describe an inter-item gap, which is distinguished by having a representedElementCategory of NSCollectionElementCategoryInterItemGap, and a representedElementKind of NSCollectionElementKindInterItemGapIndicator.  Its "frame" provides a bounding box for the gap, that will be used to position and size a drop target indicator, and its "indexPath" identifies the proposed "insert before" position.  The frame might not contain the given point, if the insertion indicator should lie elsewhere.  (For example, when a vertical Flow layout hit-tests a gap between rows, it may suggest an insertion gap to the left of the lower row's first item.)  Subclasses should override this method to return appropriate results based on their knowledge of the particular layout.  This method should return nil if no suitable drop target can be inferred from the given point.
*/
- (nullable NSCollectionViewLayoutAttributes *)layoutAttributesForDropTargetAtPoint:(NSPoint)pointInCollectionView;

/* Returns an NSCollectionViewLayoutAttributes instance that describes the inter-item gap preceding the given item indexPath.  You may pass an indexPath whose "item" index equals the number of items in the section, to request a description of the gap after the last item.  The result has a representedElementCategory of NSCollectionElementCategoryInterItemGap, and a representedElementKind of NSCollectionElementKindInterItemGapIndicator.  Subclasses should override this method to return appropriate results based on their knowledge of the particular layout.
*/
- (nullable NSCollectionViewLayoutAttributes *)layoutAttributesForInterItemGapBeforeIndexPath:(NSIndexPath *)indexPath;

- (BOOL)shouldInvalidateLayoutForBoundsChange:(NSRect)newBounds; // return YES to cause the collection view to requery the layout for geometry information
- (NSCollectionViewLayoutInvalidationContext *)invalidationContextForBoundsChange:(NSRect)newBounds;

- (BOOL)shouldInvalidateLayoutForPreferredLayoutAttributes:(NSCollectionViewLayoutAttributes *)preferredAttributes withOriginalAttributes:(NSCollectionViewLayoutAttributes *)originalAttributes;
- (NSCollectionViewLayoutInvalidationContext *)invalidationContextForPreferredLayoutAttributes:(NSCollectionViewLayoutAttributes *)preferredAttributes withOriginalAttributes:(NSCollectionViewLayoutAttributes *)originalAttributes;

- (NSPoint)targetContentOffsetForProposedContentOffset:(NSPoint)proposedContentOffset withScrollingVelocity:(NSPoint)velocity; // return a point at which to rest after scrolling - for layouts that want snap-to-point scrolling behavior
- (NSPoint)targetContentOffsetForProposedContentOffset:(NSPoint)proposedContentOffset; // a layout can return the content offset to be applied during transition or update animations

@property(readonly) NSSize collectionViewContentSize; // Subclasses must implement a collectionViewContentSize getter that returns the width and height of the collection views content. These values represent the width and height of all the content, not just the content that is currently visible. The collection view uses this information to configure its own content size to facilitate scrolling.

@end

@interface NSCollectionViewLayout (NSUpdateSupportHooks)

// This method is called when there is an update with deletes/inserts to the collection view.
// It will be called prior to calling the initial/final layout attribute methods below to give the layout an opportunity to do batch computations for the insertion and deletion layout attributes.
// The updateItems parameter is an array of NSCollectionViewUpdateItem instances for each element that is moving to a new index path.
- (void)prepareForCollectionViewUpdates:(NSArray<NSCollectionViewUpdateItem *> *)updateItems;
- (void)finalizeCollectionViewUpdates; // called inside an animation block after the update

- (void)prepareForAnimatedBoundsChange:(NSRect)oldBounds; // NSCollectionView calls this when its bounds have changed inside an animation block before displaying items in its new bounds
- (void)finalizeAnimatedBoundsChange; // also called inside the animation block

// NSCollectionView calls this when prior the layout transition animation on the incoming and outgoing layout
- (void)prepareForTransitionToLayout:(NSCollectionViewLayout *)newLayout;
- (void)prepareForTransitionFromLayout:(NSCollectionViewLayout *)oldLayout;
- (void)finalizeLayoutTransition;  // called inside an animation block after the transition

// This set of methods is called when the collection view undergoes an animated transition such as a batch update block or an animated bounds change.
// For each element on screen before the invalidation, finalLayoutAttributesForDisappearingXXX will be called and an animation setup from what is on screen to those final attributes.
// For each element on screen after the invalidation, initialLayoutAttributesForAppearingXXX will be called an an animation setup from those initial attributes to what ends up on screen.
- (nullable NSCollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath;
- (nullable NSCollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingItemAtIndexPath:(NSIndexPath *)itemIndexPath;
- (nullable NSCollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingSupplementaryElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)elementIndexPath;
- (nullable NSCollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingSupplementaryElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)elementIndexPath;
- (nullable NSCollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingDecorationElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)decorationIndexPath;
- (nullable NSCollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingDecorationElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)decorationIndexPath;

// These methods are called by collection view during an update block.
// Return an array of index paths to indicate views that the layout is deleting or inserting in response to the update.
- (NSSet<NSIndexPath *> *)indexPathsToDeleteForSupplementaryViewOfKind:(NSString *)elementKind;
- (NSSet<NSIndexPath *> *)indexPathsToDeleteForDecorationViewOfKind:(NSString *)elementKind;
- (NSSet<NSIndexPath *> *)indexPathsToInsertForSupplementaryViewOfKind:(NSString *)elementKind;
- (NSSet<NSIndexPath *> *)indexPathsToInsertForDecorationViewOfKind:(NSString *)elementKind;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                NSCollectionViewTransitionLayout.h                                                                  0100644 0001750 0001750 00000002460 12567220726 037632  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSCollectionViewTransitionLayout.h
    Application Kit
    Copyright (c) 2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/NSCollectionViewLayout.h>

NS_ASSUME_NONNULL_BEGIN

NS_CLASS_AVAILABLE_MAC(10_11)
@interface NSCollectionViewTransitionLayout : NSCollectionViewLayout
#ifndef __OBJC2__
{
@private
    NSCollectionViewLayout *_fromLayout;
    NSCollectionViewLayout *_toLayout;
    
    CGRect _fromVisibleBounds;
    CGRect _toVisibleBounds;
    NSSize _contentSize;
    
    BOOL _haveValidInfos;
    CGFloat _transitionProgress;
    
    NSMutableDictionary *_transitionInformationsDict;
    NSMutableDictionary *_currentLayoutInfos;
    
    BOOL _layoutIsValid;
    
    NSMutableArray *_disappearingLayoutAttributes;
    NSMutableArray *_appearingLayoutAttributes;
    
    CGFloat _accuracy;
}
#endif // TARGET_OS_IPHONE || __OBJC2__

@property (assign) CGFloat transitionProgress;
@property (readonly) NSCollectionViewLayout *currentLayout;
@property (readonly) NSCollectionViewLayout *nextLayout;

// Designated initializer
- (instancetype)initWithCurrentLayout:(NSCollectionViewLayout *)currentLayout nextLayout:(NSCollectionViewLayout *)newLayout;

- (void)updateValue:(CGFloat)value forAnimatedKey:(NSString *)key;
- (CGFloat)valueForAnimatedKey:(NSString *)key;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                NSColor.h                                                                                           0100644 0001750 0001750 00000044460 12567220725 032516  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSColor.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

/* NSColors store colors. Often the only NSColor message you send is the "set" method, which makes the receiver the current color in the drawing context. There is usually no need to dive in and get the individual components (for instance, red, green, blue) that make up a color.

An NSColor may be in one of several fixed number of named colorspaces. Different named colorspaces have different ways of getting at the components which define colors in that colorspace. Implementations of NSColors exist for the following named colorspaces:

  NSDeviceCMYKColorSpace	Cyan, magenta, yellow, black, and alpha components
  NSDeviceWhiteColorSpace	White and alpha components
  NSDeviceRGBColorSpace		Red, green, blue, and alpha components
				Hue, saturation, brightness, and alpha components
  NSCalibratedWhiteColorSpace	White and alpha components
  NSCalibratedRGBColorSpace	Red, green, blue, and alpha components
				Hue, saturation, brightness, and alpha components
  NSNamedColorSpace		Catalog name, color name components
  NSCustomColorSpace		Color space specified using NSColorSpace, with appropriate number of CGFloat components

The named colorspace NSCustomColorSpace allows flexibility of defining an arbitrary colorspace using an NSColorSpace. 

Alpha component defines opacity on devices which support it (1.0 == full opacity). On other devices the alpha is ignored when the color is used.

It's illegal to ask a color for components that are not defined for its colorspace. If you need to ask a color for a certain set of components (for instance, you need to know the RGB components of a color you got from the color panel), you should first convert the color to the appropriate colorspace using colorUsingColorSpace:, or the appropriate named colorspace using  colorUsingColorSpaceName:.  If the color is already in the specified colorspace, you get the same color back; otherwise you get a conversion which is usually lossy or is correct only for the current device. You might also get back nil if the specified conversion cannot be done.

Subclassers of NSColor need to implement the methods colorSpaceName, set, the various methods which return the components for that color space, and the NSCoding protocol. Some other methods such as colorWithAlphaComponent:, isEqual:, colorUsingColorSpaceName:device:, and CGColor may also be implemented if they make sense for the colorspace. If isEqual: is overridden, so should hash (because if [a isEqual:b] then [a hash] == [b hash]). Mutable subclassers (if any) should also implement copyWithZone: to a true copy.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSGeometry.h>
#import <AppKit/AppKitDefines.h>
#import <AppKit/NSCell.h>
#import <AppKit/NSPasteboard.h>
#import <QuartzCore/CIColor.h>

NS_ASSUME_NONNULL_BEGIN

@class NSImage, NSColorSpace;

#define NSAppKitVersionNumberWithPatternColorLeakFix 641.0



@interface NSColor : NSObject <NSCopying, NSSecureCoding, NSPasteboardReading, NSPasteboardWriting>

- (instancetype)init NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;

/* Create NSCalibratedWhiteColorSpace colors.
*/
+ (NSColor *)colorWithCalibratedWhite:(CGFloat)white alpha:(CGFloat)alpha;


/* Create NSCalibratedRGBColorSpace colors.
*/
+ (NSColor *)colorWithCalibratedHue:(CGFloat)hue saturation:(CGFloat)saturation brightness:(CGFloat)brightness alpha:(CGFloat)alpha;
+ (NSColor *)colorWithCalibratedRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha;


/* Create colors in various device color spaces. 
*/
+ (NSColor *)colorWithDeviceWhite:(CGFloat)white alpha:(CGFloat)alpha;
+ (NSColor *)colorWithDeviceHue:(CGFloat)hue saturation:(CGFloat)saturation brightness:(CGFloat)brightness alpha:(CGFloat)alpha;
+ (NSColor *)colorWithDeviceRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha;
+ (NSColor *)colorWithDeviceCyan:(CGFloat)cyan magenta:(CGFloat)magenta yellow:(CGFloat)yellow black:(CGFloat)black alpha:(CGFloat)alpha;


/* Create named colors from standard color catalogs (such as Pantone).
*/
+ (nullable NSColor *)colorWithCatalogName:(NSString *)listName colorName:(NSString *)colorName;


/* Create colors with arbitrary colorspace. The number of components in the provided array should match the number dictated by the specified colorspace, plus one for alpha (supply 1.0 for opaque colors); otherwise an exception will be raised.  If the colorspace is one which cannot be used with NSColors, nil is returned.
*/
+ (NSColor *)colorWithColorSpace:(NSColorSpace *)space components:(const CGFloat *)components count:(NSInteger)numberOfComponents;


/* Create NSCustomColorSpace colors in the sRGB or GenericGamma22Gray colorspaces.  
*/
+ (NSColor *)colorWithGenericGamma22White:(CGFloat)white alpha:(CGFloat)alpha  NS_AVAILABLE_MAC(10_7);
+ (NSColor *)colorWithSRGBRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha  NS_AVAILABLE_MAC(10_7);


/* Create NSCustomColorSpace colors that are compatible with sRGB colorspace; these variants are provided for easier reuse of code that uses UIColor on iOS. It's typically better to specify the colorspace explicitly with one of the above methods.
*/
+ (NSColor *)colorWithWhite:(CGFloat)white alpha:(CGFloat)alpha NS_AVAILABLE_MAC(10_9);
+ (NSColor *)colorWithRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_MAC(10_9);
+ (NSColor *)colorWithHue:(CGFloat)hue saturation:(CGFloat)saturation brightness:(CGFloat)brightness alpha:(CGFloat)alpha NS_AVAILABLE_MAC(10_9);


/* Some convenience methods to create colors in the calibrated color spaces...
*/
+ (NSColor *)blackColor;	/* 0.0 white */
+ (NSColor *)darkGrayColor;	/* 0.333 white */
+ (NSColor *)lightGrayColor;	/* 0.667 white */
+ (NSColor *)whiteColor;	/* 1.0 white */
+ (NSColor *)grayColor;		/* 0.5 white */
+ (NSColor *)redColor;		/* 1.0, 0.0, 0.0 RGB */
+ (NSColor *)greenColor;	/* 0.0, 1.0, 0.0 RGB */
+ (NSColor *)blueColor;		/* 0.0, 0.0, 1.0 RGB */
+ (NSColor *)cyanColor;		/* 0.0, 1.0, 1.0 RGB */
+ (NSColor *)yellowColor;	/* 1.0, 1.0, 0.0 RGB */
+ (NSColor *)magentaColor;	/* 1.0, 0.0, 1.0 RGB */
+ (NSColor *)orangeColor;	/* 1.0, 0.5, 0.0 RGB */
+ (NSColor *)purpleColor;	/* 0.5, 0.0, 0.5 RGB */
+ (NSColor *)brownColor;	/* 0.6, 0.4, 0.2 RGB */
+ (NSColor *)clearColor;	/* 0.0 white, 0.0 alpha */

+ (NSColor *)controlShadowColor;		// Dark border for controls
+ (NSColor *)controlDarkShadowColor;		// Darker border for controls
+ (NSColor *)controlColor;			// Control face and old window background color
+ (NSColor *)controlHighlightColor;		// Light border for controls
+ (NSColor *)controlLightHighlightColor;	// Lighter border for controls
+ (NSColor *)controlTextColor;			// Text on controls
+ (NSColor *)controlBackgroundColor;		// Background of large controls (browser, tableview, clipview, ...)
+ (NSColor *)selectedControlColor;		// Control face for selected controls
+ (NSColor *)secondarySelectedControlColor;	// Color for selected controls when control is not active (that is, not focused)
+ (NSColor *)selectedControlTextColor;		// Text on selected controls
+ (NSColor *)disabledControlTextColor;		// Text on disabled controls
+ (NSColor *)textColor;				// Document text
+ (NSColor *)textBackgroundColor;		// Document text background
+ (NSColor *)selectedTextColor;			// Selected document text
+ (NSColor *)selectedTextBackgroundColor;	// Selected document text background
+ (NSColor *)gridColor;				// Grids in controls
+ (NSColor *)keyboardFocusIndicatorColor;// Keyboard focus ring around controls
+ (NSColor *)windowBackgroundColor;		// Background fill for window contents
+ (NSColor *)underPageBackgroundColor NS_AVAILABLE_MAC(10_8);   // Background areas revealed behind views

+ (NSColor *)labelColor NS_AVAILABLE_MAC(10_10);            // Text color for static text and related elements
+ (NSColor *)secondaryLabelColor NS_AVAILABLE_MAC(10_10);   // Text color for secondary static text and related elements
+ (NSColor *)tertiaryLabelColor NS_AVAILABLE_MAC(10_10);    // Text color for disabled static text and related elements
+ (NSColor *)quaternaryLabelColor NS_AVAILABLE_MAC(10_10);  // Text color for large secondary or disabled static text, separators, large glyphs/icons, etc

+ (NSColor *)scrollBarColor;			// Scroll bar slot color
+ (NSColor *)knobColor;     			// Knob face color for controls
+ (NSColor *)selectedKnobColor;       		// Knob face color for selected controls

+ (NSColor *)windowFrameColor;			// Window frames
+ (NSColor *)windowFrameTextColor;		// Text on window frames

+ (NSColor *)selectedMenuItemColor;		// Highlight color for menus
+ (NSColor *)selectedMenuItemTextColor;		// Highlight color for menu text

+ (NSColor *)highlightColor;     	     	// Highlight color for UI elements (this is abstract and defines the color all highlights tend toward)
+ (NSColor *)shadowColor;     			// Shadow color for UI elements (this is abstract and defines the color all shadows tend toward)

+ (NSColor *)headerColor;			// Background color for header cells in Table/OutlineView
+ (NSColor *)headerTextColor;			// Text color for header cells in Table/OutlineView

+ (NSColor *)alternateSelectedControlColor;	// Similar to selectedControlColor; for use in lists and tables 
+ (NSColor *)alternateSelectedControlTextColor;		// Similar to selectedControlTextColor; see alternateSelectedControlColor

+ (NSArray<NSColor *> *)controlAlternatingRowBackgroundColors;	// Standard colors for alternating colored rows in tables and lists (for instance, light blue/white; don't assume just two colors)

- (nullable NSColor *)highlightWithLevel:(CGFloat)val;	// val = 0 => receiver, val = 1 => highlightColor
- (nullable NSColor *)shadowWithLevel:(CGFloat)val;	// val = 0 => receiver, val = 1 => shadowColor

+ (NSColor *)colorForControlTint:(NSControlTint)controlTint;	// pass in valid tint to get rough color matching. returns default if invalid tint

+ (NSControlTint)currentControlTint;	// returns current system control tint


/* Set the color: Sets the fill and stroke colors in the current drawing context. If the color doesn't know about alpha, it's set to 1.0. Should be implemented by subclassers.
*/
- (void)set;

/* Set the fill or stroke colors individually. These should be implemented by subclassers.
*/
- (void)setFill;
- (void)setStroke;

/* Get the color space of the color. Should be implemented by subclassers.
*/
@property (readonly, copy) NSString *colorSpaceName;


/* Convert the color to another colorspace, using a colorspace name. This may return nil if the specified conversion cannot be done. The abstract implementation of this method returns the receiver if the specified colorspace matches that of the receiver; otherwise it returns nil. Subclassers who can convert themselves to other colorspaces override this method to do something better.

The version of this method which takes a device description allows the color to specialize itself for the given device.  Device descriptions can be obtained from windows, screens, and printers with the "deviceDescription" method.

If device is nil then the current device (as obtained from the currently lockFocus'ed view's window or, if printing, the current printer) is used. The method without the device: argument passes nil for the device.

If colorSpace is nil, then the most appropriate color space is used.
*/ 
- (nullable NSColor *)colorUsingColorSpaceName:(NSString *)colorSpace;
- (nullable NSColor *)colorUsingColorSpaceName:(nullable NSString *)colorSpace device:(nullable NSDictionary<NSString *, id> *)deviceDescription;


/* colorUsingColorSpace: will convert existing color to a new colorspace and create a new color, which will likely have different component values but look the same. It will return the same color if the colorspace is already the same as the one specified.  Will return nil if conversion is not possible.
*/
- (nullable NSColor *)colorUsingColorSpace:(NSColorSpace *)space;


/* Blend using the NSCalibratedRGB color space. Both colors are converted into the calibrated RGB color space, and they are blended by taking fraction of color and 1 - fraction of the receiver. The result is in the calibrated RGB color space. If the colors cannot be converted into the calibrated RGB color space the blending fails and nil is returned.
*/
- (nullable NSColor *)blendedColorWithFraction:(CGFloat)fraction ofColor:(NSColor *)color;


/* Returns a color in the same color space as the receiver with the specified alpha component. The abstract implementation of this method returns the receiver if alpha is 1.0, otherwise it returns nil; subclassers who have explicit opacity components override this method to actually return a color with the specified alpha.
*/
- (NSColor *)colorWithAlphaComponent:(CGFloat)alpha;


/*** Methods to get various components of colors. Not all of the methods apply to all colors; if called, they raise. ***/

/* Get the catalog and color name of standard colors from catalogs. These colors are special colors which are usually looked up on each device by their name.
*/
@property (readonly, copy) NSString *catalogNameComponent;
@property (readonly, copy) NSString *colorNameComponent;

/* Return localized versions of the above.
*/
@property (readonly, copy) NSString *localizedCatalogNameComponent;
@property (readonly, copy) NSString *localizedColorNameComponent;

/* Get the red, green, or blue components of NSCalibratedRGB or NSDeviceRGB colors.  Starting in 10.7, it's also possible to call these on NSCustomColorSpace colors with color spaces with RGB model. 
*/
@property (readonly) CGFloat redComponent;
@property (readonly) CGFloat greenComponent;
@property (readonly) CGFloat blueComponent;
- (void)getRed:(nullable CGFloat *)red green:(nullable CGFloat *)green blue:(nullable CGFloat *)blue alpha:(nullable CGFloat *)alpha;

/* Get the components of NSCalibratedRGB or NSDeviceRGB colors as hue, saturation, or brightness. Starting in 10.7, it's also possible to call these on NSCustomColorSpace colors with color spaces with RGB model. 
*/
@property (readonly) CGFloat hueComponent;
@property (readonly) CGFloat saturationComponent;
@property (readonly) CGFloat brightnessComponent;
- (void)getHue:(nullable CGFloat *)hue saturation:(nullable CGFloat *)saturation brightness:(nullable CGFloat *)brightness alpha:(nullable CGFloat *)alpha;


/* Get the white component of NSCalibratedWhite or NSDeviceWhite colors. Starting in 10.7, it's possible to call these on NSCustomColorSpace colors with color spaces with grayscale model. 
*/
@property (readonly) CGFloat whiteComponent;
- (void)getWhite:(nullable CGFloat *)white alpha:(nullable CGFloat *)alpha;


/* Get the CMYK components of NSDeviceCMYK colors.  Starting in 10.7, it's possible to call these on NSCustomColorSpace colors with color spaces with CMYK model. 
*/
@property (readonly) CGFloat cyanComponent;
@property (readonly) CGFloat magentaComponent;
@property (readonly) CGFloat yellowComponent;
@property (readonly) CGFloat blackComponent;
- (void)getCyan:(nullable CGFloat *)cyan magenta:(nullable CGFloat *)magenta yellow:(nullable CGFloat *)yellow black:(nullable CGFloat *)black alpha:(nullable CGFloat *)alpha;


/* For colors with custom colorspace; get the colorspace and individual floating point components, including alpha. Note that all these methods will work for other NSColors which have floating point components. They will raise exceptions otherwise, like other existing colorspace-specific methods.
*/
@property (readonly, strong) NSColorSpace *colorSpace;
@property (readonly) NSInteger numberOfComponents;
- (void)getComponents:(CGFloat *)components;


/* Get the alpha component. For colors which do not have alpha components, this will return 1.0 (opaque).
*/
@property (readonly) CGFloat alphaComponent;


/* Pasteboard methods
*/
+ (nullable NSColor *)colorFromPasteboard:(NSPasteboard *)pasteBoard;
- (void)writeToPasteboard:(NSPasteboard *)pasteBoard;


/* Pattern methods. Note that colorWithPatternImage: mistakenly returns a non-autoreleased color in 10.1.x and earlier. This has been fixed in (NSAppKitVersionNumber >= NSAppKitVersionNumberWithPatternColorLeakFix), for apps linked post-10.1.x.
*/
+ (NSColor *)colorWithPatternImage:(NSImage*)image;
@property (readonly, strong) NSImage *patternImage; 

/* Draws the color and adorns it to indicate the type of color. Used by colorwells, swatches, and other UI objects that need to display colors. Implementation in NSColor simply draws the color (with an indication of transparency if the color isn't fully opaque); subclassers can draw more stuff as they see fit.
*/
- (void)drawSwatchInRect:(NSRect)rect;


/* Convert to and from CGColorRef.
*/
+ (nullable NSColor *)colorWithCGColor:(CGColorRef)cgColor NS_AVAILABLE_MAC(10_8);   // May return nil
@property (readonly) CGColorRef CGColor NS_RETURNS_INNER_POINTER NS_AVAILABLE_MAC(10_8);      // Returns an autoreleased CGColor. This will never be NULL, although the return value may be an approximation in some cases, so there isn't guaranteed round-trip fidelity.


/* Global flag for determining whether an application supports alpha.  This flag is consulted when an application imports alpha (through color dragging, for instance). The value of this flag also determines whether the color panel has an opacity slider. This value is YES by default, indicating that the opacity components of imported colors will be set to 1.0. If an application wants alpha, it can either set the "NSIgnoreAlpha" default to NO or call the set method below.

This method provides a global approach to removing alpha which might not always be appropriate. Applications which need to import alpha sometimes should set this flag to NO and explicitly make colors opaque in cases where it matters to them.
*/
+ (void)setIgnoresAlpha:(BOOL)flag;
+ (BOOL)ignoresAlpha;

@end


@interface NSColor (NSQuartzCoreAdditions)
+ (NSColor *)colorWithCIColor:(CIColor *)color;
@end

@interface CIColor (NSAppKitAdditions)
- (nullable instancetype)initWithColor:(NSColor *)color;
@end

@interface NSCoder(NSAppKitColorExtensions)

/* To decode NXColors... Will return nil if the archived color was "invalid" (written out by the kit in a few instances). Otherwise returns autoreleased NSColor. Can't write NSColors as NXColors, so we have no corresponding encode method.
*/
- (null_unspecified NSColor *)decodeNXColor NS_DEPRECATED_MAC(10_0, 10_9);

@end

APPKIT_EXTERN NSString * NSSystemColorsDidChangeNotification;

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                NSColorList.h                                                                                       0100644 0001750 0001750 00000007651 12567220725 033353  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSColorList.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

/* An NSColorList is an ordered list of NSColors, identified by keys. These keys are used to identify the colors in the list and are used to display the color to the user in the color panel. Note that the key is only used in identifying a color in a color list; it has nothing to do with the contents of the color, unless, of course the color list was set up in such a way that the keys matched the color names.

Instances of NSColorList are created for all user-created color lists (those in the color panel) and various color catalogs available on the system.

NSColorLists post "NSColorListDidChangeNotification" when changed.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <AppKit/AppKitDefines.h>
#import <CoreFoundation/CFDictionary.h>

NS_ASSUME_NONNULL_BEGIN

@class NSColor, NSBundle;

@interface NSColorList : NSObject <NSSecureCoding> {
    /*All instance variables are private*/
    NSMutableArray *_keyArray;
    NSMutableArray *_colorArray;
    CFMutableDictionaryRef _keyToIndexTable;
    NSString *_name;
    NSString *_printerType;
    NSString *_fileName;
    struct _colorListFlags {
	unsigned int colorsLoaded:1;
	unsigned int editable:1;
	unsigned int hasDeviceSpecificLists:1;
	unsigned int dirty:1;
	unsigned int hasFrozen:1;
	unsigned int notificationsDisabled:1;
        unsigned int hasAttemptedLoadingBundleForDirectory:1;
	unsigned int isProfileBased:1;
	unsigned int :24;
#if __LP64__
	unsigned int :32;
#endif
    } _flags;
    id _clAuxiliaryStorage;
}

/* Returns all color lists in the user's color list path, including those added at runtime. Creating a named color list and saving with writeToFile:nil will add it to this list; removeFile will remove it from this list. (That is what happens as the user creates and destroys color lists in the color panel.)
*/
+ (NSArray<NSColorList *> *)availableColorLists;

/* Returns the named color list from availableColorLists
*/
+ (nullable NSColorList *)colorListNamed:(NSString *)name;

/* Creates a color list; specify @"" if you don't want a name. NOTE that this does not add the color list to availableColorLists until the color list is saved into the user's path with writeToFile:nil.
*/
- (instancetype)initWithName:(NSString *)name;			
- (nullable instancetype)initWithName:(NSString *)name fromFile:(nullable NSString *)path;	/* Load initial contents */

/* Name of the color list
*/
@property (nullable, readonly, copy) NSString *name;

/* If key already exists, sets the corresponding color. Otherwise inserts the color at the end.
*/
- (void)setColor:(NSColor *)color forKey:(NSString *)key;

/* Inserts color at the specified location. If a color by the same key is already in the list but at a different location it is removed from there.
*/
- (void)insertColor:(NSColor *)color key:(NSString *)key atIndex:(NSUInteger)loc;

/* No-op if key doesn't exist.
*/
- (void)removeColorWithKey:(NSString *)key;

/* Returns nil if key doesn't exist.
*/
- (nullable NSColor *)colorWithKey:(NSString *)key;

/* Use this array to get count of colors and enumerate them according to the ordering specified when inserting.
*/
@property (readonly, copy) NSArray<NSString *> *allKeys;

/* Depends on the source of the colorlist file
*/
@property (getter=isEditable, readonly) BOOL editable;

/* Use "nil" to save to the user's private colorlists directory. If the color list is named, this method will also insert the color list into availableColorLists.
*/
- (BOOL)writeToFile:(nullable NSString *)path;	

/* If the color list is in the user's path, removes the corresponding file in user's private colorlists directory. Also removes the color list from availableColorLists. If there are no outstanding references to the color list this might deallocate the object as well.
*/
- (void)removeFile;

@end

/* Notifications */
APPKIT_EXTERN NSString * NSColorListDidChangeNotification;

NS_ASSUME_NONNULL_END

                                                                                       NSColorPanel.h                                                                                      0100644 0001750 0001750 00000006250 12567220725 033471  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSColorPanel.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSPanel.h>
#import <AppKit/NSApplication.h>

NS_ASSUME_NONNULL_BEGIN

@class NSColorList, NSMutableArray;

typedef NS_ENUM(NSInteger, NSColorPanelMode) {
    /* If the color panel is not displaying a mode, the NSNoModeColorPanel will be returned */
    NSNoModeColorPanel NS_ENUM_AVAILABLE_MAC(10_5) = -1,
    NSGrayModeColorPanel		= 0,
    NSRGBModeColorPanel			= 1,
    NSCMYKModeColorPanel		= 2,
    NSHSBModeColorPanel			= 3,
    NSCustomPaletteModeColorPanel	= 4,
    NSColorListModeColorPanel		= 5,
    NSWheelModeColorPanel		= 6,
    NSCrayonModeColorPanel		= 7
};

typedef NS_OPTIONS(NSUInteger, NSColorPanelOptions) {
    NSColorPanelGrayModeMask		= 0x00000001,
    NSColorPanelRGBModeMask		= 0x00000002,
    NSColorPanelCMYKModeMask		= 0x00000004,
    NSColorPanelHSBModeMask		= 0x00000008,
    NSColorPanelCustomPaletteModeMask	= 0x00000010,
    NSColorPanelColorListModeMask	= 0x00000020,
    NSColorPanelWheelModeMask		= 0x00000040,
    NSColorPanelCrayonModeMask		= 0x00000080,
    NSColorPanelAllModesMask		= 0x0000ffff
};
    
    

@interface NSColorPanel : NSPanel
{
    /*All instance variables are private*/
    id			_colorSwatch;
    id                  _accessoryContainerView;
    id			_colorWell;
    NSMutableArray     *_pickersWithLoadedViews;
    id			_magnifyButton;
    id			_middleView;
    id			_opacitySlider;
    id			_opacityText;
    id			_opacityView;
    id			_modalButtons;
    id			_pickerView;
    id			_customViewsList;
    id			_customPickerList;
    id			_currViewObject;
    id			_bottomConstraint;
    id			_target;
    id			_accessoryView;
    SEL			_action;
    NSSize		_minColorPanelSize;
    NSSize		_maxColorPanelSize;
    id                  _accessoryContainerViewHeight;
    id                  _opacityViewHeight;
    id                  _reserved1;
    id                  _reserved2;
    id			_resizeDimple;
    BOOL                _reserved3;
    BOOL		_reserved4;
    BOOL		_handlingOpacityMoveAction;
    BOOL		_ignoreConstraints;
    BOOL		_continuous;
    BOOL		_allowColorSetting;
    BOOL		_stillInitializing;
    BOOL                _reserved5;
    id			_opacityTextController;
}

+ (NSColorPanel *)sharedColorPanel;
+ (BOOL)sharedColorPanelExists;
+ (BOOL)dragColor:(NSColor *)color withEvent:(NSEvent *)theEvent fromView:(NSView *)sourceView;
+ (void)setPickerMask:(NSColorPanelOptions)mask;
+ (void)setPickerMode:(NSColorPanelMode)mode;

@property (nullable, strong) NSView *accessoryView;
@property (getter=isContinuous) BOOL continuous;
@property BOOL showsAlpha;
@property NSColorPanelMode mode;
@property (copy) NSColor *color;
@property (readonly) CGFloat alpha;
- (void)setAction:(nullable SEL)aSelector;
- (void)setTarget:(nullable id)anObject;
- (void)attachColorList:(NSColorList *)colorList;
- (void)detachColorList:(NSColorList *)colorList;
@end

@interface NSApplication(NSColorPanel)
- (void)orderFrontColorPanel:(nullable id)sender;
@end

@interface NSObject(NSColorPanelResponderMethod)
- (void)changeColor:(nullable id)sender;
@end

/* Notifications */
APPKIT_EXTERN NSString * NSColorPanelColorDidChangeNotification;

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                        NSColorPicker.h                                                                                     0100644 0001750 0001750 00000002226 12567220725 033646  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSColorPicker.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSColorPicking.h>

NS_ASSUME_NONNULL_BEGIN

@interface NSColorPicker : NSObject <NSColorPickingDefault>
{
    /*All instance variables are private*/
    id _imageObject;
    NSColorPanel *_colorPanel;
    NSString *_buttonToolTip;
}
- (nullable instancetype)initWithPickerMask:(NSUInteger)mask colorPanel:(NSColorPanel *)owningColorPanel;
@property (readonly, strong) NSColorPanel *colorPanel;
@property (readonly, strong) NSImage *provideNewButtonImage;
- (void)insertNewButtonImage:(NSImage *)newButtonImage in:(NSButtonCell *)buttonCell;
- (void)viewSizeChanged:(nullable id)sender;
- (void)attachColorList:(NSColorList *)colorList;
- (void)detachColorList:(NSColorList *)colorList;
- (void)setMode:(NSColorPanelMode)mode;
// The default implementation of buttonToolTip returns the current classname
@property (readonly, copy) NSString *buttonToolTip;
// The default implementation of minContentSize will look at your view's Autosizing behavior and do the right thing based on that.
@property (readonly) NSSize minContentSize;
@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                          NSColorPicking.h                                                                                    0100644 0001750 0001750 00000006254 12567220725 034022  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSColorPicking.h
    Application Kit
    Copyright (c) 1994-2015, Apple Inc.
    All rights reserved.
*/


#import <Foundation/NSObject.h>
#import <AppKit/NSColorPanel.h>

NS_ASSUME_NONNULL_BEGIN

@class NSButtonCell, NSColor, NSColorPanel, NSColorList, NSImage, NSView;

@protocol NSColorPickingDefault

/* 
    The following methods are implemented by the generic base class, NSColorPicker, and only need be implemented (overridden) by the CustomPicker developer if there is a need.
*/

/* 
    initWithPickerMask:colorPanel: allows you to return your custom color picker to the ColorPanel.

    "mask" is the mask (if any) passed to the ColorPanel by the +setPickerMask: method.  If your picker supports any of the bits in the mask, return "self", otherwise, return "nil" (default is "self" if not overridden, since if the "setPickerMask" method is never called, the ColorPanel will just start off with the normal picker modes, of which your custom mode will not be a part). This method can be used to turn off some (or all) of your subpickers, if you have any (like sliders). If this method returns "nil", the object will be freed.
 
    "owningColorPanel" is the id of the instantiating ColorPanel.  
 
    If this method is overridden, the base class' (NSColorPicker's) initFromPickerMask method should be called before any subclass processing. The instance variable "colorPanel" is set in this method.
 
    FOR PERFORMANCE, DO NOT LOAD .NIBS, ETC. HERE!! WAIT UNTIL provideNewView: in NSColorPickingCustom!
*/

- (nullable instancetype)initWithPickerMask:(NSUInteger)mask colorPanel:(NSColorPanel *)owningColorPanel;

/* Allows you to return a new image used in the toolbar. By default, you can simply have a .tiff file with the same name as your custom color picker class in the bundle, and will not need to implement this method. 
*/
- (NSImage *)provideNewButtonImage;
- (void)insertNewButtonImage:(NSImage *)newButtonImage in:(NSButtonCell *)buttonCell;
- (void)viewSizeChanged:(nullable id)sender;
- (void)alphaControlAddedOrRemoved:(nullable id)sender;
- (void)attachColorList:(NSColorList *)colorList;
- (void)detachColorList:(NSColorList *)colorList;
- (void)setMode:(NSColorPanelMode)mode;   


/* The tooltip to be used for the tool bar button.
*/
- (NSString *)buttonToolTip NS_AVAILABLE_MAC(10_5);

/* The minimum content size for your picker. The NSColorPanel will not allow resizing smaller than this size. By default, you will not have to do anything if you properly setup the Autosizing attributes in IB for your view. 
*/
- (NSSize)minContentSize NS_AVAILABLE_MAC(10_5);


@end

/* NSColorPickingCustom MUST be implemented by the CustomPicker, or an error will occur! 
*/
@protocol NSColorPickingCustom <NSColorPickingDefault>

/* Return NO if "mode" not supported. 
*/
- (BOOL)supportsMode:(NSColorPanelMode)mode;   

/* Return the current mode that your picker is in.
*/
- (NSColorPanelMode)currentMode;

/* Provide the view for your picker. initialRequest will be YES on very first call. At this point, you should load your nibs.
*/
- (NSView *)provideNewView:(BOOL)initialRequest;

/* Set your color picker's displayed color to newColor.
*/
- (void)setColor:(NSColor *)newColor;
@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                    NSColorSpace.h                                                                                      0100644 0001750 0001750 00000007122 12567220725 033464  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSColorSpace.h
	Application Kit
	Copyright (c) 2004-2015, Apple Inc.
	All rights reserved.
*/


#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <AppKit/AppKitDefines.h>
#import <ApplicationServices/ApplicationServices.h>

NS_ASSUME_NONNULL_BEGIN

@class NSData;



typedef NS_ENUM(NSInteger, NSColorSpaceModel) {
    NSUnknownColorSpaceModel = -1,
    NSGrayColorSpaceModel,
    NSRGBColorSpaceModel,
    NSCMYKColorSpaceModel,
    NSLABColorSpaceModel,
    NSDeviceNColorSpaceModel,
    NSIndexedColorSpaceModel,
    NSPatternColorSpaceModel
};


NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE
@interface NSColorSpace : NSObject <NSSecureCoding> {
    id _profile;
    struct {
	unsigned int colorSpaceID:8;
	unsigned int storageType:3;
	unsigned int replacedDuringUnarchiving:1;
	unsigned int :20;
#if __LP64__
	unsigned int :32;
#endif
    } _flags;
    void *__cgColorSpace;
    void *__cgColorTransform;
    void *_reserved[4];
}

- (nullable instancetype)initWithICCProfileData:(NSData *)iccData;
@property (nullable, readonly, strong) NSData *ICCProfileData;

- (nullable instancetype)initWithColorSyncProfile:(void * /* ColorSyncProfileRef */)prof;
@property (nullable, readonly) void * /* ColorSyncProfileRef */colorSyncProfile NS_RETURNS_INNER_POINTER;

/* Create NSColorSpace from a CGColorSpace.  Might return nil if the CGColorSpace is one not supported by NSColorSpace. Internally the NSColorSpace might retain or create a new copy of the provided CGColorSpace; do not rely on pointer equality of the CGColorSpace provided to this function, when later queried. Archiving, for instance, might not persist the pointer equality/identity of the CGColorSpace.
*/
- (nullable instancetype)initWithCGColorSpace:(CGColorSpaceRef)cgColorSpace  NS_AVAILABLE_MAC(10_5);

/* Might return NULL if the NSColorSpace space cannot be represented as a CGColorSpace.
*/
@property (nullable, readonly) CGColorSpaceRef CGColorSpace  NS_AVAILABLE_MAC(10_5);

@property (readonly) NSInteger numberOfColorComponents;		// Does not include alpha
@property (readonly) NSColorSpaceModel colorSpaceModel;
@property (nullable, readonly, copy) NSString *localizedName;			// Will return nil if no localized name

+ (NSColorSpace *)genericRGBColorSpace;		// NSColorSpace corresponding to Cocoa color space name NSCalibratedRGBColorSpace
+ (NSColorSpace *)genericGrayColorSpace;	// NSColorSpace corresponding to Cocoa color space name NSCalibratedWhiteColorSpace
+ (NSColorSpace *)genericCMYKColorSpace;
+ (NSColorSpace *)deviceRGBColorSpace;		// NSColorSpace corresponding to Cocoa color space name NSDeviceRGBColorSpace
+ (NSColorSpace *)deviceGrayColorSpace;		// NSColorSpace corresponding to Cocoa color space name NSDeviceWhiteColorSpace
+ (NSColorSpace *)deviceCMYKColorSpace;		// NSColorSpace corresponding to Cocoa color space name NSDeviceCMYKColorSpace

+ (NSColorSpace *)sRGBColorSpace  NS_AVAILABLE_MAC(10_5);
+ (NSColorSpace *)genericGamma22GrayColorSpace  NS_AVAILABLE_MAC(10_6);  // The "generic" color space with gamma 2.2.

+ (NSColorSpace *)adobeRGB1998ColorSpace  NS_AVAILABLE_MAC(10_5);

/* Return the list of color spaces available on the system that are displayed by the color panel, in the order they are displayed in the color panel. Doesn't return arbitrary color spaces which may have been created on the fly, or spaces without user displayable names. Pass model==NSUnknownColorSpaceModel to get all color spaces. Empty array is returned if no color spaces are available for the specified model. 
*/
+ (NSArray<NSColorSpace *> *)availableColorSpacesWithModel:(NSColorSpaceModel)model  NS_AVAILABLE_MAC(10_6);

@end

NS_ASSUME_NONNULL_END



                                                                                                                                                                                                                                                                                                                                                                                                                                              NSColorWell.h                                                                                       0100644 0001750 0001750 00000001531 12567220725 033332  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSColorWell.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSControl.h>

NS_ASSUME_NONNULL_BEGIN

@interface NSColorWell : NSControl
{
    /*All instance variables are private*/
    NSColor *_color;
    id _reserved;
    SEL _reserved2;
    struct __cwFlags {
	unsigned int        isActive:1;
	unsigned int        isBordered:1;
	unsigned int        cantDraw:1;
	unsigned int        isNotContinuous:1;
        unsigned int        refusesFR:1;
	unsigned int	    reservedColorWell:27;
    } _cwFlags;
}

- (void)deactivate;
- (void)activate:(BOOL)exclusive;
@property (getter=isActive, readonly) BOOL active;

- (void)drawWellInside:(NSRect)insideRect;

@property (getter=isBordered) BOOL bordered;

- (void)takeColorFrom:(nullable id)sender;
@property (copy) NSColor *color;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                       NSComboBox.h                                                                                        0100644 0001750 0001750 00000005511 12567220725 033142  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSComboBox.h
	Application Kit
	Copyright (c) 1996-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <AppKit/NSTextField.h>

NS_ASSUME_NONNULL_BEGIN

APPKIT_EXTERN NSString * NSComboBoxWillPopUpNotification;
APPKIT_EXTERN NSString * NSComboBoxWillDismissNotification;
APPKIT_EXTERN NSString * NSComboBoxSelectionDidChangeNotification;
APPKIT_EXTERN NSString * NSComboBoxSelectionIsChangingNotification;

@protocol NSComboBoxDelegate, NSComboBoxDataSource;

@interface NSComboBox : NSTextField {
    /*All instance variables are private*/
    id _dataSource;
}

@property BOOL hasVerticalScroller;
@property NSSize intercellSpacing;
@property CGFloat itemHeight;
@property NSInteger numberOfVisibleItems;

@property (getter=isButtonBordered) BOOL buttonBordered;

- (void)reloadData;
- (void)noteNumberOfItemsChanged;

@property BOOL usesDataSource;

- (void)scrollItemAtIndexToTop:(NSInteger)index;
- (void)scrollItemAtIndexToVisible:(NSInteger)index;

- (void)selectItemAtIndex:(NSInteger)index;
- (void)deselectItemAtIndex:(NSInteger)index;
@property (readonly) NSInteger indexOfSelectedItem;
@property (readonly) NSInteger numberOfItems;

@property BOOL completes;

- (nullable id <NSComboBoxDelegate>)delegate;
- (void)setDelegate:(nullable id <NSComboBoxDelegate>)anObject;

/* These two methods can only be used when usesDataSource is YES */
@property (nullable, assign) id<NSComboBoxDataSource> dataSource;

/* These methods can only be used when usesDataSource is NO */
- (void)addItemWithObjectValue:(id)object;
- (void)addItemsWithObjectValues:(NSArray *)objects;
- (void)insertItemWithObjectValue:(id)object atIndex:(NSInteger)index;
- (void)removeItemWithObjectValue:(id)object;
- (void)removeItemAtIndex:(NSInteger)index;
- (void)removeAllItems;
- (void)selectItemWithObjectValue:(nullable id)object;
- (id)itemObjectValueAtIndex:(NSInteger)index;
@property (nullable, readonly, strong) id objectValueOfSelectedItem;
- (NSInteger)indexOfItemWithObjectValue:(id)object;
@property (readonly, copy) NSArray *objectValues;

@end

@protocol NSComboBoxDataSource <NSObject>
@optional
/* These two methods are required when not using bindings */
- (NSInteger)numberOfItemsInComboBox:(NSComboBox *)aComboBox;
- (id)comboBox:(NSComboBox *)aComboBox objectValueForItemAtIndex:(NSInteger)index;

- (NSUInteger)comboBox:(NSComboBox *)aComboBox indexOfItemWithStringValue:(NSString *)string;
- (nullable NSString *)comboBox:(NSComboBox *)aComboBox completedString:(NSString *)string;
@end

@protocol NSComboBoxDelegate <NSTextFieldDelegate>
@optional

/* Notifications */
- (void)comboBoxWillPopUp:(NSNotification *)notification;
- (void)comboBoxWillDismiss:(NSNotification *)notification;
- (void)comboBoxSelectionDidChange:(NSNotification *)notification;
- (void)comboBoxSelectionIsChanging:(NSNotification *)notification;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                       NSComboBoxCell.h                                                                                    0100644 0001750 0001750 00000005547 12567220725 033753  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSComboBoxCell.h
	Application Kit
	Copyright (c) 1996-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <AppKit/NSTextFieldCell.h>

NS_ASSUME_NONNULL_BEGIN

@class NSButtonCell, NSTableView;
@protocol NSComboBoxCellDataSource;

@interface NSComboBoxCell : NSTextFieldCell   {
    /*All instance variables are private*/
    id _delegate;
    id _dataSource;
    struct __cbcFlags {
        unsigned int usesDataSource:1;
        unsigned int completes:1;
	unsigned int buttonBordered:1;
        unsigned int popUpIsUp:1;
	unsigned int filteringEvents:1;
        unsigned int drawing:1;
        unsigned int synchronizingSelection:1;
        unsigned int reserved:9;
	unsigned int visibleItems:16;
    } _cbcFlags;
    NSButtonCell *_buttonCell;
    NSTableView *_tableView;
    NSScrollView *_scrollView;
    NSWindow *_popUp;
    NSMutableArray *_popUpList;
    __strong NSRect *_cellFrame;
    void *_reserved;
 }

@property BOOL hasVerticalScroller;
@property NSSize intercellSpacing; 
@property CGFloat itemHeight;
@property NSInteger numberOfVisibleItems;

@property (getter=isButtonBordered) BOOL buttonBordered;

- (void)reloadData;
- (void)noteNumberOfItemsChanged;

@property BOOL usesDataSource;

- (void)scrollItemAtIndexToTop:(NSInteger)index;
- (void)scrollItemAtIndexToVisible:(NSInteger)index;

- (void)selectItemAtIndex:(NSInteger)index;
- (void)deselectItemAtIndex:(NSInteger)index;
@property (readonly) NSInteger indexOfSelectedItem;
@property (readonly) NSInteger numberOfItems;

@property BOOL completes;
- (nullable NSString *)completedString:(NSString *)string;

/* These two methods can only be used when usesDataSource is YES */
@property (nullable, assign) id<NSComboBoxCellDataSource> dataSource;

/* These methods can only be used when usesDataSource is NO */
- (void)addItemWithObjectValue:(id)object;
- (void)addItemsWithObjectValues:(NSArray *)objects;
- (void)insertItemWithObjectValue:(id)object atIndex:(NSInteger)index;
- (void)removeItemWithObjectValue:(id)object;
- (void)removeItemAtIndex:(NSInteger)index;
- (void)removeAllItems;
- (void)selectItemWithObjectValue:(nullable id)object;
- (id)itemObjectValueAtIndex:(NSInteger)index;
@property (nullable, readonly, strong) id objectValueOfSelectedItem;
- (NSInteger)indexOfItemWithObjectValue:(id)object;
@property (readonly, copy) NSArray *objectValues;

@end

@protocol NSComboBoxCellDataSource <NSObject>
@optional
/* These two methods are required when not using bindings */
- (NSInteger)numberOfItemsInComboBoxCell:(NSComboBoxCell *)comboBoxCell;
- (id)comboBoxCell:(NSComboBoxCell *)aComboBoxCell objectValueForItemAtIndex:(NSInteger)index;

- (NSUInteger)comboBoxCell:(NSComboBoxCell *)aComboBoxCell indexOfItemWithStringValue:(NSString *)string;
- (nullable NSString *)comboBoxCell:(NSComboBoxCell *)aComboBoxCell completedString:(NSString *)uncompletedString; 
@end

NS_ASSUME_NONNULL_END
                                                                                                                                                         NSControl.h                                                                                         0100644 0001750 0001750 00000016336 12567220725 033061  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSControl.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <AppKit/NSView.h>
#import <AppKit/NSText.h>
#import <AppKit/NSCell.h>

NS_ASSUME_NONNULL_BEGIN

@class NSCell, NSFont, NSTextView, NSNotification, NSAttributedString, NSFormatter, NSControlAuxiliary;

@interface NSControl : NSView
{
    /*All instance variables are private*/
    NSControlAuxiliary *_aux;
    id		_cell;
    struct __conFlags {
        unsigned int enabled:1;
        unsigned int ignoreMultiClick:1;
        unsigned int calcSize:1;
        unsigned int drawingAncestor:1;
        unsigned int ibReserved:1;
        unsigned int updateCellFocus:1;
        unsigned int allowsLogicalLayoutDirection:1;
        unsigned int asmlwidth:1;
        unsigned int hsmlwidth:1;
        unsigned int dontValidate:1;
        unsigned int reserved:22;
    } _conFlags;
}

@property (nullable, weak) id target; // Target is weak for zeroing-weak compatible objects in apps linked on 10.10 or later. Otherwise the behavior of this property is 'assign.
@property (nullable) SEL action;
@property NSInteger tag;
@property BOOL ignoresMultiClick;
@property (getter=isContinuous) BOOL continuous;
@property (getter=isEnabled) BOOL enabled;
@property BOOL refusesFirstResponder;
@property (getter=isHighlighted) BOOL highlighted NS_AVAILABLE_MAC(10_10);
@property NSControlSize controlSize NS_AVAILABLE_MAC(10_10);
@property (nullable, strong) __kindof NSFormatter *formatter;

@property (copy) NSString *stringValue;
@property (copy) NSAttributedString *attributedStringValue;
@property (nullable, copy) id  /* id<NSCopying> */ objectValue;
@property int intValue;
@property NSInteger integerValue;
@property float floatValue;
@property double doubleValue;


- (NSSize)sizeThatFits:(NSSize)size NS_AVAILABLE_MAC(10_10);
- (instancetype)initWithFrame:(NSRect)frameRect NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;
- (void)sizeToFit;
- (NSInteger)sendActionOn:(NSInteger)mask;

- (BOOL)sendAction:(SEL)theAction to:(nullable id)theTarget;
- (void)takeIntValueFrom:(nullable id)sender;
- (void)takeFloatValueFrom:(nullable id)sender;
- (void)takeDoubleValueFrom:(nullable id)sender;
- (void)takeStringValueFrom:(nullable id)sender;
- (void)takeObjectValueFrom:(nullable id)sender;
- (void)takeIntegerValueFrom:(nullable id)sender NS_AVAILABLE_MAC(10_5);

- (void)mouseDown:(NSEvent *)theEvent;

@end

@interface NSControl(NSKeyboardUI)
- (void)performClick:(nullable id)sender;
@end


/* The following category applies only to controls with apparent textual content of some sort (buttons with labels, textfields, etc.).
 */
@interface NSControl(NSControlTextMethods)

@property NSTextAlignment alignment;
@property (nullable, copy) NSFont *font;
@property NSLineBreakMode lineBreakMode NS_AVAILABLE_MAC(10_10);
@property BOOL usesSingleLineMode NS_AVAILABLE_MAC(10_10);

@property NSWritingDirection baseWritingDirection;

/* Gets and sets the ability for expansion tool tips to be shown or not. Expansion tooltips are automatically shown when the cell can not show the full content. This is controlled by the NSCell API expansionFrameWithFrame:inView: and is drawn by drawWithExpansionFrame:inView:. The default value is NO.
    This value is encoded along with the control. In general, it is recommended to turn this on for NSTextFields in a View Based NSTableView.
 */
@property BOOL allowsExpansionToolTips NS_AVAILABLE_MAC(10_8);

/*  Allows the control to return an expansion tool tip frame if contentFrame is too small for the entire contents in the view. When the mouse is hovered over the text in certain controls, the full contents will be shown in a special floating tool tip view. If the frame is not too small, return an empty rect, and no expansion tool tip view will be shown. By default, NSControl returns NSZeroRect, while some subclasses (such as NSTextField) will return the proper frame when required.
 */
- (NSRect)expansionFrameWithFrame:(NSRect)contentFrame NS_AVAILABLE_MAC(10_10);

/* Allows the control to perform custom expansion tool tip drawing. Note that the view may be different from the original view that the text appeared in.
 */
- (void)drawWithExpansionFrame:(NSRect)contentFrame inView:(NSView *)view NS_AVAILABLE_MAC(10_10);

@end


/* The following category applies only to controls with editable text, like NSTextField.
 */
@interface NSControl(NSControlEditableTextMethods)
- (nullable NSText *)currentEditor;
- (BOOL)abortEditing;
- (void)validateEditing;

- (void)editWithFrame:(NSRect)aRect editor:(NSText *)textObj delegate:(nullable id)anObject event:(NSEvent *)theEvent NS_AVAILABLE_MAC(10_10);
- (void)selectWithFrame:(NSRect)aRect editor:(NSText *)textObj delegate:(nullable id)anObject start:(NSInteger)selStart length:(NSInteger)selLength NS_AVAILABLE_MAC(10_10);
- (void)endEditing:(NSText *)textObj NS_AVAILABLE_MAC(10_10);
@end


@interface NSObject(NSControlSubclassNotifications)
- (void)controlTextDidBeginEditing:(NSNotification *)obj;
- (void)controlTextDidEndEditing:(NSNotification *)obj;
- (void)controlTextDidChange:(NSNotification *)obj;
@end


@protocol NSControlTextEditingDelegate <NSObject>
@optional

// These delegate and notification methods are sent from NSControl subclasses that allow text editing such as NSTextField and NSMatrix.  The classes that need to send these have delegates.  NSControl does not.
- (BOOL)control:(NSControl *)control textShouldBeginEditing:(NSText *)fieldEditor;
- (BOOL)control:(NSControl *)control textShouldEndEditing:(NSText *)fieldEditor;
- (BOOL)control:(NSControl *)control didFailToFormatString:(NSString *)string errorDescription:(nullable NSString *)error;
- (void)control:(NSControl *)control didFailToValidatePartialString:(NSString *)string errorDescription:(nullable NSString *)error;
- (BOOL)control:(NSControl *)control isValidObject:(id)obj;

- (BOOL)control:(NSControl *)control textView:(NSTextView *)textView doCommandBySelector:(SEL)commandSelector;
- (NSArray<NSString *> *)control:(NSControl *)control textView:(NSTextView *)textView completions:(NSArray<NSString *> *)words forPartialWordRange:(NSRange)charRange indexOfSelectedItem:(NSInteger *)index;
@end

                                                                    // userInfo keys:
APPKIT_EXTERN NSString * NSControlTextDidBeginEditingNotification;	//	@"NSFieldEditor"
APPKIT_EXTERN NSString * NSControlTextDidEndEditingNotification;	//	@"NSFieldEditor"
APPKIT_EXTERN NSString * NSControlTextDidChangeNotification;		//	@"NSFieldEditor"


@interface NSControl (NSDeprecated)

// Use formatters instead.  See -[NSControl formatter] and -[NSControl setFormatter:].
- (void)setFloatingPointFormat:(BOOL)autoRange left:(NSUInteger)leftDigits right:(NSUInteger)rightDigits NS_DEPRECATED_MAC(10_0, 10_0);

+ (void)setCellClass:(nullable Class)factoryId;
+ (nullable Class)cellClass;

@property (nullable, strong) __kindof NSCell *cell;

- (nullable __kindof NSCell *)selectedCell;
- (NSInteger)selectedTag;

- (void)setNeedsDisplay;    // Use setNeedsDisplay:YES instead.
- (void)calcSize;

- (void)updateCell:(NSCell *)aCell;
- (void)updateCellInside:(NSCell *)aCell;
- (void)drawCellInside:(NSCell *)aCell;
- (void)drawCell:(NSCell *)aCell;
- (void)selectCell:(NSCell *)aCell;

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                  NSController.h                                                                                      0100644 0001750 0001750 00000003215 12567220725 033554  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSController.h
	Application Kit
	Copyright (c) 2002-2015, Apple Inc.
	All rights reserved.
 */

#import <AppKit/NSKeyValueBinding.h>
#import <CoreFoundation/CoreFoundation.h>


NS_ASSUME_NONNULL_BEGIN

@class NSMutableArray, NSMutableDictionary, NSMutableSet;

@interface NSController : NSObject <NSCoding> {
@private
#if !__LP64__
    void *_reserved;
    void *_reserved2;
#endif
    int _specialPurposeType;
    id _bindingAdaptor;
    NSMutableArray *_editors;
    NSMutableArray *_declaredKeys;
    NSMutableDictionary *_dependentKeyToModelKeyTable;
    NSMutableDictionary *_modelKeyToDependentKeyTable;
    NSMutableArray *_modelKeysToRefreshEachTime;
    struct __bindingsControllerFlags {
        unsigned int _alwaysPresentsApplicationModalAlerts:1;
        unsigned int _refreshesAllModelKeys:1;
        unsigned int _multipleObservedModelObjects:1;
        unsigned int _isEditing:1;
        unsigned int _reservedController:28;
    } _bindingsControllerFlags;
#if !__LP64__
    NSMutableDictionary *_reservedOther;
#endif
@protected    // all instance variables are private
    id _modelObservingTracker;
    id _expectedObservingInfo;
    id _singleValueAccessor;
}

- (instancetype)init NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;

- (void)objectDidBeginEditing:(id)editor;
- (void)objectDidEndEditing:(id)editor;
- (void)discardEditing;
- (BOOL)commitEditing;
- (void)commitEditingWithDelegate:(nullable id)delegate didCommitSelector:(nullable SEL)didCommitSelector contextInfo:(nullable void *)contextInfo;
@property (getter=isEditing, readonly) BOOL editing;

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                                                   NSCursor.h                                                                                          0100644 0001750 0001750 00000005776 12567220725 032724  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSCursor.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSGeometry.h>

NS_ASSUME_NONNULL_BEGIN

@class NSColor, NSEvent, NSImage;

#define NSAppKitVersionNumberWithCursorSizeSupport 682.0

@interface NSCursor : NSObject <NSCoding> {
    /*All instance variables are private*/
    NSPoint _hotSpot;
    struct _cursorFlags {
	unsigned int onMouseExited:1;
	unsigned int onMouseEntered:1;
        unsigned int cursorType:8;
	unsigned int :22;
    } _flags;
    id _image;
}

/* Returns the application's current cursor. This is not necessarily the cursor that is currently being displayed on the system. If you need the currently displayed cursor, use currentSystemCursor.
*/
+ (NSCursor *)currentCursor;

/* Returns an NSCursor whose image and hot spot match those of the cursor that is currently being displayed on the system, regardless of which application set that cursor. For example, this allows an inactive application to examine the image and hot spot of a cursor set by the active application. This API doesn't care whether the cursor is hidden; it will return an NSCursor whose image matches the cursor you would see if it were visible.
 
 Only the cursor image and hot spot are replicated in the returned NSCursor. Other properties (such as isSetOnMouseExited and isSetOnMouseEntered) will not necessarily be accurate.
 
 This method returns nil if the currently displayed cursor could not be fetched.
 */
+ (nullable NSCursor *)currentSystemCursor NS_AVAILABLE_MAC(10_6);

+ (NSCursor *)arrowCursor;
+ (NSCursor *)IBeamCursor;
+ (NSCursor *)pointingHandCursor;
+ (NSCursor *)closedHandCursor;
+ (NSCursor *)openHandCursor;
+ (NSCursor *)resizeLeftCursor;
+ (NSCursor *)resizeRightCursor;
+ (NSCursor *)resizeLeftRightCursor;
+ (NSCursor *)resizeUpCursor;
+ (NSCursor *)resizeDownCursor;
+ (NSCursor *)resizeUpDownCursor;
+ (NSCursor *)crosshairCursor;
+ (NSCursor *)disappearingItemCursor;
+ (NSCursor *)operationNotAllowedCursor NS_AVAILABLE_MAC(10_5);
+ (NSCursor *)dragLinkCursor NS_AVAILABLE_MAC(10_6);
+ (NSCursor *)dragCopyCursor NS_AVAILABLE_MAC(10_6);
+ (NSCursor *)contextualMenuCursor NS_AVAILABLE_MAC(10_6);
+ (NSCursor *)IBeamCursorForVerticalLayout NS_AVAILABLE_MAC(10_7);

- (instancetype)initWithImage:(NSImage *)newImage hotSpot:(NSPoint)aPoint;
- (instancetype)initWithImage:(NSImage *)newImage	foregroundColorHint:(nullable NSColor *)fg backgroundColorHint:(nullable NSColor *)bg hotSpot:(NSPoint)hotSpot;

+ (void)hide;
+ (void)unhide;
+ (void)setHiddenUntilMouseMoves:(BOOL)flag;
+ (void)pop;

@property (readonly, strong) NSImage *image;
@property (readonly) NSPoint hotSpot;
- (void)push;
- (void)pop;
- (void)set;
- (void)setOnMouseExited:(BOOL)flag;
- (void)setOnMouseEntered:(BOOL)flag;
@property (getter=isSetOnMouseExited, readonly) BOOL setOnMouseExited;
@property (getter=isSetOnMouseEntered, readonly) BOOL setOnMouseEntered;
- (void)mouseEntered:(NSEvent *)theEvent;
- (void)mouseExited:(NSEvent *)theEvent;

@end

NS_ASSUME_NONNULL_END
  NSCustomImageRep.h                                                                                  0100644 0001750 0001750 00000002026 12567220725 034314  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSCustomImageRep.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSImageRep.h>

NS_ASSUME_NONNULL_BEGIN

@interface NSCustomImageRep : NSImageRep {
    /*All instance variables are private*/
    SEL _drawMethod;
    id _drawObject;
    unsigned int _reserved;
}
// Note that the block passed to the below method may be invoked whenever and on whatever thread the image itself is drawn on. Care should be taken to ensure that all state accessed within the drawingHandler block is done so in a thread safe manner.
- (instancetype)initWithSize:(NSSize)size flipped:(BOOL)drawingHandlerShouldBeCalledWithFlippedContext drawingHandler:(BOOL (^)(NSRect dstRect))drawingHandler NS_AVAILABLE_MAC(10_8);
@property (nullable, readonly, copy) BOOL (^drawingHandler)(NSRect) NS_AVAILABLE_MAC(10_8);

- (instancetype)initWithDrawSelector:(SEL)aMethod delegate:(id)anObject;
@property (nullable, readonly) SEL drawSelector;
@property (nullable, readonly, assign) id delegate;

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          NSDataAsset.h                                                                                       0100644 0001750 0001750 00000002435 12567220725 033305  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDataAsset.h
	Application Kit
	Copyright (c) 2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/* An NSDataAsset instance provides access to a data entry in an asset catalog such as Images.xcassets. Data entries and image entries in asset catalogs do not share the same namespace. For example, if an asset catalog contains an image entry named @"foo" but no data entry named @"foo", [[NSDataAsset alloc] initWithName:@"foo"] will return nil.
*/

NS_CLASS_AVAILABLE_MAC(10_11) @interface NSDataAsset : NSObject<NSCopying> {
    void *_namedData;
}

- (instancetype)init NS_UNAVAILABLE;

/// Equivalent to -initWithName:name bundle:[NSBundle mainBundle];
- (nullable instancetype)initWithName:(NSString *)name;
/// Create a data asset with the given name from the given bundle. Returns nil if the asset was not found.
- (nullable instancetype)initWithName:(NSString *)name bundle:(NSBundle *)bundle NS_DESIGNATED_INITIALIZER;

/// The name used to reference the data asset
@property (readonly, copy) NSString *name;
/// The data for this asset, as stored in the asset catalog
@property (readonly, copy) NSData *data;
/// The Uniform Type Identifier for this data object.
@property (readonly, copy) NSString *typeIdentifier;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                   NSDatePicker.h                                                                                      0100644 0001750 0001750 00000002431 12567220725 033443  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDatePicker.h
	Application Kit
	Copyright (c) 2004-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSControl.h>
#import <AppKit/NSDatePickerCell.h>


NS_ASSUME_NONNULL_BEGIN

@class NSCalendar, NSLocale, NSTimeZone;

@interface NSDatePicker : NSControl
{
}

#pragma mark *** Appearance Control ***

@property NSDatePickerStyle datePickerStyle;

@property (getter=isBezeled) BOOL bezeled;

@property (getter=isBordered) BOOL bordered;

@property BOOL drawsBackground;

@property (copy) NSColor *backgroundColor;

@property (copy) NSColor *textColor;

#pragma mark *** Range Mode Control ***

@property NSDatePickerMode datePickerMode;

#pragma mark *** Date Presentation Control ***

@property NSDatePickerElementFlags datePickerElements;

@property (nullable, copy) NSCalendar *calendar;

@property (nullable, copy) NSLocale *locale;

@property (nullable, copy) NSTimeZone *timeZone;

#pragma mark *** Object Value Access ***

@property (copy) NSDate *dateValue;

@property NSTimeInterval timeInterval;

#pragma mark *** Constraints on Displayable/Selectable Range ***

@property (nullable, copy) NSDate *minDate;

@property (nullable, copy) NSDate *maxDate;

#pragma mark *** Delegate ***

@property (nullable, assign) id<NSDatePickerCellDelegate> delegate;

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                       NSDatePickerCell.h                                                                                  0100644 0001750 0001750 00000005675 12567220725 034260  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDatePickerCell.h
	Application Kit
	Copyright (c) 2004-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSDate.h>
#import <AppKit/NSActionCell.h>


NS_ASSUME_NONNULL_BEGIN

typedef NS_ENUM(NSUInteger, NSDatePickerStyle) {
    NSTextFieldAndStepperDatePickerStyle    = 0,
    NSClockAndCalendarDatePickerStyle       = 1,
    NSTextFieldDatePickerStyle              = 2
};

typedef NS_ENUM(NSUInteger, NSDatePickerMode) {
    NSSingleDateMode = 0,
    NSRangeDateMode = 1
};

typedef NS_OPTIONS(NSUInteger, NSDatePickerElementFlags) {
    /* Time Elements */
    NSHourMinuteDatePickerElementFlag       = 0x000c,
    NSHourMinuteSecondDatePickerElementFlag = 0x000e,
    NSTimeZoneDatePickerElementFlag	    = 0x0010,

    /* Date Elements */
    NSYearMonthDatePickerElementFlag	    = 0x00c0,
    NSYearMonthDayDatePickerElementFlag	    = 0x00e0,
    NSEraDatePickerElementFlag		    = 0x0100,
};

@class NSCalendar, NSLocale, NSTimeZone;
@protocol NSDatePickerCellDelegate;

@interface NSDatePickerCell : NSActionCell
{
@private
    NSTimeInterval _timeInterval;
    NSDate *_minDate;
    NSDate *_maxDate;
    struct __dateCellFlags {
        unsigned int elements:16;
        unsigned int controlStyle:3;
        unsigned int controlMode:2;
        unsigned int trackingHand:2;
        unsigned int reserved2:4;
        unsigned int drawsBackground:1;
        unsigned int digitsEntered:2;
        unsigned int forcesLeadingZeroes:1;
        unsigned int wrapsDateComponentArithmetic:1;
    } _dcFlags;
    id _delegate;
    NSCalendar *_calendar;
    NSLocale *_locale;
    NSTimeZone *_timeZone;
    NSColor *_backgroundColor;
    NSColor *_textColor;
    int _indexOfSelectedSubfield;
    int _reserved0;
    id _reserved1;
    id _reserved2;
    id _reserved3;
    id _reserved4;
}

#pragma mark *** Appearance Control ***

@property NSDatePickerStyle datePickerStyle;

@property BOOL drawsBackground;

@property (copy) NSColor *backgroundColor;

@property (copy) NSColor *textColor;

#pragma mark *** Range Mode Control ***

@property NSDatePickerMode datePickerMode;

#pragma mark *** Date Presentation Control ***

@property NSDatePickerElementFlags datePickerElements;

@property (nullable, copy) NSCalendar *calendar;

@property (nullable, copy) NSLocale *locale;

@property (nullable, copy) NSTimeZone *timeZone;

#pragma mark *** Object Value Access ***

@property (copy) NSDate *dateValue;

@property NSTimeInterval timeInterval;

#pragma mark *** Constraints on Displayable/Selectable Range ***

@property (nullable, copy) NSDate *minDate;

@property (nullable, copy) NSDate *maxDate;

#pragma mark *** Delegate ***

@property (nullable, assign) id<NSDatePickerCellDelegate> delegate;

@end

@protocol NSDatePickerCellDelegate <NSObject>
@optional
- (void)datePickerCell:(NSDatePickerCell *)aDatePickerCell validateProposedDateValue:(NSDate * __nonnull *__nonnull)proposedDateValue timeInterval:(nullable NSTimeInterval *)proposedTimeInterval;
@end

NS_ASSUME_NONNULL_END

                                                                   NSDictionaryController.h                                                                            0100644 0001750 0001750 00000007724 12567220726 035614  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDictionaryController.h
	Application Kit
	Copyright (c) 2002-2015, Apple Inc.
	All rights reserved.
 */

#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <AppKit/NSArrayController.h>

NS_ASSUME_NONNULL_BEGIN

// NSDictionaryController transforms a dictionary into an array of key-value pairs that is displayed like any other array in an NSArrayController. For each key-value pair, the controller distinguishes between the actual "key" and the "localizedKey" (a user readable version of the key - see setLocalizedKeyDictionary:/-localizedKeyDictionary). If no localizedKeyDictionary is specified, the localized keys default to the keys.
// In general, the dictionary controller's validation logic will prevent duplicate keys (but developers need to turn on "Validates Immediately" for the value bindings of the controls editing keys to run that validation). For insertions of new entries, the controller will enumerate the key by default (so if the initialKey is "key", the inserted keys will be "key", "key1", "key2", and so on). To customize that behavior, override the -newObject method.

// This key-value pair object allows controls to be bound, for example, to arrangedObjects.localizedKey, arrangedObjects.key, arrangedObjects.value, and arrangedObjects.explicitlyIncluded of the controller. Mutating a key-value-pair object immediately results in the corresponding change in the content dictionary of the controller.
NS_CLASS_AVAILABLE(10_11, NA)
@interface NSDictionaryControllerKeyValuePair : NSObject

- (instancetype)init NS_UNAVAILABLE; // NSDictionaryControllerKeyValuePair instances must be created via -newObject on the NSDictionaryController.

@property (nullable, copy) NSString *key;
@property (nullable, strong) id value;

@property (nullable, copy) NSString *localizedKey; // The localized key from the NSDictionaryControllers localizedKeyDictionary
@property (readonly, getter=isExplicitlyIncluded) BOOL explicitlyIncluded; // YES if the key is in the NSDictionaryControllers includedKeys, otherwise NO

@end

NS_CLASS_AVAILABLE(10_5, NA)
@interface NSDictionaryController : NSArrayController {
@private
    void *_reserved5;
    void *_reserved6;
    void *_reserved7;
	id _contentDictionary;
	NSString *_initialKey;
	id _initialValue;
	NSUInteger _minimumInsertionKeyIndex;
	NSString *_localizedKeyStringsFileName;
	NSDictionary *_localizedKeyForKeyDictionary;
	NSDictionary *_keyForLocalizedKeyDictionary;
	NSArray *_includedKeys;
	NSArray *_excludedKeys;
    struct __dictionaryControllerFlags {
        unsigned int _deepCopiesValues:1;
        unsigned int _suppressBuildingDictionary:1;
        unsigned int _reservedDictionaryController:30;
    } _dictionaryControllerFlags;
}

- (NSDictionaryControllerKeyValuePair *)newObject;    // overridden from the superclass to create a key-value pair to represent an entry in the content dictionary of the controller; method is invoked for insertions of new key-value pairs as well as transforming existing dictionary entries into key-value pairs for display

// Initial key and value are assigned to newly inserted entries. The initial key will be copied, the initial value will be retained when inserted into the dictionary (not copied), and must implement NSCoding if the dictionary controller gets archived.
@property (copy) NSString *initialKey;
@property (strong) id initialValue;

// Included keys are always represented by a key-value pair in the display array, whether present in the underlying dictionary or not. Excluded keys are always suppressed in the display array.
@property (copy) NSArray<NSString *> *includedKeys;
@property (copy) NSArray<NSString *> *excludedKeys;

// Localized key dictionary allows to specify a (typically localized) string for each key in the dictionary (the dictionary needs to contain the keys as keys and the localized keys as values).
@property (copy) NSDictionary<NSString *, NSString *> *localizedKeyDictionary;
@property (nullable, copy) NSString *localizedKeyTable;

@end

NS_ASSUME_NONNULL_END

                                            NSDockTile.h                                                                                        0100644 0001750 0001750 00000005107 12567220726 033132  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDockTile.h
	Application Kit
	Copyright (c) 2006-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSGeometry.h>
#import <Foundation/NSObject.h>
#import <Foundation/NSString.h>

#define NSAppKitVersionNumberWithDockTilePlugInSupport 1001.0


NS_ASSUME_NONNULL_BEGIN

@class NSView;

NS_CLASS_AVAILABLE(10_5, NA)
@interface NSDockTile : NSObject {
    @private;
    id _owner;
    void *_dockContextRef;
    NSView *_contentView;
    NSView *_frameView;
    NSView *_backstopView;
    NSString *_badgeLabel;
    struct {
        unsigned int showsAppBadge:1;
        unsigned int reserved:31;
    } _dFlags;
    NSSize _dockTileSize;
    id _miniViewController;
    id reserved[4];
}

/* get the size of the dock tile, in screen coordinates
*/
@property (readonly) NSSize size;

/* set the content view to view.  view should be height and width resizable.  In order to initiate drawing in view, you must call -[NSDockTile display]. 
*/
@property (nullable, strong) NSView *contentView;

/* cause the dock tile to be redrawn.  The contentView and any subviews will be sent drawRect: messages.
*/
- (void)display;

/* setShowsApplicationBadge: sets whether or not the dock tile should be badged with the application icon.  Default is YES for NSWindow dock tiles, NO for the NSApplication dock tile.
*/
@property BOOL showsApplicationBadge;

/* Badge the dock icon with a localized string.  The badge appearance is system defined.  This is often used to show an unread count in the application dock icon.
*/
@property (nullable, copy) NSString *badgeLabel;

/* -owner will return NSApp for the application dock tile, or the NSWindow for a mini window dock tile.
*/
@property (readonly, assign) id owner;

@end



@class NSMenu;

/* An application may customize its dock tile when not running via a plugin whose principal class implements the NSDockTilePlugIn protocol.  The name of the plugin is indicated by a NSDockTilePlugIn key in the application's Info.plist file.  The plugin is loaded in a system process at login time or when the application tile is added to the Dock.  When the plugin is loaded, the principal class' implementation of -setDockTile: is invoked.  If the principal class implements -dockMenu, -dockMenu is invoked whenever the user causes the application's dock menu to be shown.  When the dock tile is no longer valid (eg. the application has been removed from the dock, -setDockTile: is invoked with a nil NSDockTile.
*/
@protocol NSDockTilePlugIn <NSObject>

@required
- (void)setDockTile:(nullable NSDockTile*)dockTile;

@optional
- (nullable NSMenu*)dockMenu;
@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                                                                                                                                                         NSDocument.h                                                                                        0100644 0001750 0001750 00000315234 12567220725 033216  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDocument.h
	Application Kit
	Copyright (c) 1997-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSNibDeclarations.h>
#import <AppKit/NSUserInterfaceValidation.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSFilePresenter.h>

NS_ASSUME_NONNULL_BEGIN

@class NSData, NSDate, NSError, NSFileWrapper, NSMenuItem, NSPageLayout, NSPrintInfo, NSPrintOperation, NSSavePanel, NSUndoManager, NSURL, NSView, NSWindow, NSWindowController;

typedef NS_ENUM(NSUInteger, NSDocumentChangeType) {

/* The value to pass to -updateChangeCount: to indicate that a single change has been done. For example, NSDocument's built-in undo support uses this whenever a document receives an NSUndoManagerWillCloseUndoGroupNotification from its own undo manager.
*/
    NSChangeDone = 0,

/* The value to pass to indicate that a single change has been undone. For example, NSDocument's built-in undo support uses this whenever a document receives an NSUndoManagerDidUndoChangeNotification from its own undo manager.
*/
    NSChangeUndone = 1,

/* The value to pass to indicate that a single change has been redone. For example, NSDocument's built-in undo support uses this whenever a document receives an NSUndoManagerDidRedoChangeNotification from its own undo manager.
*/
    NSChangeRedone NS_ENUM_AVAILABLE_MAC(10_5) = 5,

/* The value to pass to indicate that the document has been synchronized with its file or file package. For example, both -revertToContentsOfURL:ofType:error: and -saveToURL:ofType:forSaveOperation:completionHandler: may use this when they invoke -updateChangeCount:.
*/
    NSChangeCleared = 2,

/* The value to pass to indicate that the document has been initialized with the contents of a file or file package other than the one whose location would be returned by -fileURL, and therefore can't possibly be synchronized with its persistent representation. For example, -initForURL:withContentsOfURL:ofType:error: uses this when the two passed-in URLs are not equal to indicate that an autosaved document is being reopened.
*/
    NSChangeReadOtherContents = 3,

/* The value to pass to indicate that the document's contents have been autosaved. For example, -saveToURL:ofType:forSaveOperation:completionHandler: may use this when it invokes -updateChangeCount:.
*/
    NSChangeAutosaved = 4,
    
/* Use this mask to indicate that a discardable change has been done. Discardable changes cause the document to be edited. In a locked document, for example, discardable changes may be thrown away instead of prompting the user to save them. Bitwise-or this value with the appropriate kind of change, NSChangeDone, NSChangeUndone, or NSChangeRedone. For example, a discardable change is "NSChangeDone | NSChangeDiscardable".
*/
    NSChangeDiscardable NS_ENUM_AVAILABLE_MAC(10_7) = 256
    
};

typedef NS_ENUM(NSUInteger, NSSaveOperationType) {

/* The overwriting of a document's file or file package with the document's current contents because the user explicitly commanded it.
*/
    NSSaveOperation = 0,

/* The writing of a document's current contents to a new file or file package, and then making the just-written file or file package the document's current one.
*/
    NSSaveAsOperation = 1,

/* The writing of a document's current contents to a new file or file package without changing the document's current one.
*/
    NSSaveToOperation = 2,

/* The overwriting of a document's file or file package with the document's current contents even though the user has not explicitly commanded it.
*/
    NSAutosaveInPlaceOperation NS_ENUM_AVAILABLE_MAC(10_7) = 4,

/* The writing of a document's current contents to a file or file package that is separate from the document's current one, without changing the document's current one. For an NSDocument subclass that overrides Mac OS 10.7's +autosavesInPlaces to return YES this is only used during autosaving of documents that have never been saved and therefore do not yet have a document file that can be overwritten during autosaving.
*/
    NSAutosaveElsewhereOperation NS_ENUM_AVAILABLE_MAC(10_7) = 3,
    
/* The writing of a document's current contents to new file or file package even though the user has not explicitly commanded it, and then making the just-written file or file package the document's current one.
*/
    NSAutosaveAsOperation NS_ENUM_AVAILABLE_MAC(10_8) = 5,
    
/* An old name for NSAutosaveElsewhereOperation that was deprecated in Mac OS 10.7.
*/
    NSAutosaveOperation NS_ENUM_DEPRECATED_MAC(10_4, 10_7, "Use NSAutosaveElsewhereOperation instead")= 3
    
};

@interface NSDocument : NSObject<NSFilePresenter, NSUserInterfaceValidations> {
    @private
    NSWindow *_window;
    id _windowControllers;
    NSURL *_fileURL;
    NSString *_fileType;
    NSPrintInfo *_printInfo;
    long _documentReserved;
    NSView *savePanelAccessory;
    id _displayName;
    id _privateData;
    NSUndoManager *_undoManager;
    struct __docFlags {
	unsigned int inClose:1;
	unsigned int hasUndoManager:1;
	unsigned int unused:1;
	unsigned int reconciledToFileName:1;
	unsigned int checkingDisplayName:1;
	unsigned int hasInvalidRestorableState:1;
	unsigned int hasEverHadInvalidRestorableState:1;
	unsigned int RESERVED:25;
    } _docFlags;
    NSString *_savePanelSaveType;
}

#pragma mark *** Initialization ***

/* The designated initializer. It is invoked by each of NSDocument's other initialization methods.

You can override this method to perform initialization that must be done both when creating new empty documents and when opening existing documents. Your override must invoke super to initialize private NSDocument instance variables. It must never return nil. If an error can occur during object initialization, check for the error in an override of -initWithType:error:, -initWithContentsOfURL:ofType:error:, or -initForURL:withContentsOfURL:ofType:error:, because those methods can return NSErrors.
*/
- (instancetype)init NS_DESIGNATED_INITIALIZER;

#pragma mark *** Creation ***

/* Initialize a new empty document of a specified type, and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the document could not be initialized. The default implementation of this method just invokes [self init] and [self setFileType:typeName].

You can override this method to perform initialization that must be done when creating new documents but should not be done when opening existing documents. Your override should typically invoke super, or at least it must invoke -init, NSDocument's designated initializer, to initialize NSDocument's private instance variables.
*/
- (nullable instancetype)initWithType:(NSString *)typeName error:(NSError **)outError;

#pragma mark *** Opening ***

/* Return whether instances of the receiving class can concurrently read documents of the specified type. The default implementation of this method returns NO. You can override it to return YES to enable concurrent opening of documents but you must make sure your document reading code can be safely executed concurrently, in non-main threads.
*/
+ (BOOL)canConcurrentlyReadDocumentsOfType:(NSString *)typeName NS_AVAILABLE_MAC(10_6);

/* Initialize a document located by a URL, of a specified type, and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the document could not be initialized. The default implementation of this method invokes [self init], [self readFromURL:url ofType:typeName error:outError], [self setFileURL:url], [self setFileType:typeName], and [self setFileModificationDate:theModificationDate].

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self initWithContentsOfFile:url ofType:typeName] if -initWithContentsOfFile:ofType: is overridden and the URL uses the "file:" scheme. It still invokes [self setFileModificationDate:theModificationDate] in this situation.
*/
- (nullable instancetype)initWithContentsOfURL:(NSURL *)url ofType:(NSString *)typeName error:(NSError **)outError;

#pragma mark *** Reopening after Autosaving ***

/* Initialize a document located by a URL, of a specified type, but by reading the contents for the document from another URL, and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the document could not be initialized. The default implementation of this method invokes [self readFromURL:contentsURL ofType:typeName error:outError], [self setFileURL:urlOrNil], [self setAutosavedContentsFileURL:contentsURL], [self setFileType:typeName], and [self setFileModificationDate:theModificationDate]. It also invokes [self updateChangeCount:NSChangeReadOtherContents] if the two URLs aren't identical, so that -isDocumentEdited will always return YES until the user saves or reverts the document.

To ease the adoption of the autosaving feature introduced in Mac OS 10.4, the default implementation of this method invokes [self initWithContentsOfFile:[contentsURL path] ofType:typeName] if -initWithContentsOfFile:ofType: is overridden and the URL uses the "file:" scheme. It still invokes [self setFileModificationDate:theModificationDate] and [self updateChangeCount:NSChangeReadOtherContents] in this situation. It still also invokes [self setFileURL:urlOrNil], to overwrite the incorrect invocation of -setFileName: that the override of -initWithContentsOfFile:ofType: likely did.

urlOrNil will be nil if the initializing is being done as part of the reopening of an autosaved document when the autosaved document had never been saved in the first place.
*/
- (nullable instancetype)initForURL:(nullable NSURL *)urlOrNil withContentsOfURL:(NSURL *)contentsURL ofType:(NSString *)typeName error:(NSError **)outError;

#pragma mark *** Attributes Applicable to Every Kind of Document ***

/* These should all be set at initialization time, but not as part of reading the document, and during NSSaveOperations, NSSaveAsOperations, NSAutosaveInPlaceOperations, and NSAutosaveAsOperations, but not as part of writing the document. Specifically, there should be no need to set these from within an override of a -read... or -write... method.
*/

/* The name of the document's format. The set method isn't for _changing_ the document's format, it's just for initially recording the document's format during opening or saving.
*/
@property (nullable, copy) NSString *fileType;

/* The location of the document's on-disk representation. The set method doesn't actually rename the document, it's just for recording the document's location during initial opening or saving. The default implementation of -setFileURL: just records the URL so that the default implementation of -fileURL can return it. The default implementation of -fileURL returns whatever was stored by a previous invocation of the default implementation of -setFileURL:.

Starting in Mac OS 10.7 the default implementations of these methods are thread safe enough that -setFileURL: being invoked on the main thread while -fileURL is being invoked on a different thread won't cause a crash. If you override one of these methods you must maintain that thread safety because AppKit itself may invoke -fileURL on a non-main thread. (It's still not a good idea to invoke -setFileURL: on a non-main thread though.)

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of -setFileURL: instead invokes [self setFileName:[url path]] if -setFileName: is overridden and the URL is nil or uses the "file:" scheme. Likewise, the default implementation of -fileURL instead invokes -[self fileName] and returns the result as a URL if -fileName is overridden.
*/
@property (nullable, copy) NSURL *fileURL;

/* The last known modification date of the document's on-disk representation.
*/
@property (nullable, copy) NSDate *fileModificationDate;

/* Whether the document is a draft that the user has not expressed an interest in keeping around. A save panel will be presented when the user closes a draft document. Only documents with non-nil values for [self fileURL] should be considered drafts.
*/
@property (getter=isDraft) BOOL draft NS_AVAILABLE_MAC(10_8);

#pragma mark *** UI and File Access Serialization ***

/* Given a block that will perform work that might result in the presentation of modal UI, wait for any work scheduled by previous invocations of this method to be completed, and then invoke the block. The block is passed another block, the activity completion handler, which must be invoked when the activity is complete. There are two kinds of waiting possible, synchronous and asynchronous. Which one is used is controlled by the waitSynchronously parameter. If the value for that parameter is YES then this method does not return until previous activities are complete and the passed-in block has been invoked. If it is NO then the passed-in block might not be invoked before this method has returned. It might instead be invoked later, on the main thread, after previous activities are complete.

This method's primary use is to wait for asynchronous saving, a new feature that was introduced in Mac OS 10.7. With asynchronous saving it is possible for the user to instigate a user interface action that might present modal UI, a sheet for example, when asynchronous saving is about to fail and present an error alert sheet of its own, which would not work. This method solves that problem. If your NSDocument subclass supports asynchronous saving you should invoke this method around the performance of any work that might cause the presentation of modal UI, regardless of whether that work is performed synchronously or asynchronously. Here is a list of NSDocument methods whose default implementations invoke this method because they might present sheets, either to ask the user what to do as they begin their work or because they may fail and present errors to user:
-revertDocumentToSaved:
-saveDocumentWithDelegate:didSaveSelector:contextInfo:
-runModalSavePanelForSaveOperation:delegate:didSaveSelector:contextInfo:
-saveToURL:ofType:forSaveOperation:delegate:didSaveSelector:contextInfo:
-canCloseDocumentWithDelegate:shouldCloseSelector:contextInfo:
-duplicateDocumentWithDelegate:didDuplicateSelector:contextInfo:
-runModalPageLayoutWithPrintInfo:delegate:didRunSelector:contextInfo:
-printDocumentWithSettings:showPrintPanel:delegate:didPrintSelector:contextInfo:
-runModalPrintOperation:delegate:didRunSelector:contextInfo:
More uses of this method may be added to NSDocument in the future.
 
This method must be invoked on the main thread. If it is passed YES for waitSynchronously it waits on the main thread, blocking further user interaction with the document. The purpose of blocking the main thread is so the user cannot continue to change the document while an activity is pending. This prevents for example the strange situation where the user chooses to revert the document, reverting does not happen immediately because asynchronous saving is still in progress, the user is able to continue to make changes to the document, and then those changes are immediately discarded when the asynchronous saving is complete and the document is reverted. All of the NSDocument methods listed above pass YES for waitSynchronously.

You pass NO for waitSynchronously when the work that is to be done is instigated by the user so indirectly that the work might begin when modal UI is already being presented. For example, here is another method whose default implementation invokes this method, this time passing NO for waitSynchronously:
-autosaveDocumentWithDelegate:didAutosaveSelector:contextInfo:
This method might present an error alert but it is typically invoked by a timer. If it passed YES for waitSynchronously, and the timer fired while the user was looking at a sheet presented by a previous activity, blocking of the main thread would prevent the handling of the user interface events necessary to dismiss that sheet and complete that previous activity. Deadlock would result.

Whether you make this method wait synchronously or asynchronously to do your work is separate from whether your work is done synchronously or asynchronously. For example, as mentioned above -saveToURL:ofType:forSaveOperation:delegate:didSaveSelector:contextInfo: passes YES for waitSynchronously when it uses this method, even though the majority of the work it does may be done asynchronously.

You should not invoke this method during the invocation of the block passed to -performSynchronousFileAccessUsingBlock:, mentioned down below, or in between the time -performAsynchronousFileAccessUsingBlock:, also mentioned down below, invokes the block passed to it and the time at which the corresponding file access completion handler is invoked. If you do then deadlock can result. In other words, you cannot begin a new activity as part of file access. You can on the other hand invoke -performSynchronousFileAccessUsingBlock: or -performAsynchronousFileAccessUsingBlock: as part of an activity.

Some asynchronous activities, like saving, need to do work on the main thread as they are completing. A deadlock would be inevitable if there were no way to interrupt this method's blocking of the main thread. See -continueAsynchronousWorkOnMainThreadUsingBlock: to find out how to interrupt this method's blocking of the main thread.
*/
- (void)performActivityWithSynchronousWaiting:(BOOL)waitSynchronously usingBlock:(void (^)(void (^activityCompletionHandler)(void)))block NS_AVAILABLE_MAC(10_7);

/* If a block that was passed to -performActivityWithSynchronousWaiting:usingBlock: is being invoked, invoke the passed-in block, having recorded state that makes inner invocations of -performActivityWithSynchronousWaiting:usingBlock: not wait. If this method is invoked outside of an invocation of a block passed to -performActivityWithSynchronousWaiting:usingBlock:, simply invoke the passed-in block.

This method is useful when code executed in a block passed to -performActivityWithSynchronousWaiting:usingBlock: may also invoke that method. For example, -saveDocumentWithDelegate:didSaveSelector:contextInfo:, which uses -performActivityWithSynchronousWaiting:usingBlock:, uses this around its invocation of -runModalSavePanelForSaveOperation:delegate:didSaveSelector: or -saveToURL:ofType:forSaveOperation:delegate:didSaveSelector:contextInfo: because both of those methods also use -performActivityWithSynchronousWaiting:usingBlock:. Without the use of this method that inner invocation of -performActivityWithSynchronousWaiting:usingBlock: would wait forever.
*/
- (void)continueActivityUsingBlock:(void (^)(void))block NS_AVAILABLE_MAC(10_7);

/* Invoke the block on the main thread. If the main thread is blocked by an invocation of -performActivityWithSynchronousWaiting:usingBlock: or -performSynchronousFileAccessUsingBlock:, interrupt that blocking to invoke the block, and then resume blocking when the invocation of the block has returned. Invocations of this method always return before the passed-in block is invoked.

You can invoke this method when work is being done on a non-main thread and part of the work must be continued on the main thread. For example, -saveToURL:ofType:forSaveOperation:completionHandler: uses this method when it has just completed the actual writing of the file during asynchronous saving and, to finish the saving operation, must invoke -updateChangeCountWithToken:forSaveOperation: and other methods on the main thread.

This method can of course be invoked on any thread.
*/
- (void)continueAsynchronousWorkOnMainThreadUsingBlock:(void (^)(void))block NS_AVAILABLE_MAC(10_7);

/* Given a block that will perform file access, wait for any file access scheduled by previous invocations of this method or -performAsynchronousFileAccessUsingBlock: to be complete, and then invoke the block. When the block invocation returns allow the next scheduled file access to to be performed, if any.

Like -performActivityWithSynchronousWaiting:usingBlock: this method's primary use is to wait for asynchronous saving, but in contrast with that method it is only for use to wait for the part of an asynchronous saving operation that actually touches the document's file or values in memory that are in some way relative to the document's file. See the comment for -performAsynchronousFileAccessUsingBlock: for an explanation of why this distinction is important.

In general you should use this method or -performAsynchronousFileAccessUsingBlock: around code that gets or sets values in memory that only make sense in the context of the document file's current state. For example, NSDocument itself consistently uses this mechanism around invocations of these methods:
- -fileType, -fileURL, -fileModificationDate, -autosavedContentsFileURL:, and -isDraft, because you can't reliably make decisions based on a file's location, type, modification date, or draft status when it might be being asynchronously moved, renamed, or changed at that moment.
- -setFileType:, -setFileURL:, -setFileModificationDate:, -setAutosavedContentsFileURL:, and -setDraft:, to make using this mechanism when invoking the previous list of methods meaningful.
- -isDocumentEdited and -hasUnautosavedChanges, because you can't reliably make decisions based on whether the document's contents in memory have been saved to a file when it might be being asynchronously saved at that moment.
- -updateChangeCountWithToken:forSaveOperation: and, sometimes, updateChangeCount:, to make using this mechanism when invoking -isDocumentEdited and -hasUnautosavedChanges meaningful.
- -backupFileURL, since it depends on -fileURL.
 */
- (void)performSynchronousFileAccessUsingBlock:(void (^)(void))block NS_AVAILABLE_MAC(10_7);

/* Do the same sort of thing as -performSynchronousFileAccessUsingBlock:, but without ever blocking the main thread, and perhaps not invoking the block until after the method invocation has returned, though still always on the same thread as the method invocation. The block is passed another block, the file access completion handler, which must be invoked when the file access is complete, though it can be invoked from any thread. This method is for use with file access that might begin on one thread but continue on another before it is complete. saveToURL:ofType:forSaveOperation:completionHandler: for for example uses this method instead of -performSynchronousFileAccessUsingBlock: because if it does asynchronous saving then there is no way for it to actually complete all of its file access before returning from the file access block.

The distinction between entire activities and the file accessing part of activities established by having both activity performing methods and file access performing methods is worthwhile because sometimes it is valuable to perform file access without any risk of waiting for the user to dimiss a modal panel. For example, NSDocument's implementation of -[NSFilePresenter relinquishPresentedItemToWriter:] uses -performAsynchronousFileAccessUsingBlock: to ensure that the uses of -performSynchronousFileAccessUsingBlock: described above wait while another process is moving, renaming, or changing the file. Using -performActivityWithSynchronousWaiting:usingBlock: instead would not be appropriate because that would introduce the possibility of the other process' writing being blocked until the user has dismissed a sheet that is being presented as part of a previously scheduled activity.
*/
- (void)performAsynchronousFileAccessUsingBlock:(void (^)(void (^fileAccessCompletionHandler)(void)))block NS_AVAILABLE_MAC(10_7);

#pragma mark *** Reverting ***

/* The action of the File menu's Revert to Saved item in a document-based application. The default implementation of this method presents a panel giving the user the opportunity to cancel the operation and, and if the user chooses to continue, makes sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has discarded its changes and then invokes [self revertToContentsOfURL:[self url] ofType:[self fileType] error:outError]. If that returns NO, it presents the error to the user in an document-modal alert panel.

If +autosavesInPlace returns YES and +preservesVersions returns NO, this method throws an exception.
*/
- (IBAction)revertDocumentToSaved:(nullable id)sender;

/* Discard all unsaved document modifications and replace the document's contents by reading a file or file package located by a URL, of a specified type, and return YES if successful. If not successful, return NO after setting *outError to an NSError that encapsulates the reason why the document could not be reverted. The default implementation of this method invokes [self readFromURL:url ofType:typeName error:outError], [self setFileModificationDate:theModificationDate], [self updateChangeCount:NSChangeCleared], and, if the document has an undo manager, [[self undoManager] removeAllActions]. It also deletes autosaved contents files when they have become obsolete.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self revertToSavedFromFile:[url path] ofType:typeName] if -revertToSavedFromFile:ofType: is overridden and the URL uses the "file:" scheme. It still invokes [self updateChangeCount:NSChangeCleared] and [[self undoManager] removeAllActions] in this situation (because the default implementation of -revertToSavedFromFile:ofType: does not; -revertDocumentToSaved: used to, but doesn't any longer).
*/
- (BOOL)revertToContentsOfURL:(NSURL *)url ofType:(NSString *)typeName error:(NSError **)outError;

#pragma mark *** Simple Reading and Writing ***

/* Typically you would override one of the next three methods... */

/* Set the contents of this document by reading from a file or file package located by a URL, of a specified type, and return YES if successful. If not successful, return NO after setting *outError to an NSError that encapsulates the reason why the document could not be read. The default implementation of this method just creates an NSFileWrapper and invokes [self readFromFileWrapper:theFileWrapper ofType:typeName error:outError].

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self readFromFile:[url path] ofType:typeName] if -readFromFile:ofType: is overridden and the URL uses the "file:" scheme.
*/
- (BOOL)readFromURL:(NSURL *)url ofType:(NSString *)typeName error:(NSError **)outError;

/* Set the contents of this document by reading from a file wrapper of a specified type, and return YES if successful. If not successful, return NO after setting *outError to an NSError that encapsulates the reason why the document could not be read. The default implementation of this method invokes [self readFromData:[fileWrapper regularFileContents] ofType:typeName error:outError].

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self loadFileWrapperRepresentation:fileWrapper ofType:typeName] if -loadFileWrapperRepresentation:ofType: is overridden.
*/
- (BOOL)readFromFileWrapper:(NSFileWrapper *)fileWrapper ofType:(NSString *)typeName error:(NSError **)outError;

/* Set the contents of this document by reading from data of a specified type, and return YES if successful. If not successful, return NO after setting *outError to an NSError that encapsulates the reason why the document could not be read. The default implementation of this method throws an exception because at least one of these three reading methods, or every method that may invoke -readFromURL:ofType:error: (!), must be overridden. 

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self loadDataRepresentation:data ofType:typeName] if -loadDataRepresentation:ofType: is overridden.
*/
- (BOOL)readFromData:(NSData *)data ofType:(NSString *)typeName error:(NSError **)outError;

/* Return YES if the document's entire file is loaded into memory, NO otherwise. The default implementation of this method returns YES. You can override this method to return NO if additional data may need to be read from the file. NSDocument may use this value to do things like prevent volume ejection or warn the user when a partially loaded file disappears from the file system.
 */
@property (getter=isEntireFileLoaded, readonly) BOOL entireFileLoaded NS_AVAILABLE_MAC(10_7);

/* ...and also one of these. */

/* Write the contents of this document to a file or file package located by a URL, formatted to a specified type, and return YES if successful. If not successful, return NO after setting *outError to an NSError that encapsulates the reason why the document could not be written. The default implementation of this method just invokes [self fileWrapperOfType:typeName error:outError], invokes [self unblockUserInteraction], and writes the returned file wrapper to disk.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self writeToFile:[url path] ofType:typeName] if -writeToFile:ofType: is overridden and the URL uses the "file:" scheme.
*/
- (BOOL)writeToURL:(NSURL *)url ofType:(NSString *)typeName error:(NSError **)outError;

/* Create and return a file wrapper that contains the contents of this document, formatted to a specified type, or return nil after setting *outError to an NSError that encapsulates the reason why the file wrapper could not be created. The default implementation of this method just invokes [self dataOfType:typeName], makes a file wrapper for that data, and returns the file wrapper.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self fileWrapperRepresentationOfType:typeName] if -fileWrapperRepresentationOfType: is overridden.
*/
- (nullable NSFileWrapper *)fileWrapperOfType:(NSString *)typeName error:(NSError **)outError;

/* Create and return a data object that contains the contents of this document, formatted to a specified type, or return nil after setting *outError to an NSError that encapsulates the reason why the data object could not be created. The default implementation of this method throws an exception because at least one of these three writing methods, or -writeToURL:ofType:saveOperation:originalContentsURL:error:, must be overridden.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self dataRepresentationOfType:typeName] if -dataRepresentationOfType: is overridden.
*/
- (nullable NSData *)dataOfType:(NSString *)typeName error:(NSError **)outError;

/* If -saveToURL:ofType:forSaveOperation:completionHandler: is writing on a non-main thread because -canAsynchronouslyWriteToURL:ofType:forSaveOperation: has returned YES, but is still blocking the main thread, unblock the main thread. Otherwise, do nothing. For example, the default implementation of -fileWrapperOfType:error: invokes this when it has created the NSFileWrapper to return. Assuming that the NSFileWrapper will not be mutated by subsequent user actions, it is effectively a "snapshot" of the document's contents, and once it is created it is safe to resume handling user events on the main thread, even though some of those user events might change the document's contents before the NSFileWrapper has been safely written. You can invoke this method to make asynchronous saving actually asynchronous if you've overridden -writeSafelyToURL:ofType:forSaveOperation:error:, -writeToURL:forSaveOperation:originalContentsURL:error:, or -writeToURL:ofType:error: in such a way that the invocation of this method done by -writeToURL:ofType:error:'s default implementation won't happen during writing.
*/
- (void)unblockUserInteraction NS_AVAILABLE_MAC(10_7);

/* Return YES if autosaving is being done right now but nothing bad would happen if it were to be cancelled, NO otherwise. For example, when periodic autosaving is being done just for crash protection, which doesn't really have to be done all of the time, this method returns YES. When autosaving is being done because the document is being closed this method returns NO.

You can use this notion of implicitly cancellable autosaving when implementing a "stop-copying-on-write" model so that your document class' writing code can invoke -unblockUserInteraction relatively quickly during writing on a non-main thread regardless of how much work must actually be done to make the sort of snapshot mentioned in the comment for -unblockUserInteraction. When this method returns YES your writing code can invoke -unblockUserInteraction after having merely recorded the fact that changes to the document model made by the user should first cancel the rest of the writing. Your code that makes changes to the document model then has to actually always do that cancellation first. (This may be a significant amount of work but hopefully less than implementing a copy-on-write model, which is another option for invoking -unblockUserInteraction as quickly as possible.) If your writing code is implicitly cancelled like that it should signal NSCocoaErrorDomain/NSUserCancelledError, the one kind of error that is never actually presented to the user.
*/
@property (readonly) BOOL autosavingIsImplicitlyCancellable NS_AVAILABLE_MAC(10_7);

#pragma mark *** Advanced Writing ***

/* Write the contents of the document to a file or file package located by a URL, formatted to a specified type, for a particular kind of save operation, and return YES if successful. If not successful, return NO after setting *outError to an NSError that encapsulates the reason why the document could not be written. The default implementation of this method:
    1) Either creates a temporary directory in which the document writing should be done, or renames the old on-disk version of the document, depending on what sort of save operation is being done, whether or not there's already a copy of the document on disk, and the capabilities of the file system to which writing is being done. The details of this are subject to change.
    2) Invokes -writeToURL:ofType:forSaveOperation:originalContentsURL:error:.
    3) Invokes -fileAttributesToWriteToURL:ofType:forSaveOperation:originalContentsURL:error: and writes the returned attributes, if any, to the file. Some attributes from the old on-disk version of the document may be copied at the same time, if applicable.
    4) Moves the just-written file to its final location, or deletes the old on-disk version of the document, and deletes any temporary directories, depending on the same factors listed for step 1.

For documents that return NO from +preservesVersions, the default implementation of this method invokes -keepBackupFile for NSSaveOperation to determine whether or not the old on-disk version of the document, if there was one, should be preserved after being renamed. If -keepBackupFile returns YES, or for documents that return YES from +preservesVersions, the default implementation of this method invokes [self backupFileURL] to determine the location for the old on-disk version of the document; if it returns nil, no backup file will be kept.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self writeWithBackupToFile:[url path] ofType:typeName saveOperation:aSaveOperation] if -writeWithBackupToFile:ofType:saveOperation: is overridden and the URL uses the "file:" scheme. The save operation used in this case will never be one of the autosaving ones; NSSaveToOperation will be used instead.

This method is responsible for doing document writing in a way that minimizes the danger of leaving the disk to which writing is being done in an inconsistent state in the event of an application crash, system crash, hardware failure, power outage, etc. Because it does several different things, and because the things are likely to change in future releases of Mac OS X, it's probably not a good idea to override this method without invoking super (the same was true of -writeWithBackupToFile:ofType:saveOperation:).
*/
- (BOOL)writeSafelyToURL:(NSURL *)url ofType:(NSString *)typeName forSaveOperation:(NSSaveOperationType)saveOperation error:(NSError **)outError;

/* Write the contents of the document to a file or file package located by a URL, formatted to a specified type, for a particular kind of save operation, and return YES if successful. If not successful, return NO after setting *outError to an NSError that encapsulates the reason why the document could not be written. The default implementation of this method merely invokes [self writeToURL:url ofType:typeName error:outError]. You can override this method instead of one of the methods in the "Simple Reading and Writing" section above if your document writing machinery needs access to the on-disk representation of the document version that is about to be overwritten. url will often not be the same value as [self fileURL]. Other times it will not be the same as the URL for the final save destination. Likewise, absoluteOriginalContentsURL will often not be the same value as [self fileURL], though it will be nil for documents that have never been saved. It will point to nothing if the document's on-disk representation has been deleted.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self writeToFile:[url path] ofType:typeName originalFile:[absoluteOriginalContentsURL path] saveOperation:aSaveOperation] if -writeToFile:ofType:originalFile:saveOperation: is overridden and both URLs use the "file:" scheme. The save operation used in this case will never be one of the autosaving ones; NSSaveToOperation will be used instead.
*/
- (BOOL)writeToURL:(NSURL *)url ofType:(NSString *)typeName forSaveOperation:(NSSaveOperationType)saveOperation originalContentsURL:(nullable NSURL *)absoluteOriginalContentsURL error:(NSError **)outError;

/* Given that a file is being saved, return the attributes that should be written to a file or file package located by a URL, formatted to a specified type, for a particular kind of save operation. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why attributes could not be returned. The set of valid file attributes is a subset of those understood by the NSFileManager class. The default implementation of this method returns an empty dictionary for an NSSaveOperation or NSAutosaveInPlaceOperation, or a dictionary with an appropriate NSFileExtensionHidden entry for any other kind of save operation. You can override this method to customize the attributes that are written to document files.

For backward binary comaptibility with Mac OS 10.5 and earlier the default implementation of this method instead returns a dictionary with NSFileHFSCreatorCode and NSFileHFSTypeCode entries that have a value of 0 for NSSaveOperation, in applications linked against Mac OS 10.5 or earlier.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self fileAttributesToWriteToFile:[url path] ofType:typeName saveOperation:aSaveOperation] if -fileAttributesToWriteToFile:ofType:saveOperation: is overridden and the URL uses the "file:" scheme. The save operation used in this case will never be one of the autosaving ones; NSSaveToOperation will be used instead.

The default implementation of -[NSDocument writeSafelyToURL:ofType:forSaveOperation:error:] automatically copies important attributes like file permissions, creation date, and Finder info from the old on-disk version of a document to the new one during an NSSaveOperation or NSAutosaveInPlaceOperation. This method is meant to be used just for attributes that need to be written for the first time, for NSSaveAsOperations, NSSaveToOperations, and NSAutosaveAsOperations. Actually, url and absoluteOriginalContentsURL are passed in just for completeness; NSDocument's default implementation for instance doesn't even need to use them.
*/
- (nullable NSDictionary<NSString *, id> *)fileAttributesToWriteToURL:(NSURL *)url ofType:(NSString *)typeName forSaveOperation:(NSSaveOperationType)saveOperation originalContentsURL:(nullable NSURL *)absoluteOriginalContentsURL error:(NSError **)outError;

/* Return YES if the old on-disk version of a document that is being overwritten should be preserved during an NSSaveOperation, NO otherwise. The default implementation of this method returns NO. For applications that return YES from +preservesVersions, this method has no effect.
*/
@property (readonly) BOOL keepBackupFile;

/* Return the URL that will be used when preserving a backup file during an NSSaveOperation or NSAutosaveInPlaceOperation, or nil if the backup file can't be created or isn't needed.

On Mac OS 10.8, document versions can be preserved using a backup file that is stored at the returned URL during safe-saving. Using this backup file for preserving versions is much more efficient because NSDocument is able to use NSFileVersionReplacingByMoving. NSDocument calls this method twice during saving: once before -writeSafelyToURL:ofType:forSaveOperation:error: to check whether NSFileVersionReplacingByMoving will be possible (and to preserve by copying if it's not), and once within that method to discover where to put the backup file.

Implementations of -writeSafelyToURL:ofType:forSaveOperation:error: must check the value returned by this method during NSSaveOperations and NSAutosaveInPlaceOperations and, if the URL is non-nil, move the previous contents of the file that would be overwritten to that location. (The default implementation of -writeSafelyToURL:ofType:forSaveOperation:error: does this.) Custom implementations of -writeSafelyToURL:ofType:forSaveOperation:error: can use -[NSFileManager replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:] with a backup item name of [[self backupFileURL] lastPathComponent] and the NSFileManagerItemReplacementWithoutDeletingBackupItem option to easily create the backup file. If your custom implementation is unable to keep the backup file, you must override this method and return nil to ensure that the document's file gets correctly preserved before it gets overwritten.

The default implementation of this method returns a non-nil value based off the value of [self fileURL] only if the document's file needs to be preserved prior to saving, or if +preservesVersions returns NO. Otherwise, it returns nil.
*/
@property (nullable, readonly, copy) NSURL *backupFileURL NS_AVAILABLE_MAC(10_8);

#pragma mark *** Saving ***

/* The action of the File menu's Save item in a document-based application. The default implementation of this method merely invokes [self saveDocumentWithDelegate:nil didSaveSelector:NULL contextInfo:NULL].
*/
- (IBAction)saveDocument:(nullable id)sender;

/* The action of the File menu's Save As... item in a document-based application. The default implementation of this method merely invokes [self runModalSavePanelForSaveOperation:NSSaveAsOperation delegate:nil didSaveSelector:NULL contextInfo:NULL].
*/
- (IBAction)saveDocumentAs:(nullable id)sender;

/* The action of the File menu's Export... item in a document-based application (actually, the menu item goes by different names in different applications; check the Human Interface Guidelines). The default implementation of this method merely invokes [self runModalSavePanelForSaveOperation:NSSaveToOperation delegate:nil didSaveSelector:NULL contextInfo:NULL].
*/
- (IBAction)saveDocumentTo:(nullable id)sender;

/* If a save operation can be performed without further user intervention (at the very least, neither -fileURL nor -fileType return nil), then save the document. Otherwise, present a save panel to the user and then save the document if the user OKs the panel. When saving is completed or has been cancelled, send the message selected by didSaveSelector to the delegate, with the contextInfo as the last argument. The method selected by didSaveSelector must have the same signature as:

    - (void)document:(NSDocument *)document didSave:(BOOL)didSaveSuccessfully contextInfo:(void *)contextInfo;

The default implementation of this method first makes sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has committed its changes, then invokes [self runModalSavePanelForSaveOperation:NSSaveAsOperation delegate:delegate didSaveSelector:didSaveSelector contextInfo:inContextInfo] right away if a save panel must be presented. Otherwise, it may present a panel asking the user to make a decision for any of the following situations:
    1) The document's file or file package was modified by something other than the current application since it was opened or most recently saved.
    2) The document's file or file package was moved or renamed since it was opened or most recently saved.
    3) The document's file or file package was deleted or trashed since it was opened or most recently saved.
The list of conditions for which NSDocument checks is subject to change. Regardless, the default implementation of this method always invokes either -runModalSavePanelForSaveOperation:delegate:didSaveSelector:contextInfo: or -saveToURL:ofType:forSaveOperation:delegate:didSaveSelector:contextInfo: unless the user cancels one of the panels it presents.
*/
- (void)saveDocumentWithDelegate:(nullable id)delegate didSaveSelector:(nullable SEL)didSaveSelector contextInfo:(nullable void *)contextInfo;

/* Present a save panel to the user, then try to save the document if the user OKs the panel. When saving is completed, regardless of success or failure, or has been cancelled, send the message selected by didSaveSelector to the delegate, with the contextInfo as the last argument. The method selected by didSaveSelector must have the same signature as:

    - (void)document:(NSDocument *)document didSave:(BOOL)didSaveSuccessfully contextInfo:(void *)contextInfo;

The default implementation of this method first makes sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has committed its changes, then creates a save panel, adds a standard "file format" accessory view if there is more than one file type for the user to choose from and [self shouldRunSavePanelWithAccessoryView] returns YES, sets various attributes of the panel, invokes [self prepareSavePanel:theSavePanel] to provide an opportunity for customization, then presents the panel. If the user OKs the panel -saveToURL:ofType:forSaveOperation:delegate:didSaveSelector:contextInfo: is invoked.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self saveToFile:nil saveOperation:saveOperation delegate:delegate didSaveSelector:contextInfo:] if -saveToFile:saveOperation:delegate:didSaveSelector:contextInfo: is overridden, even if the user cancels the panel (because that's what 10.3 did).
*/
- (void)runModalSavePanelForSaveOperation:(NSSaveOperationType)saveOperation delegate:(nullable id)delegate didSaveSelector:(nullable SEL)didSaveSelector contextInfo:(nullable void *)contextInfo;

/* Return YES if -runModalSavePanelForSaveOperation:delegate:didSaveSelector:contextInfo: should add NSDocument's standard file format accessory view to the save panel, NO otherwise. The default implementation of this method returns YES. You can override this method to prevent NSDocument from adding an accessory view to the save panel so that your application can add its own when -prepareSavePanel is invoked.
*/
@property (readonly) BOOL shouldRunSavePanelWithAccessoryView;

/* Given the save panel that -runModalSavePanelForSaveOperation:delegate:didSaveSelector:contextInfo: is about to present to the user, make any final changes before it is presented, and return YES for success. Return NO for failure, to cancel the save operation. The default implementation of this method just returns YES.
*/
- (BOOL)prepareSavePanel:(NSSavePanel *)savePanel;

/* Return YES if a save panel has been presented by this document and the user chose to hide the name extension of the file that was selected in that save panel, NO otherwise.
*/
@property (readonly) BOOL fileNameExtensionWasHiddenInLastRunSavePanel;

/* If a save panel has been presented by this document, and a choice of file type was presented in that panel, return the name of the file type that the user chose.
*/
@property (nullable, readonly, copy) NSString *fileTypeFromLastRunSavePanel;

/* Save the contents of the document to a file or file package located by a URL, formatted to a specified type, for a particular kind of save operation. When saving is completed, regardless of success or failure, send the message selected by didSaveSelector to the delegate, with the contextInfo as the last argument. The method selected by didSaveSelector must have the same signature as:

    - (void)document:(NSDocument *)document didSave:(BOOL)didSaveSuccessfully contextInfo:(void *)contextInfo;

The default implementation of this method first makes sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has committed its changes (except for autosave operations), then invokes [self saveToURL:url ofType:typeName forSaveOperation:saveOperation completionHandler:aCompletionHandler] and, if that completion handler is passed an NSError when it is invoked, presents the error to the user in a document-modal panel before messaging the delegate.
*/
- (void)saveToURL:(NSURL *)url ofType:(NSString *)typeName forSaveOperation:(NSSaveOperationType)saveOperation delegate:(nullable id)delegate didSaveSelector:(nullable SEL)didSaveSelector contextInfo:(nullable void *)contextInfo;

/* Save the contents of the document to a file or file package located by a URL, formatted to a specified type, for a particular kind of save operation, and invoke the passed-in completion handler at some point in the future, perhaps after the method invocation has returned. The completion handler must be invoked on the main thread. If successful, pass a nil error. If not successful, pass an NSError that encapsulates the reason why the document could not be saved.
 
 The default implementation of this method invokes [self canAsynchronouslyWriteToURL:url ofType:typeName forSaveOperation:saveOperation]. If writing can't be done concurrently, it invokes [self writeSafelyToURL:url ofType:typeName forSaveOperation:saveOperation error:&anError] on the main thread thread. If writing can be done concurrently, it invokes that method on a different thread, but blocking the main thread until something invokes -unblockUserInteraction. Either way, if -writeSafelyToURL:ofType:forSaveOperation:error: returns YES, it also invokes some combination of -setFileModificationDate:, -setFileType:, -setFileURL:, -updateChangeCount:, and -setAutosavedContentsFileURL:, as appropriate for the kind of save operation, on the main thread. It also updates information that -saveDocumentWithDelegate:didSaveSelector:contextInfo: uses to check for modification, renaming, moving, deleting, and trashing of open documents, and deletes autosaved contents files when they have become obsolete. You can override this method to do things that need to be done before or after any save operation but, because this method does several different things, and because the things are likely to change in future releases of Mac OS X, it's probably not a good idea to override this method without invoking super.

For backward binary compatibility with Mac OS 10.6 and earlier, the default implementation of this method instead invokes [self saveToURL:url ofType:typeName forSaveOperation:saveOperation error:&anError] if that method is overridden and this one is not, and passes any error to the completion handler.
*/
- (void)saveToURL:(NSURL *)url ofType:(NSString *)typeName forSaveOperation:(NSSaveOperationType)saveOperation completionHandler:(void (^)(NSError * __nullable errorOrNil))completionHandler NS_AVAILABLE_MAC(10_7);

/* Return whether the receiver can concurrently write to a file or file package located by a URL, formatted for a specific type, for a specific kind of save operation. The default implementation of this method returns NO. You are strongly encouraged to override it and make it return YES, after making sure your overrides of -write... methods can be safely invoked on a non-main thread, and making sure that -unblockUserInteraction will be invoked at some appropriate time during writing.
*/
- (BOOL)canAsynchronouslyWriteToURL:(NSURL *)url ofType:(NSString *)typeName forSaveOperation:(NSSaveOperationType)saveOperation NS_AVAILABLE_MAC(10_7);

#pragma mark *** Autosaving ***

/* Return YES if saving the user's changes to the document file is probably what they want, or NO after setting *outError to an NSError that encapsulates the reason why it might not be. The default implementation of this method checks for documents that have not been changed in a while ("a while" is subject to change) or are saved in folders where the user typically does not edit documents (the ~/Downloads folder, for example; also subject to change). When it senses one of those cases it returns NO with an NSError that has recovery options like "Duplicate," "Cancel", and "Unlock."

In an application that has adopted Mac OS 10.7's new document model by overriding +autosavesInPlace and making it return YES, you can override this method to customize the autosaving safety checking that NSDocument does by default. You can remove NSDocument's default checking by overriding this method and not invoking super. You can add to NSDocument's default checking by invoking super and then doing your own checking if [super checkAutosavingSafetyAndReturnError:] did not signal an error. For example, TextEdit overrides this method to ask the user what to do when opening a document file has been lossy and overwriting that file might therefore be lossy. Other combinations of your override invoking super are possible.

When autosaving in place is turned on an NSDocument may invoke this method when it receives notification from its NSUndoManager that the user changed the document, or undid or redid a change. (Or it may not. NSDocument does not invoke this method for scripted changes or after some kinds of reverting.) If an error is returned it presents the error to the user, allowing the user to choose a recovery option. If the error is recovered from then it repeats this until no error is signalled, to make sure that all checks have been done. This means that when you signal an error and the user's choice of recovery option indicates that they have seen and disregarded a safety concern you must record that fact, and not do that particular safety check again. Once all errors are recovered from NSDocument continues on by invoking -updateChangeCount:, which it has done in response to NSUndoManager notifications since Mac OS 10.0. If an error is not recovered from then NSDocument invokes -[NSUndoManager undo] or -[NSUndoManager redo] to roll back the change. So, some of the NSError recovery options you let the user select, like NSDocument's own "Duplicate and "Cancel," should indicate failed recovery and that will cause the document to be unchanged afterward.
*/
- (BOOL)checkAutosavingSafetyAndReturnError:(NSError **)outError NS_AVAILABLE_MAC(10_7);

/* Schedule periodic autosaving for the purpose of crash protection. The default implementation of this method generally checks to see if autosaving is turned on and if so, and if [self hasUnautosavedChanges] returns YES, schedules an NSTimer to invoke -autosaveDocumentWithDelegate:didAutosaveSelector:contextInfo: in the future. If [self hasUnautosavedChanges] returns NO it will unschedule any previously scheduled timer. It takes care not to cause -autosaveDocumentWithDelegate:didAutosaveSelector:contextInfo: to be invoked before a previous invocation caused by it has finished. The exact timings it uses are complicated and subject to change in future releases of Mac OS X. You can override this method to control when exactly periodic autosaving happens. It is invoked by -updateChangeCount: and -updateChangeCountWithToken:forSaveOperation:.
*/
- (void)scheduleAutosaving NS_AVAILABLE_MAC(10_7);

/* Return YES if the document has changes that have not been autosaved, NO otherwise, as determined by the history of previous invocations of -updateChangeCount:. The default implementation of this method returns NO immediately after invocation of -updateChangeCount:NSChangeCleared or -updateChangeCount:NSChangeAutosaved. It will then return YES if subsequent invocations of -updateChangeCount: have recorded a situation in which the document has changes that have not been autosaved. (-updateChangeCount:NSChangeReadOtherContents has no effect on what the default implementation of this method returns.)
*/
@property (readonly) BOOL hasUnautosavedChanges;

/* Autosave the document's contents if it needs autosaving, and then send the message selected by didAutosaveSelector to the delegate, with the contextInfo as the last argument. The method selected by didAutosaveSelector must have the same signature as:

    - (void)document:(NSDocument *)document didAutosave:(BOOL)didAutosaveSuccessfully contextInfo:(void *)contextInfo;

If any error occurs while autosaving, it must be reported to the user, typically in a document-modal alert panel, before the delegate is messaged with succeeded:NO.

The default implementation of this method simply invokes [self autosaveWithImplicitCancellability:YES completionHandler:aCompletionHandler] and then presents to the user any error that occurs.

This method is only invoked by AppKit itself as a result of -scheduleAutosaving being invoked. It is not invoked for any of the purposes of autosaving introduced by Mac OS 10.7's new document model that is triggered by +autosavesInPlace returning YES.
*/
- (void)autosaveDocumentWithDelegate:(nullable id)delegate didAutosaveSelector:(nullable SEL)didAutosaveSelector contextInfo:(nullable void *)contextInfo;

/* Autosave the document's contents at an appropriate location if it needs autosaving, and invoke the passed-in completion handler at some point in the future, perhaps after the method invocation has returned. The completion handler must be invoked on the main thread. If successful, pass a nil error. If not successful, pass an NSError that encapsulates the reason why the document could not be autosaved. autosavingIsImplicitlyCancellable becomes what -autosavingIsImplicitlyCancellable returns while the autosaving is happening.

The default implementation of this method invokes [self hasUnautosavedChanges] and, if that returns YES, figures out where the autosaved document contents should go and invokes [self saveToURL:autosavedDocumentContentsURL ofType:[self autosavingFileType] forSaveOperation:oneOfTheAutosaveOperations completionHandler:aCompletionHandler]. oneOfTheAutosaveOperations will be NSAutosaveAsOperation if the document has been changed with NSChangeDone and the current document should be turned into a draft, NSAutosaveInPlaceOperation if [[self class] autosavesInPlace] returns YES and [self fileURL] returns non-nil, or NSAutosaveElsewhereOperation otherwise. The check of [self fileURL] is because there's no such thing as autosaving "in place" when the document does not yet have a permanent place.
*/
- (void)autosaveWithImplicitCancellability:(BOOL)autosavingIsImplicitlyCancellable completionHandler:(void (^)(NSError * __nullable errorOrNil))completionHandler NS_AVAILABLE_MAC(10_7);

/* Return YES if the receiving subclass of NSDocument supports Mac OS 10.7 autosaving in place, NO otherwise. The default implementation of this method returns NO. You can override it and return YES to declare your NSDocument subclass' ability to do Mac OS 10.7 autosaving in place. You should not invoke this method to find out whether autosaving in place is actually being done at any particular moment. You should instead use the NSSaveOperationType parameter passed to your overrides of -save... and -write... methods.
 
AppKit invokes this method at a variety of times, and not always on the main thread. For example, -autosaveWithImplicitCancellability:completionHandler: invokes this as part of determining whether the autosaving will be an NSAutosaveInPlaceOperation instead of an NSAutosaveElsewhereOperation. For another example, -canCloseDocumentWithDelegate:shouldCloseSelector:contextInfo: and NSDocumentController's machinery for handling unsaved changes at application termination time both invoke this as part of determining whether alerts about unsaved changes should be presented to the user.
*/
+ (BOOL)autosavesInPlace NS_AVAILABLE_MAC(10_7);

/* Return YES if the receiving subclass of NSDocument supports Mac OS 10.7 version preservation, NO otherwise. The default implementation of this method returns [self autosavesInPlace]. You can override it and return NO to declare that NSDocument should not preserve old document versions.

Returning NO from this method will disable version browsing and -revertDocumentToSaved:, which rely on version preservation when autosaving in place. Returning YES from this method when +autosavesInPlace returns NO will result in undefined behavior.
 */
+ (BOOL)preservesVersions NS_AVAILABLE_MAC(10_7);

/* The action of the Browse Saved Versions menu item in a document-based application. The default implementation causes the document's main window, specified by [self windowForSheet], to enter the Versions browser.
*/
- (IBAction)browseDocumentVersions:(nullable id)sender NS_AVAILABLE_MAC(10_8);

/* Return YES if the receiving subclass of NSDocument supports Mac OS 10.8 autosaving of drafts, NO otherwise. The default implementation of this method returns YES for applications linked on or after Mac OS 10.8. You can override it and return YES to declare your NSDocument subclass' ability to do Mac OS 10.8 autosaving of drafts. You can also override it and return NO to opt out of this behavior after linking with 10.8. You should not invoke this method to find out whether autosaving of a draft will be done. Instances of subclasses that return YES from this method should be ready to properly handle save operations with NSAutosaveAsOperation.

AppKit invokes this method at a variety of times. For example, when -updateChangeCount is called with NSChagneDone (without NSChangeDiscardable), NSDocument will the next autosave to use NSAutosaveAsOperation and return the document into a draft.
*/
+ (BOOL)autosavesDrafts NS_AVAILABLE_MAC(10_8);

/* Return the document type that should be used for an autosave operation. The default implementation just returns [self fileType].
*/
@property (nullable, readonly, copy) NSString *autosavingFileType;

/* The location of the most recently autosaved document contents. The default implementation of -setAutosavedContentsFileURL: records the URL and notifies the shared document controller that this document should be autoreopened if the application is quit or crashes before the document is saved. The default implementation of -autosavedContentsFileURL just returns whatever was stored by a previous invocation of the default implementation of -setAutosavedContentsFileURL:.

Starting in Mac OS 10.7 the default implementations of these methods are thread safe enough that -setAutosavedContentsFileURL: being invoked on the main thread while -autosavedContentsFileURL is being invoked on a different thread won't cause a crash. If you override one of these methods you must maintain that thread safety because AppKit itself may invoke -autosavedContentsFileURL on a background thread. (It's still not a good idea to invoke -setAutosavedContentsFileURL: on a non-main thread though.)
*/
@property (nullable, copy) NSURL *autosavedContentsFileURL;

#pragma mark *** Closing ***

/* If there are changes that have not yet been saved to the document's file and saving cannot be done without asking the user first, present a panel to the user informing them that the document is modified and asking if it should be saved. If the user indicates that it should be, then try to save it. When saving is completed, regardless of success or failure, or has been rejected one way or another by the user, send the message selected by shouldCloseSelector to the delegate, with the contextInfo as the last argument. If the document is not modified then just send the mesage selected by shouldCloseSelector right away. The method selected by shouldCloseSelector must have the same signature as:

    - (void)document:(NSDocument *)document shouldClose:(BOOL)shouldClose contextInfo:(void *)contextInfo;

The default implementation of this method has two rather different behaviors. If [[self class] autosavesInPlace] returns YES and [self fileURL] returns non-nil then it simply invokes [self autosaveWithImplicitCancellability:NO completionHandler:aCompletionHandler] if [self hasUnautosavedChanges] returns YES after making sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has committed its changes. Otherwise it presents a panel giving the user the choice of canceling, discarding changes, or saving. In that case the shouldClose value passed to the delegate will be YES if the document was not modified in the first place, or the user chose to discard modifications, or chose to save and the saving was successful. NO will be passed if the user chose to cancel the operation or saving was unsuccessful. Because -saveDocumentWithDelegate:didSaveSelector:contextInfo: is used, an alert panel will be presented before the delegate is messaged if saving is attempted but does not succeed.
*/
- (void)canCloseDocumentWithDelegate:(id)delegate shouldCloseSelector:(nullable SEL)shouldCloseSelector contextInfo:(nullable void *)contextInfo;

/* Close the document, discarding any as-yet-unsaved modifications. The default implementation of this method first makes sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has discarded its changes, sends each of the document's window controllers a -close message, invokes [[NSDocumentController sharedDocumentController] removeDocument:self], and then invokes [NSFileCoordinator removeFilePresenter:self]. This is typically the method to use to close open documents (instead of just causing them to be deallocated by some other means). It's usually correct to use -canCloseDocumentWithDelegate:shouldCloseSelector:contextInfo: first to make sure that the user's changes have been saved if appropriate.
*/
- (void)close;

#pragma mark *** Duplicating ***

/* The action of the File menu's Duplicate item in a document-based application. The default implementation of this method merely invokes [self duplicateDocumentWithDelegate:nil didDuplicateSelector:NULL contextInfo:NULL].
*/
- (IBAction)duplicateDocument:(nullable id)sender NS_AVAILABLE_MAC(10_7);

/* Create a new document whose contents are the same as the receiver's and that doesn't yet have a fileURL. When duplicating is completed, regardless of success or failure, or has been rejected one way or another by the user, send the message selected by didDuplicateSelector to the delegate, with the contextInfo as the last argument. The method selected by didDuplicateSelector must have the same signature as:
 
 - (void)document:(NSDocument *)document didDuplicate:(BOOL)didDuplicate contextInfo:(void *)contextInfo;

The default implementation of this method first makes sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has committed its changes, then checks to see if there are recent changes that might have been inadvertent and, if so, presents a panel giving the user the choice of canceling, duplicating, or duplicating then also discarding recent changes. Unless the user cancels duplicating, or if no panel was presented, it then invokes -duplicateAndReturnError:. If the user chose duplicating and discarding it also discards recent changes after duplicating.
*/
- (void)duplicateDocumentWithDelegate:(nullable id)delegate didDuplicateSelector:(nullable SEL)didDuplicateSelector contextInfo:(nullable void *)contextInfo NS_AVAILABLE_MAC(10_7);

/* Create and return a new document whose contents are the same as the receiver and that doesn't yet have a fileURL, and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the document could not be duplicated.

The default implementation of this method first uses -writeSafelyToURL:ofType:forSaveOperation:error: to write the document's current contents to a file located in the same directory that is used for the autosaved contents of untitled documents and with the same sort of name, then invokes [[NSDocumentController sharedDocumentController] duplicateDocumentWithContentsOfURL:newContentsURL copying:NO displayName:aDisplayName error:outError]. The display name parameter is either [self displayName] if self has its own name, the display name of the original document if self is a duplicate, or nil if self is untitled.

You can override this method to customize what is done during document duplication, but if your override does not invoke -[NSDocumentController duplicateDocumentWithContentsOfURL:copying:displayName:error:] you must take care to do things that that method does, especially invoking -[NSDocumentController addDocument:] and +[NSFileCoordinator addFilePresenter:].
*/
- (nullable __kindof NSDocument *)duplicateAndReturnError:(NSError **)outError NS_AVAILABLE_MAC(10_7);

#pragma mark *** Renaming ***

/* The action of the Rename menu item in a document-based application. The default implementation of this method initiates a renaming session in the window returned by [self windowForSheet].
*/
- (IBAction)renameDocument:(nullable id)sender NS_AVAILABLE_MAC(10_8);

#pragma mark *** Moving ***

/* The action of the Move to iCloud menu item in a document-based application. The default implementation of this method presents an alert, asking the user to confirm the move, then invokes -moveToURL:completionHandler: with a URL in the application's default ubiquity container.
*/
- (IBAction)moveDocumentToUbiquityContainer:(nullable id)sender NS_AVAILABLE_MAC(10_8);

/* The action of the Move To menu item in a document-based application. The default implementation of this method merely invokes [self moveDocumentWithCompletionHandler:nil].
*/
- (IBAction)moveDocument:(nullable id)sender NS_AVAILABLE_MAC(10_8);

/* Present a move panel to the user, then try to save the document if the user OKs the panel. When moving is completed, regardless of success, failure, or cancellation, invoke the given block.

The default implementation of this method first makes sure that any editor registered using Cocoa Binding's NSEditorRegistration informal protocol has committed its changes if necessary. Then, if [self fileURL] is non-nil, it creates and presents a move panel. If the user OKs the panel, -moveToURL:completionHandler: is invoked. If a file already exists at the location the user chooses, the user will be asked to choose between replacing that file, renaming the current document, or canceling. If [self fileURL] is nil, then this method will instead invoke [self runModalSavePanelForSaveOperation:NSSaveAsOperation delegate:didSaveSelector:contextInfo:].
*/
- (void)moveDocumentWithCompletionHandler:(void (^ __nullable)(BOOL didMove))completionHandler NS_AVAILABLE_MAC(10_8);

/* Move the document's file to the given URL and invoke the passed-in completion handler at some point in the future, perhaps after the method invocation has returned. The completion handler must be invoked on the main thread. If successful, pass a nil error. If not successful, pass an NSError that encapsulates the reason why the document could not be moved.

The default implementation of this method does a coordinated move of the file at [self fileURL] to the given URL, replacing any file that may currently exist at that URL, and invokes -setFileURL: if the operation is successful. If [self fileURL] is nil, then this method will instead invoke [self saveToURL:url ofType:[self fileType] forSaveOperation:NSSaveAsOperation completionHandler:aCompletionHandler].
*/
- (void)moveToURL:(NSURL *)url completionHandler:(void (^ __nullable)(NSError * __nullable))completionHandler NS_AVAILABLE_MAC(10_8);

#pragma mark *** Locking ***

/* The actions of the Lock and Unlock menu items in a document-based application. The default implementations of these method invoke -lockDocumentWithCompletionHandler: and -unlockDocumentWithCompletionHandler: respectively.
*/
- (IBAction)lockDocument:(nullable id)sender NS_AVAILABLE_MAC(10_8);
- (IBAction)unlockDocument:(nullable id)sender NS_AVAILABLE_MAC(10_8);

/* Lock the document to prevent the user from making further modifications. When locking is completed, regardless of success or failure, invoke the given block.

The default implementation of this method first makes sure that any editor registered using Cocoa Binding's NSEditorRegistration informal protocol has committed its changes and immediately autosaves the document. If the autosave completes successfully or isn't necessary, this method invokes [self lockWithCompletionHandler:]. When locking succeeds, -isLocked will begin returning YES. Documents that return nil from [self fileURL] cannot be locked.
*/
- (void)lockDocumentWithCompletionHandler:(void (^ __nullable)(BOOL didLock))completionHandler NS_AVAILABLE_MAC(10_8);

/* Lock the file at [self fileURL] to prevent further modifications. When locking is completed regardless of success or failure, invoke the given block.

The default implementation of this method enables the "user immutable" flag on the file at [self fileURL].
*/
- (void)lockWithCompletionHandler:(void (^ __nullable)(NSError * __nullable))completionHandler NS_AVAILABLE_MAC(10_8);

/* Unlock the document and allow the user to make modifications to the document. When unlocking is completed, regardless of success or failure, invoke the given block.

The default implementation of this method invokes [self unlockWithCompletionHandler:]. This method also disables autosaving safety checking, meaning that -checkAutosavingSafetyAndReturnError: will no longer be invoked on this document. When unlocking succeeds, -isLocked will being returning NO.
*/
- (void)unlockDocumentWithCompletionHandler:(void (^ __nullable)(BOOL didUnlock))completionHandler NS_AVAILABLE_MAC(10_8);

/* Unlock the file at [self fileURL] to allow modifications. When unlocking is completed, regardless of success of failure, invoke the given block.

The default implementation of this method tries to clear the "user immutable" flag and add write permissions (if necessary) to the file at [self fileURL].
*/
- (void)unlockWithCompletionHandler:(void (^ __nullable)(NSError * __nullable))completionHandler NS_AVAILABLE_MAC(10_8);

/* Returns YES when it appears the file at [self fileURL] cannot be written to. The conditions that cause this to return YES are subject to change, but may include the lack of write permissions, the "user immutable" flag, a read-only parent directory or volume, a return value of NO from -checkAutosavingSafetyAndReturnError:. You should not override this method.
*/
@property (getter=isLocked, readonly) BOOL locked NS_AVAILABLE_MAC(10_8);

#pragma mark *** Printing ***

/* The action of the File menu's Page Setup... item in a document-based application. The default implementation of this method invokes [self printInfo], makes a copy of the print info object, and invokes [self runModalPageLayoutWithPrintInfo:printInfoCopy delegate:aPrivateDelegate didRunSelector:aSelectorForAPrivateMethod contextInfo:privateContextInfo]. If the user OKs the page layout panel, [self shouldChangePrintInfo:printInfoCopy] is invoked. If that returns YES, [self setPrintInfo:printInfoCopy] is invoked.
*/
- (IBAction)runPageLayout:(nullable id)sender;

/* Present a page layout panel to the user. When the page layout panel has been dismissed, regardless of whether the user cancelled or OK'ed it, send the message selected by didRunSelector to the delegate, with the contextInfo as the last argument. The method selected by didRunSelector must have the same signature as:

    - (void)document:(NSDocument *)document didRunPageLayoutAndUserAccepted:(BOOL)userAccepted contextInfo:(void *)contextInfo;

The default implementation of this method creates a page layout panel, invokes [self preparePageLayout:thePageLayoutPanel] to provide an opportunity for customization, then presents the panel.
*/
- (void)runModalPageLayoutWithPrintInfo:(NSPrintInfo *)printInfo delegate:(nullable id)delegate didRunSelector:(nullable SEL)didRunSelector contextInfo:(nullable void *)contextInfo;

/* Given the page layout panel that -runModalPageLayoutWithPrintInfo:delegate:didRunSelector:contextInfo: is about to present to the user, make any final changes before it is presented, and return YES for success. Return NO for failure, to cancel the presentation of the panel. The default implementation of this method just returns YES.
*/
- (BOOL)preparePageLayout:(NSPageLayout *)pageLayout;

/* Given a print info object that is the result of the user OK'ing the page layout panel presented by -runPageLayout:, return YES if the print info should be set in the document, NO otherwise.
*/
- (BOOL)shouldChangePrintInfo:(NSPrintInfo *)newPrintInfo;

/* The print info for the document. The default implementation of -setPrintInfo: records the change as an undoable change, if the document has an undo manager. If the document has no undo manager, it invokes [self updateChangeCount:NSChangeDone].
*/
@property (copy) NSPrintInfo *printInfo;

/* The action of the File menu's Print... item in a document-based application. The default implementation of this method merely invokes [self printDocumentWithSettings:[NSDictionary dictionary] showPrintPanel:YES delegate:nil didPrintSelector:NULL contextInfo:NULL].
*/
- (IBAction)printDocument:(nullable id)sender;

/* Print the document. If showing of the print panel is specified, present it first, and print only if the user OKs the panel. The NSPrintInfo attributes in the passed-in printSettings dictionary should be added to a copy of the document's print info, and the resulting print info should be used for the operation. When printing is completed or has been cancelled, send the message selected by didPrintSelector to the delegate, with the contextInfo as the last argument. The method selected by didPrintSelector must have the same signature as:

    - (void)document:(NSDocument *)document didPrint:(BOOL)didPrintSuccessfully contextInfo:(void *)contextInfo;

The default implementation of this method first makes sure that any editor registered using Cocoa Bindings' NSEditorRegistration informal protocol has committed its changes, then invokes [self printOperationWithSettings:printSettings error:&anError]. If nil is returned it presents the error to the user in a document-modal panel before messaging the delegate. Otherwise it invokes [thePrintOperation setShowsPrintPanel:showPrintPanel] then [self runModalPrintOperation:thePrintOperation delegate:delegate didRunSelector:didPrintSelector contextInfo:contextInfo].

Starting in OS X 10.6, if the printSettings dictionary has an NSPrintJobDisposition entry whose value is NSPrintSaveJob, while lacking an NSPrintJobSavingURL or NSPrintSavePath entry indicating where the PDF file should be written, then the default implementation of this method will present a save panel asking the user where the PDF file should be saved. Additionally, starting in OS X 10.9, the default implementation of this method will invoke -PDFPrintOperation instead of -printOperationWithSettings:error: in this scenario.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method invokes [self printShowingPrintPanel:showPrintPanel] if -printShowingPrintPanel: is overridden. When doing this it uses private functionality to arrange for 1) the print settings to take effect despite the fact that the override of -printShowingPrintPanel: can't possibly know about them, and 2) getting notified when the print operation has been completed, so it can message the delegate at the correct time. Correct messaging of the delegate is necessary for correct handling of the Print Apple event.
*/
- (void)printDocumentWithSettings:(NSDictionary<NSString *, id> *)printSettings showPrintPanel:(BOOL)showPrintPanel delegate:(nullable id)delegate didPrintSelector:(nullable SEL)didPrintSelector contextInfo:(nullable void *)contextInfo;

/* Create a print operation that can be run to print the document's current contents, and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the print operation could not be created. The NSPrintInfo attributes in the passed-in printSettings dictionary should be added to a copy of the document's print info, and the resulting print info should be used for the operation. The default implementation of this method does nothing. You must override it to enable printing in your application.
*/
- (nullable NSPrintOperation *)printOperationWithSettings:(NSDictionary<NSString *, id> *)printSettings error:(NSError **)outError;

/* Run a print operation, possibly with printing UI presented document-modally. When printing is completed, regardless of success or failure, or has been cancelled, send the message selected by didRunSelector to the delegate, with the contextInfo as the last argument. The method selected by didRunSelector must have the same signature as:

    - (void)document:(NSDocument *)document didRunPrintOperation:(BOOL)didPrintSuccessfully contextInfo:(void *)contextInfo;
*/
- (void)runModalPrintOperation:(NSPrintOperation *)printOperation delegate:(nullable id)delegate didRunSelector:(nullable SEL)didRunSelector contextInfo:(nullable void *)contextInfo;

#pragma mark *** PDF Creation ***

/* The action of the File menu's Export As PDF... item in a document-based application. The default implementation of this method merely invokes [self printDocumentWithSettings:@{ NSPrintJobDisposition : NSPrintSaveJob } showPrintPanel:NO delegate:nil didPrintSelector:NULL contextInfo:NULL].
 */
- (IBAction)saveDocumentToPDF:(nullable id)sender NS_AVAILABLE_MAC(10_9);

/* Create a print operation that can be run to create a PDF representation of the document's current contents, and return it if successful. You typically should not use [self printInfo] when creating this print operation, but you should instead maintain a separate NSPrintInfo instance specifically for creating PDFs. The default implementation of this method simply invokes [self printOperationWithSettings:@{ NSPrintJobDisposition : NSPrintSaveJob } error:NULL], but you are highly encouraged to override it if your document subclass supports creating PDF representations.
 */
@property (readonly, strong) NSPrintOperation *PDFPrintOperation NS_AVAILABLE_MAC(10_9);

#pragma mark *** Change Management ***

/* Return YES if the document has changes that have not been saved, NO otherwise, primarily determined by the history of previous invocations of -updateChangeCount:. The default implementation of this method returns NO immediately after invocation of -updateChangeCount:NSChangeCleared. It will then return YES if subsequent invocations of -updateChangeCount: have recorded a situation in which the document has changes that have not been saved. Also, it will always return YES after invocation of -updateChangeCount:NSChangeReadOtherContents, until the next invocation of -updateChangeCount:NSChangeCleared. (-updateChangeCount:NSChangeAutosaved has no effect on what the default implementation of this method returns.) Lastly, because NSDocument implements Cocoa Bindings' NSEditorRegistration informal protocol, the default implementation will return YES whenever there are registered key-value binding editors.
*/
@property (getter=isDocumentEdited, readonly) BOOL documentEdited;

/* Return YES if the document is in read-only "viewing mode". You may use this information to prevent certain kinds of user actions or changes when the user is viewing an old document version.
*/
@property (getter=isInViewingMode, readonly) BOOL inViewingMode NS_AVAILABLE_MAC(10_7);

/* Record the fact that a change affecting the values returned by -isDocumentEdited and -hasUnautosavedChanges has occurred. See the comments for NSDocumentChangeType for examples of when this method is invoked by NSDocument's own method implementations. Your application only needs to invoke this method explicitly if it is not taking advantage of NSDocument's built-in undo support. The default implementation of this method also sends all of the document's window controllers -setDocumentEdited: messages when appropriate.
*/
- (void)updateChangeCount:(NSDocumentChangeType)change;

/* Return an object that encapsulates the current record of document change at the beginning of a save operation, for passing to -updateChangeCountWithToken:forSaveOperation: at the end of the save operation. For example, -saveToURL:ofType:forSaveOperation:completionHandler: invokes this method, on the main thread, before it does any actual saving.
*/
- (id)changeCountTokenForSaveOperation:(NSSaveOperationType)saveOperation NS_AVAILABLE_MAC(10_7);

/* Record the fact that saving has succeeded and update the values returned by methods like -isDocumentEdited and -hasUnautosavedChanges. For example, -saveToURL:ofType:forSaveOperation:completionHandler: invokes this method, on the main thread, when it is done saving. The default implementation of this method also sends all of the document's window controllers -setDocumentEdited: messages when appropriate.

This was method was introduced with support for asynchronous saving in Mac OS 10.7. Because the goal of asynchronous saving is to let the user continue changing the document during save operations, the old mechanism of merely invoke [self updateChangeCount:NSChangeCleared] when saving has succeeded is no longer sufficient.
*/
- (void)updateChangeCountWithToken:(id)changeCountToken forSaveOperation:(NSSaveOperationType)saveOperation NS_AVAILABLE_MAC(10_7);

/* The document's undo manager. The default implementation of -setUndoManager:, in addition to recording the undo manager, registers the document as an observer of various NSUndoManager notifications so that -updateChangeCount: is invoked as undoable changes are made to the document. The default implementation of -undoManager creates an undo manager if the document does not already have one and -hasUndoManager would return YES.
*/
@property (nullable, strong) NSUndoManager *undoManager;

/* Whether or not the document has an undo manager. The default implementation of -setHasUndoManager: releases the document's current undo manager if it has one before the invocation but is not to have one afterward.
*/
@property BOOL hasUndoManager;

#pragma mark *** Error Presentation ***

/* Methods that are declared by NSResponder and also implemented by NSDocument, even though for historical reasons NSDocument is not a subclass of NSResponder. NSDocument's default implementations are equivalent to NSResponder's while treating the shared NSDocumentController as the "next responder" and forwarding error presentation messages to it, despite the fact that for historical reasons NSDocumentController is not a subclass of NSResponder either.

NSWindowController has overrides of -presentError:modalForWindow:delegate:didPresentSelector:contextInfo: and -presentError: that treat the window controller's document as the "next responder" and forward these messages to it, if the window controller has a document (some do, some don't).

The default implementations of several NSDocument methods invoke -presentError:modalForWindow:delegate:didPresentSelector:contextInfo:.

You can customize the presentation of errors on a per-NSDocument-subclass basis by overriding -willPresentError:. Your override should follow the advice given for overriding of -[NSResponder willPresentError:].
*/
- (void)presentError:(NSError *)error modalForWindow:(NSWindow *)window delegate:(nullable id)delegate didPresentSelector:(nullable SEL)didPresentSelector contextInfo:(nullable void *)contextInfo;
- (BOOL)presentError:(NSError *)error;
- (NSError *)willPresentError:(NSError *)error;

/* Given an NSError that has been returned by an NSDocument method, accommodate the fact that the NSError is not going to be presented to the user and the error is definitely not going to be recovered from. Some NSDocument methods, like those involved in writing, sometimes don't immediately delete temporary files if there is a chance that the error can be recovered from and the operation can continue. To make sure that cleanup is always done you should invoke this method with NSDocument errors that are not going to be passed to one of the presentError:... methods. For example, when NSDocument's implementation of -[NSFilePresenter savePresentedItemChangesWithCompletionHandler:] invokes this method when it invokes -autosaveWithImplicitCancellability:completionHandler: and the completion handler is passed an NSError, because it does not present the error to the user.
*/
- (void)willNotPresentError:(NSError *)error NS_AVAILABLE_MAC(10_7);

#pragma mark *** Windows and Window Controllers ***

/* Create the user interface for this document, but don't show it yet. The default implementation of this method invokes [self windowNibName], creates a new window controller using the resulting nib name (if it is not nil), specifying this document as the nib file's owner, and then invokes [self addWindowController:theNewWindowController] to attach it. You can override this method to use a custom subclass of NSWindowController or to create more than one window controller right away. NSDocumentController invokes this method when creating or opening new documents.
*/
- (void)makeWindowControllers;

/* Return the name of the nib to be used by -makeWindowControllers. The default implementation returns nil. You can override this method to return the name of a nib in your application's resources; the class of the file's owner in that nib must match the class of this object, and the window outlet of the file's owner should be connected to a window. Virtually every subclass of NSDocument has to override either -makeWindowControllers or -windowNibName.
*/
@property (nullable, readonly, copy) NSString *windowNibName;

/* Be notified that a window controller will or did load a nib with this document as the nib file's owner. The default implementations of these methods do nothing. You can override these methods to do additional setup during the creation of the document's user interface, especially when there's no other reason to create a custom subclass of NSWindowController, so you're not, and you're simply overriding -windowNibName instead of -makeWindowControllers.
*/
- (void)windowControllerWillLoadNib:(NSWindowController *)windowController;
- (void)windowControllerDidLoadNib:(NSWindowController *)windowController;

/* The setter for the "window" IB outlet of this class. It is invoked automatically during the loading of any nib for which this document is the file's owner, if the file's owner window outlet is connected in the nib. You should not invoke this method directly, and typically you would not override it either.
*/
- (void)setWindow:(nullable NSWindow *)window;

/* Add or remove a window controller from this document's list of attached window controllers, and set the document of the passed-in window controller. You cannot attach a window controller to more than one document at a time. The default implementation of -addWindowController: removes the passed-in window controller from the document to which it is attached, if it is already attached to one. It also ignores redundant invocations. The default implementations of both of these methods send -setDocument: messages to the passed-in window controller (with a nil argument, in the latter case). You wouldn't typically override either of these methods. You typically invoke -addWindowController: once or more from an override of -makeWindowControllers, if you override -makeWindowControllers, and can invoke it at other times in applications that present multiple windows per document to the user.
*/
- (void)addWindowController:(NSWindowController *)windowController;
- (void)removeWindowController:(NSWindowController *)windowController;

/* Present the user interface for this document. The default implementation of this method merely sends -showWindow: messages to each of the attached window controllers. You typically would not invoke or override this method. NSDocumentController invokes this method when creating or opening new documents.
*/
- (void)showWindows;

/* Return an array of all window controllers that have been added to this document with -addWindowController: but not yet removed with -removeWindowController:.
*/
@property (readonly, copy) NSArray<__kindof NSWindowController *> *windowControllers;

/* If the window controller is one whose closing results in the document being closed too, or there is only one window controller attached to the document, do the exact same thing that -canCloseDocumentWithDelegate:shouldCloseSelector:contextInfo: would do. Otherwise send the message selected by shouldCloseSelector to the delegate, with the contextInfo as the last argument, specifying that the window controller should be closed. The method selected by shouldCloseSelector must have the same signature as:

    - (void)document:(NSDocument *)document shouldClose:(BOOL)shouldClose contextInfo:(void *)contextInfo;

The default implementation of this method sends the window controller a -shouldCloseDocument message and, if the result is YES or the current count of window controllers is one, merely invokes [self canCloseDocumentWithDelegate:delegate shouldCloseSelector:shouldCloseSelector contextInfo:contextInfo]. Otherwise it messages the delegate as described above. You can override this method, but typically you would not invoke it. NSWindow invokes this method for any window that has a window controller and a document associated with it, before sending the window delegate any -windowShouldClose: message.
*/
- (void)shouldCloseWindowController:(NSWindowController *)windowController delegate:(nullable id)delegate shouldCloseSelector:(nullable SEL)shouldCloseSelector contextInfo:(nullable void *)contextInfo;

/* Set the name for this document that is fit for presentation to the user. If the value is nil then a name based on -defaultDraftName is used.
*/
- (void)setDisplayName:(nullable NSString *)displayNameOrNil NS_AVAILABLE_MAC(10_7);

/* Returns the name for this document that is fit for presentation to the user. You can override this method, but overriding -[NSWindowController windowTitleForDocumentDisplayName:] is usually better, because a document's display name is used in error alerts, alerts presented during document saving, the alert that's presented when the user attempts to close a document that has unsaved changes, and save panels (as the default value of the "Save As:" field). In those places the document file's actual name really is what should be used.
*/
@property (readonly, copy) NSString *displayName;

/* Return the default draft name for the receiver. The default implementation returns the "Untitled" string for the user's current locale.
 
 NSDocument invokes this in -displayName when the receiver hasn't yet been assigned one and also prior to autosaving with NSAutosaveAsOperation. NSDocument will append a number to this string if there is a already another document or file with the same name. Applications will typically return a name that describes the kind of document. For example, a spreadsheet application may return "Spreadsheet". Alternatively, a document created from a template may choose to return the name of that template, like "Rsum".
*/
- (NSString *)defaultDraftName NS_AVAILABLE_MAC(10_8);

/* Of the windows associated with this document, return the one most appropriate to use as the parent window of a document-modal sheet. This method may return nil, in which case the invoker should present an application-modal panel. NSDocument's implementation of this method returns the window of the first window controller, or nil if there are no window controllers or if the first window controller has no window.
*/
@property (nullable, readonly, strong) NSWindow *windowForSheet;

#pragma mark *** Types ***

/* Return the names of the types for which this class can be instantiated for the application to play the Editor or Viewer role. The default implementation of this method returns information derived from the application's Info.plist. You must typically override it in document classes that are dynamically loaded from plugins. NSDocumentController uses this method when presenting an open panel and when trying to figure the NSDocument subclass to instantiate when opening a particular type of document.
*/
+ (NSArray<NSString *> *)readableTypes;

/* Return the names of the types which this class can save. Typically this includes types for which the application can play the Editor role, plus types than can be merely exported by the application. The default implementation of this method returns information derived from the application's Info.plist. You must typically override it in document classes that are dynamically loaded from plugins.
*/
+ (NSArray<NSString *> *)writableTypes;

/* Return YES if instances of this class can be instantiated for the application to play the Editor role, NO otherwise. The default implementation of this method returns information derived from the application's Info.plist. You must typically override it in document classes that are dynamically loaded from plugins. NSDocument uses this method when presenting a save panel; in that situation all types returned by -writableTypes are presented in the standard file format popup, except the ones for which -isNativeType returns NO.
*/
+ (BOOL)isNativeType:(NSString *)type;

/* Return the names of the types to which this document can be saved for a kind of save operation. For every kind of save operation except NSSaveToOperation the returned array must only include types for which the the application can play the Editor role. For NSSaveToOperation the returned array may include types for which the application can only play the Viewer role, and other types that the application can merely export. The default implementation of this method returns [[self class] writableTypes] with, except during NSSaveToOperations, types for which +isNativeType returns NO filtered out.

You can override this method to limit the set of writable types when the documently currently contains data that is not representable in all types. For example, you can disallow saving to .rtf files when the document contains an attachment and can only be saved properly to .rtfd files. NSDocument uses this this method during save operations that present save panels, and during scripted save operations that do not. It may be called at additional times in future releases of Mac OS X. 

You can invoke this method when creating a custom save panel accessory view to easily present the same set of types that NSDocument would in its standard file format popup menu.
*/
- (NSArray<NSString *> *)writableTypesForSaveOperation:(NSSaveOperationType)saveOperation;

/* For a specified type, and a particular kind of save operation, return a file name extension that can be appended to a base file name. The default implementation of this method invokes [[NSWorkspace sharedWorkspace] preferredFilenameExtensionForType:typeName] if the type is a UTI or, for backward binary compatibility with Mac OS 10.4 and earlier, invokes [[NSDocumentController sharedDocumentController] fileExtensionsFromType:typeName] and chooses the first file name extension in the returned array if not.

You can override this method to customize the appending of extensions to file names by NSDocument. It's invoked from a variety of places within AppKit itself.
*/
- (nullable NSString *)fileNameExtensionForType:(NSString *)typeName saveOperation:(NSSaveOperationType)saveOperation NS_AVAILABLE_MAC(10_5);

#pragma mark *** Menu Item Validation ***

/* Conformance to the NSUserInterfaceValidations protocol. NSDocument's implementation of this method conditionally enables menu items for all of the action methods listed in this header file.
*/
- (BOOL)validateUserInterfaceItem:(id <NSValidatedUserInterfaceItem>)anItem;

#pragma mark *** Ubiquitous Storage ***

/* Return YES if instances of this class should allow the use of ubiquitous document storage. The default implementation of this method returns YES if the application has a valid ubiquity container entitlement. When this method returns YES, NSDocument may do things like add new menu items and other UI for ubiquitous documents and allow documents to be saved or moved into the default ubiquity container. You can override this method to return NO for document classes that should not include these features. */
+ (BOOL)usesUbiquitousStorage NS_AVAILABLE_MAC(10_8);

@end

@interface NSDocument(NSDeprecated)

#pragma mark *** Backward Compatibility ***

/* Methods that were deprecated in Mac OS 10.6. See the comments above for information about when your overrides of them are still invoked, for backward binary compatibility.
*/
- (BOOL)saveToURL:(NSURL *)url ofType:(NSString *)typeName forSaveOperation:(NSSaveOperationType)saveOperation error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_6, "Use -saveToURL:ofType:forSaveOperation:completionHandler: instead");

/* Methods that were deprecated in Mac OS 10.4. See the comments above for information about when your overrides of them are still invoked, for backward binary compatibility.
*/
- (nullable NSData *)dataRepresentationOfType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable NSDictionary *)fileAttributesToWriteToFile:(NSString *)fullDocumentPath ofType:(NSString *)documentTypeName saveOperation:(NSSaveOperationType)saveOperationType NS_DEPRECATED_MAC(10_1, 10_4);
- (nullable NSString *)fileName NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable NSFileWrapper *)fileWrapperRepresentationOfType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)initWithContentsOfFile:(NSString *)absolutePath ofType:(NSString *)typeName NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)initWithContentsOfURL:(NSURL *)url ofType:(NSString *)typeName NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)loadDataRepresentation:(NSData *)data ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)loadFileWrapperRepresentation:(NSFileWrapper *)wrapper ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (void)printShowingPrintPanel:(BOOL)flag NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)readFromFile:(NSString *)fileName ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)readFromURL:(NSURL *)url ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)revertToSavedFromFile:(NSString *)fileName ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)revertToSavedFromURL:(NSURL *)url ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (NSInteger)runModalPageLayoutWithPrintInfo:(NSPrintInfo *)printInfo NS_DEPRECATED_MAC(10_0, 10_4);
- (void)saveToFile:(NSString *)fileName saveOperation:(NSSaveOperationType)saveOperation delegate:(nullable id)delegate didSaveSelector:(nullable SEL)didSaveSelector contextInfo:(nullable void *)contextInfo NS_DEPRECATED_MAC(10_0, 10_4);
- (void)setFileName:(nullable NSString *)fileName NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)writeToFile:(NSString *)fileName ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)writeToFile:(NSString *)fullDocumentPath ofType:(NSString *)documentTypeName originalFile:(nullable NSString *)fullOriginalDocumentPath saveOperation:(NSSaveOperationType)saveOperationType NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)writeToURL:(NSURL *)url ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)writeWithBackupToFile:(NSString *)fullDocumentPath ofType:(NSString *)documentTypeName saveOperation:(NSSaveOperationType)saveOperationType NS_DEPRECATED_MAC(10_0, 10_4);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                    NSDocumentController.h                                                                              0100644 0001750 0001750 00000071220 12567220725 035254  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDocumentController.h
	Application Kit
	Copyright (c) 1997-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSNibDeclarations.h>
#import <AppKit/NSUserInterfaceValidation.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSDate.h>

NS_ASSUME_NONNULL_BEGIN

@class NSDocument, NSError, NSMenuItem, NSMutableDictionary, NSOpenPanel, NSURL, NSWindow;

@interface NSDocumentController : NSObject<NSCoding, NSUserInterfaceValidations> {
    @private
    id _documents;
    id _moreVars;
    NSArray *_cachedTypeDescriptions;
    NSMutableDictionary *_recents;
    int _recentsLimit;
}

#pragma mark *** The Shared Document Controller ***

/* Return the application's shared document controller. This method will create an instance of NSDocumentController if there is no shared document controller yet. Because the first instance of NSDocumentController to be allocate and initialized during application launch is used as the shared document controller, you have two options for installing an instance of a custom subclass of NSDocumentController as the shared document controller:
    1) Instantiate your NSDocumentController subclass in the application's main nib, or
    2) Allocate and initialize an instance of your subclass in your application delegate's applicationWillFinishLaunching: method.
*/
+ (__kindof NSDocumentController *)sharedDocumentController;

/* The designated initializer. The first instance of NSDocumentController to be allocate and initialized during application launch is used as the shared document controller.
*/
- (instancetype)init NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;

#pragma mark *** Currently Open Documents ***

/* Return an array of all open documents.
*/
@property (readonly, copy) NSArray<__kindof NSDocument *> *documents;

/* Return the active document, or nil if there is no active document. The "active" document is the one corresponding to the key window, or the one corresponding to the main window if the key window has no document.
*/
@property (nullable, readonly, strong) __kindof NSDocument *currentDocument;

/* Return the path of the directory containing the active document's file or file package, if there is an active document and it has a file or file package. Return nil otherwise. The default implementation of -URLsFromRunningOpenPanel invokes this to find the current directory to set in the open panel before presenting it.
*/
@property (nullable, readonly, copy) NSString *currentDirectory;

/* Given a URL, return the open document whose file or file package is located by the URL, or nil if there is no such open document. The default implementation of this method queries each open document to find one whose URL matches, and returns the first one whose URL does match.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self documentForFileName:[url path]] if -documentForFileName: is overridden and the URL uses the "file:" scheme.  
*/
- (nullable __kindof NSDocument *)documentForURL:(NSURL *)url;

/* Given a window, return the document corresponding to the window, nil if no document corrresponds to the window.
*/
- (nullable __kindof NSDocument *)documentForWindow:(NSWindow *)window;

/* Add or remove a document from the list of open documents. You can override these methods if your application needs to customize what is done when documents are opened and closed. -addDocument is invoked by the default implementations of all NSDocumentController methods whose names start with "open." Your application can invoke -addDocument: manually if it creates a document using something other than one of NSDocument's "open" methods. -removeDocument is invoked by the default implementation of -[NSDocument close].
*/
- (void)addDocument:(NSDocument *)document;
- (void)removeDocument:(NSDocument *)document;

#pragma mark *** Document Creation ***

/* The action of the File menu's New item in a document-based application. The default implementation of this method invokes -openUntitledDocumentAndDisplay:error: and, if nil is returned, presents the error in an application-modal panel.
*/
- (IBAction)newDocument:(nullable id)sender;

/* Create a new untitled document, present its user interface if displayDocument is YES, and return the document if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why a new untitled document could not be created. The default implementation of this method invokes [self defaultType] to determine the type of new document to create, invokes -makeUntitledDocumentOfType:error: to create it, then invokes -addDocument: to record its opening. If displayDocument is YES, it then sends the new document -makeWindowControllers and -showWindows messages.

The default implementation of this method uses the file coordination mechanism that was added to the Foundation framework in Mac OS 10.7. It passes the document to +[NSFileCoordinator addFilePresenter:] right after -addDocument: is invoked. (The balancing invocation of +[NSFileCoordinator removeFilePresenter:] is in -[NSDocument close]).

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self openUntitledDocumentOfType:[self defaultType] display:displayDocument] if -openUntitledDocumentOfType:display: is overridden.
*/
- (nullable __kindof NSDocument *)openUntitledDocumentAndDisplay:(BOOL)displayDocument error:(NSError **)outError;

/* Instantiate a new untitled document of the specified type and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why a new untitled document could not be instantiated. The default implementation of this method invokes -documentClassForType: to find out the class of document to instantiate, allocates a document object, and initializes it by sending it an -initWithType:error: message.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self makeUntitledDocumentOfType:typeName] if -makeUntitledDocumentOfType: is overridden.
*/
- (nullable __kindof NSDocument *)makeUntitledDocumentOfType:(NSString *)typeName error:(NSError **)outError;

#pragma mark *** Document Opening ***

/* The action of the File menu's Open... item in a document-based application. The default implementation of this method invokes -beginOpenPanelWithCompletionHandler:, unless -fileNamesFromRunningOpenPanel is overridden, in which case that method is invoked instead for backward binary compatibility with Mac OS 10.3 and earlier. If an array other than nil is obtained from that call, it invokes -openDocumentWithContentsOfURL:display:completionHandler: for each URL and, if an error is signaled for any of them, presents the error in an application-modal panel.
*/
- (IBAction)openDocument:(nullable id)sender;

/* Present an application-modal open panel to the user and, if the user selects one or more files and indicates that they are to be opened, return an array of those files' URLs. Return nil otherwise. The default implementation of this method invokes -runModalOpenPanel:forTypes: after it has set up an open panel.
*/
- (nullable NSArray<NSURL *> *)URLsFromRunningOpenPanel;

/* Present the application-modal open panel to the user, specifying a list of UTIs (in Mac OS 10.5), file name extensions, and encoded HFS file types for openable files. Return NSOKButton or NSCancelButton depending on how the user dismisses the panel.
*/
- (NSInteger)runModalOpenPanel:(NSOpenPanel *)openPanel forTypes:(nullable NSArray<NSString *> *)types;

/* Present an open panel, which may or may not be application-modal, to the user and, if the user selects one or more files and indicates that they are to be opened, invoke the completion handler with an array of those files' URLs. Invoke the completion handler with nil otherwise. The default implementation of this method invokes -beginOpenPanel:forTypes:completionHandler:. However, for backward binary compatibility, it invokes -runModalOpenPanel:forTypes: instead if you override it in a subclass and not -beginOpenPanel:forTypes:completionHandler:.

If you override -[NSDocumentController openDocument:], you would typically want to invoke this method instead of -beginOpenPanel:forTypes:completionHandler: or -URLsFromRunningOpenPanel directly. You typically would not override this method without calling super.
*/
- (void)beginOpenPanelWithCompletionHandler:(void (^)(NSArray<NSURL *> * __nullable))completionHandler NS_AVAILABLE_MAC(10_8);

/* Present an open panel, which may or may not be application-modal, to the user, specifying a list of UTIs for openable files. Invoke the completion handler with NSOKButton or NSCancelButton depending on how the user dismisses the panel.

You typically would not invoke this method directly. You can override it though if you need to customize the open panel before it gets displayed.
*/
- (void)beginOpenPanel:(NSOpenPanel *)openPanel forTypes:(nullable NSArray<NSString *> *)inTypes completionHandler:(void (^)(NSInteger result))completionHandler NS_AVAILABLE_MAC(10_8);

/* Open a document located by a URL, present its user interface if displayDocument is YES, and invoke the passed-in completion handler at some point in the future, perhaps after the method invocation has returned. The completion handler must be invoked on the main thread. If successful, pass the document to the completion handler, and also whether the document was already open or being opened before this method was invoked. If not successful, pass a nil document and an NSError that encapsulates the reason why the document could not be opened.
 
The default implementation of this method checks to see if the document is already open or being opened, and if it is not determines the type of the document, invokes -makeDocumentWithContentsOfURL:ofType:error: to instantiate it, invokes -addDocument: to record its opening, and sends the document -makeWindowControllers and -showWindows messages if displayDocument is YES. If the document is already open it is just sent a -showWindows message if displayDocument is YES. If the relevant document class returns YES when sent +canConcurrentlyReadDocumentsOfType: then the invocation of -makeDocumentWithContentsOfURL:ofType:error: is done on a thread other than the main one and when that has returned the rest of the operation is done on the main thread.

The default implementation of this method uses the file coordination mechanism that was added to the Foundation framework in Mac OS 10.7. All of the work it does is one big coordinated read, and it passes the document to +[NSFileCoordinator addFilePresenter:] right after -addDocument: is invoked. (The balancing invocation of +[NSFileCoordinator removeFilePresenter:] is in -[NSDocument close]).

You can override this method to customize how documents are opened. Its implemention however is somewhat complex so unless your customization is to do additional work before invoking super, or to invoke super with a completion handler that does additional work before invoking the original completion handler, you should investigate overriding one of the methods that it invokes instead. If you do override this method you should investigate whether you should also override -reopenDocumentForURL:withContentsOfURL:display:completionHandler: to apply the same customization. In either cause take care to always invoke the completion handler on the main thread.

You can of course invoke this method to open a document.

For backward binary compatibility with Mac OS 10.6 and earlier, the default implementation of this method invokes [self openDocumentWithContentsOfURL:url display:displayDocument error:&anError] if that method or the even older -openDocumentWithContentsOfFile:display: method is overridden and this one is not, instead of invoking -makeDocumentWithContentsOfURL:ofType:error: and all the rest.
*/
- (void)openDocumentWithContentsOfURL:(NSURL *)url display:(BOOL)displayDocument completionHandler:(void (^)(NSDocument * __nullable document, BOOL documentWasAlreadyOpen, NSError * __nullable error))completionHandler NS_AVAILABLE_MAC(10_7);

/* Instantiate a document located by a URL, of a specified type, and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the document could not be instantiated. The default implementation of this method invokes -documentClassForType: to find out the class of document to instantiate, allocates a document object, and initializes it by sending it an -initWithContentsOfURL:ofType:error: message.

For backward binary compatibility with Mac OS 10.3 and earlier, the default implementation of this method instead invokes [self makeDocumentWithContentsOfFile:[url path] ofType:typeName] if -makeDocumentWithContentsOfFile:ofType: is overridden and the URL uses the "file:" scheme.
*/
- (nullable __kindof NSDocument *)makeDocumentWithContentsOfURL:(NSURL *)url ofType:(NSString *)typeName error:(NSError **)outError;

#pragma mark *** Document Reopening ***

/* Reopen a document, perhaps located by a URL, perhaps not, by reading the contents for the document from another URL, which may or may not be a different URL, present its user interface if displayDocument is YES, and invoke the passed-in completion handler at some point in the future, perhaps after the method invocation has returned. The completion handler must be invoked on the main thread. If successful, pass the document to the completion handler, and also whether the document was already open or being opened before this method was invoked. If not successful, pass a nil document and an NSError that encapsulates the reason why the document could not be opened. A nil URL indicates that the opened document is to have no fileURL, much like an untitled document has.
 
The default implementation of this method is very similar to -openDocumentWithContentsOfURL:display:completionHandler:'s, the primary difference being that it invokes -makeDocumentForURL:withContentsOfURL:ofType:error: instead of -makeDocumentWithContentsOfURL:ofType:error:.

You can override this method to customize how documents are reopened during application launching by the restorable state mechanism that was added to the AppKit framework in Mac OS 10.7. Its implemention however is somewhat complex so unless your customization is to do additional work before invoking super, or to invoke super with a completion handler that does additional work before invoking the original completion handler, you should investigate overriding one of the methods that it invokes instead.

We don't anticipate any uses for an application to invoke this method directly, but you may discover one.

For backward binary compatibility with Mac OS 10.6 and earlier, the default implementation of this method invokes [self reopenDocumentForURL:url withContentsOfURLcontentsURL error:&anError] if that method is overridden and this one is not, instead of invoking -makeDocumentForURL:withContentsOfURL:ofType:error: and all the rest.
*/
- (void)reopenDocumentForURL:(nullable NSURL *)urlOrNil withContentsOfURL:(NSURL *)contentsURL display:(BOOL)displayDocument completionHandler:(void (^)(NSDocument * __nullable document, BOOL documentWasAlreadyOpen, NSError * __nullable error))completionHandler NS_AVAILABLE_MAC(10_7);

/* Instantiate a document, perhaps located by a URL, perhaps not, by reading the contents for the document from another URL, which may or may not be a different URL, and return it if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the document could not be instantiated. The default implementation of this method invokes -documentClassForType: to find out the class of document to instantiate, allocates a document object, and initializes it by sending it an -initForURL:withContentsOfURL:ofType:error: message.
*/
- (nullable __kindof NSDocument *)makeDocumentForURL:(nullable NSURL *)urlOrNil withContentsOfURL:(NSURL *)contentsURL ofType:(NSString *)typeName error:(NSError **)outError;

#pragma mark *** Document Autosaving ***

/* The time interval in seconds for periodic autosaving. A value of 0 indicates that periodic autosaving should not be done at all. NSDocument will use this number as the minimum amount of time to wait between detecting that a document has unautosaved changes and sending the document an -autosaveDocumentWithDelegate:didAutosaveSelector:contextInfo: message. The default value is 0. You can change it to enable periodic autosaving.
*/
@property NSTimeInterval autosavingDelay;

#pragma mark *** Document Saving ***

/* The action of the File menu's Save All item in a document-based application. The default implementation of this method sends each modified document a -saveDocumentWithDelegate:didSaveSelector:contextInfo: message.
*/
- (IBAction)saveAllDocuments:(nullable id)sender;

#pragma mark *** Document Closing ***

/* Return YES if any open document is modified, NO otherwise. This method is invoked at application quitting time, to determine whether -reviewUnsavedDocumentsWithAlertTitle:cancellable:delegate:didReviewAllSelector:contextInfo: should be invoked.
*/
@property (readonly) BOOL hasEditedDocuments;

/* If there is more than one modified document, present an application-modal alert panel telling the user that there are unsaved documents and giving the option of canceling, not saving the documents, or saving the documents. If the user indicates that saving should be done, or if there was only one modified document in the first place, invoke -closeAllDocumentsWithDelegate:didCloseAllSelector:didReviewAll:contextInfo: to attempt to close all modified documents, doing whatever saving is necessary to not lose data. Finally, send the message selected by didReviewAllSelector to the delegate, with the contextInfo as the last argument. The default implementation of this method ignores the passed-in title string (which is passed in only as the result of a historical quirk). The method selected by didReviewAllSelector must have the same signature as:

    - (void)documentController:(NSDocumentController *)documentController didReviewAll:(BOOL)didReviewAll contextInfo:(void *)contextInfo;
*/
- (void)reviewUnsavedDocumentsWithAlertTitle:(nullable NSString *)title cancellable:(BOOL)cancellable delegate:(nullable id)delegate didReviewAllSelector:(nullable SEL)didReviewAllSelector contextInfo:(nullable void *)contextInfo;

/* For each open, modified, document present a document-modal alert panel asking whether the document should be saved and giving the option of canceling, not saving the document, or saving the document. Stop presenting alert panels if the user indicates cancellation in any one of them. The default implementation of this merely sends each open document -canCloseDocumentWithDelegate:shouldCloseSelector:contextInfo: and -close messages until one of them cannot be closed. The method selected by didCloseAllSelector must have the same signature as:

    - (void)documentController:(NSDocumentController *)documentController didCloseAll:(BOOL)didCloseAll contextInfo:(void *)contextInfo;
*/
- (void)closeAllDocumentsWithDelegate:(nullable id)delegate didCloseAllSelector:(nullable SEL)didCloseAllSelector contextInfo:(nullable void *)contextInfo;

#pragma mark *** Document Duplicating ***

/* Create a new document that will not yet have a location by reading the contents for the document from another URL, present its user interface, and return the document if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why a new document could not be created. If duplicateByCopying is YES then first copy the contents located at the passed-in URL into a file located in the same directory that is used for the autosaved contents of untitled documents and with the same sort of name. if displayNameOrNil is not nil then use that value to derive a display name for the new document that does not match one that is already in use by an open document.
 
The default implementation of this method copies the file if specified, determines the type of the document, invokes -makeDocumentForURL:withContentsOfURL:ofType:error: to instantiate it, sends the document -setDisplayName: to name it if displayNameOrNil is not nil, invokes -addDocument: to record its opening, and sends the document -makeWindowControllers and -showWindows messages.

The default implementation of this method uses the file coordination mechanism that was added to the Foundation framework in Mac OS 10.7. It passes the document to +[NSFileCoordinator addFilePresenter:] right after -addDocument: is invoked. (The balancing invocation of +[NSFileCoordinator removeFilePresenter:] is in -[NSDocument close]).

You can override this method to customize how documents are duplicated. It is invoked by -[NSDocument duplicateAndReturnError:]. It may however also be invoked from other places in AppKit.
 
We don't anticipate any uses for your application to invoke this method directly, but you may discover one.
*/
- (nullable __kindof NSDocument *)duplicateDocumentWithContentsOfURL:(NSURL *)url copying:(BOOL)duplicateByCopying displayName:(nullable NSString *)displayNameOrNil error:(NSError **)outError NS_AVAILABLE_MAC(10_7);

#pragma mark *** Error Presentation ***

/* Methods that are declared by NSResponder and also implemented by NSDocumentController, even though for historical reasons NSDocumentController is not a subclass of NSResponder. NSDocumentController's default implementations are equivalent to NSResponder's while treating the application object as the "next responder" and forwarding error presentation messages to it.

NSDocument has overrides of -presentError:modalForWindow:delegate:didPresentSelector:contextInfo: and -presentError: that treat the shared document controller as the "next responder" and forward these messages it.

The default implementations of several NSDocumentController methods invoke -presentError:.

You can customize the presentation of errors for all kinds of documents by overriding -willPresentError:. Your override should follow the advice given for overriding of -[NSResponder willPresentError:].
*/
- (void)presentError:(NSError *)error modalForWindow:(NSWindow *)window delegate:(nullable id)delegate didPresentSelector:(nullable SEL)didPresentSelector contextInfo:(nullable void *)contextInfo;
- (BOOL)presentError:(NSError *)error;
- (NSError *)willPresentError:(NSError *)error;

#pragma mark *** The Open Recent Menu ***

/* Return the maximum number of items that may be presented in the standard Open Recent menu. A value of 0 indicates that NSDocumentController will not attempt to add an Open Recent menu to your application's File menu, though NSDocumentController will not attempt to remove any Open Recent menu item if there is one already there. The default implementation returns a value that is subject to change and may or may not be derived from a setting made by the user in a System Preferences panel.
*/
@property (readonly) NSUInteger maximumRecentDocumentCount;

/* The action of the Open Recent menu's Clear Menu item.
*/
- (IBAction)clearRecentDocuments:(nullable id)sender;

/* Add an item corresponding to a document to the Open Recent menu, or replace an existing item for the same document.
*/
- (void)noteNewRecentDocument:(NSDocument *)document;

/* Add an item corresponding to the data located by a URL to the Open Recent menu, or replace an existing item with the same URL. You can use this even in non-NSDocument-based applications.
*/
- (void)noteNewRecentDocumentURL:(NSURL *)url;

/* Return an array of URLs for the entries currently appearing in the Open Recent menu.
*/
@property (readonly, copy) NSArray<NSURL *> *recentDocumentURLs;

#pragma mark *** Document Types ***

/* Return the name of the document type that should be used when creating new documents. The default implementation of this method returns the first Editor type declared in the application's Info.plist, or returns nil if no Editor type is declared. You can override it to customize the type of document that is created when, for instance, the user chooses New in the File menu.
*/
@property (nullable, readonly) NSString *defaultType;

/* Given a URL, return the name of the document type that should be used when opening the document at that location, if successful. If not successful, return nil after setting *outError to an NSError that encapsulates the reason why the document's type could not be determined, or the fact that the document's type is just unrecognized. The default implementation of this method merely returns the URL's NSURLTypeIdentifierKey resource value. You can override this to customize type determination for documents being opened.

For backward binary compatibility with Mac OS 10.4 and earlier, the default implementation of this method actually first does the same thing that it did in Mac OS 10.4 (invoke -typeFromFileExtension:, possibly twice, passing an HFS file type string for the second invocation) if there are any CFBundleDocumentTypes Info.plist entries that don't have LSItemContentTypes subentries, and only gets the URL's NSURLTypeIdentifierKey resource value if that does not succeed.
*/
- (nullable NSString *)typeForContentsOfURL:(NSURL *)url error:(NSError **)outError;

/* Return the names of NSDocument subclasses supported by this application. The default implementation of this method returns information derived from the application's Info.plist. You can override it to return the names of document classes that are dynamically loaded from plugins.
*/
@property (readonly, copy) NSArray<NSString *> *documentClassNames;

/* Given a document type name, return the subclass of NSDocument that should be instantiated when opening a document of that type, or nil for failure.
*/
- (nullable Class)documentClassForType:(NSString *)typeName;

/* Given a document type name, return a string describing the document type that is fit to present to the user, or nil for failure.
*/
- (nullable NSString *)displayNameForType:(NSString *)typeName;

#pragma mark *** Menu Item Validation ***

/* Conformance to the NSUserInterfaceValidations protocol. NSDocumentController's implementation of this method conditionally enables menu items for all of the action methods listed in this header file, as well as the private action method for Open Recent menu items.
*/
- (BOOL)validateUserInterfaceItem:(id <NSValidatedUserInterfaceItem>)anItem;

@end

@interface NSDocumentController(NSDeprecated)

#pragma mark *** Backward Compatibility

/* Methods that were deprecated in Mac OS 10.7. See the comments above for information about when your overrides of them are still invoked, for backward binary compatibility.
*/
- (nullable id)openDocumentWithContentsOfURL:(NSURL *)url display:(BOOL)displayDocument error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7, "Use -openDocumentWithContentsOfURL:display:completionHandler: instead");
- (BOOL)reopenDocumentForURL:(nullable NSURL *)url withContentsOfURL:(NSURL *)contentsURL error:(NSError **)outError NS_DEPRECATED_MAC(10_4, 10_7, "Use -reopenDocumentForURL:withContentsOfURL:display:completionHandler: instead");

/* Methods that were deprecated in Mac OS 10.5, and don't work well in applications whose document types are declared with UTIs. In general, if each of the application's CFBundleDocumentTypes Info.plist entries has a valid LSItemContentTypes subentry, and the application doesn't invoke deprecated methods like -fileNamesFromRunningOpenPanel, then these methods will never be invoked from within Cocoa.
*/
- (nullable NSArray *)fileExtensionsFromType:(NSString *)typeName NS_DEPRECATED_MAC(10_0, 10_5);
- (nullable NSString *)typeFromFileExtension:(NSString *)fileNameExtensionOrHFSFileType NS_DEPRECATED_MAC(10_0, 10_5);

/* Methods that were deprecated in Mac OS 10.4. See the comments above for information about when your overrides of them are still invoked, for backward binary compatibility.
*/
- (nullable id)documentForFileName:(NSString *)fileName NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable NSArray *)fileNamesFromRunningOpenPanel NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)makeDocumentWithContentsOfFile:(NSString *)fileName ofType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)makeDocumentWithContentsOfURL:(NSURL *)url ofType:(null_unspecified NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)makeUntitledDocumentOfType:(NSString *)type NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)openDocumentWithContentsOfFile:(NSString *)fileName display:(BOOL)display NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)openDocumentWithContentsOfURL:(NSURL *)url display:(BOOL)display NS_DEPRECATED_MAC(10_0, 10_4);
- (nullable id)openUntitledDocumentOfType:(NSString*)type display:(BOOL)display NS_DEPRECATED_MAC(10_0, 10_4);
- (void)setShouldCreateUI:(BOOL)flag NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)shouldCreateUI NS_DEPRECATED_MAC(10_0, 10_4);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                NSDocumentScripting.h                                                                               0100644 0001750 0001750 00000001251 12567220725 035070  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSDocumentScripting.h
        AppKit Framework
        Copyright (c) 1997-2015, Apple Inc.
        All rights reserved.
*/

#import <AppKit/NSDocument.h>

NS_ASSUME_NONNULL_BEGIN

@class NSCloseCommand;
@class NSScriptCommand;
@class NSScriptObjectSpecifier;
@class NSString;

@interface NSDocument (NSScripting)

@property (copy) NSString *lastComponentOfFileName;

- (nullable id)handleSaveScriptCommand:(NSScriptCommand *)command;
- (nullable id)handleCloseScriptCommand:(NSCloseCommand *)command;
- (nullable id)handlePrintScriptCommand:(NSScriptCommand *)command;

@property (readonly, strong) NSScriptObjectSpecifier *objectSpecifier;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                       NSDragging.h                                                                                        0100644 0001750 0001750 00000035076 12567220725 033165  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDragging.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObjCRuntime.h>
#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSGeometry.h>
#import <limits.h>

NS_ASSUME_NONNULL_BEGIN

@class NSDraggingItem, NSDraggingSession, NSImage, NSPasteboard, NSView, NSWindow;
@class NSURL;
@protocol NSPasteboardWriting;


typedef NS_OPTIONS(NSUInteger, NSDragOperation) {
    NSDragOperationNone		= 0,
    NSDragOperationCopy		= 1,
    NSDragOperationLink		= 2,
    NSDragOperationGeneric	= 4,
    NSDragOperationPrivate	= 8,
    NSDragOperationMove		= 16,
    NSDragOperationDelete	= 32,
    NSDragOperationEvery	= NSUIntegerMax,
    
    NSDragOperationAll_Obsolete	NS_ENUM_DEPRECATED_MAC(10_0, 10_10) = 15, // Use NSDragOperationEvery
    NSDragOperationAll NS_ENUM_DEPRECATED_MAC(10_0, 10_10) = NSDragOperationAll_Obsolete, // Use NSDragOperationEvery
};

typedef NS_ENUM(NSInteger, NSDraggingFormation) {
    NSDraggingFormationDefault = 0, // System determined formation.
    NSDraggingFormationNone,  // Drag images maintain their set positions relative to each other
    NSDraggingFormationPile,  // Drag images are placed on top of each other with random rotations
    NSDraggingFormationList,  // Drag images are laid out vertically, non-overlapping with the left edges aligned
    NSDraggingFormationStack // Drag images are laid out overlapping diagonally
} NS_ENUM_AVAILABLE_MAC(10_7);

typedef NS_ENUM(NSInteger, NSDraggingContext) {
    NSDraggingContextOutsideApplication = 0,
    NSDraggingContextWithinApplication
} NS_ENUM_AVAILABLE_MAC(10_7);

typedef NS_OPTIONS(NSUInteger, NSDraggingItemEnumerationOptions) {
    NSDraggingItemEnumerationConcurrent			= NSEnumerationConcurrent,
    /* When the following option is set, AppKit will automatically set the imageComponentProvider to nil for all dragging items that do not meet the classes/searchOptions criteria. Effectively, this hides the drag image for non valid items for this destination. */
    NSDraggingItemEnumerationClearNonenumeratedImages 	= (1UL << 16),
} NS_ENUM_AVAILABLE_MAC(10_7);

/* The spring loading highlight styles roughly correlate to {None: NotSpringLoadable, Light: SpringLoadable, Dark: SpringLoadingEngaged}. However, this not not strictly true as Drag & Drop may switch between highlight styles as an animated signal to the user. */
typedef NS_ENUM(NSInteger, NSSpringLoadingHighlight) {
    NSSpringLoadingHighlightNone = 0,
    NSSpringLoadingHighlightStandard,
    NSSpringLoadingHighlightEmphasized
} NS_ENUM_AVAILABLE_MAC(10_11);

/* protocol for the sender argument of the messages sent to a drag destination.  The view or
   window that registered dragging types sends these messages as dragging is
   happening to find out details about that session of dragging.
 */
@protocol NSDraggingInfo <NSObject>
@required
- (nullable NSWindow *)draggingDestinationWindow;
- (NSDragOperation)draggingSourceOperationMask;
- (NSPoint)draggingLocation;

/* Returns the current location of the current composited dragging images origin in NSDraggingFormationNone translated to the base coordinate system of the destination objects window
*/
- (NSPoint)draggedImageLocation;
- (nullable NSImage *)draggedImage;
- (NSPasteboard *)draggingPasteboard;
- (nullable id)draggingSource;
- (NSInteger)draggingSequenceNumber;
- (void)slideDraggedImageTo:(NSPoint)screenPoint;
- (nullable NSArray<NSString *> *)namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination;

/* Controls the dragging formation while the drag is over this destination. The default value is the current drag formation. */
@property NSDraggingFormation draggingFormation NS_AVAILABLE_MAC(10_7);

/* During the conclusion of an accepted drag, if this property is set to YES, the drag manager will animate each dragging image to their NSDraggingFormationNone locations. Otherwise, the drag images are removed without any animation. Note: This property is inspected between -prepareForDragOperation: and -performDragOperation:. If the final destination frames do not match the current NSDraggingFormationNone frames, then enumerate through the draggingItems during -performDragOperation: to set thier NSDraggingFormationNone frames to the correct destinations.
 */
@property BOOL animatesToDestination NS_AVAILABLE_MAC(10_7);

/* During draggingEntered: or draggingUpdated:, you are responsible for returning the drag operation. In some cases, you may accept some, but not all items on the dragging pasteboard. (For example, you only accept image files.) If you only accept some of the items, you should set this property so the drag manager can update the drag count badge. When -updateItems: is called, you should set the image of non valid dragging items to nil. If none of the drag items are valid then do not call this method. Simply return NSDragOperationNone from draggingEntered: and/or draggingUpdated: and do not modify any drag item properties.
 */
@property NSInteger numberOfValidItemsForDrop NS_AVAILABLE_MAC(10_7);

/* Use the following enumerate method to modify the properties of each dragging item. For example, change the drag image and size.
   Note: All changes made here are only in effect while the drag is over the destination. When the drag exits the destination all properties return to the values last set by the dragging session.
*/

/* Enumerate through each dragging item. Any changes made to the properties of the draggingItem are reflected in the drag and are automatically removed when the drag exits. Classes in the provided array must implement the NSPasteboardReading protocol. Cocoa classes that implement this protocol include NSImage, NSString, NSURL, NSColor, NSAttributedString, and NSPasteboardItem. For every item on the pasteboard, each class in the provided array will be queried for the types it can read using -readableTypesForPasteboard:. An instance will be created of the first class found in the provided array whose readable types match a conforming type contained in that pasteboard item. If an Instance is created from the pasteboard item data, it is placed into an NSDraggingItem along with the dragging properties of that item such as the dragging image. The NSDraggingItem is then passed as a parameter to the provided block. Additional search options, such as restricting the search to file URLs with particular content types, can be specified with a search options dictionary.  See the comments for the Pasteboard Reading Options keys in NSPasteboard.h for a full description. Note: all coordinate properties in the NSDraggingItem are in the coordinate system of view. If view is nil, the screen coordinate space is used.
*/
- (void)enumerateDraggingItemsWithOptions:(NSDraggingItemEnumerationOptions)enumOpts forView:(NSView *)view classes:(NSArray<Class> *)classArray searchOptions:(NSDictionary<NSString *, id> *)searchOptions usingBlock:(void (^)(NSDraggingItem *draggingItem, NSInteger idx, BOOL *stop))block NS_AVAILABLE_MAC(10_7);

@property (readonly) NSSpringLoadingHighlight springLoadingHighlight NS_AVAILABLE_MAC(10_11);

/* Used when the drag crosses two distinct but valid spring loading regions within the same destination. The hover timer is reset and if the user is currently in a force click, they must release and re-force click to highlight the new region. */
- (void)resetSpringLoading NS_AVAILABLE_MAC(10_11);

@end


/* Methods implemented by an object that receives dragged images.  The
   destination view or window is sent these messages during dragging if it
   responds to them.
 */
@protocol NSDraggingDestination <NSObject>
@optional
- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender;
- (NSDragOperation)draggingUpdated:(id <NSDraggingInfo>)sender; /* if the destination responded to draggingEntered: but not to draggingUpdated: the return value from draggingEntered: is used */
- (void)draggingExited:(nullable id <NSDraggingInfo>)sender;
- (BOOL)prepareForDragOperation:(id <NSDraggingInfo>)sender;
- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender;
- (void)concludeDragOperation:(nullable id <NSDraggingInfo>)sender;
/* draggingEnded: is implemented as of Mac OS 10.5 */
- (void)draggingEnded:(nullable id <NSDraggingInfo>)sender;
/* the receiver of -wantsPeriodicDraggingUpdates should return NO if it does not require periodic -draggingUpdated messages (eg. not autoscrolling or otherwise dependent on draggingUpdated: sent while mouse is stationary) */
- (BOOL)wantsPeriodicDraggingUpdates;

/* While a destination may change the dragging images at any time, it is recommended to wait until this method is called before updating the dragging image. This allows the system to delay changing the dragging images until it is likely that the user will drop on this destination. Otherwise, the dragging images will change too often during the drag which would be distracting to the user. The destination may update the dragging images by calling one of the -enumerateDraggingItems methods on the sender.
*/
- (void)updateDraggingItemsForDrag:(nullable id <NSDraggingInfo>)sender NS_AVAILABLE_MAC(10_7);
@end


@protocol NSDraggingSource <NSObject>
/* Methods implemented by an object that initiates a drag session. The source application is sent these messages during dragging.  The first must be implemented, the others are sent if the source responds to them.
*/

@required 
/* Declares what types of operations the source allows to be performed. Apple may provide more specific "within" values in the future. To account for this, for unrecongized localities, return the operation mask for the most specific context that you are concerned with. For example:
    switch(context) {
        case NSDraggingContextOutsideApplication:
            return ...
            break;

        case NSDraggingContextWithinApplication:
        default:
            return ...
            break;
    }
*/
- (NSDragOperation)draggingSession:(NSDraggingSession *)session sourceOperationMaskForDraggingContext:(NSDraggingContext)context;

@optional
- (void)draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint;
- (void)draggingSession:(NSDraggingSession *)session movedToPoint:(NSPoint)screenPoint;
- (void)draggingSession:(NSDraggingSession *)session endedAtPoint:(NSPoint)screenPoint operation:(NSDragOperation)operation;

- (BOOL)ignoreModifierKeysForDraggingSession:(NSDraggingSession *)session;

@end


typedef NS_OPTIONS(NSUInteger, NSSpringLoadingOptions) {
    NSSpringLoadingDisabled	= 0,		// Spring loading disabled
    NSSpringLoadingEnabled	= 1UL << 0,	// Spring loading allowed (via Force Click release and hover timeout depending on user preferences)
    
    /* Activate spring loading when user enters Force Click as opposed to release from Force Click. Spring loading is de-activated when Force Click is released. If hover is enabled, spring loading is activated on hover timeout and deactivates when the drag exits the target. This option should be used sparingly. */
    NSSpringLoadingContinuousActivation    = 1UL << 1,
    
    /* Disable spring loading activation via hover. This option should be used sparingly, but there are some rare cases where spring loading via hover results in too many false positives, but is otherwise very useful with a Force Click. These are generally cases when the destination view is very large, such as a canvas. */
    NSSpringLoadingNoHover 	= 1UL << 3
} NS_ENUM_AVAILABLE_MAC(10_11);

@protocol NSSpringLoadingDestination <NSObject>
@required
/* Perform the spring loading action (For example, the button's action, or select the tab). Normally, spring loading is a discreet action that only activates after the user completes the spring loading input. When the NSSpringLoadingContinuousActivation option set, spring loading become a continuous action that activates (YES) when the user starts spring loading and then deactivates (NO) when the user releases spring loading. See NSSpringLoadingContinuousActivation for more information.
 */
- (void)springLoadingActivated:(BOOL)activated draggingInfo:(id <NSDraggingInfo>)draggingInfo NS_AVAILABLE_MAC(10_11);

/* Called when the spring loading highlight changes */
- (void)springLoadingHighlightChanged:(id <NSDraggingInfo>)draggingInfo NS_AVAILABLE_MAC(10_11);

/* Note: You must also implement either -springLoadingEntered: or -springLoadingUpdated: */

@optional
/* Called when a drag enters the spring loading destination. Return NSSpringLoadingEnabled to enable spring loading. A view is not considered valid spring loading drag destination if neither this method nor springLoadingUpdated: is implemented */
- (NSSpringLoadingOptions)springLoadingEntered:(id <NSDraggingInfo>)draggingInfo NS_AVAILABLE_MAC(10_11);

/* Called when a drag moves or the drag info changes. If this method is not implemented, then the value from -springLoadingEntered: is used. */
- (NSSpringLoadingOptions)springLoadingUpdated:(id <NSDraggingInfo>)draggingInfo NS_AVAILABLE_MAC(10_11);

/* Called when a drag exits the spring loading destination */
- (void)springLoadingExited:(id <NSDraggingInfo>)draggingInfo NS_AVAILABLE_MAC(10_11);

/* The drag & drop operation has ended. Un-spring if needed. Note: If this obejct is both an NSSpringLoadingDestination and NSDraggingDestination, draggingEnded: will only be called once. */
- (void)draggingEnded:(id <NSDraggingInfo>)draggingInfo NS_AVAILABLE_MAC(10_11);
@end


@interface NSObject(NSDraggingSourceDeprecated)
/* The following methods are informally deprecated and are only called if the source does not implement the NSDraggingSource protocol methods. These methods will be formally deprecated in a future OS release
*/
- (nullable NSArray<NSString *> *)namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination;

// Formally deprecated
- (NSDragOperation)draggingSourceOperationMaskForLocal:(BOOL)flag NS_DEPRECATED_MAC(10_0, 10_7, "Use -draggingSession:sourceOperationMaskForDraggingContext: instead");
- (void)draggedImage:(null_unspecified NSImage *)image beganAt:(NSPoint)screenPoint NS_DEPRECATED_MAC(10_0, 10_7, "Use -draggingSession:willBeginAtPoint: instead");
- (void)draggedImage:(null_unspecified NSImage *)image endedAt:(NSPoint)screenPoint operation:(NSDragOperation)operation NS_DEPRECATED_MAC(10_0, 10_7, "Use -draggingSession:endedAtPoint:operation: instead");
- (void)draggedImage:(null_unspecified NSImage *)image movedTo:(NSPoint)screenPoint NS_DEPRECATED_MAC(10_0, 10_7, "Use -draggingSession:movedToPoint: instead");
- (BOOL)ignoreModifierKeysWhileDragging NS_DEPRECATED_MAC(10_0, 10_7, "Use -ignoreModifierKeysForDraggingSession: instead");

- (void)draggedImage:(null_unspecified NSImage *)image endedAt:(NSPoint)screenPoint deposited:(BOOL)flag DEPRECATED_IN_MAC_OS_X_VERSION_10_1_AND_LATER;
@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  NSDraggingItem.h                                                                                    0100644 0001750 0001750 00000010016 12567220726 033770  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDraggingItem.h
	Application Kit
	Copyright (c) 2010-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSGeometry.h>
#import <AppKit/AppKitDefines.h>

NS_ASSUME_NONNULL_BEGIN

@class NSString;
@protocol NSPasteboardWriting;


APPKIT_EXTERN NSString * const NSDraggingImageComponentIconKey NS_AVAILABLE_MAC(10_7);
APPKIT_EXTERN NSString * const NSDraggingImageComponentLabelKey NS_AVAILABLE_MAC(10_7);

NS_CLASS_AVAILABLE(10_7, NA)
@interface NSDraggingImageComponent : NSObject {
@private
    NSString *_key;
    id	_contents;
    NSRect _frame;
}

+ (NSDraggingImageComponent *)draggingImageComponentWithKey:(NSString *)key;

/* Designated initializer */
- (instancetype)initWithKey:(NSString *)key;

/* key must be unique for each component in an NSDraggingItem. You can create your own named components, but the following names have special meaning. NSDraggingImageComponentIconKey is an image of the item being dragged. NSDraggingImageComponentLabelKey represents a textual label associate with the item, for example, a file name.
*/
@property (copy) NSString *key;

/* An object providing the image contents of the component, typically you set an NSImage, but may be anything CALayer accepts.
*/
@property (nullable, strong) id contents;

/* The coordinate space is the bounds of the parent NSDraggingItem. That is, {{0,0}, {draggingFrame.size.width, draggingFrame.size.height}} Note: NSDraggingItem does not clip its components.
*/
@property NSRect frame;

@end

NS_CLASS_AVAILABLE(10_7, NA)
@interface NSDraggingItem : NSObject {
@private
    id _item;
    NSRect _frame;
    NSArray *_components;
    NSArray *(^_componentsProvider)(void);
#if !__LP64__
    NSInteger _reserved1;
    NSInteger _reserved2;
#endif
}

/* The designated initializer. When creating an NSDraggingItem the pasteboardWriter must implement the NSPasteboardWriting protocol.
*/
- (instancetype)initWithPasteboardWriter:(id <NSPasteboardWriting>) pasteboardWriter;

/* When you create an NSDraggingItem, item is the pasteboardWriter passed to initWithPasteboardWriter. However, when enumerating dragging items in an NSDraggingSession or NSDraggingInfo object, item is not the original pasteboardWriter. It is an instance of one of the classes provided to the enumeration method.
*/
@property (readonly, strong) id item;

/* The dragging frame that provides the spatial relationship between NSDraggingItems in the NSDraggingFormationNone. Note: The exact coordinate space of this rect depends on where it is used. See NSDraggingSession and NSDraggingInfo. 
*/
@property NSRect draggingFrame;

/* The dragging image is the composite of an array of NSDraggingImageComponents. The dragging image components may not be set directly. Instead, provide a block to generate the components and the block will be called if necessary. The block may be set to nil, meaning that this drag item has no image. Generally, only dragging destinations do this, and only if there is at least one valid item in the drop, and this is not it. The components are composited in painting order. That is, each component in the array is painted on top of the previous components in the array.
*/
@property (nullable, copy) NSArray<NSDraggingImageComponent *> * __nonnull (^imageComponentsProvider)(void);

/* Alternate single image component setter. This method simplifies modifiying the components of an NSDraggingItem when there is only one component. This method will set the draggingFrame and imageComponentsProvider properties. frame is in the same coordinate space that the draggingFrame property is.
*/
- (void)setDraggingFrame:(NSRect)frame contents:(id)contents;

/* An array of NSDraggingImageComponents that are used to create the drag image. Note: the array contains copies of the components. Changes made to these copies are not reflected in the drag. If needed, the imageComponentsProvider block is called to generate the image components.
*/
@property (nullable, readonly, copy) NSArray<NSDraggingImageComponent *> *imageComponents;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  NSDraggingSession.h                                                                                 0100644 0001750 0001750 00000010040 12567220726 034512  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSDraggingSession.h
	Application Kit
	Copyright (c) 2010-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSGeometry.h>
#import <AppKit/NSDragging.h>

NS_ASSUME_NONNULL_BEGIN

@class NSPasteboard, NSImage, NSDraggingItem;
@protocol NSDraggingSource, NSPasteboardWriting;

NS_CLASS_AVAILABLE(10_7, NA)
@interface NSDraggingSession : NSObject {
@private
    void *_private;
#if !__LP64__
    NSPoint _dragLocation;
#endif
    NSPoint _offset;
    id<NSDraggingSource> _source;
    id _alternateDragSource;
    id<NSDraggingSource> _filePromiseDragSource;
    NSPasteboard *_pboard;
    NSImage *_compositeImageCache;
#if !__LP64__
    NSInteger _leaderIndex;
#endif
    BOOL _animatesOnCancelOrFail;
#if !__LP64__    
    BOOL _reservedBOOL1;
    BOOL _reservedBOOL2;
    BOOL _reservedBOOL3;
    BOOL _reservedBOOL4;
    BOOL _reservedBOOL5;
    BOOL _reservedBOOL6;
    BOOL _reservedBOOL7;
    NSInteger _reservedInteger1;
    NSInteger _reservedInteger2;
#endif
}

/* Controls the dragging formation when the drag is over the source. The default value is NSDraggingFormationNone. */
@property NSDraggingFormation draggingFormation;

/* Controls whether the dragging image animates back to its starting point on a cancelled or failed drag. -draggingSession:endedAtPoint:operation: is a good time to change this value depending on the result of the drag operation. The default value is YES.
 */
@property BOOL animatesToStartingPositionsOnCancelOrFail;

/* The index of the draggingItem under the cursor. The default is the NSDraggingItem closest to the location in the event that was passed to -beginDraggingSessionWithItems:event:source:
 */
@property NSInteger draggingLeaderIndex;

/* Returns the pasteboard object that holds the data being dragged. */
@property(readonly) NSPasteboard *draggingPasteboard;

/* Returns a number that uniquely identifies the dragging session. */
@property(readonly) NSInteger draggingSequenceNumber;

/* The current location (cursor) of the drag in screen coordinates. */
@property(readonly) NSPoint draggingLocation;

/* Use the following enumerate methods to modify the properties of each dragging item. For example, change the drag image and size.
   Note: All changes made here are only in effect while destination is not overriding them. When the drag exits the destination, all properties return to the last values set here.
*/

/* Enumerate through each dragging item. Any changes made to the properties of the draggingItem are reflected in the drag when the destination is not overriding them. Classes in the provided array must implement the NSPasteboardReading protocol. Cocoa classes that implement this protocol include NSImage, NSString, NSURL, NSColor, NSAttributedString, and NSPasteboardItem. For every item on the pasteboard, each class in the provided array will be queried for the types it can read using -readableTypesForPasteboard:. An instance will be created of the first class found in the provided array whose readable types match a conforming type contained in that pasteboard item. If an Instance is created from the pasteboard item data, it is placed into an NSDraggingItem along with the dragging properties of that item such as the drag image. The NSDraggingItem is then passed as a parameter to the provided block. Additional search options, such as restricting the search to file URLs with particular content types, can be specified with a search options dictionary.  See the comments for the Pasteboard Reading Options keys in NSPasteboard.h for a full description. Note: all coordinate properties in the NSDraggingItem are in the coordinate system of view. If view is nil, the screen coordinate space is used.
*/
- (void)enumerateDraggingItemsWithOptions:(NSDraggingItemEnumerationOptions)enumOpts forView:(nullable NSView *)view classes:(NSArray<Class> *)classArray searchOptions:(NSDictionary<NSString *, id> *)searchOptions usingBlock:(void (^)(NSDraggingItem *draggingItem, NSInteger idx, BOOL *stop))block;
@end


NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                NSDrawer.h                                                                                          0100644 0001750 0001750 00000007535 12567220725 032666  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSDrawer.h
        Application Kit
        Copyright (c) 1999-2015, Apple Inc.
        All rights reserved.
*/

#import <CoreFoundation/CFDate.h>
#import <CoreFoundation/CFRunLoop.h>
#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSGeometry.h>
#import <AppKit/AppKitDefines.h>
#import <AppKit/NSResponder.h>
#import <AppKit/NSWindow.h>

NS_ASSUME_NONNULL_BEGIN

@class NSLock;
@class NSView;
@class NSWindow;
@class NSNotification;
@protocol NSDrawerDelegate;

typedef NS_ENUM(NSUInteger, NSDrawerState) {
    NSDrawerClosedState			= 0,
    NSDrawerOpeningState 		= 1,
    NSDrawerOpenState 			= 2,
    NSDrawerClosingState 		= 3
};

@interface NSDrawer : NSResponder <NSAccessibilityElement, NSAccessibility>
{
    /*All instance variables are private*/
    NSDrawerState 	_drawerState;
    NSDrawerState	_drawerNextState;
    NSRectEdge 		_drawerEdge;
    NSRectEdge 		_drawerNextEdge;
    NSRectEdge 		_drawerPreferredEdge;
    float 		_drawerPercent;
    float 		_drawerPercentSaved;
    CGFloat		_drawerLeadingOffset;
    CGFloat		_drawerTrailingOffset;
    NSLock 		*_drawerLock;
    NSWindow		*_drawerWindow;
    NSWindow 		*_drawerParentWindow;
    NSWindow		*_drawerNextParentWindow;
    NSString		*_drawerSaveName;
    CFAbsoluteTime 	_drawerStartTime;
    CFTimeInterval 	_drawerTotalTime;
    CFRunLoopRef 	_drawerLoop;
    __strong CFRunLoopTimerRef 	_drawerTimer;
    id 			_drawerDelegate;
    unsigned int	_drawerFlags;
    __strong CFRunLoopObserverRef _drawerObserver;
}

- (instancetype)initWithContentSize:(NSSize)contentSize preferredEdge:(NSRectEdge)edge;

@property (nullable, assign) NSWindow *parentWindow;
@property (nullable, strong) NSView *contentView;
@property NSRectEdge preferredEdge;
@property (nullable, assign) id<NSDrawerDelegate> delegate;

- (void)open;
- (void)openOnEdge:(NSRectEdge)edge;
- (void)close;

- (void)open:(nullable id)sender;
- (void)close:(nullable id)sender;
- (void)toggle:(nullable id)sender;

@property (readonly) NSInteger state;
@property (readonly) NSRectEdge edge;

@property NSSize contentSize;
@property NSSize minContentSize;
@property NSSize maxContentSize;

@property CGFloat leadingOffset;
@property CGFloat trailingOffset;

@end

@interface NSWindow(Drawers)

@property (nullable, readonly, copy) NSArray<NSDrawer *> *drawers;

@end

@protocol NSDrawerDelegate <NSObject>
@optional
- (BOOL)drawerShouldOpen:(NSDrawer *)sender;
- (BOOL)drawerShouldClose:(NSDrawer *)sender;
- (NSSize)drawerWillResizeContents:(NSDrawer *)sender toSize:(NSSize)contentSize;

/* Notifications */
- (void)drawerWillOpen:(NSNotification *)notification;
- (void)drawerDidOpen:(NSNotification *)notification;
- (void)drawerWillClose:(NSNotification *)notification;
- (void)drawerDidClose:(NSNotification *)notification;

@end

/* Notifications */
APPKIT_EXTERN NSString * NSDrawerWillOpenNotification;
APPKIT_EXTERN NSString * NSDrawerDidOpenNotification;
APPKIT_EXTERN NSString * NSDrawerWillCloseNotification;
APPKIT_EXTERN NSString * NSDrawerDidCloseNotification;

NS_ASSUME_NONNULL_END

/* Note that the size of a drawer is determined partly by its content, partly by
the size of its parent window.  The size in the direction of the drawer's motion
is determined by the drawer's content size, and may be manually changed by the
user within the limits determined by the min and max content sizes (programmatic
changes are not so limited.)  The size in the transverse direction is determined
by the size of the parent window, combined with the drawer's leading and trailing
offsets.  For finer control over the size of the drawer in the transverse direction,
listen for the parent window's NSWindowDidResizeNotification and then reset the
leading and/or trailing offsets accordingly.  The one overriding restriction is
that a drawer can never be larger than its parent, and the sizes of both drawer
and parent are constrained by this. */
                                                                                                                                                                   NSEPSImageRep.h                                                                                     0100644 0001750 0001750 00000001306 12567220725 033471  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSEPSImageRep.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSImageRep.h>

NS_ASSUME_NONNULL_BEGIN

@class NSPDFImageRep;

@interface NSEPSImageRep : NSImageRep {
    /*All instance variables are private*/
    NSPoint _bBoxOrigin;
    NSData *_epsData;
    NSPDFImageRep* _pdfImageRep;
}

+ (nullable instancetype)imageRepWithData:(NSData *)epsData;	/* Convenience of initWithData: */
- (nullable instancetype)initWithData:(NSData *)epsData;

/* prepareGState is unused */
- (void)prepareGState NS_DEPRECATED_MAC(10_0, 10_10);

@property (readonly, copy) NSData *EPSRepresentation;

@property (readonly) NSRect boundingBox;

@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                          NSErrors.h                                                                                          0100644 0001750 0001750 00000004441 12567220725 032707  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSErrors.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/AppKitDefines.h>

@class NSString;

NS_ASSUME_NONNULL_BEGIN

// The following strings are the names of exceptions the AppKit can raise

APPKIT_EXTERN NSString *NSTextLineTooLongException;
APPKIT_EXTERN NSString *NSTextNoSelectionException;
APPKIT_EXTERN NSString *NSWordTablesWriteException;
APPKIT_EXTERN NSString *NSWordTablesReadException;
APPKIT_EXTERN NSString *NSTextReadException;
APPKIT_EXTERN NSString *NSTextWriteException;
APPKIT_EXTERN NSString *NSPasteboardCommunicationException;
APPKIT_EXTERN NSString *NSPrintingCommunicationException;
APPKIT_EXTERN NSString *NSAbortModalException;
APPKIT_EXTERN NSString *NSAbortPrintingException;
APPKIT_EXTERN NSString *NSIllegalSelectorException;
APPKIT_EXTERN NSString *NSAppKitVirtualMemoryException;
APPKIT_EXTERN NSString *NSBadRTFDirectiveException;
APPKIT_EXTERN NSString *NSBadRTFFontTableException;
APPKIT_EXTERN NSString *NSBadRTFStyleSheetException;
APPKIT_EXTERN NSString *NSTypedStreamVersionException;
APPKIT_EXTERN NSString *NSTIFFException;
APPKIT_EXTERN NSString *NSPrintPackageException;
APPKIT_EXTERN NSString *NSBadRTFColorTableException;
APPKIT_EXTERN NSString *NSDraggingException;
APPKIT_EXTERN NSString *NSColorListIOException;
APPKIT_EXTERN NSString *NSColorListNotEditableException;
APPKIT_EXTERN NSString *NSBadBitmapParametersException;
APPKIT_EXTERN NSString *NSWindowServerCommunicationException;
APPKIT_EXTERN NSString *NSFontUnavailableException;
APPKIT_EXTERN NSString *NSPPDIncludeNotFoundException;
APPKIT_EXTERN NSString *NSPPDParseException;
APPKIT_EXTERN NSString *NSPPDIncludeStackOverflowException;
APPKIT_EXTERN NSString *NSPPDIncludeStackUnderflowException;
APPKIT_EXTERN NSString *NSRTFPropertyStackOverflowException;
APPKIT_EXTERN NSString *NSAppKitIgnoredException;
APPKIT_EXTERN NSString *NSBadComparisonException;
APPKIT_EXTERN NSString *NSImageCacheException;
APPKIT_EXTERN NSString *NSNibLoadingException;
APPKIT_EXTERN NSString *NSBrowserIllegalDelegateException;
APPKIT_EXTERN NSString *NSAccessibilityException NS_DEPRECATED_MAC(10_1, 10_11, "Exceptions are no longer appropriate for indicating errors in accessibility API. Unexpected values should be handled through appropriate type checking.");

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                               NSEvent.h                                                                                           0100644 0001750 0001750 00000103006 12567220725 032511  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSEvent.h
    Application Kit
    Copyright (c) 1994-2015, Apple Inc.
    All rights reserved.
*/

#import <AppKit/NSTouch.h>
#import <ApplicationServices/ApplicationServices.h>
#import <Foundation/NSObjCRuntime.h>
#import <Foundation/NSObject.h>
#import <Foundation/NSDate.h>
#import <Foundation/NSGeometry.h>
#import <Foundation/NSSet.h>
#import <IOKit/hidsystem/IOLLEvent.h>
#import <limits.h>

NS_ASSUME_NONNULL_BEGIN

@class NSGraphicsContext, NSWindow, NSTrackingArea;

typedef NS_ENUM(NSUInteger, NSEventType) {        /* various types of events */
    NSLeftMouseDown             = 1,            
    NSLeftMouseUp               = 2,
    NSRightMouseDown            = 3,
    NSRightMouseUp              = 4,
    NSMouseMoved                = 5,
    NSLeftMouseDragged          = 6,
    NSRightMouseDragged         = 7,
    NSMouseEntered              = 8,
    NSMouseExited               = 9,
    NSKeyDown                   = 10,
    NSKeyUp                     = 11,
    NSFlagsChanged              = 12,
    NSAppKitDefined             = 13,
    NSSystemDefined             = 14,
    NSApplicationDefined        = 15,
    NSPeriodic                  = 16,
    NSCursorUpdate              = 17,
    NSScrollWheel               = 22,
    NSTabletPoint               = 23,
    NSTabletProximity           = 24,
    NSOtherMouseDown            = 25,
    NSOtherMouseUp              = 26,
    NSOtherMouseDragged         = 27,
    /* The following event types are available on some hardware on 10.5.2 and later */
    NSEventTypeGesture NS_ENUM_AVAILABLE_MAC(10_5)       = 29,
    NSEventTypeMagnify NS_ENUM_AVAILABLE_MAC(10_5)       = 30,
    NSEventTypeSwipe   NS_ENUM_AVAILABLE_MAC(10_5)       = 31,
    NSEventTypeRotate  NS_ENUM_AVAILABLE_MAC(10_5)       = 18,
    NSEventTypeBeginGesture NS_ENUM_AVAILABLE_MAC(10_5)  = 19,
    NSEventTypeEndGesture NS_ENUM_AVAILABLE_MAC(10_5)    = 20,

#if __LP64__
    NSEventTypeSmartMagnify NS_ENUM_AVAILABLE_MAC(10_8) = 32,
#endif
    NSEventTypeQuickLook NS_ENUM_AVAILABLE_MAC(10_8) = 33,

#if __LP64__
    NSEventTypePressure NS_ENUM_AVAILABLE_MAC(10_10_3) = 34
#endif
};


// For APIs introduced in Mac OS X 10.6 and later, this type is used with NS*Mask constants to indicate the events of interest.
typedef NS_OPTIONS(unsigned long long, NSEventMask) { /* masks for the types of events */
    NSLeftMouseDownMask         = 1 << NSLeftMouseDown,
    NSLeftMouseUpMask           = 1 << NSLeftMouseUp,
    NSRightMouseDownMask        = 1 << NSRightMouseDown,
    NSRightMouseUpMask          = 1 << NSRightMouseUp,
    NSMouseMovedMask            = 1 << NSMouseMoved,
    NSLeftMouseDraggedMask      = 1 << NSLeftMouseDragged,
    NSRightMouseDraggedMask     = 1 << NSRightMouseDragged,
    NSMouseEnteredMask          = 1 << NSMouseEntered,
    NSMouseExitedMask           = 1 << NSMouseExited,
    NSKeyDownMask               = 1 << NSKeyDown,
    NSKeyUpMask                 = 1 << NSKeyUp,
    NSFlagsChangedMask          = 1 << NSFlagsChanged,
    NSAppKitDefinedMask         = 1 << NSAppKitDefined,
    NSSystemDefinedMask         = 1 << NSSystemDefined,
    NSApplicationDefinedMask    = 1 << NSApplicationDefined,
    NSPeriodicMask              = 1 << NSPeriodic,
    NSCursorUpdateMask          = 1 << NSCursorUpdate,
    NSScrollWheelMask           = 1 << NSScrollWheel,
    NSTabletPointMask           = 1 << NSTabletPoint,
    NSTabletProximityMask       = 1 << NSTabletProximity,
    NSOtherMouseDownMask        = 1 << NSOtherMouseDown,
    NSOtherMouseUpMask          = 1 << NSOtherMouseUp,
    NSOtherMouseDraggedMask     = 1 << NSOtherMouseDragged,
    /* The following event masks are available on some hardware on 10.5.2 and later */
    NSEventMaskGesture NS_ENUM_AVAILABLE_MAC(10_5)          = 1 << NSEventTypeGesture,
    NSEventMaskMagnify NS_ENUM_AVAILABLE_MAC(10_5)          = 1 << NSEventTypeMagnify,
    NSEventMaskSwipe NS_ENUM_AVAILABLE_MAC(10_5)            = 1U << NSEventTypeSwipe,
    NSEventMaskRotate NS_ENUM_AVAILABLE_MAC(10_5)           = 1 << NSEventTypeRotate,
    NSEventMaskBeginGesture NS_ENUM_AVAILABLE_MAC(10_5)     = 1 << NSEventTypeBeginGesture,
    NSEventMaskEndGesture NS_ENUM_AVAILABLE_MAC(10_5)       = 1 << NSEventTypeEndGesture,
    
#if __LP64__
    /* Note: You can only use these event masks on 64 bit. In other words, you cannot setup a local, nor global, event monitor for these event types on 32 bit. Also, you cannot search the event queue for them (nextEventMatchingMask:...) on 32 bit.
     */
    NSEventMaskSmartMagnify NS_ENUM_AVAILABLE_MAC(10_8) = 1ULL << NSEventTypeSmartMagnify,
    NSEventMaskPressure NS_ENUM_AVAILABLE_MAC(10_10_3) = 1ULL << NSEventTypePressure,
#endif
    
    NSAnyEventMask              = NSUIntegerMax
};


#if __LP64__
NS_INLINE NSEventMask NSEventMaskFromType(NSEventType type) { return (1UL << type); }
#else
NS_INLINE NSEventMask NSEventMaskFromType(NSEventType type) { return (1 << type); }
#endif

/* Device-independent bits found in event modifier flags */
typedef NS_OPTIONS(NSUInteger, NSEventModifierFlags) {
    NSAlphaShiftKeyMask         = 1 << 16,
    NSShiftKeyMask              = 1 << 17,
    NSControlKeyMask            = 1 << 18,
    NSAlternateKeyMask          = 1 << 19,
    NSCommandKeyMask            = 1 << 20,
    NSNumericPadKeyMask         = 1 << 21,
    NSHelpKeyMask               = 1 << 22,
    NSFunctionKeyMask           = 1 << 23,
    NSDeviceIndependentModifierFlagsMask    = 0xffff0000UL
};

/* pointer types for NSTabletProximity events or mouse events with subtype NSTabletProximityEventSubtype*/
typedef NS_ENUM(NSUInteger, NSPointingDeviceType) {        
    NSUnknownPointingDevice     = NX_TABLET_POINTER_UNKNOWN,
    NSPenPointingDevice         = NX_TABLET_POINTER_PEN,
    NSCursorPointingDevice      = NX_TABLET_POINTER_CURSOR,
    NSEraserPointingDevice      = NX_TABLET_POINTER_ERASER
};

/* button masks for NSTabletPoint events or mouse events with subtype NSTabletPointEventSubtype */
typedef NS_OPTIONS(NSUInteger, NSEventButtonMask) {
    NSPenTipMask                = NX_TABLET_BUTTON_PENTIPMASK,
    NSPenLowerSideMask          = NX_TABLET_BUTTON_PENLOWERSIDEMASK,
    NSPenUpperSideMask          = NX_TABLET_BUTTON_PENUPPERSIDEMASK
};

typedef NS_OPTIONS(NSUInteger, NSEventPhase) {
    NSEventPhaseNone        = 0, // event not associated with a phase.
    NSEventPhaseBegan       = 0x1 << 0,
    NSEventPhaseStationary  = 0x1 << 1,
    NSEventPhaseChanged     = 0x1 << 2,
    NSEventPhaseEnded       = 0x1 << 3,
    NSEventPhaseCancelled   = 0x1 << 4,
    NSEventPhaseMayBegin    = 0x1 << 5,
} NS_ENUM_AVAILABLE_MAC(10_7);

typedef NS_ENUM(NSInteger, NSEventGestureAxis) {
    NSEventGestureAxisNone = 0,
    NSEventGestureAxisHorizontal,
    NSEventGestureAxisVertical
} NS_ENUM_AVAILABLE_MAC(10_7);

typedef NS_OPTIONS(NSUInteger, NSEventSwipeTrackingOptions) {
    NSEventSwipeTrackingLockDirection = 0x1 << 0, // Clamp gestureAmount to 0 if the user starts to swipe in the opposite direction than they started.
    NSEventSwipeTrackingClampGestureAmount = 0x1 << 1  // Don't allow gestureAmount to go beyond +/-1.0
} NS_ENUM_AVAILABLE_MAC(10_7);

typedef NS_ENUM(short, NSEventSubtype) {
    /* event subtypes for NSAppKitDefined events */
    NSWindowExposedEventType            = 0,
    NSApplicationActivatedEventType     = 1,
    NSApplicationDeactivatedEventType   = 2,
    NSWindowMovedEventType              = 4,
    NSScreenChangedEventType            = 8,
    NSAWTEventType                      = 16,
    
    /* event subtypes for NSSystemDefined events */
    NSPowerOffEventType             = 1,
    
    /* event subtypes for mouse events */
    NSMouseEventSubtype             = NX_SUBTYPE_DEFAULT,
    NSTabletPointEventSubtype       = NX_SUBTYPE_TABLET_POINT,
    NSTabletProximityEventSubtype   = NX_SUBTYPE_TABLET_PROXIMITY,
    NSTouchEventSubtype NS_ENUM_AVAILABLE_MAC(10_6)             = NX_SUBTYPE_MOUSE_TOUCH
};


// NSPressureBehavior - The pressure gesture behavior that describes how a pressure gesture behaves and progresses
// In general, pressure gestures begin when stage reaches 1 and end when stage reaches 0. This corresponds to the simultaneously generated mouse down/up events.
typedef NS_ENUM(NSInteger, NSPressureBehavior) {
    NSPressureBehaviorUnknown = -1,
    
    // The default primary behavior when otherwise not explicitly configured. In 10.10.3 the default is NSPressureBehaviorPrimaryDeepClick.
    NSPressureBehaviorPrimaryDefault = 0,
    
    // Variable pressure with a small dynamic range after mouseDown.
    // Mouse events: LeftMouse
    // # of Stages: 1
    // Allowed stage transitions: 1->0
    // Actuations: mouseDown, mouseUp
    // stageTransition: NO
    NSPressureBehaviorPrimaryClick = 1,
    
    // Variable pressure with a large dynamic range after mouseDown suitable for drawing and general pressure use.
    // Mouse events: LeftMouse
    // # of Stages: 1
    // Allowed stage transitions: 1->0
    // Actuations: mouseDown, mouseUp
    // stageTransition: NO
    NSPressureBehaviorPrimaryGeneric = 2,
    
    // Variable pressure after mouseDown suitable for controlling speed. Used by NSAcceleratorButton
    // Mouse events: LeftMouse
    // # of Stages: 1
    // Allowed stage transitions: 1->0
    // Actuations: mouseDown, mouseUp
    // stageTransition: NO
    NSPressureBehaviorPrimaryAccelerator = 3,
    
    // Toggle between stages 1 and 2 until drag or mouse up (e.g. Force Click)
    // Mouse events: LeftMouse
    // # of Stages: 2 (stage 2 is disabled once dragging starts)
    // Allowed stage transitions: 1->0, 1->2, 2->1, 2->0
    // Actuations: mouseDown, mouseUp, 1->2, 2->1
    // stageTransition: into and release from stage 2
    NSPressureBehaviorPrimaryDeepClick = 5,
    
    // Toggle between stages 1 and 2 until mouse up (e.g. Force Click)
    // Mouse events: LeftMouse
    // # of Stages: 2
    // Allowed stage transitions: 1->0, 1->2, 2->1, 2->0
    // Actuations: mouseDown, mouseUp, 1->2, 2->1
    // stageTransition: into and release from stage 2
    NSPressureBehaviorPrimaryDeepDrag = 6,
    
}NS_ENUM_AVAILABLE_MAC(10_10_3);

@interface NSEvent : NSObject <NSCopying, NSCoding> {
    /*All instance variables are private*/
    NSEventType _type;
    NSPoint _location;
    unsigned int _modifierFlags;
    id _WSTimestamp;
    NSTimeInterval _timestamp;
    NSInteger _windowNumber;
    NSWindow *_window;
    NSGraphicsContext* _context;
    union {
        struct {
            int eventNumber;
            int clickCount;
            float pressure;
#if __LP64__
            CGFloat deltaX;
            CGFloat deltaY;
            int subtype;
            short buttonNumber;
            short reserved1;
            int reserved2[3];
#endif
        } mouse;
        struct {
            NSString *keys;
            NSString *unmodKeys;
            unsigned short keyCode;
            BOOL isARepeat;
#if __LP64__
            int eventFlags;
            int reserved[5];
#endif
        } key;
        struct {
            int eventNumber;
            NSInteger trackingNumber;
            void *userData;
#if __LP64__
            int reserved[6];
#endif
        } tracking;
        struct {
            CGFloat deltaX;
            CGFloat deltaY;
            CGFloat deltaZ; 
#if __LP64__
            short subtype;
            short reserved1;
            int reserved2[6];
#endif
        } scrollWheel;
        struct {
            CGFloat deltaX;
            CGFloat deltaY;
            CGFloat deltaZ; 
#if __LP64__
            int reserved[7];
#endif
        } axisGesture;
        struct {
            short subtype;
            BOOL gestureEnded;
            BOOL reserved;
            int value;
            float percentage;
#if __LP64__
            int reserved2[7];
#endif
        } miscGesture;
        struct {
            int subtype;
            NSInteger data1;
            NSInteger data2;
#if __LP64__
            int reserved[6];
#endif
        } misc;
#if __LP64__
        int tabletPointData[14];
        int tabletProximityData[14];
#endif
    } _data;
    void *_eventRef;
#if __LP64__
    void *reserved1;
    void *reserved2;
#endif
}


/* these messages are valid for all events */
@property (readonly) NSEventType type;
@property (readonly) NSEventModifierFlags modifierFlags;
@property (readonly) NSTimeInterval timestamp;
@property (nullable, readonly, assign) NSWindow *window;
@property (readonly) NSInteger windowNumber;
@property (nullable, readonly, strong) NSGraphicsContext *context;

/* these messages are valid for all mouse down/up/drag events */
@property (readonly) NSInteger clickCount;
@property (readonly) NSInteger buttonNumber;    // for NSOtherMouse events, but will return valid constants for NSLeftMouse and NSRightMouse
/* these messages are valid for all mouse down/up/drag and enter/exit events */
@property (readonly) NSInteger eventNumber;

/* -pressure is valid for all mouse down/up/drag events, and is also valid for NSTabletPoint events on 10.4 or later and NSEventTypePressure on 10.10.3 or later */
@property (readonly) float pressure;
/* -locationInWindow is valid for all mouse-related events */
@property (readonly) NSPoint locationInWindow;

/* these messages are valid for scroll wheel events and mouse move/drag events.  As of 10.5.2, deltaX and deltaY are also valid for swipe events.  A non-0 deltaX will represent a horizontal swipe, -1 for swipe right and 1 for swipe left.  A non-0 deltaY will represent a vertical swipe, -1 for swipe down and 1 for swipe up. As of 10.7, the preferred methods for scroll wheel events are scrollingDeltaX and scrollingDeltaY defined below.
*/
@property (readonly) CGFloat deltaX;    
@property (readonly) CGFloat deltaY;    
@property (readonly) CGFloat deltaZ;    // 0 for most scroll wheel and mouse events

/* This message is valid for NSScrollWheel events. A generic scroll wheel issues rather coarse scroll deltas. Some Apple mice and trackpads provide much more precise delta. This method determines the resolution of the scrollDeltaX and scrollDeltaY values.
*/
@property (readonly) BOOL hasPreciseScrollingDeltas NS_AVAILABLE_MAC(10_7);

/* The following two message are the preferred API for accessing NSScrollWheel deltas. When -hasPreciseScrollDeltas reutrns NO, multiply the returned value by line or row height. When -hasPreciseScrollDeltas returns YES, scroll by the returned value (in points). 
*/
@property (readonly) CGFloat scrollingDeltaX NS_AVAILABLE_MAC(10_7);
@property (readonly) CGFloat scrollingDeltaY NS_AVAILABLE_MAC(10_7);

/* This message is valid for NSScrollWheel events. With the Magic Mouse and some trackpads, the user can flick thier finger resulting in a stream of scroll events that dissipate over time. The location of these scroll wheel events changes as the user moves the cursor. AppKit latches these scroll wheel events to the view that is under the cursor when the flick occurs. A custom view can use this method to recognize these momentum scroll events and further route the event to the appropriate sub component.
*/
@property (readonly) NSEventPhase momentumPhase NS_AVAILABLE_MAC(10_7);

/* valid for NSEventScrollWheel events. The user may choose to change the scrolling behavior such that it feels like they are moving the content instead of the scroll bar. To accomplish this, deltaX/Y and scrollingDeltaX/Y are automatically inverted for NSEventScrollWheel events according to the user's preferences. However, for some uses, the behavior should not respect the user preference. This method allows you to determine when the event has been inverted and compensate by multiplying -1 if needed. 
*/
@property (getter=isDirectionInvertedFromDevice, readonly) BOOL directionInvertedFromDevice NS_AVAILABLE_MAC(10_7);

/* these messages are valid for keyup and keydown events */
@property (nullable, readonly, copy) NSString *characters;
@property (nullable, readonly, copy) NSString *charactersIgnoringModifiers;
  /* the chars that would have been generated, regardless of modifier keys (except shift) */
@property (getter=isARepeat, readonly) BOOL ARepeat;
/* this message is valid for keyup, keydown and flagschanged events */
@property (readonly) unsigned short keyCode;        /* device-independent key number */

/* these messages are valid for enter and exit events */
@property (readonly) NSInteger trackingNumber;
@property (nullable, readonly) void *userData NS_RETURNS_INNER_POINTER;
/* -trackingArea returns the NSTrackingArea that generated this event.  It is possible for there to be no trackingArea associated with the event in some cases where the event corresponds to a trackingRect installed with -[NSView addTrackingRect:owner:userData:assumeInside:], in which case nil is returned. */
@property (nullable, readonly, strong) NSTrackingArea *trackingArea NS_AVAILABLE_MAC(10_5); 

/* this message is valid for kit, system, and app-defined events */
/* this message is also valid for mouse events on 10.4 or later */
@property (readonly) NSEventSubtype subtype;

/* these messages are valid for kit, system, and app-defined events */
@property (readonly) NSInteger data1;
@property (readonly) NSInteger data2;


/* -eventRef and +eventWithEventRef:  are valid for all events */
/* -eventRef returns an EventRef corresponding to the NSEvent.  The EventRef is retained by the NSEvent, so will be valid as long as the NSEvent is valid, and will be released when the NSEvent is freed.  You can use RetainEvent to extend the lifetime of the EventRef, with a corresponding ReleaseEvent when you are done with it.  If there is no EventRef corresponding to the NSEvent, -eventRef will return NULL.
*/
@property (nullable, readonly) const void * /* EventRef */eventRef NS_RETURNS_INNER_POINTER NS_AVAILABLE_MAC(10_5);
/* +eventWithEventRef: returns an autoreleased NSEvent corresponding to the EventRef.  The EventRef is retained by the NSEvent and will be released when the NSEvent is freed.  If there is no NSEvent corresponding to the EventRef, +eventWithEventRef will return nil.
*/
+ (nullable NSEvent *)eventWithEventRef:(const void * /* EventRef */)eventRef NS_AVAILABLE_MAC(10_5);

/* -CGEvent returns an autoreleased CGEventRef corresponding to the NSEvent.  If there is no CGEventRef corresponding to the NSEvent, -CGEvent will return NULL.
*/
@property (nullable, readonly) CGEventRef CGEvent NS_AVAILABLE_MAC(10_5);

/* +eventWithCGEvent: returns an autoreleased NSEvent corresponding to the CGEventRef.  The CGEventRef is retained by the NSEvent and will be released when the NSEvent is freed.  If there is no NSEvent corresponding to the CGEventRef, +eventWithEventRef will return nil.
*/
+ (nullable NSEvent *)eventWithCGEvent:(CGEventRef)cgEvent NS_AVAILABLE_MAC(10_5);

/* Enable or disable coalescing of mouse movement events, including mouse moved, mouse dragged, and tablet events.  Coalescing is enabled by default.
*/
+ (void)setMouseCoalescingEnabled:(BOOL)flag NS_AVAILABLE_MAC(10_5);
+ (BOOL)isMouseCoalescingEnabled NS_AVAILABLE_MAC(10_5);


/* This message is valid for events of type NSEventTypeMagnify, on 10.5.2 or later */
@property (readonly) CGFloat magnification NS_AVAILABLE_MAC(10_5);       // change in magnification.   This value should be added to the current scaling of an item to get the new scale factor.

/* this message is valid for mouse events with subtype NSTabletPointEventSubtype or NSTabletProximityEventSubtype, and for NSTabletPoint and NSTabletProximity events */
@property (readonly) NSUInteger deviceID;

/* this message is valid for valid for mouse events with subtype NSTabletPointEventSubtype, and for NSTabletPoint events.  On 10.5.2 or later, it is also valid for NSEventTypeRotate events. */
@property (readonly) float rotation;       // In degrees.  For NSTabletPoint, this is rotation of the pen.  For NSEventTypeRotate, it is rotation on the track pad.

/* these messages are valid for mouse events with subtype NSTabletPointEventSubtype, and for NSTabletPoint events */
/* absolute x coordinate in tablet space at full tablet resolution */
@property (readonly) NSInteger absoluteX; 
/* absolute y coordinate in tablet space at full tablet resolution */
@property (readonly) NSInteger absoluteY;               
/* absolute z coordinate in tablet space at full tablet resolution */
@property (readonly) NSInteger absoluteZ;     
/* mask indicating which buttons are pressed.*/
@property (readonly) NSEventButtonMask buttonMask;
/* range is -1 to 1 for both axes */
@property (readonly) NSPoint tilt;     
/* tangential pressure on the device; range is -1 to 1 */
@property (readonly) float tangentialPressure;  
/* NSArray of 3 vendor defined shorts */
@property (readonly, strong) id vendorDefined;    

/* these messages are valid for mouse events with subtype NSTabletProximityEventSubtype, and  for NSTabletProximity events */
/* vendor defined, typically USB vendor ID */
@property (readonly) NSUInteger vendorID;
/* vendor defined tablet ID */
@property (readonly) NSUInteger tabletID;
/* index of the device on the tablet.  Usually 0, except for tablets that support multiple concurrent devices */
@property (readonly) NSUInteger pointingDeviceID;
/* system assigned unique tablet ID */
@property (readonly) NSUInteger systemTabletID;
/* vendor defined pointing device type */
@property (readonly) NSUInteger vendorPointingDeviceType; 
/* vendor defined serial number of pointing device */
@property (readonly) NSUInteger pointingDeviceSerialNumber; 
/* vendor defined unique ID */
@property (readonly) unsigned long long uniqueID;    
/* mask representing capabilities of device */
@property (readonly) NSUInteger capabilityMask;    
/* mask representing capabilities of device */
@property (readonly) NSPointingDeviceType pointingDeviceType;
/* YES - entering; NO - leaving */
@property (getter=isEnteringProximity, readonly) BOOL enteringProximity;    


- (NSSet<NSTouch *> *)touchesMatchingPhase:(NSTouchPhase)phase inView:(nullable NSView *)view NS_AVAILABLE_MAC(10_6);

/* The phase of a gesture scroll event. A gesture phrase are all the events that begin with a NSEventPhaseBegan and end with either a NSEventPhaseEnded or NSEventPhaseCancelled. All the gesture events are sent to the view under the cursor when the NSEventPhaseBegan occurred.  A gesture scroll event starts with a NSEventPhaseBegan phase and ends with a NSPhaseEnded. Legacy scroll wheel events (say from a Mighty Mouse) and momentum scroll wheel events have a phase of NSEventPhaseNone.
    Valid for NSScrollWheel
*/
@property (readonly) NSEventPhase phase NS_AVAILABLE_MAC(10_7);

/* This message is valid for NSEventTypePressure events. Pressure gesture events go through multiple stages.
*/
@property (readonly) NSInteger stage NS_AVAILABLE_MAC(10_10_3);

/* This message is valid for NSEventTypePressure events. Positive stageTransition describes approaching the next stage of the pressure gesture. Negative stageTransition describes approaching release of the current stage.
*/
@property (readonly) CGFloat stageTransition NS_AVAILABLE_MAC(10_10_3);

/* This message is valid for Mouse events. The event mask describing the various events that you may also get during this event sequence. Useful for determining if the input device issuing this mouse event can also simultaneously issue NSEventTypePressure events.
*/
@property (readonly) NSEventMask associatedEventsMask NS_AVAILABLE_MAC(10_10_3);

/* this message is valid for NSEventTypePressure events */
@property (readonly) NSPressureBehavior pressureBehavior NS_AVAILABLE_MAC(10_11);

/* Returns the user's preference about using gesture scrolls as a way to track fluid swipes. This value is determined by the Mouse / Trackpad preference panel for the current user. Generally, NSScrollView will check this for you. However, if your app is not using an NSScrollView, or your NSResponder can receive scrollWheel messages without first being sent to an NSScrollView, then you should check this preference before calling -trackSwipeEventWithOptions:dampenAmountThresholdMin:max:usingHandler:
*/
+ (BOOL)isSwipeTrackingFromScrollEventsEnabled NS_AVAILABLE_MAC(10_7);

/* This method allows easy tracking and UI feedback of scroll events as fluid swipes. Fluid swipes are tracked not only to the end of the physical gesture phase by the user, but also to the completion of any UI animation that should be performed. Using this method allows your implementation to maintain a consistent fluid feel with other applications. Any gesture amount outside of the supplied minimum and maximum dampen amount is pre-dampened for you to provide an elastic feel.

   The trackingHandler has the following parameters:
       gestureAmount: the amount of gesture that you should display in the UI. This may be a fractional amount. Note: Upon completion, the gesture amount will animate to one of the following values: -1, 0, 1.
       phase: the phase of the physical gesture as performed by the user. When the phase is either NSPhaseEnded, or NSPhaseCancelled, the use has physically ended the gesture successfully or not, respectively. Your handler will continue to be called with updated progress values to complete the fluid swipe animation with a phase of NSPhaseNone.
       isComplete: Signifies the swipe and animation are complete and you should tear down any temporary animation objects. The trackingHandler is released and will not be called further.
      *stop: A pointer to a BOOL allowing you to cancel further use of this trackingHandler by setting its value to YES. The trackingHandler is released appropriately.

   Note: This method returns immediately and tracking is performed asynchronously.

   Valid for Scroll events with a phase of NSEventPhaseBegan or NSEventPhaseChanged
*/
- (void)trackSwipeEventWithOptions:(NSEventSwipeTrackingOptions)options dampenAmountThresholdMin:(CGFloat)minDampenThreshold max:(CGFloat)maxDampenThreshold usingHandler:(void (^)(CGFloat gestureAmount, NSEventPhase phase, BOOL isComplete, BOOL *stop))trackingHandler NS_AVAILABLE_MAC(10_7);

/* used for initial delay and periodic behavior in tracking loops */
+ (void)startPeriodicEventsAfterDelay:(NSTimeInterval)delay withPeriod:(NSTimeInterval)period;
+ (void)stopPeriodicEvents;

/* apps will rarely create these objects */
+ (nullable NSEvent *)mouseEventWithType:(NSEventType)type location:(NSPoint)location modifierFlags:(NSEventModifierFlags)flags timestamp:(NSTimeInterval)time windowNumber:(NSInteger)wNum context:(nullable NSGraphicsContext*)context eventNumber:(NSInteger)eNum clickCount:(NSInteger)cNum pressure:(float)pressure;
+ (nullable NSEvent *)keyEventWithType:(NSEventType)type location:(NSPoint)location modifierFlags:(NSEventModifierFlags)flags timestamp:(NSTimeInterval)time windowNumber:(NSInteger)wNum context:(nullable NSGraphicsContext*)context characters:(NSString *)keys charactersIgnoringModifiers:(NSString *)ukeys isARepeat:(BOOL)flag keyCode:(unsigned short)code;
+ (nullable NSEvent *)enterExitEventWithType:(NSEventType)type location:(NSPoint)location modifierFlags:(NSEventModifierFlags)flags timestamp:(NSTimeInterval)time windowNumber:(NSInteger)wNum context:(nullable NSGraphicsContext*)context eventNumber:(NSInteger)eNum trackingNumber:(NSInteger)tNum userData:(nullable void *)data;
+ (nullable NSEvent *)otherEventWithType:(NSEventType)type location:(NSPoint)location modifierFlags:(NSEventModifierFlags)flags timestamp:(NSTimeInterval)time windowNumber:(NSInteger)wNum context:(nullable NSGraphicsContext*)context subtype:(short)subtype data1:(NSInteger)d1 data2:(NSInteger)d2;

// global mouse coordinates
+ (NSPoint)mouseLocation;

/* modifier keys currently down.  This returns the state of devices combined with synthesized events at the moment, independent of which events have been delivered via the event stream. */
+ (NSEventModifierFlags)modifierFlags NS_AVAILABLE_MAC(10_6);

/* mouse buttons currently down.  Returns indices of the mouse buttons currently down.  1 << 0 corresponds to leftMouse, 1 << 1 to rightMouse, and 1 << n, n >= 2 to other mouse buttons.  This returns the state of devices combined with synthesized events at the moment, independent of which events have been delivered via the event stream, so this method is not suitable for tracking. */
+ (NSUInteger)pressedMouseButtons NS_AVAILABLE_MAC(10_6);

/* the time in which a second click must occur in order to be considered a doubleClick.  This is a system value so overrides will have no effect. */
+ (NSTimeInterval)doubleClickInterval   NS_AVAILABLE_MAC(10_6);
/* the time for which a key must be held down in order to generate the first key repeat event.  This is a system value so overrides will have no effect. */
+ (NSTimeInterval)keyRepeatDelay        NS_AVAILABLE_MAC(10_6);
/* the time between subsequent key repeat events.  This is a system value so overrides will have no effect. */
+ (NSTimeInterval)keyRepeatInterval     NS_AVAILABLE_MAC(10_6);

/*
   API for monitoring events in other processes, or in your own process. For either +addGlobal or +addLocal, pass an event mask specifying which events you wish to monitor, and a block that will be called with the event to monitor.

   Use +addGlobal to install an event monitor that receives copies of events posted to other applications. Events are delivered asynchronously to your app and you can only observe the event; you cannot modify or otherwise prevent the event from being delivered to its original target application. Key-related events may only be monitored if accessibility is enabled or if your application is trusted for accessibility access (see AXIsProcessTrusted in AXUIElement.h). Note that your handler will not be called for events that are sent to your own application.

   Use +addLocal to install an event monitor that receives events before they are dispatched by -[NSApplication sendEvent:]. In this case, your block should either return a valid NSEvent (which may be the same as the incoming NSEvent, or may be a newly created NSEvent) to cause the event to be dispatched, or it may return nil to stop dispatching of the event. Note that your handler will not be called for events that are consumed by nested event-tracking loops such as control tracking, menu tracking, or window dragging; only events that are dispatched through -[NSApplication sendEvent:] will be passed to your handler.

   In either case, the return value of the API is a retained NSObject. You typically do not need to retain and release the event monitor yourself, since the implementation will retain it while needed.
   
   To remove the event monitor, under both garbage collection and non-GC, pass the return value from the +add API to +removeMonitor.
*/
+ (nullable id)addGlobalMonitorForEventsMatchingMask:(NSEventMask)mask handler:(void (^)(NSEvent*))block NS_AVAILABLE_MAC(10_6);
+ (nullable id)addLocalMonitorForEventsMatchingMask:(NSEventMask)mask handler:(NSEvent* __nullable (^)(NSEvent*))block NS_AVAILABLE_MAC(10_6);
+ (void)removeMonitor:(id)eventMonitor NS_AVAILABLE_MAC(10_6);

@end


/* Unicodes we reserve for function keys on the keyboard,  OpenStep reserves the range 0xF700-0xF8FF for this purpose.  The availability of various keys will be system dependent. */
enum {
    NSUpArrowFunctionKey        = 0xF700,
    NSDownArrowFunctionKey      = 0xF701,
    NSLeftArrowFunctionKey      = 0xF702,
    NSRightArrowFunctionKey     = 0xF703,
    NSF1FunctionKey             = 0xF704,
    NSF2FunctionKey             = 0xF705,
    NSF3FunctionKey             = 0xF706,
    NSF4FunctionKey             = 0xF707,
    NSF5FunctionKey             = 0xF708,
    NSF6FunctionKey             = 0xF709,
    NSF7FunctionKey             = 0xF70A,
    NSF8FunctionKey             = 0xF70B,
    NSF9FunctionKey             = 0xF70C,
    NSF10FunctionKey            = 0xF70D,
    NSF11FunctionKey            = 0xF70E,
    NSF12FunctionKey            = 0xF70F,
    NSF13FunctionKey            = 0xF710,
    NSF14FunctionKey            = 0xF711,
    NSF15FunctionKey            = 0xF712,
    NSF16FunctionKey            = 0xF713,
    NSF17FunctionKey            = 0xF714,
    NSF18FunctionKey            = 0xF715,
    NSF19FunctionKey            = 0xF716,
    NSF20FunctionKey            = 0xF717,
    NSF21FunctionKey            = 0xF718,
    NSF22FunctionKey            = 0xF719,
    NSF23FunctionKey            = 0xF71A,
    NSF24FunctionKey            = 0xF71B,
    NSF25FunctionKey            = 0xF71C,
    NSF26FunctionKey            = 0xF71D,
    NSF27FunctionKey            = 0xF71E,
    NSF28FunctionKey            = 0xF71F,
    NSF29FunctionKey            = 0xF720,
    NSF30FunctionKey            = 0xF721,
    NSF31FunctionKey            = 0xF722,
    NSF32FunctionKey            = 0xF723,
    NSF33FunctionKey            = 0xF724,
    NSF34FunctionKey            = 0xF725,
    NSF35FunctionKey            = 0xF726,
    NSInsertFunctionKey         = 0xF727,
    NSDeleteFunctionKey         = 0xF728,
    NSHomeFunctionKey           = 0xF729,
    NSBeginFunctionKey          = 0xF72A,
    NSEndFunctionKey            = 0xF72B,
    NSPageUpFunctionKey         = 0xF72C,
    NSPageDownFunctionKey       = 0xF72D,
    NSPrintScreenFunctionKey    = 0xF72E,
    NSScrollLockFunctionKey     = 0xF72F,
    NSPauseFunctionKey          = 0xF730,
    NSSysReqFunctionKey         = 0xF731,
    NSBreakFunctionKey          = 0xF732,
    NSResetFunctionKey          = 0xF733,
    NSStopFunctionKey           = 0xF734,
    NSMenuFunctionKey           = 0xF735,
    NSUserFunctionKey           = 0xF736,
    NSSystemFunctionKey         = 0xF737,
    NSPrintFunctionKey          = 0xF738,
    NSClearLineFunctionKey      = 0xF739,
    NSClearDisplayFunctionKey   = 0xF73A,
    NSInsertLineFunctionKey     = 0xF73B,
    NSDeleteLineFunctionKey     = 0xF73C,
    NSInsertCharFunctionKey     = 0xF73D,
    NSDeleteCharFunctionKey     = 0xF73E,
    NSPrevFunctionKey           = 0xF73F,
    NSNextFunctionKey           = 0xF740,
    NSSelectFunctionKey         = 0xF741,
    NSExecuteFunctionKey        = 0xF742,
    NSUndoFunctionKey           = 0xF743,
    NSRedoFunctionKey           = 0xF744,
    NSFindFunctionKey           = 0xF745,
    NSHelpFunctionKey           = 0xF746,
    NSModeSwitchFunctionKey     = 0xF747
};

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          NSFileWrapper.h                                                                                     0100644 0001750 0001750 00000000441 12567220725 033647  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSFileWrapper.h
        Application Kit
        Copyright (c) 1995-2015, Apple Inc.
        All rights reserved.
*/

#warning NSFileWrapper has been moved to Foundation. Import <Foundation/Foundation.h> instead of <AppKit/NSFileWrapper.h>.

#import <Foundation/NSFileWrapper.h>
                                                                                                                                                                                                                               NSFileWrapperExtensions.h                                                                           0100644 0001750 0001750 00000001271 12567220726 035732  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSFileWrapperExtensions.h
	Application Kit
	Copyright (c) 2002-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSFileWrapper.h>

NS_ASSUME_NONNULL_BEGIN

@class NSImage;

@interface NSFileWrapper(NSExtensions)

/* The icon. -icon may return nil even if the receiver is the result of reading a parent from the file system (use NSFileWrapperReadingImmediately if appropriate to prevent that). The image that's returned might be shared by many NSFileWrappers so your application must not mutate it. If your application needs to mutate the returned image it should make a copy and mutate the copy instead.
*/
@property (nullable, strong) NSImage *icon;

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                       NSFont.h                                                                                            0100644 0001750 0001750 00000032442 12567220725 032343  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSFont.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSString.h> // for NSStringEncoding
#import <AppKit/AppKitDefines.h>
#import <AppKit/NSCell.h> // for NSControlSize

NS_ASSUME_NONNULL_BEGIN

@class NSFontDescriptor, NSAffineTransform, NSGraphicsContext;

/********* NSGlyph *********/
/* This is the Application Kit glyph ID.
*/
typedef unsigned int NSGlyph;

enum {
    NSControlGlyph = 0x00FFFFFF, // An NSGlyph value representing control characters (i.e. tab, line breaks, etc)
    NSNullGlyph = 0x0 // An NSGlyph value representing glyphs removed by the layout process
};

/********* Font Matrix *********/
/* This is a font matrix value representing [1 0 0 1 0 0].
*/
APPKIT_EXTERN const CGFloat * NSFontIdentityMatrix;

/********* Glyph packing *********/
/* Other glyph packing modes are deprecated.
*/
typedef NS_ENUM(NSUInteger, NSMultibyteGlyphPacking) {
    NSNativeShortGlyphPacking = 5
};

/********* Screen Font Rendering Mode *********/
typedef NS_ENUM(NSUInteger, NSFontRenderingMode) {
    NSFontDefaultRenderingMode = 0, // Determines the actual mode based on the user preference settings
    NSFontAntialiasedRenderingMode = 1, // Antialiased, floating-point advancements rendering mode (synonym to printerFont)
    NSFontIntegerAdvancementsRenderingMode = 2, // integer advancements rendering mode
    NSFontAntialiasedIntegerAdvancementsRenderingMode = 3 // Antialiased, integer advancements rendering mode
};

NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE
@interface NSFont : NSObject <NSCopying, NSSecureCoding> {
    /* All instance variables are private */
    NSString *_name;
    CGFloat _size;
    NSInteger _retainCount;
    struct __fFlags {
        unsigned int _isScreenFont:1;
        unsigned int _systemFontType:8;
        unsigned int _reserved1:4;
        unsigned int _matrixIsIdentity:1;
        unsigned int _renderingMode:3;
        unsigned int _inInstanceCache:1;
        unsigned int _reserved2:14;
    } _fFlags;
    id _private;
}

/********* Factory *********/
+ (nullable NSFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize;
+ (nullable NSFont *)fontWithName:(NSString *)fontName matrix:(const CGFloat *)fontMatrix;
/* Instantiates an NSFont object matching fontDescriptor. If fontSize is greater than 0.0, it has precedence over NSFontSizeAttribute in fontDescriptor.
*/
+ (nullable NSFont *)fontWithDescriptor:(NSFontDescriptor *)fontDescriptor size:(CGFloat)fontSize;

/* Instantiates an NSFont object matching fontDescriptor. If textTransform is non-nil, it has precedence over NSFontMatrixAttribute in fontDescriptor.
*/
+ (nullable NSFont *)fontWithDescriptor:(NSFontDescriptor *)fontDescriptor textTransform:(nullable NSAffineTransform *)textTransform;

/********* Meta Font *********/
/* User font settings
*/
+ (nullable NSFont *)userFontOfSize:(CGFloat)fontSize;	// Application font
+ (nullable NSFont *)userFixedPitchFontOfSize:(CGFloat)fontSize; // fixed-pitch font
+ (void)setUserFont:(nullable NSFont *)aFont;	// set preference for Application font.
+ (void)setUserFixedPitchFont:(nullable NSFont *)aFont; // set preference for fixed-pitch.

/* UI font settings
*/
+ (NSFont *)systemFontOfSize:(CGFloat)fontSize;	// System font with NSFontWeightRegular and proportional digits
+ (NSFont *)boldSystemFontOfSize:(CGFloat)fontSize; // System font with NSFontWeightBold and proportional digits
+ (NSFont *)labelFontOfSize:(CGFloat)fontSize; // Label font

+ (NSFont *)titleBarFontOfSize:(CGFloat)fontSize;
+ (NSFont *)menuFontOfSize:(CGFloat)fontSize;
+ (NSFont *)menuBarFontOfSize:(CGFloat)fontSize;
+ (NSFont *)messageFontOfSize:(CGFloat)fontSize;
+ (NSFont *)paletteFontOfSize:(CGFloat)fontSize;
+ (NSFont *)toolTipsFontOfSize:(CGFloat)fontSize;
+ (NSFont *)controlContentFontOfSize:(CGFloat)fontSize;

/* Following two factory methods return system font with NSFontWeightTrait. Returns the system font object corresponding to fontSize and weight. +monospacedDigitSystemFontOfSize:weight: always return a system font instance with monospaced digit glyphs. It's recommended to use the symbolic weight values declared in NSFontDescriptor.h. Due to sophisticated system font weight matching logic underneath, it's recommended to use this factory method all the time when getting non-standard weight system fonts instead of transforming existing instances via methods like -[NSFontManager convertFont:toSize]. When asked for a missing weight for the running version of OS X, this method returns the nearest heavier weight available if the application is linked against the current or older SDK; otherwise, it returns the nearest lighter weight available.
*/
+ (NSFont *)systemFontOfSize:(CGFloat)fontSize weight:(CGFloat)weight NS_AVAILABLE_MAC(10_11);
+ (NSFont *)monospacedDigitSystemFontOfSize:(CGFloat)fontSize weight:(CGFloat)weight NS_AVAILABLE_MAC(10_11);

/* UI font size settings
*/
+ (CGFloat)systemFontSize; // size of the standard System font.
+ (CGFloat)smallSystemFontSize; // size of standard small System font.
+ (CGFloat)labelFontSize;	// size of the standard Label Font.

+ (CGFloat)systemFontSizeForControlSize:(NSControlSize)controlSize;

/********* Core font attribute *********/
@property (readonly, copy) NSString *fontName;
@property (readonly) CGFloat pointSize;
@property (readonly) const CGFloat *matrix NS_RETURNS_INNER_POINTER;
@property (nullable, readonly, copy) NSString *familyName;
@property (nullable, readonly, copy) NSString *displayName;
@property (readonly, strong) NSFontDescriptor *fontDescriptor;
@property (readonly, copy) NSAffineTransform *textTransform;

/********* Glyph coverage *********/
@property (readonly) NSUInteger numberOfGlyphs;
@property (readonly) NSStringEncoding mostCompatibleStringEncoding;
- (NSGlyph)glyphWithName:(NSString *)aName;
@property (readonly, strong) NSCharacterSet *coveredCharacterSet;

/********* Font instance-wide metrics *********/
/* These methods return scaled numbers.  If the font was created with a matrix, the matrix is applied automatically; otherwise the coordinates are multiplied by size.
*/
@property (readonly) NSRect boundingRectForFont;
@property (readonly) NSSize maximumAdvancement;

@property (readonly) CGFloat ascender;
@property (readonly) CGFloat descender;
@property (readonly) CGFloat leading;

@property (readonly) CGFloat underlinePosition;
@property (readonly) CGFloat underlineThickness;
@property (readonly) CGFloat italicAngle;
@property (readonly) CGFloat capHeight;
@property (readonly) CGFloat xHeight;
@property (getter=isFixedPitch, readonly) BOOL fixedPitch;

/********* Glyph metrics *********/
- (NSRect)boundingRectForGlyph:(NSGlyph)aGlyph;
- (NSSize)advancementForGlyph:(NSGlyph)ag;

// bulk query
- (void)getBoundingRects:(NSRectArray)bounds forGlyphs:(const NSGlyph *)glyphs count:(NSUInteger)glyphCount;
- (void)getAdvancements:(NSSizeArray)advancements forGlyphs:(const NSGlyph *)glyphs count:(NSUInteger)glyphCount;
- (void)getAdvancements:(NSSizeArray)advancements forPackedGlyphs:(const void *)packedGlyphs length:(NSUInteger)length; // only supports NSNativeShortGlyphPacking

/********* NSGraphicsContext-related *********/
- (void)set;
- (void)setInContext:(NSGraphicsContext *)graphicsContext;

/********* Rendering mode *********/
@property (readonly, copy) NSFont *printerFont;
@property (readonly, copy) NSFont *screenFont; // Same as screenFontWithRenderingMode:NSFontDefaultRenderingMode
- (NSFont *)screenFontWithRenderingMode:(NSFontRenderingMode)renderingMode;
@property (readonly) NSFontRenderingMode renderingMode;

/********* Vertical mode *********/
/* Returns a vertical version of the receiver if such a configuration is supported.  Returns the receiver if no vertical variant available.  A vertical font applies appropriate rotation to the text matrix in -setInContext:, returns vertical metrics, and enables the vertical glyph substitution feature by default. */
@property (readonly, copy) NSFont *verticalFont NS_AVAILABLE_MAC(10_7);

/* Returns YES if a vertical variant */
@property (getter=isVertical, readonly) BOOL vertical NS_AVAILABLE_MAC(10_7);
@end

/********* Glyph packing *********/
/* Take a buffer of NSGlyphs, of some given length, and a packing type, and a place to put some packed glyphs.  Pack up the NSGlyphs according to the NSMultibyteGlyphPacking, null-terminate the bytes, and then put them into the output buffer.  Return the count of bytes output, including the null-terminator.  The output buffer (packedGlyphs) provided by the caller is guaranteed to be at least "count*4+1" bytes long. This function only supports NSNativeShortGlyphPacking on Mac OS X.
*/
APPKIT_EXTERN NSInteger NSConvertGlyphsToPackedGlyphs(NSGlyph * __nonnull glBuf, NSInteger count, NSMultibyteGlyphPacking packing, char * __nonnull packedGlyphs);

/********* Notifications *********/
/* This notification is posted when the antialias threshold is changed by the user.
*/
APPKIT_EXTERN NSString * NSAntialiasThresholdChangedNotification;

/* This notification is posted when the available font set is modified as a result of activation/deactivation.
*/
APPKIT_EXTERN NSString * NSFontSetChangedNotification;

NS_ASSUME_NONNULL_END


/********* Deprecated API *********/
// The remaining portion is deprecated on Mac OS X 10.4 and Later.
#if !__LP64__
#if MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_4
/* Only NSNativeShortGlyphPacking is supported on Mac OS X.
*/
enum {
    NSOneByteGlyphPacking,
    NSJapaneseEUCGlyphPacking,
    NSAsciiWithDoubleByteEUCGlyphPacking,
    NSTwoByteGlyphPacking,
    NSFourByteGlyphPacking,
} NS_ENUM_DEPRECATED_MAC(10_0, 10_4);

enum _NSGlyphRelation {
    NSGlyphBelow = 1,
    NSGlyphAbove = 2
} NS_ENUM_DEPRECATED_MAC(10_0, 10_4);
#endif /* MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_4 */
typedef NSUInteger  NSGlyphRelation NS_DEPRECATED_MAC(10_0, 10_4);

@interface NSFont (NSFontDeprecated)
+ (void)useFont:(null_unspecified NSString *)fontName NS_DEPRECATED_MAC(10_0, 10_4); // This is now automatically handled by Quartz.
- (CGFloat)widthOfString:(null_unspecified NSString *)string NS_DEPRECATED_MAC(10_0, 10_4); // This API never returns correct value. Use NSStringDrawing API instead.
- (BOOL)isBaseFont NS_DEPRECATED_MAC(10_0, 10_4);
- (null_unspecified NSDictionary *)afmDictionary NS_DEPRECATED_MAC(10_0, 10_4);
- (BOOL)glyphIsEncoded:(NSGlyph)aGlyph NS_DEPRECATED_MAC(10_0, 10_4); // Can be deduced by aGlyph < [NSFont numberOfGlyphs] since only NSNativeShortGlyphPacking is supported.
- (CGFloat)defaultLineHeightForFont NS_DEPRECATED_MAC(10_0, 10_4); // Use -[NSLayoutManager defaultLineHeightForFont:] instead.
+ (null_unspecified NSArray *)preferredFontNames NS_DEPRECATED_MAC(10_0, 10_4); // NSFontCascadeListAttribute offers more powerful font substitution management
+ (void)setPreferredFontNames:(null_unspecified NSArray *)fontNameArray NS_DEPRECATED_MAC(10_0, 10_4);
- (null_unspecified NSString *)encodingScheme NS_DEPRECATED_MAC(10_0, 10_4);
- (NSMultibyteGlyphPacking) glyphPacking NS_DEPRECATED_MAC(10_0, 10_4);

NS_ASSUME_NONNULL_BEGIN
// The context-sensitive inter-glyph spacing is now performed at the typesetting stage.
- (NSPoint)positionOfGlyph:(NSGlyph)curGlyph precededByGlyph:(NSGlyph)prevGlyph isNominal:(null_unspecified BOOL *)nominal NS_DEPRECATED_MAC(10_0, 10_4);
- (NSInteger)positionsForCompositeSequence:(null_unspecified NSGlyph *)someGlyphs numberOfGlyphs:(NSInteger)numGlyphs pointArray:(NSPointArray)points NS_DEPRECATED_MAC(10_0, 10_4);
- (NSPoint)positionOfGlyph:(NSGlyph)curGlyph struckOverGlyph:(NSGlyph)prevGlyph metricsExist:(null_unspecified BOOL *)exist NS_DEPRECATED_MAC(10_0, 10_4);
- (NSPoint)positionOfGlyph:(NSGlyph)aGlyph struckOverRect:(NSRect)aRect metricsExist:(null_unspecified BOOL *)exist NS_DEPRECATED_MAC(10_0, 10_4);
- (NSPoint)positionOfGlyph:(NSGlyph)aGlyph forCharacter:(unichar)aChar struckOverRect:(NSRect)aRect NS_DEPRECATED_MAC(10_0, 10_4);
- (NSPoint)positionOfGlyph:(NSGlyph)thisGlyph withRelation:(NSGlyphRelation)rel toBaseGlyph:(NSGlyph)baseGlyph totalAdvancement:(NSSizePointer)adv metricsExist:(null_unspecified BOOL *)exist NS_DEPRECATED_MAC(10_0, 10_4);
@end

APPKIT_EXTERN NSString *NSAFMFamilyName         NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMFontName           NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMFormatVersion      NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMFullName           NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMNotice             NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMVersion            NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMWeight             NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMEncodingScheme     NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMCharacterSet       NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMCapHeight          NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMXHeight            NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMAscender           NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMDescender          NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMUnderlinePosition  NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMUnderlineThickness NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMItalicAngle        NS_DEPRECATED_MAC(10_0, 10_4);
APPKIT_EXTERN NSString *NSAFMMappingScheme      NS_DEPRECATED_MAC(10_0, 10_4);
NS_ASSUME_NONNULL_END

#endif /* !__LP64__ */
                                                                                                                                                                                                                              NSFontCollection.h                                                                                  0100644 0001750 0001750 00000021312 12567220726 034352  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSFontCollection.h
	Application Kit
	Copyright (c) 2010-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSError.h>
#import <Foundation/NSLocale.h>
#import <Foundation/NSString.h>
#import <AppKit/AppKitDefines.h>


NS_ASSUME_NONNULL_BEGIN

@class NSFontDescriptor;

/*
 Named collection visibility
 */
typedef NS_OPTIONS(NSUInteger, NSFontCollectionVisibility) {
    // Visible within this process, not persistent
    NSFontCollectionVisibilityProcess = (1UL << 0),
    
    // Visible to all processes, stored persistently
    NSFontCollectionVisibilityUser = (1UL << 1),
    
    // Visible to all users, stored persistently
    NSFontCollectionVisibilityComputer = (1UL << 2)
};


/*
 NSFontCollection - immutable font list
 */
NS_CLASS_AVAILABLE(10_7, NA)
@interface NSFontCollection : NSObject <NSCopying, NSMutableCopying, NSCoding>

/*
 Creating collections
 */
// Return a font collection matching the given descriptors
+ (NSFontCollection *)fontCollectionWithDescriptors:(NSArray<NSFontDescriptor *> *)queryDescriptors;

// Return a font collection matching all registered fonts
+ (NSFontCollection *)fontCollectionWithAllAvailableDescriptors;

// Return a collection with fonts for the specified locale.
+ (nullable NSFontCollection *)fontCollectionWithLocale:(NSLocale *)locale;

/* 
 Naming collections
 
 These methods allow you to associate a name with a collection. Named collections are shown by user interfaces such as NSFontPanel.
 
 Set the visibility to NSFontCollectionVisibilityProcess if you wish to make the collection visible to the current process, but not to other processes. NSFontCollectionVisibilityUser will archive the collection to persistent storage and make it visible to other processes. NSFontCollectionVisibilityComputer is like NSFontCollectionVisibilityUser but makes the collection visible to all users of the computer.
 
 There is no association between the the NSFontCollection instance and the name from which it was created. When you change the collection, you must show it again to see the changes reflected on disk or in font UI.
 
 Errors returned from these methods are NSFileManager errors.
 */

// Make the font collection visible by giving it a name
+ (BOOL)showFontCollection:(NSFontCollection *)collection withName:(NSString *)name visibility:(NSFontCollectionVisibility)visibility error:(NSError **)error;

// Remove font collection from view (for a persistent collection, deletes the named font collection from disk)
+ (BOOL)hideFontCollectionWithName:(NSString *)name visibility:(NSFontCollectionVisibility)visibility error:(NSError **)error;

// Rename named collection
+ (BOOL)renameFontCollectionWithName:(NSString *)name visibility:(NSFontCollectionVisibility)visibility toName:(NSString *)name error:(NSError **)error;

// Named collections visible to this process (array of NSString)
+ (NSArray<NSString *> *)allFontCollectionNames;

// Return the specified named collection
+ (nullable NSFontCollection *)fontCollectionWithName:(NSString *)name;

// Return the specified named collection with specified visibility
+ (nullable NSFontCollection *)fontCollectionWithName:(NSString *)name visibility:(NSFontCollectionVisibility)visibility;

/*
 Descriptor matching
 */

// The list of NSFontDescriptors to match. The matching descriptors are produced by matching this list of descriptors.
@property (nullable, readonly, copy) NSArray<NSFontDescriptor *> *queryDescriptors;

// A separate list of query descriptors. The matching results from this list are excluded from matchingDescriptors.
@property (nullable, readonly, copy) NSArray<NSFontDescriptor *> *exclusionDescriptors;

// Returns a list of descriptors matching the logical descriptors.
// These are determined at runtime as (matching queryDescriptors - matching exclusionDescriptors).
// options may be nil or a dictionary containing any combination of {NSFontCollectionIncludeDisabledFontsOption, NSFontCollectionRemoveDuplicatesOption, NSFontCollectionDisallowAutoActivationOption}.
@property (nullable, readonly, copy) NSArray<NSFontDescriptor *> *matchingDescriptors;
- (nullable NSArray<NSFontDescriptor *> *)matchingDescriptorsWithOptions:(nullable NSDictionary<NSString *, NSNumber *> *)options;

// Return a list of matching descriptors for a particular family
- (nullable NSArray<NSFontDescriptor *> *)matchingDescriptorsForFamily:(NSString *)family;
- (nullable NSArray<NSFontDescriptor *> *)matchingDescriptorsForFamily:(NSString *)family options:(nullable NSDictionary<NSString *, NSNumber *> *)options;

@end

/*
 NSMutableFontCollection - mutable font list
 */
NS_CLASS_AVAILABLE(10_7, NA)
@interface NSMutableFontCollection : NSFontCollection

// Return a font collection matching the given descriptors
+ (NSMutableFontCollection *)fontCollectionWithDescriptors:(NSArray<NSFontDescriptor *> *)queryDescriptors;

// Return a font collection matching all registered fonts
+ (NSMutableFontCollection *)fontCollectionWithAllAvailableDescriptors;

// Return a collection with fonts for the specified locale.
+ (NSMutableFontCollection *)fontCollectionWithLocale:(NSLocale *)locale;

// Return the specified named collection
+ (nullable NSMutableFontCollection *)fontCollectionWithName:(NSString *)name;

// Return the specified named collection with specified visibility
+ (nullable NSMutableFontCollection *)fontCollectionWithName:(NSString *)name visibility:(NSFontCollectionVisibility)visibility;

@property (nullable, copy) NSArray<NSFontDescriptor *> *queryDescriptors;

@property (nullable, copy) NSArray<NSFontDescriptor *> *exclusionDescriptors;

// Edit the query and exclusion arrays to ensure that the results of querying the given descriptors are included in the matching descriptors.
- (void)addQueryForDescriptors:(NSArray<NSFontDescriptor *> *)descriptors;

// Edit the query and exclusion arrays to ensure that the results of querying the given descriptors are excluded from the matching descriptors.
- (void)removeQueryForDescriptors:(NSArray<NSFontDescriptor *> *)descriptors;

@end

/*
 Matching options
 */
// NSNumber BOOL specifying whether disabled fonts should be included in the list of matching descriptors (YES) or not (NO). When unspecified, CoreText assumes NO. This option is intended only for font management applications. This option will make descriptor matching slower.
APPKIT_EXTERN NSString * const NSFontCollectionIncludeDisabledFontsOption NS_AVAILABLE_MAC(10_7);

// NSNumber BOOL controlling whether more than one copy of a font with the same PostScript name should be included in the list of matching descriptors
APPKIT_EXTERN NSString * const NSFontCollectionRemoveDuplicatesOption NS_AVAILABLE_MAC(10_7);

// NSNumber BOOL specifying that auto-activation should not be used to find missing fonts
APPKIT_EXTERN NSString * const NSFontCollectionDisallowAutoActivationOption NS_AVAILABLE_MAC(10_7);

/*
 NSFontCollectionDidChangeNotification
 
 This notification is sent to the local notification center when a named, persistent collection is modified.
 User info key NSFontCollectionNotificationAction describes the nature of the change.
 */
APPKIT_EXTERN NSString * const NSFontCollectionDidChangeNotification NS_AVAILABLE_MAC(10_7);

// Notification user info dictionary keys
APPKIT_EXTERN NSString * const NSFontCollectionActionKey NS_AVAILABLE_MAC(10_7);			// NSString: action taken
APPKIT_EXTERN NSString * const NSFontCollectionNameKey NS_AVAILABLE_MAC(10_7);			// NSString: current name of affected collection
APPKIT_EXTERN NSString * const NSFontCollectionOldNameKey NS_AVAILABLE_MAC(10_7);		// NSString: for NSFontCollectionWasRenamed, previous name of affected collection
APPKIT_EXTERN NSString * const NSFontCollectionVisibilityKey NS_AVAILABLE_MAC(10_7);		// NSNumber: visibility of affected collection

// Values for NSFontCollectionAction
APPKIT_EXTERN NSString * const NSFontCollectionWasShown NS_AVAILABLE_MAC(10_7);
APPKIT_EXTERN NSString * const NSFontCollectionWasHidden NS_AVAILABLE_MAC(10_7);
APPKIT_EXTERN NSString * const NSFontCollectionWasRenamed NS_AVAILABLE_MAC(10_7);

/*
 Standard named collections
 
 Standard mutable collection names -- these names are included in the list of allFontCollectionNames -- they have special meaning to the
 Cocoa font system and should not be hidden or renamed.
 */
APPKIT_EXTERN NSString * const NSFontCollectionAllFonts NS_AVAILABLE_MAC(10_7);		// All fonts in the system
APPKIT_EXTERN NSString * const NSFontCollectionUser NS_AVAILABLE_MAC(10_7);			// Per-user unmodifiable collection
APPKIT_EXTERN NSString * const NSFontCollectionFavorites NS_AVAILABLE_MAC(10_7);		// Collection of the user's preferred font descriptors
APPKIT_EXTERN NSString * const NSFontCollectionRecentlyUsed NS_AVAILABLE_MAC(10_7);	// Collection automatically maintained by NSFontManager

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                                                                                                                      NSFontDescriptor.h                                                                                  0100644 0001750 0001750 00000023275 12567220725 034406  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSFontDescriptor.h
	Application Kit
	Copyright (c) 2003-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSGeometry.h>
#import <Foundation/NSSet.h>
#import <AppKit/AppKitDefines.h>


/* Symbolic Font Traits */
/*!
    @enum NSFontSymbolicTraits
    @abstract Symbolic representation of stylistic font attributes.
    @discussion NSFontSymbolicTraits symbolically describes stylistic aspects of a font. The upper 16 bits is used to describe appearance of the font whereas the lower 16 bits for typeface. The font appearance information represented by the upper 16 bits can be used for stylistic font matching. The symbolic traits supersedes the existing NSFontTraitMask type used by NSFontManager. The corresponding values are kept compatible between NSFontTraitMask and NSFontSymbolicTraits.
*/
NS_ASSUME_NONNULL_BEGIN

typedef uint32_t NSFontSymbolicTraits;

/* Font appearance info (upper 16 bits of NSFontSymbolicTraits */
/*!
    @enum NSFontFamilyClass
    @abstract Stylistic class values.
    @discussion NSFontFamilyClass classifies certain stylistic qualities of the font. These values correspond closely to the font class values in the OpenType 'OS/2' table. The class values are bundled in the upper four bits of the NSFontSymbolicTraits and can be accessed via NSFontFamilyClassMask. For specific meaning of each identifier, refer to the OpenType specification.
 */
enum {
    NSFontUnknownClass = 0 << 28,
    NSFontOldStyleSerifsClass = 1 << 28,
    NSFontTransitionalSerifsClass = 2 << 28,
    NSFontModernSerifsClass = 3 << 28,
    NSFontClarendonSerifsClass = 4 << 28,
    NSFontSlabSerifsClass = 5 << 28,
    NSFontFreeformSerifsClass = 7 << 28,
    NSFontSansSerifClass = 8 << 28,
    NSFontOrnamentalsClass = 9 << 28,
    NSFontScriptsClass = 10 << 28,
    NSFontSymbolicClass = 12 << 28
};	
typedef uint32_t NSFontFamilyClass;

enum {
    NSFontFamilyClassMask = 0xF0000000
};

/* Typeface info (lower 16 bits of NSFontSymbolicTraits */
enum {
    NSFontItalicTrait = (1 << 0),
    NSFontBoldTrait = (1 << 1),
    NSFontExpandedTrait = (1 << 5), // expanded and condensed traits are mutually exclusive
    NSFontCondensedTrait = (1 << 6),
    NSFontMonoSpaceTrait = (1 << 10), // Use fixed-pitch glyphs if available. May have multiple glyph advances (most CJK glyphs may contain two spaces)
    NSFontVerticalTrait = (1 << 11), // Use vertical glyph variants and metrics
    NSFontUIOptimizedTrait = (1 << 12) // Synthesize appropriate attributes for UI rendering such as control titles if necessary
};

@class NSAffineTransform;

@interface NSFontDescriptor: NSObject <NSCopying, NSSecureCoding> {
/* All instance variables are private */
    NSMutableDictionary *_attributes;
    id _reserved1;
    id _reserved2;
    id _reserved3;
    id _reserved4;
    id _reserved5;
}

/* Core attribute access */
@property (nullable, readonly, copy) NSString *postscriptName;
@property (readonly) CGFloat pointSize;
@property (nullable, readonly, copy) NSAffineTransform *matrix;
@property (readonly) NSFontSymbolicTraits symbolicTraits;

- (nullable id)objectForKey:(NSString *)anAttribute;

@property (readonly, copy) NSDictionary<NSString *, id> *fontAttributes;

/* Instantiation */
+ (NSFontDescriptor *)fontDescriptorWithFontAttributes:(nullable NSDictionary<NSString *, id> *)attributes;
+ (NSFontDescriptor *)fontDescriptorWithName:(NSString *)fontName size:(CGFloat)size;
+ (NSFontDescriptor *)fontDescriptorWithName:(NSString *)fontName matrix:(NSAffineTransform *)matrix;

- (instancetype)initWithFontAttributes:(nullable NSDictionary<NSString *, id> *)attributes;
/* Instance conversion */
/* Returns "normalized" font descriptors matching the receiver. mandatoryKeys is an NSSet instance containing keys that are required to be identical in order to be matched. mandatoryKeys can be nil.
*/
- (NSArray<NSFontDescriptor *> *)matchingFontDescriptorsWithMandatoryKeys:(nullable NSSet<NSString *> *)mandatoryKeys;

/* Returns a "normalized" font descriptor matching the receiver. It is the first element returned from -matchingFontDescriptorsWithMandatoryKeys:. mandatoryKeys is an NSSet instance containing keys that are required to be identical in order to be matched. mandatoryKeys can be nil.
 */
- (nullable NSFontDescriptor *)matchingFontDescriptorWithMandatoryKeys:(nullable NSSet<NSString *> *)mandatoryKeys NS_AVAILABLE_MAC(10_5);

- (NSFontDescriptor *)fontDescriptorByAddingAttributes:(NSDictionary<NSString *, id> *)attributes; // the new attributes take precedence over the existing ones in the receiver
- (NSFontDescriptor *)fontDescriptorWithSymbolicTraits:(NSFontSymbolicTraits)symbolicTraits;
- (NSFontDescriptor *)fontDescriptorWithSize:(CGFloat)newPointSize;
- (NSFontDescriptor *)fontDescriptorWithMatrix:(NSAffineTransform *)matrix;
- (NSFontDescriptor *)fontDescriptorWithFace:(NSString *)newFace;
- (NSFontDescriptor *)fontDescriptorWithFamily:(NSString *)newFamily;
@end

/* Predefined font attributes not defined in NSAttributedString.h */

APPKIT_EXTERN NSString * NSFontFamilyAttribute;
APPKIT_EXTERN NSString * NSFontNameAttribute;
APPKIT_EXTERN NSString * NSFontFaceAttribute;
APPKIT_EXTERN NSString * NSFontSizeAttribute; 
APPKIT_EXTERN NSString * NSFontVisibleNameAttribute; 

APPKIT_EXTERN NSString * NSFontMatrixAttribute                  ; // An NSAffineTransform instance. (default: identity matrix)
APPKIT_EXTERN NSString * NSFontVariationAttribute               ; // An NSDictionary instance describing variation axis (default: supplied by font)
APPKIT_EXTERN NSString * NSFontCharacterSetAttribute            ; // An NSCharacterSet instance representing a set of Unicode characters covered by the font. (default: supplied by font)
APPKIT_EXTERN NSString * NSFontCascadeListAttribute             ; // An NSArray instance. Each member of the array is a sub-descriptor. (default: the system default cascading list for user's locale)
APPKIT_EXTERN NSString * NSFontTraitsAttribute                  ; // An NSDictionary instance fully describing font traits. (default: supplied by font)
APPKIT_EXTERN NSString * NSFontFixedAdvanceAttribute            ; // A float represented as an NSNumber. The value overrides glyph advancement specified by the font. (default: 0.0)
APPKIT_EXTERN NSString * NSFontFeatureSettingsAttribute          NS_AVAILABLE_MAC(10_5); // An array of dictionaries representing non-default font feature settings. Each dictionary contains NSFontFeatureTypeIdentifierKey and NSFontFeatureSelectorIdentifierKey.

APPKIT_EXTERN NSString * NSFontColorAttribute 			NS_DEPRECATED_MAC(10_3, 10_4); // This attribute is obsolete. Use NSForegroundColorAttributeName instead.

/* Font traits keys */
/* This key is used with a trait dictionary to get the symbolic traits value as an NSNumber.
*/
APPKIT_EXTERN NSString * NSFontSymbolicTrait;

/* This key is used with a trait dictionary to get the normalized weight value as an NSNumber. The valid value range is from -1.0 to 1.0. The value of 0.0 corresponds to the regular or medium font weight.
*/
APPKIT_EXTERN NSString * NSFontWeightTrait;

/* This key is used with a trait dictionary to get the relative inter-glyph spacing value as an NSNumber. The valid value range is from -1.0 to 1.0. The value of 0.0 corresponds to the regular glyph spacing.
*/
APPKIT_EXTERN NSString * NSFontWidthTrait;

/* This key is used with a trait dictionary to get the relative slant angle value as an NSNumber. The valid value range is from -1.0 to 1.0. The value or 0.0 corresponds to 0 degree clockwise rotation from the vertical and 1.0 corresponds to 30 degrees clockwise rotation.
*/
APPKIT_EXTERN NSString * NSFontSlantTrait;

/* Font variation keys */
/* This key is used with a variation axis dictionary to get the axis identifier value as an NSNumber.
*/
APPKIT_EXTERN NSString * NSFontVariationAxisIdentifierKey;

/* This key is used with a variation axis dictionary to get the  minimum axis value as an NSNumber.
*/
APPKIT_EXTERN NSString * NSFontVariationAxisMinimumValueKey;

/* This key is used with a variation axis dictionary to get the maximum axis value as an NSNumber.
*/
APPKIT_EXTERN NSString * NSFontVariationAxisMaximumValueKey;

/* This key is used with a variation axis dictionary to get the default axis value as an NSNumber.
*/
APPKIT_EXTERN NSString * NSFontVariationAxisDefaultValueKey;

/* This key is used with a variation axis dictionary to get the localized variation axis name.
*/
APPKIT_EXTERN NSString * NSFontVariationAxisNameKey;

/* Font feature keys */
/* A number object specifying font feature type such as ligature, character shape, etc. Refer to ATS/SFNTLayoutTypes.h for predefined feature types.
 */
APPKIT_EXTERN NSString * NSFontFeatureTypeIdentifierKey NS_AVAILABLE_MAC(10_5);

/* A number object specifying font feature selector such as common ligature off, traditional character shape, etc. Refer to ATS/SFNTLayoutTypes.h for predefined feature selectors.
 */
APPKIT_EXTERN NSString * NSFontFeatureSelectorIdentifierKey NS_AVAILABLE_MAC(10_5);

/* Font weight trait */
/* Predefined symbolic weight values used for NSFontWeightTrait and +[NSFont systemFontOfSize:weight:].
 */
APPKIT_EXTERN const CGFloat NSFontWeightUltraLight NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightThin NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightLight NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightRegular NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightMedium NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightSemibold NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightBold NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightHeavy NS_AVAILABLE_MAC(10_11);
APPKIT_EXTERN const CGFloat NSFontWeightBlack NS_AVAILABLE_MAC(10_11);

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                   NSFontManager.h                                                                                     0100644 0001750 0001750 00000017460 12567220725 033641  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSFontManager.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSGeometry.h>

NS_ASSUME_NONNULL_BEGIN

@class NSFont, NSFontPanel, NSMenu, NSFontDescriptor;

/*
 * Font Traits
 *
 * This list should be kept small since the more traits that are assigned
 * to a given font, the harder it will be to map it to some other family.
 * Some traits are mutually exclusive such as NSExpanded and NSCondensed.
 */
typedef NS_OPTIONS(NSUInteger, NSFontTraitMask) {
    NSItalicFontMask			= 0x00000001,
    NSBoldFontMask			= 0x00000002,
    NSUnboldFontMask			= 0x00000004,
    NSNonStandardCharacterSetFontMask	= 0x00000008,
    NSNarrowFontMask			= 0x00000010,
    NSExpandedFontMask			= 0x00000020,
    NSCondensedFontMask			= 0x00000040,
    NSSmallCapsFontMask			= 0x00000080,
    NSPosterFontMask			= 0x00000100,
    NSCompressedFontMask		= 0x00000200,
    NSFixedPitchFontMask		= 0x00000400,
    NSUnitalicFontMask			= 0x01000000
};


typedef NS_OPTIONS(NSUInteger, NSFontCollectionOptions) {
   NSFontCollectionApplicationOnlyMask = 1 << 0
};


/* And these "actions" are really tag values in Font Menu cells which send any of the action messages listed above.  Normally, they're pre-defined in the font panel.
 */
typedef NS_ENUM(NSUInteger, NSFontAction) {
    NSNoFontChangeAction		= 0,
    NSViaPanelFontAction		= 1,
    NSAddTraitFontAction		= 2,
    NSSizeUpFontAction			= 3,
    NSSizeDownFontAction		= 4,
    NSHeavierFontAction			= 5,
    NSLighterFontAction			= 6,
    NSRemoveTraitFontAction		= 7
};

NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE
@interface NSFontManager : NSObject
{
/*All instance variables are private*/
@private
    NSFontPanel * _panel;
    unsigned int _fmReserved1;
    SEL _action;
    id _actionOrigin;
    id _target;
    NSFont *_selFont;
    struct _fmFlags {
	unsigned int multipleFont:1;
	unsigned int disabled:1;
        unsigned int senderTagMode:2;
	unsigned int _RESERVED:12;
    } _fmFlags;
    unsigned short _fmReserved3;
    id _delegate;
    id _collections;
    id _hiddenCollections;
    NSUInteger _fmReserved4;
}

+ (void)setFontPanelFactory:(nullable Class)factoryId;
+ (void)setFontManagerFactory:(nullable Class)factoryId;
+ (NSFontManager *)sharedFontManager;

@property (getter=isMultiple, readonly) BOOL multiple;
@property (nullable, readonly, strong) NSFont *selectedFont;
- (void)setSelectedFont:(NSFont *)fontObj isMultiple:(BOOL)flag;
- (void)setFontMenu:(NSMenu *)newMenu;
- (nullable NSMenu *)fontMenu:(BOOL)create;
- (nullable NSFontPanel *)fontPanel:(BOOL)create;
- (nullable NSFont *)fontWithFamily:(NSString *)family traits:(NSFontTraitMask)traits weight:(NSInteger)weight size:(CGFloat)size;
- (NSFontTraitMask)traitsOfFont:(NSFont *)fontObj;
- (NSInteger)weightOfFont:(NSFont *)fontObj;

/* Three methods for supporting app font management.  The fonts and names used/returned by these functions are the same as those used by the NSFontPanel.  The third method below takes as input a name as returned by "availableFontFamilies" and returns an NSArray of NSArrays.  The elements of the "inner" arrays are: (0) the font's name, (1) non-family part of the name as used by NSFontPanel, (2) an NSNumber indicating the weight, and (3) an NSNumber indicating the traits.
*/
@property (readonly, copy) NSArray<NSString *> *availableFonts;
@property (readonly, copy) NSArray<NSString *> *availableFontFamilies;
- (nullable NSArray<NSArray *> *)availableMembersOfFontFamily:(NSString *)fam;

- (NSFont *)convertFont:(NSFont *)fontObj;
- (NSFont *)convertFont:(NSFont *)fontObj toSize:(CGFloat)size;
- (nullable NSFont *)convertFont:(NSFont *)fontObj toFace:(NSString *)typeface;
- (NSFont *)convertFont:(NSFont *)fontObj toFamily:(NSString *)family;
- (NSFont *)convertFont:(NSFont *)fontObj toHaveTrait:(NSFontTraitMask)trait;
- (NSFont *)convertFont:(NSFont *)fontObj toNotHaveTrait:(NSFontTraitMask)trait;
- (NSFont *)convertWeight:(BOOL)upFlag ofFont:(NSFont *)fontObj;
@property (getter=isEnabled) BOOL enabled;
@property SEL action;
@property (nullable, assign) id delegate NS_DEPRECATED_MAC(10_0, 10_11, "NSFontManager doesn't have any delegate method. This property should not be used.");


- (BOOL)sendAction;

- (NSString *) localizedNameForFamily:(NSString *)family face:(nullable NSString *)faceKey;

- (void)setSelectedAttributes:(NSDictionary<NSString *, id> *)attributes isMultiple:(BOOL)flag;
- (NSDictionary<NSString *, id> *)convertAttributes:(NSDictionary<NSString *, id> *)attributes;

- (nullable NSArray *)availableFontNamesMatchingFontDescriptor:(NSFontDescriptor *)descriptor NS_DEPRECATED_MAC(10_0, 10_11, "Use -[NSFontDescriptor matchingFontDescriptorsWithMandatoryKeys:] instead");

@property (readonly, copy) NSArray *collectionNames NS_DEPRECATED_MAC(10_0, 10_11, "Use +[NSFontCollection allFontCollectionNames] instead");
- (nullable NSArray *)fontDescriptorsInCollection:(NSString *)collectionNames NS_DEPRECATED_MAC(10_0, 10_11, "Use -[NSFontCollection matchingDescriptors] instead");
- (BOOL)addCollection:(NSString *)collectionName options:(NSFontCollectionOptions)collectionOptions NS_DEPRECATED_MAC(10_0, 10_11, "Use +[NSFontCollection showFontCollection:withName:visibility:name:] instead");
- (BOOL)removeCollection:(NSString *)collectionName NS_DEPRECATED_MAC(10_0, 10_11, "Use +[NSFontCollection hideFontCollectionWithName:visibility:error:] instead");

- (void)addFontDescriptors:(NSArray *)descriptors  toCollection:(NSString *)collectionName NS_DEPRECATED_MAC(10_0, 10_11, "Use -[NSMutableFontCollection addQueryForDescriptors:] instead");
- (void)removeFontDescriptor:(NSFontDescriptor *)descriptor fromCollection:(NSString *)collection NS_DEPRECATED_MAC(10_0, 10_11, "Use -[NSMutableFontCollection removeQueryForDescriptors:] instead");

/* Returns the current font action used by -convertFont:. This method is intended to be invoked to query the font conversion action while the action message (usually -changeFont:) is being invoked.
 */
@property (readonly) NSFontAction currentFontAction NS_AVAILABLE_MAC(10_5);

/* Converts fontTraits to a new traits mask value just as -convertFont:. This method is intended to be invoked to query the font traits while the action message (usually -changeFont:) is being invoked when the current font action is either NSAddTraitFontAction or NSRemoveTraitFontAction.
 */
- (NSFontTraitMask)convertFontTraits:(NSFontTraitMask)traits NS_AVAILABLE_MAC(10_5);

@property (nullable, weak) id target NS_AVAILABLE_MAC(10_5);

@end

@interface NSFontManager(NSFontManagerMenuActionMethods)

- (BOOL)fontNamed:(NSString *)fName hasTraits:(NSFontTraitMask)someTraits;

/* The following is like "availableFonts", but checks traits.  Returns an auto-released instance.  To get fonts with "non-italic" or "non-bold" combine the flags NSUnitalicFontMask and/or NSUnboldFontMask as the argument "someTraits".
*/
- (nullable NSArray<NSString *> *)availableFontNamesWithTraits:(NSFontTraitMask)someTraits;

/* These methods are action messages sent from Font Menu items:
*/
- (void)addFontTrait:(nullable id)sender;
- (void)removeFontTrait:(nullable id)sender;
- (void)modifyFontViaPanel:(nullable id)sender;
- (void)modifyFont:(nullable id)sender;
- (void)orderFrontFontPanel:(nullable id)sender;
- (void)orderFrontStylesPanel:(nullable id)sender;

@end

/* This method is perhaps inappropriately named; it is sent to the delegate of the shared NSFontPanel instance, not to the delegate of the NSFontManager.
*/
@interface NSObject(NSFontManagerDelegate)
- (BOOL)fontManager:(id)sender willIncludeFont:(NSString *)fontName NS_DEPRECATED_MAC(10_0, 10_11, "Use NSFontCollection for providing filtered font lists");
@end

/* This is the message that's propagated up the responder chain.
*/
@interface NSObject(NSFontManagerResponderMethod)
- (void)changeFont:(nullable id)sender;
@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                                NSFontPanel.h                                                                                       0100644 0001750 0001750 00000007646 12567220725 033333  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSFontPanel.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSPanel.h>

NS_ASSUME_NONNULL_BEGIN

@class NSFontPanel, NSMutableDictionary, NSFontManager, NSMutableArray, NSTableView, NSFontDescriptor, NSFont;


@interface NSObject (NSFontPanelValidationAdditions)
- (NSUInteger) validModesForFontPanel: (NSFontPanel *) fontPanel;
@end


NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE
@interface NSFontPanel : NSPanel {
    /*All instance variables are private*/
    NSFontManager *_manager;
    NSArray *_collectionNames;
    id _selection;
    void *_carbonNotification; 
    id _targetObject;

    id			_familyList;
    id                  _faceList;
    id                  _sizeList;
    id                  _mainCollectionList;
    id			_sizeField;
    id                  _sizeSlider;
    id                  _sizeSliderBox;
    id			_preview;
    id			_previewContainer;
    id                  _mainSplitView;
    id			_mmCollectionList;	
    id			_mmFamilyList;
    id                  _mmFaceList;
    id                  _mmSizeList;
    id			_fullSizeHeightConstraint;
    id                  _searchField;
    id			_fixedListButton;
    id		        _sliderButton; 
    id		        _accessoryView; 
    struct __fpFlags {
	unsigned int	    setFontChange:1;
	unsigned int	    setFontAttributeChange:1;
	unsigned int	    _delRespFamily:1;
	unsigned int	    _delRespFace:1;
	unsigned int	    _delRespSize:1;
	unsigned int	    _delRespColl:1;
	unsigned int	    _collectionDisabled:1; // used by validate font panel modes. 
	unsigned int	    _sizeDisabled:1; // used by validate font panel modes. 
	unsigned int	    _faceDisabled:1; // used by validate font panel modes. 
        unsigned int        showEffects:1;
        unsigned int        _uiMode:8;
        unsigned int        _miniMode:1;
        unsigned int _reserved:13;
    } _fpFlags;

    id			_regularModeBox; 
    id			_miniModeBox; 
    id			_sizeBox;
    id			_collectionLabel; 
    id			_sizeLabel; 
    id                  _faceDivider;
    id                  _familyLabel;
    id			_sizeStyleButton; 
    id			_newSizeField; 
    id			_editSizeList; 
    id			_editSizeListBox; 
    id			_editSizeSliderBox; 
    id			_editSizeSliderMaxField; 
    id			_editSizeSliderMinField; 
    id			_sizeEditWindow; 
    id			_availableSizes; 

    id _addCollectionButton;
    id _removeCollectionButton;

    CGFloat _fontPanelPreviewHeight; 
    id _typographyPanel;
    id _actionButton;
    id _fontEffectsBox;
    int _sizeStyle;

#if !__LP64__
    id _fpUnused[72];
#endif /* !__LP64__ */
}

+ (NSFontPanel *)sharedFontPanel;
+ (BOOL)sharedFontPanelExists;

@property (nullable, strong) NSView *accessoryView;
- (void)setPanelFont:(NSFont *)fontObj isMultiple:(BOOL)flag;
- (NSFont *)panelConvertFont:(NSFont *)fontObj;
@property BOOL worksWhenModal;
@property (getter=isEnabled) BOOL enabled;

/* This method triggers a re-load to the default state, so that the delegate will be called, and have an opportunity to scrutinize the default list of fonts to be displayed in the panel.
*/
- (void) reloadDefaultFontFamilies;

@end


enum {
    NSFontPanelFaceModeMask = 1 << 0,
    NSFontPanelSizeModeMask = 1 << 1,
    NSFontPanelCollectionModeMask = 1 << 2,
    NSFontPanelUnderlineEffectModeMask = 1<<8,
    NSFontPanelStrikethroughEffectModeMask = 1<<9,
    NSFontPanelTextColorEffectModeMask = 1<< 10,
    NSFontPanelDocumentColorEffectModeMask = 1<<11,
    NSFontPanelShadowEffectModeMask = 1<<12,
    NSFontPanelAllEffectsModeMask = 0XFFF00,
    NSFontPanelStandardModesMask = 0xFFFF,
    NSFontPanelAllModesMask = 0xFFFFFFFF
};

/* Tags of views in the FontPanel
 THESE ARE ALL OBSOLETE and should not be used.
 */
enum {
    NSFPPreviewButton			= 131,
    NSFPRevertButton			= 130,
    NSFPSetButton			= 132,
    NSFPPreviewField			= 128,
    NSFPSizeField			= 129,
    NSFPSizeTitle			= 133,
    NSFPCurrentField			= 134
} NS_ENUM_DEPRECATED_MAC(10_0, 10_0);

NS_ASSUME_NONNULL_END
                                                                                          NSForm.h                                                                                            0100644 0001750 0001750 00000004261 12567220725 032336  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSForm.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSMatrix.h>

NS_ASSUME_NONNULL_BEGIN

@class NSFormCell;

NS_CLASS_DEPRECATED_MAC(10_0, 10_10, "Use NSTextField directly instead, and consider NSStackView for layout assistance")
@interface  NSForm : NSMatrix

- (NSInteger)indexOfSelectedItem;
- (void)setEntryWidth:(CGFloat)width;
- (void)setInterlineSpacing:(CGFloat)spacing;
- (void)setBordered:(BOOL)flag;
- (void)setBezeled:(BOOL)flag;
- (void)setTitleAlignment:(NSTextAlignment)mode;
- (void)setTextAlignment:(NSTextAlignment)mode;
- (void)setTitleFont:(NSFont *)fontObj;
- (void)setTextFont:(NSFont *)fontObj;
- (null_unspecified id)cellAtIndex:(NSInteger)index;
- (void)drawCellAtIndex:(NSInteger)index;
- (NSFormCell *)addEntry:(NSString *)title;
- (null_unspecified NSFormCell *)insertEntry:(NSString *)title atIndex:(NSInteger)index;
- (void)removeEntryAtIndex:(NSInteger)index;
- (NSInteger)indexOfCellWithTag:(NSInteger)aTag;
- (void)selectTextAtIndex:(NSInteger)index;
- (void)setFrameSize:(NSSize)newSize;
- (void)setTitleBaseWritingDirection:(NSWritingDirection)writingDirection;
- (void)setTextBaseWritingDirection:(NSWritingDirection)writingDirection;

/* Determine the preferred width of the text field portion of the receiver's cells. The preferred width is reflected in the cell's cellSize, which will be large enough to accommodate the title, bezel, and a text field of width preferredTextWidth. It is also reflected in the intrinsicContentSize of the NSForm. That is, under autolayout, the NSForm will try to size itself so that the text field cell is the given width, according to the usual content size constraint priorities.
 
 If the width is negative, the cellSize matches the historic behavior, which is that it is large enough to accommodate the title, bezel, and the current text. The default is -1.

 This method can aid migration to autolayout, and is sufficient for simple cases. However, for new apps, prefer to use NSTextFields directly instead of NSForm.
*/
- (void)setPreferredTextFieldWidth:(CGFloat)preferredWidth NS_AVAILABLE_MAC(10_8);
- (CGFloat)preferredTextFieldWidth NS_AVAILABLE_MAC(10_8);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                               NSFormCell.h                                                                                        0100644 0001750 0001750 00000004064 12567220725 033137  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSFormCell.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <AppKit/NSActionCell.h>

NS_ASSUME_NONNULL_BEGIN

@interface NSFormCell : NSActionCell
{
    /*All instance variables are private*/
    CGFloat	_titleWidth;
    id		_titleCell;
    CGFloat	_titleEndPoint;
#if __LP64__
    CGFloat    _preferredTextFieldWidth;
#endif
}

- (instancetype)initTextCell:(nullable NSString *)aString;

- (CGFloat)titleWidth:(NSSize)aSize;
@property CGFloat titleWidth;
@property (copy) NSString *title;
@property (strong) NSFont *titleFont;
@property NSTextAlignment titleAlignment;
@property (getter=isOpaque, readonly) BOOL opaque;

@property (nullable, copy) NSString *placeholderString;
@property (nullable, copy) NSAttributedString *placeholderAttributedString;

@property NSWritingDirection titleBaseWritingDirection;


/* Determine the preferred width of the text field portion of the receiver. The preferred width is reflected in the cell's cellSize, which will be large enough to accommodate the title, bezel, and a text field of width preferredTextWidth. It is also reflected in the intrinsicContentSize of the NSForm. That is, under autolayout, the NSForm will try to size itself so that the text field cell is the given width, according to the usual content size constraint priorities.
 
 If the width is negative, the cellSize matches the historic behavior, which is that it is large enough to accommodate the title, bezel, and the current text. The default is -1.
 
 This method can aid migration to autolayout, and is sufficient for simple cases. However, for new apps, prefer to use NSTextFields directly instead of NSForm.
 */
@property CGFloat preferredTextFieldWidth NS_AVAILABLE_MAC(10_8);

@end

@interface NSFormCell(NSKeyboardUI)
/* Deprecated in 10.8 and higher. Use setTitle: instead.
 */
- (void)setTitleWithMnemonic:(null_unspecified NSString *)stringWithAmpersand NS_DEPRECATED_MAC(10_0, 10_8);
@end

@interface NSFormCell(NSFormCellAttributedStringMethods)
@property (copy) NSAttributedString *attributedTitle;
@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            NSGestureRecognizer.h                                                                               0100644 0001750 0001750 00000024522 12567220725 035103  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
    NSGestureRecognizer.h
    Application Kit
    Copyright (c) 2013-2015, Apple Inc.
    All rights reserved.
*/

#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol NSGestureRecognizerDelegate;
@class NSView, NSEvent, NSPressureConfiguration;

NS_ENUM_AVAILABLE_MAC(10_10)
typedef NS_ENUM(NSInteger, NSGestureRecognizerState) {
    NSGestureRecognizerStatePossible,   // the recognizer has not yet recognized its gesture, but may be evaluating events. this is the default state
    
    NSGestureRecognizerStateBegan,      // the recognizer has received events recognized as the gesture. the action method will be called at the next turn of the run loop
    NSGestureRecognizerStateChanged,    // the recognizer has received events recognized as a change to the gesture. the action method will be called at the next turn of the run loop
    NSGestureRecognizerStateEnded,      // the recognizer has received events recognized as the end of the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to NSGestureRecognizerStatePossible
    NSGestureRecognizerStateCancelled,  // the recognizer has received events resulting in the cancellation of the gesture. the action method will be called at the next turn of the run loop. the recognizer will be reset to NSGestureRecognizerStatePossible
    
    NSGestureRecognizerStateFailed,     // the recognizer has received an event sequence that can not be recognized as the gesture. the action method will not be called and the recognizer will be reset to NSGestureRecognizerStatePossible
    
    // Discrete Gestures  gesture recognizers that recognize a discrete event but do not report changes (for example, a click) do not transition through the Began and Changed states and can not fail or be cancelled
    NSGestureRecognizerStateRecognized = NSGestureRecognizerStateEnded // the recognizer has received events recognized as the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to NSGestureRecognizerStatePossible
};

NS_CLASS_AVAILABLE_MAC(10_10)
@interface NSGestureRecognizer : NSObject <NSCoding> {
  @private
    NSMutableArray                   *_targets;
    __weak id                        _target;
    SEL                              _action;
    NSMutableArray                   *_delayedEvents;
    __weak NSView                    *_view;
    NSEvent                          *_updateEvent;
    __weak id <NSGestureRecognizerDelegate>  _delegate;
    NSMutableSet                     *_friends;
    NSGestureRecognizerState          _state;
    NSUInteger                        _gestureFlags;
    NSUInteger                        _delayFlags;
    
    NSMutableSet                     *_failureRequirements;
    NSMutableSet                     *_failureDependents;
    NSMutableSet                     *_dynamicFailureRequirements;
    NSMutableSet                     *_dynamicFailureDependents;
    id                                _failureMap;
    
    id                                _reserved;
}

/* valid action method signatures:
     -(void)handleGesture;
     -(void)handleGesture:(NSGestureRecognizer*)gestureRecognizer;
*/
- (instancetype)initWithTarget:(id)target action:(nullable SEL)action NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;

@property (nullable, weak) id target;
@property (nullable) SEL action;

/* the current state of the gesture recognizer */
@property (readonly) NSGestureRecognizerState state;

/* the gesture recognizer's delegate */
@property (nullable, weak) id <NSGestureRecognizerDelegate> delegate;

/* default is YES. disabled gesture recognizers will not receive events. when changed to NO the gesture recognizer will be cancelled if it's currently recognizing a gesture */
@property (getter=isEnabled) BOOL enabled;

/* an NSGestureRecognizer receives events hit-tested to its view and any of that view's subviews
   the view the gesture is attached to. set by adding the recognizer to a NSView using the addGestureRecognizer: method
*/
@property (nullable, readonly) NSView *view;

/* The pressure configuration the view should use when this recognizer is eligible for recognition. At any point in time during recognition the view's effective pressure configuration will be the most compatible configuration among the set of active recognizers. This property may be set at any time before or during recognition. If recognition fails, the effective configuration will revert to the view's -pressureConfiguration. */
@property (strong) NSPressureConfiguration *pressureConfiguration NS_AVAILABLE_MAC(10_11);

/*  causes the specified events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any events that may be recognized as part of this gesture. note: once a gesture recognizer starts delaying one type of event, all event types are delayed until this gesture has failed recognition. refer to specific gesture subclasses as they have different defaults.
*/
@property BOOL delaysPrimaryMouseButtonEvents;      // default is NO.
@property BOOL delaysSecondaryMouseButtonEvents;    // default is NO.
@property BOOL delaysOtherMouseButtonEvents;        // default is NO.
@property BOOL delaysKeyEvents;                     // default is NO.
@property BOOL delaysMagnificationEvents;           // default is NO.
@property BOOL delaysRotationEvents;                // default is NO.

/* individual NSGestureRecognizer subclasses may provide subclass-specific location information. see individual subclasses for details */
- (NSPoint)locationInView:(nullable NSView*)view;

@end


@protocol NSGestureRecognizerDelegate <NSObject>
@optional
/* called when the window begins a new recognition stream
 return YES to allow the recognizer to process events. return NO to fail recognition and opt the recognizer out of the event stream
 */
- (BOOL)gestureRecognizer:(NSGestureRecognizer *)gestureRecognizer shouldAttemptToRecognizeWithEvent:(NSEvent *)event NS_AVAILABLE_MAC(10_11);

/* called when a gesture recognizer attempts to transition out of NSGestureRecognizerStatePossible. returning NO causes it to transition to NSGestureRecognizerStateFailed */
- (BOOL)gestureRecognizerShouldBegin:(NSGestureRecognizer *)gestureRecognizer;

/* called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other
   return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)

   note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture's delegate may return YES
*/
- (BOOL)gestureRecognizer:(NSGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)otherGestureRecognizer;

/* called once per attempt to recognize, so failure requirements can be determined lazily and may be set up between recognizers across view hierarchies
   return YES to set up a dynamic failure requirement between gestureRecognizer and otherGestureRecognizer

   note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture's counterpart delegate or subclass methods may return YES
*/
- (BOOL)gestureRecognizer:(NSGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)otherGestureRecognizer;
- (BOOL)gestureRecognizer:(NSGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)otherGestureRecognizer;

@end

// the extensions in this header are to be used only by subclasses of NSGestureRecognizer
// code that uses NSGestureRecognizers must never call these

@interface NSGestureRecognizer (NSSubclassUse)

// readonly for users of a gesture recognizer. may only be changed by direct subclasses of NSGestureRecognizer
@property NSGestureRecognizerState state;  // the current state of the gesture recognizer. can only be set by subclasses of NSGestureRecognizer, but can be read by consumers

// the following methods are to be overridden by subclasses of NSGestureRecognizer
// if you override one you must call super

// called automatically by the runtime after the gesture state has been set to NSGestureRecognizerStateEnded
// any internal state should be reset to prepare for a new attempt to recognize the gesture
// after this is received all remaining active touches will be ignored (no further updates will be received for touches that had already begun but haven't ended)
- (void)reset;

// same behavior as the equivalent delegate methods, but can be used by subclasses to define class-wide prevention rules
// for example, a NSTapGestureRecognizer never prevents another NSTapGestureRecognizer with a higher tap count
- (BOOL)canPreventGestureRecognizer:(NSGestureRecognizer *)preventedGestureRecognizer;
- (BOOL)canBePreventedByGestureRecognizer:(NSGestureRecognizer *)preventingGestureRecognizer;

// same behavior as the equivalent delegate methods, but can be used by subclasses to define class-wide failure requirements
- (BOOL)shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)otherGestureRecognizer;
- (BOOL)shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)otherGestureRecognizer;

// mirror of the event-delivery methods on NSResponder
// NSGestureRecognizers aren't in the responder chain, but observe events hit-tested to their view and their view's subviews
// NSGestureRecognizers receive events before the view to which the event was hit-tested
- (void)mouseDown:(NSEvent *)event;
- (void)rightMouseDown:(NSEvent *)event;
- (void)otherMouseDown:(NSEvent *)event;
- (void)mouseUp:(NSEvent *)event;
- (void)rightMouseUp:(NSEvent *)event;
- (void)otherMouseUp:(NSEvent *)event;
- (void)mouseDragged:(NSEvent *)event;
- (void)rightMouseDragged:(NSEvent *)event;
- (void)otherMouseDragged:(NSEvent *)event;
- (void)keyDown:(NSEvent *)event;
- (void)keyUp:(NSEvent *)event;
- (void)flagsChanged:(NSEvent *)event;
- (void)tabletPoint:(NSEvent *)event;
- (void)magnifyWithEvent:(NSEvent *)event;
- (void)rotateWithEvent:(NSEvent *)event;
- (void)pressureChangeWithEvent:(NSEvent *)event NS_AVAILABLE_MAC(10_10_3);

@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                              NSGlyphGenerator.h                                                                                  0100644 0001750 0001750 00000002412 12567220725 034361  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSGlyphGenerator.h
        Application Kit
        Copyright (c) 1993-2015, Apple Inc.
        All rights reserved.
*/

#import <Foundation/NSAttributedString.h>
#import <AppKit/NSFont.h> // for NSGlyph

/* NSGlyphStorage layout options */
NS_ASSUME_NONNULL_BEGIN

enum {
    NSShowControlGlyphs = (1 << 0), // if set, generates displayable glyphs for control chars
    NSShowInvisibleGlyphs = (1 << 1), // if set, generates displayable glyphs for invisible chars
    NSWantsBidiLevels = (1 << 2) // if set, generates bidi levels
};

@protocol NSGlyphStorage
- (void)insertGlyphs:(const NSGlyph *)glyphs length:(NSUInteger)length forStartingGlyphAtIndex:(NSUInteger)glyphIndex characterIndex:(NSUInteger)charIndex;

// sets glyph attribute defined in NSLayoutManager.h
- (void)setIntAttribute:(NSInteger)attributeTag value:(NSInteger)val forGlyphAtIndex:(NSUInteger)glyphIndex;

- (NSAttributedString *)attributedString;
- (NSUInteger)layoutOptions;
@end

@interface NSGlyphGenerator : NSObject
- (void)generateGlyphsForGlyphStorage:(id <NSGlyphStorage>)glyphStorage desiredNumberOfCharacters:(NSUInteger)nChars glyphIndex:(nullable NSUInteger *)glyphIndex characterIndex:(nullable NSUInteger *)charIndex;

+ (NSGlyphGenerator *)sharedGlyphGenerator;
@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                      NSGlyphInfo.h                                                                                       0100644 0001750 0001750 00000003252 12567220725 033331  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*	
	NSGlyphInfo.h
	Copyright (c) 2002-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSString.h>
#import <AppKit/NSFont.h>

NS_ASSUME_NONNULL_BEGIN

typedef NS_ENUM(NSUInteger, NSCharacterCollection) {
    NSIdentityMappingCharacterCollection = 0, // Identity mapping (CID == NSGlyph)
    NSAdobeCNS1CharacterCollection = 1, // Adobe-CNS1
    NSAdobeGB1CharacterCollection = 2, // Adobe-GB1
    NSAdobeJapan1CharacterCollection = 3, // Adobe-Japan1
    NSAdobeJapan2CharacterCollection = 4, // Adobe-Japan2
    NSAdobeKorea1CharacterCollection = 5, // Adobe-Korea1
};

@interface NSGlyphInfo : NSObject <NSCopying, NSSecureCoding> {
    NSString *_baseString;
}

// Returns an NSGlyphInfo object for the glyph name such as "copyright."
+ (nullable NSGlyphInfo *)glyphInfoWithGlyphName:(NSString *)glyphName forFont:(NSFont *)font baseString:(NSString *)theString;

// Returns an NSGlyphInfo object for the NSGlyph glyph
+ (nullable NSGlyphInfo *)glyphInfoWithGlyph:(NSGlyph)glyph forFont:(NSFont *)font baseString:(NSString *)theString;

// Returns an NSGlyphInfo object for the CID/RO
+ (nullable NSGlyphInfo *)glyphInfoWithCharacterIdentifier:(NSUInteger)cid collection:(NSCharacterCollection)characterCollection baseString:(NSString *)theString;

// Returns the glyph name.  If the receiver is instantiated without glyph name, returns nil
@property (nullable, readonly, copy) NSString *glyphName;

// Returns CID
@property (readonly) NSUInteger characterIdentifier;

// Returns RO (character collection).  Returns NSIdentityMappingCharacterCollection if instantiated with NSGlyph or glyph name
@property (readonly) NSCharacterCollection characterCollection;
@end

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                      NSGradient.h                                                                                        0100644 0001750 0001750 00000022470 12567220726 033173  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSGradient.h
	Application Kit
	Copyright (c) 2006-2015, Apple Inc.
	All rights reserved.
*/


#import <Foundation/NSObject.h>
#import <Foundation/NSArray.h>
#import <Foundation/NSGeometry.h>


NS_ASSUME_NONNULL_BEGIN

@class NSBezierPath, NSColor, NSColorSpace;

typedef NSUInteger NSGradientDrawingOptions;

enum {
    NSGradientDrawsBeforeStartingLocation =   (1 << 0),
    NSGradientDrawsAfterEndingLocation =    (1 << 1),
};

/* An NSGradient defines a transition between colors.  The transition is defined over a range from 0.0 to 1.0 inclusive.  A gradient typically contains a color at location 0.0, and one at location 1.0 with additional colors assigned to locations between 0.0 and 1.0.

An NSGradient is a drawing primitive that can draw itself as a linear or radial gradient.  The color value at location 0.0 is considered the starting color, the color value at location 1.0 is considered the ending color.  A primitive drawing method is provided for both linear and radial gradients.  Each primitive drawing method provides flexibility in specifying the location of its respective gradient.  These primitive drawing methods perform no clipping before drawing.

In addition, convenience drawing methods take a rectangle or path, and automatically calculate staring and ending locations and perform clipping to provide a convenient means for drawing gradient fills.  Two of the convenience methods are demonstrated below:


The following code will fill a rectangle with a 45 degree linear gradient, from black to white:
	
	NSRect rect; // assume this exists
	NSGradient *gradient = [[NSGradient alloc] initWithStartingColor: [NSColor blackColor] endingColor: [NSColor whiteColor]];
	[gradient drawInRect: rect angle: 45.0];
	[gradient release];
	
The following code will fill an arbitrary bezier path with a radial gradient, from the center of the path's bounding box, that transitions through three colors, evenly distributed in the gradient from 0.0 to 1.0.

	NSBezierPath *path // assume this exists
	NSArray *colorArray = [NSArray arrayWithObjects: [NSColor blueColor], [NSColor yellowColor], [NSColor orangeColor], nil];
	NSGradient *gradient = [[NSGradient alloc] initWithColors: colorArray];
	[gradient drawInBezierPath: path relativeCenterPosition: NSZeroPoint];
	[gradient release];
	
An NSGradient has a color space.  When initialized, all colors provided are converted to that color space, and interpolation of colors occurs using the components of that color space.  The designated initializer takes a color space argument, all other initializers use the default generic RGB color space.

*/

NS_CLASS_AVAILABLE(10_5, NA)
@interface NSGradient : NSObject <NSCopying, NSCoding> {
@private
    NSArray *_colorArray;
    NSColorSpace *_colorSpace;
    __strong void *_functionRef;
    void *_componentArray;
    void *_reserved1;
    void *_reserved2;
    void *_reserved3;
}


/* Initializes a gradient with starting color at location 0.0 and ending color at location 1.0  The color space returned by [NSColorSpace genericRGBColorSpace] is used.
*/
- (nullable instancetype)initWithStartingColor:(NSColor *)startingColor endingColor:(NSColor *)endingColor;


/* Initializes a gradient with the first color in the array at 0.0, the last color in the array at 1.0, and intervening colors at equal intervals in between. The color space returned by [NSColorSpace genericRGBColorSpace] is used.
*/
- (nullable instancetype)initWithColors:(NSArray<NSColor *> *)colorArray;


/* This initializer takes the first color, then the first location as a CGFloat, then an alternating list of colors and CGFloats, terminated by nil.  If no color is provided for 0.0 or 1.0, the created color gradient will use the color provided at the locations closest to 0.0 and 1.0 for those values.  The color space returned by [NSColorSpace genericRGBColorSpace] is used.

    For example:
    NSGradient *gradient = [[NSGradient alloc] initWithColorsAndLocations: [NSColor blackColor], 0.0, [NSColor blueColor], 0.33, [NSColor cyanColor], 0.45, [NSColor orangeColor], 0.72, [NSColor redColor], 1.0, nil];

*/
- (nullable instancetype)initWithColorsAndLocations:(NSColor *)firstColor, ... NS_REQUIRES_NIL_TERMINATION;


/* Initializes a gradient by pairing the colors provided in the color array with the locations provided in the locations array.    Each location should be a CGFloat between 0.0 and 1.0.  The color array and location array should not be empty, and should contain the same number of items.  If no color is provided for 0.0 or 1.0, the created color gradient will use the color provided at the locations closest to 0.0 and 1.0 for those values.  This is the designated initializer.
*/
- (nullable instancetype)initWithColors:(NSArray<NSColor *> *)colorArray atLocations:(nullable const CGFloat *)locations colorSpace:(NSColorSpace *)colorSpace;


/* DRAWING LINEAR GRADIENTS */

/* Draws a linear gradient from start point to end point.  The option flags control whether the gradient draws itself before the start point, or after the end point.  The gradient is drawn in the current graphics context without performing any additinal clipping.  This is the primitive method for drawing a linear gradient.
*/
- (void)drawFromPoint:(NSPoint)startingPoint toPoint:(NSPoint)endingPoint options:(NSGradientDrawingOptions)options;


/* Convenience method for drawing a linear gradient to fill a rectangle.  Draws a linear gradient clipped to the provided rect.  The start point and end point are calculated with respect to the provided rect so that the gradient is drawn at the provided angle in degrees.  The end points are located such that both the start and end color in the gradient are visible in the rect.
*/
- (void)drawInRect:(NSRect)rect angle:(CGFloat)angle;


/* Convenience method for drawing a linear gradient to fill a path.  Draws a linear gradient clipped by the provided path.  The start point and end point are calculated with respect to the provided path so that the gradient is drawn at the provided angle in degrees. The end points are located such that both the start and end color in the gradient are visible in the path.
*/
- (void)drawInBezierPath:(NSBezierPath *)path angle:(CGFloat)angle;


/* DRAWING RADIAL GRADIENTS */

/* Draws a radial gradient between two circles defined by the center point and radius of each circle.  The option flags control whether the gradient draws itself before the start point, or after the end point.  The gradient is drawn in the current graphics context without performing any additinal clipping.  This is the primitive method for drawing a radial gradient.
*/
- (void)drawFromCenter:(NSPoint)startCenter radius:(CGFloat)startRadius toCenter:(NSPoint)endCenter radius:(CGFloat)endRadius options:(NSGradientDrawingOptions)options;


/* Convenience method for drawing a radial gradient to fill a rect.  Draws a radial gradient clipped by the provided rect.  The starting circle is always a single point located at the center of the ending circle which encloses the drawn rect.  The radius of the ending circle is determined by the relative center position.

    The relative center position proportionally adjusts the center location of the radial gradient.  It maps the four corners of the rectangle to (-1.0, -1.0), (1.0, -1.0), (1.0, 1.0) and (-1.0, 1.0), with (0.0, 0.0) in the center of the rectangle.  Use NSZeroPoint to center the radial gradient in the rect.  The radius of the ending circle is the distance from the relative center to the opposite corner of the rect.
*/
- (void)drawInRect:(NSRect)rect relativeCenterPosition:(NSPoint)relativeCenterPosition;


/* Convenience method for drawing a radial gradient to fill a path.  Draws a radial gradient clipped by the provided path.  The starting circle is always a single point located at the center of the ending circle which encloses the drawn path.  The radius of the ending circle is determined by the relative center position.

    The relative center position proportionally adjusts the center location of the radial gradient.  It maps the four corners of the path bounding rect to (-1.0, -1.0), (1.0, -1.0), (1.0, 1.0) and (-1.0, 1.0), with (0.0, 0.0) in the center of path bounding rect.  Use NSZeroPoint to center the radial gradient in the path bounding rect.  The radius of the ending circle is the distance from the relative center to the opposite corner of the path bounding rect.
*/
- (void)drawInBezierPath:(NSBezierPath *)path relativeCenterPosition:(NSPoint)relativeCenterPosition;




/* These methods are primarily for the use of controls which manipulate the color gradient.
*/

/* Returns the color space of the gradient */
@property (readonly, strong) NSColorSpace *colorSpace;


/* The number of color stops in the color gradient */
@property (readonly) NSInteger numberOfColorStops;


/* Returns the color and location at a particular index in the color gradient */
- (void)getColor:(NSColor * __nonnull * __nullable)color location:(nullable CGFloat *)location atIndex:(NSInteger)index;


/* This method will return the interpolated gradient value at the given location.  For example, in a two color gradient with white at location 0.0 and black at location 1.0, the interpolated color at location 0.5 would be 50% gray.

You should not need to override this method, it reports the color value of the gradient at a particular location, and does not affect the drawn color values.
*/
- (NSColor *)interpolatedColorAtLocation:(CGFloat)location;


@end

NS_ASSUME_NONNULL_END

                                                                                                                                                                                                        NSGraphics.h                                                                                        0100644 0001750 0001750 00000030066 12567220725 033175  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
	NSGraphics.h
	Application Kit
	Copyright (c) 1994-2015, Apple Inc.
	All rights reserved.
*/

#import <Foundation/NSGeometry.h> 
#import <AppKit/AppKitDefines.h>

NS_ASSUME_NONNULL_BEGIN

@class NSColor, NSView;

/*=== CONSTANTS ===*/
/* operation types for composite operators */
/* Constants moved from dpsOpenStep.h */
typedef NS_ENUM(NSUInteger, NSCompositingOperation) {
    /* Porter-Duff compositing operations */
    /* http://www.w3.org/TR/2014/CR-compositing-1-20140220/#porterduffcompositingoperators */
    NSCompositeClear,		
    NSCompositeCopy,		
    NSCompositeSourceOver,	
    NSCompositeSourceIn,	
    NSCompositeSourceOut,	
    NSCompositeSourceAtop,	
    NSCompositeDestinationOver,	
    NSCompositeDestinationIn,	
    NSCompositeDestinationOut,	
    NSCompositeDestinationAtop,	
    NSCompositeXOR,		
    NSCompositePlusDarker,
    NSCompositeHighlight	NS_DEPRECATED_MAC(10_0, 10_0, "Use NSCompositeSourceOver instead"),
    NSCompositePlusLighter,
    
    /* Separable blend-modes */
    /* http://www.w3.org/TR/2014/CR-compositing-1-20140220/#blendingseparable */
    NSCompositeMultiply		NS_AVAILABLE_MAC(10_10),
    NSCompositeScreen		NS_AVAILABLE_MAC(10_10),
    NSCompositeOverlay		NS_AVAILABLE_MAC(10_10),
    NSCompositeDarken		NS_AVAILABLE_MAC(10_10),
    NSCompositeLighten		NS_AVAILABLE_MAC(10_10),
    NSCompositeColorDodge	NS_AVAILABLE_MAC(10_10),
    NSCompositeColorBurn	NS_AVAILABLE_MAC(10_10),
    NSCompositeSoftLight	NS_AVAILABLE_MAC(10_10),
    NSCompositeHardLight	NS_AVAILABLE_MAC(10_10),
    NSCompositeDifference	NS_AVAILABLE_MAC(10_10),
    NSCompositeExclusion	NS_AVAILABLE_MAC(10_10),
    
    /* Non-separable blend-modes */
    /* http://www.w3.org/TR/2014/CR-compositing-1-20140220/#blendingnonseparable */
    NSCompositeHue		NS_AVAILABLE_MAC(10_10),
    NSCompositeSaturation	NS_AVAILABLE_MAC(10_10),
    NSCompositeColor		NS_AVAILABLE_MAC(10_10),
    NSCompositeLuminosity	NS_AVAILABLE_MAC(10_10),
};


/* types of window backing store */
typedef NS_ENUM(NSUInteger, NSBackingStoreType) {
    NSBackingStoreRetained	 = 0,
    NSBackingStoreNonretained	 = 1,
    NSBackingStoreBuffered	 = 2
};

/* ways to order windows */
typedef NS_ENUM(NSInteger, NSWindowOrderingMode) {
    NSWindowAbove		 =  1,
    NSWindowBelow		 = -1,
    NSWindowOut			 =  0
};

/* order in which to draw focus ring - above or below graphic or just draw ring */
typedef NS_ENUM(NSUInteger, NSFocusRingPlacement) {
    NSFocusRingOnly	 = 0,
    NSFocusRingBelow	 = 1,
    NSFocusRingAbove	 = 2
};

/* used by NSView and NSCell to configure if and how the control should draw its focus ring */
typedef NS_ENUM(NSUInteger, NSFocusRingType) {
    NSFocusRingTypeDefault = 0,
    NSFocusRingTypeNone = 1,
    NSFocusRingTypeExterior = 2
};


// values interchangeable with CGColorRenderingIntent values
typedef NS_ENUM(NSInteger, NSColorRenderingIntent) {
    NSColorRenderingIntentDefault, //  = kCGRenderingIntentDefault,
    NSColorRenderingIntentAbsoluteColorimetric, //  = kCGRenderingIntentAbsoluteColorimetric,
    NSColorRenderingIntentRelativeColorimetric, //  = kCGRenderingIntentRelativeColorimetric,
    NSColorRenderingIntentPerceptual, // = kCGRenderingIntentPerceptual,
    NSColorRenderingIntentSaturation // = kCGRenderingIntentSaturation
} NS_ENUM_AVAILABLE_MAC(10_5);


/* Predefined colorspace names.
*/
APPKIT_EXTERN NSString *NSCalibratedWhiteColorSpace;	/* 1.0 == white */
APPKIT_EXTERN NSString *NSCalibratedRGBColorSpace;
APPKIT_EXTERN NSString *NSDeviceWhiteColorSpace;	/* 1.0 == white */
APPKIT_EXTERN NSString *NSDeviceRGBColorSpace;
APPKIT_EXTERN NSString *NSDeviceCMYKColorSpace;
APPKIT_EXTERN NSString *NSNamedColorSpace;		/* Used for "catalog" colors */
APPKIT_EXTERN NSString *NSPatternColorSpace;
APPKIT_EXTERN NSString *NSCustomColorSpace;		/* Used to indicate a custom gstate in images */

/* Prefer colorspaces where 1.0 means white.
 */
APPKIT_EXTERN NSString *NSCalibratedBlackColorSpace     /* 1.0 == black */ NS_DEPRECATED_MAC(10_0, 10_6);	
APPKIT_EXTERN NSString *NSDeviceBlackColorSpace 	/* 1.0 == black */ NS_DEPRECATED_MAC(10_0, 10_6);


/* NSWindowDepth defines the values used in setting window depth limits. "0" indicates default depth. Window depths should not be made persistent as they will not be the same across systems. Use the functions NSBitsPerSampleFromDepth(), NSColorSpaceFromDepth(), NSBitsPerPixelFromDepth(), and NSPlanarFromDepth() to extract info from an NSWindowDepth 

On Mac OS X 10.5 and earlier, use NSBestDepth() to compute window depths. NSBestDepth() will try to accomodate all the parameters (match or better); if there are multiple matches, it gives the closest, with matching colorSpace first, then bps, then planar, then bpp. bpp is "bits per pixel"; 0 indicates default (same as the number of bits per plane, either bps or bps * NSNumberOfColorComponents()); other values maybe used as hints to provide backing stores of different configuration; for instance, 8 bit color. exactMatch is optional and indicates whether all the parameters matched exactly.

On Mac OS X 10.6 and later, you can pass one of the explicit bit depths below to -[NSWindow setDepthLimit:].  NSWindowDepthTwentyfourBitRGB is the default.
*/
enum {
    NSWindowDepthTwentyfourBitRGB = 0x208,
    NSWindowDepthSixtyfourBitRGB = 0x210,
    NSWindowDepthOnehundredtwentyeightBitRGB = 0x220
} NS_ENUM_AVAILABLE_MAC(10_6);

typedef int NSWindowDepth;

APPKIT_EXTERN NSWindowDepth NSBestDepth (NSString *colorSpace, NSInteger bps, NSInteger bpp, BOOL planar, BOOL * __nullable exactMatch);
APPKIT_EXTERN BOOL NSPlanarFromDepth (NSWindowDepth depth);
APPKIT_EXTERN NSString * __nullable NSColorSpaceFromDepth (NSWindowDepth depth);
APPKIT_EXTERN NSInteger NSBitsPerSampleFromDepth(NSWindowDepth depth);
APPKIT_EXTERN NSInteger NSBitsPerPixelFromDepth(NSWindowDepth depth);
APPKIT_EXTERN NSInteger NSNumberOfColorComponents(NSString *colorSpaceName);
APPKIT_EXTERN const NSWindowDepth *NSAvailableWindowDepths (void); /* 0 terminated */


/* Standard gray values for the 2-bit deep grayscale colorspace.
*/
APPKIT_EXTERN const CGFloat NSWhite;
APPKIT_EXTERN const CGFloat NSLightGray;
APPKIT_EXTERN const CGFloat NSDarkGray;
APPKIT_EXTERN const CGFloat NSBlack;


/* Keys for deviceDescription dictionaries.
*/
APPKIT_EXTERN NSString *NSDeviceResolution;		/* NSValue containing NSSize, basically dpi */
APPKIT_EXTERN NSString *NSDeviceColorSpaceName;	/* NSString */
APPKIT_EXTERN NSString *NSDeviceBitsPerSample;		/* NSValue containing int */
APPKIT_EXTERN NSString *NSDeviceIsScreen;		/* "YES" or not there */
APPKIT_EXTERN NSString *NSDeviceIsPrinter;		/* "YES" or not there */
APPKIT_EXTERN NSString *NSDeviceSize;			/* NSValue containing NSSize */


/* Graphics functions
*/
APPKIT_EXTERN void NSRectFill(NSRect aRect);
APPKIT_EXTERN void NSRectFillList(const NSRect *rects, NSInteger count);
APPKIT_EXTERN void NSRectFillListWithGrays(const NSRect *rects, const CGFloat *grays, NSInteger num);
APPKIT_EXTERN void NSRectFillListWithColors(const NSRect *rects,  NSColor * const __nonnull * __nonnull colors, NSInteger num);
APPKIT_EXTERN void NSRectFillUsingOperation(NSRect aRect, NSCompositingOperation op);
APPKIT_EXTERN void NSRectFillListUsingOperation(const NSRect *rects, NSInteger count, NSCompositingOperation op);
APPKIT_EXTERN void NSRectFillListWithColorsUsingOperation(const NSRect *rects, NSColor * const __nonnull * __nonnull colors, NSInteger num, NSCompositingOperation op);
APPKIT_EXTERN void NSFrameRect(NSRect aRect);
APPKIT_EXTERN void NSFrameRectWithWidth(NSRect aRect, CGFloat frameWidth);
APPKIT_EXTERN void NSFrameRectWithWidthUsingOperation(NSRect aRect, CGFloat frameWidth, NSCompositingOperation op);
APPKIT_EXTERN void NSRectClip(NSRect aRect);
APPKIT_EXTERN void NSRectClipList(const NSRect *rects, NSInteger count);
APPKIT_EXTERN NSRect NSDrawTiledRects(NSRect boundsRect, NSRect clipRect, const NSRectEdge *sides, const CGFloat *grays, NSInteger count);
APPKIT_EXTERN void NSDrawGrayBezel(NSRect aRect, NSRect clipRect);
APPKIT_EXTERN void NSDrawGroove(NSRect aRect, NSRect clipRect);
APPKIT_EXTERN void NSDrawWhiteBezel(NSRect aRect, NSRect clipRect);
APPKIT_EXTERN void NSDrawButton(NSRect aRect, NSRect clipRect);
APPKIT_EXTERN void NSEraseRect(NSRect aRect);
APPKIT_EXTERN NSColor * __nullable NSReadPixel(NSPoint passedPoint);
APPKIT_EXTERN void NSDrawBitmap(NSRect rect, NSInteger width, NSInteger height, NSInteger bps, NSInteger spp, NSInteger bpp, NSInteger bpr, BOOL isPlanar, BOOL hasAlpha, NSString *colorSpaceName, const unsigned char *const __nullable data[5]);

APPKIT_EXTERN void NSHighlightRect(NSRect aRect) NS_DEPRECATED_MAC(10_0, 10_0);
APPKIT_EXTERN void NSBeep(void);

/* gets performance stats about window server memory usage */
APPKIT_EXTERN NSInteger NSGetWindowServerMemory(NSInteger context, NSInteger *virtualMemory, NSInteger *windowBackingMemory,   NSString * __nonnull * __nonnull windowDumpString); // Deprecated; doesn't return anything useful (as of 10.0)

APPKIT_EXTERN NSRect NSDrawColorTiledRects(NSRect boundsRect, NSRect clipRect, const NSRectEdge *sides, NSColor * __nonnull * __nonnull colors, NSInteger count);
APPKIT_EXTERN void NSDrawDarkBezel(NSRect aRect, NSRect clipRect);
APPKIT_EXTERN void NSDrawLightBezel(NSRect aRect, NSRect clipRect);
APPKIT_EXTERN void NSDottedFrameRect(NSRect aRect);

APPKIT_EXTERN void NSDrawWindowBackground(NSRect aRect);
APPKIT_EXTERN void NSSetFocusRingStyle(NSFocusRingPlacement placement);

/* Disable and reenable screen updates.  
** NSDisableScreenUpdates prevents drawing for all windows belonging to the calling  
** process from being flushed to the screen.  This function permits operations on 
** multiple windows to appear atomic to the user, and is particularly useful for parent
** and child windows.  Note that this function should be used with care for short 
** operations only as the system will only allow updates to be disabled for a short 
** time (currently one second) before automatically reenabling updates.
** NSEnableScreenUpdates reenables drawing that was previously disabled by 
** NSDisableScreenUpdates.  Multiple calls stack.
*/
APPKIT_EXTERN void NSDisableScreenUpdates(void);
APPKIT_EXTERN void NSEnableScreenUpdates(void);


/* Runs one of the standard system animation effects (display and sound).
** 'centerLocation' represents the center, in screen coordinates, to show the effect.
** 'size' specifies how big the effect should be.  Use NSZeroSize to get the default size.
** 'animationDelegate' is optionally, an object that wants to know when the effect has completed.
** 'didEndSelector' will be invoked in the animationDelegate when the animation has completed.
**  
** The didEndSelector should have the following signature:
** 	- (void)animationEffectDidEnd:(void *)contextInfo;
*/

typedef NS_ENUM(NSUInteger, NSAnimationEffect) {
	// The default effect used to indicate removal of an item from a collection, 
	// such as toolbar (indicates removal, without destroying the underlying data).
	NSAnimationEffectDisappearingItemDefault = 0,

	// An effect showing a puff of smoke.
	NSAnimationEffectPoof = 10
};

APPKIT_EXTERN void NSShowAnimationEffect(NSAnimationEffect animationEffect, NSPoint centerLocation, NSSize size, __nullable id animationDelegate, __nullable SEL didEndSelector, void * __nullable contextInfo);

/* NSCountWindows, NSWindowList, NSCountWindowsForContext, and NSWindowListForContext are deprecated on Mac OS 10.6 and later.  Use +[NSWindow windowNumbersWithOptions:] instead */
APPKIT_EXTERN void NSCountWindows(NSInteger *count) NS_DEPRECATED_MAC(10_0, 10_6, "Use +[Window windowNumbersWithOptions:] instead");
APPKIT_EXTERN void NSWindowList(NSInteger size, NSInteger list[]) NS_DEPRECATED_MAC(10_0, 10_6, "Use +[Window windowNumbersWithOptions:] instead");
APPKIT_EXTERN void NSCountWindowsForContext(NSInteger context, NSInteger *count) NS_DEPRECATED_MAC(10_0, 10_6, "Use +[Window windowNumbersWithOptions:] instead");
APPKIT_EXTERN void NSWindowListForContext(NSInteger context, NSInteger size, NSInteger list[]) NS_DEPRECATED_MAC(10_0, 10_6, "Use +[Window windowNumbersWithOptions:] instead");
/* This method does nothing, and is deprecated */
APPKIT_EXTERN void NSCopyBits(NSInteger srcGState, NSRect srcRect, NSPoint destPoint) NS_DEPRECATED_MAC(10_0, 10_10);

NS_ASSUME_NONNULL_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          NSGraphicsContext.h                                                                                 0100644 0001750 0001750 00000011755 12567220725 034546  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/AppKit.framework/Versions/C/Headers                                                                      /*
        NSGraphicsContext.h
        Application Kit
        Copyright (c) 1997-2015, Apple Inc.
        All rights reserved.
*/

#import <AppKit/AppKitDefines.h>
#import <AppKit/NSGraphics.h>
#import <Foundation/NSGeometry.h>
#import <Foundation/NSObject.h>
#import <Foundation/NSDictionary.h>

#import <CoreGraphics/CGContext.h>

NS_ASSUME_NONNULL_BEGIN

@class NSString;
@class NSWindow;
@class NSBitmapImageRep;

/* Attributes that can be passed to graphicsContextWithAttributes: method */
APPKIT_EXTERN NSString * NSGraphicsContextDestinationAttributeName; // Can be an instance of NSWindow, NSMutableData, NSBitmapImageRep, or NSURL.

// Attributes for NSMutableData or NSURL destinations
APPKIT_EXTERN NSString * NSGraphicsContextRepresentationFormatAttributeName; // Specifies destination file format

// Supported file format
APPKIT_EXTERN NSString * NSGraphicsContextPSFormat;
APPKIT_EXTERN NSString * NSGraphicsContextPDFFormat;

typedef NS_ENUM(NSUInteger, NSImageInterpolation) {
   NSImageInterpolationDefault = 0,
   NSImageInterpolationNone = 1,
   NSImageInterpolationLow = 2, /* Low quality, fast interpolation. */
   NSImageInterpolationMedium NS_ENUM_AVAILABLE_MAC(10_6) = 4, /* Medium quality, slower than NSImageInterpolationLow. */
   NSImageInterpolationHigh = 3 /* Highest quality, slower than NSImageInterpolationMedium. */
};

@interface NSGraphicsContext : NSObject {
}

// Instantiates from an appropriate concrete subclass depending on NSGraphicsContextDestinationAttributeName attribute
+ (nullable NSGr