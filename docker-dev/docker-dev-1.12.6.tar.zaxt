WDuYaNkqbG9AclVMwWVxJK
gnjIFNkXgiYtXSAfea7+1HAWFpWD2DU5/1JddRwWxRNVz0fMdWVSSt7wsKfkCpYL
+63C4iWEst3kvX5ZbJvw8NjnyvLplzh+ib7M+zkXYT9y2zqR2GUBGR2tUKRXCnxL
vJxxcypFURmFzI79R6d0lR2o0a9OF7FpJsKqeFdbxU2n5Z4FF5TKsl+gSRiNNOkm
bEgeqmiSBeGCc1qb3AdbCG19ndeNIdn8FCCqwkXfP+cAslHkwvgFuXkajDTznlvk
N1trSt8sV4pAWja63XVECDdCcAz+3F4hoKOKwJCcaNpQ5kUQR3i2TtJlycM33+FC
Y7BXN0Ute4qcvwXqZVUz9zkQxSgqIXobisQk+T8VyJoVIPVVYpbtbZNQvOSqeK3Z
ywplh6ZmwcSBo3c6WB4L7oOLnR7SUqTMHW+wmG2UMbX4cQrcufx9MmDm66+KAQ==
-----END CERTIFICATE-----

# Issuer: CN=CA Disig O=Disig a.s.
# Subject: CN=CA Disig O=Disig a.s.
# Label: "CA Disig"
# Serial: 1
# MD5 Fingerprint: 3f:45:96:39:e2:50:87:f7:bb:fe:98:0c:3c:20:98:e6
# SHA1 Fingerprint: 2a:c8:d5:8b:57:ce:bf:2f:49:af:f2:fc:76:8f:51:14:62:90:7a:41
# SHA256 Fingerprint: 92:bf:51:19:ab:ec:ca:d0:b1:33:2d:c4:e1:d0:5f:ba:75:b5:67:90:44:ee:0c:a2:6e:93:1f:74:4f:2f:33:cf
-----BEGIN CERTIFICATE-----
MIIEDzCCAvegAwIBAgIBATANBgkqhkiG9w0BAQUFADBKMQswCQYDVQQGEwJTSzET
MBEGA1UEBxMKQnJhdGlzbGF2YTETMBEGA1UEChMKRGlzaWcgYS5zLjERMA8GA1UE
AxMIQ0EgRGlzaWcwHhcNMDYwMzIyMDEzOTM0WhcNMTYwMzIyMDEzOTM0WjBKMQsw
CQYDVQQGEwJTSzETMBEGA1UEBxMKQnJhdGlzbGF2YTETMBEGA1UEChMKRGlzaWcg
YS5zLjERMA8GA1UEAxMIQ0EgRGlzaWcwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw
ggEKAoIBAQCS9jHBfYj9mQGp2HvycXXxMcbzdWb6UShGhJd4NLxs/LxFWYgmGErE
Nx+hSkS943EE9UQX4j/8SFhvXJ56CbpRNyIjZkMhsDxkovhqFQ4/61HhVKndBpnX
mjxUizkDPw/Fzsbrg3ICqB9x8y34dQjbYkzo+s7552oftms1grrijxaSfQUMbEYD
XcDtab86wYqg6I7ZuUUohwjstMoVvoLdtUSLLa2GDGhibYVW8qwUYzrG0ZmsNHhW
S8+2rT+MitcE5eN4TPWGqvWP+j1scaMtymfraHtuM6kMgiioTGohQBUgDCZbg8Kp
FhXAJIJdKxatymP2dACw30PEEGBWZ2NFAgMBAAGjgf8wgfwwDwYDVR0TAQH/BAUw
AwEB/zAdBgNVHQ4EFgQUjbJJaJ1yCCW5wCf1UJNWSEZx+Y8wDgYDVR0PAQH/BAQD
AgEGMDYGA1UdEQQvMC2BE2Nhb3BlcmF0b3JAZGlzaWcuc2uGFmh0dHA6Ly93d3cu
ZGlzaWcuc2svY2EwZgYDVR0fBF8wXTAtoCugKYYnaHR0cDovL3d3dy5kaXNpZy5z
ay9jYS9jcmwvY2FfZGlzaWcuY3JsMCygKqAohiZodHRwOi8vY2EuZGlzaWcuc2sv
Y2EvY3JsL2NhX2Rpc2lnLmNybDAaBgNVHSAEEzARMA8GDSuBHpGT5goAAAABAQEw
DQYJKoZIhvcNAQEFBQADggEBAF00dGFMrzvY/59tWDYcPQuBDRIrRhCA/ec8J9B6
yKm2fnQwM6M6int0wHl5QpNt/7EpFIKrIYwvF/k/Ji/1WcbvgAa3mkkp7M5+cTxq
EEHA9tOasnxakZzArFvITV734VP/Q3f8nktnbNfzg9Gg4H8l37iYC5oyOGwwoPP/
CBUz91BKez6jPiCp3C9WgArtQVCwyfTssuMmRAAOb54GvCKWU3BlxFAKRmukLyeB
EicTXxChds6KezfqwzlhA5WYOudsiCUI/HloDYd9Yvi0X/vF2Ey9WLw/Q1vUHgFN
PGO+I++MzVpQuGhU+QqZMxEA4Z7CRneC9VkGjCFMhwnN5ag=
-----END CERTIFICATE-----

# Issuer: CN=Juur-SK O=AS Sertifitseerimiskeskus
# Subject: CN=Juur-SK O=AS Sertifitseerimiskeskus
# Label: "Juur-SK"
# Serial: 999181308
# MD5 Fingerprint: aa:8e:5d:d9:f8:db:0a:58:b7:8d:26:87:6c:82:35:55
# SHA1 Fingerprint: 40:9d:4b:d9:17:b5:5c:27:b6:9b:64:cb:98:22:44:0d:cd:09:b8:89
# SHA256 Fingerprint: ec:c3:e9:c3:40:75:03:be:e0:91:aa:95:2f:41:34:8f:f8:8b:aa:86:3b:22:64:be:fa:c8:07:90:15:74:e9:39
-----BEGIN CERTIFICATE-----
MIIE5jCCA86gAwIBAgIEO45L/DANBgkqhkiG9w0BAQUFADBdMRgwFgYJKoZIhvcN
AQkBFglwa2lAc2suZWUxCzAJBgNVBAYTAkVFMSIwIAYDVQQKExlBUyBTZXJ0aWZp
dHNlZXJpbWlza2Vza3VzMRAwDgYDVQQDEwdKdXVyLVNLMB4XDTAxMDgzMDE0MjMw
MVoXDTE2MDgyNjE0MjMwMVowXTEYMBYGCSqGSIb3DQEJARYJcGtpQHNrLmVlMQsw
CQYDVQQGEwJFRTEiMCAGA1UEChMZQVMgU2VydGlmaXRzZWVyaW1pc2tlc2t1czEQ
MA4GA1UEAxMHSnV1ci1TSzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AIFxNj4zB9bjMI0TfncyRsvPGbJgMUaXhvSYRqTCZUXP00B841oiqBB4M8yIsdOB
SvZiF3tfTQou0M+LI+5PAk676w7KvRhj6IAcjeEcjT3g/1tf6mTll+g/mX8MCgkz
ABpTpyHhOEvWgxutr2TC+Rx6jGZITWYfGAriPrsfB2WThbkasLnE+w0R9vXW+RvH
LCu3GFH+4Hv2qEivbDtPL+/40UceJlfwUR0zlv/vWT3aTdEVNMfqPxZIe5EcgEMP
PbgFPtGzlc3Yyg/CQ2fbt5PgIoIuvvVoKIO5wTtpeyDaTpxt4brNj3pssAki14sL
2xzVWiZbDcDq5WDQn/413z8CAwEAAaOCAawwggGoMA8GA1UdEwEB/wQFMAMBAf8w
ggEWBgNVHSAEggENMIIBCTCCAQUGCisGAQQBzh8BAQEwgfYwgdAGCCsGAQUFBwIC
MIHDHoHAAFMAZQBlACAAcwBlAHIAdABpAGYAaQBrAGEAYQB0ACAAbwBuACAAdgDk
AGwAagBhAHMAdABhAHQAdQBkACAAQQBTAC0AaQBzACAAUwBlAHIAdABpAGYAaQB0
AHMAZQBlAHIAaQBtAGkAcwBrAGUAcwBrAHUAcwAgAGEAbABhAG0ALQBTAEsAIABz
AGUAcgB0AGkAZgBpAGsAYQBhAHQAaQBkAGUAIABrAGkAbgBuAGkAdABhAG0AaQBz
AGUAawBzMCEGCCsGAQUFBwIBFhVodHRwOi8vd3d3LnNrLmVlL2Nwcy8wKwYDVR0f
BCQwIjAgoB6gHIYaaHR0cDovL3d3dy5zay5lZS9qdXVyL2NybC8wHQYDVR0OBBYE
FASqekej5ImvGs8KQKcYP2/v6X2+MB8GA1UdIwQYMBaAFASqekej5ImvGs8KQKcY
P2/v6X2+MA4GA1UdDwEB/wQEAwIB5jANBgkqhkiG9w0BAQUFAAOCAQEAe8EYlFOi
CfP+JmeaUOTDBS8rNXiRTHyoERF5TElZrMj3hWVcRrs7EKACr81Ptcw2Kuxd/u+g
kcm2k298gFTsxwhwDY77guwqYHhpNjbRxZyLabVAyJRld/JXIWY7zoVAtjNjGr95
HvxcHdMdkxuLDF2FvZkwMhgJkVLpfKG6/2SSmuz+Ne6ML678IIbsSt4beDI3poHS
na9aEhbKmVv8b20OxaAehsmR0FyYgl9jDIpaq9iVpszLita/ZEuOyoqysOkhMp6q
qIWYNIE5ITuoOlIyPfZrN4YGWhWY3PARZv40ILcD9EEQfTmEeZZyY7aWAuVrua0Z
TbvGRNs2yyqcjg==
-----END CERTIFICATE-----

# Issuer: CN=Hongkong Post Root CA 1 O=Hongkong Post
# Subject: CN=Hongkong Post Root CA 1 O=Hongkong Post
# Label: "Hongkong Post Root CA 1"
# Serial: 1000
# MD5 Fingerprint: a8:0d:6f:39:78:b9:43:6d:77:42:6d:98:5a:cc:23:ca
# SHA1 Fingerprint: d6:da:a8:20:8d:09:d2:15:4d:24:b5:2f:cb:34:6e:b2:58:b2:8a:58
# SHA256 Fingerprint: f9:e6:7d:33:6c:51:00:2a:c0:54:c6:32:02:2d:66:dd:a2:e7:e3:ff:f1:0a:d0:61:ed:31:d8:bb:b4:10:cf:b2
-----BEGIN CERTIFICATE-----
MIIDMDCCAhigAwIBAgICA+gwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCSEsx
FjAUBgNVBAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdrb25nIFBvc3Qg
Um9vdCBDQSAxMB4XDTAzMDUxNTA1MTMxNFoXDTIzMDUxNTA0NTIyOVowRzELMAkG
A1UEBhMCSEsxFjAUBgNVBAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdr
b25nIFBvc3QgUm9vdCBDQSAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
AQEArP84tulmAknjorThkPlAj3n54r15/gK97iSSHSL22oVyaf7XPwnU3ZG1ApzQ
jVrhVcNQhrkpJsLj2aDxaQMoIIBFIi1WpztUlVYiWR8o3x8gPW2iNr4joLFutbEn
PzlTCeqrauh0ssJlXI6/fMN4hM2eFvz1Lk8gKgifd/PFHsSaUmYeSF7jEAaPIpjh
ZY4bXSNmO7ilMlHIhqqhqZ5/dpTCpmy3QfDVyAY45tQM4vM7TG1QjMSDJ8EThFk9
nnV0ttgCXjqQesBCNnLsak3c78QA3xMYV18meMjWCnl3v/evt3a5pQuEF10Q6m/h
q5URX208o1xNg1vysxmKgIsLhwIDAQABoyYwJDASBgNVHRMBAf8ECDAGAQH/AgED
MA4GA1UdDwEB/wQEAwIBxjANBgkqhkiG9w0BAQUFAAOCAQEADkbVPK7ih9legYsC
mEEIjEy82tvuJxuC52pF7BaLT4Wg87JwvVqWuspube5Gi27nKi6Wsxkz67SfqLI3
7piol7Yutmcn1KZJ/RyTZXaeQi/cImyaT/JaFTmxcdcrUehtHJjA2Sr0oYJ71clB
oiMBdDhViw+5LmeiIAQ32pwL0xch4I+XeTRvhEgCIDMb5jREn5Fw9IBehEPCKdJs
EhTkYY2sEJCehFC78JZvRZ+K88psT/oROhUVRsPNH4NbLUES7VBnQRM9IauUiqpO
fMGx+6fWtScvl6tu4B3i0RwsH0Ti/L6RoZz71ilTc4afU9hDDl3WY4JxHYB0yvbi
AmvZWg==
-----END CERTIFICATE-----

# Issuer: CN=SecureSign RootCA11 O=Japan Certification Services, Inc.
# Subject: CN=SecureSign RootCA11 O=Japan Certification Services, Inc.
# Label: "SecureSign RootCA11"
# Serial: 1
# MD5 Fingerprint: b7:52:74:e2:92:b4:80:93:f2:75:e4:cc:d7:f2:ea:26
# SHA1 Fingerprint: 3b:c4:9f:48:f8:f3:73:a0:9c:1e:bd:f8:5b:b1:c3:65:c7:d8:11:b3
# SHA256 Fingerprint: bf:0f:ee:fb:9e:3a:58:1a:d5:f9:e9:db:75:89:98:57:43:d2:61:08:5c:4d:31:4f:6f:5d:72:59:aa:42:16:12
-----BEGIN CERTIFICATE-----
MIIDbTCCAlWgAwIBAgIBATANBgkqhkiG9w0BAQUFADBYMQswCQYDVQQGEwJKUDEr
MCkGA1UEChMiSmFwYW4gQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcywgSW5jLjEcMBoG
A1UEAxMTU2VjdXJlU2lnbiBSb290Q0ExMTAeFw0wOTA0MDgwNDU2NDdaFw0yOTA0
MDgwNDU2NDdaMFgxCzAJBgNVBAYTAkpQMSswKQYDVQQKEyJKYXBhbiBDZXJ0aWZp
Y2F0aW9uIFNlcnZpY2VzLCBJbmMuMRwwGgYDVQQDExNTZWN1cmVTaWduIFJvb3RD
QTExMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA/XeqpRyQBTvLTJsz
i1oURaTnkBbR31fSIRCkF/3frNYfp+TbfPfs37gD2pRY/V1yfIw/XwFndBWW4wI8
h9uuywGOwvNmxoVF9ALGOrVisq/6nL+k5tSAMJjzDbaTj6nU2DbysPyKyiyhFTOV
MdrAG/LuYpmGYz+/3ZMqg6h2uRMft85OQoWPIucuGvKVCbIFtUROd6EgvanyTgp9
UK31BQ1FT0Zx/Sg+U/sE2C3XZR1KG/rPO7AxmjVuyIsG0wCR8pQIZUyxNAYAeoni
8McDWc/V1uinMrPmmECGxc0nEovMe863ETxiYAcjPitAbpSACW22s293bzUIUPsC
h8U+iQIDAQABo0IwQDAdBgNVHQ4EFgQUW/hNT7KlhtQ60vFjmqC+CfZXt94wDgYD
VR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEB
AKChOBZmLqdWHyGcBvod7bkixTgm2E5P7KN/ed5GIaGHd48HCJqypMWvDzKYC3xm
KbabfSVSSUOrTC4rbnpwrxYO4wJs+0LmGJ1F2FXI6Dvd5+H0LgscNFxsWEr7jIhQ
X5Ucv+2rIrVls4W6ng+4reV6G4pQOh29Dbx7VFALuUKvVaAYga1lme++5Jy/xIWr
QbJUb9wlze144o4MjQlJ3WN7WmmWAiGovVJZ6X01y8hSyn+B/tlr0/cR7SXf+Of5
pPpyl4RTDaXQMhhRdlkUbA/r7F+AjHVDg8OFmP9Mni0N5HeDk061lgeLKBObjBmN
QSdJQO7e5iNEOdyhIta6A/I=
-----END CERTIFICATE-----

# Issuer: CN=ACEDICOM Root O=EDICOM OU=PKI
# Subject: CN=ACEDICOM Root O=EDICOM OU=PKI
# Label: "ACEDICOM Root"
# Serial: 7029493972724711941
# MD5 Fingerprint: 42:81:a0:e2:1c:e3:55:10:de:55:89:42:65:96:22:e6
# SHA1 Fingerprint: e0:b4:32:2e:b2:f6:a5:68:b6:54:53:84:48:18:4a:50:36:87:43:84
# SHA256 Fingerprint: 03:95:0f:b4:9a:53:1f:3e:19:91:94:23:98:df:a9:e0:ea:32:d7:ba:1c:dd:9b:c8:5d:b5:7e:d9:40:0b:43:4a
-----BEGIN CERTIFICATE-----
MIIFtTCCA52gAwIBAgIIYY3HhjsBggUwDQYJKoZIhvcNAQEFBQAwRDEWMBQGA1UE
AwwNQUNFRElDT00gUm9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZFRElDT00x
CzAJBgNVBAYTAkVTMB4XDTA4MDQxODE2MjQyMloXDTI4MDQxMzE2MjQyMlowRDEW
MBQGA1UEAwwNQUNFRElDT00gUm9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZF
RElDT00xCzAJBgNVBAYTAkVTMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKC
AgEA/5KV4WgGdrQsyFhIyv2AVClVYyT/kGWbEHV7w2rbYgIB8hiGtXxaOLHkWLn7
09gtn70yN78sFW2+tfQh0hOR2QetAQXW8713zl9CgQr5auODAKgrLlUTY4HKRxx7
XBZXehuDYAQ6PmXDzQHe3qTWDLqO3tkE7hdWIpuPY/1NFgu3e3eM+SW10W2ZEi5P
Grjm6gSSrj0RuVFCPYewMYWveVqc/udOXpJPQ/yrOq2lEiZmueIM15jO1FillUAK
t0SdE3QrwqXrIhWYENiLxQSfHY9g5QYbm8+5eaA9oiM/Qj9r+hwDezCNzmzAv+Yb
X79nuIQZ1RXve8uQNjFiybwCq0Zfm/4aaJQ0PZCOrfbkHQl/Sog4P75n/TSW9R28
MHTLOO7VbKvU/PQAtwBbhTIWdjPp2KOZnQUAqhbm84F9b32qhm2tFXTTxKJxqvQU
fecyuB+81fFOvW8XAjnXDpVCOscAPukmYxHqC9FK/xidstd7LzrZlvvoHpKuE1XI
2Sf23EgbsCTBheN3nZqk8wwRHQ3ItBTutYJXCb8gWH8vIiPYcMt5bMlL8qkqyPyH
K9caUPgn6C9D4zq92Fdx/c6mUlv53U3t5fZvie27k5x2IXXwkkwp9y+cAS7+UEae
ZAwUswdbxcJzbPEHXEUkFDWug/FqTYl6+rPYLWbwNof1K1MCAwEAAaOBqjCBpzAP
BgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFKaz4SsrSbbXc6GqlPUB53NlTKxQ
MA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUprPhKytJttdzoaqU9QHnc2VMrFAw
RAYDVR0gBD0wOzA5BgRVHSAAMDEwLwYIKwYBBQUHAgEWI2h0dHA6Ly9hY2VkaWNv
bS5lZGljb21ncm91cC5jb20vZG9jMA0GCSqGSIb3DQEBBQUAA4ICAQDOLAtSUWIm
fQwng4/F9tqgaHtPkl7qpHMyEVNEskTLnewPeUKzEKbHDZ3Ltvo/Onzqv4hTGzz3
gvoFNTPhNahXwOf9jU8/kzJPeGYDdwdY6ZXIfj7QeQCM8htRM5u8lOk6e25SLTKe
I6RF+7YuE7CLGLHdztUdp0J/Vb77W7tH1PwkzQSulgUV1qzOMPPKC8W64iLgpq0i
5ALudBF/TP94HTXa5gI06xgSYXcGCRZj6hitoocf8seACQl1ThCojz2GuHURwCRi
ipZ7SkXp7FnFvmuD5uHorLUwHv4FB4D54SMNUI8FmP8sX+g7tq3PgbUhh8oIKiMn
MCArz+2UW6yyetLHKKGKC5tNSixthT8Jcjxn4tncB7rrZXtaAWPWkFtPF2Y9fwsZ
o5NjEFIqnxQWWOLcpfShFosOkYuByptZ+thrkQdlVV9SH686+5DdaaVbnG0OLLb6
zqylfDJKZ0DcMDQj3dcEI2bw/FWAp/tmGYI1Z2JwOV5vx+qQQEQIHriy1tvuWacN
GHk0vFQYXlPKNFHtRQrmjseCNj6nOGOpMCwXEGCSn1WHElkQwg9naRHMTh5+Spqt
r0CodaxWkHS4oJyleW/c6RrIaQXpuvoDs3zk4E7Czp3otkYNbn5XOmeUwssfnHdK
Z05phkOTOPu220+DkdRgfks+KzgHVZhepA==
-----END CERTIFICATE-----

# Issuer: O=VeriSign, Inc. OU=Class 3 Public Primary Certification Authority
# Subject: O=VeriSign, Inc. OU=Class 3 Public Primary Certification Authority
# Label: "Verisign Class 3 Public Primary Certification Authority"
# Serial: 80507572722862485515306429940691309246
# MD5 Fingerprint: ef:5a:f1:33:ef:f1:cd:bb:51:02:ee:12:14:4b:96:c4
# SHA1 Fingerprint: a1:db:63:93:91:6f:17:e4:18:55:09:40:04:15:c7:02:40:b0:ae:6b
# SHA256 Fingerprint: a4:b6:b3:99:6f:c2:f3:06:b3:fd:86:81:bd:63:41:3d:8c:50:09:cc:4f:a3:29:c2:cc:f0:e2:fa:1b:14:03:05
-----BEGIN CERTIFICATE-----
MIICPDCCAaUCEDyRMcsf9tAbDpq40ES/Er4wDQYJKoZIhvcNAQEFBQAwXzELMAkG
A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFz
cyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTk2
MDEyOTAwMDAwMFoXDTI4MDgwMjIzNTk1OVowXzELMAkGA1UEBhMCVVMxFzAVBgNV
BAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFzcyAzIFB1YmxpYyBQcmlt
YXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GN
ADCBiQKBgQDJXFme8huKARS0EN8EQNvjV69qRUCPhAwL0TPZ2RHP7gJYHyX3KqhE
BarsAx94f56TuZoAqiN91qyFomNFx3InzPRMxnVx0jnvT0Lwdd8KkMaOIG+YD/is
I19wKTakyYbnsZogy1Olhec9vn2a/iRFM9x2Fe0PonFkTGUugWhFpwIDAQABMA0G
CSqGSIb3DQEBBQUAA4GBABByUqkFFBkyCEHwxWsKzH4PIRnN5GfcX6kb5sroc50i
2JhucwNhkcV8sEVAbkSdjbCxlnRhLQ2pRdKkkirWmnWXbj9T/UWZYB2oK0z5XqcJ
2HUw19JlYD1n1khVdWk/kfVIC0dpImmClr7JyDiGSnoscxlIaU5rfGW/D/xwzoiQ
-----END CERTIFICATE-----

# Issuer: CN=Microsec e-Szigno Root CA 2009 O=Microsec Ltd.
# Subject: CN=Microsec e-Szigno Root CA 2009 O=Microsec Ltd.
# Label: "Microsec e-Szigno Root CA 2009"
# Serial: 14014712776195784473
# MD5 Fingerprint: f8:49:f4:03:bc:44:2d:83:be:48:69:7d:29:64:fc:b1
# SHA1 Fingerprint: 89:df:74:fe:5c:f4:0f:4a:80:f9:e3:37:7d:54:da:91:e1:01:31:8e
# SHA256 Fingerprint: 3c:5f:81:fe:a5:fa:b8:2c:64:bf:a2:ea:ec:af:cd:e8:e0:77:fc:86:20:a7:ca:e5:37:16:3d:f3:6e:db:f3:78
-----BEGIN CERTIFICATE-----
MIIECjCCAvKgAwIBAgIJAMJ+QwRORz8ZMA0GCSqGSIb3DQEBCwUAMIGCMQswCQYD
VQQGEwJIVTERMA8GA1UEBwwIQnVkYXBlc3QxFjAUBgNVBAoMDU1pY3Jvc2VjIEx0
ZC4xJzAlBgNVBAMMHk1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EgMjAwOTEfMB0G
CSqGSIb3DQEJARYQaW5mb0BlLXN6aWduby5odTAeFw0wOTA2MTYxMTMwMThaFw0y
OTEyMzAxMTMwMThaMIGCMQswCQYDVQQGEwJIVTERMA8GA1UEBwwIQnVkYXBlc3Qx
FjAUBgNVBAoMDU1pY3Jvc2VjIEx0ZC4xJzAlBgNVBAMMHk1pY3Jvc2VjIGUtU3pp
Z25vIFJvb3QgQ0EgMjAwOTEfMB0GCSqGSIb3DQEJARYQaW5mb0BlLXN6aWduby5o
dTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOn4j/NjrdqG2KfgQvvP
kd6mJviZpWNwrZuuyjNAfW2WbqEORO7hE52UQlKavXWFdCyoDh2Tthi3jCyoz/tc
cbna7P7ofo/kLx2yqHWH2Leh5TvPmUpG0IMZfcChEhyVbUr02MelTTMuhTlAdX4U
fIASmFDHQWe4oIBhVKZsTh/gnQ4H6cm6M+f+wFUoLAKApxn1ntxVUwOXewdI/5n7
N4okxFnMUBBjjqqpGrCEGob5X7uxUG6k0QrM1XF+H6cbfPVTbiJfyyvm1HxdrtbC
xkzlBQHZ7Vf8wSN5/PrIJIOV87VqUQHQd9bpEqH5GoP7ghu5sJf0dgYzQ0mg/wu1
+rUCAwEAAaOBgDB+MA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0G
A1UdDgQWBBTLD8bfQkPMPcu1SCOhGnqmKrs0aDAfBgNVHSMEGDAWgBTLD8bfQkPM
Pcu1SCOhGnqmKrs0aDAbBgNVHREEFDASgRBpbmZvQGUtc3ppZ25vLmh1MA0GCSqG
SIb3DQEBCwUAA4IBAQDJ0Q5eLtXMs3w+y/w9/w0olZMEyL/azXm4Q5DwpL7v8u8h
mLzU1F0G9u5C7DBsoKqpyvGvivo/C3NqPuouQH4frlRheesuCDfXI/OMn74dseGk
ddug4lQUsbocKaQY9hK6ohQU4zE1yED/t+AFdlfBHFny+L/k7SViXITwfn4fs775
tyERzAMBVnCnEJIeGzSBHq2cGsMEPO0CYdYeBvNfOofyK/FFh+U9rNHHV4S9a67c
2Pm2G2JwCz02yULyMtd6YebS2z3PyKnJm9zbWETXbzivf3jTo60adbocwTZ8jx5t
HMN1Rq41Bab2XD0h7lbwyYIiLXpUq3DDfSJlgnCW
-----END CERTIFICATE-----

# Issuer: CN=e-Guven Kok Elektronik Sertifika Hizmet Saglayicisi O=Elektronik Bilgi Guvenligi A.S.
# Subject: CN=e-Guven Kok Elektronik Sertifika Hizmet Saglayicisi O=Elektronik Bilgi Guvenligi A.S.
# Label: "E-Guven Kok Elektronik Sertifika Hizmet Saglayicisi"
# Serial: 91184789765598910059173000485363494069
# MD5 Fingerprint: 3d:41:29:cb:1e:aa:11:74:cd:5d:b0:62:af:b0:43:5b
# SHA1 Fingerprint: dd:e1:d2:a9:01:80:2e:1d:87:5e:84:b3:80:7e:4b:b1:fd:99:41:34
# SHA256 Fingerprint: e6:09:07:84:65:a4:19:78:0c:b6:ac:4c:1c:0b:fb:46:53:d9:d9:cc:6e:b3:94:6e:b7:f3:d6:99:97:ba:d5:98
-----BEGIN CERTIFICATE-----
MIIDtjCCAp6gAwIBAgIQRJmNPMADJ72cdpW56tustTANBgkqhkiG9w0BAQUFADB1
MQswCQYDVQQGEwJUUjEoMCYGA1UEChMfRWxla3Ryb25payBCaWxnaSBHdXZlbmxp
Z2kgQS5TLjE8MDoGA1UEAxMzZS1HdXZlbiBLb2sgRWxla3Ryb25payBTZXJ0aWZp
a2EgSGl6bWV0IFNhZ2xheWljaXNpMB4XDTA3MDEwNDExMzI0OFoXDTE3MDEwNDEx
MzI0OFowdTELMAkGA1UEBhMCVFIxKDAmBgNVBAoTH0VsZWt0cm9uaWsgQmlsZ2kg
R3V2ZW5saWdpIEEuUy4xPDA6BgNVBAMTM2UtR3V2ZW4gS29rIEVsZWt0cm9uaWsg
U2VydGlmaWthIEhpem1ldCBTYWdsYXlpY2lzaTCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAMMSIJ6wXgBljU5Gu4Bc6SwGl9XzcslwuedLZYDBS75+PNdU
MZTe1RK6UxYC6lhj71vY8+0qGqpxSKPcEC1fX+tcS5yWCEIlKBHMilpiAVDV6wlT
L/jDj/6z/P2douNffb7tC+Bg62nsM+3YjfsSSYMAyYuXjDtzKjKzEve5TfL0TW3H
5tYmNwjy2f1rXKPlSFxYvEK+A1qBuhw1DADT9SN+cTAIJjjcJRFHLfO6IxClv7wC
90Nex/6wN1CZew+TzuZDLMN+DfIcQ2Zgy2ExR4ejT669VmxMvLz4Bcpk9Ok0oSy1
c+HCPujIyTQlCFzz7abHlJ+tiEMl1+E5YP6sOVkCAwEAAaNCMEAwDgYDVR0PAQH/
BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJ/uRLOU1fqRTy7ZVZoE
VtstxNulMA0GCSqGSIb3DQEBBQUAA4IBAQB/X7lTW2M9dTLn+sR0GstG30ZpHFLP
qk/CaOv/gKlR6D1id4k9CnU58W5dF4dvaAXBlGzZXd/aslnLpRCKysw5zZ/rTt5S
/wzw9JKp8mxTq5vSR6AfdPebmvEvFZ96ZDAYBzwqD2fK/A+JYZ1lpTzlvBNbCNvj
/+27BrtqBrF6T2XGgv0enIu1De5Iu7i9qgi0+6N8y5/NkHZchpZ4Vwpm+Vganf2X
KWDeEaaQHBkc7gGWIjQ0LpH5t8Qn0Xvmv/uARFoW5evg1Ao4vOSR49XrXMGs3xtq
fJ7lddK2l4fbzIcrQzqECK+rPNv3PGYxhrCdU3nt+CPeQuMtgvEP5fqX
-----END CERTIFICATE-----

# Issuer: CN=GlobalSign O=GlobalSign OU=GlobalSign Root CA - R3
# Subject: CN=GlobalSign O=GlobalSign OU=GlobalSign Root CA - R3
# Label: "GlobalSign Root CA - R3"
# Serial: 4835703278459759426209954
# MD5 Fingerprint: c5:df:b8:49:ca:05:13:55:ee:2d:ba:1a:c3:3e:b0:28
# SHA1 Fingerprint: d6:9b:56:11:48:f0:1c:77:c5:45:78:c1:09:26:df:5b:85:69:76:ad
# SHA256 Fingerprint: cb:b5:22:d7:b7:f1:27:ad:6a:01:13:86:5b:df:1c:d4:10:2e:7d:07:59:af:63:5a:7c:f4:72:0d:c9:63:c5:3b
-----BEGIN CERTIFICATE-----
MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
WD9f
-----END CERTIFICATE-----

# Issuer: CN=Autoridad de Certificacion Firmaprofesional CIF A62634068
# Subject: CN=Autoridad de Certificacion Firmaprofesional CIF A62634068
# Label: "Autoridad de Certificacion Firmaprofesional CIF A62634068"
# Serial: 6047274297262753887
# MD5 Fingerprint: 73:3a:74:7a:ec:bb:a3:96:a6:c2:e4:e2:c8:9b:c0:c3
# SHA1 Fingerprint: ae:c5:fb:3f:c8:e1:bf:c4:e5:4f:03:07:5a:9a:e8:00:b7:f7:b6:fa
# SHA256 Fingerprint: 04:04:80:28:bf:1f:28:64:d4:8f:9a:d4:d8:32:94:36:6a:82:88:56:55:3f:3b:14:30:3f:90:14:7f:5d:40:ef
-----BEGIN CERTIFICATE-----
MIIGFDCCA/ygAwIBAgIIU+w77vuySF8wDQYJKoZIhvcNAQEFBQAwUTELMAkGA1UE
BhMCRVMxQjBABgNVBAMMOUF1dG9yaWRhZCBkZSBDZXJ0aWZpY2FjaW9uIEZpcm1h
cHJvZmVzaW9uYWwgQ0lGIEE2MjYzNDA2ODAeFw0wOTA1MjAwODM4MTVaFw0zMDEy
MzEwODM4MTVaMFExCzAJBgNVBAYTAkVTMUIwQAYDVQQDDDlBdXRvcmlkYWQgZGUg
Q2VydGlmaWNhY2lvbiBGaXJtYXByb2Zlc2lvbmFsIENJRiBBNjI2MzQwNjgwggIi
MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDKlmuO6vj78aI14H9M2uDDUtd9
thDIAl6zQyrET2qyyhxdKJp4ERppWVevtSBC5IsP5t9bpgOSL/UR5GLXMnE42QQM
cas9UX4PB99jBVzpv5RvwSmCwLTaUbDBPLutN0pcyvFLNg4kq7/DhHf9qFD0sefG
L9ItWY16Ck6WaVICqjaY7Pz6FIMMNx/Jkjd/14Et5cS54D40/mf0PmbR0/RAz15i
NA9wBj4gGFrO93IbJWyTdBSTo3OxDqqHECNZXyAFGUftaI6SEspd/NYrspI8IM/h
X68gvqB2f3bl7BqGYTM+53u0P6APjqK5am+5hyZvQWyIplD9amML9ZMWGxmPsu2b
m8mQ9QEM3xk9Dz44I8kvjwzRAv4bVdZO0I08r0+k8/6vKtMFnXkIoctXMbScyJCy
Z/QYFpM6/EfY0XiWMR+6KwxfXZmtY4laJCB22N/9q06mIqqdXuYnin1oKaPnirja
EbsXLZmdEyRG98Xi2J+Of8ePdG1asuhy9azuJBCtLxTa/y2aRnFHvkLfuwHb9H/T
KI8xWVvTyQKmtFLKbpf7Q8UIJm+K9Lv9nyiqDdVF8xM6HdjAeI9BZzwelGSuewvF
6NkBiDkal4ZkQdU7hwxu+g/GvUgUvzlN1J5Bto+WHWOWk9mVBngxaJ43BjuAiUVh
OSPHG0SjFeUc+JIwuwIDAQABo4HvMIHsMBIGA1UdEwEB/wQIMAYBAf8CAQEwDgYD
VR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRlzeurNR4APn7VdMActHNHDhpkLzCBpgYD
VR0gBIGeMIGbMIGYBgRVHSAAMIGPMC8GCCsGAQUFBwIBFiNodHRwOi8vd3d3LmZp
cm1hcHJvZmVzaW9uYWwuY29tL2NwczBcBggrBgEFBQcCAjBQHk4AUABhAHMAZQBv
ACAAZABlACAAbABhACAAQgBvAG4AYQBuAG8AdgBhACAANAA3ACAAQgBhAHIAYwBl
AGwAbwBuAGEAIAAwADgAMAAxADcwDQYJKoZIhvcNAQEFBQADggIBABd9oPm03cXF
661LJLWhAqvdpYhKsg9VSytXjDvlMd3+xDLx51tkljYyGOylMnfX40S2wBEqgLk9
am58m9Ot/MPWo+ZkKXzR4Tgegiv/J2Wv+xYVxC5xhOW1//qkR71kMrv2JYSiJ0L1
ILDCExARzRAVukKQKtJE4ZYm6zFIEv0q2skGz3QeqUvVhyj5eTSSPi5E6PaPT481
PyWzOdxjKpBrIF/EUhJOlywqrJ2X3kjyo2bbwtKDlaZmp54lD+kLM5FlClrD2VQS
3a/DTg4fJl4N3LON7NWBcN7STyQF82xO9UxJZo3R/9ILJUFI/lGExkKvgATP0H5k
SeTy36LssUzAKh3ntLFlosS88Zj0qnAHY7S42jtM+kAiMFsRpvAFDsYCA0irhpuF
3dvd6qJ2gHN99ZwExEWN57kci57q13XRcrHedUTnQn3iV2t93Jm8PYMo6oCTjcVM
ZcFwgbg4/EMxsvYDNEeyrPsiBsse3RdHHF9mudMaotoRsaS8I8nkvof/uZS2+F0g
StRf571oe2XyFR7SOqkt6dhrJKyXWERHrVkY8SFlcN7ONGCoQPHzPKTDKCOM/icz
Q0CgFzzr6juwcqajuUpLXhZI9LK8yIySxZ2frHI2vDSANGupi5LAuBft7HZT9SQB
jLMi6Et8Vcad+qMUu2WFbm5PEn4KPJ2V
-----END CERTIFICATE-----

# Issuer: CN=Izenpe.com O=IZENPE S.A.
# Subject: CN=Izenpe.com O=IZENPE S.A.
# Label: "Izenpe.com"
# Serial: 917563065490389241595536686991402621
# MD5 Fingerprint: a6:b0:cd:85:80:da:5c:50:34:a3:39:90:2f:55:67:73
# SHA1 Fingerprint: 2f:78:3d:25:52:18:a7:4a:65:39:71:b5:2c:a2:9c:45:15:6f:e9:19
# SHA256 Fingerprint: 25:30:cc:8e:98:32:15:02:ba:d9:6f:9b:1f:ba:1b:09:9e:2d:29:9e:0f:45:48:bb:91:4f:36:3b:c0:d4:53:1f
-----BEGIN CERTIFICATE-----
MIIF8TCCA9mgAwIBAgIQALC3WhZIX7/hy/WL1xnmfTANBgkqhkiG9w0BAQsFADA4
MQswCQYDVQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6
ZW5wZS5jb20wHhcNMDcxMjEzMTMwODI4WhcNMzcxMjEzMDgyNzI1WjA4MQswCQYD
VQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5j
b20wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ03rKDx6sp4boFmVq
scIbRTJxldn+EFvMr+eleQGPicPK8lVx93e+d5TzcqQsRNiekpsUOqHnJJAKClaO
xdgmlOHZSOEtPtoKct2jmRXagaKH9HtuJneJWK3W6wyyQXpzbm3benhB6QiIEn6H
LmYRY2xU+zydcsC8Lv/Ct90NduM61/e0aL6i9eOBbsFGb12N4E3GVFWJGjMxCrFX
uaOKmMPsOzTFlUFpfnXCPCDFYbpRR6AgkJOhkEvzTnyFRVSa0QUmQbC1TR0zvsQD
yCV8wXDbO/QJLVQnSKwv4cSsPsjLkkxTOTcj7NMB+eAJRE1NZMDhDVqHIrytG6P+
JrUV86f8hBnp7KGItERphIPzidF0BqnMC9bC3ieFUCbKF7jJeodWLBoBHmy+E60Q
rLUk9TiRodZL2vG70t5HtfG8gfZZa88ZU+mNFctKy6lvROUbQc/hhqfK0GqfvEyN
BjNaooXlkDWgYlwWTvDjovoDGrQscbNYLN57C9saD+veIR8GdwYDsMnvmfzAuU8L
hij+0rnq49qlw0dpEuDb8PYZi+17cNcC1u2HGCgsBCRMd+RIihrGO5rUD8r6ddIB
QFqNeb+Lz0vPqhbBleStTIo+F5HUsWLlguWABKQDfo2/2n+iD5dPDNMN+9fR5XJ+
HMh3/1uaD7euBUbl8agW7EekFwIDAQABo4H2MIHzMIGwBgNVHREEgagwgaWBD2lu
Zm9AaXplbnBlLmNvbaSBkTCBjjFHMEUGA1UECgw+SVpFTlBFIFMuQS4gLSBDSUYg
QTAxMzM3MjYwLVJNZXJjLlZpdG9yaWEtR2FzdGVpeiBUMTA1NSBGNjIgUzgxQzBB
BgNVBAkMOkF2ZGEgZGVsIE1lZGl0ZXJyYW5lbyBFdG9yYmlkZWEgMTQgLSAwMTAx
MCBWaXRvcmlhLUdhc3RlaXowDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
AQYwHQYDVR0OBBYEFB0cZQ6o8iV7tJHP5LGx5r1VdGwFMA0GCSqGSIb3DQEBCwUA
A4ICAQB4pgwWSp9MiDrAyw6lFn2fuUhfGI8NYjb2zRlrrKvV9pF9rnHzP7MOeIWb
laQnIUdCSnxIOvVFfLMMjlF4rJUT3sb9fbgakEyrkgPH7UIBzg/YsfqikuFgba56
awmqxinuaElnMIAkejEWOVt+8Rwu3WwJrfIxwYJOubv5vr8qhT/AQKM6WfxZSzwo
JNu0FXWuDYi6LnPAvViH5ULy617uHjAimcs30cQhbIHsvm0m5hzkQiCeR7Csg1lw
LDXWrzY0tM07+DKo7+N4ifuNRSzanLh+QBxh5z6ikixL8s36mLYp//Pye6kfLqCT
VyvehQP5aTfLnnhqBbTFMXiJ7HqnheG5ezzevh55hM6fcA5ZwjUukCox2eRFekGk
LhObNA5me0mrZJfQRsN5nXJQY6aYWwa9SG3YOYNw6DXwBdGqvOPbyALqfP2C2sJb
UjWumDqtujWTI6cfSN01RpiyEGjkpTHCClguGYEQyVB1/OpaFs4R1+7vUIgtYf8/
QnMFlEPVjjxOAToZpR9GTnfQXeWBIiGH/pR9hNiTrdZoQ0iy2+tzJOeRf1SktoA+
naM8THLCV8Sg1Mw4J87VBp6iSNnpn86CcDaTmjvfliHjWbcM2pE38P1ZWrOZyGls
QyYBNWNgVYkDOnXYukrZVP/u3oDYLdE41V4tC5h9Pmzb/CaIxw==
-----END CERTIFICATE-----

# Issuer: CN=Chambers of Commerce Root - 2008 O=AC Camerfirma S.A.
# Subject: CN=Chambers of Commerce Root - 2008 O=AC Camerfirma S.A.
# Label: "Chambers of Commerce Root - 2008"
# Serial: 11806822484801597146
# MD5 Fingerprint: 5e:80:9e:84:5a:0e:65:0b:17:02:f3:55:18:2a:3e:d7
# SHA1 Fingerprint: 78:6a:74:ac:76:ab:14:7f:9c:6a:30:50:ba:9e:a8:7e:fe:9a:ce:3c
# SHA256 Fingerprint: 06:3e:4a:fa:c4:91:df:d3:32:f3:08:9b:85:42:e9:46:17:d8:93:d7:fe:94:4e:10:a7:93:7e:e2:9d:96:93:c0
-----BEGIN CERTIFICATE-----
MIIHTzCCBTegAwIBAgIJAKPaQn6ksa7aMA0GCSqGSIb3DQEBBQUAMIGuMQswCQYD
VQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0
IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3
MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xKTAnBgNVBAMTIENoYW1iZXJz
IG9mIENvbW1lcmNlIFJvb3QgLSAyMDA4MB4XDTA4MDgwMTEyMjk1MFoXDTM4MDcz
MTEyMjk1MFowga4xCzAJBgNVBAYTAkVVMUMwQQYDVQQHEzpNYWRyaWQgKHNlZSBj
dXJyZW50IGFkZHJlc3MgYXQgd3d3LmNhbWVyZmlybWEuY29tL2FkZHJlc3MpMRIw
EAYDVQQFEwlBODI3NDMyODcxGzAZBgNVBAoTEkFDIENhbWVyZmlybWEgUy5BLjEp
MCcGA1UEAxMgQ2hhbWJlcnMgb2YgQ29tbWVyY2UgUm9vdCAtIDIwMDgwggIiMA0G
CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCvAMtwNyuAWko6bHiUfaN/Gh/2NdW9
28sNRHI+JrKQUrpjOyhYb6WzbZSm891kDFX29ufyIiKAXuFixrYp4YFs8r/lfTJq
VKAyGVn+H4vXPWCGhSRv4xGzdz4gljUha7MI2XAuZPeEklPWDrCQiorjh40G072Q
DuKZoRuGDtqaCrsLYVAGUvGef3bsyw/QHg3PmTA9HMRFEFis1tPo1+XqxQEHd9ZR
5gN/ikilTWh1uem8nk4ZcfUyS5xtYBkL+8ydddy/Js2Pk3g5eXNeJQ7KXOt3EgfL
ZEFHcpOrUMPrCXZkNNI5t3YRCQ12RcSprj1qr7V9ZS+UWBDsXHyvfuK2GNnQm05a
Sd+pZgvMPMZ4fKecHePOjlO+Bd5gD2vlGts/4+EhySnB8esHnFIbAURRPHsl18Tl
UlRdJQfKFiC4reRB7noI/plvg6aRArBsNlVq5331lubKgdaX8ZSD6e2wsWsSaR6s
+12pxZjptFtYer49okQ6Y1nUCyXeG0+95QGezdIp1Z8XGQpvvwyQ0wlf2eOKNcx5
Wk0ZN5K3xMGtr/R5JJqyAQuxr1yW84Ay+1w9mPGgP0revq+ULtlVmhduYJ1jbLhj
ya6BXBg14JC7vjxPNyK5fuvPnnchpj04gftI2jE9K+OJ9dC1vX7gUMQSibMjmhAx
hduub+84Mxh2EQIDAQABo4IBbDCCAWgwEgYDVR0TAQH/BAgwBgEB/wIBDDAdBgNV
HQ4EFgQU+SSsD7K1+HnA+mCIG8TZTQKeFxkwgeMGA1UdIwSB2zCB2IAU+SSsD7K1
+HnA+mCIG8TZTQKeFxmhgbSkgbEwga4xCzAJBgNVBAYTAkVVMUMwQQYDVQQHEzpN
YWRyaWQgKHNlZSBjdXJyZW50IGFkZHJlc3MgYXQgd3d3LmNhbWVyZmlybWEuY29t
L2FkZHJlc3MpMRIwEAYDVQQFEwlBODI3NDMyODcxGzAZBgNVBAoTEkFDIENhbWVy
ZmlybWEgUy5BLjEpMCcGA1UEAxMgQ2hhbWJlcnMgb2YgQ29tbWVyY2UgUm9vdCAt
IDIwMDiCCQCj2kJ+pLGu2jAOBgNVHQ8BAf8EBAMCAQYwPQYDVR0gBDYwNDAyBgRV
HSAAMCowKAYIKwYBBQUHAgEWHGh0dHA6Ly9wb2xpY3kuY2FtZXJmaXJtYS5jb20w
DQYJKoZIhvcNAQEFBQADggIBAJASryI1wqM58C7e6bXpeHxIvj99RZJe6dqxGfwW
PJ+0W2aeaufDuV2I6A+tzyMP3iU6XsxPpcG1Lawk0lgH3qLPaYRgM+gQDROpI9CF
5Y57pp49chNyM/WqfcZjHwj0/gF/JM8rLFQJ3uIrbZLGOU8W6jx+ekbURWpGqOt1
glanq6B8aBMz9p0w8G8nOSQjKpD9kCk18pPfNKXG9/jvjA9iSnyu0/VU+I22mlaH
FoI6M6taIgj3grrqLuBHmrS1RaMFO9ncLkVAO+rcf+g769HsJtg1pDDFOqxXnrN2
pSB7+R5KBWIBpih1YJeSDW4+TTdDDZIVnBgizVGZoCkaPF+KMjNbMMeJL0eYD6MD
xvbxrN8y8NmBGuScvfaAFPDRLLmF9dijscilIeUcE5fuDr3fKanvNFNb0+RqE4QG
tjICxFKuItLcsiFCGtpA8CnJ7AoMXOLQusxI0zcKzBIKinmwPQN/aUv0NCB9szTq
jktk9T79syNnFQ0EuPAtwQlRPLJsFfClI9eDdOTlLsn+mCdCxqvGnrDQWzilm1De
fhiYtUU79nm06PcaewaD+9CL2rvHvRirCG88gGtAPxkZumWK5r7VXNM21+9AUiRg
OGcEMeyP84LG3rlV8zsxkVrctQgVrXYlCg17LofiDKYGvCYQbTed7N14jHyAxfDZ
d0jQ
-----END CERTIFICATE-----

# Issuer: CN=Global Chambersign Root - 2008 O=AC Camerfirma S.A.
# Subject: CN=Global Chambersign Root - 2008 O=AC Camerfirma S.A.
# Label: "Global Chambersign Root - 2008"
# Serial: 14541511773111788494
# MD5 Fingerprint: 9e:80:ff:78:01:0c:2e:c1:36:bd:fe:96:90:6e:08:f3
# SHA1 Fingerprint: 4a:bd:ee:ec:95:0d:35:9c:89:ae:c7:52:a1:2c:5b:29:f6:d6:aa:0c
# SHA256 Fingerprint: 13:63:35:43:93:34:a7:69:80:16:a0:d3:24:de:72:28:4e:07:9d:7b:52:20:bb:8f:bd:74:78:16:ee:be:ba:ca
-----BEGIN CERTIFICATE-----
MIIHSTCCBTGgAwIBAgIJAMnN0+nVfSPOMA0GCSqGSIb3DQEBBQUAMIGsMQswCQYD
VQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0
IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3
MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xJzAlBgNVBAMTHkdsb2JhbCBD
aGFtYmVyc2lnbiBSb290IC0gMjAwODAeFw0wODA4MDExMjMxNDBaFw0zODA3MzEx
MjMxNDBaMIGsMQswCQYDVQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3Vy
cmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAG
A1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xJzAl
BgNVBAMTHkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwODCCAiIwDQYJKoZI
hvcNAQEBBQADggIPADCCAgoCggIBAMDfVtPkOpt2RbQT2//BthmLN0EYlVJH6xed
KYiONWwGMi5HYvNJBL99RDaxccy9Wglz1dmFRP+RVyXfXjaOcNFccUMd2drvXNL7
G706tcuto8xEpw2uIRU/uXpbknXYpBI4iRmKt4DS4jJvVpyR1ogQC7N0ZJJ0YPP2
zxhPYLIj0Mc7zmFLmY/CDNBAspjcDahOo7kKrmCgrUVSY7pmvWjg+b4aqIG7HkF4
ddPB/gBVsIdU6CeQNR1MM62X/JcumIS/LMmjv9GYERTtY/jKmIhYF5ntRQOXfjyG
HoiMvvKRhI9lNNgATH23MRdaKXoKGCQwoze1eqkBfSbW+Q6OWfH9GzO1KTsXO0G2
Id3UwD2ln58fQ1DJu7xsepeY7s2MH/ucUa6LcL0nn3HAa6x9kGbo1106DbDVwo3V
yJ2dwW3Q0L9R5OP4wzg2rtandeavhENdk5IMagfeOx2YItaswTXbo6Al/3K1dh3e
beksZixShNBFks4c5eUzHdwHU1SjqoI7mjcv3N2gZOnm3b2u/GSFHTynyQbehP9r
6GsaPMWis0L7iwk+XwhSx2LE1AVxv8Rk5Pihg+g+EpuoHtQ2TS9x9o0o9oOpE9Jh
wZG7SMA0j0GMS0zbaRL/UJScIINZc+18ofLx/d33SdNDWKBWY8o9PeU1VlnpDsog
zCtLkykPAgMBAAGjggFqMIIBZjASBgNVHRMBAf8ECDAGAQH/AgEMMB0GA1UdDgQW
BBS5CcqcHtvTbDprru1U8VuTBjUuXjCB4QYDVR0jBIHZMIHWgBS5CcqcHtvTbDpr
ru1U8VuTBjUuXqGBsqSBrzCBrDELMAkGA1UEBhMCRVUxQzBBBgNVBAcTOk1hZHJp
ZCAoc2VlIGN1cnJlbnQgYWRkcmVzcyBhdCB3d3cuY2FtZXJmaXJtYS5jb20vYWRk
cmVzcykxEjAQBgNVBAUTCUE4Mjc0MzI4NzEbMBkGA1UEChMSQUMgQ2FtZXJmaXJt
YSBTLkEuMScwJQYDVQQDEx5HbG9iYWwgQ2hhbWJlcnNpZ24gUm9vdCAtIDIwMDiC
CQDJzdPp1X0jzjAOBgNVHQ8BAf8EBAMCAQYwPQYDVR0gBDYwNDAyBgRVHSAAMCow
KAYIKwYBBQUHAgEWHGh0dHA6Ly9wb2xpY3kuY2FtZXJmaXJtYS5jb20wDQYJKoZI
hvcNAQEFBQADggIBAICIf3DekijZBZRG/5BXqfEv3xoNa/p8DhxJJHkn2EaqbylZ
UohwEurdPfWbU1Rv4WCiqAm57OtZfMY18dwY6fFn5a+6ReAJ3spED8IXDneRRXoz
X1+WLGiLwUePmJs9wOzL9dWCkoQ10b42OFZyMVtHLaoXpGNR6woBrX/sdZ7LoR/x
fxKxueRkf2fWIyr0uDldmOghp+G9PUIadJpwr2hsUF1Jz//7Dl3mLEfXgTpZALVz
a2Mg9jFFCDkO9HB+QHBaP9BrQql0PSgvAm11cpUJjUhjxsYjV5KTXjXBjfkK9yyd
Yhz2rXzdpjEetrHHfoUm+qRqtdpjMNHvkzeyZi99Bffnt0uYlDXA2TopwZ2yUDMd
SqlapskD7+3056huirRXhOukP9DuqqqHW2Pok+JrqNS4cnhrG+055F3Lm6qH1U9O
AP7Zap88MQ8oAgF9mOinsKJknnn4SPIVqczmyETrP3iZ8ntxPjzxmKfFGBI/5rso
M0LpRQp8bfKGeS/Fghl9CYl8slR2iK7ewfPM4W7bMdaTrpmg7yVqc5iJWzouE4ge
v8CSlDQb4ye3ix5vQv/n6TebUB0tovkC7stYWDpxvGjjqsGvHCgfotwjZT+B6q6Z
09gwzxMNTxXJhLynSC34MCN32EZLeW32jO06f2ARePTpm67VVMB0gNELQp/B
-----END CERTIFICATE-----

# Issuer: CN=Go Daddy Root Certificate Authority - G2 O=GoDaddy.com, Inc.
# Subject: CN=Go Daddy Root Certificate Authority - G2 O=GoDaddy.com, Inc.
# Label: "Go Daddy Root Certificate Authority - G2"
# Serial: 0
# MD5 Fingerprint: 80:3a:bc:22:c1:e6:fb:8d:9b:3b:27:4a:32:1b:9a:01
# SHA1 Fingerprint: 47:be:ab:c9:22:ea:e8:0e:78:78:34:62:a7:9f:45:c2:54:fd:e6:8b
# SHA256 Fingerprint: 45:14:0b:32:47:eb:9c:c8:c5:b4:f0:d7:b5:30:91:f7:32:92:08:9e:6e:5a:63:e2:74:9d:d3:ac:a9:19:8e:da
-----BEGIN CERTIFICATE-----
MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMx
EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoT
EUdvRGFkZHkuY29tLCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRp
ZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIz
NTk1OVowgYMxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQH
EwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5LmNvbSwgSW5jLjExMC8GA1UE
AxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw
DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3gElY6SKD
E6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH
/PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7Rnwy
DfMAZiLIjWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVh
GkSBjCypQ5Yj36w6gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGR
tDtwKj9useiciAF9n9T521NtYJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEA
AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
FDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3DQEBCwUAA4IBAQCZ21151fmX
WWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC2gV7+AJ1uP2lsdeu
9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95kTXWXwTr
gIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo
2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPO
LPAvTK33sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI
4uJEvlz36hz1
-----END CERTIFICATE-----

# Issuer: CN=Starfield Root Certificate Authority - G2 O=Starfield Technologies, Inc.
# Subject: CN=Starfield Root Certificate Authority - G2 O=Starfield Technologies, Inc.
# Label: "Starfield Root Certificate Authority - G2"
# Serial: 0
# MD5 Fingerprint: d6:39:81:c6:52:7e:96:69:fc:fc:ca:66:ed:05:f2:96
# SHA1 Fingerprint: b5:1c:06:7c:ee:2b:0c:3d:f8:55:ab:2d:92:f4:fe:39:d4:e7:0f:0e
# SHA256 Fingerprint: 2c:e1:cb:0b:f9:d2:f9:e1:02:99:3f:be:21:51:52:c3:b2:dd:0c:ab:de:1c:68:e5:31:9b:83:91:54:db:b7:f5
-----BEGIN CERTIFICATE-----
MIID3TCCAsWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBjzELMAkGA1UEBhMCVVMx
EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT
HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAMTKVN0YXJmaWVs
ZCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAw
MFoXDTM3MTIzMTIzNTk1OVowgY8xCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6
b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFyZmllbGQgVGVj
aG5vbG9naWVzLCBJbmMuMTIwMAYDVQQDEylTdGFyZmllbGQgUm9vdCBDZXJ0aWZp
Y2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
ggEBAL3twQP89o/8ArFvW59I2Z154qK3A2FWGMNHttfKPTUuiUP3oWmb3ooa/RMg
nLRJdzIpVv257IzdIvpy3Cdhl+72WoTsbhm5iSzchFvVdPtrX8WJpRBSiUZV9Lh1
HOZ/5FSuS/hVclcCGfgXcVnrHigHdMWdSL5stPSksPNkN3mSwOxGXn/hbVNMYq/N
Hwtjuzqd+/x5AJhhdM8mgkBj87JyahkNmcrUDnXMN/uLicFZ8WJ/X7NfZTD4p7dN
dloedl40wOiWVpmKs/B/pM293DIxfJHP4F8R+GuqSVzRmZTRouNjWwl2tVZi4Ut0
HZbUJtQIBFnQmA4O5t78w+wfkPECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO
BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFHwMMh+n2TB/xH1oo2Kooc6rB1snMA0G
CSqGSIb3DQEBCwUAA4IBAQARWfolTwNvlJk7mh+ChTnUdgWUXuEok21iXQnCoKjU
sHU48TRqneSfioYmUeYs0cYtbpUgSpIB7LiKZ3sx4mcujJUDJi5DnUox9g61DLu3
4jd/IroAow57UvtruzvE03lRTs2Q9GcHGcg8RnoNAX3FWOdt5oUwF5okxBDgBPfg
8n/Uqgr/Qh037ZTlZFkSIHc40zI+OIF1lnP6aI+xy84fxez6nH7PfrHxBy22/L/K
pL/QlwVKvOoYKAKQvVR4CSFx09F9HdkWsKlhPdAKACL8x3vLCWRFCztAgfd9fDL1
mMpYjn0q7pBZc2T5NnReJaH1ZgUufzkVqSr7UIuOhWn0
-----END CERTIFICATE-----

# Issuer: CN=Starfield Services Root Certificate Authority - G2 O=Starfield Technologies, Inc.
# Subject: CN=Starfield Services Root Certificate Authority - G2 O=Starfield Technologies, Inc.
# Label: "Starfield Services Root Certificate Authority - G2"
# Serial: 0
# MD5 Fingerprint: 17:35:74:af:7b:61:1c:eb:f4:f9:3c:e2:ee:40:f9:a2
# SHA1 Fingerprint: 92:5a:8f:8d:2c:6d:04:e0:66:5f:59:6a:ff:22:d8:63:e8:25:6f:3f
# SHA256 Fingerprint: 56:8d:69:05:a2:c8:87:08:a4:b3:02:51:90:ed:cf:ed:b1:97:4a:60:6a:13:c6:e5:29:0f:cb:2a:e6:3e:da:b5
-----BEGIN CERTIFICATE-----
MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx
EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT
HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs
ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5
MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD
VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy
ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy
dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p
OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2
8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K
Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe
hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk
6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw
DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q
AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI
bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB
ve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z
qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd
iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn
0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN
sSi6
-----END CERTIFICATE-----

# Issuer: CN=AffirmTrust Commercial O=AffirmTrust
# Subject: CN=AffirmTrust Commercial O=AffirmTrust
# Label: "AffirmTrust Commercial"
# Serial: 8608355977964138876
# MD5 Fingerprint: 82:92:ba:5b:ef:cd:8a:6f:a6:3d:55:f9:84:f6:d6:b7
# SHA1 Fingerprint: f9:b5:b6:32:45:5f:9c:be:ec:57:5f:80:dc:e9:6e:2c:c7:b2:78:b7
# SHA256 Fingerprint: 03:76:ab:1d:54:c5:f9:80:3c:e4:b2:e2:01:a0:ee:7e:ef:7b:57:b6:36:e8:a9:3c:9b:8d:48:60:c9:6f:5f:a7
-----BEGIN CERTIFICATE-----
MIIDTDCCAjSgAwIBAgIId3cGJyapsXwwDQYJKoZIhvcNAQELBQAwRDELMAkGA1UE
BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVz
dCBDb21tZXJjaWFsMB4XDTEwMDEyOTE0MDYwNloXDTMwMTIzMTE0MDYwNlowRDEL
MAkGA1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZp
cm1UcnVzdCBDb21tZXJjaWFsMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
AQEA9htPZwcroRX1BiLLHwGy43NFBkRJLLtJJRTWzsO3qyxPxkEylFf6EqdbDuKP
Hx6GGaeqtS25Xw2Kwq+FNXkyLbscYjfysVtKPcrNcV/pQr6U6Mje+SJIZMblq8Yr
ba0F8PrVC8+a5fBQpIs7R6UjW3p6+DM/uO+Zl+MgwdYoic+U+7lF7eNAFxHUdPAL
MeIrJmqbTFeurCA+ukV6BfO9m2kVrn1OIGPENXY6BwLJN/3HR+7o8XYdcxXyl6S1
yHp52UKqK39c/s4mT6NmgTWvRLpUHhwwMmWd5jyTXlBOeuM61G7MGvv50jeuJCqr
VwMiKA1JdX+3KNp1v47j3A55MQIDAQABo0IwQDAdBgNVHQ4EFgQUnZPGU4teyq8/
nx4P5ZmVvCT2lI8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJ
KoZIhvcNAQELBQADggEBAFis9AQOzcAN/wr91LoWXym9e2iZWEnStB03TX8nfUYG
XUPGhi4+c7ImfU+TqbbEKpqrIZcUsd6M06uJFdhrJNTxFq7YpFzUf1GO7RgBsZNj
vbz4YYCanrHOQnDiqX0GJX0nof5v7LMeJNrjS1UaADs1tDvZ110w/YETifLCBivt
Z8SOyUOyXGsViQK8YvxO8rUzqrJv0wqiUOP2O+guRMLbZjipM1ZI8W0bM40NjD9g
N53Tym1+NH4Nn3J2ixufcv1SNUFFApYvHLKac0khsUlHRUe072o0EclNmsxZt9YC
nlpOZbWUrhvfKbAW8b8Angc6F2S1BLUjIZkKlTuXfO8=
-----END CERTIFICATE-----

# Issuer: CN=AffirmTrust Networking O=AffirmTrust
# Subject: CN=AffirmTrust Networking O=AffirmTrust
# Label: "AffirmTrust Networking"
# Serial: 8957382827206547757
# MD5 Fingerprint: 42:65:ca:be:01:9a:9a:4c:a9:8c:41:49:cd:c0:d5:7f
# SHA1 Fingerprint: 29:36:21:02:8b:20:ed:02:f5:66:c5:32:d1:d6:ed:90:9f:45:00:2f
# SHA256 Fingerprint: 0a:81:ec:5a:92:97:77:f1:45:90:4a:f3:8d:5d:50:9f:66:b5:e2:c5:8f:cd:b5:31:05:8b:0e:17:f3:f0:b4:1b
-----BEGIN CERTIFICATE-----
MIIDTDCCAjSgAwIBAgIIfE8EORzUmS0wDQYJKoZIhvcNAQEFBQAwRDELMAkGA1UE
BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVz
dCBOZXR3b3JraW5nMB4XDTEwMDEyOTE0MDgyNFoXDTMwMTIzMTE0MDgyNFowRDEL
MAkGA1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZp
cm1UcnVzdCBOZXR3b3JraW5nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
AQEAtITMMxcua5Rsa2FSoOujz3mUTOWUgJnLVWREZY9nZOIG41w3SfYvm4SEHi3y
YJ0wTsyEheIszx6e/jarM3c1RNg1lho9Nuh6DtjVR6FqaYvZ/Ls6rnla1fTWcbua
kCNrmreIdIcMHl+5ni36q1Mr3Lt2PpNMCAiMHqIjHNRqrSK6mQEubWXLviRmVSRL
QESxG9fhwoXA3hA/Pe24/PHxI1Pcv2WXb9n5QHGNfb2V1M6+oF4nI979ptAmDgAp
6zxG8D1gvz9Q0twmQVGeFDdCBKNwV6gbh+0t+nvujArjqWaJGctB+d1ENmHP4ndG
yH329JKBNv3bNPFyfvMMFr20FQIDAQABo0IwQDAdBgNVHQ4EFgQUBx/S55zawm6i
QLSwelAQUHTEyL0wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJ
KoZIhvcNAQEFBQADggEBAIlXshZ6qML91tmbmzTCnLQyFE2npN/svqe++EPbkTfO
tDIuUFUaNU52Q3Eg75N3ThVwLofDwR1t3Mu1J9QsVtFSUzpE0nPIxBsFZVpikpzu
QY0x2+c06lkh1QF612S4ZDnNye2v7UsDSKegmQGA3GWjNq5lWUhPgkvIZfFXHeVZ
Lgo/bNjR9eUJtGxUAArgFU2HdW23WJZa3W3SAKD0m0i+wzekujbgfIeFlxoVot4u
olu9rxj5kFDNcFn4J2dHy8egBzp90SxdbBk6ZrV9/ZFvgrG+CJPbFEfxojfHRZ48
x3evZKiT3/Zpg4Jg8klCNO1aAFSFHBY2kgxc+qatv9s=
-----END CERTIFICATE-----

# Issuer: CN=AffirmTrust Premium O=AffirmTrust
# Subject: CN=AffirmTrust Premium O=AffirmTrust
# Label: "AffirmTrust Premium"
# Serial: 7893706540734352110
# MD5 Fingerprint: c4:5d:0e:48:b6:ac:28:30:4e:0a:bc:f9:38:16:87:57
# SHA1 Fingerprint: d8:a6:33:2c:e0:03:6f:b1:85:f6:63:4f:7d:6a:06:65:26:32:28:27
# SHA256 Fingerprint: 70:a7:3f:7f:37:6b:60:07:42:48:90:45:34:b1:14:82:d5:bf:0e:69:8e:cc:49:8d:f5:25:77:eb:f2:e9:3b:9a
-----BEGIN CERTIFICATE-----
MIIFRjCCAy6gAwIBAgIIbYwURrGmCu4wDQYJKoZIhvcNAQEMBQAwQTELMAkGA1UE
BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1UcnVz
dCBQcmVtaXVtMB4XDTEwMDEyOTE0MTAzNloXDTQwMTIzMTE0MTAzNlowQTELMAkG
A1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1U
cnVzdCBQcmVtaXVtMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxBLf
qV/+Qd3d9Z+K4/as4Tx4mrzY8H96oDMq3I0gW64tb+eT2TZwamjPjlGjhVtnBKAQ
JG9dKILBl1fYSCkTtuG+kU3fhQxTGJoeJKJPj/CihQvL9Cl/0qRY7iZNyaqoe5rZ
+jjeRFcV5fiMyNlI4g0WJx0eyIOFJbe6qlVBzAMiSy2RjYvmia9mx+n/K+k8rNrS
s8PhaJyJ+HoAVt70VZVs+7pk3WKL3wt3MutizCaam7uqYoNMtAZ6MMgpv+0GTZe5
HMQxK9VfvFMSF5yZVylmd2EhMQcuJUmdGPLu8ytxjLW6OQdJd/zvLpKQBY0tL3d7
70O/Nbua2Plzpyzy0FfuKE4mX4+QaAkvuPjcBukumj5Rp9EixAqnOEhss/n/fauG
V+O61oV4d7pD6kh/9ti+I20ev9E2bFhc8e6kGVQa9QPSdubhjL08s9NIS+LI+H+S
qHZGnEJlPqQewQcDWkYtuJfzt9WyVSHvutxMAJf7FJUnM7/oQ0dG0giZFmA7mn7S
5u046uwBHjxIVkkJx0w3AJ6IDsBz4W9m6XJHMD4Q5QsDyZpCAGzFlH5hxIrff4Ia
C1nEWTJ3s7xgaVY5/bQGeyzWZDbZvUjthB9+pSKPKrhC9IK31FOQeE4tGv2Bb0TX
OwF0lkLgAOIua+rF7nKsu7/+6qqo+Nz2snmKtmcCAwEAAaNCMEAwHQYDVR0OBBYE
FJ3AZ6YMItkm9UWrpmVSESfYRaxjMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/
BAQDAgEGMA0GCSqGSIb3DQEBDAUAA4ICAQCzV00QYk465KzquByvMiPIs0laUZx2
KI15qldGF9X1Uva3ROgIRL8YhNILgM3FEv0AVQVhh0HctSSePMTYyPtwni94loMg
Nt58D2kTiKV1NpgIpsbfrM7jWNa3Pt668+s0QNiigfV4Py/VpfzZotReBA4Xrf5B
8OWycvpEgjNC6C1Y91aMYj+6QrCcDFx+LmUmXFNPALJ4fqENmS2NuB2OosSw/WDQ
MKSOyARiqcTtNd56l+0OOF6SL5Nwpamcb6d9Ex1+xghIsV5n61EIJenmJWtSKZGc
0jlzCFfemQa0W50QBuHCAKi4HEoCChTQwUHK+4w1IX2COPKpVJEZNZOUbWo6xbLQ
u4mGk+ibyQ86p3q4ofB4Rvr8Ny/lioTz3/4E2aFooC8k4gmVBtWVyuEklut89pMF
u+1z6S3RdTnX5yTb2E5fQ4+e0BQ5v1VwSJlXMbSc7kqYA5YwH2AG7hsj/oFgIxpH
YoWlzBk0gG+zrBrjn/B7SK3VAdlntqlyk+otZrWyuOQ9PLLvTIzq6we/qzWaVYa8
GKa1qF60g2xraUDTn9zxw2lrueFtCfTxqlB2Cnp9ehehVZZCmTEJ3WARjQUwfuaO
RtGdFNrHF+QFlozEJLUbzxQHskD4o55BhrwE0GuWyCqANP2/7waj3VjFhT0+j/6e
KeC2uAloGRwYQw==
-----END CERTIFICATE-----

# Issuer: CN=AffirmTrust Premium ECC O=AffirmTrust
# Subject: CN=AffirmTrust Premium ECC O=AffirmTrust
# Label: "AffirmTrust Premium ECC"
# Serial: 8401224907861490260
# MD5 Fingerprint: 64:b0:09:55:cf:b1:d5:99:e2:be:13:ab:a6:5d:ea:4d
# SHA1 Fingerprint: b8:23:6b:00:2f:1d:16:86:53:01:55:6c:11:a4:37:ca:eb:ff:c3:bb
# SHA256 Fingerprint: bd:71:fd:f6:da:97:e4:cf:62:d1:64:7a:dd:25:81:b0:7d:79:ad:f8:39:7e:b4:ec:ba:9c:5e:84:88:82:14:23
-----BEGIN CERTIFICATE-----
MIIB/jCCAYWgAwIBAgIIdJclisc/elQwCgYIKoZIzj0EAwMwRTELMAkGA1UEBhMC
VVMxFDASBgNVBAoMC0FmZmlybVRydXN0MSAwHgYDVQQDDBdBZmZpcm1UcnVzdCBQ
cmVtaXVtIEVDQzAeFw0xMDAxMjkxNDIwMjRaFw00MDEyMzExNDIwMjRaMEUxCzAJ
BgNVBAYTAlVTMRQwEgYDVQQKDAtBZmZpcm1UcnVzdDEgMB4GA1UEAwwXQWZmaXJt
VHJ1c3QgUHJlbWl1bSBFQ0MwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQNMF4bFZ0D
0KF5Nbc6PJJ6yhUczWLznCZcBz3lVPqj1swS6vQUX+iOGasvLkjmrBhDeKzQN8O9
ss0s5kfiGuZjuD0uL3jET9v0D6RoTFVya5UdThhClXjMNzyR4ptlKymjQjBAMB0G
A1UdDgQWBBSaryl6wBE1NSZRMADDav5A1a7WPDAPBgNVHRMBAf8EBTADAQH/MA4G
A1UdDwEB/wQEAwIBBjAKBggqhkjOPQQDAwNnADBkAjAXCfOHiFBar8jAQr9HX/Vs
aobgxCd05DhT1wV/GzTjxi+zygk8N53X57hG8f2h4nECMEJZh0PUUd+60wkyWs6I
flc9nF9Ca/UHLbXwgpP5WW+uZPpY5Yse42O+tYHNbwKMeQ==
-----END CERTIFICATE-----

# Issuer: CN=Certum Trusted Network CA O=Unizeto Technologies S.A. OU=Certum Certification Authority
# Subject: CN=Certum Trusted Network CA O=Unizeto Technologies S.A. OU=Certum Certification Authority
# Label: "Certum Trusted Network CA"
# Serial: 279744
# MD5 Fingerprint: d5:e9:81:40:c5:18:69:fc:46:2c:89:75:62:0f:aa:78
# SHA1 Fingerprint: 07:e0:32:e0:20:b7:2c:3f:19:2f:06:28:a2:59:3a:19:a7:0f:06:9e
# SHA256 Fingerprint: 5c:58:46:8d:55:f5:8e:49:7e:74:39:82:d2:b5:00:10:b6:d1:65:37:4a:cf:83:a7:d4:a3:2d:b7:68:c4:40:8e
-----BEGIN CERTIFICATE-----
MIIDuzCCAqOgAwIBAgIDBETAMA0GCSqGSIb3DQEBBQUAMH4xCzAJBgNVBAYTAlBM
MSIwIAYDVQQKExlVbml6ZXRvIFRlY2hub2xvZ2llcyBTLkEuMScwJQYDVQQLEx5D
ZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxIjAgBgNVBAMTGUNlcnR1bSBU
cnVzdGVkIE5ldHdvcmsgQ0EwHhcNMDgxMDIyMTIwNzM3WhcNMjkxMjMxMTIwNzM3
WjB+MQswCQYDVQQGEwJQTDEiMCAGA1UEChMZVW5pemV0byBUZWNobm9sb2dpZXMg
Uy5BLjEnMCUGA1UECxMeQ2VydHVtIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MSIw
IAYDVQQDExlDZXJ0dW0gVHJ1c3RlZCBOZXR3b3JrIENBMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEA4/t9o3K6wvDJFIf1awFO4W5AB7ptJ11/91sts1rH
UV+rpDKmYYe2bg+G0jACl/jXaVehGDldamR5xgFZrDwxSjh80gTSSyjoIF87B6LM
TXPb865Px1bVWqeWifrzq2jUI4ZZJ88JJ7ysbnKDHDBy3+Ci6dLhdHUZvSqeexVU
BBvXQzmtVSjF4hq79MDkrjhJM8x2hZ85RdKknvISjFH4fOQtf/WsX+sWn7Et0brM
kUJ3TCXJkDhv2/DM+44el1k+1WBO5gUo7Ul5E0u6SNsv+XLTOcr+H9g0cvW0QM8x
AcPs3hEtF10fuFDRXhmnad4HMyjKUJX5p1TLVIZQRan5SQIDAQABo0IwQDAPBgNV
HRMBAf8EBTADAQH/MB0GA1UdDgQWBBQIds3LB/8k9sXN7buQvOKEN0Z19zAOBgNV
HQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEBAKaorSLOAT2mo/9i0Eidi15y
sHhE49wcrwn9I0j6vSrEuVUEtRCjjSfeC4Jj0O7eDDd5QVsisrCaQVymcODU0HfL
I9MA4GxWL+FpDQ3Zqr8hgVDZBqWo/5U30Kr+4rP1mS1FhIrlQgnXdAIv94nYmem8
J9RHjboNRhx3zxSkHLmkMcScKHQDNP8zGSal6Q10tz6XxnboJ5ajZt3hrvJBW8qY
VoNzcOSGGtIxQbovvi0TWnZvTuhOgQ4/WwMioBK+ZlgRSssDxLQqKi2WF+A5VLxI
03YnnZotBqbJ7DnSq9ufmgsnAjUpsUCV5/nonFWIGUbWtzT1fs45mtk48VH3Tyw=
-----END CERTIFICATE-----

# Issuer: CN=Certinomis - Autorité Racine O=Certinomis OU=0002 433998903
# Subject: CN=Certinomis - Autorité Racine O=Certinomis OU=0002 433998903
# Label: "Certinomis - Autorité Racine"
# Serial: 1
# MD5 Fingerprint: 7f:30:78:8c:03:e3:ca:c9:0a:e2:c9:ea:1e:aa:55:1a
# SHA1 Fingerprint: 2e:14:da:ec:28:f0:fa:1e:8e:38:9a:4e:ab:eb:26:c0:0a:d3:83:c3
# SHA256 Fingerprint: fc:bf:e2:88:62:06:f7:2b:27:59:3c:8b:07:02:97:e1:2d:76:9e:d1:0e:d7:93:07:05:a8:09:8e:ff:c1:4d:17
-----BEGIN CERTIFICATE-----
MIIFnDCCA4SgAwIBAgIBATANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJGUjET
MBEGA1UEChMKQ2VydGlub21pczEXMBUGA1UECxMOMDAwMiA0MzM5OTg5MDMxJjAk
BgNVBAMMHUNlcnRpbm9taXMgLSBBdXRvcml0w6kgUmFjaW5lMB4XDTA4MDkxNzA4
Mjg1OVoXDTI4MDkxNzA4Mjg1OVowYzELMAkGA1UEBhMCRlIxEzARBgNVBAoTCkNl
cnRpbm9taXMxFzAVBgNVBAsTDjAwMDIgNDMzOTk4OTAzMSYwJAYDVQQDDB1DZXJ0
aW5vbWlzIC0gQXV0b3JpdMOpIFJhY2luZTCCAiIwDQYJKoZIhvcNAQEBBQADggIP
ADCCAgoCggIBAJ2Fn4bT46/HsmtuM+Cet0I0VZ35gb5j2CN2DpdUzZlMGvE5x4jY
F1AMnmHawE5V3udauHpOd4cN5bjr+p5eex7Ezyh0x5P1FMYiKAT5kcOrJ3NqDi5N
8y4oH3DfVS9O7cdxbwlyLu3VMpfQ8Vh30WC8Tl7bmoT2R2FFK/ZQpn9qcSdIhDWe
rP5pqZ56XjUl+rSnSTV3lqc2W+HN3yNw2F1MpQiD8aYkOBOo7C+ooWfHpi2GR+6K
/OybDnT0K0kCe5B1jPyZOQE51kqJ5Z52qz6WKDgmi92NjMD2AR5vpTESOH2VwnHu
7XSu5DaiQ3XV8QCb4uTXzEIDS3h65X27uK4uIJPT5GHfceF2Z5c/tt9qc1pkIuVC
28+BA5PY9OMQ4HL2AHCs8MF6DwV/zzRpRbWT5BnbUhYjBYkOjUjkJW+zeL9i9Qf6
lSTClrLooyPCXQP8w9PlfMl1I9f09bze5N/NgL+RiH2nE7Q5uiy6vdFrzPOlKO1E
nn1So2+WLhl+HPNbxxaOu2B9d2ZHVIIAEWBsMsGoOBvrbpgT1u449fCfDu/+MYHB
0iSVL1N6aaLwD4ZFjliCK0wi1F6g530mJ0jfJUaNSih8hp75mxpZuWW/Bd22Ql09
5gBIgl4g9xGC3srYn+Y3RyYe63j3YcNBZFgCQfna4NH4+ej9Uji29YnfAgMBAAGj
WzBZMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBQN
jLZh2kS40RR9w759XkjwzspqsDAXBgNVHSAEEDAOMAwGCiqBegFWAgIAAQEwDQYJ
KoZIhvcNAQEFBQADggIBACQ+YAZ+He86PtvqrxyaLAEL9MW12Ukx9F1BjYkMTv9s
ov3/4gbIOZ/xWqndIlgVqIrTseYyCYIDbNc/CMf4uboAbbnW/FIyXaR/pDGUu7ZM
OH8oMDX/nyNTt7buFHAAQCvaR6s0fl6nVjBhK4tDrP22iCj1a7Y+YEq6QpA0Z43q
619FVDsXrIvkxmUP7tCMXWY5zjKn2BCXwH40nJ+U8/aGH88bc62UeYdocMMzpXDn
2NU4lG9jeeu/Cg4I58UvD0KgKxRA/yHgBcUn4YQRE7rWhh1BCxMjidPJC+iKunqj
o3M3NYB9Ergzd0A4wPpeMNLytqOx1qKVl4GbUu1pTP+A5FPbVFsDbVRfsbjvJL1v
nxHDx2TCDyhihWZeGnuyt++uNckZM6i4J9szVb9o4XVIRFb7zdNIu0eJOqxp9YDG
5ERQL1TEqkPFMTFYvZbF6nVsmnWxTfj3l/+WFvKXTej28xH5On2KOG4Ey+HTRRWq
pdEdnV1j6CTmNhTih60bWfVEm/vXd3wfAXBioSAaosUaKPQhA+4u2cGA6rnZgtZb
dsLLO7XSAPCjDuGtbkD326C00EauFddEwk01+dIL8hf2rGbVJLJP0RyZwG71fet0
BLj5TXcJ17TPBzAJ8bgAVtkXFhYKK4bfjwEZGuW7gmP/vgt2Fl43N+bYdJeimUV5
-----END CERTIFICATE-----

# Issuer: CN=Root CA Generalitat Valenciana O=Generalitat Valenciana OU=PKIGVA
# Subject: CN=Root CA Generalitat Valenciana O=Generalitat Valenciana OU=PKIGVA
# Label: "Root CA Generalitat Valenciana"
# Serial: 994436456
# MD5 Fingerprint: 2c:8c:17:5e:b1:54:ab:93:17:b5:36:5a:db:d1:c6:f2
# SHA1 Fingerprint: a0:73:e5:c5:bd:43:61:0d:86:4c:21:13:0a:85:58:57:cc:9c:ea:46
# SHA256 Fingerprint: 8c:4e:df:d0:43:48:f3:22:96:9e:7e:29:a4:cd:4d:ca:00:46:55:06:1c:16:e1:b0:76:42:2e:f3:42:ad:63:0e
-----BEGIN CERTIFICATE-----
MIIGizCCBXOgAwIBAgIEO0XlaDANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJF
UzEfMB0GA1UEChMWR2VuZXJhbGl0YXQgVmFsZW5jaWFuYTEPMA0GA1UECxMGUEtJ
R1ZBMScwJQYDVQQDEx5Sb290IENBIEdlbmVyYWxpdGF0IFZhbGVuY2lhbmEwHhcN
MDEwNzA2MTYyMjQ3WhcNMjEwNzAxMTUyMjQ3WjBoMQswCQYDVQQGEwJFUzEfMB0G
A1UEChMWR2VuZXJhbGl0YXQgVmFsZW5jaWFuYTEPMA0GA1UECxMGUEtJR1ZBMScw
JQYDVQQDEx5Sb290IENBIEdlbmVyYWxpdGF0IFZhbGVuY2lhbmEwggEiMA0GCSqG
SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDGKqtXETcvIorKA3Qdyu0togu8M1JAJke+
WmmmO3I2F0zo37i7L3bhQEZ0ZQKQUgi0/6iMweDHiVYQOTPvaLRfX9ptI6GJXiKj
SgbwJ/BXufjpTjJ3Cj9BZPPrZe52/lSqfR0grvPXdMIKX/UIKFIIzFVd0g/bmoGl
u6GzwZTNVOAydTGRGmKy3nXiz0+J2ZGQD0EbtFpKd71ng+CT516nDOeB0/RSrFOy
A8dEJvt55cs0YFAQexvba9dHq198aMpunUEDEO5rmXteJajCq+TA81yc477OMUxk
Hl6AovWDfgzWyoxVjr7gvkkHD6MkQXpYHYTqWBLI4bft75PelAgxAgMBAAGjggM7
MIIDNzAyBggrBgEFBQcBAQQmMCQwIgYIKwYBBQUHMAGGFmh0dHA6Ly9vY3NwLnBr
aS5ndmEuZXMwEgYDVR0TAQH/BAgwBgEB/wIBAjCCAjQGA1UdIASCAiswggInMIIC
IwYKKwYBBAG/VQIBADCCAhMwggHoBggrBgEFBQcCAjCCAdoeggHWAEEAdQB0AG8A
cgBpAGQAYQBkACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEAYwBpAPMAbgAgAFIA
YQDtAHoAIABkAGUAIABsAGEAIABHAGUAbgBlAHIAYQBsAGkAdABhAHQAIABWAGEA
bABlAG4AYwBpAGEAbgBhAC4ADQAKAEwAYQAgAEQAZQBjAGwAYQByAGEAYwBpAPMA
bgAgAGQAZQAgAFAAcgDhAGMAdABpAGMAYQBzACAAZABlACAAQwBlAHIAdABpAGYA
aQBjAGEAYwBpAPMAbgAgAHEAdQBlACAAcgBpAGcAZQAgAGUAbAAgAGYAdQBuAGMA
aQBvAG4AYQBtAGkAZQBuAHQAbwAgAGQAZQAgAGwAYQAgAHAAcgBlAHMAZQBuAHQA
ZQAgAEEAdQB0AG8AcgBpAGQAYQBkACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEA
YwBpAPMAbgAgAHMAZQAgAGUAbgBjAHUAZQBuAHQAcgBhACAAZQBuACAAbABhACAA
ZABpAHIAZQBjAGMAaQDzAG4AIAB3AGUAYgAgAGgAdAB0AHAAOgAvAC8AdwB3AHcA
LgBwAGsAaQAuAGcAdgBhAC4AZQBzAC8AYwBwAHMwJQYIKwYBBQUHAgEWGWh0dHA6
Ly93d3cucGtpLmd2YS5lcy9jcHMwHQYDVR0OBBYEFHs100DSHHgZZu90ECjcPk+y
eAT8MIGVBgNVHSMEgY0wgYqAFHs100DSHHgZZu90ECjcPk+yeAT8oWykajBoMQsw
CQYDVQQGEwJFUzEfMB0GA1UEChMWR2VuZXJhbGl0YXQgVmFsZW5jaWFuYTEPMA0G
A1UECxMGUEtJR1ZBMScwJQYDVQQDEx5Sb290IENBIEdlbmVyYWxpdGF0IFZhbGVu
Y2lhbmGCBDtF5WgwDQYJKoZIhvcNAQEFBQADggEBACRhTvW1yEICKrNcda3Fbcrn
lD+laJWIwVTAEGmiEi8YPyVQqHxK6sYJ2fR1xkDar1CdPaUWu20xxsdzCkj+IHLt
b8zog2EWRpABlUt9jppSCS/2bxzkoXHPjCpaF3ODR00PNvsETUlR4hTJZGH71BTg
9J63NI8KJr2XXPR5OkowGcytT6CYirQxlyric21+eLj4iIlPsSKRZEv1UN4D2+XF
ducTZnV+ZfsBn5OHiJ35Rld8TWCvmHMTI6QgkYH60GFmuH3Rr9ZvHmw96RH9qfmC
IoaZM3Fa6hlXPZHNqcCjbgcTpsnt+GijnsNacgmHKNHEc8RzGF9QdRYxn7fofMM=
-----END CERTIFICATE-----

# Issuer: CN=A-Trust-nQual-03 O=A-Trust Ges. f. Sicherheitssysteme im elektr. Datenverkehr GmbH OU=A-Trust-nQual-03
# Subject: CN=A-Trust-nQual-03 O=A-Trust Ges. f. Sicherheitssysteme im elektr. Datenverkehr GmbH OU=A-Trust-nQual-03
# Label: "A-Trust-nQual-03"
# Serial: 93214
# MD5 Fingerprint: 49:63:ae:27:f4:d5:95:3d:d8:db:24:86:b8:9c:07:53
# SHA1 Fingerprint: d3:c0:63:f2:19:ed:07:3e:34:ad:5d:75:0b:32:76:29:ff:d5:9a:f2
# SHA256 Fingerprint: 79:3c:bf:45:59:b9:fd:e3:8a:b2:2d:f1:68:69:f6:98:81:ae:14:c4:b0:13:9a:c7:88:a7:8a:1a:fc:ca:02:fb
-----BEGIN CERTIFICATE-----
MIIDzzCCAregAwIBAgIDAWweMA0GCSqGSIb3DQEBBQUAMIGNMQswCQYDVQQGEwJB
VDFIMEYGA1UECgw/QS1UcnVzdCBHZXMuIGYuIFNpY2hlcmhlaXRzc3lzdGVtZSBp
bSBlbGVrdHIuIERhdGVudmVya2VociBHbWJIMRkwFwYDVQQLDBBBLVRydXN0LW5R
dWFsLTAzMRkwFwYDVQQDDBBBLVRydXN0LW5RdWFsLTAzMB4XDTA1MDgxNzIyMDAw
MFoXDTE1MDgxNzIyMDAwMFowgY0xCzAJBgNVBAYTAkFUMUgwRgYDVQQKDD9BLVRy
dXN0IEdlcy4gZi4gU2ljaGVyaGVpdHNzeXN0ZW1lIGltIGVsZWt0ci4gRGF0ZW52
ZXJrZWhyIEdtYkgxGTAXBgNVBAsMEEEtVHJ1c3QtblF1YWwtMDMxGTAXBgNVBAMM
EEEtVHJ1c3QtblF1YWwtMDMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
AQCtPWFuA/OQO8BBC4SAzewqo51ru27CQoT3URThoKgtUaNR8t4j8DRE/5TrzAUj
lUC5B3ilJfYKvUWG6Nm9wASOhURh73+nyfrBJcyFLGM/BWBzSQXgYHiVEEvc+RFZ
znF/QJuKqiTfC0Li21a8StKlDJu3Qz7dg9MmEALP6iPESU7l0+m0iKsMrmKS1GWH
2WrX9IWf5DMiJaXlyDO6w8dB3F/GaswADm0yqLaHNgBid5seHzTLkDx4iHQF63n1
k3Flyp3HaxgtPVxO59X4PzF9j4fsCiIvI+n+u33J4PTs63zEsMMtYrWacdaxaujs
2e3Vcuy+VwHOBVWf3tFgiBCzAgMBAAGjNjA0MA8GA1UdEwEB/wQFMAMBAf8wEQYD
VR0OBAoECERqlWdVeRFPMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQUFAAOC
AQEAVdRU0VlIXLOThaq/Yy/kgM40ozRiPvbY7meIMQQDbwvUB/tOdQ/TLtPAF8fG
KOwGDREkDg6lXb+MshOWcdzUzg4NCmgybLlBMRmrsQd7TZjTXLDR8KdCoLXEjq/+
8T/0709GAHbrAvv5ndJAlseIOrifEXnzgGWovR/TeIGgUUw3tKZdJXDRZslo+S4R
FGjxVJgIrCaSD96JntT6s3kr0qN51OyLrIdTaEJMUVF0HhsnLuP1Hyl0Te2v9+GS
mYHovjrHF1D2t8b8m7CKa9aIA5GPBnc6hQLdmNVDeD/GMBWsm2vLV7eJUYs66MmE
DNuxUCAKGkq6ahq97BvIxYSazQ==
-----END CERTIFICATE-----

# Issuer: CN=TWCA Root Certification Authority O=TAIWAN-CA OU=Root CA
# Subject: CN=TWCA Root Certification Authority O=TAIWAN-CA OU=Root CA
# Label: "TWCA Root Certification Authority"
# Serial: 1
# MD5 Fingerprint: aa:08:8f:f6:f9:7b:b7:f2:b1:a7:1e:9b:ea:ea:bd:79
# SHA1 Fingerprint: cf:9e:87:6d:d3:eb:fc:42:26:97:a3:b5:a3:7a:a0:76:a9:06:23:48
# SHA256 Fingerprint: bf:d8:8f:e1:10:1c:41:ae:3e:80:1b:f8:be:56:35:0e:e9:ba:d1:a6:b9:bd:51:5e:dc:5c:6d:5b:87:11:ac:44
-----BEGIN CERTIFICATE-----
MIIDezCCAmOgAwIBAgIBATANBgkqhkiG9w0BAQUFADBfMQswCQYDVQQGEwJUVzES
MBAGA1UECgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFU
V0NBIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwODI4MDcyNDMz
WhcNMzAxMjMxMTU1OTU5WjBfMQswCQYDVQQGEwJUVzESMBAGA1UECgwJVEFJV0FO
LUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFUV0NBIFJvb3QgQ2VydGlm
aWNhdGlvbiBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
AQCwfnK4pAOU5qfeCTiRShFAh6d8WWQUe7UREN3+v9XAu1bihSX0NXIP+FPQQeFE
AcK0HMMxQhZHhTMidrIKbw/lJVBPhYa+v5guEGcevhEFhgWQxFnQfHgQsIBct+HH
K3XLfJ+utdGdIzdjp9xCoi2SBBtQwXu4PhvJVgSLL1KbralW6cH/ralYhzC2gfeX
RfwZVzsrb+RH9JlF/h3x+JejiB03HFyP4HYlmlD4oFT/RJB2I9IyxsOrBr/8+7/z
rX2SYgJbKdM1o5OaQ2RgXbL6Mv87BK9NQGr5x+PvI/1ry+UPizgN7gr8/g+YnzAx
3WxSZfmLgb4i4RxYA7qRG4kHAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
HRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqOFsmjd6LWvJPelSDGRjjCDWmujANBgkq
hkiG9w0BAQUFAAOCAQEAPNV3PdrfibqHDAhUaiBQkr6wQT25JmSDCi/oQMCXKCeC
MErJk/9q56YAf4lCmtYR5VPOL8zy2gXE/uJQxDqGfczafhAJO5I1KlOy/usrBdls
XebQ79NqZp4VKIV66IIArB6nCWlWQtNoURi+VJq/REG6Sb4gumlc7rh3zc5sH62D
lhh9DrUUOYTxKOkto557HnpyWoOzeW/vtPzQCqVYT0bf+215WfKEIlKuD8z7fDvn
aspHYcN6+NOSBB+4IIThNlQWx0DeO4pz3N/GCUzf7Nr/1FNCocnyYh0igzyXxfkZ
YiesZSLX0zzG5Y6yU8xJzrww/nsOM5D77dIUkR8Hrw==
-----END CERTIFICATE-----

# Issuer: O=SECOM Trust Systems CO.,LTD. OU=Security Communication RootCA2
# Subject: O=SECOM Trust Systems CO.,LTD. OU=Security Communication RootCA2
# Label: "Security Communication RootCA2"
# Serial: 0
# MD5 Fingerprint: 6c:39:7d:a4:0e:55:59:b2:3f:d6:41:b1:12:50:de:43
# SHA1 Fingerprint: 5f:3b:8c:f2:f8:10:b3:7d:78:b4:ce:ec:19:19:c3:73:34:b9:c7:74
# SHA256 Fingerprint: 51:3b:2c:ec:b8:10:d4:cd:e5:dd:85:39:1a:df:c6:c2:dd:60:d8:7b:b7:36:d2:b5:21:48:4a:a4:7a:0e:be:f6
-----BEGIN CERTIFICATE-----
MIIDdzCCAl+gAwIBAgIBADANBgkqhkiG9w0BAQsFADBdMQswCQYDVQQGEwJKUDEl
MCMGA1UEChMcU0VDT00gVHJ1c3QgU3lzdGVtcyBDTy4sTFRELjEnMCUGA1UECxMe
U2VjdXJpdHkgQ29tbXVuaWNhdGlvbiBSb290Q0EyMB4XDTA5MDUyOTA1MDAzOVoX
DTI5MDUyOTA1MDAzOVowXTELMAkGA1UEBhMCSlAxJTAjBgNVBAoTHFNFQ09NIFRy
dXN0IFN5c3RlbXMgQ08uLExURC4xJzAlBgNVBAsTHlNlY3VyaXR5IENvbW11bmlj
YXRpb24gUm9vdENBMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANAV
OVKxUrO6xVmCxF1SrjpDZYBLx/KWvNs2l9amZIyoXvDjChz335c9S672XewhtUGr
zbl+dp+++T42NKA7wfYxEUV0kz1XgMX5iZnK5atq1LXaQZAQwdbWQonCv/Q4EpVM
VAX3NuRFg3sUZdbcDE3R3n4MqzvEFb46VqZab3ZpUql6ucjrappdUtAtCms1FgkQ
hNBqyjoGADdH5H5XTz+L62e4iKrFvlNVspHEfbmwhRkGeC7bYRr6hfVKkaHnFtWO
ojnflLhwHyg/i/xAXmODPIMqGplrz95Zajv8bxbXH/1KEOtOghY6rCcMU/Gt1SSw
awNQwS08Ft1ENCcadfsCAwEAAaNCMEAwHQYDVR0OBBYEFAqFqXdlBZh8QIH4D5cs
OPEK7DzPMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
DQEBCwUAA4IBAQBMOqNErLlFsceTfsgLCkLfZOoc7llsCLqJX2rKSpWeeo8HxdpF
coJxDjrSzG+ntKEju/Ykn8sX/oymzsLS28yN/HH8AynBbF0zX2S2ZTuJbxh2ePXc
okgfGT+Ok+vx+hfuzU7jBBJV1uXk3fs+BXziHV7Gp7yXT2g69ekuCkO2r1dcYmh8
t/2jioSgrGK+KwmHNPBqAbubKVY8/gA3zyNs8U6qtnRGEmyR7jTV7JqR50S+kDFy
1UkC9gLl9B/rfNmWVan/7Ir5mUf/NVoCqgTLiluHcSmRvaS0eg29mvVXIwAHIRc/
SjnRBUkLp7Y3gaVdjKozXoEofKd9J+sAro03
-----END CERTIFICATE-----

# Issuer: CN=Hellenic Academic and Research Institutions RootCA 2011 O=Hellenic Academic and Research Institutions Cert. Authority
# Subject: CN=Hellenic Academic and Research Institutions RootCA 2011 O=Hellenic Academic and Research Institutions Cert. Authority
# Label: "Hellenic Academic and Research Institutions RootCA 2011"
# Serial: 0
# MD5 Fingerprint: 73:9f:4c:4b:73:5b:79:e9:fa:ba:1c:ef:6e:cb:d5:c9
# SHA1 Fingerprint: fe:45:65:9b:79:03:5b:98:a1:61:b5:51:2e:ac:da:58:09:48:22:4d
# SHA256 Fingerprint: bc:10:4f:15:a4:8b:e7:09:dc:a5:42:a7:e1:d4:b9:df:6f:05:45:27:e8:02:ea:a9:2d:59:54:44:25:8a:fe:71
-----BEGIN CERTIFICATE-----
MIIEMTCCAxmgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBlTELMAkGA1UEBhMCR1Ix
RDBCBgNVBAoTO0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1
dGlvbnMgQ2VydC4gQXV0aG9yaXR5MUAwPgYDVQQDEzdIZWxsZW5pYyBBY2FkZW1p
YyBhbmQgUmVzZWFyY2ggSW5zdGl0dXRpb25zIFJvb3RDQSAyMDExMB4XDTExMTIw
NjEzNDk1MloXDTMxMTIwMTEzNDk1MlowgZUxCzAJBgNVBAYTAkdSMUQwQgYDVQQK
EztIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFyY2ggSW5zdGl0dXRpb25zIENl
cnQuIEF1dGhvcml0eTFAMD4GA1UEAxM3SGVsbGVuaWMgQWNhZGVtaWMgYW5kIFJl
c2VhcmNoIEluc3RpdHV0aW9ucyBSb290Q0EgMjAxMTCCASIwDQYJKoZIhvcNAQEB
BQADggEPADCCAQoCggEBAKlTAOMupvaO+mDYLZU++CwqVE7NuYRhlFhPjz2L5EPz
dYmNUeTDN9KKiE15HrcS3UN4SoqS5tdI1Q+kOilENbgH9mgdVc04UfCMJDGFr4PJ
fel3r+0ae50X+bOdOFAPplp5kYCvN66m0zH7tSYJnTxa71HFK9+WXesyHgLacEns
bgzImjeN9/E2YEsmLIKe0HjzDQ9jpFEw4fkrJxIH2Oq9GGKYsFk3fb7u8yBRQlqD
75O6aRXxYp2fmTmCobd0LovUxQt7L/DICto9eQqakxylKHJzkUOap9FNhYS5qXSP
FEDH3N6sQWRstBmbAmNtJGSPRLIl6s5ddAxjMlyNh+UCAwEAAaOBiTCBhjAPBgNV
HRMBAf8EBTADAQH/MAsGA1UdDwQEAwIBBjAdBgNVHQ4EFgQUppFC/RNhSiOeCKQp
5dgTBCPuQSUwRwYDVR0eBEAwPqA8MAWCAy5ncjAFggMuZXUwBoIELmVkdTAGggQu
b3JnMAWBAy5ncjAFgQMuZXUwBoEELmVkdTAGgQQub3JnMA0GCSqGSIb3DQEBBQUA
A4IBAQAf73lB4XtuP7KMhjdCSk4cNx6NZrokgclPEg8hwAOXhiVtXdMiKahsog2p
6z0GW5k6x8zDmjR/qw7IThzh+uTczQ2+vyT+bOdrwg3IBp5OjWEopmr95fZi6hg8
TqBTnbI6nOulnJEWtk2C4AwFSKls9cz4y51JtPACpf1wA+2KIaWuE4ZJwzNzvoc7
dIsXRSZMFpGD/md9zU1jZ/rzAxKWeAaNsWftjj++n08C9bMJL/NMh98qy5V8Acys
Nnq/onN694/BtZqhFLKPM58N7yLcZnuEvUUXBj08yrl3NI/K6s8/MT7jiOOASSXI
l7WdmplNsDz4SgCbZN2fOUvRJ9e4
-----END CERTIFICATE-----

# Issuer: CN=Actalis Authentication Root CA O=Actalis S.p.A./03358520967
# Subject: CN=Actalis Authentication Root CA O=Actalis S.p.A./03358520967
# Label: "Actalis Authentication Root CA"
# Serial: 6271844772424770508
# MD5 Fingerprint: 69:c1:0d:4f:07:a3:1b:c3:fe:56:3d:04:bc:11:f6:a6
# SHA1 Fingerprint: f3:73:b3:87:06:5a:28:84:8a:f2:f3:4a:ce:19:2b:dd:c7:8e:9c:ac
# SHA256 Fingerprint: 55:92:60:84:ec:96:3a:64:b9:6e:2a:be:01:ce:0b:a8:6a:64:fb:fe:bc:c7:aa:b5:af:c1:55:b3:7f:d7:60:66
-----BEGIN CERTIFICATE-----
MIIFuzCCA6OgAwIBAgIIVwoRl0LE48wwDQYJKoZIhvcNAQELBQAwazELMAkGA1UE
BhMCSVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8w
MzM1ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290
IENBMB4XDTExMDkyMjExMjIwMloXDTMwMDkyMjExMjIwMlowazELMAkGA1UEBhMC
SVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8wMzM1
ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290IENB
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAp8bEpSmkLO/lGMWwUKNv
UTufClrJwkg4CsIcoBh/kbWHuUA/3R1oHwiD1S0eiKD4j1aPbZkCkpAW1V8IbInX
4ay8IMKx4INRimlNAJZaby/ARH6jDuSRzVju3PvHHkVH3Se5CAGfpiEd9UEtL0z9
KK3giq0itFZljoZUj5NDKd45RnijMCO6zfB9E1fAXdKDa0hMxKufgFpbOr3JpyI/
gCczWw63igxdBzcIy2zSekciRDXFzMwujt0q7bd9Zg1fYVEiVRvjRuPjPdA1Yprb
rxTIW6HMiRvhMCb8oJsfgadHHwTrozmSBp+Z07/T6k9QnBn+locePGX2oxgkg4YQ
51Q+qDp2JE+BIcXjDwL4k5RHILv+1A7TaLndxHqEguNTVHnd25zS8gebLra8Pu2F
be8lEfKXGkJh90qX6IuxEAf6ZYGyojnP9zz/GPvG8VqLWeICrHuS0E4UT1lF9gxe
KF+w6D9Fz8+vm2/7hNN3WpVvrJSEnu68wEqPSpP4RCHiMUVhUE4Q2OM1fEwZtN4F
v6MGn8i1zeQf1xcGDXqVdFUNaBr8EBtiZJ1t4JWgw5QHVw0U5r0F+7if5t+L4sbn
fpb2U8WANFAoWPASUHEXMLrmeGO89LKtmyuy/uE5jF66CyCU3nuDuP/jVo23Eek7
jPKxwV2dpAtMK9myGPW1n0sCAwEAAaNjMGEwHQYDVR0OBBYEFFLYiDrIn3hm7Ynz
ezhwlMkCAjbQMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUUtiIOsifeGbt
ifN7OHCUyQICNtAwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBCwUAA4ICAQAL
e3KHwGCmSUyIWOYdiPcUZEim2FgKDk8TNd81HdTtBjHIgT5q1d07GjLukD0R0i70
jsNjLiNmsGe+b7bAEzlgqqI0JZN1Ut6nna0Oh4lScWoWPBkdg/iaKWW+9D+a2fDz
WochcYBNy+A4mz+7+uAwTc+G02UQGRjRlwKxK3JCaKygvU5a2hi/a5iB0P2avl4V
SM0RFbnAKVy06Ij3Pjaut2L9HmLecHgQHEhb2rykOLpn7VU+Xlff1ANATIGk0k9j
pwlCCRT8AKnCgHNPLsBA2RF7SOp6AsDT6ygBJlh0wcBzIm2Tlf05fbsq4/aC4yyX
X04fkZT6/iyj2HYauE2yOE+b+h1IYHkm4vP9qdCa6HCPSXrW5b0KDtst842/6+Ok
fcvHlXHo2qN8xcL4dJIEG4aspCJTQLas/kx2z/uUMsA1n3Y/buWQbqCmJqK4LL7R
K4X9p2jIugErsWx0Hbhzlefut8cl8ABMALJ+tguLHPPAUJ4lueAI3jZm/zel0btU
ZCzJJ7VLkn5l/9Mt4blOvH+kQSGQQXemOR/qnuOf0GZvBeyqdn6/axag67XH/JJU
LysRJyU3eExRarDzzFhdFPFqSBX/wge2sY0PjlxQRrM9vwGYT7JZVEc+NHt4bVaT
LnPqZih4zR0Uv6CPLy64Lo7yFIrM6bV8+2ydDKXhlg==
-----END CERTIFICATE-----

# Issuer: O=Trustis Limited OU=Trustis FPS Root CA
# Subject: O=Trustis Limited OU=Trustis FPS Root CA
# Label: "Trustis FPS Root CA"
# Serial: 36053640375399034304724988975563710553
# MD5 Fingerprint: 30:c9:e7:1e:6b:e6:14:eb:65:b2:16:69:20:31:67:4d
# SHA1 Fingerprint: 3b:c0:38:0b:33:c3:f6:a6:0c:86:15:22:93:d9:df:f5:4b:81:c0:04
# SHA256 Fingerprint: c1:b4:82:99:ab:a5:20:8f:e9:63:0a:ce:55:ca:68:a0:3e:da:5a:51:9c:88:02:a0:d3:a6:73:be:8f:8e:55:7d
-----BEGIN CERTIFICATE-----
MIIDZzCCAk+gAwIBAgIQGx+ttiD5JNM2a/fH8YygWTANBgkqhkiG9w0BAQUFADBF
MQswCQYDVQQGEwJHQjEYMBYGA1UEChMPVHJ1c3RpcyBMaW1pdGVkMRwwGgYDVQQL
ExNUcnVzdGlzIEZQUyBSb290IENBMB4XDTAzMTIyMzEyMTQwNloXDTI0MDEyMTEx
MzY1NFowRTELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1RydXN0aXMgTGltaXRlZDEc
MBoGA1UECxMTVHJ1c3RpcyBGUFMgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAMVQe547NdDfxIzNjpvto8A2mfRC6qc+gIMPpqdZh8mQRUN+
AOqGeSoDvT03mYlmt+WKVoaTnGhLaASMk5MCPjDSNzoiYYkchU59j9WvezX2fihH
iTHcDnlkH5nSW7r+f2C/revnPDgpai/lkQtV/+xvWNUtyd5MZnGPDNcE2gfmHhjj
vSkCqPoc4Vu5g6hBSLwacY3nYuUtsuvffM/bq1rKMfFMIvMFE/eC+XN5DL7XSxzA
0RU8k0Fk0ea+IxciAIleH2ulrG6nS4zto3Lmr2NNL4XSFDWaLk6M6jKYKIahkQlB
OrTh4/L68MkKokHdqeMDx4gVOxzUGpTXn2RZEm0CAwEAAaNTMFEwDwYDVR0TAQH/
BAUwAwEB/zAfBgNVHSMEGDAWgBS6+nEleYtXQSUhhgtx67JkDoshZzAdBgNVHQ4E
FgQUuvpxJXmLV0ElIYYLceuyZA6LIWcwDQYJKoZIhvcNAQEFBQADggEBAH5Y//01
GX2cGE+esCu8jowU/yyg2kdbw++BLa8F6nRIW/M+TgfHbcWzk88iNVy2P3UnXwmW
zaD+vkAMXBJV+JOCyinpXj9WV4s4NvdFGkwozZ5BuO1WTISkQMi4sKUraXAEasP4
1BIy+Q7DsdwyhEQsb8tGD+pmQQ9P8Vilpg0ND2HepZ5dfWWhPBfnqFVO76DH7cZE
f1T1o+CP8HxVIo8ptoGj4W1OLBuAZ+ytIJ8MYmHVl/9D7S3B2l0pKoU/rGXuhg8F
jZBf3+6f9L/uHfuY5H+QK4R4EA5sSVPvFVtlRkpdr7r7OnIdzfYliB6XzCGcKQEN
ZetX2fNXlrtIzYE=
-----END CERTIFICATE-----

# Issuer: CN=StartCom Certification Authority O=StartCom Ltd. OU=Secure Digital Certificate Signing
# Subject: CN=StartCom Certification Authority O=StartCom Ltd. OU=Secure Digital Certificate Signing
# Label: "StartCom Certification Authority"
# Serial: 45
# MD5 Fingerprint: c9:3b:0d:84:41:fc:a4:76:79:23:08:57:de:10:19:16
# SHA1 Fingerprint: a3:f1:33:3f:e2:42:bf:cf:c5:d1:4e:8f:39:42:98:40:68:10:d1:a0
# SHA256 Fingerprint: e1:78:90:ee:09:a3:fb:f4:f4:8b:9c:41:4a:17:d6:37:b7:a5:06:47:e9:bc:75:23:22:72:7f:cc:17:42:a9:11
-----BEGIN CERTIFICATE-----
MIIHhzCCBW+gAwIBAgIBLTANBgkqhkiG9w0BAQsFADB9MQswCQYDVQQGEwJJTDEW
MBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg
Q2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh
dGlvbiBBdXRob3JpdHkwHhcNMDYwOTE3MTk0NjM3WhcNMzYwOTE3MTk0NjM2WjB9
MQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMi
U2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3Rh
cnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA
A4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul38kMKogZk
pMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf
OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/C
Ji/6tRYccjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYT
Kqi5pquDSR3l8u/d5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNi
HzvEvqBTViVsUQn3qqvKv3b9bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMM
Av+Z6+hsTXBbKWWc3apdzK8BMewM69KN6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w
+2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHuEhANxjJ/GP/89PrNbpHoNkm+
Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZPV/+Qt+OR0t3vwmC3
Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOzEmDyei+B
26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID
AQABo4ICEDCCAgwwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD
VR0OBBYEFE4L7xqkQFulF2mHMMo0aEPQQa7yMB8GA1UdIwQYMBaAFE4L7xqkQFul
F2mHMMo0aEPQQa7yMIIBWgYDVR0gBIIBUTCCAU0wggFJBgsrBgEEAYG1NwEBATCC
ATgwLgYIKwYBBQUHAgEWImh0dHA6Ly93d3cuc3RhcnRzc2wuY29tL3BvbGljeS5w
ZGYwNAYIKwYBBQUHAgEWKGh0dHA6Ly93d3cuc3RhcnRzc2wuY29tL2ludGVybWVk
aWF0ZS5wZGYwgc8GCCsGAQUFBwICMIHCMCcWIFN0YXJ0IENvbW1lcmNpYWwgKFN0
YXJ0Q29tKSBMdGQuMAMCAQEagZZMaW1pdGVkIExpYWJpbGl0eSwgcmVhZCB0aGUg
c2VjdGlvbiAqTGVnYWwgTGltaXRhdGlvbnMqIG9mIHRoZSBTdGFydENvbSBDZXJ0
aWZpY2F0aW9uIEF1dGhvcml0eSBQb2xpY3kgYXZhaWxhYmxlIGF0IGh0dHA6Ly93
d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwEQYJYIZIAYb4QgEBBAQDAgAHMDgG
CWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTANBgkqhkiG9w0BAQsFAAOCAgEAjo/n3JR5fPGFf59Jb2vKXfuM/gTF
wWLRfUKKvFO3lANmMD+x5wqnUCBVJX92ehQN6wQOQOY+2IirByeDqXWmN3PH/UvS
Ta0XQMhGvjt/UfzDtgUx3M2FIk5xt/JxXrAaxrqTi3iSSoX4eA+D/i+tLPfkpLst
0OcNOrg+zvZ49q5HJMqjNTbOx8aHmNrs++myziebiMMEofYLWWivydsQD032ZGNc
pRJvkrKTlMeIFw6Ttn5ii5B/q06f/ON1FE8qMt9bDeD1e5MNq6HPh+GlBEXoPBKl
CcWw0bdT82AUuoVpaiF8H3VhFyAXe2w7QSlc4axa0c2Mm+tgHRns9+Ww2vl5GKVF
P0lDV9LdJNUso/2RjSe15esUBppMeyG7Oq0wBhjA2MFrLH9ZXF2RsXAiV+uKa0hK
1Q8p7MZAwC+ITGgBF3f0JBlPvfrhsiAhS90a2Cl9qrjeVOwhVYBsHvUwyKMQ5bLm
KhQxw4UtjJixhlpPiVktucf3HMiKf8CdBUrmQk9io20ppB+Fq9vlgcitKj1MXVuE
JnHEhV5xJMqlG2zYYdMa4FTbzrqpMrUi9nNBCV24F10OD5mQ1kfabwo6YigUZ4LZ
8dCAWZvLMdibD4x3TrVoivJs9iQOLWxwxXPR3hTQcY+203sC9uO41Alua551hDnm
fyWl8kgAwKQB2j8=
-----END CERTIFICATE-----

# Issuer: CN=StartCom Certification Authority G2 O=StartCom Ltd.
# Subject: CN=StartCom Certification Authority G2 O=StartCom Ltd.
# Label: "StartCom Certification Authority G2"
# Serial: 59
# MD5 Fingerprint: 78:4b:fb:9e:64:82:0a:d3:b8:4c:62:f3:64:f2:90:64
# SHA1 Fingerprint: 31:f1:fd:68:22:63:20:ee:c6:3b:3f:9d:ea:4a:3e:53:7c:7c:39:17
# SHA256 Fingerprint: c7:ba:65:67:de:93:a7:98:ae:1f:aa:79:1e:71:2d:37:8f:ae:1f:93:c4:39:7f:ea:44:1b:b7:cb:e6:fd:59:95
-----BEGIN CERTIFICATE-----
MIIFYzCCA0ugAwIBAgIBOzANBgkqhkiG9w0BAQsFADBTMQswCQYDVQQGEwJJTDEW
MBQGA1UEChMNU3RhcnRDb20gTHRkLjEsMCoGA1UEAxMjU3RhcnRDb20gQ2VydGlm
aWNhdGlvbiBBdXRob3JpdHkgRzIwHhcNMTAwMTAxMDEwMDAxWhcNMzkxMjMxMjM1
OTAxWjBTMQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjEsMCoG
A1UEAxMjU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgRzIwggIiMA0G
CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2iTZbB7cgNr2Cu+EWIAOVeq8Oo1XJ
JZlKxdBWQYeQTSFgpBSHO839sj60ZwNq7eEPS8CRhXBF4EKe3ikj1AENoBB5uNsD
vfOpL9HG4A/LnooUCri99lZi8cVytjIl2bLzvWXFDSxu1ZJvGIsAQRSCb0AgJnoo
D/Uefyf3lLE3PbfHkffiAez9lInhzG7TNtYKGXmu1zSCZf98Qru23QumNK9LYP5/
Q0kGi4xDuFby2X8hQxfqp0iVAXV16iulQ5XqFYSdCI0mblWbq9zSOdIxHWDirMxW
RST1HFSr7obdljKF+ExP6JV2tgXdNiNnvP8V4so75qbsO+wmETRIjfaAKxojAuuK
HDp2KntWFhxyKrOq42ClAJ8Em+JvHhRYW6Vsi1g8w7pOOlz34ZYrPu8HvKTlXcxN
nw3h3Kq74W4a7I/htkxNeXJdFzULHdfBR9qWJODQcqhaX2YtENwvKhOuJv4KHBnM
0D4LnMgJLvlblnpHnOl68wVQdJVznjAJ85eCXuaPOQgeWeU1FEIT/wCc976qUM/i
UUjXuG+v+E5+M5iSFGI6dWPPe/regjupuznixL0sAA7IF6wT700ljtizkC+p2il9
Ha90OrInwMEePnWjFqmveiJdnxMaz6eg6+OGCtP95paV1yPIN93EfKo2rJgaErHg
TuixO/XWb/Ew1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQE
AwIBBjAdBgNVHQ4EFgQUS8W0QGutHLOlHGVuRjaJhwUMDrYwDQYJKoZIhvcNAQEL
BQADggIBAHNXPyzVlTJ+N9uWkusZXn5T50HsEbZH77Xe7XRcxfGOSeD8bpkTzZ+K
2s06Ctg6Wgk/XzTQLwPSZh0avZyQN8gMjgdalEVGKua+etqhqaRpEpKwfTbURIfX
UfEpY9Z1zRbkJ4kd+MIySP3bmdCPX1R0zKxnNBFi2QwKN4fRoxdIjtIXHfbX/dtl
6/2o1PXWT6RbdejF0mCy2wl+JYt7ulKSnj7oxXehPOBKc2thz4bcQ///If4jXSRK
9dNtD2IEBVeC2m6kMyV5Sy5UGYvMLD0w6dEG/+gyRr61M3Z3qAFdlsHB1b6uJcDJ
HgoJIIihDsnzb02CVAAgp9KP5DlUFy6NHrgbuxu9mk47EDTcnIhT76IxW1hPkWLI
wpqazRVdOKnWvvgTtZ8SafJQYqz7Fzf07rh1Z2AQ+4NQ+US1dZxAF7L+/XldblhY
XzD8AK6vM8EOTmy6p6ahfzLbOOCxchcKK5HsamMm7YnUeMx0HgX4a/6ManY5Ka5l
IxKVCCIcl85bBu4M4ru8H0ST9tg4RQUh7eStqxK2A6RCLi3ECToDZ2mEmuFZkIoo
hdVddLHRDiBYmxOlsGOm7XtH/UVVMKTumtTm4ofvmMkyghEpIrwACjFeLQ/Ajulr
so8uBtjRkcfGEvRM/TAXw8HaOFvjqermobp573PYtlNXLfbQ4ddI
-----END CERTIFICATE-----

# Issuer: CN=Buypass Class 2 Root CA O=Buypass AS-983163327
# Subject: CN=Buypass Class 2 Root CA O=Buypass AS-983163327
# Label: "Buypass Class 2 Root CA"
# Serial: 2
# MD5 Fingerprint: 46:a7:d2:fe:45:fb:64:5a:a8:59:90:9b:78:44:9b:29
# SHA1 Fingerprint: 49:0a:75:74:de:87:0a:47:fe:58:ee:f6:c7:6b:eb:c6:0b:12:40:99
# SHA256 Fingerprint: 9a:11:40:25:19:7c:5b:b9:5d:94:e6:3d:55:cd:43:79:08:47:b6:46:b2:3c:df:11:ad:a4:a0:0e:ff:15:fb:48
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd
MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg
Q2xhc3MgMiBSb290IENBMB4XDTEwMTAyNjA4MzgwM1oXDTQwMTAyNjA4MzgwM1ow
TjELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAw
HgYDVQQDDBdCdXlwYXNzIENsYXNzIDIgUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEB
BQADggIPADCCAgoCggIBANfHXvfBB9R3+0Mh9PT1aeTuMgHbo4Yf5FkNuud1g1Lr
6hxhFUi7HQfKjK6w3Jad6sNgkoaCKHOcVgb/S2TwDCo3SbXlzwx87vFKu3MwZfPV
L4O2fuPn9Z6rYPnT8Z2SdIrkHJasW4DptfQxh6NR/Md+oW+OU3fUl8FVM5I+GC91
1K2GScuVr1QGbNgGE41b/+EmGVnAJLqBcXmQRFBoJJRfuLMR8SlBYaNByyM21cHx
MlAQTn/0hpPshNOOvEu/XAFOBz3cFIqUCqTqc/sLUegTBxj6DvEr0VQVfTzh97QZ
QmdiXnfgolXsttlpF9U6r0TtSsWe5HonfOV116rLJeffawrbD02TTqigzXsu8lkB
arcNuAeBfos4GzjmCleZPe4h6KP1DBbdi+w0jpwqHAAVF41og9JwnxgIzRFo1clr
Us3ERo/ctfPYV3Me6ZQ5BL/T3jjetFPsaRyifsSP5BtwrfKi+fv3FmRmaZ9JUaLi
FRhnBkp/1Wy1TbMz4GHrXb7pmA8y1x1LPC5aAVKRCfLf6o3YBkBjqhHk/sM3nhRS
P/TizPJhk9H9Z2vXUq6/aKtAQ6BXNVN48FP4YUIHZMbXb5tMOA1jrGKvNouicwoN
9SG9dKpN6nIDSdvHXx1iY8f93ZHsM+71bbRuMGjeyNYmsHVee7QHIJihdjK4TWxP
AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMmAd+BikoL1Rpzz
uvdMw964o605MA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAU18h
9bqwOlI5LJKwbADJ784g7wbylp7ppHR/ehb8t/W2+xUbP6umwHJdELFx7rxP462s
A20ucS6vxOOto70MEae0/0qyexAQH6dXQbLArvQsWdZHEIjzIVEpMMpghq9Gqx3t
OluwlN5E40EIosHsHdb9T7bWR9AUC8rmyrV7d35BH16Dx7aMOZawP5aBQW9gkOLo
+fsicdl9sz1Gv7SEr5AcD48Saq/v7h56rgJKihcrdv6sVIkkLE8/trKnToyokZf7
KcZ7XC25y2a2t6hbElGFtQl+Ynhw/qlqYLYdDnkM/crqJIByw5c/8nerQyIKx+u2
DISCLIBrQYoIwOula9+ZEsuK1V6ADJHgJgg2SMX6OBE1/yWDLfJ6v9r9jv6ly0Us
H8SIU653DtmadsWOLB2jutXsMq7Aqqz30XpN69QH4kj3Io6wpJ9qzo6ysmD0oyLQ
I+uUWnpp3Q+/QFesa1lQ2aOZ4W7+jQF5JyMV3pKdewlNWudLSDBaGOYKbeaP4NK7
5t98biGCwWg5TbSYWGZizEqQXsP6JwSxeRV0mcy+rSDeJmAc61ZRpqPq5KM/p/9h
3PFaTWwyI0PurKju7koSCTxdccK+efrCh2gdC/1cacwG0Jp9VJkqyTkaGa9LKkPz
Y11aWOIv4x3kqdbQCtCev9eBCfHJxyYNrJgWVqA=
-----END CERTIFICATE-----

# Issuer: CN=Buypass Class 3 Root CA O=Buypass AS-983163327
# Subject: CN=Buypass Class 3 Root CA O=Buypass AS-983163327
# Label: "Buypass Class 3 Root CA"
# Serial: 2
# MD5 Fingerprint: 3d:3b:18:9e:2c:64:5a:e8:d5:88:ce:0e:f9:37:c2:ec
# SHA1 Fingerprint: da:fa:f7:fa:66:84:ec:06:8f:14:50:bd:c7:c2:81:a5:bc:a9:64:57
# SHA256 Fingerprint: ed:f7:eb:bc:a2:7a:2a:38:4d:38:7b:7d:40:10:c6:66:e2:ed:b4:84:3e:4c:29:b4:ae:1d:5b:93:32:e6:b2:4d
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd
MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg
Q2xhc3MgMyBSb290IENBMB4XDTEwMTAyNjA4Mjg1OFoXDTQwMTAyNjA4Mjg1OFow
TjELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAw
HgYDVQQDDBdCdXlwYXNzIENsYXNzIDMgUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEB
BQADggIPADCCAgoCggIBAKXaCpUWUOOV8l6ddjEGMnqb8RB2uACatVI2zSRHsJ8Y
ZLya9vrVediQYkwiL944PdbgqOkcLNt4EemOaFEVcsfzM4fkoF0LXOBXByow9c3E
N3coTRiR5r/VUv1xLXA+58bEiuPwKAv0dpihi4dVsjoT/Lc+JzeOIuOoTyrvYLs9
tznDDgFHmV0ST9tD+leh7fmdvhFHJlsTmKtdFoqwNxxXnUX/iJY2v7vKB3tvh2PX
0DJq1l1sDPGzbjniazEuOQAnFN44wOwZZoYS6J1yFhNkUsepNxz9gjDthBgd9K5c
/3ATAOux9TN6S9ZV+AWNS2mw9bMoNlwUxFFzTWsL8TQH2xc519woe2v1n/MuwU8X
KhDzzMro6/1rqy6any2CbgTUUgGTLT2G/H783+9CHaZr77kgxve9oKeV/afmiSTY
zIw0bOIjL9kSGiG5VZFvC5F5GQytQIgLcOJ60g7YaEi7ghM5EFjp2CoHxhLbWNvS
O1UQRwUVZ2J+GGOmRj8JDlQyXr8NYnon74Do29lLBlo3WiXQCBJ31G8JUJc9yB3D
34xFMFbG02SrZvPAXpacw8Tvw3xrizp5f7NJzz3iiZ+gMEuFuZyUJHmPfWupRWgP
K9Dx2hzLabjKSWJtyNBjYt1gD1iqj6G8BaVmos8bdrKEZLFMOVLAMLrwjEsCsLa3
AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFEe4zf/lb+74suwv
Tg75JbCOPGvDMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAACAj
QTUEkMJAYmDv4jVM1z+s4jSQuKFvdvoWFqRINyzpkMLyPPgKn9iB5btb2iUspKdV
cSQy9sgL8rxq+JOssgfCX5/bzMiKqr5qb+FJEMwx14C7u8jYog5kV+qi9cKpMRXS
IGrs/CIBKM+GuIAeqcwRpTzyFrNHnfzSgCHEy9BHcEGhyoMZCCxt8l13nIoUE9Q2
HJLw5QY33KbmkJs4j1xrG0aGQ0JfPgEHU1RdZX33inOhmlRaHylDFCfChQ+1iHsa
O5S3HWCntZznKWlXWpuTekMwGwPXYshApqr8ZORK15FTAaggiG6cX0S5y2CBNOxv
033aSF/rtJC8LakcC6wc1aJoIIAE1vyxjy+7SjENSoYc6+I2KSb12tjE8nVhz36u
dmNKekBlk4f4HoCMhuWG1o8O/FMsYOgWYRqiPkN7zTlgVGr18okmAWiDSKIz6MkE
kbIRNBE+6tBDGR8Dk5AM/1E9V/RBbuHLoL7ryWPNbczk+DaqaJ3tvV2XcEQNtg41
3OEMXbugUZTLfhbrES+jkkXITHHZvMmZUldGL1DPvTVp9D0VzgalLA8+9oG6lLvD
u79leNKGef9JOxqDDPDeeOzI8k1MGt6CKfjBWtrt7uYnXuhF0J0cUahoq0Tj0Itq
4/g7u9xN12TyUb7mqqta6THuBrxzvxNiCp/HuZc=
-----END CERTIFICATE-----

# Issuer: CN=T-TeleSec GlobalRoot Class 3 O=T-Systems Enterprise Services GmbH OU=T-Systems Trust Center
# Subject: CN=T-TeleSec GlobalRoot Class 3 O=T-Systems Enterprise Services GmbH OU=T-Systems Trust Center
# Label: "T-TeleSec GlobalRoot Class 3"
# Serial: 1
# MD5 Fingerprint: ca:fb:40:a8:4e:39:92:8a:1d:fe:8e:2f:c4:27:ea:ef
# SHA1 Fingerprint: 55:a6:72:3e:cb:f2:ec:cd:c3:23:74:70:19:9d:2a:be:11:e3:81:d1
# SHA256 Fingerprint: fd:73:da:d3:1c:64:4f:f1:b4:3b:ef:0c:cd:da:96:71:0b:9c:d9:87:5e:ca:7e:31:70:7a:f3:e9:6d:52:2b:bd
-----BEGIN CERTIFICATE-----
MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUx
KzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAd
BgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNl
YyBHbG9iYWxSb290IENsYXNzIDMwHhcNMDgxMDAxMTAyOTU2WhcNMzMxMDAxMjM1
OTU5WjCBgjELMAkGA1UEBhMCREUxKzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnBy
aXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50
ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNzIDMwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC9dZPwYiJvJK7genasfb3ZJNW4t/zN
8ELg63iIVl6bmlQdTQyK9tPPcPRStdiTBONGhnFBSivwKixVA9ZIw+A5OO3yXDw/
RLyTPWGrTs0NvvAgJ1gORH8EGoel15YUNpDQSXuhdfsaa3Ox+M6pCSzyU9XDFES4
hqX2iys52qMzVNn6chr3IhUciJFrf2blw2qAsCTz34ZFiP0Zf3WHHx+xGwpzJFu5
ZeAsVMhg02YXP+HMVDNzkQI6pn97djmiH5a2OK61yJN0HZ65tOVgnS9W0eDrXltM
EnAMbEQgqxHY9Bn20pxSN+f6tsIxO0rUFJmtxxr1XV/6B7h8DR/Wgx6zAgMBAAGj
QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS1
A/d2O2GCahKqGFPrAyGUv/7OyjANBgkqhkiG9w0BAQsFAAOCAQEAVj3vlNW92nOy
WL6ukK2YJ5f+AbGwUgC4TeQbIXQbfsDuXmkqJa9c1h3a0nnJ85cp4IaH3gRZD/FZ
1GSFS5mvJQQeyUapl96Cshtwn5z2r3Ex3XsFpSzTucpH9sry9uetuUg/vBa3wW30
6gmv7PO15wWeph6KU1HWk4HMdJP2udqmJQV0eVp+QD6CSyYRMG7hP0HHRwA11fXT
91Q+gT3aSWqas+8QPebrb9HIIkfLzM8BMZLZGOMivgkeGj5asuRrDFR6fUNOuIml
e9eiPZaGzPImNC1qkp2aGtAw4l1OBLBfiyB+d8E9lYLRRpo7PHi4b6HQDWSieB4p
TpPDpFQUWw==
-----END CERTIFICATE-----

# Issuer: CN=EE Certification Centre Root CA O=AS Sertifitseerimiskeskus
# Subject: CN=EE Certification Centre Root CA O=AS Sertifitseerimiskeskus
# Label: "EE Certification Centre Root CA"
# Serial: 112324828676200291871926431888494945866
# MD5 Fingerprint: 43:5e:88:d4:7d:1a:4a:7e:fd:84:2e:52:eb:01:d4:6f
# SHA1 Fingerprint: c9:a8:b9:e7:55:80:5e:58:e3:53:77:a7:25:eb:af:c3:7b:27:cc:d7
# SHA256 Fingerprint: 3e:84:ba:43:42:90:85:16:e7:75:73:c0:99:2f:09:79:ca:08:4e:46:85:68:1f:f1:95:cc:ba:8a:22:9b:8a:76
-----BEGIN CERTIFICATE-----
MIIEAzCCAuugAwIBAgIQVID5oHPtPwBMyonY43HmSjANBgkqhkiG9w0BAQUFADB1
MQswCQYDVQQGEwJFRTEiMCAGA1UECgwZQVMgU2VydGlmaXRzZWVyaW1pc2tlc2t1
czEoMCYGA1UEAwwfRUUgQ2VydGlmaWNhdGlvbiBDZW50cmUgUm9vdCBDQTEYMBYG
CSqGSIb3DQEJARYJcGtpQHNrLmVlMCIYDzIwMTAxMDMwMTAxMDMwWhgPMjAzMDEy
MTcyMzU5NTlaMHUxCzAJBgNVBAYTAkVFMSIwIAYDVQQKDBlBUyBTZXJ0aWZpdHNl
ZXJpbWlza2Vza3VzMSgwJgYDVQQDDB9FRSBDZXJ0aWZpY2F0aW9uIENlbnRyZSBS
b290IENBMRgwFgYJKoZIhvcNAQkBFglwa2lAc2suZWUwggEiMA0GCSqGSIb3DQEB
AQUAA4IBDwAwggEKAoIBAQDIIMDs4MVLqwd4lfNE7vsLDP90jmG7sWLqI9iroWUy
euuOF0+W2Ap7kaJjbMeMTC55v6kF/GlclY1i+blw7cNRfdCT5mzrMEvhvH2/UpvO
bntl8jixwKIy72KyaOBhU8E2lf/slLo2rpwcpzIP5Xy0xm90/XsY6KxX7QYgSzIw
WFv9zajmofxwvI6Sc9uXp3whrj3B9UiHbCe9nyV0gVWw93X2PaRka9ZP585ArQ/d
MtO8ihJTmMmJ+xAdTX7Nfh9WDSFwhfYggx/2uh8Ej+p3iDXE/+pOoYtNP2MbRMNE
1CV2yreN1x5KZmTNXMWcg+HCCIia7E6j8T4cLNlsHaFLAgMBAAGjgYowgYcwDwYD
VR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFBLyWj7qVhy/
zQas8fElyalL1BSZMEUGA1UdJQQ+MDwGCCsGAQUFBwMCBggrBgEFBQcDAQYIKwYB
BQUHAwMGCCsGAQUFBwMEBggrBgEFBQcDCAYIKwYBBQUHAwkwDQYJKoZIhvcNAQEF
BQADggEBAHv25MANqhlHt01Xo/6tu7Fq1Q+e2+RjxY6hUFaTlrg4wCQiZrxTFGGV
v9DHKpY5P30osxBAIWrEr7BSdxjhlthWXePdNl4dp1BUoMUq5KqMlIpPnTX/dqQG
E5Gion0ARD9V04I8GtVbvFZMIi5GQ4okQC3zErg7cBqklrkar4dBGmoYDQZPxz5u
uSlNDUmJEYcyW+ZLBMjkXOZ0c5RdFpgTlf7727FE5TpwrDdr5rMzcijJs1eg9gIW
iAYLtqZLICjU3j2LrTcFU3T+bsy8QxdxXvnFzBqpYe73dgzzcvRyrc9yAjYHR8/v
GVCJYMzpJJUPwssd8m92kMfMdcGWxZ0=
-----END CERTIFICATE-----

# Issuer: CN=TÜRKTRUST Elektronik Sertifika Hizmet Sağlayıcısı O=TÜRKTRUST Bilgi İletişim ve Bilişim Güvenliği Hizmetleri A.Ş. (c) Aralık 2007
# Subject: CN=TÜRKTRUST Elektronik Sertifika Hizmet Sağlayıcısı O=TÜRKTRUST Bilgi İletişim ve Bilişim Güvenliği Hizmetleri A.Ş. (c) Aralık 2007
# Label: "TURKTRUST Certificate Services Provider Root 2007"
# Serial: 1
# MD5 Fingerprint: 2b:70:20:56:86:82:a0:18:c8:07:53:12:28:70:21:72
# SHA1 Fingerprint: f1:7f:6f:b6:31:dc:99:e3:a3:c8:7f:fe:1c:f1:81:10:88:d9:60:33
# SHA256 Fingerprint: 97:8c:d9:66:f2:fa:a0:7b:a7:aa:95:00:d9:c0:2e:9d:77:f2:cd:ad:a6:ad:6b:a7:4a:f4:b9:1c:66:59:3c:50
-----BEGIN CERTIFICATE-----
MIIEPTCCAyWgAwIBAgIBATANBgkqhkiG9w0BAQUFADCBvzE/MD0GA1UEAww2VMOc
UktUUlVTVCBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sx
c8SxMQswCQYDVQQGEwJUUjEPMA0GA1UEBwwGQW5rYXJhMV4wXAYDVQQKDFVUw5xS
S1RSVVNUIEJpbGdpIMSwbGV0acWfaW0gdmUgQmlsacWfaW0gR8O8dmVubGnEn2kg
SGl6bWV0bGVyaSBBLsWeLiAoYykgQXJhbMSxayAyMDA3MB4XDTA3MTIyNTE4Mzcx
OVoXDTE3MTIyMjE4MzcxOVowgb8xPzA9BgNVBAMMNlTDnFJLVFJVU1QgRWxla3Ry
b25payBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPEsTELMAkGA1UEBhMC
VFIxDzANBgNVBAcMBkFua2FyYTFeMFwGA1UECgxVVMOcUktUUlVTVCBCaWxnaSDE
sGxldGnFn2ltIHZlIEJpbGnFn2ltIEfDvHZlbmxpxJ9pIEhpem1ldGxlcmkgQS7F
ni4gKGMpIEFyYWzEsWsgMjAwNzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
ggEBAKu3PgqMyKVYFeaK7yc9SrToJdPNM8Ig3BnuiD9NYvDdE3ePYakqtdTyuTFY
KTsvP2qcb3N2Je40IIDu6rfwxArNK4aUyeNgsURSsloptJGXg9i3phQvKUmi8wUG
+7RP2qFsmmaf8EMJyupyj+sA1zU511YXRxcw9L6/P8JorzZAwan0qafoEGsIiveG
HtyaKhUG9qPw9ODHFNRRf8+0222vR5YXm3dx2KdxnSQM9pQ/hTEST7ruToK4uT6P
IzdezKKqdfcYbwnTrqdUKDT74eA7YH2gvnmJhsifLfkKS8RQouf9eRbHegsYz85M
733WB2+Y8a+xwXrXgTW4qhe04MsCAwEAAaNCMEAwHQYDVR0OBBYEFCnFkKslrxHk
Yb+j/4hhkeYO/pyBMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MA0G
CSqGSIb3DQEBBQUAA4IBAQAQDdr4Ouwo0RSVgrESLFF6QSU2TJ/sPx+EnWVUXKgW
AkD6bho3hO9ynYYKVZ1WKKxmLNA6VpM0ByWtCLCPyA8JWcqdmBzlVPi5RX9ql2+I
aE1KBiY3iAIOtsbWcpnOa3faYjGkVh+uX4132l32iPwa2Z61gfAyuOOI0JzzaqC5
mxRZNTZPz/OOXl0XrRWV2N2y1RVuAE6zS89mlOTgzbUF2mNXi+WzqtvALhyQRNsa
XRik7r4EW5nVcV9VZWRi1aKbBFmGyGJ353yCRWo9F7/snXUMrqNvWtMvmDb08PUZ
qxFdyKbjKlhqQgnDvZImZjINXQhVdP+MmNAKpoRq0Tl9
-----END CERTIFICATE-----

# Issuer: CN=D-TRUST Root Class 3 CA 2 2009 O=D-Trust GmbH
# Subject: CN=D-TRUST Root Class 3 CA 2 2009 O=D-Trust GmbH
# Label: "D-TRUST Root Class 3 CA 2 2009"
# Serial: 623603
# MD5 Fingerprint: cd:e0:25:69:8d:47:ac:9c:89:35:90:f7:fd:51:3d:2f
# SHA1 Fingerprint: 58:e8:ab:b0:36:15:33:fb:80:f7:9b:1b:6d:29:d3:ff:8d:5f:00:f0
# SHA256 Fingerprint: 49:e7:a4:42:ac:f0:ea:62:87:05:00:54:b5:25:64:b6:50:e4:f4:9e:42:e3:48:d6:aa:38:e0:39:e9:57:b1:c1
-----BEGIN CERTIFICATE-----
MIIEMzCCAxugAwIBAgIDCYPzMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNVBAYTAkRF
MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMMHkQtVFJVU1QgUm9vdCBD
bGFzcyAzIENBIDIgMjAwOTAeFw0wOTExMDUwODM1NThaFw0yOTExMDUwODM1NTha
ME0xCzAJBgNVBAYTAkRFMRUwEwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMM
HkQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIgMjAwOTCCASIwDQYJKoZIhvcNAQEB
BQADggEPADCCAQoCggEBANOySs96R+91myP6Oi/WUEWJNTrGa9v+2wBoqOADER03
UAifTUpolDWzU9GUY6cgVq/eUXjsKj3zSEhQPgrfRlWLJ23DEE0NkVJD2IfgXU42
tSHKXzlABF9bfsyjxiupQB7ZNoTWSPOSHjRGICTBpFGOShrvUD9pXRl/RcPHAY9R
ySPocq60vFYJfxLLHLGvKZAKyVXMD9O0Gu1HNVpK7ZxzBCHQqr0ME7UAyiZsxGsM
lFqVlNpQmvH/pStmMaTJOKDfHR+4CS7zp+hnUquVH+BGPtikw8paxTGA6Eian5Rp
/hnd2HN8gcqW3o7tszIFZYQ05ub9VxC1X3a/L7AQDcUCAwEAAaOCARowggEWMA8G
A1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFP3aFMSfMN4hvR5COfyrYyNJ4PGEMA4G
A1UdDwEB/wQEAwIBBjCB0wYDVR0fBIHLMIHIMIGAoH6gfIZ6bGRhcDovL2RpcmVj
dG9yeS5kLXRydXN0Lm5ldC9DTj1ELVRSVVNUJTIwUm9vdCUyMENsYXNzJTIwMyUy
MENBJTIwMiUyMDIwMDksTz1ELVRydXN0JTIwR21iSCxDPURFP2NlcnRpZmljYXRl
cmV2b2NhdGlvbmxpc3QwQ6BBoD+GPWh0dHA6Ly93d3cuZC10cnVzdC5uZXQvY3Js
L2QtdHJ1c3Rfcm9vdF9jbGFzc18zX2NhXzJfMjAwOS5jcmwwDQYJKoZIhvcNAQEL
BQADggEBAH+X2zDI36ScfSF6gHDOFBJpiBSVYEQBrLLpME+bUMJm2H6NMLVwMeni
acfzcNsgFYbQDfC+rAF1hM5+n02/t2A7nPPKHeJeaNijnZflQGDSNiH+0LS4F9p0
o3/U37CYAqxva2ssJSRyoWXuJVrl5jLn8t+rSfrzkGkj2wTZ51xY/GXUl77M/C4K
zCUqNQT4YJEVdT1B/yMfGchs64JTBKbkTCJNjYy6zltz7GRUUG3RnFX7acM2w4y8
PIWmawomDeCTmGCufsYkl4phX5GOZpIJhzbNi5stPvZR1FDUWSi9g/LMKHtThm3Y
Johw1+qRzT65ysCQblrGXnRl11z+o+I=
-----END CERTIFICATE-----

# Issuer: CN=D-TRUST Root Class 3 CA 2 EV 2009 O=D-Trust GmbH
# Subject: CN=D-TRUST Root Class 3 CA 2 EV 2009 O=D-Trust GmbH
# Label: "D-TRUST Root Class 3 CA 2 EV 2009"
# Serial: 623604
# MD5 Fingerprint: aa:c6:43:2c:5e:2d:cd:c4:34:c0:50:4f:11:02:4f:b6
# SHA1 Fingerprint: 96:c9:1b:0b:95:b4:10:98:42:fa:d0:d8:22:79:fe:60:fa:b9:16:83
# SHA256 Fingerprint: ee:c5:49:6b:98:8c:e9:86:25:b9:34:09:2e:ec:29:08:be:d0:b0:f3:16:c2:d4:73:0c:84:ea:f1:f3:d3:48:81
-----BEGIN CERTIFICATE-----
MIIEQzCCAyugAwIBAgIDCYP0MA0GCSqGSIb3DQEBCwUAMFAxCzAJBgNVBAYTAkRF
MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNVBAMMIUQtVFJVU1QgUm9vdCBD
bGFzcyAzIENBIDIgRVYgMjAwOTAeFw0wOTExMDUwODUwNDZaFw0yOTExMDUwODUw
NDZaMFAxCzAJBgNVBAYTAkRFMRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNV
BAMMIUQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIgRVYgMjAwOTCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAJnxhDRwui+3MKCOvXwEz75ivJn9gpfSegpn
ljgJ9hBOlSJzmY3aFS3nBfwZcyK3jpgAvDw9rKFs+9Z5JUut8Mxk2og+KbgPCdM0
3TP1YtHhzRnp7hhPTFiu4h7WDFsVWtg6uMQYZB7jM7K1iXdODL/ZlGsTl28So/6Z
qQTMFexgaDbtCHu39b+T7WYxg4zGcTSHThfqr4uRjRxWQa4iN1438h3Z0S0NL2lR
p75mpoo6Kr3HGrHhFPC+Oh25z1uxav60sUYgovseO3Dvk5h9jHOW8sXvhXCtKSb8
HgQ+HKDYD8tSg2J87otTlZCpV6LqYQXY+U3EJ/pure3511H3a6UCAwEAAaOCASQw
ggEgMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNOUikxiEyoZLsyvcop9Ntea
HNxnMA4GA1UdDwEB/wQEAwIBBjCB3QYDVR0fBIHVMIHSMIGHoIGEoIGBhn9sZGFw
Oi8vZGlyZWN0b3J5LmQtdHJ1c3QubmV0L0NOPUQtVFJVU1QlMjBSb290JTIwQ2xh
c3MlMjAzJTIwQ0ElMjAyJTIwRVYlMjAyMDA5LE89RC1UcnVzdCUyMEdtYkgsQz1E
RT9jZXJ0aWZpY2F0ZXJldm9jYXRpb25saXN0MEagRKBChkBodHRwOi8vd3d3LmQt
dHJ1c3QubmV0L2NybC9kLXRydXN0X3Jvb3RfY2xhc3NfM19jYV8yX2V2XzIwMDku
Y3JsMA0GCSqGSIb3DQEBCwUAA4IBAQA07XtaPKSUiO8aEXUHL7P+PPoeUSbrh/Yp
3uDx1MYkCenBz1UbtDDZzhr+BlGmFaQt77JLvyAoJUnRpjZ3NOhk31KxEcdzes05
nsKtjHEh8lprr988TlWvsoRlFIm5d8sqMb7Po23Pb0iUMkZv53GMoKaEGTcH8gNF
CSuGdXzfX2lXANtu2KZyIktQ1HWYVt+3GP9DQ1CuekR78HlR10M9p9OB0/DJT7na
xpeG0ILD5EJt/rDiZE4OJudANCa1CInXCGNjOCd1HjPqbqjdn5lPdE2BiYBL3ZqX
KVwvvoFBuYz/6n1gBp7N1z3TLqMVvKjmJuVvw9y4AyHqnxbxLFS1
-----END CERTIFICATE-----

# Issuer: CN=Autoridad de Certificacion Raiz del Estado Venezolano O=Sistema Nacional de Certificacion Electronica OU=Superintendencia de Servicios de Certificacion Electronica
# Subject: CN=PSCProcert O=Sistema Nacional de Certificacion Electronica OU=Proveedor de Certificados PROCERT
# Label: "PSCProcert"
# Serial: 11
# MD5 Fingerprint: e6:24:e9:12:01:ae:0c:de:8e:85:c4:ce:a3:12:dd:ec
# SHA1 Fingerprint: 70:c1:8d:74:b4:28:81:0a:e4:fd:a5:75:d7:01:9f:99:b0:3d:50:74
# SHA256 Fingerprint: 3c:fc:3c:14:d1:f6:84:ff:17:e3:8c:43:ca:44:0c:00:b9:67:ec:93:3e:8b:fe:06:4c:a1:d7:2c:90:f2:ad:b0
-----BEGIN CERTIFICATE-----
MIIJhjCCB26gAwIBAgIBCzANBgkqhkiG9w0BAQsFADCCAR4xPjA8BgNVBAMTNUF1
dG9yaWRhZCBkZSBDZXJ0aWZpY2FjaW9uIFJhaXogZGVsIEVzdGFkbyBWZW5lem9s
YW5vMQswCQYDVQQGEwJWRTEQMA4GA1UEBxMHQ2FyYWNhczEZMBcGA1UECBMQRGlz
dHJpdG8gQ2FwaXRhbDE2MDQGA1UEChMtU2lzdGVtYSBOYWNpb25hbCBkZSBDZXJ0
aWZpY2FjaW9uIEVsZWN0cm9uaWNhMUMwQQYDVQQLEzpTdXBlcmludGVuZGVuY2lh
IGRlIFNlcnZpY2lvcyBkZSBDZXJ0aWZpY2FjaW9uIEVsZWN0cm9uaWNhMSUwIwYJ
KoZIhvcNAQkBFhZhY3JhaXpAc3VzY2VydGUuZ29iLnZlMB4XDTEwMTIyODE2NTEw
MFoXDTIwMTIyNTIzNTk1OVowgdExJjAkBgkqhkiG9w0BCQEWF2NvbnRhY3RvQHBy
b2NlcnQubmV0LnZlMQ8wDQYDVQQHEwZDaGFjYW8xEDAOBgNVBAgTB01pcmFuZGEx
KjAoBgNVBAsTIVByb3ZlZWRvciBkZSBDZXJ0aWZpY2Fkb3MgUFJPQ0VSVDE2MDQG
A1UEChMtU2lzdGVtYSBOYWNpb25hbCBkZSBDZXJ0aWZpY2FjaW9uIEVsZWN0cm9u
aWNhMQswCQYDVQQGEwJWRTETMBEGA1UEAxMKUFNDUHJvY2VydDCCAiIwDQYJKoZI
hvcNAQEBBQADggIPADCCAgoCggIBANW39KOUM6FGqVVhSQ2oh3NekS1wwQYalNo9
7BVCwfWMrmoX8Yqt/ICV6oNEolt6Vc5Pp6XVurgfoCfAUFM+jbnADrgV3NZs+J74
BCXfgI8Qhd19L3uA3VcAZCP4bsm+lU/hdezgfl6VzbHvvnpC2Mks0+saGiKLt38G
ieU89RLAu9MLmV+QfI4tL3czkkohRqipCKzx9hEC2ZUWno0vluYC3XXCFCpa1sl9
JcLB/KpnheLsvtF8PPqv1W7/U0HU9TI4seJfxPmOEO8GqQKJ/+MMbpfg353bIdD0
PghpbNjU5Db4g7ayNo+c7zo3Fn2/omnXO1ty0K+qP1xmk6wKImG20qCZyFSTXai2
0b1dCl53lKItwIKOvMoDKjSuc/HUtQy9vmebVOvh+qBa7Dh+PsHMosdEMXXqP+UH
0quhJZb25uSgXTcYOWEAM11G1ADEtMo88aKjPvM6/2kwLkDd9p+cJsmWN63nOaK/
6mnbVSKVUyqUtd+tFjiBdWbjxywbk5yqjKPK2Ww8F22c3HxT4CAnQzb5EuE8XL1m
v6JpIzi4mWCZDlZTOpx+FIywBm/xhnaQr/2v/pDGj59/i5IjnOcVdo/Vi5QTcmn7
K2FjiO/mpF7moxdqWEfLcU8UC17IAggmosvpr2uKGcfLFFb14dq12fy/czja+eev
bqQ34gcnAgMBAAGjggMXMIIDEzASBgNVHRMBAf8ECDAGAQH/AgEBMDcGA1UdEgQw
MC6CD3N1c2NlcnRlLmdvYi52ZaAbBgVghl4CAqASDBBSSUYtRy0yMDAwNDAzNi0w
MB0GA1UdDgQWBBRBDxk4qpl/Qguk1yeYVKIXTC1RVDCCAVAGA1UdIwSCAUcwggFD
gBStuyIdxuDSAaj9dlBSk+2YwU2u06GCASakggEiMIIBHjE+MDwGA1UEAxM1QXV0
b3JpZGFkIGRlIENlcnRpZmljYWNpb24gUmFpeiBkZWwgRXN0YWRvIFZlbmV6b2xh
bm8xCzAJBgNVBAYTAlZFMRAwDgYDVQQHEwdDYXJhY2FzMRkwFwYDVQQIExBEaXN0
cml0byBDYXBpdGFsMTYwNAYDVQQKEy1TaXN0ZW1hIE5hY2lvbmFsIGRlIENlcnRp
ZmljYWNpb24gRWxlY3Ryb25pY2ExQzBBBgNVBAsTOlN1cGVyaW50ZW5kZW5jaWEg
ZGUgU2VydmljaW9zIGRlIENlcnRpZmljYWNpb24gRWxlY3Ryb25pY2ExJTAjBgkq
hkiG9w0BCQEWFmFjcmFpekBzdXNjZXJ0ZS5nb2IudmWCAQowDgYDVR0PAQH/BAQD
AgEGME0GA1UdEQRGMESCDnByb2NlcnQubmV0LnZloBUGBWCGXgIBoAwMClBTQy0w
MDAwMDKgGwYFYIZeAgKgEgwQUklGLUotMzE2MzUzNzMtNzB2BgNVHR8EbzBtMEag
RKBChkBodHRwOi8vd3d3LnN1c2NlcnRlLmdvYi52ZS9sY3IvQ0VSVElGSUNBRE8t
UkFJWi1TSEEzODRDUkxERVIuY3JsMCOgIaAfhh1sZGFwOi8vYWNyYWl6LnN1c2Nl
cnRlLmdvYi52ZTA3BggrBgEFBQcBAQQrMCkwJwYIKwYBBQUHMAGGG2h0dHA6Ly9v
Y3NwLnN1c2NlcnRlLmdvYi52ZTBBBgNVHSAEOjA4MDYGBmCGXgMBAjAsMCoGCCsG
AQUFBwIBFh5odHRwOi8vd3d3LnN1c2NlcnRlLmdvYi52ZS9kcGMwDQYJKoZIhvcN
AQELBQADggIBACtZ6yKZu4SqT96QxtGGcSOeSwORR3C7wJJg7ODU523G0+1ng3dS
1fLld6c2suNUvtm7CpsR72H0xpkzmfWvADmNg7+mvTV+LFwxNG9s2/NkAZiqlCxB
3RWGymspThbASfzXg0gTB1GEMVKIu4YXx2sviiCtxQuPcD4quxtxj7mkoP3Yldmv
Wb8lK5jpY5MvYB7Eqvh39YtsL+1+LrVPQA3uvFd359m21D+VJzog1eWuq2w1n8Gh
HVnchIHuTQfiSLaeS5UtQbHh6N5+LwUeaO6/u5BlOsju6rEYNxxik6SgMexxbJHm
pHmJWhSnFFAFTKQAVzAswbVhltw+HoSvOULP5dAssSS830DD7X9jSr3hTxJkhpXz
sOfIt+FTvZLm8wyWuevo5pLtp4EJFAv8lXrPj9Y0TzYS3F7RNHXGRoAvlQSMx4bE
qCaJqD8Zm4G7UaRKhqsLEQ+xrmNTbSjq3TNWOByyrYDT13K9mmyZY+gAu0F2Bbdb
mRiKw7gSXFbPVgx96OLP7bx0R/vu0xdOIk9W/1DzLuY5poLWccret9W6aAjtmcz9
opLLabid+Qqkpj5PkygqYWwHJgD/ll9ohri4zspV4KuxPX+Y1zMOWj3YeMLEYC/H
YvBhkdI4sPaeVdtAgAUSM84dkpvRabP/v/GSCmE1P93+hvS84Bpxs2Km
-----END CERTIFICATE-----

# Issuer: CN=China Internet Network Information Center EV Certificates Root O=China Internet Network Information Center
# Subject: CN=China Internet Network Information Center EV Certificates Root O=China Internet Network Information Center
# Label: "China Internet Network Information Center EV Certificates Root"
# Serial: 1218379777
# MD5 Fingerprint: 55:5d:63:00:97:bd:6a:97:f5:67:ab:4b:fb:6e:63:15
# SHA1 Fingerprint: 4f:99:aa:93:fb:2b:d1:37:26:a1:99:4a:ce:7f:f0:05:f2:93:5d:1e
# SHA256 Fingerprint: 1c:01:c6:f4:db:b2:fe:fc:22:55:8b:2b:ca:32:56:3f:49:84:4a:cf:c3:2b:7b:e4:b0:ff:59:9f:9e:8c:7a:f7
-----BEGIN CERTIFICATE-----
MIID9zCCAt+gAwIBAgIESJ8AATANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMC
Q04xMjAwBgNVBAoMKUNoaW5hIEludGVybmV0IE5ldHdvcmsgSW5mb3JtYXRpb24g
Q2VudGVyMUcwRQYDVQQDDD5DaGluYSBJbnRlcm5ldCBOZXR3b3JrIEluZm9ybWF0
aW9uIENlbnRlciBFViBDZXJ0aWZpY2F0ZXMgUm9vdDAeFw0xMDA4MzEwNzExMjVa
Fw0zMDA4MzEwNzExMjVaMIGKMQswCQYDVQQGEwJDTjEyMDAGA1UECgwpQ2hpbmEg
SW50ZXJuZXQgTmV0d29yayBJbmZvcm1hdGlvbiBDZW50ZXIxRzBFBgNVBAMMPkNo
aW5hIEludGVybmV0IE5ldHdvcmsgSW5mb3JtYXRpb24gQ2VudGVyIEVWIENlcnRp
ZmljYXRlcyBSb290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAm35z
7r07eKpkQ0H1UN+U8i6yjUqORlTSIRLIOTJCBumD1Z9S7eVnAztUwYyZmczpwA//
DdmEEbK40ctb3B75aDFk4Zv6dOtouSCV98YPjUesWgbdYavi7NifFy2cyjw1l1Vx
zUOFsUcW9SxTgHbP0wBkvUCZ3czY28Sf1hNfQYOL+Q2HklY0bBoQCxfVWhyXWIQ8
hBouXJE0bhlffxdpxWXvayHG1VA6v2G5BY3vbzQ6sm8UY78WO5upKv23KzhmBsUs
4qpnHkWnjQRmQvaPK++IIGmPMowUc9orhpFjIpryp9vOiYurXccUwVswah+xt54u
gQEC7c+WXmPbqOY4twIDAQABo2MwYTAfBgNVHSMEGDAWgBR8cks5x8DbYqVPm6oY
NJKiyoOCWTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4E
FgQUfHJLOcfA22KlT5uqGDSSosqDglkwDQYJKoZIhvcNAQEFBQADggEBACrDx0M3
j92tpLIM7twUbY8opJhJywyA6vPtI2Z1fcXTIWd50XPFtQO3WKwMVC/GVhMPMdoG
52U7HW8228gd+f2ABsqjPWYWqJ1MFn3AlUa1UeTiH9fqBk1jjZaM7+czV0I664zB
echNdn3e9rG3geCg+aF4RhcaVpjwTj2rHO3sOdwHSPdj/gauwqRcalsyiMXHM4Ws
ZkJHwlgkmeHlPuV1LI5D1l08eB6olYIpUNHRFrrvwb562bTYzB5MRuF3sTGrvSrI
zo9uoV1/A3U05K2JRVRevq4opbs/eHnrc7MKDf2+yfdWrPa37S+bISnHOLaVxATy
wy39FCqQmbkHzJ8=
-----END CERTIFICATE-----

# Issuer: CN=Swisscom Root CA 2 O=Swisscom OU=Digital Certificate Services
# Subject: CN=Swisscom Root CA 2 O=Swisscom OU=Digital Certificate Services
# Label: "Swisscom Root CA 2"
# Serial: 40698052477090394928831521023204026294
# MD5 Fingerprint: 5b:04:69:ec:a5:83:94:63:18:a7:86:d0:e4:f2:6e:19
# SHA1 Fingerprint: 77:47:4f:c6:30:e4:0f:4c:47:64:3f:84:ba:b8:c6:95:4a:8a:41:ec
# SHA256 Fingerprint: f0:9b:12:2c:71:14:f4:a0:9b:d4:ea:4f:4a:99:d5:58:b4:6e:4c:25:cd:81:14:0d:29:c0:56:13:91:4c:38:41
-----BEGIN CERTIFICATE-----
MIIF2TCCA8GgAwIBAgIQHp4o6Ejy5e/DfEoeWhhntjANBgkqhkiG9w0BAQsFADBk
MQswCQYDVQQGEwJjaDERMA8GA1UEChMIU3dpc3Njb20xJTAjBgNVBAsTHERpZ2l0
YWwgQ2VydGlmaWNhdGUgU2VydmljZXMxGzAZBgNVBAMTElN3aXNzY29tIFJvb3Qg
Q0EgMjAeFw0xMTA2MjQwODM4MTRaFw0zMTA2MjUwNzM4MTRaMGQxCzAJBgNVBAYT
AmNoMREwDwYDVQQKEwhTd2lzc2NvbTElMCMGA1UECxMcRGlnaXRhbCBDZXJ0aWZp
Y2F0ZSBTZXJ2aWNlczEbMBkGA1UEAxMSU3dpc3Njb20gUm9vdCBDQSAyMIICIjAN
BgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlUJOhJ1R5tMJ6HJaI2nbeHCOFvEr
jw0DzpPMLgAIe6szjPTpQOYXTKueuEcUMncy3SgM3hhLX3af+Dk7/E6J2HzFZ++r
0rk0X2s682Q2zsKwzxNoysjL67XiPS4h3+os1OD5cJZM/2pYmLcX5BtS5X4HAB1f
2uY+lQS3aYg5oUFgJWFLlTloYhyxCwWJwDaCFCE/rtuh/bxvHGCGtlOUSbkrRsVP
ACu/obvLP+DHVxxX6NZp+MEkUp2IVd3Chy50I9AU/SpHWrumnf2U5NGKpV+GY3aF
y6//SSj8gO1MedK75MDvAe5QQQg1I3ArqRa0jG6F6bYRzzHdUyYb3y1aSgJA/MTA
tukxGggo5WDDH8SQjhBiYEQN7Aq+VRhxLKX0srwVYv8c474d2h5Xszx+zYIdkeNL
6yxSNLCK/RJOlrDrcH+eOfdmQrGrrFLadkBXeyq96G4DsguAhYidDMfCd7Camlf0
uPoTXGiTOmekl9AbmbeGMktg2M7v0Ax/lZ9vh0+Hio5fCHyqW/xavqGRn1V9TrAL
acywlKinh/LTSlDcX3KwFnUey7QYYpqwpzmqm59m2I2mbJYV4+by+PGDYmy7Velh
k6M99bFXi08jsJvllGov34zflVEpYKELKeRcVVi3qPyZ7iVNTA6z00yPhOgpD/0Q
VAKFyPnlw4vP5w8CAwEAAaOBhjCBgzAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0hBBYw
FDASBgdghXQBUwIBBgdghXQBUwIBMBIGA1UdEwEB/wQIMAYBAf8CAQcwHQYDVR0O
BBYEFE0mICKJS9PVpAqhb97iEoHF8TwuMB8GA1UdIwQYMBaAFE0mICKJS9PVpAqh
b97iEoHF8TwuMA0GCSqGSIb3DQEBCwUAA4ICAQAyCrKkG8t9voJXiblqf/P0wS4R
fbgZPnm3qKhyN2abGu2sEzsOv2LwnN+ee6FTSA5BesogpxcbtnjsQJHzQq0Qw1zv
/2BZf82Fo4s9SBwlAjxnffUy6S8w5X2lejjQ82YqZh6NM4OKb3xuqFp1mrjX2lhI
REeoTPpMSQpKwhI3qEAMw8jh0FcNlzKVxzqfl9NX+Ave5XLzo9v/tdhZsnPdTSpx
srpJ9csc1fV5yJmz/MFMdOO0vSk3FQQoHt5FRnDsr7p4DooqzgB53MBfGWcsa0vv
aGgLQ+OswWIJ76bdZWGgr4RVSJFSHMYlkSrQwSIjYVmvRRGFHQEkNI/Ps/8XciAT
woCqISxxOQ7Qj1zB09GOInJGTB2Wrk9xseEFKZZZ9LuedT3PDTcNYtsmjGOpI99n
Bjx8Oto0QuFmtEYE3saWmA9LSHokMnWRn6z3aOkquVVlzl1h0ydw2Df+n7mvoC5W
t6NlUe07qxS/TFED6F+KBZvuim6c779o+sjaC+NCydAXFJy3SuCvkychVSa1ZC+N
8f+mQAWFBVzKBxlcCxMoTFh/wqXvRdpg065lYZ1Tg3TCrvJcwhbtkj6EPnNgiLx2
9CzP0H1907he0ZESEOnN3col49XtmS++dYFLJPlFRpTJKSFTnCZFqhMX5OfNeOI5
wSsSnqaeG8XmDtkx2Q==
-----END CERTIFICATE-----

# Issuer: CN=Swisscom Root EV CA 2 O=Swisscom OU=Digital Certificate Services
# Subject: CN=Swisscom Root EV CA 2 O=Swisscom OU=Digital Certificate Services
# Label: "Swisscom Root EV CA 2"
# Serial: 322973295377129385374608406479535262296
# MD5 Fingerprint: 7b:30:34:9f:dd:0a:4b:6b:35:ca:31:51:28:5d:ae:ec
# SHA1 Fingerprint: e7:a1:90:29:d3:d5:52:dc:0d:0f:c6:92:d3:ea:88:0d:15:2e:1a:6b
# SHA256 Fingerprint: d9:5f:ea:3c:a4:ee:dc:e7:4c:d7:6e:75:fc:6d:1f:f6:2c:44:1f:0f:a8:bc:77:f0:34:b1:9e:5d:b2:58:01:5d
-----BEGIN CERTIFICATE-----
MIIF4DCCA8igAwIBAgIRAPL6ZOJ0Y9ON/RAdBB92ylgwDQYJKoZIhvcNAQELBQAw
ZzELMAkGA1UEBhMCY2gxETAPBgNVBAoTCFN3aXNzY29tMSUwIwYDVQQLExxEaWdp
dGFsIENlcnRpZmljYXRlIFNlcnZpY2VzMR4wHAYDVQQDExVTd2lzc2NvbSBSb290
IEVWIENBIDIwHhcNMTEwNjI0MDk0NTA4WhcNMzEwNjI1MDg0NTA4WjBnMQswCQYD
VQQGEwJjaDERMA8GA1UEChMIU3dpc3Njb20xJTAjBgNVBAsTHERpZ2l0YWwgQ2Vy
dGlmaWNhdGUgU2VydmljZXMxHjAcBgNVBAMTFVN3aXNzY29tIFJvb3QgRVYgQ0Eg
MjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMT3HS9X6lds93BdY7Bx
UglgRCgzo3pOCvrY6myLURYaVa5UJsTMRQdBTxB5f3HSek4/OE6zAMaVylvNwSqD
1ycfMQ4jFrclyxy0uYAyXhqdk/HoPGAsp15XGVhRXrwsVgu42O+LgrQ8uMIkqBPH
oCE2G3pXKSinLr9xJZDzRINpUKTk4RtiGZQJo/PDvO/0vezbE53PnUgJUmfANykR
HvvSEaeFGHR55E+FFOtSN+KxRdjMDUN/rhPSays/p8LiqG12W0OfvrSdsyaGOx9/
5fLoZigWJdBLlzin5M8J0TbDC77aO0RYjb7xnglrPvMyxyuHxuxenPaHZa0zKcQv
idm5y8kDnftslFGXEBuGCxobP/YCfnvUxVFkKJ3106yDgYjTdLRZncHrYTNaRdHL
OdAGalNgHa/2+2m8atwBz735j9m9W8E6X47aD0upm50qKGsaCnw8qyIL5XctcfaC
NYGu+HuB5ur+rPQam3Rc6I8k9l2dRsQs0h4rIWqDJ2dVSqTjyDKXZpBy2uPUZC5f
46Fq9mDU5zXNysRojddxyNMkM3OxbPlq4SjbX8Y96L5V5jcb7STZDxmPX2MYWFCB
UWVv8p9+agTnNCRxunZLWB4ZvRVgRaoMEkABnRDixzgHcgplwLa7JSnaFp6LNYth
7eVxV4O1PHGf40+/fh6Bn0GXAgMBAAGjgYYwgYMwDgYDVR0PAQH/BAQDAgGGMB0G
A1UdIQQWMBQwEgYHYIV0AVMCAgYHYIV0AVMCAjASBgNVHRMBAf8ECDAGAQH/AgED
MB0GA1UdDgQWBBRF2aWBbj2ITY1x0kbBbkUe88SAnTAfBgNVHSMEGDAWgBRF2aWB
bj2ITY1x0kbBbkUe88SAnTANBgkqhkiG9w0BAQsFAAOCAgEAlDpzBp9SSzBc1P6x
XCX5145v9Ydkn+0UjrgEjihLj6p7jjm02Vj2e6E1CqGdivdj5eu9OYLU43otb98T
PLr+flaYC/NUn81ETm484T4VvwYmneTwkLbUwp4wLh/vx3rEUMfqe9pQy3omywC0
Wqu1kx+AiYQElY2NfwmTv9SoqORjbdlk5LgpWgi/UOGED1V7XwgiG/W9mR4U9s70
WBCCswo9GcG/W6uqmdjyMb3lOGbcWAXH7WMaLgqXfIeTK7KK4/HsGOV1timH59yL
Gn602MnTihdsfSlEvoqq9X46Lmgxk7lq2prg2+kupYTNHAq4Sgj5nPFhJpiTt3tm
7JFe3VE/23MPrQRYCd0EApUKPtN236YQHoA96M2kZNEzx5LH4k5E4wnJTsJdhw4S
nr8PyQUQ3nqjsTzyP6WqJ3mtMX0f/fwZacXduT98zca0wjAefm6S139hdlqP65VN
vBFuIXxZN5nQBrz5Bm0yFqXZaajh3DyAHmBR3NdUIR7KYndP+tiPsys6DXhyyWhB
WkdKwqPrGtcKqzwyVcgKEZzfdNbwQBUdyLmPtTbFr/giuMod89a2GQ+fYWVq6nTI
fI/DT11lgh/ZDYnadXL77/FHZxOzyNEZiCcmmpl5fx7kLD977vHeTYuWl8PVP3wb
I+2ksx0WckNLIOFZfsLorSa/ovc=
-----END CERTIFICATE-----

# Issuer: CN=CA Disig Root R1 O=Disig a.s.
# Subject: CN=CA Disig Root R1 O=Disig a.s.
# Label: "CA Disig Root R1"
# Serial: 14052245610670616104
# MD5 Fingerprint: be:ec:11:93:9a:f5:69:21:bc:d7:c1:c0:67:89:cc:2a
# SHA1 Fingerprint: 8e:1c:74:f8:a6:20:b9:e5:8a:f4:61:fa:ec:2b:47:56:51:1a:52:c6
# SHA256 Fingerprint: f9:6f:23:f4:c3:e7:9c:07:7a:46:98:8d:5a:f5:90:06:76:a0:f0:39:cb:64:5d:d1:75:49:b2:16:c8:24:40:ce
-----BEGIN CERTIFICATE-----
MIIFaTCCA1GgAwIBAgIJAMMDmu5QkG4oMA0GCSqGSIb3DQEBBQUAMFIxCzAJBgNV
BAYTAlNLMRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMu
MRkwFwYDVQQDExBDQSBEaXNpZyBSb290IFIxMB4XDTEyMDcxOTA5MDY1NloXDTQy
MDcxOTA5MDY1NlowUjELMAkGA1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmEx
EzARBgNVBAoTCkRpc2lnIGEucy4xGTAXBgNVBAMTEENBIERpc2lnIFJvb3QgUjEw
ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCqw3j33Jijp1pedxiy3QRk
D2P9m5YJgNXoqqXinCaUOuiZc4yd39ffg/N4T0Dhf9Kn0uXKE5Pn7cZ3Xza1lK/o
OI7bm+V8u8yN63Vz4STN5qctGS7Y1oprFOsIYgrY3LMATcMjfF9DCCMyEtztDK3A
fQ+lekLZWnDZv6fXARz2m6uOt0qGeKAeVjGu74IKgEH3G8muqzIm1Cxr7X1r5OJe
IgpFy4QxTaz+29FHuvlglzmxZcfe+5nkCiKxLU3lSCZpq+Kq8/v8kiky6bM+TR8n
oc2OuRf7JT7JbvN32g0S9l3HuzYQ1VTW8+DiR0jm3hTaYVKvJrT1cU/J19IG32PK
/yHoWQbgCNWEFVP3Q+V8xaCJmGtzxmjOZd69fwX3se72V6FglcXM6pM6vpmumwKj
rckWtc7dXpl4fho5frLABaTAgqWjR56M6ly2vGfb5ipN0gTco65F97yLnByn1tUD
3AjLLhbKXEAz6GfDLuemROoRRRw1ZS0eRWEkG4IupZ0zXWX4Qfkuy5Q/H6MMMSRE
7cderVC6xkGbrPAXZcD4XW9boAo0PO7X6oifmPmvTiT6l7Jkdtqr9O3jw2Dv1fkC
yC2fg69naQanMVXVz0tv/wQFx1isXxYb5dKj6zHbHzMVTdDypVP1y+E9Tmgt2BLd
qvLmTZtJ5cUoobqwWsagtQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud
DwEB/wQEAwIBBjAdBgNVHQ4EFgQUiQq0OJMa5qvum5EY+fU8PjXQ04IwDQYJKoZI
hvcNAQEFBQADggIBADKL9p1Kyb4U5YysOMo6CdQbzoaz3evUuii+Eq5FLAR0rBNR
xVgYZk2C2tXck8An4b58n1KeElb21Zyp9HWc+jcSjxyT7Ff+Bw+r1RL3D65hXlaA
SfX8MPWbTx9BLxyE04nH4toCdu0Jz2zBuByDHBb6lM19oMgY0sidbvW9adRtPTXo
HqJPYNcHKfyyo6SdbhWSVhlMCrDpfNIZTUJG7L399ldb3Zh+pE3McgODWF3vkzpB
emOqfDqo9ayk0d2iLbYq/J8BjuIQscTK5GfbVSUZP/3oNn6z4eGBrxEWi1CXYBmC
AMBrTXO40RMHPuq2MU/wQppt4hF05ZSsjYSVPCGvxdpHyN85YmLLW1AL14FABZyb
7bq2ix4Eb5YgOe2kfSnbSM6C3NQCjR0EMVrHS/BsYVLXtFHCgWzN4funodKSds+x
DzdYpPJScWc/DIh4gInByLUfkmO+p3qKViwaqKactV2zY9ATIKHrkWzQjX2v3wvk
F7mGnjixlAxYjOBVqjtjbZqJYLhkKpLGN/R+Q0O3c+gB53+XD9fyexn9GtePyfqF
a3qdnom2piiZk4hA9z7NUaPK6u95RyG1/jLix8NRb76AdPCkwzryT+lf3xkK8jsT
Q6wxpLPn6/wY1gGp8yqPNg7rtLG8t0zJa7+h89n07eLw4+1knj0vllJPgFOL
-----END CERTIFICATE-----

# Issuer: CN=CA Disig Root R2 O=Disig a.s.
# Subject: CN=CA Disig Root R2 O=Disig a.s.
# Label: "CA Disig Root R2"
# Serial: 10572350602393338211
# MD5 Fingerprint: 26:01:fb:d8:27:a7:17:9a:45:54:38:1a:43:01:3b:03
# SHA1 Fingerprint: b5:61:eb:ea:a4:de:e4:25:4b:69:1a:98:a5:57:47:c2:34:c7:d9:71
# SHA256 Fingerprint: e2:3d:4a:03:6d:7b:70:e9:f5:95:b1:42:20:79:d2:b9:1e:df:bb:1f:b6:51:a0:63:3e:aa:8a:9d:c5:f8:07:03
-----BEGIN CERTIFICATE-----
MIIFaTCCA1GgAwIBAgIJAJK4iNuwisFjMA0GCSqGSIb3DQEBCwUAMFIxCzAJBgNV
BAYTAlNLMRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMu
MRkwFwYDVQQDExBDQSBEaXNpZyBSb290IFIyMB4XDTEyMDcxOTA5MTUzMFoXDTQy
MDcxOTA5MTUzMFowUjELMAkGA1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmEx
EzARBgNVBAoTCkRpc2lnIGEucy4xGTAXBgNVBAMTEENBIERpc2lnIFJvb3QgUjIw
ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCio8QACdaFXS1tFPbCw3Oe
NcJxVX6B+6tGUODBfEl45qt5WDza/3wcn9iXAng+a0EE6UG9vgMsRfYvZNSrXaNH
PWSb6WiaxswbP7q+sos0Ai6YVRn8jG+qX9pMzk0DIaPY0jSTVpbLTAwAFjxfGs3I
x2ymrdMxp7zo5eFm1tL7A7RBZckQrg4FY8aAamkw/dLukO8NJ9+flXP04SXabBbe
QTg06ov80egEFGEtQX6sx3dOy1FU+16SGBsEWmjGycT6txOgmLcRK7fWV8x8nhfR
yyX+hk4kLlYMeE2eARKmK6cBZW58Yh2EhN/qwGu1pSqVg8NTEQxzHQuyRpDRQjrO
QG6Vrf/GlK1ul4SOfW+eioANSW1z4nuSHsPzwfPrLgVv2RvPN3YEyLRa5Beny912
H9AZdugsBbPWnDTYltxhh5EF5EQIM8HauQhl1K6yNg3ruji6DOWbnuuNZt2Zz9aJ
QfYEkoopKW1rOhzndX0CcQ7zwOe9yxndnWCywmZgtrEE7snmhrmaZkCo5xHtgUUD
i/ZnWejBBhG93c+AAk9lQHhcR1DIm+YfgXvkRKhbhZri3lrVx/k6RGZL5DJUfORs
nLMOPReisjQS1n6yqEm70XooQL6iFh/f5DcfEXP7kAplQ6INfPgGAVUzfbANuPT1
rqVCV3w2EYx7XsQDnYx5nQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud
DwEB/wQEAwIBBjAdBgNVHQ4EFgQUtZn4r7CU9eMg1gqtzk5WpC5uQu0wDQYJKoZI
hvcNAQELBQADggIBACYGXnDnZTPIgm7ZnBc6G3pmsgH2eDtpXi/q/075KMOYKmFM
tCQSin1tERT3nLXK5ryeJ45MGcipvXrA1zYObYVybqjGom32+nNjf7xueQgcnYqf
GopTpti72TVVsRHFqQOzVju5hJMiXn7B9hJSi+osZ7z+Nkz1uM/Rs0mSO9MpDpkb
lvdhuDvEK7Z4bLQjb/D907JedR+Zlais9trhxTF7+9FGs9K8Z7RiVLoJ92Owk6Ka
+elSLotgEqv89WBW7xBci8QaQtyDW2QOy7W81k/BfDxujRNt+3vrMNDcTa/F1bal
TFtxyegxvug4BkihGuLq0t4SOVga/4AOgnXmt8kHbA7v/zjxmHHEt38OFdAlab0i
nSvtBfZGR6ztwPDUO+Ls7pZbkBNOHlY667DvlruWIxG68kOGdGSVyCh13x01utI3
gzhTODY7z2zp+WsO0PsE6E9312UBeIYMej4hYvF/Y3EMyZ9E26gnonW+boE+18Dr
G5gPcFw0sorMwIUY6256s/daoQe/qUKS82Ail+QUoQebTnbAjn39pCXHR+3/H3Os
zMOl6W8KjptlwlCFtaOgUxLMVYdh84GuEEZhvUQhuMI9dM9+JDX6HAcOmz0iyu8x
L4ysEr3vQCj8KWefshNPZiTEUxnpHikV7+ZtsH8tZ/3zbBt1RqPlShfppNcL
-----END CERTIFICATE-----
                                                                                                                                                                                                                                                                   usr/lib/python2.7/dist-packages/websocket_client-0.18.0.egg-info/                                   0040755 0000000 0000000 00000000000 13077704307 022666  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python2.7/dist-packages/websocket_client-0.18.0.egg-info/PKG-INFO                           0100644 0000000 0000000 00000024132 12431314654 023755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Metadata-Version: 1.1
Name: websocket-client
Version: 0.18.0
Summary: WebSocket client for python. hybi13 is supported.
Home-page: https://github.com/liris/websocket-client
Author: liris
Author-email: liris.pp@gmail.com
License: LGPL
Description: =================
        websocket-client
        =================
        
        websocket-client module  is WebSocket client for python. This provide the low level APIs for WebSocket. All APIs are the synchronous functions.
        
        websocket-client supports only hybi-13.
        
        CAUTION
        ============
        
        We have a big change on version 0.14.0.
        So, please test carefully.
        
        
        License
        ============
        
         - LGPL
        
        Installation
        =============
        
        This module is tested on Python 2.7 and Python 3.x.
        
        Type "python setup.py install" or "pip install websocket-client" to install.
        
        .. CAUTION::
        
          from v0.16.0, we can install by "pip install websocket-client" for python 3.
        
        This module depend on
        
         - six
         - backports.ssl_match_hostname for Python 2.x
        
        How about Python 3
        ===========================
        
        Now, we support python 3 on  single source code from version 0.14.0. Thanks, @battlemidget and @ralphbean.
        
        HTTP Proxy
        =============
        
        Support websocket access via http proxy.
        The proxy server must allow "CONNECT" method to websocket port.
        Default squid setting is "ALLOWED TO CONNECT ONLY HTTPS PORT".
        
        Current implementation of websocket-client is using "CONNECT" method via proxy.
        
        
        example::
        -------------
        
            import websocket
            ws = websocket.WebSocket(support_socket_io="0.9")
              :
        
        
        
        Example
        =============
        
        Low Level API example::
        
            from websocket import create_connection
            ws = create_connection("ws://echo.websocket.org/")
            print "Sending 'Hello, World'..."
            ws.send("Hello, World")
            print "Sent"
            print "Reeiving..."
            result =  ws.recv()
            print "Received '%s'" % result
            ws.close()
        
        If you want to customize socket options, set sockopt.
        
        sockopt example:
        
            from websocket import create_connection
            ws = create_connection("ws://echo.websocket.org/".
                                    sockopt=((socket.IPPROTO_TCP, socket.TCP_NODELAY),) )
        
        
        JavaScript websocket-like API example::
        
            import websocket
            import thread
            import time
        
            def on_message(ws, message):
                print message
        
            def on_error(ws, error):
                print error
        
            def on_close(ws):
                print "### closed ###"
        
            def on_open(ws):
                def run(*args):
                    for i in range(3):
                        time.sleep(1)
                        ws.send("Hello %d" % i)
                    time.sleep(1)
                    ws.close()
                    print "thread terminating..."
                thread.start_new_thread(run, ())
        
        
            if __name__ == "__main__":
                websocket.enableTrace(True)
                ws = websocket.WebSocketApp("ws://echo.websocket.org/",
                                          on_message = on_message,
                                          on_error = on_error,
                                          on_close = on_close)
                ws.on_open = on_open
                ws.run_forever()
        
        
        FAQ
        ============
        
        How to disable ssl cert verification?
        ----------------------------------------
        
        Please set sslopt to {"cert_reqs": ssl.CERT_NONE}.
        
        WebScoketApp sample::
        
            ws = websocket.WebSocketApp("https://echo.websocket.org")
            ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})
        
        create_connection sample::
        
            ws = websocket.create_connection("https://echo.websocket.org",
              sslopt={"cert_reqs": ssl.CERT_NONE})
        
        WebSocket sample::
        
            ws = websocket.WebSocket(sslopt={"cert_reqs": ssl.CERT_NONE})
            ws.connect("https://echo.websocket.org")
        
        
        How to disable hostname verification.
        ----------------------------------------
        
        Please set sslopt to {"check_hostname": False}.
        (since v0.18.0)
        
        WebScoketApp sample::
        
            ws = websocket.WebSocketApp("https://echo.websocket.org")
            ws.run_forever(sslopt={"check_hostname": False})
        
        create_connection sample::
        
            ws = websocket.create_connection("https://echo.websocket.org",
              sslopt={"check_hostname": False})
        
        WebSocket sample::
        
            ws = websocket.WebSocket(sslopt={"check_hostname": False})
            ws.connect("https://echo.websocket.org")
        
        
        
        wsdump.py
        ============
        
        wsdump.py is simple WebSocket test(debug) tool.
        
        sample for echo.websocket.org::
        
          $ wsdump.py ws://echo.websocket.org/
          Press Ctrl+C to quit
          > Hello, WebSocket
          < Hello, WebSocket
          > How are you?
          < How are you?
        
        Usage
        ---------
        
        usage::
          wsdump.py [-h] [-v [VERBOSE]] ws_url
        
        WebSocket Simple Dump Tool
        
        positional arguments:
          ws_url                websocket url. ex. ws://echo.websocket.org/
        
        optional arguments:
          -h, --help                           show this help message and exit
        WebSocketApp
          -v VERBOSE, --verbose VERBOSE    set verbose mode. If set to 1, show opcode. If set to 2, enable to trace websocket module
        
        example::
        
          $ wsdump.py ws://echo.websocket.org/
          $ wsdump.py ws://echo.websocket.org/ -v
          $ wsdump.py ws://echo.websocket.org/ -vv
        
        ChangeLog
        ============
        
        - v0.18.0
        
          -  allow override of match_hostname usage on ssl (#105)
        
        - v0.17.0
        
          - can't set timeout on a standing websocket connection (#102)
          - fixed local variable 'error' referenced before assignment (#102, #98)
        
        - v0.16.0
        
          - lock some method for multithread. (#92)
          - disable cert verification. (#89)
        
        - v0.15.0
        
          - fixed exception when send a large message (#84)
        
        - v0.14.1
        
          - fixed to work on Python2.6 (#83)
        
        - v0.14.0
        
          - Support python 3(#73)
          - Support IPv6(#77)
          - Support explicit web proxy(#57)
          - specify cookie in connect method option(#82)
        
        - v0.13.0
        
          - MemoryError when receiving large amount of data (~60 MB) at once(ISSUE#59)
          - Controlling fragmentation(ISSUE#55)
          - server certificate validation(ISSUE#56)
          - PyPI tarball is missing test_websocket.py(ISSUE#65)
          - Payload length encoding bug(ISSUE#58)
          - disable Nagle algorithm by default(ISSUE#41)
          - Better event loop in WebSocketApp(ISSUE#63)
          - Skip tests that require Internet access by default(ISSUE#66)
        
        - v0.12.0
        
          - support keep alive for WebSocketApp(ISSUE#34)
          - fix some SSL bugs(ISSUE#35, #36)
          - fix "Timing out leaves websocket library in bad state"(ISSUE#37)
          - fix "WebSocketApp.run_with_no_err() silently eats all exceptions"(ISSUE#38)
          - WebSocketTimeoutException will be raised for ws/wss timeout(ISSUE#40)
          - improve wsdump message(ISSUE#42)
          - support fragmentation message(ISSUE#43)
          - fix some bugs
        
        - v0.11.0
        
          - Only log non-normal close status(ISSUE#31)
          - Fix default Origin isn't URI(ISSUE#32)
          - fileno support(ISSUE#33)
        
        - v0.10.0
        
          - allow to set HTTP Header to WebSocketApp(ISSUE#27)
          - fix typo in pydoc(ISSUE#28)
          - Passing a socketopt flag to the websocket constructor(ISSUE#29)
          - websocket.send fails with long data(ISSUE#30)
        
        
        - v0.9.0
        
          - allow to set opcode in WebSocketApp.send(ISSUE#25)
          - allow to modify Origin(ISSUE#26)
        
        - v0.8.0
        
          - many bug fix
          - some performance improvement
        
        - v0.7.0
        
          - fixed problem to read long data.(ISSUE#12)
          - fix buffer size boundary violation
        
        - v0.6.0
        
          - Patches: UUID4, self.keep_running, mask_key (ISSUE#11)
          - add wsdump.py tool
        
        - v0.5.2
        
          - fix Echo App Demo Throw Error: 'NoneType' object has no attribute 'opcode  (ISSUE#10)
        
        - v0.5.1
        
          - delete invalid print statement.
        
        - v0.5.0
        
          - support hybi-13 protocol.
        
        - v0.4.1
        
          - fix incorrect custom header order(ISSUE#1)
        
        
Keywords: websockets
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 3 
Classifier: Operating System :: MacOS :: MacOS X
Classifier: Operating System :: POSIX
Classifier: Operating System :: Microsoft :: Windows
Classifier: Topic :: Internet
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Intended Audience :: Developers
                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python2.7/dist-packages/websocket_client-0.18.0.egg-info/dependency_links.txt               0100644 0000000 0000000 00000000001 12431314654 026724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python2.7/dist-packages/websocket_client-0.18.0.egg-info/requires.txt                       0100644 0000000 0000000 00000000041 12431314654 025251  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        six
backports.ssl_match_hostname
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python2.7/dist-packages/websocket_client-0.18.0.egg-info/top_level.txt                      0100644 0000000 0000000 00000000012 12431314654 025401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        websocket
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python2.7/dist-packages/yum/                                                                0040755 0000000 0000000 00000000000 13077704344 015741  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/Errors.py                                                       0100644 0000000 0000000 00000007223 12451005146 017555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2004 Duke University

"""
Exceptions and Errors thrown by yum.
"""

from i18n import to_unicode

class YumBaseError(Exception):
    """
    Base Yum Error. All other Errors thrown by yum should inherit from
    this.
    """
    def __init__(self, value=None):
        Exception.__init__(self)
        self.value = value
    def __str__(self):
        return "%s" %(self.value,)

    def __unicode__(self):
        return '%s' % to_unicode(self.value)

class YumGPGCheckError(YumBaseError):
    pass

class YumDownloadError(YumBaseError):
    pass

class YumTestTransactionError(YumBaseError):
    pass

class YumRPMCheckError(YumBaseError):
    pass
        
class YumRPMTransError(YumBaseError):
    """ This class means rpm's .ts.run() returned known errors. We are compat.
        with YumBaseError in that we print nicely, and compat. with traditional
        usage of this error from runTransaction(). """
    def __init__(self, msg, errors):
        self.msg    = msg
        self.errors = errors
        # old YumBaseError raises from runTransaction used to raise just this
        self.value  = self.errors

    def __str__(self):
        return "%s" %(self.msg,)

    def __unicode__(self):
        return '%s' % to_unicode(self.msg)


class LockError(YumBaseError):
    def __init__(self, errno, msg, pid=0):
        YumBaseError.__init__(self, msg)
        self.errno = errno
        self.msg = msg
        self.pid = pid
        
class DepError(YumBaseError):
    pass
    
class RepoError(YumBaseError):
    pass

class DuplicateRepoError(RepoError):
    pass

class NoMoreMirrorsRepoError(RepoError):
    pass
    
class ConfigError(YumBaseError):
    pass
    
class MiscError(YumBaseError):
    pass

class GroupsError(YumBaseError):
    pass

class InstallError(YumBaseError):
    pass

class UpdateError(YumBaseError):
    pass
    
class RemoveError(YumBaseError):
    pass

class ReinstallError(YumBaseError):
    pass

class ReinstallRemoveError(ReinstallError):
    pass

class ReinstallInstallError(ReinstallError):
    def __init__(self, value=None, failed_pkgs=[]):
        ReinstallError.__init__(self, value)
        self.failed_pkgs = failed_pkgs

class DowngradeError(YumBaseError):
    pass

class RepoMDError(YumBaseError):
    pass

class PackageSackError(YumBaseError):
    pass

class RpmDBError(YumBaseError):
    pass

class CompsException(YumBaseError):
    pass

class MediaError(YumBaseError):
    pass
    
class PkgTagsError(YumBaseError):
    pass
    
class YumDeprecationWarning(DeprecationWarning):
    """
    Used to mark a method as deprecated.
    """
    def __init__(self, value=None):
        DeprecationWarning.__init__(self, value)

class YumFutureDeprecationWarning(YumDeprecationWarning):
    """
    Used to mark a method as deprecated. Unlike YumDeprecationWarning,
    YumFutureDeprecationWarnings will not be shown on the console.
    """
    def __init__(self, value=None):
        YumDeprecationWarning.__init__(self, value)
                                                                                                                                                                                                                                                                                                                                                                             usr/lib/python2.7/dist-packages/yum/Errors.pyc                                                      0100644 0000000 0000000 00000017502 13077704344 017734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  Z  d d l m Z d e f d     YZ d e f d     YZ d e f d     YZ d	 e f d
     YZ d e f d     YZ d e f d     YZ	 d e f d     YZ
 d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d e f d      YZ d! e f d"     YZ d# e f d$     YZ d% e f d&     YZ d' e f d(     YZ d) e f d*     YZ d+ e f d,     YZ d- e f d.     YZ d/ e f d0     YZ d1 e f d2     YZ d3 e f d4     YZ d5 e f d6     YZ d7 e f d8     YZ d9 e f d:     YZ  d; e  f d<     YZ! d= S(>   s&   
Exceptions and Errors thrown by yum.
i(   t
   to_unicodet   YumBaseErrorc           B   s,   e  Z d  Z d d  Z d   Z d   Z RS(   sV   
    Base Yum Error. All other Errors thrown by yum should inherit from
    this.
    c         C   s   t  j |   | |  _ d  S(   N(   t	   Exceptiont   __init__t   value(   t   selfR   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR      s    c         C   s   d |  j  f S(   Ns   %s(   R   (   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyt   __str__   s    c         C   s   d t  |  j  S(   Ns   %s(   R    R   (   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyt   __unicode__"   s    N(   t   __name__t
   __module__t   __doc__t   NoneR   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR      s   	t   YumGPGCheckErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   %   s   t   YumDownloadErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   (   s   t   YumTestTransactionErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   +   s   t   YumRPMCheckErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   .   s   t   YumRPMTransErrorc           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   s    This class means rpm's .ts.run() returned known errors. We are compat.
        with YumBaseError in that we print nicely, and compat. with traditional
        usage of this error from runTransaction(). c         C   s"   | |  _  | |  _ |  j |  _ d  S(   N(   t   msgt   errorsR   (   R   R   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   5   s    		c         C   s   d |  j  f S(   Ns   %s(   R   (   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   ;   s    c         C   s   d t  |  j  S(   Ns   %s(   R    R   (   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   >   s    (   R   R	   R
   R   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   1   s   		t	   LockErrorc           B   s   e  Z d  d  Z RS(   i    c         C   s/   t  j |  |  | |  _ | |  _ | |  _ d  S(   N(   R   R   t   errnoR   t   pid(   R   R   R   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   C   s    		(   R   R	   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   B   s   t   DepErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   I   s   t	   RepoErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   L   s   t   DuplicateRepoErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   O   s   t   NoMoreMirrorsRepoErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   R   s   t   ConfigErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   U   s   t	   MiscErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   X   s   t   GroupsErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   [   s   t   InstallErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   ^   s   t   UpdateErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   a   s   t   RemoveErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   d   s   t   ReinstallErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR    g   s   t   ReinstallRemoveErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR!   j   s   t   ReinstallInstallErrorc           B   s   e  Z d g  d   Z RS(   c         C   s   t  j |  |  | |  _ d  S(   N(   R    R   t   failed_pkgs(   R   R   R#   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR   n   s    N(   R   R	   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR"   m   s   t   DowngradeErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR$   r   s   t   RepoMDErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR%   u   s   t   PackageSackErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR&   x   s   t
   RpmDBErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR'   {   s   t   CompsExceptionc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR(   ~   s   t
   MediaErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR)      s   t   PkgTagsErrorc           B   s   e  Z RS(    (   R   R	   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR*      s   t   YumDeprecationWarningc           B   s   e  Z d  Z d d  Z RS(   s.   
    Used to mark a method as deprecated.
    c         C   s   t  j |  |  d  S(   N(   t   DeprecationWarningR   (   R   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR      s    N(   R   R	   R
   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR+      s   t   YumFutureDeprecationWarningc           B   s   e  Z d  Z d d  Z RS(   s   
    Used to mark a method as deprecated. Unlike YumDeprecationWarning,
    YumFutureDeprecationWarnings will not be shown on the console.
    c         C   s   t  j |  |  d  S(   N(   R+   R   (   R   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR      s    N(   R   R	   R
   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyR-      s   N("   R
   t   i18nR    R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R   R    R!   R"   R$   R%   R&   R'   R(   R)   R*   R,   R+   R-   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/Errors.pyt   <module>   s<                                                                                                                                                                                                 usr/lib/python2.7/dist-packages/yum/__init__.py                                                     0100644 0000000 0000000 00000716031 12451005146 020044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University

"""
The Yum RPM software updater.
"""

import os
import os.path
import rpm

def _rpm_ver_atleast(vertup):
    """ Check if rpm is at least the current vertup. Can return False/True/None
        as rpm hasn't had version info for a long time. """
    if not hasattr(rpm, '__version_info__'):
        return None
    try:
        # 4.8.x rpm used strings for the tuple members, so convert.
        vi = tuple([ int(num) for num in rpm.__version_info__])
        return vi >= vertup
    except:
        return None # Something went wrong...

import re
import types
import errno
import time
import glob
import fnmatch
import logging
import logging.config
import operator
import tempfile

import yum.i18n
_ = yum.i18n._
P_ = yum.i18n.P_

import config
from config import ParsingError, ConfigParser
import Errors
import rpmsack
import rpmUtils.updates
from rpmUtils.arch import archDifference, canCoinstall, ArchStorage, isMultiLibArch
from rpmUtils.miscutils import compareEVR
import rpmUtils.transaction
import comps
import pkgtag_db
from repos import RepoStorage
import misc
from parser import ConfigPreProcessor, varReplace
import transactioninfo
import urlgrabber
from urlgrabber.grabber import URLGrabber, URLGrabError
from urlgrabber.progress import format_number
from packageSack import packagesNewestByName, packagesNewestByNameArch, ListPackageSack
import depsolve
import plugins
import logginglevels
import yumRepo
import callbacks
import yum.history

import warnings
warnings.simplefilter("ignore", Errors.YumFutureDeprecationWarning)

from packages import parsePackages, comparePoEVR
from packages import YumAvailablePackage, YumLocalPackage, YumInstalledPackage
from packages import YumUrlPackage, YumNotFoundPackage
from constants import *
from yum.rpmtrans import RPMTransaction,SimpleCliCallBack
from yum.i18n import to_unicode, to_str

import string
import StringIO

from weakref import proxy as weakref

from urlgrabber.grabber import default_grabber

__version__ = '3.4.3'
__version_info__ = tuple([ int(num) for num in __version__.split('.')])

#  Setup a default_grabber UA here that says we are yum, done using the global
# so that other API users can easily add to it if they want.
#  Don't do it at init time, or we'll get multiple additions if you create
# multiple YumBase() objects.
default_grabber.opts.user_agent += " yum/" + __version__


class _YumPreBaseConf:
    """This is the configuration interface for the YumBase configuration.
       So if you want to change if plugins are on/off, or debuglevel/etc.
       you tweak it here, and when yb.conf does it's thing ... it happens. """

    def __init__(self):
        self.fn = '/etc/yum/yum.conf'
        self.root = '/'
        self.init_plugins = True
        self.plugin_types = (plugins.TYPE_CORE,)
        self.optparser = None
        self.debuglevel = None
        self.errorlevel = None
        self.disabled_plugins = None
        self.enabled_plugins = None
        self.syslog_ident = None
        self.syslog_facility = None
        self.syslog_device = None
        self.arch = None
        self.releasever = None
        self.uuid = None


class _YumPreRepoConf:
    """This is the configuration interface for the repos configuration.
       So if you want to change callbacks etc. you tweak it here, and when
       yb.repos does it's thing ... it happens. """

    def __init__(self):
        self.progressbar = None
        self.callback = None
        self.failure_callback = None
        self.interrupt_callback = None
        self.confirm_func = None
        self.gpg_import_func = None
        self.gpgca_import_func = None
        self.cachedir = None
        self.cache = None


class _YumCostExclude:
    """ This excludes packages that are in repos. of lower cost than the passed
        repo. """

    def __init__(self, repo, repos):
        self.repo   = weakref(repo)
        self._repos = weakref(repos)

    def __contains__(self, pkgtup):
        # (n, a, e, v, r) = pkgtup
        for repo in self._repos.listEnabled():
            if repo.cost >= self.repo.cost:
                break
            #  searchNevra is a bit slower, although more generic for repos. 
            # that don't use sqlitesack as the backend ... although they are
            # probably screwed anyway.
            #
            # if repo.sack.searchNevra(n, e, v, r, a):
            if pkgtup in repo.sack._pkgtup2pkgs:
                return True
        return False

class YumBase(depsolve.Depsolve):
    """This is a primary structure and base class. It houses the objects and
       methods needed to perform most things in yum. It is almost an abstract
       class in that you will need to add your own class above it for most
       real use."""
    
    def __init__(self):
        depsolve.Depsolve.__init__(self)
        self._conf = None
        self._tsInfo = None
        self._rpmdb = None
        self._up = None
        self._comps = None
        self._history = None
        self._pkgSack = None
        self._lockfile = None
        self._tags = None
        self._ts_save_file = None
        self.skipped_packages = []   # packages skip by the skip-broken code
        self._not_found_a = {}
        self._not_found_i = {}
        self.logger = logging.getLogger("yum.YumBase")
        self.verbose_logger = logging.getLogger("yum.verbose.YumBase")
        self._override_sigchecks = False
        self._repos = RepoStorage(self)
        self.repo_setopts = {} # since we have to use repo_setopts in base and 
                               # not in cli - set it up as empty so no one
                               # trips over it later

        # Start with plugins disabled
        self.disablePlugins()

        self.localPackages = [] # for local package handling

        self.mediagrabber = None
        self.arch = ArchStorage()
        self.preconf = _YumPreBaseConf()
        self.prerepoconf = _YumPreRepoConf()

        self.run_with_package_names = set()
        self._cleanup = []

    def __del__(self):
        self.close()
        self.closeRpmDB()
        self.doUnlock()
        # call cleanup callbacks
        for cb in self._cleanup: cb()

    def close(self):
        # We don't want to create the object, so we test if it's been created
        if self._history is not None:
            self.history.close()

        if self._repos:
            self._repos.close()

    def _transactionDataFactory(self):
        """Factory method returning TransactionData object"""
        return transactioninfo.TransactionData()

    def doGenericSetup(self, cache=0):
        """do a default setup for all the normal/necessary yum components,
           really just a shorthand for testing"""

        self.preconf.init_plugins = False
        self.conf.cache = cache

    def doConfigSetup(self, fn='/etc/yum/yum.conf', root='/', init_plugins=True,
            plugin_types=(plugins.TYPE_CORE,), optparser=None, debuglevel=None,
            errorlevel=None):
        warnings.warn(_('doConfigSetup() will go away in a future version of Yum.\n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)

        if hasattr(self, 'preconf'):
            self.preconf.fn = fn
            self.preconf.root = root
            self.preconf.init_plugins = init_plugins
            self.preconf.plugin_types = plugin_types
            self.preconf.optparser = optparser
            self.preconf.debuglevel = debuglevel
            self.preconf.errorlevel = errorlevel

        return self.conf
        
    def _getConfig(self, **kwargs):
        '''
        Parse and load Yum's configuration files and call hooks initialise
        plugins and logging. Uses self.preconf for pre-configuration,
        configuration. '''

        # ' xemacs syntax hack

        if kwargs:
            warnings.warn('Use .preconf instead of passing args to _getConfig')

        if self._conf:
            return self._conf
        conf_st = time.time()            

        if kwargs:
            for arg in ('fn', 'root', 'init_plugins', 'plugin_types',
                        'optparser', 'debuglevel', 'errorlevel',
                        'disabled_plugins', 'enabled_plugins'):
                if arg in kwargs:
                    setattr(self.preconf, arg, kwargs[arg])

        fn = self.preconf.fn
        root = self.preconf.root
        init_plugins = self.preconf.init_plugins
        plugin_types = self.preconf.plugin_types
        optparser = self.preconf.optparser
        debuglevel = self.preconf.debuglevel
        errorlevel = self.preconf.errorlevel
        disabled_plugins = self.preconf.disabled_plugins
        enabled_plugins = self.preconf.enabled_plugins
        syslog_ident    = self.preconf.syslog_ident
        syslog_facility = self.preconf.syslog_facility
        syslog_device   = self.preconf.syslog_device
        releasever = self.preconf.releasever
        arch = self.preconf.arch
        uuid = self.preconf.uuid
        
        if arch: # if preconf is setting an arch we need to pass that up
            self.arch.setup_arch(arch)
        else:
            arch = self.arch.canonarch

        # TODO: Remove this block when we no longer support configs outside
        # of /etc/yum/
        if fn == '/etc/yum/yum.conf' and not os.path.exists(fn):
            # Try the old default
            fn = '/etc/yum.conf'

        startupconf = config.readStartupConfig(fn, root)
        startupconf.arch = arch
        startupconf.basearch = self.arch.basearch
        if uuid:
            startupconf.uuid = uuid
        
        if startupconf.gaftonmode:
            global _
            _ = yum.i18n.dummy_wrapper

        if debuglevel != None:
            startupconf.debuglevel = debuglevel
        if errorlevel != None:
            startupconf.errorlevel = errorlevel
        if syslog_ident != None:
            startupconf.syslog_ident = syslog_ident
        if syslog_facility != None:
            startupconf.syslog_facility = syslog_facility
        if syslog_device != None:
            startupconf.syslog_device = syslog_device
        if releasever == '/':
            if startupconf.installroot == '/':
                releasever = None
            else:
                releasever = yum.config._getsysver("/",startupconf.distroverpkg)
        if releasever != None:
            startupconf.releasever = releasever

        self.doLoggingSetup(startupconf.debuglevel, startupconf.errorlevel,
                            startupconf.syslog_ident,
                            startupconf.syslog_facility,
                            startupconf.syslog_device)

        if init_plugins and startupconf.plugins:
            self.doPluginSetup(optparser, plugin_types, startupconf.pluginpath,
                    startupconf.pluginconfpath,disabled_plugins,enabled_plugins)

        self._conf = config.readMainConfig(startupconf)

        #  We don't want people accessing/altering preconf after it becomes
        # worthless. So we delete it, and thus. it'll raise AttributeError
        del self.preconf

        # Packages used to run yum...
        for pkgname in self.conf.history_record_packages:
            self.run_with_package_names.add(pkgname)

        # run the postconfig plugin hook
        self.plugins.run('postconfig')
        #  Note that Pungi has historically replaced _getConfig(), and it sets
        # up self.conf.yumvar but not self.yumvar ... and AFAIK nothing needs
        # to use YumBase.yumvar, so it's probably easier to just semi-deprecate
        # this (core now only uses YumBase.conf.yumvar).
        self.yumvar = self.conf.yumvar

        # who are we:
        self.conf.uid = os.geteuid()
        # repos are ver/arch specific so add $basearch/$releasever
        self.conf._repos_persistdir = os.path.normpath('%s/repos/%s/%s/'
               % (self.conf.persistdir,  self.yumvar.get('basearch', '$basearch'),
                  self.yumvar.get('releasever', '$releasever')))        
        self.doFileLogSetup(self.conf.uid, self.conf.logfile)
        self.verbose_logger.debug('Config time: %0.3f' % (time.time() - conf_st))
        self.plugins.run('init')
        return self._conf
        

    def doLoggingSetup(self, debuglevel, errorlevel,
                       syslog_ident=None, syslog_facility=None,
                       syslog_device='/dev/log'):
        '''
        Perform logging related setup.

        @param debuglevel: Debug logging level to use.
        @param errorlevel: Error logging level to use.
        '''
        logginglevels.doLoggingSetup(debuglevel, errorlevel,
                                     syslog_ident, syslog_facility,
                                     syslog_device)

    def doFileLogSetup(self, uid, logfile):
        logginglevels.setFileLog(uid, logfile, self._cleanup)

    def getReposFromConfigFile(self, repofn, repo_age=None, validate=None):
        """read in repositories from a config .repo file"""

        if repo_age is None:
            repo_age = os.stat(repofn)[8]
        
        confpp_obj = ConfigPreProcessor(repofn, vars=self.conf.yumvar)
        parser = ConfigParser()
        try:
            parser.readfp(confpp_obj)
        except ParsingError, e:
            msg = str(e)
            raise Errors.ConfigError, msg

        # Check sections in the .repo file that was just slurped up
        for section in parser.sections():

            if section in ['main', 'installed']:
                continue

            # Check the repo.id against the valid chars
            bad = None
            for byte in section:
                if byte in string.ascii_letters:
                    continue
                if byte in string.digits:
                    continue
                if byte in "-_.:":
                    continue
                
                bad = byte
                break

            if bad:
                self.logger.warning("Bad id for repo: %s, byte = %s %d" %
                                    (section, bad, section.find(bad)))
                continue

            try:
                thisrepo = self.readRepoConfig(parser, section)
            except (Errors.RepoError, Errors.ConfigError), e:
                self.logger.warning(e)
                continue
            else:
                thisrepo.repo_config_age = repo_age
                thisrepo.repofile = repofn

                thisrepo.base_persistdir = self.conf._repos_persistdir


            if thisrepo.id in self.repo_setopts:
                for opt in self.repo_setopts[thisrepo.id].items:
                    if not hasattr(thisrepo, opt):
                        msg = "Repo %s did not have a %s attr. before setopt"
                        self.logger.warning(msg % (thisrepo.id, opt))
                    setattr(thisrepo, opt, getattr(self.repo_setopts[thisrepo.id], opt))
                    
            if validate and not validate(thisrepo):
                continue
                    
            # Got our list of repo objects, add them to the repos
            # collection
            try:
                self._repos.add(thisrepo)
            except Errors.RepoError, e:
                self.logger.warning(e)
        
    def getReposFromConfig(self):
        """read in repositories from config main and .repo files"""

        # Read .repo files from directories specified by the reposdir option
        # (typically /etc/yum/repos.d)
        repo_config_age = self.conf.config_file_age
        
        # Get the repos from the main yum.conf file
        self.getReposFromConfigFile(self.conf.config_file_path, repo_config_age)

        for reposdir in self.conf.reposdir:
            # this check makes sure that our dirs exist properly.
            # if they aren't in the installroot then don't prepend the installroot path
            # if we don't do this then anaconda likes to not  work.
            if os.path.exists(self.conf.installroot+'/'+reposdir):
                reposdir = self.conf.installroot + '/' + reposdir

            if os.path.isdir(reposdir):
                for repofn in sorted(glob.glob('%s/*.repo' % reposdir)):
                    thisrepo_age = os.stat(repofn)[8]
                    if thisrepo_age < repo_config_age:
                        thisrepo_age = repo_config_age
                    self.getReposFromConfigFile(repofn, repo_age=thisrepo_age)

    def readRepoConfig(self, parser, section):
        '''Parse an INI file section for a repository.

        @param parser: ConfParser or similar to read INI file values from.
        @param section: INI file section to read.
        @return: YumRepository instance.
        '''
        repo = yumRepo.YumRepository(section)
        try:
            repo.populate(parser, section, self.conf)
        except ValueError, e:
            msg = _('Repository %r: Error parsing config: %s' % (section,e))
            raise Errors.ConfigError, msg

        # Ensure that the repo name is set
        if not repo.name:
            repo.name = section
            self.logger.error(_('Repository %r is missing name in configuration, '
                    'using id') % section)
        repo.name = to_unicode(repo.name)

        # Set attributes not from the config file
        repo.basecachedir = self.conf.cachedir
        repo.yumvar.update(self.conf.yumvar)
        repo.cfg = parser

        return repo

    def disablePlugins(self):
        '''Disable yum plugins
        '''
        self.plugins = plugins.DummyYumPlugins()
    
    def doPluginSetup(self, optparser=None, plugin_types=None, searchpath=None,
            confpath=None,disabled_plugins=None,enabled_plugins=None):
        '''Initialise and enable yum plugins. 

        Note: _getConfig() will initialise plugins if instructed to. Only
        call this method directly if not calling _getConfig() or calling
        doConfigSetup(init_plugins=False).

        @param optparser: The OptionParser instance for this run (optional)
        @param plugin_types: A sequence specifying the types of plugins to load.
            This should be a sequence containing one or more of the
            yum.plugins.TYPE_...  constants. If None (the default), all plugins
            will be loaded.
        @param searchpath: A list of directories to look in for plugins. A
            default will be used if no value is specified.
        @param confpath: A list of directories to look in for plugin
            configuration files. A default will be used if no value is
            specified.
        @param disabled_plugins: Plugins to be disabled    
        @param enabled_plugins: Plugins to be enabled
        '''
        if isinstance(self.plugins, plugins.YumPlugins):
            raise RuntimeError(_("plugins already initialised"))

        self.plugins = plugins.YumPlugins(self, searchpath, optparser,
                plugin_types, confpath, disabled_plugins, enabled_plugins)

    
    def doRpmDBSetup(self):
        warnings.warn(_('doRpmDBSetup() will go away in a future version of Yum.\n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)

        return self._getRpmDB()
    
    def _getRpmDB(self):
        """sets up a holder object for important information from the rpmdb"""

        if self._rpmdb is None:
            rpmdb_st = time.time()
            self.verbose_logger.log(logginglevels.DEBUG_4,
                                    _('Reading Local RPMDB'))
            self._rpmdb = rpmsack.RPMDBPackageSack(root=self.conf.installroot,
                                                   releasever=self.conf.yumvar['releasever'],
                                                   persistdir=self.conf.persistdir)
            self.verbose_logger.debug('rpmdb time: %0.3f' % (time.time() - rpmdb_st))
        return self._rpmdb

    def closeRpmDB(self):
        """closes down the instances of the rpmdb we have wangling around"""
        if self._rpmdb is not None:
            self._rpmdb.ts = None
            self._rpmdb.dropCachedData()
        self._rpmdb = None
        self._ts = None
        self._tsInfo = None
        self._up = None
        self.comps = None
    
    def _deleteTs(self):
        del self._ts
        self._ts = None

    def doRepoSetup(self, thisrepo=None):
        warnings.warn(_('doRepoSetup() will go away in a future version of Yum.\n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)

        return self._getRepos(thisrepo, True)

    def _getRepos(self, thisrepo=None, doSetup = False):
        """ For each enabled repository set up the basics of the repository. """
        if hasattr(self, 'prerepoconf'):
            self.conf # touch the config class first

            self.getReposFromConfig()

        #  For rhnplugin, and in theory other stuff, calling
        # .getReposFromConfig() recurses back into this function but only once.
        # This means that we have two points on the stack leaving the above call
        # but only one of them can do the repos setup. BZ 678043.
        if hasattr(self, 'prerepoconf'):
            # Recursion
            prerepoconf = self.prerepoconf
            del self.prerepoconf

            self.repos.setProgressBar(prerepoconf.progressbar)
            self.repos.callback = prerepoconf.callback
            self.repos.setFailureCallback(prerepoconf.failure_callback)
            self.repos.setInterruptCallback(prerepoconf.interrupt_callback)
            self.repos.confirm_func = prerepoconf.confirm_func
            self.repos.gpg_import_func = prerepoconf.gpg_import_func
            self.repos.gpgca_import_func = prerepoconf.gpgca_import_func
            if prerepoconf.cachedir is not None:
                self.repos.setCacheDir(prerepoconf.cachedir)
            if prerepoconf.cache is not None:
                self.repos.setCache(prerepoconf.cache)


        if doSetup:
            if (hasattr(urlgrabber, 'grabber') and
                hasattr(urlgrabber.grabber, 'pycurl')):
                # Must do basename checking, on cert. files...
                cert_basenames = {}
                for repo in self._repos.listEnabled():
                    if not repo.sslclientcert:
                        continue
                    bn = os.path.basename(repo.sslclientcert)
                    if bn not in cert_basenames:
                        cert_basenames[bn] = repo
                        continue
                    if repo.sslclientcert == cert_basenames[bn].sslclientcert:
                        # Exactly the same path is fine too
                        continue

                    msg = 'sslclientcert basename shared between %s and %s'
                    raise Errors.ConfigError, msg % (repo, cert_basenames[bn])

            repo_st = time.time()        
            self._repos.doSetup(thisrepo)
            self.verbose_logger.debug('repo time: %0.3f' % (time.time() - repo_st))        
        return self._repos

    def _delRepos(self):
        del self._repos
        self._repos = RepoStorage(self)
    
    def doSackSetup(self, archlist=None, thisrepo=None):
        warnings.warn(_('doSackSetup() will go away in a future version of Yum.\n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)

        return self._getSacks(archlist=archlist, thisrepo=thisrepo)
        
    def _getSacks(self, archlist=None, thisrepo=None):
        """populates the package sacks for information from our repositories,
           takes optional archlist for archs to include"""

        # FIXME: Fist of death ... normally we'd do either:
        #
        # 1. use self._pkgSack is not None, and only init. once.
        # 2. auto. correctly re-init each time a repo is added/removed
        #
        # ...we should probably just smeg it and do #2, but it's hard and will
        # probably break something (but it'll "fix" excludes).
        #  #1 can't be done atm. because we did self._pkgSack and external
        # tools now rely on being able to create an empty sack and then have it
        # auto. re-init when they add some stuff. So we add a bit more "clever"
        # and don't setup the pkgSack to not be None when it's empty. This means
        # we skip excludes/includes/etc. ... but there's no packages, so
        # hopefully that's ok.
        if self._pkgSack is not None and thisrepo is None:
            return self._pkgSack
        
        if thisrepo is None:
            repos = 'enabled'
        else:
            repos = self.repos.findRepos(thisrepo)
        
        self.verbose_logger.debug(_('Setting up Package Sacks'))
        sack_st = time.time()
        if not archlist:
            archlist = self.arch.archlist
        
        archdict = {}
        for arch in archlist:
            archdict[arch] = 1
        
        self.repos.getPackageSack().setCompatArchs(archdict)
        self.repos.populateSack(which=repos)
        if not self.repos.getPackageSack():
            return self.repos.getPackageSack() # ha ha, see above
        self._pkgSack = self.repos.getPackageSack()
        
        self.excludePackages()
        self._pkgSack.excludeArchs(archlist)
        
        #FIXME - this could be faster, too.
        if repos == 'enabled':
            repos = self.repos.listEnabled()
        for repo in repos:
            self.includePackages(repo)
            self.excludePackages(repo)
        self.plugins.run('exclude')
        self._pkgSack.buildIndexes()

        # now go through and kill pkgs based on pkg.repo.cost()
        self.costExcludePackages()
        self.verbose_logger.debug('pkgsack time: %0.3f' % (time.time() - sack_st))
        return self._pkgSack
    
    
    def _delSacks(self):
        """reset the package sacks back to zero - making sure to nuke the ones
           in the repo objects, too - where it matters"""
           
        # nuke the top layer
        
        self._pkgSack = None
           
        for repo in self.repos.repos.values():
            if hasattr(repo, '_resetSack'):
                repo._resetSack()
            else:
                warnings.warn(_('repo object for repo %s lacks a _resetSack method\n') +
                        _('therefore this repo cannot be reset.\n'),
                        Errors.YumFutureDeprecationWarning, stacklevel=2)
            
           
    def doUpdateSetup(self):
        warnings.warn(_('doUpdateSetup() will go away in a future version of Yum.\n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)

        return self._getUpdates()
        
    def _getUpdates(self):
        """setups up the update object in the base class and fills out the
           updates, obsoletes and others lists"""
        
        if self._up:
            return self._up
        
        self.verbose_logger.debug(_('Building updates object'))

        up_st = time.time()

        self._up = rpmUtils.updates.Updates(self.rpmdb.simplePkgList(), self.pkgSack.simplePkgList())
        if self.conf.debuglevel >= 7:
            self._up.debug = 1
        
        if hasattr(self, '_up_obs_hack'):
            self._up.rawobsoletes = self._up_obs_hack.rawobsoletes
            del self._up_obs_hack
        elif self.conf.obsoletes:
            obs_init = time.time()    
            #  Note: newest=True here is semi-required for repos. with multiple
            # versions. The problem is that if pkgA-2 _accidentally_ obsoletes
            # pkgB-1, and we keep all versions, we want to release a pkgA-3
            # that doesn't do the obsoletes ... and thus. not obsolete pkgB-1.
            self._up.rawobsoletes = self.pkgSack.returnObsoletes(newest=True)
            self.verbose_logger.debug('up:Obs Init time: %0.3f' % (time.time() - obs_init))

        self._up.myarch = self.arch.canonarch
        self._up._is_multilib = self.arch.multilib
        self._up._archlist = self.arch.archlist
        self._up._multilib_compat_arches = self.arch.compatarches
        self._up.exactarch = self.conf.exactarch
        self._up.exactarchlist = self.conf.exactarchlist
        up_pr_st = time.time()
        self._up.doUpdates()
        self.verbose_logger.debug('up:simple updates time: %0.3f' % (time.time() - up_pr_st))

        if self.conf.obsoletes:
            obs_st = time.time()
            self._up.doObsoletes()
            self.verbose_logger.debug('up:obs time: %0.3f' % (time.time() - obs_st))

        cond_up_st = time.time()                    
        self._up.condenseUpdates()
        self.verbose_logger.debug('up:condense time: %0.3f' % (time.time() - cond_up_st))
        self.verbose_logger.debug('updates time: %0.3f' % (time.time() - up_st))        
        return self._up
    
    def doGroupSetup(self):
        warnings.warn(_('doGroupSetup() will go away in a future version of Yum.\n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)

        self.comps = None
        return self._getGroups()

    def _setGroups(self, val):
        if val is None:
            # if we unset the comps object, we need to undo which repos have
            # been added to the group file as well
            if self._repos:
                for repo in self._repos.listGroupsEnabled():
                    repo.groups_added = False
        self._comps = val
    
    def _getGroups(self):
        """create the groups object that will store the comps metadata
           finds the repos with groups, gets their comps data and merge it
           into the group object"""
        
        if self._comps:
            return self._comps

        group_st = time.time()            
        self.verbose_logger.log(logginglevels.DEBUG_4,
                                _('Getting group metadata'))
        reposWithGroups = []
        #  Need to make sure the groups data is ready to read. Really we'd want
        # to add groups to the mdpolicy list of the repo. but we don't atm.
        self.pkgSack
        for repo in self.repos.listGroupsEnabled():
            if repo.groups_added: # already added the groups from this repo
                reposWithGroups.append(repo)
                continue
                
            if not repo.ready():
                raise Errors.RepoError, "Repository '%s' not yet setup" % repo
            try:
                groupremote = repo.getGroupLocation()
            except Errors.RepoMDError, e:
                pass
            else:
                reposWithGroups.append(repo)
        
        # now we know which repos actually have groups files.
        overwrite = self.conf.overwrite_groups
        self._comps = comps.Comps(overwrite_groups = overwrite)

        for repo in reposWithGroups:
            if repo.groups_added: # already added the groups from this repo
                continue
                
            self.verbose_logger.log(logginglevels.DEBUG_4,
                _('Adding group file from repository: %s'), repo)
            groupfile = repo.getGroups()
            # open it up as a file object so iterparse can cope with our compressed file
            if groupfile:
                groupfile = misc.repo_gen_decompress(groupfile, 'groups.xml',
                                                     cached=repo.cache)
                # Do we want a RepoError here?
                
            try:
                self._comps.add(groupfile)
            except (Errors.GroupsError,Errors.CompsException), e:
                msg = _('Failed to add groups file for repository: %s - %s') % (repo, str(e))
                self.logger.critical(msg)
            else:
                repo.groups_added = True

        if self._comps.compscount == 0:
            raise Errors.GroupsError, _('No Groups Available in any repository')

        self._comps.compile(self.rpmdb.simplePkgList())
        self.verbose_logger.debug('group time: %0.3f' % (time.time() - group_st))                
        return self._comps

    def _getTags(self):
        """ create the tags object used to search/report from the pkgtags 
            metadata"""
        
        tag_st = time.time()
        self.verbose_logger.log(logginglevels.DEBUG_4,
                                _('Getting pkgtags metadata'))
        
        if self._tags is None:
            self._tags = yum.pkgtag_db.PackageTags()
           
            for repo in self.repos.listEnabled():
                if 'pkgtags' not in repo.repoXML.fileTypes():
                    continue

                self.verbose_logger.log(logginglevels.DEBUG_4,
                    _('Adding tags from repository: %s'), repo)
                
                # fetch the sqlite tagdb
                try:
                    tag_md = repo.retrieveMD('pkgtags')
                    tag_sqlite  = misc.repo_gen_decompress(tag_md,
                                                           'pkgtags.sqlite',
                                                           cached=repo.cache)
                    # feed it into _tags.add()
                    self._tags.add(repo.id, tag_sqlite)
                except (Errors.RepoError, Errors.PkgTagsError), e:
                    msg = _('Failed to add Pkg Tags for repository: %s - %s') % (repo, str(e))
                    self.logger.critical(msg)
                    
                
        self.verbose_logger.debug('tags time: %0.3f' % (time.time() - tag_st))
        return self._tags
        
    def _getHistory(self):
        """auto create the history object that to access/append the transaction
           history information. """
        if self._history is None:
            pdb_path = self.conf.persistdir + "/history"
            self._history = yum.history.YumHistory(root=self.conf.installroot,
                                                   db_path=pdb_path)
        return self._history
    
    # properties so they auto-create themselves with defaults
    repos = property(fget=lambda self: self._getRepos(),
                     fset=lambda self, value: setattr(self, "_repos", value),
                     fdel=lambda self: self._delRepos(),
                     doc="Repo Storage object - object of yum repositories")
    pkgSack = property(fget=lambda self: self._getSacks(),
                       fset=lambda self, value: setattr(self, "_pkgSack", value),
                       fdel=lambda self: self._delSacks(),
                       doc="Package sack object - object of yum package objects")
    conf = property(fget=lambda self: self._getConfig(),
                    fset=lambda self, value: setattr(self, "_conf", value),
                    fdel=lambda self: setattr(self, "_conf", None),
                    doc="Yum Config Object")
    rpmdb = property(fget=lambda self: self._getRpmDB(),
                     fset=lambda self, value: setattr(self, "_rpmdb", value),
                     fdel=lambda self: setattr(self, "_rpmdb", None),
                     doc="RpmSack object")
    tsInfo = property(fget=lambda self: self._getTsInfo(), 
                      fset=lambda self,value: self._setTsInfo(value), 
                      fdel=lambda self: self._delTsInfo(),
                      doc="Transaction Set information object")
    ts = property(fget=lambda self: self._getActionTs(), 
                  fdel=lambda self: self._deleteTs(),
                  doc="TransactionSet object")
    up = property(fget=lambda self: self._getUpdates(),
                  fset=lambda self, value: setattr(self, "_up", value),
                  fdel=lambda self: setattr(self, "_up", None),
                  doc="Updates Object")
    comps = property(fget=lambda self: self._getGroups(),
                     fset=lambda self, value: self._setGroups(value),
                     fdel=lambda self: setattr(self, "_comps", None),
                     doc="Yum Component/groups object")
    history = property(fget=lambda self: self._getHistory(),
                       fset=lambda self, value: setattr(self, "_history",value),
                       fdel=lambda self: setattr(self, "_history", None),
                       doc="Yum History Object")

    pkgtags = property(fget=lambda self: self._getTags(),
                       fset=lambda self, value: setattr(self, "_tags",value),
                       fdel=lambda self: setattr(self, "_tags", None),
                       doc="Yum Package Tags Object")
    
    
    def doSackFilelistPopulate(self):
        """convenience function to populate the repos with the filelist metadata
           it also is simply to only emit a log if anything actually gets populated"""
        
        necessary = False
        
        # I can't think of a nice way of doing this, we have to have the sack here
        # first or the below does nothing so...
        if self.pkgSack:
            for repo in self.repos.listEnabled():
                if repo in repo.sack.added:
                    if 'filelists' in repo.sack.added[repo]:
                        continue
                    else:
                        necessary = True
                else:
                    necessary = True

        if necessary:
            msg = _('Importing additional filelist information')
            self.verbose_logger.log(logginglevels.INFO_2, msg)
            self.repos.populateSack(mdtype='filelists')
           
    def yumUtilsMsg(self, func, prog):
        """ Output a message that the tool requires the yum-utils package,
            if not installed. """
        if self.rpmdb.contains(name="yum-utils"):
            return

        hibeg, hiend = "", ""
        if hasattr(self, 'term'):
            hibeg, hiend = self.term.MODE['bold'], self.term.MODE['normal']

        func(_("The program %s%s%s is found in the yum-utils package.") %
             (hibeg, prog, hiend))

    def buildTransaction(self, unfinished_transactions_check=True):
        """go through the packages in the transaction set, find them in the
           packageSack or rpmdb, and pack up the ts accordingly"""
        if (unfinished_transactions_check and
            misc.find_unfinished_transactions(yumlibpath=self.conf.persistdir)):
            msg = _('There are unfinished transactions remaining. You might ' \
                    'consider running yum-complete-transaction first to finish them.' )
            self.logger.critical(msg)
            self.yumUtilsMsg(self.logger.critical, "yum-complete-transaction")
            time.sleep(3)
        
        # XXX - we could add a conditional here to avoid running the plugins and 
        # limit_installonly_pkgs, etc - if we're being run from yum-complete-transaction
        # and don't want it to happen. - skv
        
        self.plugins.run('preresolve')
        ds_st = time.time()

        (rescode, restring) = self.resolveDeps()
        self._limit_installonly_pkgs()
        # if enabled clean up requirments when removing the things which brought them in.
        if self.conf.clean_requirements_on_remove:
            self.verbose_logger.log(logginglevels.INFO_2, _('--> Finding unneeded leftover dependencies'))
            self._remove_old_deps()
        #  We _must_ get rid of all the used tses before we go on, so that C-c
        # works for downloads / mirror failover etc.
        kern_pkgtup = None
        if rescode == 2 and self.conf.protected_packages:
            kern_pkgtup =misc.get_running_kernel_pkgtup(self.rpmdb.readOnlyTS())
        self.rpmdb.ts = None

        # do the skip broken magic, if enabled and problems exist
        (rescode, restring) = self._doSkipBroken(rescode, restring)

        self.plugins.run('postresolve', rescode=rescode, restring=restring)

        if self.tsInfo.changed:
            (rescode, restring) = self.resolveDeps(rescode == 1)
            # If transaction was changed by postresolve plugins then we should run skipbroken again
            (rescode, restring) = self._doSkipBroken(rescode, restring, clear_skipped=False )

        if self.tsInfo.pkgSack is not None: # rm Transactions don't have pkgSack
            self.tsInfo.pkgSack.dropCachedData()

        # FIXME: This is horrible, see below and yummain. Maybe create a real
        #        rescode object? :(
        self._depsolving_failed = rescode == 1

        txmbrs = []
        if rescode == 2 and self.conf.protected_multilib and self.arch.multilib:
            txmbrs = self.tsInfo.getMembersWithState(None, TS_INSTALL_STATES)
        vers = {}
        for txmbr in txmbrs:
            if self.allowedMultipleInstalls(txmbr.po):
                continue # Just allow these, it's easier.

            #  In theory we could skip noarch packages here, but it's really
            # fast and there are some edge cases where it'll help.
            if txmbr.name not in vers:
                vers[txmbr.name] = [txmbr.po]
                continue
            vers[txmbr.name].append(txmbr.po)

        fine = []
        xrestring = []
        for pkgname in vers:
            if len(vers[pkgname]) <= 1:
                # We have to go govelling through the rpmdb data to get
                for pkg in self.rpmdb.searchNames([pkgname]):
                    if self.tsInfo.getMembersWithState(pkg.pkgtup,
                                                       TS_REMOVE_STATES):
                        continue
                    vers[pkgname].append(pkg)

            #  If we have multiple packages, they should be of different arches
            # and so if all the versions are equal, we should be fine.
            first = vers[pkgname][0]
            for other in vers[pkgname][1:]:
                if first.verEQ(other):
                    continue
                msg = _('Protected multilib versions: %s != %s')
                xrestring.append(msg % (first, other))
        if xrestring:
            rescode = 1
            self._depsolving_failed = False
            restring = xrestring

        #  This is a version of the old "protect-packages" plugin, it allows
        # you to erase duplicates and do remove+install.
        #  But we don't allow you to turn it off!:)
        protect_states = [TS_OBSOLETED, TS_ERASE]
        txmbrs = []
        if rescode == 2 and self.conf.protected_packages:
            protected = set(self.conf.protected_packages)
            txmbrs = self.tsInfo.getMembersWithState(None, protect_states)
        bad_togo = {}
        for txmbr in txmbrs:
            if kern_pkgtup is not None and txmbr.pkgtup == kern_pkgtup:
                pass
            elif kern_pkgtup is not None and txmbr.name == kern_pkgtup[0]:
                #  We don't care if they've explicitly set protected on the
                # kernel package. Because we don't allow you to uninstall the
                # running one so it has _special_ semantics anyway.
                continue
            elif txmbr.name not in protected:
                continue
            if txmbr.name not in bad_togo:
                bad_togo[txmbr.name] = []
            bad_togo[txmbr.name].append(txmbr.pkgtup)
        for ipkg in self.rpmdb.searchNames(bad_togo.keys()):
            if (kern_pkgtup is not None and ipkg.name == kern_pkgtup[0] and
                kern_pkgtup in bad_togo[kern_pkgtup[0]]):
                continue # If "running kernel" matches, it's always bad.
            if ipkg.name not in bad_togo:
                continue
            # If there is at least one version not being removed, allow it
            if ipkg.pkgtup not in bad_togo[ipkg.name]:
                del bad_togo[ipkg.name]
        for pkgname in bad_togo.keys():
            if (kern_pkgtup is not None and pkgname == kern_pkgtup[0] and
                kern_pkgtup in bad_togo[kern_pkgtup[0]]):
                continue # If "running kernel" matches, it's always bad.
            for txmbr in self.tsInfo.matchNaevr(name=pkgname):
                if txmbr.name not in bad_togo:
                    continue
                if txmbr.pkgtup in bad_togo[ipkg.name]:
                    continue
                # If we are installing one version we aren't removing, allow it
                if txmbr.output_state in TS_INSTALL_STATES:
                    del bad_togo[ipkg.name]

        if bad_togo:
            rescode = 1
            restring = []
            for pkgname in sorted(bad_togo):
                restring.append(_('Trying to remove "%s", which is protected') %
                                pkgname)
            self._depsolving_failed = False

        if rescode == 2:
            self.save_ts(auto=True)
        self.verbose_logger.debug('Depsolve time: %0.3f' % (time.time() - ds_st))
        return rescode, restring

    def _doSkipBroken(self,rescode, restring, clear_skipped=True):
        ''' do skip broken if it is enabled '''
        # if depsolve failed and skipbroken is enabled
        # The remove the broken packages from the transactions and
        # Try another depsolve
        if self.conf.skip_broken and rescode==1:
            if clear_skipped:
                self.skipped_packages = []    # reset the public list of skipped packages.
            sb_st = time.time()
            rescode, restring = self._skipPackagesWithProblems(rescode, restring)
            self._printTransaction()        
            self.verbose_logger.debug('Skip-Broken time: %0.3f' % (time.time() - sb_st))
        return (rescode, restring)
            

    def _skipPackagesWithProblems(self, rescode, restring):
        ''' Remove the packages with depsolve errors and depsolve again '''

        def _remove(po, depTree, toRemove):
            if not po:
                return
            self._getPackagesToRemove(po, depTree, toRemove)
            # Only remove non installed packages from pkgSack
            _remove_from_sack(po)

        def _remove_from_sack(po):
            # get all compatible arch packages from pkgSack
            # we need to remove them too so i386 packages are not 
            # dragged in when a x86_64 is skipped.
            pkgs = self._getPackagesToRemoveAllArch(po)
            for pkg in pkgs:
                if not po.repoid == 'installed' and pkg not in removed_from_sack:             
                    self.verbose_logger.debug('SKIPBROKEN: removing %s from pkgSack & updates' % str(po))
                    self.pkgSack.delPackage(pkg)
                    self.up.delPackage(pkg.pkgtup)
                    removed_from_sack.add(pkg)

        # Keep removing packages & Depsolve until all errors is gone
        # or the transaction is empty
        count = 0
        skipped_po = set()
        removed_from_sack = set()
        orig_restring = restring    # Keep the old error messages 
        looping = 0 
        while (len(self.po_with_problems) > 0 and rescode == 1):
            count += 1
            #  Remove all the rpmdb cache data, this is somewhat heavy handed
            # but easier than removing/altering specific bits of the cache ...
            # and skip-broken shouldn't care too much about speed.
            self.rpmdb.transactionReset()
            self.installedFileRequires = None # Kind of hacky
            self.verbose_logger.debug("SKIPBROKEN: ########### Round %i ################" , count)
            if count == 30: # Failsafe, to avoid endless looping
                self.verbose_logger.debug('SKIPBROKEN: Too many loops ')
                break
            self._printTransaction()        
            depTree = self._buildDepTree()
            startTs = set(self.tsInfo)
            toRemove = set()
            for po,wpo,err in self.po_with_problems:
                # check if the problem is caused by a package in the transaction
                if not self.tsInfo.exists(po.pkgtup):
                    _remove(wpo, depTree, toRemove)
                else:
                    _remove(po,  depTree, toRemove)
            for po in toRemove:
                skipped = self._skipFromTransaction(po)
                for skip in skipped:
                    skipped_po.add(skip)
                    # make sure we get the compat arch packages skip from pkgSack and up too.
                    if skip not in removed_from_sack and skip.repoid != 'installed':
                        _remove_from_sack(skip)
            # Nothing was removed, so we still got a problem
             # the first time we get here we reset the resolved members of
             # tsInfo and takes a new run all members in the current transaction
            if not toRemove: 
                looping += 1
                if looping > 2:
                    break # Bail out
                else:
                    self.verbose_logger.debug('SKIPBROKEN: resetting already resolved packages (no packages to skip)' )
                    self.tsInfo.resetResolved(hard=True)
            rescode, restring = self.resolveDeps(True, skipping_broken=True)
            endTs = set(self.tsInfo)
             # Check if tsInfo has changes since we started to skip packages
             # if there is no changes then we got a loop.
             # the first time we get here we reset the resolved members of
             # tsInfo and takes a new run all members in the current transaction
            if startTs-endTs == set():
                looping += 1
                if looping > 2:
                    break # Bail out
                else:
                    self.verbose_logger.debug('SKIPBROKEN: resetting already resolved packages (transaction not changed)' )
                    self.tsInfo.resetResolved(hard=True)
            else: 
                # Reset the looping counter, because it is only a loop if the same transaction is
                # unchanged two times in row, not if it has been unchanged in a early stage.
                looping = 0 
                    
            # if we are all clear, then we have to check that the whole current transaction 
            # can complete the depsolve without error, because the packages skipped
            # can have broken something that passed the tests earlier.
            # FIXME: We need do this in a better way.
            if rescode != 1:
                self.verbose_logger.debug('SKIPBROKEN: sanity check the current transaction' )
                self.tsInfo.resetResolved(hard=True)
                self._checkMissingObsoleted() # This is totally insane, but needed :(
                self._checkUpdatedLeftovers() # Cleanup updated leftovers
                rescode, restring = self.resolveDeps()
        if rescode != 1:
            self.verbose_logger.debug("SKIPBROKEN: took %i rounds ", count)
            self.verbose_logger.info(_('\nPackages skipped because of dependency problems:'))
            skipped_list = [p for p in skipped_po]
            skipped_list.sort()
            for po in skipped_list:
                msg = _("    %s from %s") % (str(po),po.repo.id)
                self.verbose_logger.info(msg)
            self.skipped_packages.extend(skipped_list)   # make the skipped packages public
        else:
            # If we cant solve the problems the show the original error messages.
            self.verbose_logger.info("Skip-broken could not solve problems")
            return 1, orig_restring
        return rescode, restring

    def _add_not_found(self, pkgs, nevra_dict):
        if pkgs:
            return None

        pkgtup = (nevra_dict['name'], nevra_dict['arch'],
                  nevra_dict['epoch'], nevra_dict['version'],
                  nevra_dict['release'])
        if None in pkgtup:
            return None
        return pkgtup
    def _add_not_found_a(self, pkgs, nevra_dict):
        pkgtup = self._add_not_found(pkgs, nevra_dict)
        if pkgtup is None:
            return
        self._not_found_a[pkgtup] = YumNotFoundPackage(pkgtup)
    def _add_not_found_i(self, pkgs, nevra_dict):
        pkgtup = self._add_not_found(pkgs, nevra_dict)
        if pkgtup is None:
            return
        self._not_found_i[pkgtup] = YumNotFoundPackage(pkgtup)

    def _checkMissingObsoleted(self):
        """ 
        If multiple packages is obsoleting the same package
        then the TS_OBSOLETED can get removed from the transaction
        so we must make sure that they, exist and else create them
        """
        for txmbr in self.tsInfo.getMembersWithState(None, [TS_OBSOLETING,TS_OBSOLETED]):
            for pkg in txmbr.obsoletes:
                if not self.tsInfo.exists(pkg.pkgtup):
                    obs = self.tsInfo.addObsoleted(pkg,txmbr.po)
                    self.verbose_logger.debug('SKIPBROKEN: Added missing obsoleted %s (%s)' % (pkg,txmbr.po) )
            for pkg in txmbr.obsoleted_by:
                # check if the obsoleting txmbr is in the transaction
                # else remove the obsoleted txmbr
                # it clean out some really wierd cases
                if not self.tsInfo.exists(pkg.pkgtup):
                    self.verbose_logger.debug('SKIPBROKEN: Remove extra obsoleted %s (%s)' % (txmbr.po,pkg) )
                    self.tsInfo.remove(txmbr.po.pkgtup)

    def _checkUpdatedLeftovers(self):
        """ 
        If multiple packages is updated the same package
        and this package get removed because of an dep issue
        then make sure that all the TS_UPDATED get removed.
        """
        for txmbr in self.tsInfo.getMembersWithState(None, [TS_UPDATED]):
            for pkg in txmbr.updated_by:
                # check if the updating txmbr is in the transaction
                # else remove the updated txmbr
                # it clean out some really wierd cases with dupes installed on the system
                if not self.tsInfo.exists(pkg.pkgtup):
                    self.verbose_logger.debug('SKIPBROKEN: Remove extra updated %s (%s)' % (txmbr.po,pkg) )
                    self.tsInfo.remove(txmbr.po.pkgtup)

    def _getPackagesToRemoveAllArch(self,po):
        ''' get all compatible arch packages in pkgSack'''
        pkgs = []
        if self.arch.multilib:
            n,a,e,v,r = po.pkgtup
            # skip for all compat archs
            for a in self.arch.archlist:
                pkgtup = (n,a,e,v,r)
                matched = self.pkgSack.searchNevra(n,e,v,r,a) 
                pkgs.extend(matched)
        else:
            pkgs.append(po)
        return pkgs   
        
                
                
        

    def _skipFromTransaction(self,po):
        skipped =  []
        n,a,e,v,r = po.pkgtup
        # skip for all compat archs
        for a in self.arch.archlist:
            pkgtup = (n,a,e,v,r)
            if self.tsInfo.exists(pkgtup):
                for txmbr in self.tsInfo.getMembers(pkgtup):
                    pkg = txmbr.po
                    skip = self._removePoFromTransaction(pkg)
                    skipped.extend(skip)
        return skipped

    def _removePoFromTransaction(self,po):
        skip =  []
        if self.tsInfo.exists(po.pkgtup):
            self.verbose_logger.debug('SKIPBROKEN: removing %s from transaction' % str(po))
            self.tsInfo.remove(po.pkgtup)
            if not po.repoid == 'installed':
                skip.append(po)
        return skip 
              
    def _buildDepTree(self):
        ''' create a dictionary with po and deps '''
        depTree = { }
        for txmbr in self.tsInfo:
            for dep in txmbr.depends_on:
                depTree.setdefault(dep, []).append(txmbr.po)
        # self._printDepTree(depTree)
        return depTree

    def _printDepTree(self, tree):
        for pkg, l in tree.iteritems():
            print pkg
            for p in l:
                print "\t", p

    def _printTransaction(self):
        #transaction set states
        state = { TS_UPDATE     : "update",
                  TS_INSTALL    : "install",
                  TS_TRUEINSTALL: "trueinstall",
                  TS_ERASE      : "erase",
                  TS_OBSOLETED  : "obsoleted",
                  TS_OBSOLETING : "obsoleting",
                  TS_AVAILABLE  : "available",
                  TS_UPDATED    : "updated"}

        self.verbose_logger.log(logginglevels.DEBUG_2,"SKIPBROKEN: Current Transaction : %i member(s) " % len(self.tsInfo))
        for txmbr in sorted(self.tsInfo):
            msg = "SKIPBROKEN:  %-11s : %s " % (state[txmbr.output_state],txmbr.po)
            self.verbose_logger.log(logginglevels.DEBUG_2, msg)
            for po,rel in sorted(set(txmbr.relatedto)):
                msg = "SKIPBROKEN:                   %s : %s" % (rel,po)
                self.verbose_logger.log(logginglevels.DEBUG_2, msg)
        self.verbose_logger.log(logginglevels.DEBUG_2,"SKIPBROKEN:%s" % (60 * "="))
                                    
    def _getPackagesToRemove(self,po,deptree,toRemove):
        '''
        get the (related) pos to remove.
        '''
        toRemove.add(po)
        for txmbr in self.tsInfo.getMembers(po.pkgtup):
            for pkg in (txmbr.updates + txmbr.obsoletes):
                toRemove.add(pkg)
                self._getDepsToRemove(pkg, deptree, toRemove)
            # Remove related packages    
            for (relative, relation) in txmbr.relatedto:
                toRemove.add(relative)
                self._getDepsToRemove(relative, deptree, toRemove)                
        self._getDepsToRemove(po, deptree, toRemove)

    def _getDepsToRemove(self,po, deptree, toRemove):
        for dep in deptree.get(po, []): # Loop trough all deps of po
            for txmbr in self.tsInfo.getMembers(dep.pkgtup):
                for pkg in (txmbr.updates + txmbr.obsoletes):
                    toRemove.add(pkg)
            toRemove.add(dep)
            self._getDepsToRemove(dep, deptree, toRemove)

    def _rpmdb_warn_checks(self, out=None, warn=True, chkcmd=None, header=None,
                           ignore_pkgs=[]):
        if out is None:
            out = self.logger.warning
        if chkcmd is None:
            chkcmd = ['dependencies', 'duplicates']
        if header is None:
            # FIXME: _N()
            msg = _("** Found %d pre-existing rpmdb problem(s),"
                    " 'yum check' output follows:")
            header = lambda problems: not problems or out(msg % problems)
        if warn:
            out(_('Warning: RPMDB altered outside of yum.'))

        if type(chkcmd) in (type([]), type(set())):
            chkcmd = set(chkcmd)
        else:
            chkcmd = set([chkcmd])

        ignore_pkgtups = set((pkg.pkgtup for pkg in ignore_pkgs))

        rc = 0
        probs = []
        if chkcmd.intersection(set(('all', 'dependencies'))):
            prob2ui = {'requires' : _('missing requires'),
                       'conflicts' : _('installed conflict')}
            for prob in self.rpmdb.check_dependencies():
                if prob.pkg.pkgtup in ignore_pkgtups:
                    continue
                if prob.problem == 'conflicts':
                    found = True # all the conflicting pkgs have to be ignored
                    for res in prob.conflicts:
                        if res.pkgtup not in ignore_pkgtups:
                            found = False
                            break
                    if found:
                        continue
                probs.append(prob)

        if chkcmd.intersection(set(('all', 'duplicates'))):
            iopkgs = set(self.conf.installonlypkgs)
            for prob in self.rpmdb.check_duplicates(iopkgs):
                if prob.pkg.pkgtup in ignore_pkgtups:
                    continue
                if prob.duplicate.pkgtup in ignore_pkgtups:
                    continue
                probs.append(prob)

        if chkcmd.intersection(set(('all', 'obsoleted'))):
            for prob in self.rpmdb.check_obsoleted():
                if prob.pkg.pkgtup in ignore_pkgtups:
                    continue
                if prob.obsoleter.pkgtup in ignore_pkgtups:
                    continue
                probs.append(prob)

        if chkcmd.intersection(set(('all', 'provides'))):
            for prob in self.rpmdb.check_provides():
                if prob.pkg.pkgtup in ignore_pkgtups:
                    continue
                probs.append(prob)

        header(len(probs))
        for prob in sorted(probs):
            out(prob)

        return probs

    def runTransaction(self, cb):
        """takes an rpm callback object, performs the transaction"""

        self.plugins.run('pretrans')

        #  We may want to put this other places, eventually, but for now it's
        # good as long as we get it right for history.
        for repo in self.repos.listEnabled():
            if repo._xml2sqlite_local:
                self.run_with_package_names.add('yum-metadata-parser')
                break

        if (not self.conf.history_record or
            self.ts.isTsFlagSet(rpm.RPMTRANS_FLAG_TEST)):
            frpmdbv = self.tsInfo.futureRpmDBVersion()
        else:
            using_pkgs_pats = list(self.run_with_package_names)
            using_pkgs = self.rpmdb.returnPackages(patterns=using_pkgs_pats)
            rpmdbv  = self.rpmdb.simpleVersion(main_only=True)[0]
            lastdbv = self.history.last()
            if lastdbv is not None:
                lastdbv = lastdbv.end_rpmdbversion
            rpmdb_problems = []
            if lastdbv is None or rpmdbv != lastdbv:
                txmbrs = self.tsInfo.getMembersWithState(None, TS_REMOVE_STATES)
                ignore_pkgs = [txmbr.po for txmbr in txmbrs]
                output_warn = lastdbv is not None
                rpmdb_problems = self._rpmdb_warn_checks(warn=output_warn,
                                                        ignore_pkgs=ignore_pkgs)
            cmdline = None
            if hasattr(self, 'args') and self.args:
                cmdline = ' '.join(self.args)
            elif hasattr(self, 'cmds') and self.cmds:
                cmdline = ' '.join(self.cmds)

            frpmdbv = self.tsInfo.futureRpmDBVersion()
            self.history.beg(rpmdbv, using_pkgs, list(self.tsInfo),
                             self.skipped_packages, rpmdb_problems, cmdline)
            # write out our config and repo data to additional history info
            self._store_config_in_history()
            if hasattr(self, '_shell_history_write'): # Only in cli...
                self._shell_history_write()
            
            self.plugins.run('historybegin')
        #  Just before we update the transaction, update what we think the
        # rpmdb will look like. This needs to be done before the run, so that if
        # "something" happens and the rpmdb is different from what we think it
        # will be we store what we thought, not what happened (so it'll be an
        # invalid cache).
        self.rpmdb.transactionResultVersion(frpmdbv)
        # transaction has started - all bets are off on our saved ts file
        if self._ts_save_file is not None:
            # write the saved transaction data to the addon location in history
            # so we can pull it back later if we need to
            savetx_msg = open(self._ts_save_file, 'r').read()
            self.history.write_addon_data('saved_tx', savetx_msg)

            try:
                os.unlink(self._ts_save_file)
            except (IOError, OSError), e:
                pass
        self._ts_save_file = None
        
        errors = self.ts.run(cb.callback, '')
        # ts.run() exit codes are, hmm, "creative": None means all ok, empty 
        # list means some errors happened in the transaction and non-empty 
        # list that there were errors preventing the ts from starting...
        
        # make resultobject - just a plain yumgenericholder object
        resultobject = misc.GenericHolder()
        resultobject.return_code = 0
        if errors is None:
            pass
        elif len(errors) == 0:
            errstring = _('Warning: scriptlet or other non-fatal errors occurred during transaction.')
            self.verbose_logger.debug(errstring)
            resultobject.return_code = 1
        else:
            if self.conf.history_record and not self.ts.isTsFlagSet(rpm.RPMTRANS_FLAG_TEST):
                herrors = [to_unicode(to_str(x)) for x in errors]
                self.plugins.run('historyend')                
                self.history.end(rpmdbv, 2, errors=herrors)

                
            self.logger.critical(_("Transaction couldn't start:"))
            for e in errors:
                self.logger.critical(e[0]) # should this be 'to_unicoded'?
            raise Errors.YumRPMTransError(msg=_("Could not run transaction."),
                                          errors=errors)

                          
        if (not self.conf.keepcache and
            not self.ts.isTsFlagSet(rpm.RPMTRANS_FLAG_TEST)):
            self.cleanUsedHeadersPackages()
        
        for i in ('ts_all_fn', 'ts_done_fn'):
            if hasattr(cb, i):
                fn = getattr(cb, i)
                try:
                    misc.unlink_f(fn)
                except (IOError, OSError), e:
                    self.logger.critical(_('Failed to remove transaction file %s') % fn)

        
        # drop out the rpm cache so we don't step on bad hdr indexes
        if (self.ts.isTsFlagSet(rpm.RPMTRANS_FLAG_TEST) or
            resultobject.return_code):
            self.rpmdb.dropCachedData()
        else:
            self.rpmdb.dropCachedDataPostTransaction(list(self.tsInfo))

        self.plugins.run('posttrans')
        # sync up what just happened versus what is in the rpmdb
        if not self.ts.isTsFlagSet(rpm.RPMTRANS_FLAG_TEST):
            self.verifyTransaction(resultobject)
        return resultobject

    def verifyTransaction(self, resultobject=None):
        """checks that the transaction did what we expected it to do. Also 
           propagates our external yumdb info"""
        
        # check to see that the rpmdb and the tsInfo roughly matches
        # push package object metadata outside of rpmdb into yumdb
        # delete old yumdb metadata entries
        
        # for each pkg in the tsInfo
        # if it is an install - see that the pkg is installed
        # if it is a remove - see that the pkg is no longer installed, provided
        #    that there is not also an install of this pkg in the tsInfo (reinstall)
        # for any kind of install add from_repo to the yumdb, and the cmdline
        # and the install reason
        
        vt_st = time.time()
        self.plugins.run('preverifytrans')
        for txmbr in self.tsInfo:
            if txmbr.output_state in TS_INSTALL_STATES:
                if not self.rpmdb.contains(po=txmbr.po):
                    # maybe a file log here, too
                    # but raising an exception is not going to do any good
                    self.logger.critical(_('%s was supposed to be installed' \
                                           ' but is not!' % txmbr.po))
                    # Note: Get Panu to do te.Failed() so we don't have to
                    txmbr.output_state = TS_FAILED
                    continue
                po = self.getInstalledPackageObject(txmbr.pkgtup)
                rpo = txmbr.po
                po.yumdb_info.from_repo = rpo.repoid
                po.yumdb_info.reason = txmbr.reason
                po.yumdb_info.releasever = self.conf.yumvar['releasever']
                if hasattr(self, 'args') and self.args:
                    po.yumdb_info.command_line = ' '.join(self.args)
                elif hasattr(self, 'cmds') and self.cmds:
                    po.yumdb_info.command_line = ' '.join(self.cmds)
                csum = rpo.returnIdSum()
                if csum is not None:
                    po.yumdb_info.checksum_type = str(csum[0])
                    po.yumdb_info.checksum_data = str(csum[1])

                if isinstance(rpo, YumLocalPackage):
                    try:
                        st = os.stat(rpo.localPkg())
                        lp_ctime = str(int(st.st_ctime))
                        lp_mtime = str(int(st.st_mtime))
                        po.yumdb_info.from_repo_revision  = lp_ctime
                        po.yumdb_info.from_repo_timestamp = lp_mtime
                    except: pass

                if rpo.xattr_origin_url is not None:
                    po.yumdb_info.origin_url = rpo.xattr_origin_url

                if hasattr(rpo.repo, 'repoXML'):
                    md = rpo.repo.repoXML
                    if md and md.revision is not None:
                        po.yumdb_info.from_repo_revision  = str(md.revision)
                    if md:
                        po.yumdb_info.from_repo_timestamp = str(md.timestamp)

                loginuid = misc.getloginuid()
                if txmbr.updates or txmbr.downgrades or txmbr.reinstall:
                    if txmbr.updates:
                        opo = txmbr.updates[0]
                    elif txmbr.downgrades:
                        opo = txmbr.downgrades[0]
                    else:
                        opo = po
                    if 'installed_by' in opo.yumdb_info:
                        po.yumdb_info.installed_by = opo.yumdb_info.installed_by
                    if loginuid is not None:
                        po.yumdb_info.changed_by = str(loginuid)
                elif loginuid is not None:
                    po.yumdb_info.installed_by = str(loginuid)

        # Remove old ones after installing new ones, so we can copy values.
        for txmbr in self.tsInfo:
            if txmbr.output_state in TS_INSTALL_STATES:
                pass
            elif txmbr.output_state in TS_REMOVE_STATES:
                if self.rpmdb.contains(po=txmbr.po):
                    if not self.tsInfo.getMembersWithState(pkgtup=txmbr.pkgtup,
                                output_states=TS_INSTALL_STATES):
                        # maybe a file log here, too
                        # but raising an exception is not going to do any good
                        # Note: This actually triggers atm. because we can't
                        #       always find the erased txmbr to set it when
                        #       we should.
                        self.logger.critical(_('%s was supposed to be removed' \
                                               ' but is not!' % txmbr.po))
                        # Note: Get Panu to do te.Failed() so we don't have to
                        txmbr.output_state = TS_FAILED
                        continue
                yumdb_item = self.rpmdb.yumdb.get_package(po=txmbr.po)
                yumdb_item.clean()
            else:
                self.verbose_logger.log(logginglevels.DEBUG_2, 'What is this? %s' % txmbr.po)

        self.plugins.run('postverifytrans')
        rpmdbv = self.rpmdb.simpleVersion(main_only=True)[0]
        if self.conf.history_record and not self.ts.isTsFlagSet(rpm.RPMTRANS_FLAG_TEST):
            ret = -1
            if resultobject is not None:
                ret = resultobject.return_code
            self.plugins.run('historyend')
            self.history.end(rpmdbv, ret)
        self.rpmdb.dropCachedData()
        self.verbose_logger.debug('VerifyTransaction time: %0.3f' % (time.time() - vt_st))

    def costExcludePackages(self):
        """ Create an excluder for repos. with higher cost. Eg.
            repo-A:cost=1 repo-B:cost=2 ... here we setup an excluder on repo-B
            that looks for pkgs in repo-B."""
        
        # if all the repo.costs are equal then don't bother running things
        costs = {}
        for r in self.repos.listEnabled():
            costs.setdefault(r.cost, []).append(r)

        if len(costs) <= 1:
            return

        done = False
        exid = "yum.costexcludes"
        orepos = []
        for cost in sorted(costs):
            if done: # Skip the first one, as they have lowest cost so are good.
                for repo in costs[cost]:
                    yce = _YumCostExclude(repo, self.repos)
                    repo.sack.addPackageExcluder(repo.id, exid,
                                                 'exclude.pkgtup.in', yce)
            orepos.extend(costs[cost])
            done = True

    def excludePackages(self, repo=None):
        """removes packages from packageSacks based on global exclude lists,
           command line excludes and per-repository excludes, takes optional 
           repo object to use."""

        if "all" in self.conf.disable_excludes:
            return
        
        # if not repo: then assume global excludes, only
        # if repo: then do only that repos' packages and excludes
        
        if not repo: # global only
            if "main" in self.conf.disable_excludes:
                return
            excludelist = self.conf.exclude
            repoid = None
            exid_beg = 'yum.excludepkgs'
        else:
            if repo.id in self.conf.disable_excludes:
                return
            excludelist = repo.getExcludePkgList()
            repoid = repo.id
            exid_beg = 'yum.excludepkgs.' + repoid

        count = 0
        for match in excludelist:
            count += 1
            exid = "%s.%u" % (exid_beg, count)
            self.pkgSack.addPackageExcluder(repoid, exid,'exclude.match', match)

    def includePackages(self, repo):
        """removes packages from packageSacks based on list of packages, to include.
           takes repoid as a mandatory argument."""
        
        includelist = repo.getIncludePkgList()
        
        if len(includelist) == 0:
            return
        
        # includepkgs actually means "exclude everything that doesn't match".
        #  So we mark everything, then wash those we want to keep and then
        # exclude everything that is marked.
        exid = "yum.includepkgs.1"
        self.pkgSack.addPackageExcluder(repo.id, exid, 'mark.washed')
        count = 0
        for match in includelist:
            count += 1
            exid = "%s.%u" % ("yum.includepkgs.2", count)
            self.pkgSack.addPackageExcluder(repo.id, exid, 'wash.match', match)
        exid = "yum.includepkgs.3"
        self.pkgSack.addPackageExcluder(repo.id, exid, 'exclude.marked')
        
    def doLock(self, lockfile = YUM_PID_FILE):
        """perform the yum locking, raise yum-based exceptions, not OSErrors"""
        
        if self.conf.uid != 0:
            #  If we are a user, assume we are using the root cache ... so don't
            # bother locking.
            if self.conf.cache:
                return
            root = self.conf.cachedir
            # Don't want <cachedir>/var/run/yum.pid ... just: <cachedir>/yum.pid
            lockfile = os.path.basename(lockfile)
        else:
            root = self.conf.installroot
        lockfile = root + '/' + lockfile # lock in the chroot
        lockfile = os.path.normpath(lockfile) # get rid of silly preceding extra /
        
        mypid=str(os.getpid())    
        while not self._lock(lockfile, mypid, 0644):
            try:
                fd = open(lockfile, 'r')
            except (IOError, OSError), e:
                msg = _("Could not open lock %s: %s") % (lockfile, e)
                raise Errors.LockError(errno.EPERM, msg)
                
            try: oldpid = int(fd.readline())
            except ValueError:
                # bogus data in the pid file. Throw away.
                self._unlock(lockfile)
            else:
                if oldpid == os.getpid(): # if we own the lock, we're fine
                    break
                try: os.kill(oldpid, 0)
                except OSError, e:
                    if e[0] == errno.ESRCH:
                        # The pid doesn't exist
                        self._unlock(lockfile)
                    else:
                        # Whoa. What the heck happened?
                        msg = _('Unable to check if PID %s is active') % oldpid
                        raise Errors.LockError(errno.EPERM, msg, oldpid)
                else:
                    # Another copy seems to be running.
                    msg = _('Existing lock %s: another copy is running as pid %s.') % (lockfile, oldpid)
                    raise Errors.LockError(0, msg, oldpid)
        # We've got the lock, store it so we can auto-unlock on __del__...
        self._lockfile = lockfile
    
    def doUnlock(self, lockfile=None):
        """do the unlock for yum"""
        
        # if we're not root then we don't lock - just return nicely
        #  Note that we can get here from __del__, so if we haven't created
        # YumBase.conf we don't want to do so here as creating stuff inside
        # __del__ is bad.
        if hasattr(self, 'preconf'):
            return

        #  Obviously, we can't lock random places as non-root, but we still want
        # to get rid of our lock file. Given we now have _lockfile I'm pretty
        # sure nothing should ever pass lockfile in here anyway.
        if self.conf.uid != 0:
            lockfile = None
        
        if lockfile is not None:
            root = self.conf.installroot
            lockfile = root + '/' + lockfile # lock in the chroot
        elif self._lockfile is None:
            return # Don't delete other people's lock files on __del__
        else:
            lockfile = self._lockfile # Get the value we locked with
        
        self._unlock(lockfile)
        self._lockfile = None
        
    def _lock(self, filename, contents='', mode=0777):
        lockdir = os.path.dirname(filename)
        try:
            if not os.path.exists(lockdir):
                os.makedirs(lockdir, mode=0755)
            fd = os.open(filename, os.O_EXCL|os.O_CREAT|os.O_WRONLY, mode)    
        except OSError, msg:
            if not msg.errno == errno.EEXIST: 
                # Whoa. What the heck happened?
                errmsg = _('Could not create lock at %s: %s ') % (filename, str(msg))
                raise Errors.LockError(msg.errno, errmsg, int(contents))
            return 0
        else:
            os.write(fd, contents)
            os.close(fd)
            return 1
    
    def _unlock(self, filename):
        misc.unlink_f(filename)

    def verifyPkg(self, fo, po, raiseError):
        """verifies the package is what we expect it to be
           raiseError  = defaults to 0 - if 1 then will raise
           a URLGrabError if the file does not check out.
           otherwise it returns false for a failure, true for success"""
        failed = False

        if type(fo) is types.InstanceType:
            fo = fo.filename
        
        if fo != po.localPkg():
            po.localpath = fo

        if not po.verifyLocalPkg():
            failed = True
        else:
            ylp = YumLocalPackage(self.rpmdb.readOnlyTS(), fo)
            if ylp.pkgtup != po.pkgtup:
                failed = True


        if failed:            
            # if the file is wrong AND it is >= what we expected then it
            # can't be redeemed. If we can, kill it and start over fresh
            cursize = os.stat(fo)[6]
            totsize = long(po.size)
            if cursize >= totsize and not po.repo.cache:
                # if the path to the file is NOT inside the cachedir then don't
                # unlink it b/c it is probably a file:// url and possibly
                # unlinkable
                if fo.startswith(po.repo.cachedir):
                    os.unlink(fo)

            if raiseError:
                msg = _('Package does not match intended download. Suggestion: run yum --enablerepo=%s clean metadata') %  po.repo.id 
                raise URLGrabError(-1, msg)
            else:
                return False

        
        return True
        
        
    def verifyChecksum(self, fo, checksumType, csum):
        """Verify the checksum of the file versus the 
           provided checksum"""

        try:
            filesum = misc.checksum(checksumType, fo)
        except Errors.MiscError, e:
            raise URLGrabError(-3, _('Could not perform checksum'))
            
        if filesum != csum:
            raise URLGrabError(-1, _('Package does not match checksum'))
        
        return 0

    def downloadPkgs(self, pkglist, callback=None, callback_total=None):
        def mediasort(apo, bpo):
            # FIXME: we should probably also use the mediaid; else we
            # could conceivably ping-pong between different disc1's
            a = apo.getDiscNum()
            b = bpo.getDiscNum()
            if a is None and b is None:
                return cmp(apo, bpo)
            if a is None:
                return -1
            if b is None:
                return 1
            if a < b:
                return -1
            elif a > b:
                return 1
            return 0
        
        """download list of package objects handed to you, output based on
           callback, raise yum.Errors.YumBaseError on problems"""

        errors = {}
        def adderror(po, msg):
            errors.setdefault(po, []).append(msg)

        #  We close the history DB here because some plugins (presto) use
        # threads. And sqlite really doesn't like threads. And while I don't
        # think it should matter, we've had some reports of history DB
        # corruption, and it was implied that it happened just after C-c
        # at download time and this is a safe thing to do.
        #  Note that manual testing shows that history is not connected by
        # this point, from the cli with no plugins. So this really does
        # nothing *sigh*.
        self.history.close()

        self.plugins.run('predownload', pkglist=pkglist)
        repo_cached = False
        remote_pkgs = []
        remote_size = 0
        for po in pkglist:
            if hasattr(po, 'pkgtype') and po.pkgtype == 'local':
                continue
                    
            local = po.localPkg()
            if os.path.exists(local):
                if not self.verifyPkg(local, po, False):
                    if po.repo.cache:
                        repo_cached = True
                        adderror(po, _('package fails checksum but caching is '
                            'enabled for %s') % po.repo.id)
                else:
                    self.verbose_logger.debug(_("using local copy of %s") %(po,))
                    continue
                        
            remote_pkgs.append(po)
            remote_size += po.size
            
            # caching is enabled and the package 
            # just failed to check out there's no 
            # way to save this, report the error and return
            if (self.conf.cache or repo_cached) and errors:
                return errors
                

        remote_pkgs.sort(mediasort)
        #  This is kind of a hack and does nothing in non-Fedora versions,
        # we'll fix it one way or anther soon.
        if (hasattr(urlgrabber.progress, 'text_meter_total_size') and
            len(remote_pkgs) > 1):
            urlgrabber.progress.text_meter_total_size(remote_size)
        beg_download = time.time()
        i = 0
        local_size = 0
        done_repos = set()
        for po in remote_pkgs:
            #  Recheck if the file is there, works around a couple of weird
            # edge cases.
            local = po.localPkg()
            i += 1
            if os.path.exists(local):
                if self.verifyPkg(local, po, False):
                    self.verbose_logger.debug(_("using local copy of %s") %(po,))
                    remote_size -= po.size
                    if hasattr(urlgrabber.progress, 'text_meter_total_size'):
                        urlgrabber.progress.text_meter_total_size(remote_size,
                                                                  local_size)
                    continue
                if os.path.getsize(local) >= po.size:
                    os.unlink(local)

            checkfunc = (self.verifyPkg, (po, 1), {})
            dirstat = os.statvfs(po.repo.pkgdir)
            if (dirstat.f_bavail * dirstat.f_bsize) <= long(po.size):
                adderror(po, _('Insufficient space in download directory %s\n'
                        "    * free   %s\n"
                        "    * needed %s") %
                         (po.repo.pkgdir,
                          format_number(dirstat.f_bavail * dirstat.f_bsize),
                          format_number(po.size)))
                continue
            
            try:
                if i == 1 and not local_size and remote_size == po.size:
                    text = os.path.basename(po.relativepath)
                else:
                    text = '(%s/%s): %s' % (i, len(remote_pkgs),
                                            os.path.basename(po.relativepath))
                mylocal = po.repo.getPackage(po,
                                   checkfunc=checkfunc,
                                   text=text,
                                   cache=po.repo.http_caching != 'none',
                                   )
                local_size += po.size
                if hasattr(urlgrabber.progress, 'text_meter_total_size'):
                    urlgrabber.progress.text_meter_total_size(remote_size,
                                                              local_size)
                if po.repoid not in done_repos:
                    #  Check a single package per. repo. ... to give a hint to
                    # the user on big downloads.
                    result, errmsg = self.sigCheckPkg(po)
                    if result != 0:
                        self.verbose_logger.warn("%s", errmsg)
                done_repos.add(po.repoid)

            except Errors.RepoError, e:
                adderror(po, str(e))
            else:
                po.localpath = mylocal
                if po in errors:
                    del errors[po]

        if hasattr(urlgrabber.progress, 'text_meter_total_size'):
            urlgrabber.progress.text_meter_total_size(0)
        if callback_total is not None and not errors:
            callback_total(remote_pkgs, remote_size, beg_download)

        self.plugins.run('postdownload', pkglist=pkglist, errors=errors)

        # Close curl object after we've downloaded everything.
        if hasattr(urlgrabber.grabber, 'reset_curl_obj'):
            urlgrabber.grabber.reset_curl_obj()

        return errors

    def verifyHeader(self, fo, po, raiseError):
        """check the header out via it's naevr, internally"""
        if type(fo) is types.InstanceType:
            fo = fo.filename
            
        try:
            hlist = rpm.readHeaderListFromFile(fo)
            hdr = hlist[0]
        except (rpm.error, IndexError):
            if raiseError:
                raise URLGrabError(-1, _('Header is not complete.'))
            else:
                return 0
                
        yip = YumInstalledPackage(hdr) # we're using YumInstalledPackage b/c
                                       # it takes headers <shrug>
        if yip.pkgtup != po.pkgtup:
            if raiseError:
                raise URLGrabError(-1, 'Header does not match intended download')
            else:
                return 0
        
        return 1
        
    def downloadHeader(self, po):
        """download a header from a package object.
           output based on callback, raise yum.Errors.YumBaseError on problems"""

        if hasattr(po, 'pkgtype') and po.pkgtype == 'local':
            return
                
        errors = {}
        local =  po.localHdr()
        repo = self.repos.getRepo(po.repoid)
        if os.path.exists(local):
            try:
                result = self.verifyHeader(local, po, raiseError=1)
            except URLGrabError, e:
                # might add a check for length of file - if it is < 
                # required doing a reget
                misc.unlink_f(local)
            else:
                po.hdrpath = local
                return
        else:
            if self.conf.cache:
                raise Errors.RepoError, \
                _('Header not in local cache and caching-only mode enabled. Cannot download %s') % po.hdrpath
        
        if self.dsCallback: self.dsCallback.downloadHeader(po.name)
        
        try:
            if not os.path.exists(repo.hdrdir):
                os.makedirs(repo.hdrdir)
            checkfunc = (self.verifyHeader, (po, 1), {})
            hdrpath = repo.getHeader(po, checkfunc=checkfunc,
                    cache=repo.http_caching != 'none',
                    )
        except Errors.RepoError, e:
            saved_repo_error = e
            try:
                misc.unlink_f(local)
            except OSError, e:
                raise Errors.RepoError, saved_repo_error
            else:
                raise Errors.RepoError, saved_repo_error
        else:
            po.hdrpath = hdrpath
            return

    def sigCheckPkg(self, po):
        '''
        Take a package object and attempt to verify GPG signature if required

        Returns (result, error_string) where result is:
            - 0 - GPG signature verifies ok or verification is not required.
            - 1 - GPG verification failed but installation of the right GPG key
                  might help.
            - 2 - Fatal GPG verification error, give up.
        '''
        if self._override_sigchecks:
            check = False
            hasgpgkey = 0
        elif hasattr(po, 'pkgtype') and po.pkgtype == 'local':
            check = self.conf.localpkg_gpgcheck
            hasgpgkey = 0
        else:
            repo = self.repos.getRepo(po.repoid)
            check = repo.gpgcheck
            hasgpgkey = not not repo.gpgkey 
        
        if check:
            ts = self.rpmdb.readOnlyTS()
            sigresult = rpmUtils.miscutils.checkSig(ts, po.localPkg())
            localfn = os.path.basename(po.localPkg())
            
            if sigresult == 0:
                result = 0
                msg = ''

            elif sigresult == 1:
                if hasgpgkey:
                    result = 1
                else:
                    result = 2
                msg = _('Public key for %s is not installed') % localfn

            elif sigresult == 2:
                result = 2
                msg = _('Problem opening package %s') % localfn

            elif sigresult == 3:
                if hasgpgkey:
                    result = 1
                else:
                    result = 2
                result = 1
                msg = _('Public key for %s is not trusted') % localfn

            elif sigresult == 4:
                result = 2 
                msg = _('Package %s is not signed') % localfn
            
        else:
            result =0
            msg = ''

        return result, msg

    def cleanUsedHeadersPackages(self):
        filelist = []
        for txmbr in self.tsInfo:
            if txmbr.po.state not in TS_INSTALL_STATES:
                continue
            if txmbr.po.repoid == "installed":
                continue
            if txmbr.po.repoid not in self.repos.repos:
                continue
            
            # make sure it's not a local file
            repo = self.repos.repos[txmbr.po.repoid]
            local = False
            for u in repo.baseurl:
                if u.startswith("file:"):
                    local = True
                    break
                
            if local:
                filelist.extend([txmbr.po.localHdr()])
            else:
                txmbr.po.xattr_origin_url # Load this, before we rm the file.
                filelist.extend([txmbr.po.localPkg(), txmbr.po.localHdr()])

        # now remove them
        for fn in filelist:
            if not os.path.exists(fn):
                continue
            try:
                misc.unlink_f(fn)
            except OSError, e:
                self.logger.warning(_('Cannot remove %s'), fn)
                continue
            else:
                self.verbose_logger.log(logginglevels.DEBUG_4,
                    _('%s removed'), fn)
        
    def cleanHeaders(self):
        exts = ['hdr']
        return self._cleanFiles(exts, 'hdrdir', 'header')

    def cleanPackages(self):
        exts = ['rpm']
        return self._cleanFiles(exts, 'pkgdir', 'package')

    def cleanSqlite(self):
        exts = ['sqlite', 'sqlite.bz2', 'sqlite-journal']
        return self._cleanFiles(exts, 'cachedir', 'sqlite')

    def cleanMetadata(self):
        exts = ['xml.gz', 'xml', 'cachecookie', 'mirrorlist.txt', 'asc']
        # Metalink is also here, but is a *.xml file
        return self._cleanFiles(exts, 'cachedir', 'metadata') 

    def cleanExpireCache(self):
        exts = ['cachecookie', 'mirrorlist.txt']
        return self._cleanFiles(exts, 'cachedir', 'metadata')

    def cleanRpmDB(self):
        cachedir = self.conf.persistdir + "/rpmdb-indexes/"
        if not os.path.exists(cachedir):
            filelist = []
        else:
            filelist = misc.getFileList(cachedir, '', [])
        return self._cleanFilelist('rpmdb', filelist)

    def _cleanFiles(self, exts, pathattr, filetype):
        filelist = []
        for ext in exts:
            for repo in self.repos.listEnabled():
                path = getattr(repo, pathattr)
                if os.path.exists(path) and os.path.isdir(path):
                    filelist = misc.getFileList(path, ext, filelist)
        return self._cleanFilelist(filetype, filelist)

    def _cleanFilelist(self, filetype, filelist):
        removed = 0
        for item in filelist:
            try:
                misc.unlink_f(item)
            except OSError, e:
                self.logger.critical(_('Cannot remove %s file %s'), filetype, item)
                continue
            else:
                self.verbose_logger.log(logginglevels.DEBUG_4,
                    _('%s file %s removed'), filetype, item)
                removed+=1
        msg = P_('%d %s file removed', '%d %s files removed', removed) % (removed, filetype)
        return 0, [msg]

    def doPackageLists(self, pkgnarrow='all', patterns=None, showdups=None,
                       ignore_case=False):
        """generates lists of packages, un-reduced, based on pkgnarrow option"""

        if showdups is None:
            showdups = self.conf.showdupesfromrepos
        ygh = misc.GenericHolder(iter=pkgnarrow)
        
        installed = []
        available = []
        reinstall_available = []
        old_available = []
        updates = []
        obsoletes = []
        obsoletesTuples = []
        recent = []
        extras = []

        ic = ignore_case
        # list all packages - those installed and available, don't 'think about it'
        if pkgnarrow == 'all': 
            dinst = {}
            ndinst = {} # Newest versions by name.arch
            for po in self.rpmdb.returnPackages(patterns=patterns,
                                                ignore_case=ic):
                dinst[po.pkgtup] = po
                if showdups:
                    continue
                key = (po.name, po.arch)
                if key not in ndinst or po.verGT(ndinst[key]):
                    ndinst[key] = po
            installed = dinst.values()
                        
            if showdups:
                avail = self.pkgSack.returnPackages(patterns=patterns,
                                                    ignore_case=ic)
            else:
                try:
                    avail = self.pkgSack.returnNewestByNameArch(patterns=patterns,
                                                              ignore_case=ic)
                except Errors.PackageSackError:
                    avail = []
            
            for pkg in avail:
                if showdups:
                    if pkg.pkgtup in dinst:
                        reinstall_available.append(pkg)
                    else:
                        available.append(pkg)
                else:
                    key = (pkg.name, pkg.arch)
                    if pkg.pkgtup in dinst:
                        reinstall_available.append(pkg)
                    elif key not in ndinst or pkg.verGT(ndinst[key]):
                        available.append(pkg)
                    else:
                        old_available.append(pkg)

        # produce the updates list of tuples
        elif pkgnarrow == 'updates':
            for (n,a,e,v,r) in self.up.getUpdatesList():
                matches = self.pkgSack.searchNevra(name=n, arch=a, epoch=e, 
                                                   ver=v, rel=r)
                if len(matches) > 1:
                    updates.append(matches[0])
                    self.verbose_logger.log(logginglevels.DEBUG_1,
                        _('More than one identical match in sack for %s'), 
                        matches[0])
                elif len(matches) == 1:
                    updates.append(matches[0])
                else:
                    self.verbose_logger.log(logginglevels.DEBUG_1,
                        _('Nothing matches %s.%s %s:%s-%s from update'), n,a,e,v,r)
            if patterns:
                exactmatch, matched, unmatched = \
                   parsePackages(updates, patterns, casematch=not ignore_case)
                updates = exactmatch + matched

        # installed only
        elif pkgnarrow == 'installed':
            installed = self.rpmdb.returnPackages(patterns=patterns,
                                                  ignore_case=ic)
        
        # available in a repository
        elif pkgnarrow == 'available':

            if showdups:
                avail = self.pkgSack.returnPackages(patterns=patterns,
                                                    ignore_case=ic)
            else:
                try:
                    avail = self.pkgSack.returnNewestByNameArch(patterns=patterns,
                                                              ignore_case=ic)
                except Errors.PackageSackError:
                    avail = []
            
            for pkg in avail:
                if showdups:
                    if self.rpmdb.contains(po=pkg):
                        reinstall_available.append(pkg)
                    else:
                        available.append(pkg)
                else:
                    ipkgs = self.rpmdb.searchNevra(pkg.name, arch=pkg.arch)
                    if ipkgs:
                        latest = sorted(ipkgs, reverse=True)[0]
                    if not ipkgs or pkg.verGT(latest):
                        available.append(pkg)
                    elif pkg.verEQ(latest):
                        reinstall_available.append(pkg)
                    else:
                        old_available.append(pkg)

        # not in a repo but installed
        elif pkgnarrow == 'extras':
            # we must compare the installed set versus the repo set
            # anything installed but not in a repo is an extra
            avail = self.pkgSack.simplePkgList(patterns=patterns,
                                               ignore_case=ic)
            avail = set(avail)
            for po in self.rpmdb.returnPackages(patterns=patterns,
                                                ignore_case=ic):
                if po.pkgtup not in avail:
                    extras.append(po)

        # obsoleting packages (and what they obsolete)
        elif pkgnarrow == 'obsoletes':
            self.conf.obsoletes = 1

            for (pkgtup, instTup) in self.up.getObsoletesTuples():
                (n,a,e,v,r) = pkgtup
                pkgs = self.pkgSack.searchNevra(name=n, arch=a, ver=v, rel=r, epoch=e)
                instpo = self.getInstalledPackageObject(instTup)
                for po in pkgs:
                    obsoletes.append(po)
                    obsoletesTuples.append((po, instpo))
            if patterns:
                exactmatch, matched, unmatched = \
                   parsePackages(obsoletes, patterns, casematch=not ignore_case)
                obsoletes = exactmatch + matched
                matched_obsoletes = set(obsoletes)
                nobsoletesTuples = []
                for po, instpo in obsoletesTuples:
                    if po not in matched_obsoletes:
                        continue
                    nobsoletesTuples.append((po, instpo))
                obsoletesTuples = nobsoletesTuples
            if not showdups:
                obsoletes = packagesNewestByName(obsoletes)
                filt = set(obsoletes)
                nobsoletesTuples = []
                for po, instpo in obsoletesTuples:
                    if po not in filt:
                        continue
                    nobsoletesTuples.append((po, instpo))
                obsoletesTuples = nobsoletesTuples
        
        # packages recently added to the repositories
        elif pkgnarrow == 'recent':
            now = time.time()
            recentlimit = now-(self.conf.recent*86400)
            if showdups:
                avail = self.pkgSack.returnPackages(patterns=patterns,
                                                    ignore_case=ic)
            else:
                try:
                    avail = self.pkgSack.returnNewestByNameArch(patterns=patterns,
                                                              ignore_case=ic)
                except Errors.PackageSackError:
                    avail = []
            
            for po in avail:
                if int(po.filetime) > recentlimit:
                    recent.append(po)
        
        
        ygh.installed = installed
        ygh.available = available
        ygh.reinstall_available = reinstall_available
        ygh.old_available = old_available
        ygh.updates = updates
        ygh.obsoletes = obsoletes
        ygh.obsoletesTuples = obsoletesTuples
        ygh.recent = recent
        ygh.extras = extras

        return ygh


        
    def findDeps(self, pkgs):
        """
        Return the dependencies for a given package object list, as well
        possible solutions for those dependencies.
           
        Returns the deps as a dict of dicts::
            packageobject = [reqs] = [list of satisfying pkgs]
        """
        
        results = {}

        for pkg in pkgs:
            results[pkg] = {} 
            reqs = pkg.requires
            reqs.sort()
            pkgresults = results[pkg] # shorthand so we don't have to do the
                                      # double bracket thing
            
            for req in reqs:
                (r,f,v) = req
                if r.startswith('rpmlib('):
                    continue
                
                satisfiers = []

                for po in self.whatProvides(r, f, v):
                    satisfiers.append(po)

                pkgresults[req] = satisfiers
        
        return results
    
    # pre 3.2.10 API used to always showdups, so that's the default atm.
    def searchGenerator(self, fields, criteria, showdups=True, keys=False, 
                                             searchtags=True, searchrpmdb=True):
        """Generator method to lighten memory load for some searches.
           This is the preferred search function to use. Setting keys to True
           will use the search keys that matched in the sorting, and return
           the search keys in the results. """
        sql_fields = []
        for f in fields:
            sql_fields.append(RPM_TO_SQLITE.get(f, f))

        # yield the results in order of most terms matched first
        sorted_lists = {} # count_of_matches = [(pkgobj, 
                          #                     [search strings which matched], 
                          #                     [results that matched])]
        tmpres = []
        real_crit = []
        real_crit_lower = [] # Take the s.lower()'s out of the loop
        rcl2c = {}
        # weigh terms in given order (earlier = more relevant)
        critweight = 0
        critweights = {}
        for s in criteria:
            real_crit.append(s)
            real_crit_lower.append(s.lower())
            rcl2c[s.lower()] = s
            critweights.setdefault(s, critweight)
            critweight -= 1

        for sack in self.pkgSack.sacks.values():
            tmpres.extend(sack.searchPrimaryFieldsMultipleStrings(sql_fields, real_crit))

        def results2sorted_lists(tmpres, sorted_lists):
            for (po, count) in tmpres:
                # check the pkg for sanity
                # pop it into the sorted lists
                tmpkeys   = set()
                tmpvalues = []
                if count not in sorted_lists: sorted_lists[count] = []
                for s in real_crit_lower:
                    for field in fields:
                        value = to_unicode(getattr(po, field))
                        if value and value.lower().find(s) != -1:
                            tmpvalues.append(value)
                            tmpkeys.add(rcl2c[s])

                if len(tmpvalues) > 0:
                    sorted_lists[count].append((po, tmpkeys, tmpvalues))

        results2sorted_lists(tmpres, sorted_lists)

        if searchrpmdb:
            tmpres = self.rpmdb.searchPrimaryFieldsMultipleStrings(fields,
                                                                   real_crit_lower,
                                                                   lowered=True)
            # close our rpmdb connection so we can ctrl-c, kthxbai
            self.closeRpmDB()

            results2sorted_lists(tmpres, sorted_lists)
            del tmpres

        results_by_pkg = {} # pkg=[list_of_tuples_of_values]
        if searchtags:
            tmpres = self.searchPackageTags(real_crit_lower)
            
            
            for pkg in tmpres:
                count = 0
                matchkeys = []
                tagresults = []
                for (match, taglist) in tmpres[pkg]:
                    count += len(taglist)
                    matchkeys.append(rcl2c[match])
                    tagresults.extend(taglist)
                    if pkg not in results_by_pkg:
                        results_by_pkg[pkg] = []
                    results_by_pkg[pkg].append((matchkeys, tagresults))

            del tmpres

        if sorted_lists.values():
            # do the ones we already have
            for item in sorted_lists.values():
                for pkg, k, v in item:
                    if pkg not in results_by_pkg:
                        results_by_pkg[pkg] = []
                    results_by_pkg[pkg].append((k,v))

        # take our existing dict-by-pkg and make the dict-by-count for 
        # this bizarro sorted_lists format
        # FIXME - stab sorted_lists in the chest at some later date
        sorted_lists = {}
        for pkg in results_by_pkg:
            totkeys = []
            totvals = []
            for (k, v) in results_by_pkg[pkg]:
                totkeys.extend(k)
                totvals.extend(v)
            
            totkeys = misc.unique(totkeys)
            totvals = misc.unique(totvals)
            count = len(totkeys)
            if count not in sorted_lists:
                sorted_lists[count] = []
            sorted_lists[count].append((pkg, totkeys, totvals))

        #  To explain why the following code looks like someone took drugs
        # before/during/after coding:
        #
        # We are sorting a list of: (po, tmpkeys, tmpvalues).
        #                  Eg.      (po, ['foo', 'bar'], ['matches foo',
        #                                                 'matches barx'])
        #
        # So we sort, and get a result like:
        #        po    | repo | matching value
        #     1. yum-1 |  fed | -2
        #     2. yum-2 |  fed | -2 
        #     3. yum-2 | @fed | -2
        #     4. yum-3 |  ups | -1
        # ...but without showdups we want to output _just_ #3, which requires
        # we find the newest EVR po for the best "matching value". Without keys
        # it's the same, except we just want the newest EVR.
        #  If we screw it up it's probably not even noticable most of the time
        # either, so it's pretty thankless. HTH. HAND.
        # By default just sort using package sorting
        sort_func = operator.itemgetter(0)
        dup = lambda x: True
        if keys:
            # Take into account the keys found, their original order,
            # and number of fields hit as well
            sort_func = lambda x: (-sum((critweights[y] for y in x[1])),
                                   -len(x[2]), "\0".join(sorted(x[1])), x[0])
            dup = lambda x,y: sort_func(x)[:-1] == sort_func(y)[:-1]
        yielded = {}
        for val in reversed(sorted(sorted_lists)):
            last = None
            for sl_vals in sorted(sorted_lists[val], key=sort_func):
                if showdups:
                    (po, ks, vs) = sl_vals
                else:
                    if (sl_vals[0].name, sl_vals[0].arch) in yielded:
                        continue

                    na = (sl_vals[0].name, sl_vals[0].arch)
                    if last is None or (last[0] == na and dup(last[1],sl_vals)):
                        last = (na, sl_vals)
                        continue

                    (po, ks, vs) = last[1]
                    if last[0] == na: # Dito. yielded test above.
                        last = None
                    else:
                        last = (na, sl_vals)

                if keys:
                    yield (po, ks, vs)
                else:
                    yield (po, vs)

                if not showdups:
                    yielded[(po.name, po.arch)] = 1
            if last is not None:
                (po, ks, vs) = last[1]
                if keys:
                    yield (po, ks, vs)
                else:
                    yield (po, vs)

    def searchPackageTags(self, criteria):
        results = {} # name = [(criteria, taglist)]
        for c in criteria:
            c = c.lower()
            res = self.pkgtags.search_tags(c)
            for (name, taglist) in res.items():
                pkgs = self.pkgSack.searchNevra(name=name)
                if not pkgs:
                    continue
                pkg = pkgs[0]
                if pkg not in results:
                    results[pkg] = []
                results[pkg].append((c, taglist))
        
        return results
        
    def searchPackages(self, fields, criteria, callback=None):
        """Search specified fields for matches to criteria
           optional callback specified to print out results
           as you go. Callback is a simple function of:
           callback(po, matched values list). It will 
           just return a dict of dict[po]=matched values list"""
        warnings.warn(_('searchPackages() will go away in a future version of Yum.\
                      Use searchGenerator() instead. \n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)           
        matches = {}
        match_gen = self.searchGenerator(fields, criteria)
        
        for (po, matched_strings) in match_gen:
            if callback:
                callback(po, matched_strings)
            if po not in matches:
                matches[po] = []
            
            matches[po].extend(matched_strings)
        
        return matches
    
    def searchPackageProvides(self, args, callback=None,
                              callback_has_matchfor=False):
        def _arg_data(arg):
            if not misc.re_glob(arg):
                isglob = False
                if arg[0] != '/':
                    canBeFile = False
                else:
                    canBeFile = True
            else:
                isglob = True
                canBeFile = misc.re_filename(arg)

            return isglob, canBeFile

        matches = {}
        for arg in args:
            arg = to_unicode(arg)
            isglob, canBeFile = _arg_data(arg)

            if not isglob:
                usedDepString = True
                where = self.returnPackagesByDep(arg)
            else:
                usedDepString = False
                where = self.pkgSack.searchAll(arg, False)
            self.verbose_logger.log(logginglevels.DEBUG_1,
               P_('Searching %d package', 'Searching %d packages', len(where)), len(where))
            
            for po in sorted(where):
                self.verbose_logger.log(logginglevels.DEBUG_2,
                    _('searching package %s'), po)
                tmpvalues = []
                
                if usedDepString:
                    tmpvalues.append(arg)

                if not isglob and canBeFile:
                    # then it is not a globbed file we have matched it precisely
                    tmpvalues.append(arg)
                    
                if isglob and canBeFile:
                    self.verbose_logger.log(logginglevels.DEBUG_2,
                        _('searching in file entries'))
                    for thisfile in po.dirlist + po.filelist + po.ghostlist:
                        if fnmatch.fnmatch(thisfile, arg):
                            tmpvalues.append(thisfile)
                

                self.verbose_logger.log(logginglevels.DEBUG_2,
                    _('searching in provides entries'))
                for (p_name, p_flag, (p_e, p_v, p_r)) in po.provides:
                    prov = misc.prco_tuple_to_string((p_name, p_flag, (p_e, p_v, p_r)))
                    if not usedDepString:
                        if fnmatch.fnmatch(p_name, arg) or fnmatch.fnmatch(prov, arg):
                            tmpvalues.append(prov)

                if len(tmpvalues) > 0:
                    if callback: # No matchfor, on globs
                        if not isglob and callback_has_matchfor:
                            callback(po, tmpvalues, args)
                        else:
                            callback(po, tmpvalues)
                    matches[po] = tmpvalues
        
        # installed rpms, too
        taglist = ['filelist', 'dirnames', 'provides_names']
        taglist_provonly = ['provides_names']
        for arg in args:
            isglob, canBeFile = _arg_data(arg)
            
            if not isglob:
                where = self.returnInstalledPackagesByDep(arg)
                usedDepString = True
                for po in where:
                    tmpvalues = [arg]

                    if len(tmpvalues) > 0:
                        if callback:
                            if callback_has_matchfor:
                                callback(po, tmpvalues, args)
                            else:
                                callback(po, tmpvalues)
                        matches[po] = tmpvalues

            else:
                usedDepString = False
                where = self.rpmdb

                if canBeFile:
                    arg_taglist = taglist
                else:
                    arg_taglist = taglist_provonly

                arg_regex = re.compile(fnmatch.translate(arg))
                for po in sorted(where):
                    searchlist = []
                    tmpvalues = []
                    for tag in arg_taglist:
                        tagdata = getattr(po, tag)
                        if tagdata is None:
                            continue
                        if type(tagdata) is types.ListType:
                            searchlist.extend(tagdata)
                        else:
                            searchlist.append(tagdata)
                    
                    for item in searchlist:
                        if arg_regex.match(item):
                            tmpvalues.append(item)
                
                    if len(tmpvalues) > 0:
                        if callback: # No matchfor, on globs
                            callback(po, tmpvalues)
                        matches[po] = tmpvalues
            
            
        return matches

    def doGroupLists(self, uservisible=0, patterns=None, ignore_case=True):
        """returns two lists of groups, installed groups and available groups
           optional 'uservisible' bool to tell it whether or not to return
           only groups marked as uservisible"""
        
        
        installed = []
        available = []

        if self.comps.compscount == 0:
            raise Errors.GroupsError, _('No group data available for configured repositories')
        
        if patterns is None:
            grps = self.comps.groups
        else:
            grps = self.comps.return_groups(",".join(patterns),
                                            case_sensitive=not ignore_case)
        for grp in grps:
            if grp.installed:
                if uservisible:
                    if grp.user_visible:
                        installed.append(grp)
                else:
                    installed.append(grp)
            else:
                if uservisible:
                    if grp.user_visible:
                        available.append(grp)
                else:
                    available.append(grp)
            
        return sorted(installed), sorted(available)
    
    
    def groupRemove(self, grpid):
        """mark all the packages in this group to be removed"""
        
        txmbrs_used = []
        
        thesegroups = self.comps.return_groups(grpid)
        if not thesegroups:
            raise Errors.GroupsError, _("No Group named %s exists") % to_unicode(grpid)

        for thisgroup in thesegroups:
            thisgroup.toremove = True
            pkgs = thisgroup.packages
            for pkg in thisgroup.packages:
                txmbrs = self.remove(name=pkg, silence_warnings=True)
                txmbrs_used.extend(txmbrs)
                for txmbr in txmbrs:
                    txmbr.groups.append(thisgroup.groupid)
            
        return txmbrs_used

    def groupUnremove(self, grpid):
        """unmark any packages in the group from being removed"""
        

        thesegroups = self.comps.return_groups(grpid)
        if not thesegroups:
            raise Errors.GroupsError, _("No Group named %s exists") % to_unicode(grpid)

        for thisgroup in thesegroups:
            thisgroup.toremove = False
            pkgs = thisgroup.packages
            for pkg in thisgroup.packages:
                for txmbr in self.tsInfo:
                    if txmbr.po.name == pkg and txmbr.po.state in TS_INSTALL_STATES:
                        try:
                            txmbr.groups.remove(grpid)
                        except ValueError:
                            self.verbose_logger.log(logginglevels.DEBUG_1,
                               _("package %s was not marked in group %s"), txmbr.po,
                                grpid)
                            continue
                        
                        # if there aren't any other groups mentioned then remove the pkg
                        if len(txmbr.groups) == 0:
                            self.tsInfo.remove(txmbr.po.pkgtup)
        
        
    def selectGroup(self, grpid, group_package_types=[], enable_group_conditionals=None):
        """mark all the packages in the group to be installed
           returns a list of transaction members it added to the transaction 
           set
           Optionally take:
           group_package_types=List - overrides self.conf.group_package_types
           enable_group_conditionals=Bool - overrides self.conf.enable_group_conditionals
        """

        if not self.comps.has_group(grpid):
            raise Errors.GroupsError, _("No Group named %s exists") % to_unicode(grpid)
        
        txmbrs_used = []
        thesegroups = self.comps.return_groups(grpid)
     
        if not thesegroups:
            raise Errors.GroupsError, _("No Group named %s exists") % to_unicode(grpid)

        package_types = self.conf.group_package_types
        if group_package_types:
            package_types = group_package_types

        for thisgroup in thesegroups:
            if thisgroup.selected:
                continue
            
            thisgroup.selected = True
            
            pkgs = []
            if 'mandatory' in package_types:
                pkgs.extend(thisgroup.mandatory_packages)
            if 'default' in package_types:
                pkgs.extend(thisgroup.default_packages)
            if 'optional' in package_types:
                pkgs.extend(thisgroup.optional_packages)

            old_txmbrs = len(txmbrs_used)
            for pkg in pkgs:
                self.verbose_logger.log(logginglevels.DEBUG_2,
                    _('Adding package %s from group %s'), pkg, thisgroup.groupid)
                try:
                    txmbrs = self.install(name = pkg)
                except Errors.InstallError, e:
                    self.verbose_logger.debug(_('No package named %s available to be installed'),
                        pkg)
                else:
                    txmbrs_used.extend(txmbrs)
                    for txmbr in txmbrs:
                        txmbr.groups.append(thisgroup.groupid)
            
            group_conditionals = self.conf.enable_group_conditionals
            if enable_group_conditionals is not None: # has to be this way so we can set it to False
                group_conditionals = enable_group_conditionals

            count_cond_test = 0
            if group_conditionals:
                for condreq, cond in thisgroup.conditional_packages.iteritems():
                    if self.isPackageInstalled(cond):
                        try:
                            txmbrs = self.install(name = condreq)
                        except Errors.InstallError:
                            # we don't care if the package doesn't exist
                            continue
                        else:
                            if cond not in self.tsInfo.conditionals:
                                self.tsInfo.conditionals[cond]=[]

                        txmbrs_used.extend(txmbrs)
                        for txmbr in txmbrs:
                            txmbr.groups.append(thisgroup.groupid)
                            self.tsInfo.conditionals[cond].append(txmbr.po)
                        continue
                    # Otherwise we hook into tsInfo.add to make sure
                    # we'll catch it if it's added later in this transaction
                    pkgs = self.pkgSack.searchNevra(name=condreq)
                    if pkgs:
                        if self.arch.multilib:
                            if self.conf.multilib_policy == 'best':
                                use = []
                                best = self.arch.legit_multi_arches
                                best.append('noarch')
                                for pkg in pkgs:
                                    if pkg.arch in best:
                                        use.append(pkg)
                                pkgs = use
                               
                        pkgs = packagesNewestByName(pkgs)
                        count_cond_test += len(pkgs)

                        if cond not in self.tsInfo.conditionals:
                            self.tsInfo.conditionals[cond] = []
                        self.tsInfo.conditionals[cond].extend(pkgs)
            if len(txmbrs_used) == old_txmbrs:
                self.logger.critical(_('Warning: Group %s does not have any packages.'), thisgroup.groupid)
                if count_cond_test:
                    self.logger.critical(_('Group %s does have %u conditional packages, which may get installed.'), count_cond_test)
        return txmbrs_used

    def deselectGroup(self, grpid, force=False):
        """ Without the force option set, this removes packages from being
            installed that were added as part of installing one of the
            group(s). If the force option is set, then all installing packages
            in the group(s) are force removed from the transaction. """
        
        if not self.comps.has_group(grpid):
            raise Errors.GroupsError, _("No Group named %s exists") % to_unicode(grpid)
            
        thesegroups = self.comps.return_groups(grpid)
        if not thesegroups:
            raise Errors.GroupsError, _("No Group named %s exists") % to_unicode(grpid)
        
        for thisgroup in thesegroups:
            thisgroup.selected = False
            
            for pkgname in thisgroup.packages:
                txmbrs = self.tsInfo.getMembersWithState(None,TS_INSTALL_STATES)
                for txmbr in txmbrs:
                    if txmbr.po.name != pkgname:
                        continue

                    if not force:
                        try: 
                            txmbr.groups.remove(grpid)
                        except ValueError:
                            self.verbose_logger.log(logginglevels.DEBUG_1,
                               _("package %s was not marked in group %s"), txmbr.po,
                                grpid)
                            continue
                        
                    # If the pkg isn't part of any group, or the group is
                    # being forced out ... then remove the pkg
                    if force or len(txmbr.groups) == 0:
                        self.tsInfo.remove(txmbr.po.pkgtup)
                        for pkg in self.tsInfo.conditionals.get(txmbr.name, []):
                            self.tsInfo.remove(pkg.pkgtup)
        
    def getPackageObject(self, pkgtup, allow_missing=False):
        """retrieves a packageObject from a pkgtuple - if we need
           to pick and choose which one is best we better call out
           to some method from here to pick the best pkgobj if there are
           more than one response - right now it's more rudimentary."""
           
        
        # look it up in the self.localPackages first:
        for po in self.localPackages:
            if po.pkgtup == pkgtup:
                return po
                
        pkgs = self.pkgSack.searchPkgTuple(pkgtup)

        if len(pkgs) == 0:
            self._add_not_found_a(pkgs, pkgtup)
            if allow_missing: #  This can happen due to excludes after .up has
                return None   # happened.
            raise Errors.DepError, _('Package tuple %s could not be found in packagesack') % str(pkgtup)
            
        if len(pkgs) > 1: # boy it'd be nice to do something smarter here FIXME
            result = pkgs[0]
        else:
            result = pkgs[0] # which should be the only
        
            # this is where we could do something to figure out which repository
            # is the best one to pull from
        
        return result

    def getInstalledPackageObject(self, pkgtup):
        """ Returns a YumInstalledPackage object for the pkgtup specified, or
            raises an exception. You should use this instead of
            searchPkgTuple() if you are assuming there is a value. """

        pkgs = self.rpmdb.searchPkgTuple(pkgtup)
        if len(pkgs) == 0:
            self._add_not_found_i(pkgs, pkgtup)
            raise Errors.RpmDBError, _('Package tuple %s could not be found in rpmdb') % str(pkgtup)

        # Dito. FIXME from getPackageObject() for len() > 1 ... :)
        po = pkgs[0] # take the first one
        return po
        
    def gpgKeyCheck(self):
        """checks for the presence of gpg keys in the rpmdb
           returns 0 if no keys returns 1 if keys"""

        gpgkeyschecked = self.conf.cachedir + '/.gpgkeyschecked.yum'
        if os.path.exists(gpgkeyschecked):
            return 1
            
        myts = rpmUtils.transaction.initReadOnlyTransaction(root=self.conf.installroot)
        myts.pushVSFlags(~(rpm._RPMVSF_NOSIGNATURES|rpm._RPMVSF_NODIGESTS))
        idx = myts.dbMatch('name', 'gpg-pubkey')
        keys = idx.count()
        del idx
        del myts
        
        if keys == 0:
            return 0
        else:
            mydir = os.path.dirname(gpgkeyschecked)
            if not os.path.exists(mydir):
                os.makedirs(mydir)
                
            fo = open(gpgkeyschecked, 'w')
            fo.close()
            del fo
            return 1

    def returnPackagesByDep(self, depstring):
        """Pass in a generic [build]require string and this function will 
           pass back the packages it finds providing that dep."""

        if not depstring:
            return []

        # parse the string out
        #  either it is 'dep (some operator) e:v-r'
        #  or /file/dep
        #  or packagename
        if type(depstring) == types.TupleType:
            (depname, depflags, depver) = depstring
        else:
            depname = depstring
            depflags = None
            depver = None

            if depstring[0] != '/':
                # not a file dep - look at it for being versioned
                dep_split = depstring.split()
                if len(dep_split) == 3:
                    depname, flagsymbol, depver = dep_split
                    if not flagsymbol in SYMBOLFLAGS:
                        raise Errors.YumBaseError, _('Invalid version flag from: %s') % str(depstring)
                    depflags = SYMBOLFLAGS[flagsymbol]

        return self.pkgSack.getProvides(depname, depflags, depver).keys()

    def returnPackageByDep(self, depstring):
        """Pass in a generic [build]require string and this function will 
           pass back the best(or first) package it finds providing that dep."""
        
        # we get all sorts of randomness here
        errstring = depstring
        if type(depstring) not in types.StringTypes:
            errstring = str(depstring)
        
        try:
            pkglist = self.returnPackagesByDep(depstring)
        except Errors.YumBaseError:
            raise Errors.YumBaseError, _('No Package found for %s') % errstring
        
        ps = ListPackageSack(pkglist)
        result = self._bestPackageFromList(ps.returnNewestByNameArch())
        if result is None:
            raise Errors.YumBaseError, _('No Package found for %s') % errstring
        
        return result

    def returnInstalledPackagesByDep(self, depstring):
        """Pass in a generic [build]require string and this function will 
           pass back the installed packages it finds providing that dep."""
        
        if not depstring:
            return []

        # parse the string out
        #  either it is 'dep (some operator) e:v-r'
        #  or /file/dep
        #  or packagename
        if type(depstring) == types.TupleType:
            (depname, depflags, depver) = depstring
        else:
            depname = depstring
            depflags = None
            depver = None
            
            if depstring[0] != '/':
                # not a file dep - look at it for being versioned
                dep_split = depstring.split()
                if len(dep_split) == 3:
                    depname, flagsymbol, depver = dep_split
                    if not flagsymbol in SYMBOLFLAGS:
                        raise Errors.YumBaseError, _('Invalid version flag from: %s') % str(depstring)
                    depflags = SYMBOLFLAGS[flagsymbol]

        return self.rpmdb.getProvides(depname, depflags, depver).keys()

    def _bestPackageFromList(self, pkglist):
        """take list of package objects and return the best package object.
           If the list is empty, return None. 
           
           Note: this is not aware of multilib so make sure you're only
           passing it packages of a single arch group."""
        
        
        if len(pkglist) == 0:
            return None
            
        if len(pkglist) == 1:
            return pkglist[0]

        bestlist = self._compare_providers(pkglist, None)
        return bestlist[0][0]

    def bestPackagesFromList(self, pkglist, arch=None, single_name=False):
        """Takes a list of packages, returns the best packages.
           This function is multilib aware so that it will not compare
           multilib to singlelib packages""" 
    
        returnlist = []
        compatArchList = self.arch.get_arch_list(arch)
        multiLib = []
        singleLib = []
        noarch = []
        for po in pkglist:
            if po.arch not in compatArchList:
                continue
            elif po.arch in ("noarch"):
                noarch.append(po)
            elif isMultiLibArch(arch=po.arch):
                multiLib.append(po)
            else:
                singleLib.append(po)
                
        # we now have three lists.  find the best package(s) of each
        multi = self._bestPackageFromList(multiLib)
        single = self._bestPackageFromList(singleLib)
        no = self._bestPackageFromList(noarch)

        if single_name and multi and single and multi.name != single.name:
            # Sinlge _must_ match multi, if we want a single package name
            single = None

        # now, to figure out which arches we actually want
        # if there aren't noarch packages, it's easy. multi + single
        if no is None:
            if multi: returnlist.append(multi)
            if single: returnlist.append(single)
        # if there's a noarch and it's newer than the multilib, we want
        # just the noarch.  otherwise, we want multi + single
        elif multi:
            best = self._bestPackageFromList([multi,no])
            if best.arch == "noarch":
                returnlist.append(no)
            else:
                if multi: returnlist.append(multi)
                if single: returnlist.append(single)
        # similar for the non-multilib case
        elif single:
            best = self._bestPackageFromList([single,no])
            if best.arch == "noarch":
                returnlist.append(no)
            else:
                returnlist.append(single)
        # if there's not a multi or single lib, then we want the noarch
        else:
            returnlist.append(no)

        return returnlist

    # FIXME: This doesn't really work, as it assumes one obsoleter for each pkg
    # when we can have:
    # 1 pkg obsoleted by multiple pkgs _and_
    # 1 pkg obsoleting multiple pkgs
    # ...and we need to detect loops, and get the arches "right" and do this
    # for chains. Atm. I hate obsoletes, and I can't get it to work better,
    # easily ... so screw it, don't create huge chains of obsoletes with some
    # loops in there too ... or I'll have to hurt you.
    def _pkg2obspkg(self, po):
        """ Given a package return the package it's obsoleted by and so
            we should install instead. Or None if there isn't one. """
        if self._up is not None:
            thispkgobsdict = self.up.checkForObsolete([po.pkgtup])
        else:
            #  This is pretty hacky, but saves a huge amount of time for small
            # ops.
            if not self.conf.obsoletes:
                return None

            if not hasattr(self, '_up_obs_hack'):
                obs_init = time.time()
                up = rpmUtils.updates.Updates([], [])
                up.rawobsoletes = self.pkgSack.returnObsoletes(newest=True)
                self.verbose_logger.debug('Obs Init time: %0.3f' % (time.time()
                                                                    - obs_init))
                self._up_obs_hack = up
            thispkgobsdict = self._up_obs_hack.checkForObsolete([po.pkgtup])

        if po.pkgtup in thispkgobsdict:
            obsoleting  = thispkgobsdict[po.pkgtup]
            oobsoleting = []
            # We want to keep the arch. of the obsoleted pkg. if possible.
            for opkgtup in obsoleting:
                if not canCoinstall(po.arch, opkgtup[1]):
                    oobsoleting.append(opkgtup)
            if oobsoleting:
                obsoleting = oobsoleting
            if len(obsoleting) > 1:
                # Pick the first name, and run with it...
                first = obsoleting[0]
                obsoleting = [pkgtup for pkgtup in obsoleting
                              if first[0] == pkgtup[0]]
            if len(obsoleting) > 1:
                # Lock to the latest version...
                def _sort_ver(x, y):
                    n1,a1,e1,v1,r1 = x
                    n2,a2,e2,v2,r2 = y
                    return compareEVR((e1,v1,r1), (e2,v2,r2))
                obsoleting.sort(_sort_ver)
                first = obsoleting[0]
                obsoleting = [pkgtup for pkgtup in obsoleting
                              if not _sort_ver(first, pkgtup)]
            if len(obsoleting) > 1:
                # Now do arch distance (see depsolve:compare_providers)...
                def _sort_arch_i(carch, a1, a2):
                    res1 = archDifference(carch, a1)
                    if not res1:
                        return 0
                    res2 = archDifference(carch, a2)
                    if not res2:
                        return 0
                    return res1 - res2
                def _sort_arch(x, y):
                    n1,a1,e1,v1,r1 = x
                    n2,a2,e2,v2,r2 = y
                    ret = _sort_arch_i(po.arch,            a1, a2)
                    if ret:
                        return ret
                    ret = _sort_arch_i(self.arch.bestarch, a1, a2)
                    return ret
                obsoleting.sort(_sort_arch)
            for pkgtup in obsoleting:
                pkg = self.getPackageObject(pkgtup, allow_missing=True)
                if pkg is not None:
                    return pkg
            return None
        return None

    def _test_loop(self, node, next_func):
        """ Generic comp. sci. test for looping, walk the list with two pointers
            moving one twice as fast as the other. If they are ever == you have
            a loop. If loop we return None, if no loop the last element. """
        slow = node
        done = False
        while True:
            next = next_func(node)
            if next is None and not done: return None
            if next is None: return node
            node = next_func(next)
            if node is None: return next
            done = True

            slow = next_func(slow)
            if next == slow:
                return None

    def _at_groupinstall(self, pattern):
        " Do groupinstall via. leading @ on the cmd line, for install/update."
        assert pattern[0] == '@'
        group_string = pattern[1:]
        tx_return = []
        for group in self.comps.return_groups(group_string):
            try:
                txmbrs = self.selectGroup(group.groupid)
                tx_return.extend(txmbrs)
            except yum.Errors.GroupsError:
                self.logger.critical(_('Warning: Group %s does not exist.'), group_string)
                continue
        return tx_return
        
    def _at_groupremove(self, pattern):
        " Do groupremove via. leading @ on the cmd line, for remove."
        assert pattern[0] == '@'
        group_string = pattern[1:]
        tx_return = []
        try:
            txmbrs = self.groupRemove(group_string)
        except yum.Errors.GroupsError:
            self.logger.critical(_('No group named %s exists'), group_string)
        else:
            tx_return.extend(txmbrs)
        return tx_return

    #  Note that this returns available pkgs, and not txmbrs like the other
    # _at_group* functions.
    def _at_groupdowngrade(self, pattern):
        " Do downgrade of a group via. leading @ on the cmd line."
        assert pattern[0] == '@'
        grpid = pattern[1:]

        thesegroups = self.comps.return_groups(grpid)
        if not thesegroups:
            raise Errors.GroupsError, _("No Group named %s exists") % to_unicode(grpid)
        pkgnames = set()
        for thisgroup in thesegroups:
            pkgnames.update(thisgroup.packages)
        return self.pkgSack.searchNames(pkgnames)

    def _minus_deselect(self, pattern):
        """ Remove things from the transaction, like kickstart. """
        assert pattern[0] == '-'
        pat = pattern[1:]

        if pat and pat[0] == '@':
            pat = pat[1:]
            return self.deselectGroup(pat)

        return self.tsInfo.deselect(pat)

    def _find_obsoletees(self, po):
        """ Return the pkgs. that are obsoleted by the po we pass in. """
        if not self.conf.obsoletes:
            return

        if not isinstance(po, YumLocalPackage):
            for (obstup, inst_tup) in self.up.getObsoletersTuples(name=po.name):
                if po.pkgtup == obstup:
                    installed_pkg =  self.getInstalledPackageObject(inst_tup)
                    yield installed_pkg
        else:
            for pkg in self._find_obsoletees_direct(po):
                yield pkg

    def _find_obsoletees_direct(self, po):
        """ Return the pkgs. that are obsoleted by the po we pass in. This works
            directly on the package data, for two reasons:
            1. Consulting .up. has a slow setup for small/fast ops.
            2. We need this work even if obsoletes are turned off, because rpm
               will be doing it for us. """
        for obs_n in po.obsoletes_names:
            for pkg in self.rpmdb.searchNevra(name=obs_n):
                if pkg.obsoletedBy([po]):
                    yield pkg

    def _add_prob_flags(self, *flags):
        """ Add all of the passed flags to the tsInfo.probFilterFlags array. """
        for flag in flags:
            if flag not in self.tsInfo.probFilterFlags:
                self.tsInfo.probFilterFlags.append(flag)

    def install(self, po=None, **kwargs):
        """try to mark for install the item specified. Uses provided package 
           object, if available. If not it uses the kwargs and gets the best
           packages from the keyword options provided 
           returns the list of txmbr of the items it installs
           
           """
        
        pkgs = []
        was_pattern = False
        if po:
            if isinstance(po, YumAvailablePackage) or isinstance(po, YumLocalPackage):
                pkgs.append(po)
            else:
                raise Errors.InstallError, _('Package Object was not a package object instance')
            
        else:
            if not kwargs:
                raise Errors.InstallError, _('Nothing specified to install')

            if 'pattern' in kwargs:
                if kwargs['pattern'] and kwargs['pattern'][0] == '-':
                    return self._minus_deselect(kwargs['pattern'])

                if kwargs['pattern'] and kwargs['pattern'][0] == '@':
                    return self._at_groupinstall(kwargs['pattern'])

                was_pattern = True
                pats = [kwargs['pattern']]
                mypkgs = self.pkgSack.returnPackages(patterns=pats,
                                                      ignore_case=False)
                pkgs.extend(mypkgs)
                # if we have anything left unmatched, let's take a look for it
                # being a dep like glibc.so.2 or /foo/bar/baz
                
                if not mypkgs:
                    arg = kwargs['pattern']
                    self.verbose_logger.debug(_('Checking for virtual provide or file-provide for %s'), 
                        arg)

                    try:
                        mypkgs = self.returnPackagesByDep(arg)
                    except yum.Errors.YumBaseError, e:
                        self.logger.critical(_('No Match for argument: %s') % to_unicode(arg))
                    else:
                        # install MTA* == fail, because provides don't do globs
                        # install /usr/kerberos/bin/* == success (and we want
                        #                                all of the pkgs)
                        if mypkgs and not misc.re_glob(arg):
                            mypkgs = self.bestPackagesFromList(mypkgs,
                                                               single_name=True)
                        if mypkgs:
                            pkgs.extend(mypkgs)
                        
            else:
                nevra_dict = self._nevra_kwarg_parse(kwargs)

                pkgs = self.pkgSack.searchNevra(name=nevra_dict['name'],
                     epoch=nevra_dict['epoch'], arch=nevra_dict['arch'],
                     ver=nevra_dict['version'], rel=nevra_dict['release'])
                self._add_not_found_a(pkgs, nevra_dict)
                
            if pkgs:
                # if was_pattern or nevra-dict['arch'] is none, take the list
                # of arches based on our multilib_compat config and 
                # toss out any pkgs of any arch NOT in that arch list

                
                # only do these things if we're multilib
                if self.arch.multilib:
                    if was_pattern or not nevra_dict['arch']: # and only if they
                                                              # they didn't specify an arch
                        if self.conf.multilib_policy == 'best':
                            pkgs_by_name = {}
                            use = []
                            not_added = []
                            best = self.arch.legit_multi_arches
                            best.append('noarch')
                            for pkg in pkgs:
                                if pkg.arch in best:
                                    pkgs_by_name[pkg.name] = 1    
                                    use.append(pkg)  
                                else:
                                    not_added.append(pkg)
                            for pkg in not_added:
                                if not pkg.name in pkgs_by_name:
                                    use.append(pkg)
                           
                            pkgs = use
                           
                pkgs = packagesNewestByName(pkgs)

                pkgbyname = {}
                for pkg in pkgs:
                    if pkg.name not in pkgbyname:
                        pkgbyname[pkg.name] = [ pkg ]
                    else:
                        pkgbyname[pkg.name].append(pkg)

                lst = []
                for pkgs in pkgbyname.values():
                    lst.extend(self.bestPackagesFromList(pkgs))
                pkgs = lst


        if not pkgs:
            # Do we still want to return errors here?
            # We don't in the cases below, so I didn't here...
            if 'pattern' in kwargs:
                pkgs = self.rpmdb.returnPackages(patterns=[kwargs['pattern']],
                                                 ignore_case=False)
            if 'name' in kwargs:
                pkgs = self.rpmdb.searchNevra(name=kwargs['name'])
            if 'pkgtup' in kwargs:
                pkgs = self.rpmdb.searchNevra(name=kwargs['pkgtup'][0])
            # Warning here does "weird" things when doing:
            # yum --disablerepo='*' install '*'
            # etc. ... see RHBZ#480402
            if False:
                for pkg in pkgs:
                    self.verbose_logger.warning(_('Package %s installed and not available'), pkg)
            if pkgs:
                return []
            raise Errors.InstallError, _('No package(s) available to install')
        
        # FIXME - lots more checking here
        #  - install instead of erase
        #  - better error handling/reporting


        tx_return = []
        for po in pkgs:
            if self.tsInfo.exists(pkgtup=po.pkgtup):
                if self.tsInfo.getMembersWithState(po.pkgtup, TS_INSTALL_STATES):
                    self.verbose_logger.log(logginglevels.DEBUG_1,
                        _('Package: %s  - already in transaction set'), po)
                    tx_return.extend(self.tsInfo.getMembers(pkgtup=po.pkgtup))
                    continue
            
            # make sure this shouldn't be passed to update:
            if (self.rpmdb.searchNames([po.name]) and
                po.pkgtup in self.up.updating_dict):
                txmbrs = self.update(po=po)
                tx_return.extend(txmbrs)
                continue
            
            #  Make sure we're not installing a package which is obsoleted by
            # something else in the repo. Unless there is a obsoletion loop,
            # at which point ignore everything.
            obsoleting_pkg = None
            if self.conf.obsoletes:
                obsoleting_pkg = self._test_loop(po, self._pkg2obspkg)
            if obsoleting_pkg is not None:
                # this is not a definitive check but it'll make sure we don't
                # pull in foo.i586 when foo.x86_64 already obsoletes the pkg and
                # is already installed
                already_obs = None
                pkgs = self.rpmdb.searchNevra(name=obsoleting_pkg.name)
                pkgs = po.obsoletedBy(pkgs, limit=1)
                if pkgs:
                    already_obs = pkgs[0]

                if already_obs:
                    self.verbose_logger.warning(_('Package %s is obsoleted by %s which is already installed'), 
                                                po, already_obs)
                else:
                    if 'provides_for' in kwargs:
                        if not obsoleting_pkg.provides_for(kwargs['provides_for']):
                            self.verbose_logger.warning(_('Package %s is obsoleted by %s, but obsoleting package does not provide for requirements'),
                                                  po.name, obsoleting_pkg.name)
                            continue
                    self.verbose_logger.warning(_('Package %s is obsoleted by %s, trying to install %s instead'),
                        po.name, obsoleting_pkg.name, obsoleting_pkg)
                    tx_return.extend(self.install(po=obsoleting_pkg))
                continue
            
            # make sure it's not already installed
            if self.rpmdb.contains(po=po):
                if not self.tsInfo.getMembersWithState(po.pkgtup, TS_REMOVE_STATES):
                    self.verbose_logger.warning(_('Package %s already installed and latest version'), po)
                    continue

            # make sure we don't have a name.arch of this already installed
            # if so pass it to update b/c it should be able to figure it out
            # if self.rpmdb.contains(name=po.name, arch=po.arch) and not self.allowedMultipleInstalls(po):
            if not self.allowedMultipleInstalls(po):
                found = True
                for ipkg in self.rpmdb.searchNevra(name=po.name, arch=po.arch):
                    found = False
                    if self.tsInfo.getMembersWithState(ipkg.pkgtup, TS_REMOVE_STATES):
                        found = True
                        break
                if not found:
                    self.verbose_logger.warning(_('Package matching %s already installed. Checking for update.'), po)            
                    txmbrs = self.update(po=po)
                    tx_return.extend(txmbrs)
                    continue

                
            # at this point we are going to mark the pkg to be installed, make sure
            # it's not an older package that is allowed in due to multiple installs
            # or some other oddity. If it is - then modify the problem filter to cope
            
            for ipkg in self.rpmdb.searchNevra(name=po.name, arch=po.arch):
                if ipkg.verEQ(po):
                    self._add_prob_flags(rpm.RPMPROB_FILTER_REPLACEPKG,
                                         rpm.RPMPROB_FILTER_REPLACENEWFILES,
                                         rpm.RPMPROB_FILTER_REPLACEOLDFILES)
                    #  Yum needs the remove to happen before we allow the
                    # install of the same version. But rpm doesn't like that
                    # as it then has an install which removes the old version
                    # and a remove, which also tries to remove the old version.
                    self.tsInfo.remove(ipkg.pkgtup)
                    break
            for ipkg in self.rpmdb.searchNevra(name=po.name):
                if ipkg.verGT(po) and not canCoinstall(ipkg.arch, po.arch):
                    self._add_prob_flags(rpm.RPMPROB_FILTER_OLDPACKAGE)
                    break
            
            # it doesn't obsolete anything. If it does, mark that in the tsInfo, too
            obs_pkgs = list(self._find_obsoletees_direct(po))
            if obs_pkgs:
                for obsoletee in obs_pkgs:
                    txmbr = self.tsInfo.addObsoleting(po, obsoletee)
                    self.tsInfo.addObsoleted(obsoletee, po)
                    tx_return.append(txmbr)
            else:
                txmbr = self.tsInfo.addInstall(po)
                tx_return.append(txmbr)

        return tx_return

    def _check_new_update_provides(self, opkg, npkg):
        """ Check for any difference in the provides of the old and new update
            that is needed by the transaction. If so we "update" those pkgs
            too, to the latest version. """
        oprovs = set(opkg.returnPrco('provides'))
        nprovs = set(npkg.returnPrco('provides'))
        tx_return = []
        for prov in oprovs.difference(nprovs):
            reqs = self.tsInfo.getRequires(*prov)
            for pkg in reqs:
                for req in reqs[pkg]:
                    if not npkg.inPrcoRange('provides', req):
                        naTup = (pkg.name, pkg.arch)
                        for pkg in self.pkgSack.returnNewestByNameArch(naTup):
                            tx_return.extend(self.update(po=pkg))
                        break
        return tx_return

    def _newer_update_in_trans(self, pkgtup, available_pkg, tx_return):
        """ We return True if there is a newer package already in the
            transaction. If there is an older one, we remove it (and update any
            deps. that aren't satisfied by the newer pkg) and return False so
            we'll update to this newer pkg. """
        found = False
        for txmbr in self.tsInfo.getMembersWithState(pkgtup, [TS_UPDATED]):
            count = 0
            for po in txmbr.updated_by:
                if available_pkg.verLE(po):
                    count += 1
                else:
                    for ntxmbr in self.tsInfo.getMembers(po.pkgtup):
                        self.tsInfo.remove(ntxmbr.po.pkgtup)
                        txs = self._check_new_update_provides(ntxmbr.po,
                                                              available_pkg)
                        tx_return.extend(txs)
            if count:
                found = True
            else:
                self.tsInfo.remove(txmbr.po.pkgtup)
        return found

    def _add_up_txmbr(self, requiringPo, upkg, ipkg):
        txmbr = self.tsInfo.addUpdate(upkg, ipkg)
        if requiringPo:
            txmbr.setAsDep(requiringPo)
        if ('reason' in ipkg.yumdb_info and ipkg.yumdb_info.reason == 'dep'):
            txmbr.reason = 'dep'
        return txmbr

    def update(self, po=None, requiringPo=None, update_to=False, **kwargs):
        """try to mark for update the item(s) specified. 
            po is a package object - if that is there, mark it for update,
            if possible
            else use **kwargs to match the package needing update
            if nothing is specified at all then attempt to update everything
            
            returns the list of txmbr of the items it marked for update"""
        
        # check for args - if no po nor kwargs, do them all
        # if po, do it, ignore all else
        # if no po do kwargs
        # uninstalled pkgs called for update get returned with errors in a list, maybe?

        tx_return = []
        if not po and not kwargs: # update everything (the easy case)
            self.verbose_logger.log(logginglevels.DEBUG_2, _('Updating Everything'))
            updates = self.up.getUpdatesTuples()
            if self.conf.obsoletes:
                obsoletes = self.up.getObsoletesTuples(newest=1)
            else:
                obsoletes = []

            for (obsoleting, installed) in obsoletes:
                obsoleting_pkg = self.getPackageObject(obsoleting,
                                                       allow_missing=True)
                if obsoleting_pkg is None:
                    continue
                topkg = self._test_loop(obsoleting_pkg, self._pkg2obspkg)
                if topkg is not None:
                    obsoleting_pkg = topkg
                installed_pkg =  self.getInstalledPackageObject(installed)
                txmbr = self.tsInfo.addObsoleting(obsoleting_pkg, installed_pkg)
                self.tsInfo.addObsoleted(installed_pkg, obsoleting_pkg)
                if requiringPo:
                    txmbr.setAsDep(requiringPo)
                tx_return.append(txmbr)
                
            for (new, old) in updates:
                if self.tsInfo.isObsoleted(pkgtup=old):
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('Not Updating Package that is already obsoleted: %s.%s %s:%s-%s') %
                        old)
                else:
                    new = self.getPackageObject(new, allow_missing=True)
                    if new is None:
                        continue
                    tx_return.extend(self.update(po=new))
            
            return tx_return

        # complications
        # the user has given us something - either a package object to be
        # added to the transaction as an update or they've given us a pattern 
        # of some kind
        
        instpkgs = []
        availpkgs = []
        if po: # just a po
            if po.repoid == 'installed':
                instpkgs.append(po)
            else:
                availpkgs.append(po)
                
                
        elif 'pattern' in kwargs:
            if kwargs['pattern'] and kwargs['pattern'][0] == '-':
                return self._minus_deselect(kwargs['pattern'])

            if kwargs['pattern'] and kwargs['pattern'][0] == '@':
                return self._at_groupinstall(kwargs['pattern'])

            arg = kwargs['pattern']
            if not update_to:
                instpkgs  = self.rpmdb.returnPackages(patterns=[arg])
            else:
                availpkgs = self.pkgSack.returnPackages(patterns=[arg])

            if not instpkgs and not availpkgs:
                depmatches = []
                try:
                    if update_to:
                        depmatches = self.returnPackagesByDep(arg)
                    else:
                        depmatches = self.returnInstalledPackagesByDep(arg)
                except yum.Errors.YumBaseError, e:
                    self.logger.critical(_('%s') % e)

                if update_to:
                    availpkgs.extend(depmatches)
                else:
                    instpkgs.extend(depmatches)

            #  Always look for available packages, it doesn't seem to do any
            # harm (apart from some time). And it fixes weird edge cases where
            # "update a" (which requires a new b) is different from "update b"
            try:
                if update_to:
                    m = []
                else:
                    pats = [kwargs['pattern']]
                    # pats += list(set([pkg.name for pkg in instpkgs]))
                    m = self.pkgSack.returnNewestByNameArch(patterns=pats)
            except Errors.PackageSackError:
                m = []
            availpkgs.extend(m)

            if not availpkgs and not instpkgs:
                self.logger.critical(_('No Match for argument: %s') % to_unicode(arg))
        
        else: # we have kwargs, sort them out.
            nevra_dict = self._nevra_kwarg_parse(kwargs)

            instpkgs = self.rpmdb.searchNevra(name=nevra_dict['name'], 
                        epoch=nevra_dict['epoch'], arch=nevra_dict['arch'], 
                        ver=nevra_dict['version'], rel=nevra_dict['release'])

            if not instpkgs:
                availpkgs = self.pkgSack.searchNevra(name=nevra_dict['name'],
                            epoch=nevra_dict['epoch'], arch=nevra_dict['arch'],
                            ver=nevra_dict['version'], rel=nevra_dict['release'])
                self._add_not_found_a(availpkgs, nevra_dict)
                if len(availpkgs) > 1:
                    availpkgs = self._compare_providers(availpkgs, requiringPo)
                    availpkgs = map(lambda x: x[0], availpkgs)
                elif not availpkgs:
                    self.logger.warning(_("No package matched to upgrade: %s"), self._ui_nevra_dict(nevra_dict))
       
        # for any thing specified
        # get the list of available pkgs matching it (or take the po)
        # get the list of installed pkgs matching it (or take the po)
        # go through each list and look for:
           # things obsoleting it if it is an installed pkg
           # things it updates if it is an available pkg
           # things updating it if it is an installed pkg
           # in that order
           # all along checking to make sure we:
            # don't update something that's already been obsoleted
            # don't update something that's already been updated
            
        # if there are more than one package that matches an update from
        # a pattern/kwarg then:
            # if it is a valid update and we'
        
        # TODO: we should search the updates and obsoletes list and
        # mark the package being updated or obsoleted away appropriately
        # and the package relationship in the tsInfo
        

        # check for obsoletes first
        if self.conf.obsoletes:
            for installed_pkg in instpkgs:
                obs_tups = self.up.obsoleted_dict.get(installed_pkg.pkgtup, [])
                # This is done so we don't have to returnObsoletes(newest=True)
                # It's a minor UI problem for RHEL, but might as well dtrt.
                obs_pkgs = []
                for pkgtup in obs_tups:
                    obsoleting_pkg = self.getPackageObject(pkgtup,
                                                           allow_missing=True)
                    if obsoleting_pkg is None:
                        continue
                    obs_pkgs.append(obsoleting_pkg)
                for obsoleting_pkg in packagesNewestByName(obs_pkgs):
                    tx_return.extend(self.install(po=obsoleting_pkg))
            for available_pkg in availpkgs:
                for obsoleted_pkg in self._find_obsoletees(available_pkg):
                    obsoleted = obsoleted_pkg.pkgtup
                    txmbr = self.tsInfo.addObsoleting(available_pkg, obsoleted_pkg)
                    if requiringPo:
                        txmbr.setAsDep(requiringPo)
                    tx_return.append(txmbr)
                    if self.tsInfo.isObsoleted(obsoleted):
                        self.verbose_logger.log(logginglevels.DEBUG_2, _('Package is already obsoleted: %s.%s %s:%s-%s') % obsoleted)
                    else:
                        txmbr = self.tsInfo.addObsoleted(obsoleted_pkg, available_pkg)
                        tx_return.append(txmbr)

        for installed_pkg in instpkgs:
            for updating in self.up.updatesdict.get(installed_pkg.pkgtup, []):
                po = self.getPackageObject(updating, allow_missing=True)
                if po is None:
                    continue
                if self.tsInfo.isObsoleted(installed_pkg.pkgtup):
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('Not Updating Package that is already obsoleted: %s.%s %s:%s-%s') %
                                            installed_pkg.pkgtup)                                               
                # at this point we are going to mark the pkg to be installed, make sure
                # it doesn't obsolete anything. If it does, mark that in the tsInfo, too
                elif po.pkgtup in self.up.getObsoletesList(name=po.name):
                    for obsoletee in self._find_obsoletees(po):
                        txmbr = self.tsInfo.addUpdate(po, installed_pkg)
                        if requiringPo:
                            txmbr.setAsDep(requiringPo)
                        self.tsInfo.addObsoleting(po, obsoletee)
                        self.tsInfo.addObsoleted(obsoletee, po)
                        tx_return.append(txmbr)
                else:
                    if self.tsInfo.getMembersWithState(installed_pkg.pkgtup,
                                                       TS_REMOVE_STATES):
                        self.tsInfo.remove(installed_pkg.pkgtup)
                    txmbr = self._add_up_txmbr(requiringPo, po, installed_pkg)
                    tx_return.append(txmbr)
                        
        for available_pkg in availpkgs:
            #  Make sure we're not installing a package which is obsoleted by
            # something else in the repo. Unless there is a obsoletion loop,
            # at which point ignore everything.
            obsoleting_pkg = self._test_loop(available_pkg, self._pkg2obspkg)
            if obsoleting_pkg is not None:
                self.verbose_logger.log(logginglevels.DEBUG_2, _('Not Updating Package that is obsoleted: %s'), available_pkg)
                tx_return.extend(self.update(po=obsoleting_pkg))
                continue
            for updated in self.up.updating_dict.get(available_pkg.pkgtup, []):
                if self.tsInfo.isObsoleted(updated):
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('Not Updating Package that is already obsoleted: %s.%s %s:%s-%s') %
                                            updated)
                elif self._newer_update_in_trans(updated, available_pkg,
                                                 tx_return):
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('Not Updating Package that is already updated: %s.%s %s:%s-%s') %
                                            updated)
                
                else:
                    updated_pkg =  self.getInstalledPackageObject(updated)
                    if self.tsInfo.getMembersWithState(updated,
                                                       TS_REMOVE_STATES):
                        self.tsInfo.remove(updated)
                    txmbr = self._add_up_txmbr(requiringPo,
                                               available_pkg, updated_pkg)
                    tx_return.append(txmbr)
                    
            # check to see if the pkg we want to install is not _quite_ the newest
            # one but still technically an update over what is installed.
            pot_updated = self.rpmdb.searchNevra(name=available_pkg.name, arch=available_pkg.arch)
            if pot_updated and self.allowedMultipleInstalls(available_pkg):
                # only compare against the newest of what's installed for kernel
                pot_updated = sorted(pot_updated)[-1:]
#FIXME - potentially do the comparables thing from what used to
#        be in cli.installPkgs() to see what we should be comparing
#        it to of what is installed. in the meantime name.arch is
#        most likely correct
# this is sorta a fix - but it shouldn't be only for localPackages
#            else:
#                if available_pkg in self.localPackages:
#                    # if we got here the potentially updated is not a matching arch
#                    # and we're goofed up in a localPackage that someone wants to apply for some odd reason
#                    # so we go for name-only update match and check
#                    pot_updated = self.rpmdb.searchNevra(name=available_pkg.name)
            
            for ipkg in pot_updated:
                if self.tsInfo.isObsoleted(ipkg.pkgtup):
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('Not Updating Package that is already obsoleted: %s.%s %s:%s-%s') %
                                            ipkg.pkgtup)
                elif self._newer_update_in_trans(ipkg.pkgtup, available_pkg,
                                                 tx_return):
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('Not Updating Package that is already updated: %s.%s %s:%s-%s') %
                                            ipkg.pkgtup)
                elif ipkg.verLT(available_pkg):
                    txmbr = self._add_up_txmbr(requiringPo, available_pkg, ipkg)
                    tx_return.append(txmbr)
        
        for txmbr in tx_return:
            for i_pkg in self.rpmdb.searchNevra(name=txmbr.name):
                if i_pkg not in txmbr.updates:
                    if self._does_this_update(txmbr.po, i_pkg):
                        self.tsInfo.addUpdated(i_pkg, txmbr.po)
                        
        return tx_return
        
    def remove(self, po=None, **kwargs):
        """try to find and mark for remove the specified package(s) -
            if po is specified then that package object (if it is installed) 
            will be marked for removal.
            if no po then look at kwargs, if neither then raise an exception"""

        if not po and not kwargs:
            raise Errors.RemoveError, 'Nothing specified to remove'
        
        tx_return = []
        pkgs = []
        
        
        if po:
            pkgs = [po]  
        else:
            if 'pattern' in kwargs:
                if kwargs['pattern'] and kwargs['pattern'][0] == '-':
                    return self._minus_deselect(kwargs['pattern'])

                if kwargs['pattern'] and kwargs['pattern'][0] == '@':
                    return self._at_groupremove(kwargs['pattern'])

                (e,m,u) = self.rpmdb.matchPackageNames([kwargs['pattern']])
                pkgs.extend(e)
                pkgs.extend(m)
                if u:
                    depmatches = []
                    arg = u[0]
                    try:
                        depmatches = self.returnInstalledPackagesByDep(arg)
                    except yum.Errors.YumBaseError, e:
                        self.logger.critical(_('%s') % e)
                    
                    if not depmatches:
                        arg = to_unicode(arg)
                        self.logger.critical(_('No Match for argument: %s') % to_unicode(arg))
                    else:
                        pkgs.extend(depmatches)
                
            else:    
                nevra_dict = self._nevra_kwarg_parse(kwargs)

                pkgs = self.rpmdb.searchNevra(name=nevra_dict['name'], 
                            epoch=nevra_dict['epoch'], arch=nevra_dict['arch'], 
                            ver=nevra_dict['version'], rel=nevra_dict['release'])
                self._add_not_found_i(pkgs, nevra_dict)
                if len(pkgs) == 0:
                    if not kwargs.get('silence_warnings', False):
                        self.logger.warning(_("No package matched to remove: %s"), self._ui_nevra_dict(nevra_dict))

        ts = self.rpmdb.readOnlyTS()
        kern_pkgtup = misc.get_running_kernel_pkgtup(ts)
        for po in pkgs:
            if self.conf.protected_packages and po.pkgtup == kern_pkgtup:
                self.logger.warning(_("Skipping the running kernel: %s") % po)
                continue

            if self.tsInfo.getMembers(po.pkgtup):
                # This allows multiple reinstalls and update/downgrade "cancel"
                for txmbr in self.tsInfo.matchNaevr(po.name):
                    self.logger.info(_("Removing %s from the transaction") %
                                     txmbr)
                    self.tsInfo.remove(txmbr.pkgtup)
                # Now start the remove/reinstall
            txmbr = self.tsInfo.addErase(po)
            tx_return.append(txmbr)
        
        return tx_return

    def installLocal(self, pkg, po=None, updateonly=False):
        """
        handles installs/updates of rpms provided on the filesystem in a
        local dir (ie: not from a repo)

        Return the added transaction members.

        @param pkg: a path to an rpm file on disk.
        @param po: A YumLocalPackage
        @param updateonly: Whether or not true installs are valid.
        """

        # read in the package into a YumLocalPackage Object
        # append it to self.localPackages
        # check if it can be installed or updated based on nevra versus rpmdb
        # don't import the repos until we absolutely need them for depsolving
        tx_return = []
        installpkgs = []
        updatepkgs = []
        donothingpkgs = []

        if not po:
            try:
                po = YumUrlPackage(self, ts=self.rpmdb.readOnlyTS(), url=pkg,
                                   ua=default_grabber.opts.user_agent)
            except Errors.MiscError:
                self.logger.critical(_('Cannot open: %s. Skipping.'), pkg)
                return tx_return
            self.verbose_logger.log(logginglevels.INFO_2,
                _('Examining %s: %s'), po.localpath, po)

        # apparently someone wanted to try to install a drpm as an rpm :(
        if po.hdr['payloadformat'] == 'drpm':
            self.logger.critical(_('Cannot localinstall deltarpm: %s. Skipping.'), pkg)
            return tx_return

        # if by any chance we're a noncompat arch rpm - bail and throw out an error
        # FIXME -our archlist should be stored somewhere so we don't have to
        # do this: but it's not a config file sort of thing
        # FIXME: Should add noarch, yum localinstall works ...
        # just rm this method?
        if po.arch not in self.arch.archlist:
            self.logger.critical(_('Cannot add package %s to transaction. Not a compatible architecture: %s'), pkg, po.arch)
            return tx_return
        
        if self.conf.obsoletes:
            obsoleters = po.obsoletedBy(self.rpmdb.searchObsoletes(po.name))
            if obsoleters:
                self.logger.critical(_('Cannot install package %s. It is obsoleted by installed package %s'), po, obsoleters[0])
                return tx_return
            
        # everything installed that matches the name
        installedByKey = self.rpmdb.searchNevra(name=po.name)
        # go through each package
        if len(installedByKey) == 0: # nothing installed by that name
            if updateonly:
                self.logger.warning(_('Package %s not installed, cannot update it. Run yum install to install it instead.'), po.name)
                return tx_return
            else:
                installpkgs.append(po)

        for installed_pkg in installedByKey:
            if po.verGT(installed_pkg): # we're newer - this is an update, pass to them
                if installed_pkg.name in self.conf.exactarchlist:
                    if po.arch == installed_pkg.arch:
                        updatepkgs.append((po, installed_pkg))
                    else:
                        donothingpkgs.append(po)
                else:
                    updatepkgs.append((po, installed_pkg))
            elif po.verEQ(installed_pkg):
                if (po.arch != installed_pkg.arch and
                    (isMultiLibArch(po.arch) or
                     isMultiLibArch(installed_pkg.arch))):
                    if updateonly:
                        self.logger.warning(_('Package %s.%s not installed, cannot update it. Run yum install to install it instead.'), po.name, po.arch)
                    else:
                        installpkgs.append(po)
                else:
                    donothingpkgs.append(po)
            elif self.allowedMultipleInstalls(po):
                if updateonly:
                    self.logger.warning(_('Package %s.%s not installed, cannot update it. Run yum install to install it instead.'), po.name, po.arch)
                else:
                    installpkgs.append(po)
            else:
                donothingpkgs.append(po)

        # handle excludes for a localinstall
        check_pkgs = installpkgs + [x[0] for x in updatepkgs]
        if self._is_local_exclude(po, check_pkgs):
            self.verbose_logger.debug(_('Excluding %s'), po)
            return tx_return

        for po in installpkgs:
            self.verbose_logger.log(logginglevels.INFO_2,
                _('Marking %s to be installed'), po.localpath)
            self.localPackages.append(po)
            tx_return.extend(self.install(po=po))

        for (po, oldpo) in updatepkgs:
            self.verbose_logger.log(logginglevels.INFO_2,
                _('Marking %s as an update to %s'), po.localpath, oldpo)
            self.localPackages.append(po)
            txmbrs = self.update(po=po)
            tx_return.extend(txmbrs)

        for po in donothingpkgs:
            self.verbose_logger.log(logginglevels.INFO_2,
                _('%s: does not update installed package.'), po.localpath)
        
        # this checks to make sure that any of the to-be-installed pkgs
        # does not obsolete something else that's installed
        # this doesn't handle the localpkgs obsoleting EACH OTHER or
        # anything else in the transaction set, though. That could/should
        # be fixed later but a fair bit of that is a pebkac and should be
        # said as "don't do that". potential 'fixme'
        for txmbr in tx_return:
            #  We don't want to do this twice, so only bother if the txmbr
            # doesn't already obsolete anything.
            if txmbr.po.obsoletes and not txmbr.obsoletes:
                for obs_pkg in self._find_obsoletees(txmbr.po):
                    self.tsInfo.addObsoleted(obs_pkg, txmbr.po)
                    txmbr.obsoletes.append(obs_pkg)
                    self.tsInfo.addObsoleting(txmbr.po,obs_pkg)
                
        return tx_return

    def reinstallLocal(self, pkg, po=None):
        """
        handles reinstall of rpms provided on the filesystem in a
        local dir (ie: not from a repo)

        Return the added transaction members.

        @param pkg: a path to an rpm file on disk.
        @param po: A YumLocalPackage
        """

        if not po:
            try:
                po = YumUrlPackage(self, ts=self.rpmdb.readOnlyTS(), url=pkg,
                                   ua=default_grabber.opts.user_agent)
            except Errors.MiscError:
                self.logger.critical(_('Cannot open file: %s. Skipping.'), pkg)
                return []
            self.verbose_logger.log(logginglevels.INFO_2,
                _('Examining %s: %s'), po.localpath, po)

        if po.arch not in self.arch.archlist:
            self.logger.critical(_('Cannot add package %s to transaction. Not a compatible architecture: %s'), pkg, po.arch)
            return []

        # handle excludes for a local reinstall
        if self._is_local_exclude(po, [po]):
            self.verbose_logger.debug(_('Excluding %s'), po)
            return []

        return self.reinstall(po=po)

    def reinstall(self, po=None, **kwargs):
        """Setup the problem filters to allow a reinstall to work, then
           pass everything off to install"""
           
        self._add_prob_flags(rpm.RPMPROB_FILTER_REPLACEPKG,
                             rpm.RPMPROB_FILTER_REPLACENEWFILES,
                             rpm.RPMPROB_FILTER_REPLACEOLDFILES)

        tx_mbrs = []
        if po: # The po, is the "available" po ... we want the installed po
            tx_mbrs.extend(self.remove(pkgtup=po.pkgtup))
        else:
            tx_mbrs.extend(self.remove(**kwargs))
        if not tx_mbrs:
            raise Errors.ReinstallRemoveError, _("Problem in reinstall: no package matched to remove")
        templen = len(tx_mbrs)
        # this is a reinstall, so if we can't reinstall exactly what we uninstalled
        # then we really shouldn't go on
        new_members = []
        failed = []
        failed_pkgs = []
        for item in tx_mbrs[:]:
            #  Make sure obsoletes processing is off, so we can reinstall()
            # pkgs that are obsolete.
            old_conf_obs = self.conf.obsoletes
            self.conf.obsoletes = False
            if isinstance(po, YumLocalPackage):
                members = self.install(po=po)
            else:
                members = self.install(pkgtup=item.pkgtup)
            self.conf.obsoletes = old_conf_obs
            if len(members) == 0:
                self.tsInfo.remove(item.pkgtup)
                tx_mbrs.remove(item)
                failed.append(str(item.po))
                failed_pkgs.append(item.po)
                continue
            new_members.extend(members)

        if failed and not tx_mbrs:
            raise Errors.ReinstallInstallError(_("Problem in reinstall: no package %s matched to install") % ", ".join(failed), failed_pkgs=failed_pkgs)
        tx_mbrs.extend(new_members)
        return tx_mbrs
        
    def downgradeLocal(self, pkg, po=None):
        """
        handles downgrades of rpms provided on the filesystem in a
        local dir (ie: not from a repo)

        Return the added transaction members.

        @param pkg: a path to an rpm file on disk.
        @param po: A YumLocalPackage
        """

        if not po:
            try:
                po = YumUrlPackage(self, ts=self.rpmdb.readOnlyTS(), url=pkg,
                                   ua=default_grabber.opts.user_agent)
            except Errors.MiscError:
                self.logger.critical(_('Cannot open file: %s. Skipping.'), pkg)
                return []
            self.verbose_logger.log(logginglevels.INFO_2,
                _('Examining %s: %s'), po.localpath, po)

        if po.arch not in self.arch.archlist:
            self.logger.critical(_('Cannot add package %s to transaction. Not a compatible architecture: %s'), pkg, po.arch)
            return []

        # handle excludes for a local downgrade
        if self._is_local_exclude(po, [po]):
            self.verbose_logger.debug(_('Excluding %s'), po)
            return []

        return self.downgrade(po=po)

    def _is_local_exclude(self, po, pkglist):
        """returns True if the local pkg should be excluded"""
        
        if "all" in self.conf.disable_excludes or \
           "main" in self.conf.disable_excludes:
            return False
        
        toexc = []
        if len(self.conf.exclude) > 0:
            exactmatch, matched, unmatched = \
                   parsePackages(pkglist, self.conf.exclude, casematch=1)
            toexc = exactmatch + matched

        if po in toexc:
            return True

        return False
        
    def downgrade(self, po=None, **kwargs):
        """ Try to downgrade a package. Works like:
            % yum shell <<EOL
            remove  abcd
            install abcd-<old-version>
            run
            EOL """

        if not po and not kwargs:
            raise Errors.DowngradeError, 'Nothing specified to downgrade'

        doing_group_pkgs = False
        if po:
            apkgs = [po]
        elif 'pattern' in kwargs:
            if kwargs['pattern'] and kwargs['pattern'][0] == '-':
                return self._minus_deselect(kwargs['pattern'])

            if kwargs['pattern'] and kwargs['pattern'][0] == '@':
                apkgs = self._at_groupdowngrade(kwargs['pattern'])
                doing_group_pkgs = True # Don't warn. about some things
            else:
                apkgs = self.pkgSack.returnPackages(patterns=[kwargs['pattern']],
                                                   ignore_case=False)
                if not apkgs:
                    arg = kwargs['pattern']
                    self.verbose_logger.debug(_('Checking for virtual provide or file-provide for %s'), 
                        arg)

                    try:
                        apkgs = self.returnPackagesByDep(arg)
                    except yum.Errors.YumBaseError, e:
                        self.logger.critical(_('No Match for argument: %s') % to_unicode(arg))

        else:
            nevra_dict = self._nevra_kwarg_parse(kwargs)
            apkgs = self.pkgSack.searchNevra(name=nevra_dict['name'], 
                                             epoch=nevra_dict['epoch'],
                                             arch=nevra_dict['arch'], 
                                             ver=nevra_dict['version'],
                                             rel=nevra_dict['release'])
            self._add_not_found_a(apkgs, nevra_dict)

        if not apkgs:
            # Do we still want to return errors here?
            # We don't in the cases below, so I didn't here...
            pkgs = []
            if 'pattern' in kwargs:
                pkgs = self.rpmdb.returnPackages(patterns=[kwargs['pattern']],
                                                 ignore_case=False)
            if 'name' in kwargs:
                pkgs = self.rpmdb.searchNevra(name=kwargs['name'])
            if pkgs:
                return []
            raise Errors.DowngradeError, _('No package(s) available to downgrade')

        warned_nas = set()
        # Skip kernel etc.
        tapkgs = []
        for pkg in apkgs:
            if self.allowedMultipleInstalls(pkg):
                if (pkg.name, pkg.arch) not in warned_nas:
                    msg = _("Package %s is allowed multiple installs, skipping") % pkg
                    self.verbose_logger.log(logginglevels.INFO_2, msg)
                warned_nas.add((pkg.name, pkg.arch))
                continue
            tapkgs.append(pkg)
        apkgs = tapkgs

        # Find installed versions of "to downgrade pkgs"
        apkg_names = set()
        for pkg in apkgs:
            apkg_names.add(pkg.name)
        ipkgs = self.rpmdb.searchNames(list(apkg_names))

        latest_installed_na = {}
        latest_installed_n  = {}
        for pkg in sorted(ipkgs):
            if (pkg.name not in latest_installed_n or
                pkg.verGT(latest_installed_n[pkg.name][0])):
                latest_installed_n[pkg.name] = [pkg]
            elif pkg.verEQ(latest_installed_n[pkg.name][0]):
                latest_installed_n[pkg.name].append(pkg)
            latest_installed_na[(pkg.name, pkg.arch)] = pkg

        #  Find "latest downgrade", ie. latest available pkg before
        # installed version. Indexed fromn the latest installed pkgtup.
        downgrade_apkgs = {}
        for pkg in sorted(apkgs):
            na  = (pkg.name, pkg.arch)

            # Here we allow downgrades from .i386 => .noarch, or .i586 => .i386
            # but not .i386 => .x86_64 (similar to update).
            lipkg = None
            if na in latest_installed_na:
                lipkg = latest_installed_na[na]
            elif pkg.name in latest_installed_n:
                for tlipkg in latest_installed_n[pkg.name]:
                    if not canCoinstall(pkg.arch, tlipkg.arch):
                        lipkg = tlipkg
                        #  Use this so we don't get confused when we have
                        # different versions with different arches.
                        na = (pkg.name, lipkg.arch)
                        break

            if lipkg is None:
                if (na not in warned_nas and not doing_group_pkgs and
                    pkg.name not in latest_installed_n):
                    msg = _('No Match for available package: %s') % pkg
                    self.logger.critical(msg)
                warned_nas.add(na)
                continue

            if pkg.verGE(lipkg):
                if na not in warned_nas:
                    msg = _('Only Upgrade available on package: %s') % pkg
                    self.logger.critical(msg)
                warned_nas.add(na)
                continue

            warned_nas.add(na)
            if (lipkg.pkgtup in downgrade_apkgs and
                pkg.verLE(downgrade_apkgs[lipkg.pkgtup])):
                continue # Skip older than "latest downgrade"
            downgrade_apkgs[lipkg.pkgtup] = pkg

        tx_return = []
        for ipkg in ipkgs:
            if ipkg.pkgtup not in downgrade_apkgs:
                continue
            txmbrs = self.tsInfo.addDowngrade(downgrade_apkgs[ipkg.pkgtup],ipkg)
            if not txmbrs: # Fail?
                continue
            self._add_prob_flags(rpm.RPMPROB_FILTER_OLDPACKAGE)
            tx_return.extend(txmbrs)

        return tx_return

    @staticmethod
    def _ui_nevra_dict(nevra_dict):
        n = nevra_dict['name']
        e = nevra_dict['epoch']
        v = nevra_dict['version']
        r = nevra_dict['release']
        a = nevra_dict['arch']

        if e and v and r:
            evr = '%s:%s-%s' % (e, v, r)
        elif v and r:
            evr = '%s-%s' % (e, v, r)
        elif e and v:
            evr = '%s:%s' % (e, v)
        elif v: # e and r etc. is just too weird to print
            evr = v
        else:
            evr = ''
        if n and evr:
            return '%s-%s' % (n, evr)
        if evr:
            return '*-%s' % evr
        if n:
            return n
        return '<unknown>'
        
    def _nevra_kwarg_parse(self, kwargs):
            
        returndict = {}
        
        if 'pkgtup' in kwargs:
            (n, a, e, v, r) = kwargs['pkgtup']
            returndict['name'] = n
            returndict['epoch'] = e
            returndict['arch'] = a
            returndict['version'] = v
            returndict['release'] = r
            return returndict

        returndict['name'] = kwargs.get('name')
        returndict['epoch'] = kwargs.get('epoch')
        returndict['arch'] = kwargs.get('arch')
        # get them as ver, version and rel, release - if someone
        # specifies one of each then that's kinda silly.
        returndict['version'] = kwargs.get('version')
        if returndict['version'] is None:
            returndict['version'] = kwargs.get('ver')

        returndict['release'] = kwargs.get('release')
        if returndict['release'] is None:
            returndict['release'] = kwargs.get('rel')

        return returndict

    def history_redo(self, transaction):
        """ Given a valid historical transaction object, try and repeat
            that transaction. """
        # NOTE: This is somewhat basic atm. ... see comment in undo.
        #  Also note that redo doesn't force install Dep-Install packages,
        # which is probably what is wanted the majority of the time.
        old_conf_obs = self.conf.obsoletes
        self.conf.obsoletes = False
        done = False
        for pkg in transaction.trans_data:
            if pkg.state == 'Reinstall':
                if self.reinstall(pkgtup=pkg.pkgtup):
                    done = True
        for pkg in transaction.trans_data:
            if pkg.state == 'Downgrade':
                try:
                    if self.downgrade(pkgtup=pkg.pkgtup):
                        done = True
                except yum.Errors.DowngradeError:
                    self.logger.critical(_('Failed to downgrade: %s'), pkg)
        for pkg in transaction.trans_data:
            if pkg.state == 'Update':
                if self.update(pkgtup=pkg.pkgtup):
                    done = True
                else:
                    self.logger.critical(_('Failed to upgrade: %s'), pkg)
        for pkg in transaction.trans_data:
            if pkg.state in ('Install', 'True-Install', 'Obsoleting'):
                if self.install(pkgtup=pkg.pkgtup):
                    done = True
        for pkg in transaction.trans_data:
            if pkg.state == 'Erase':
                if self.remove(pkgtup=pkg.pkgtup):
                    done = True
        self.conf.obsoletes = old_conf_obs
        return done

    def history_undo(self, transaction):
        """ Given a valid historical transaction object, try and undo
            that transaction. """
        # NOTE: This is somewhat basic atm. ... for instance we don't check
        #       that we are going from the old new version. However it's still
        #       better than the RHN rollback code, and people pay for that :).
        #  We turn obsoletes off because we want the specific versions of stuff
        # from history ... even if they've been obsoleted since then.
        old_conf_obs = self.conf.obsoletes
        self.conf.obsoletes = False
        done = False
        for pkg in transaction.trans_data:
            if pkg.state == 'Reinstall':
                if self.reinstall(pkgtup=pkg.pkgtup):
                    done = True
        for pkg in transaction.trans_data:
            if pkg.state == 'Updated':
                try:
                    if self.downgrade(pkgtup=pkg.pkgtup):
                        done = True
                except yum.Errors.DowngradeError:
                    self.logger.critical(_('Failed to downgrade: %s'), pkg)
        for pkg in transaction.trans_data:
            if pkg.state == 'Downgraded':
                if self.update(pkgtup=pkg.pkgtup):
                    done = True
                else:
                    self.logger.critical(_('Failed to upgrade: %s'), pkg)
        for pkg in transaction.trans_data:
            if pkg.state == 'Obsoleting':
                #  Note that obsoleting can mean anything, so if this is part of
                # something else, it should be done by now (so do nothing).
                if self.tsInfo.getMembers(pkg.pkgtup):
                    continue
                #  If not it should be an install/obsolete ... so remove it.
                if self.remove(pkgtup=pkg.pkgtup):
                    done = True
        for pkg in transaction.trans_data:
            if pkg.state in ('Dep-Install', 'Install', 'True-Install'):
                if self.remove(pkgtup=pkg.pkgtup):
                    done = True
        for pkg in transaction.trans_data:
            if pkg.state == 'Obsoleted':
                if self.install(pkgtup=pkg.pkgtup):
                    done = True
        for pkg in transaction.trans_data:
            if pkg.state == 'Erase':
                if self.install(pkgtup=pkg.pkgtup):
                    done = True
        self.conf.obsoletes = old_conf_obs
        return done

    def _retrievePublicKey(self, keyurl, repo=None, getSig=True):
        """
        Retrieve a key file
        @param keyurl: url to the key to retrieve
        Returns a list of dicts with all the keyinfo
        """
        key_installed = False
        
        msg = _('Retrieving key from %s') % keyurl
        self.verbose_logger.log(logginglevels.INFO_2, msg)
       
        # Go get the GPG key from the given URL
        try:
            url = misc.to_utf8(keyurl)
            if repo is None:
                opts = {'limit':9999}
                text = 'global/gpgkey'
            else:
                #  If we have a repo. use the proxy etc. configuration for it.
                # In theory we have a global proxy config. too, but meh...
                # external callers should just update.
                opts = repo._default_grabopts()
                text = repo.id + '/gpgkey'
            rawkey = urlgrabber.urlread(url, **opts)

        except urlgrabber.grabber.URLGrabError, e:
            raise Errors.YumBaseError(_('GPG key retrieval failed: ') +
                                      to_unicode(str(e)))
                                      
        # check for a .asc file accompanying it - that's our gpg sig on the key
        # suck it down and do the check
        sigfile = None
        valid_sig = False
        if getSig and repo and repo.gpgcakey:
            self.getCAKeyForRepo(repo, callback=repo.confirm_func)
            try:
                url = misc.to_utf8(keyurl + '.asc')
                opts = repo._default_grabopts()
                text = repo.id + '/gpgkeysig'
                sigfile = urlgrabber.urlopen(url, **opts)

            except urlgrabber.grabber.URLGrabError, e:
                sigfile = None

            if sigfile:
                if not misc.valid_detached_sig(sigfile, 
                                    StringIO.StringIO(rawkey), repo.gpgcadir):
                    #if we decide we want to check, even though the sig failed
                    # here is where we would do that
                    raise Errors.YumBaseError(_('GPG key signature on key %s does not match CA Key for repo: %s') % (url, repo.id))
                else:
                    msg = _('GPG key signature verified against CA Key(s)')
                    self.verbose_logger.log(logginglevels.INFO_2, msg)
                    valid_sig = True
            
        # Parse the key
        try:
            keys_info = misc.getgpgkeyinfo(rawkey, multiple=True)
        except ValueError, e:
            raise Errors.YumBaseError(_('Invalid GPG Key from %s: %s') % 
                                      (url, to_unicode(str(e))))
        keys = []
        for keyinfo in keys_info:
            thiskey = {}
            for info in ('keyid', 'timestamp', 'userid', 
                         'fingerprint', 'raw_key'):
                if info not in keyinfo:
                    raise Errors.YumBaseError, \
                      _('GPG key parsing failed: key does not have value %s') + info
                thiskey[info] = keyinfo[info]
            thiskey['hexkeyid'] = misc.keyIdToRPMVer(keyinfo['keyid']).upper()
            thiskey['valid_sig'] = valid_sig
            thiskey['has_sig'] = bool(sigfile)
            keys.append(thiskey)
        
        return keys

    def _getKeyImportMessage(self, info, keyurl, keytype='GPG'):
        msg = None
        if keyurl.startswith("file:"):
            fname = keyurl[len("file:"):]
            pkgs = self.rpmdb.searchFiles(fname)
            if pkgs:
                pkgs = sorted(pkgs)[-1]
                msg = (_('Importing %s key 0x%s:\n'
                         ' Userid : %s\n'
                         ' Package: %s (%s)\n'
                         ' From   : %s') %
                       (keytype, info['hexkeyid'], to_unicode(info['userid']),
                        pkgs, pkgs.ui_from_repo,
                        keyurl.replace("file://","")))
        if msg is None:
            msg = (_('Importing %s key 0x%s:\n'
                     ' Userid: "%s"\n'
                     ' From  : %s') %
                   (keytype, info['hexkeyid'], to_unicode(info['userid']),
                    keyurl.replace("file://","")))
        self.logger.critical("%s", msg)

    def getKeyForPackage(self, po, askcb = None, fullaskcb = None):
        """
        Retrieve a key for a package. If needed, prompt for if the key should
        be imported using askcb.
        
        @param po: Package object to retrieve the key of.
        @param askcb: Callback function to use for asking for permission to
                      import a key. This is verification, but also "choice".
                      Takes arguments of the po, the userid for the key, and
                      the keyid.
        @param fullaskcb: Callback function to use for asking for permission to
                          import a key. This is verification, but also "choice".
                          Differs from askcb in that it gets passed a
                          dictionary so that we can expand the values passed.
        """
        repo = self.repos.getRepo(po.repoid)
        keyurls = repo.gpgkey
        key_installed = False

        user_cb_fail = False
        for keyurl in keyurls:
            keys = self._retrievePublicKey(keyurl, repo)

            for info in keys:
                ts = self.rpmdb.readOnlyTS()
                # Check if key is already installed
                if misc.keyInstalled(ts, info['keyid'], info['timestamp']) >= 0:
                    self.logger.info(_('GPG key at %s (0x%s) is already installed') % (
                        keyurl, info['hexkeyid']))
                    continue
                
                if repo.gpgcakey and info['has_sig'] and info['valid_sig']:
                    key_installed = True
                else:
                    # Try installing/updating GPG key
                    self._getKeyImportMessage(info, keyurl)
                    rc = False
                    if self.conf.assumeyes:
                        rc = True
                        
                    # grab the .sig/.asc for the keyurl, if it exists
                    # if it does check the signature on the key
                    # if it is signed by one of our ca-keys for this repo or the global one
                    # then rc = True
                    # else ask as normal.

                    elif fullaskcb:
                        rc = fullaskcb({"po": po, "userid": info['userid'],
                                        "hexkeyid": info['hexkeyid'], 
                                        "keyurl": keyurl,
                                        "fingerprint": info['fingerprint'],
                                        "timestamp": info['timestamp']})
                    elif askcb:
                        rc = askcb(po, info['userid'], info['hexkeyid'])

                    if not rc:
                        user_cb_fail = True
                        continue
                    
                # Import the key
                ts = self.rpmdb.readOnlyTS()
                result = ts.pgpImportPubkey(misc.procgpgkey(info['raw_key']))
                if result != 0:
                    raise Errors.YumBaseError, \
                          _('Key import failed (code %d)') % result
                self.logger.info(_('Key imported successfully'))
                key_installed = True

        if not key_installed and user_cb_fail:
            raise Errors.YumBaseError, _("Didn't install any keys")

        if not key_installed:
            raise Errors.YumBaseError, \
                  _('The GPG keys listed for the "%s" repository are ' \
                  'already installed but they are not correct for this ' \
                  'package.\n' \
                  'Check that the correct key URLs are configured for ' \
                  'this repository.') % (repo.name)

        # Check if the newly installed keys helped
        result, errmsg = self.sigCheckPkg(po)
        if result != 0:
            self.logger.info(_("Import of key(s) didn't help, wrong key(s)?"))
            raise Errors.YumBaseError, errmsg
    
    def _getAnyKeyForRepo(self, repo, destdir, keyurl_list, is_cakey=False, callback=None):
        """
        Retrieve a key for a repository If needed, prompt for if the key should
        be imported using callback
        
        @param repo: Repository object to retrieve the key of.
        @param destdir: destination of the gpg pub ring
        @param keyurl_list: list of urls for gpg keys
        @param is_cakey: bool - are we pulling in a ca key or not
        @param callback: Callback function to use for asking for permission to
                         import a key. This is verification, but also "choice".
                         Takes a dictionary of key info.
        """

        key_installed = False
        user_cb_fail = False
        for keyurl in keyurl_list:
            keys = self._retrievePublicKey(keyurl, repo, getSig=not is_cakey)
            for info in keys:
                # Check if key is already installed
                if hex(int(info['keyid']))[2:-1].upper() in misc.return_keyids_from_pubring(destdir):
                    self.logger.info(_('GPG key at %s (0x%s) is already imported') % (
                        keyurl, info['hexkeyid']))
                    key_installed = True
                    continue
                # Try installing/updating GPG key
                if is_cakey:
                    # know where the 'imported_cakeys' file is
                    ikf = repo.base_persistdir + '/imported_cakeys'
                    keytype = 'CA'
                    cakeys  = []
                    try:
                        cakeys_d = open(ikf, 'r').read()
                        cakeys = cakeys_d.split('\n')
                    except (IOError, OSError):
                        pass
                    if str(info['hexkeyid']) in cakeys:
                        key_installed = True
                else:
                    keytype = 'GPG'
                    if repo.gpgcakey and info['has_sig'] and info['valid_sig']:
                        key_installed = True
                        
                if not key_installed:
                    self._getKeyImportMessage(info, keyurl, keytype)
                    rc = False
                    if self.conf.assumeyes:
                        rc = True
                    elif callback:
                        rc = callback({"repo": repo, "userid": info['userid'],
                                        "hexkeyid": info['hexkeyid'], "keyurl": keyurl,
                                        "fingerprint": info['fingerprint'],
                                        "timestamp": info['timestamp']})


                    if not rc:
                        user_cb_fail = True
                        continue
                
                # Import the key
                result = misc.import_key_to_pubring(info['raw_key'], info['hexkeyid'], gpgdir=destdir)
                if not result:
                    raise Errors.YumBaseError, _('Key import failed')
                self.logger.info(_('Key imported successfully'))
                key_installed = True
                # write out the key id to imported_cakeys in the repos basedir
                if is_cakey and key_installed:
                    if info['hexkeyid'] not in cakeys:
                        ikfo = open(ikf, 'a')
                        try:
                            ikfo.write(info['hexkeyid']+'\n')
                            ikfo.flush()
                            ikfo.close()
                        except (IOError, OSError):
                            # maybe a warning - but in general this is not-critical, just annoying to the user
                            pass

        if not key_installed and user_cb_fail:
            raise Errors.YumBaseError, _("Didn't install any keys for repo %s") % repo

        if not key_installed:
            raise Errors.YumBaseError, \
                  _('The GPG keys listed for the "%s" repository are ' \
                  'already installed but they are not correct.\n' \
                  'Check that the correct key URLs are configured for ' \
                  'this repository.') % (repo.name)

    def getKeyForRepo(self, repo, callback=None):
        """
        Retrieve a key for a repository If needed, prompt for if the key should
        be imported using callback
        
        @param repo: Repository object to retrieve the key of.
        @param callback: Callback function to use for asking for verification
                          of a key. Takes a dictionary of key info.
        """
        self._getAnyKeyForRepo(repo, repo.gpgdir, repo.gpgkey, is_cakey=False, callback=callback)

    def getCAKeyForRepo(self, repo, callback=None):
        """
        Retrieve a key for a repository If needed, prompt for if the key should
        be imported using callback
        
        @param repo: Repository object to retrieve the key of.
        @param callback: Callback function to use for asking for verification
                          of a key. Takes a dictionary of key info.
        """

        self._getAnyKeyForRepo(repo, repo.gpgcadir, repo.gpgcakey, is_cakey=True, callback=callback)

    def _limit_installonly_pkgs(self):
        """ Limit packages based on conf.installonly_limit, if any of the
            packages being installed have a provide in conf.installonlypkgs.
            New in 3.2.24: Obey yumdb_info.installonly data. """

        def _sort_and_filter_installonly(pkgs):
            """ Allow the admin to specify some overrides fo installonly pkgs.
                using the yumdb. """
            ret_beg = []
            ret_mid = []
            ret_end = []
            for pkg in sorted(pkgs):
                if 'installonly' not in pkg.yumdb_info:
                    ret_mid.append(pkg)
                    continue

                if pkg.yumdb_info.installonly == 'keep':
                    continue

                if True: # Don't to magic sorting, yet
                    ret_mid.append(pkg)
                    continue

                if pkg.yumdb_info.installonly == 'remove-first':
                    ret_beg.append(pkg)
                elif pkg.yumdb_info.installonly == 'remove-last':
                    ret_end.append(pkg)
                else:
                    ret_mid.append(pkg)

            return ret_beg + ret_mid + ret_end

        if self.conf.installonly_limit < 1 :
            return 
            
        toremove = []
        #  We "probably" want to use either self.ts or self.rpmdb.ts if either
        # is available. However each ts takes a ref. on signals generally, and
        # SIGINT specifically, so we _must_ have got rid of all of the used tses
        # before we try downloading. This is called from buildTransaction()
        # so self.rpmdb.ts should be valid.
        ts = self.rpmdb.readOnlyTS()
        (cur_kernel_v, cur_kernel_r) = misc.get_running_kernel_version_release(ts)
        install_only_names = set(self.conf.installonlypkgs)
        for m in self.tsInfo.getMembers():
            if m.ts_state not in ('i', 'u'):
                continue
            if m.reinstall:
                continue

            po_names = set([m.name] + m.po.provides_names)
            if not po_names.intersection(install_only_names):
                continue

            installed = self.rpmdb.searchNevra(name=m.name)
            installed = _sort_and_filter_installonly(installed)
            if len(installed) < self.conf.installonly_limit - 1:
                continue # we're adding one

            numleft = len(installed) - self.conf.installonly_limit + 1
            for po in installed:
                if (po.version, po.release) == (cur_kernel_v, cur_kernel_r): 
                    # don't remove running
                    continue
                if numleft == 0:
                    break
                toremove.append((po,m))
                numleft -= 1
                        
        for po,rel in toremove:
            txmbr = self.tsInfo.addErase(po)
            # Add a dep relation to the new version of the package, causing this one to be erased
            # this way skipbroken, should clean out the old one, if the new one is skipped
            txmbr.depends_on.append(rel)

    def processTransaction(self, callback=None,rpmTestDisplay=None, rpmDisplay=None):
        '''
        Process the current Transaction
        - Download Packages
        - Check GPG Signatures.
        - Run Test RPM Transaction
        - Run RPM Transaction
        
        callback.event method is called at start/end of each process.
        
        @param callback: callback object (must have an event method)
        @param rpmTestDisplay: Name of display class to use in RPM Test Transaction 
        @param rpmDisplay: Name of display class to use in RPM Transaction 
        '''
        
        if not callback:
            callback = callbacks.ProcessTransNoOutputCallback()
        
        # Download Packages
        callback.event(callbacks.PT_DOWNLOAD)
        pkgs = self._downloadPackages(callback)
        # Check Package Signatures
        if pkgs != None:
            callback.event(callbacks.PT_GPGCHECK)
            self._checkSignatures(pkgs,callback)
        # Run Test Transaction
        callback.event(callbacks.PT_TEST_TRANS)
        self._doTestTransaction(callback,display=rpmTestDisplay)
        # Run Transaction
        callback.event(callbacks.PT_TRANSACTION)
        self._doTransaction(callback,display=rpmDisplay)
    
    def _downloadPackages(self,callback):
        ''' Download the need packages in the Transaction '''
        # This can be overloaded by a subclass.    
        dlpkgs = map(lambda x: x.po, filter(lambda txmbr:
                                            txmbr.ts_state in ("i", "u"),
                                            self.tsInfo.getMembers()))
        # Check if there is something to do
        if len(dlpkgs) == 0:
            return None
        # make callback with packages to download                                    
        callback.event(callbacks.PT_DOWNLOAD_PKGS,dlpkgs)
        try:
            probs = self.downloadPkgs(dlpkgs)

        except IndexError:
            raise Errors.YumBaseError, [_("Unable to find a suitable mirror.")]
        if len(probs) > 0:
            errstr = [_("Errors were encountered while downloading packages.")]
            for key in probs:
                errors = misc.unique(probs[key])
                for error in errors:
                    errstr.append("%s: %s" % (key, error))

            raise Errors.YumDownloadError, errstr
        return dlpkgs

    def _checkSignatures(self,pkgs,callback):
        ''' The the signatures of the downloaded packages '''
        # This can be overloaded by a subclass.    
        for po in pkgs:
            result, errmsg = self.sigCheckPkg(po)
            if result == 0:
                # Verified ok, or verify not req'd
                continue            
            elif result == 1:
                self.getKeyForPackage(po, self._askForGPGKeyImport)
            else:
                raise Errors.YumGPGCheckError, errmsg

        return 0
        
    def _askForGPGKeyImport(self, po, userid, hexkeyid):
        ''' 
        Ask for GPGKeyImport 
        This need to be overloaded in a subclass to make GPG Key import work
        '''
        return False
    
    def _doTestTransaction(self,callback,display=None):
        ''' Do the RPM test transaction '''
        self.initActionTs()
        # save our dsCallback out
        dscb = self.dsCallback
        self.dsCallback = None # dumb, dumb dumb dumb!
        self.populateTs( keepold=0 ) # sigh

        # This can be overloaded by a subclass.    
        self.verbose_logger.log(logginglevels.INFO_2, 
                 _('Running Transaction Check'))
        msgs = self._run_rpm_check()
        if msgs:
            rpmlib_only = True
            for msg in msgs:
                if msg.startswith('rpmlib('):
                    continue
                rpmlib_only = False
            if rpmlib_only:
                retmsgs = [_("ERROR You need to update rpm to handle:")]
                retmsgs.extend(msgs)
                raise Errors.YumRPMCheckError, retmsgs
            retmsgs = [_('ERROR with transaction check vs depsolve:')]
            retmsgs.extend(msgs) 
            retmsgs.append(_('Please report this error at %s') 
                                         % self.conf.bugtracker_url)
            raise Errors.YumRPMCheckError,retmsgs
        
        tsConf = {}
        for feature in ['diskspacecheck']: # more to come, I'm sure
            tsConf[feature] = getattr( self.conf, feature )
        #
        testcb = RPMTransaction(self, test=True)
        # overwrite the default display class
        if display:
            testcb.display = display
  
        tserrors = self.ts.test( testcb, conf=tsConf )
        del testcb
  
        if len( tserrors ) > 0:
            errstring =  _('Test Transaction Errors: ')
            for descr in tserrors:
                errstring += '  %s\n' % descr 
            raise Errors.YumTestTransactionError, errstring

        del self.ts
        # put back our depcheck callback
        self.dsCallback = dscb


    def _doTransaction(self,callback,display=None):
        ''' do the RPM Transaction '''
        # This can be overloaded by a subclass.    
        self.initActionTs() # make a new, blank ts to populate
        self.populateTs( keepold=0 ) # populate the ts
        self.ts.check() # required for ordering
        self.ts.order() # order
        cb = RPMTransaction(self,display=SimpleCliCallBack)
        # overwrite the default display class
        if display:
            cb.display = display
        self.runTransaction( cb=cb )

    def _run_rpm_check(self):
        results = []
        self.ts.check()
        for prob in self.ts.problems():
            #  Newer rpm (4.8.0+) has problem objects, older have just strings.
            #  Should probably move to using the new objects, when we can. For
            # now just be compatible.
            results.append(to_str(prob))

        return results

    def add_enable_repo(self, repoid, baseurls=[], mirrorlist=None, **kwargs):
        """add and enable a repo with just a baseurl/mirrorlist and repoid
           requires repoid and at least one of baseurl and mirrorlist
           additional optional kwargs are:
           variable_convert=bool (defaults to true)
           and any other attribute settable to the normal repo setup
           ex: metadata_expire, enable_groups, gpgcheck, cachedir, etc
           returns the repo object it added"""
        # out of place fixme - maybe we should make this the default repo addition
        # routine and use it from getReposFromConfigFile(), etc.
        newrepo = yumRepo.YumRepository(repoid)
        newrepo.name = repoid
        newrepo.basecachedir = self.conf.cachedir

        var_convert = kwargs.get('variable_convert', True)
        
        if baseurls:
            replaced = []
            if var_convert:
                for baseurl in baseurls:
                    if baseurl:
                        replaced.append(varReplace(baseurl, self.conf.yumvar))
            else:
                replaced = baseurls
            newrepo.baseurl = replaced

        if mirrorlist:
            if var_convert:
                mirrorlist = varReplace(mirrorlist, self.conf.yumvar)
            newrepo.mirrorlist = mirrorlist

        # setup the repo
        newrepo.setup(cache=self.conf.cache)

        # some reasonable defaults, (imo)
        newrepo.enablegroups = True
        newrepo.metadata_expire = 0
        newrepo.gpgcheck = self.conf.gpgcheck
        newrepo.repo_gpgcheck = self.conf.repo_gpgcheck
        newrepo.basecachedir = self.conf.cachedir
        newrepo.base_persistdir = self.conf._repos_persistdir

        for key in kwargs.keys():
            if not hasattr(newrepo, key): continue # skip the ones which aren't vars
            setattr(newrepo, key, kwargs[key])
        
        # add the new repo
        self.repos.add(newrepo)
        # enable the main repo  
        self.repos.enableRepo(newrepo.id)
        return newrepo

    def setCacheDir(self, force=False, tmpdir=None, reuse=True,
                    suffix='/$basearch/$releasever'):
        ''' Set a new cache dir, using misc.getCacheDir() and var. replace
            on suffix. '''

        if not force and os.geteuid() == 0:
            return True # We are root, not forced, so happy with the global dir.
        if tmpdir is None:
            tmpdir = os.getenv('TMPDIR')
        if tmpdir is None: # Note that TMPDIR isn't exported by default :(
            tmpdir = '/var/tmp'
        try:
            cachedir = misc.getCacheDir(tmpdir, reuse)
        except (IOError, OSError), e:
            self.logger.critical(_('Could not set cachedir: %s') % str(e))
            cachedir = None
            
        if cachedir is None:
            return False # Tried, but failed, to get a "user" cachedir

        cachedir += varReplace(suffix, self.conf.yumvar)
        if hasattr(self, 'prerepoconf'):
            self.prerepoconf.cachedir = cachedir
        else:
            self.repos.setCacheDir(cachedir)
        self.conf.cachedir = cachedir
        return True # We got a new cache dir

    def _does_this_update(self, pkg1, pkg2):
        """returns True if pkg1 can update pkg2, False if not. 
           This only checks if it can be an update it does not check if
           it is obsoleting or anything else."""
        
        if pkg1.name != pkg2.name:
            return False
        if pkg1.verLE(pkg2):
            return False
        if pkg1.arch not in self.arch.archlist:
            return False
        if rpmUtils.arch.canCoinstall(pkg1.arch, pkg2.arch):
            return False
        if self.allowedMultipleInstalls(pkg1):
            return False
            
        return True    

    def _store_config_in_history(self):
        self.history.write_addon_data('config-main', self.conf.dump())
        myrepos = ''
        for repo in self.repos.listEnabled():
            myrepos += repo.dump()
            myrepos += '\n'
        self.history.write_addon_data('config-repos', myrepos)
        
    def verify_plugins_cb(self, verify_package):
        """ Callback to call a plugin hook for pkg.verify(). """
        self.plugins.run('verify_package', verify_package=verify_package)
        return verify_package

    def save_ts(self, filename=None, auto=False):
        """saves out a transaction to .yumtx file to be loaded later"""
        
        if self.tsInfo._unresolvedMembers:
            if auto:
                self.logger.critical(_("Dependencies not solved. Will not save unresolved transaction."))
                return
            raise Errors.YumBaseError(_("Dependencies not solved. Will not save unresolved transaction."))
        
        if not filename:
            prefix = 'yum_save_tx-%s' % time.strftime('%Y-%m-%d-%H-%M')
            fd,filename = tempfile.mkstemp(suffix='.yumtx', prefix=prefix)
            f = os.fdopen(fd, 'w')
        else:
            f = open(filename, 'w')
        
        self._ts_save_file = filename
        
        msg = "%s\n" % self.rpmdb.simpleVersion(main_only=True)[0]
        msg += "%s\n" % self.ts.getTsFlags()
        if self.tsInfo.pkgSack is None: # rm Transactions don't have pkgSack
            msg += "0\n"
        else:
            msg += "%s\n" % len(self.repos.listEnabled())
            for r in self.repos.listEnabled():
                msg += "%s:%s:%s\n" % (r.id, len(r.sack), r.repoXML.revision)

        msg += "%s\n" % len(self.tsInfo.getMembers())
        for txmbr in self.tsInfo.getMembers():
            msg += txmbr._dump()
        try:
            f.write(msg)
            f.close()
        except (IOError, OSError), e:
            self._ts_save_file = None
            if auto:
                self.logger.critical(_("Could not save transaction file %s: %s") % (filename, str(e)))
            else:
                raise Errors.YumBaseError(_("Could not save transaction file %s: %s") % (filename, str(e)))

        
    def load_ts(self, filename, ignorerpm=None, ignoremissing=None):
        """loads a transaction from a .yumtx file"""
        # check rpmversion - if not match throw a fit
        # check repoversions  (and repos)- if not match throw a fit
        # load each txmbr - if pkgs being updated don't exist, bail w/error
        # setup any ts flags
        # setup cmds for history/yumdb to know about
        # return txmbrs loaded
        try:
            data = open(filename, 'r').readlines()
        except (IOError, OSError), e:
            raise Errors.YumBaseError(_("Could not access/read saved transaction %s : %s") % (filename, str(e)))
            

        if ignorerpm is None:
            ignorerpm = self.conf.loadts_ignorerpm
        if ignoremissing is None:
            ignoremissing = self.conf.loadts_ignoremissing
            
        # data format
        # 0 == rpmdb version
        # 1 == tsflags
        # 2 == numrepos
        # 3:numrepos = repos
        # 3+numrepos = num pkgs
        # 3+numrepos+1 -> EOF= txmembers
        
        # rpm db ver
        rpmv = data[0].strip()
        if rpmv != str(self.rpmdb.simpleVersion(main_only=True)[0]):
            msg = _("rpmdb ver mismatched saved transaction version, ")
            if ignorerpm:
                msg += _(" ignoring, as requested.")
                self.logger.critical(_(msg))
            else:
                msg += _(" aborting.")
                raise Errors.YumBaseError(msg)
        
        # tsflags
        # FIXME - probably should let other tsflags play nicely together
        #         so someone can add --nogpgcheck or --nodocs or --nodiskspace or some nonsense and have it work
        try:
            tsflags = int(data[1].strip())
        except (ValueError, IndexError), e:
            msg = _("cannot find tsflags or tsflags not integer.")
            raise Errors.YumBaseError(msg)

        self.ts.setFlags(tsflags)
        
        # repos
        numrepos = int(data[2].strip())
        repos = []
        rindex=3+numrepos
        for r in data[3:rindex]:
            repos.append(r.strip().split(':'))

        # pkgs/txmbrs
        numpkgs = int(data[rindex].strip())

        pkgstart = rindex + 1
        
        pkgcount = 0
        pkgprob = False
        curpkg = None
        for l in data[pkgstart:]:
            l = l.rstrip()
            # our main txmbrs
            if l.startswith('mbr:'):
                if curpkg:
                    self.tsInfo.add(curpkg)
                    if curpkg in self.tsInfo._unresolvedMembers and not missingany:
                        self.tsInfo._unresolvedMembers.remove(curpkg)

                missingany = False
                pkgtup, current_state = l.split(':')[1].strip().split(' ')
                current_state = int(current_state.strip())
                pkgtup = tuple(pkgtup.strip().split(','))
                try:
                    if current_state == TS_INSTALL:
                        po = self.getInstalledPackageObject(pkgtup)
                    elif current_state == TS_AVAILABLE:
                        po = self.getPackageObject(pkgtup)
                    else:
                        msg = _("Found txmbr in unknown current state: %s" % current_state)
                        raise Errors.YumBaseError(msg)
                except Errors.YumBaseError, e:
                    missingany = True
                    msg = _("Could not find txmbr: %s in state %s" % (str(pkgtup), current_state))
                    if not ignoremissing:
                        raise Errors.YumBaseError(msg)
                    else:
                        self.logger.critical(msg)
                else:
                    pkgcount += 1
                    curpkg = transactioninfo.TransactionMember(po)
                    curpkg.current_state = current_state
                    continue

            l = l.strip()
            k,v = l.split(':', 1)
            v = v.lstrip()
            # attributes of our txmbrs
            if k in ('isDep', 'reinstall'):
                v = v.strip().lower()
                if v == 'false':
                    setattr(curpkg, k, False)
                elif v == 'true':
                    setattr(curpkg, k, True)
            elif k in ('output_state'):
                setattr(curpkg, k, int(v.strip()))
            elif k in ('groups'):
                curpkg.groups.extend(v.split(' '))
            # the relationships to our main txmbrs
            elif k in ('updated_by', 'obsoleted_by', 'downgraded_by', 
                       'downgrades', 'updates', 'obsoletes', 'depends_on'):
                for pkgspec in v.strip().split(' '):
                    pkgtup, origin  = pkgspec.split('@')
                    try:
                        if origin == 'i':
                            po = self.getInstalledPackageObject(tuple(pkgtup.split(',')))
                        else:
                            po = self.getPackageObject(tuple(pkgtup.split(',')))
                    except Errors.YumBaseError, e:
                        msg = _("Could not find txmbr: %s from origin: %s" % (str(pkgtup), origin))
                        self.logger.critical(msg)
                        missingany = True
                    else:
                        curlist = getattr(curpkg, k)
                        curlist.append(po)
                        setattr(curpkg, k, curlist)
            elif k in ('relatedto'):
                for item in v.split(' '):
                    pkgspec, rel = item.split(':')
                    pkgtup,origin = pkgspec.split('@')
                    try:
                        if origin == 'i':
                            po = self.getInstalledPackageObject(tuple(pkgtup.split(',')))
                        else:
                            po = self.getPackageObject(tuple(pkgtup.split(',')))
                    except Errors.YumBaseError, e:
                        msg = _("Could not find txmbr: %s from origin: %s" % (str(pkgtup), origin))
                        self.logger.critical(msg)
                        missingany = True
                    else:
                        curlist = getattr(curpkg, k)
                        curlist.append((po,rel))
                        setattr(curpkg, k, curlist)
                        
            # the plain strings
            else: #ts_state, reason
                setattr(curpkg, k, v.strip())
            
            if missingany:
                pkgprob = True
                
        # make sure we get the last one in!
        self.tsInfo.add(curpkg)
        if curpkg in self.tsInfo._unresolvedMembers:
            self.tsInfo._unresolvedMembers.remove(curpkg)

            
        if numpkgs != pkgcount:
            pkgprob = True
            
        if pkgprob:
            msg = _("Transaction members, relations are missing or ts has been modified,")
            if ignoremissing:
                msg += _(" ignoring, as requested. You must redepsolve!")
                self.logger.critical(msg)
            else:
                msg += _(" aborting.")
                raise Errors.YumBaseError(msg)
            
        return self.tsInfo.getMembers()

    def _remove_old_deps(self):
        """take the set of pkgs being removed and remove any pkgs which are:
           1. not required anymore
           2. marked as a 'dep' in the 'reason' in the yumdb. """
        found_leaves = set()
        checked = set()
        beingremoved = [ t.po for t in self.tsInfo.getMembersWithState(output_states=TS_REMOVE_STATES) ]
        # cache previously examined packages
        okay_to_remove = {}
        for i in self.rpmdb.returnPackages():
            okay_to_remove[i] = True

        for pkg in beingremoved: # for each package required by the pkg being removed
            #print 'removal: %s' % pkg.name
            for required in pkg.required_packages():
                #if required in checked:
                #    continue # if we've already checked it, skip it.
                #checked.add(required)
                if required.yumdb_info.get('reason', '') != 'dep': # if the required pkg is not a dep, then skip it
                    okay_to_remove[required] = False
                    continue
                if required in beingremoved:
                    continue
                if self._has_needed_revdeps(required, beingremoved, okay_to_remove):
                    continue
                still_needed = False
                for requiring in required.requiring_packages(): # so we have required deps - look at all the pkgs which require them
                    if requiring == required: # if they are self-requiring skip them
                        continue
                        
                # go through the stuff in the ts to be installed - make sure none of that needs the required pkg, either.
                for (provn,provf,provevr) in required.provides:
                    if self.tsInfo.getNewRequires(provn, provf, provevr).keys():
                        still_needed = True
                        okay_to_remove[required] = False
                        break
                for fn in required.filelist + required.dirlist:
                    if self.tsInfo.getNewRequires(fn, None,(None,None,None)).keys():
                        okay_to_remove[required] = False
                        still_needed = True
                        break
                            
                    #for tbi_pkg in self.tsInfo.getMembersWithState(output_states=TS_INSTALL_STATES):
                    #   for reqtuple in tbi_pkg.po.requires:
                    #        if required.provides_for(reqtuple):
                    #            still_needed = True
                    #            break
                
                if not still_needed:
                    print '---> Marking %s to be removed - no longer needed by %s' % (required.name, pkg.name)
                    txmbrs = self.remove(po=required)

                    for txmbr in txmbrs:
                        txmbr.setAsDep(po=pkg)
                        if txmbr.po not in beingremoved:
                            beingremoved.append(txmbr.po)
                        found_leaves.add(txmbr)
        self.verbose_logger.log(logginglevels.INFO_2, "Found and removing %s unneeded dependencies" % len(found_leaves))
            
    # Checks if pkg has any reverse deps which cannot be removed. 
    # Currently this only checks the install reason for each revdep, 
    # but we may want to check for other reasons that would  
    # prevent the revdep from being removed (e.g. protected)
    def _has_needed_revdeps(self, pkg, beingremoved, ok_to_remove):
        # check if we've already found this package to have user-installed deps
        if not ok_to_remove[pkg]:
            # Debugging output
            self.verbose_logger.log(logginglevels.DEBUG_2, _("%s has been visited already and cannot be removed."), pkg)
            return True
        # Debugging output
        self.verbose_logger.log(logginglevels.DEBUG_2, _("Examining revdeps of %s"), pkg)
        # track which pkgs we have visited already
        visited = {}
        for po in self.rpmdb.returnPackages():
            visited[po] = False
        # no need to consider packages that are already being removed
        for po in beingremoved:
            visited[po] = True
        stack = []
        stack.append(pkg)
        # depth-first search
        while stack:
            curpkg = stack[-1]
            if not visited[curpkg]:
                if not ok_to_remove[curpkg]:
                    # Debugging output
                    self.verbose_logger.log(logginglevels.DEBUG_2, _("%s has been visited already and cannot be removed."), pkg)
                    ok_to_remove[pkg] = False
                    return True
                if curpkg.yumdb_info.get('reason', '') != 'dep':
                    # Debugging output
                    self.verbose_logger.log(logginglevels.DEBUG_2, _("%s has revdep %s which was user-installed."), pkg, curpkg)
                    ok_to_remove[pkg] = False
                    return True
                visited[curpkg] = True
            all_leaves_visited = True
            leaves = curpkg.requiring_packages()
            for leaf in leaves:
                if not visited[leaf]:
                    stack.append(leaf)
                    all_leaves_visited = False
                    break
            if all_leaves_visited:
                stack.pop()
        # Debugging output
        self.verbose_logger.log(logginglevels.DEBUG_2, _("%s has no user-installed revdeps."), pkg)
        return False

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python2.7/dist-packages/yum/__init__.pyc                                                    0100644 0000000 0000000 00000452101 13077704344 020215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  Z  d d l Z d d l Z d d l Z d   Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z e j j a e j j Z d d l Z d d l m Z m Z d d l Z d d l Z d d l Z d d l m Z m Z m Z m Z d d l  m! Z! d d l" Z d d l# Z# d d l$ Z$ d d l% m& Z& d d l' Z' d d l( m) Z) m* Z* d d l+ Z+ d d l, Z, d d	 l- m. Z. m/ Z/ d d
 l0 m1 Z1 d d l2 m3 Z3 m4 Z4 m5 Z5 d d l6 Z6 d d l7 Z7 d d l8 Z8 d d l9 Z9 d d l: Z: d d l; Z d d l< Z< e< j= d e j>  d d l? m@ Z@ mA ZA d d l? mB ZB mC ZC mD ZD d d l? mE ZE mF ZF d d lG Td d lH mI ZI mJ ZJ d d l mK ZK mL ZL d d lM ZM d d lN ZN d d lO mP ZO d d l- mQ ZQ d ZR eS g  eR jT d  D] ZU eV eU  ^ q- ZW eQ jX jY d eR 7_Y d d  d     YZZ d d! d     YZ[ d d" d     YZ\ d e6 j] f d     YZ^ d S(#   s   
The Yum RPM software updater.
iNc         C   sX   t  t d  s d Sy6 t g  t j D] } t |  ^ q#  } | |  k SWn d SXd S(   s    Check if rpm is at least the current vertup. Can return False/True/None
        as rpm hasn't had version info for a long time. t   __version_info__N(   t   hasattrt   rpmt   Nonet   tupleR    t   int(   t   vertupt   numt   vi(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _rpm_ver_atleast   s    ((   t   ParsingErrort   ConfigParser(   t   archDifferencet   canCoinstallt   ArchStoraget   isMultiLibArch(   t
   compareEVR(   t   RepoStorage(   t   ConfigPreProcessort
   varReplace(   t
   URLGrabbert   URLGrabError(   t   format_number(   t   packagesNewestByNamet   packagesNewestByNameArcht   ListPackageSackt   ignore(   t   parsePackagest   comparePoEVR(   t   YumAvailablePackaget   YumLocalPackaget   YumInstalledPackage(   t   YumUrlPackaget   YumNotFoundPackage(   t   *(   t   RPMTransactiont   SimpleCliCallBack(   t
   to_unicodet   to_str(   t   proxy(   t   default_grabbers   3.4.3t   .s    yum/t   _YumPreBaseConfc           B   s   e  Z d  Z d   Z RS(   s   This is the configuration interface for the YumBase configuration.
       So if you want to change if plugins are on/off, or debuglevel/etc.
       you tweak it here, and when yb.conf does it's thing ... it happens. c         C   s   d |  _  d |  _ t |  _ t j f |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   Ns   /etc/yum/yum.conft   /(   t   fnt   roott   Truet   init_pluginst   pluginst	   TYPE_COREt   plugin_typesR   t	   optparsert
   debuglevelt
   errorlevelt   disabled_pluginst   enabled_pluginst   syslog_identt   syslog_facilityt   syslog_devicet   archt
   releasevert   uuid(   t   self(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   __init__m   s    													(   t   __name__t
   __module__t   __doc__R?   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR*   h   s   t   _YumPreRepoConfc           B   s   e  Z d  Z d   Z RS(   s   This is the configuration interface for the repos configuration.
       So if you want to change callbacks etc. you tweak it here, and when
       yb.repos does it's thing ... it happens. c         C   sU   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  S(   N(
   R   t   progressbart   callbackt   failure_callbackt   interrupt_callbackt   confirm_funct   gpg_import_funct   gpgca_import_funct   cachedirt   cache(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR?      s    								(   R@   RA   RB   R?   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRC      s   t   _YumCostExcludec           B   s    e  Z d  Z d   Z d   Z RS(   sW    This excludes packages that are in repos. of lower cost than the passed
        repo. c         C   s"   t  |  |  _ t  |  |  _ d  S(   N(   t   weakreft   repot   _repos(   R>   RO   t   repos(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR?      s    c         C   sM   xF |  j  j   D]5 } | j |  j j k r/ Pn  | | j j k r t Sq Wt S(   N(   RP   t   listEnabledt   costRO   t   sackt   _pkgtup2pkgsR.   t   False(   R>   t   pkgtupRO   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   __contains__   s    (   R@   RA   RB   R?   RX   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRM      s   	t   YumBasec        	   B   s  e  Z d  Z d   Z d   Z d   Z d   Z d d  Z d d e e	 j
 f e e e d	  Z d
   Z e e d d  Z d   Z e e d  Z d   Z d   Z d   Z e e e e e e d  Z d   Z d   Z d   Z d   Z e d  Z e e d  Z d   Z e e d  Z e e d  Z d   Z d   Z  d   Z! d   Z" d    Z# d!   Z$ d"   Z% d#   Z& e' d$ d%   d& d'   d( d)   d* d+  Z( e' d$ d,   d& d-   d( d.   d* d/  Z) e' d$ d0   d& d1   d( d2   d* d3  Z* e' d$ d4   d& d5   d( d6   d* d7  Z+ e' d$ d8   d& d9   d( d:   d* d;  Z, e' d$ d<   d( d=   d* d>  Z- e' d$ d?   d& d@   d( dA   d* dB  Z. e' d$ dC   d& dD   d( dE   d* dF  Z/ e' d$ dG   d& dH   d( dI   d* dJ  Z0 e' d$ dK   d& dL   d( dM   d* dN  Z1 dO   Z2 dP   Z3 e dQ  Z4 e dR  Z5 dS   Z6 dT   Z7 dU   Z8 dV   Z9 dW   Z: dX   Z; dY   Z< dZ   Z= d[   Z> d\   Z? d]   Z@ d^   ZA d_   ZB d`   ZC e e e e g  da  ZD db   ZE e dc  ZF dd   ZG e de  ZH df   ZI eJ dg  ZK e dh  ZL di dj dk  ZM dl   ZN dm   ZO dn   ZP e e do  ZQ dp   ZR dq   ZS dr   ZT ds   ZU dt   ZV du   ZW dv   ZX dw   ZY dx   ZZ dy   Z[ dz   Z\ d{   Z] d| e e e d}  Z^ d~   Z_ e e e e d  Z` d   Za e d  Zb e e d  Zc d e e d  Zd d   Ze d   Zf g  e d  Zg e d  Zh e d  Zi d   Zj d   Zk d   Zl d   Zm d   Zn d   Zo e e d  Zp d   Zq d   Zr d   Zs d   Zt d   Zu d   Zv d   Zw d   Zx d   Zy e d  Zz d   Z{ d   Z| d   Z} e e e d  Z~ e d  Z e e d  Z e d  Z e d  Z e d  Z d   Z e d  Z e d    Z d   Z d   Z d   Z e e d  Z d d  Z e e d  Z e e d  Z e d  Z e d  Z d   Z e e e d  Z d   Z d   Z d   Z e d  Z e d  Z d   Z g  e d  Z e e e d d  Z d   Z d   Z d   Z e e d  Z e e d  Z d   Z d   Z RS(   s   This is a primary structure and base class. It houses the objects and
       methods needed to perform most things in yum. It is almost an abstract
       class in that you will need to add your own class above it for most
       real use.c         C   s#  t  j j |   d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ g  |  _ i  |  _ i  |  _ t j d  |  _ t j d  |  _ t |  _ t |   |  _ i  |  _ |  j   g  |  _ d  |  _ t   |  _ t   |  _  t!   |  _" t#   |  _$ g  |  _% d  S(   Ns   yum.YumBases   yum.verbose.YumBase(&   t   depsolvet   DepsolveR?   R   t   _conft   _tsInfot   _rpmdbt   _upt   _compst   _historyt   _pkgSackt	   _lockfilet   _tagst   _ts_save_filet   skipped_packagest   _not_found_at   _not_found_it   loggingt	   getLoggert   loggert   verbose_loggerRV   t   _override_sigchecksR   RP   t   repo_setoptst   disablePluginst   localPackagest   mediagrabberR   R;   R*   t   preconfRC   t   prerepoconft   sett   run_with_package_namest   _cleanup(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR?      s6    															
		c         C   s=   |  j    |  j   |  j   x |  j D] } |   q( Wd  S(   N(   t   closet
   closeRpmDBt   doUnlockRv   (   R>   t   cb(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   __del__   s
    


 c         C   s<   |  j  d  k	 r |  j j   n  |  j r8 |  j j   n  d  S(   N(   Ra   R   t   historyRw   RP   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRw      s    	c         C   s
   t  j   S(   s/   Factory method returning TransactionData object(   t   transactioninfot   TransactionData(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _transactionDataFactory   s    i    c         C   s   t  |  j _ | |  j _ d S(   sn   do a default setup for all the normal/necessary yum components,
           really just a shorthand for testingN(   RV   Rr   R/   t   confRL   (   R>   RL   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doGenericSetup   s    s   /etc/yum/yum.confR+   c         C   s   t  j t d  t j d d t |  d  r | |  j _ | |  j _ | |  j _	 | |  j _
 | |  j _ | |  j _ | |  j _ n  |  j S(   Ns9   doConfigSetup() will go away in a future version of Yum.
t
   stackleveli   Rr   (   t   warningst   warnt   _t   Errorst   YumFutureDeprecationWarningR   Rr   R,   R-   R/   R2   R3   R4   R5   R   (   R>   R,   R-   R/   R2   R3   R4   R5   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doConfigSetup   s    c      	   K   s  | r t  j d  n  |  j r& |  j St j   } | rr x7 d D], } | | k r? t |  j | | |  q? q? Wn  |  j j } |  j j } |  j j } |  j j	 } |  j j
 } |  j j }	 |  j j }
 |  j j } |  j j } |  j j } |  j j } |  j j } |  j j } |  j j } |  j j } | r?|  j j |  n |  j j } | d k rst j j |  rsd } n  t j | |  } | | _ |  j j | _ | r| | _ n  | j rt j j  a! n  |	 d k r|	 | _ n  |
 d k r|
 | _ n  | d k r| | _ n  | d k r'| | _ n  | d k r?| | _ n  | d k r~| j# d k rcd } q~t j j$ d | j%  } n  | d k r| | _ n  |  j& | j | j | j | j | j  | r| j' r|  j( | | | j) | j* | |  n  t j+ |  |  _ |  ` x$ |  j, j- D] } |  j. j/ |  qW|  j' j0 d  |  j, j1 |  _1 t j2   |  j, _3 t j j4 d |  j, j5 |  j1 j6 d d  |  j1 j6 d d  f  |  j, _7 |  j8 |  j, j3 |  j, j9  |  j: j; d t j   |  |  j' j0 d  |  j S(   s   
        Parse and load Yum's configuration files and call hooks initialise
        plugins and logging. Uses self.preconf for pre-configuration,
        configuration. s2   Use .preconf instead of passing args to _getConfigR,   R-   R/   R2   R3   R4   R5   R6   R7   s   /etc/yum/yum.confs   /etc/yum.confR+   t
   postconfigs   %s/repos/%s/%s/t   basearchs	   $basearchR<   s   $releasevers   Config time: %0.3ft   init(	   s   fns   roots   init_pluginss   plugin_typess	   optparsers
   debuglevels
   errorlevels   disabled_pluginss   enabled_pluginsN(<   R   R   R\   t   timet   setattrRr   R,   R-   R/   R2   R3   R4   R5   R6   R7   R8   R9   R:   R<   R;   R=   t
   setup_archt	   canonarcht   ost   patht   existst   configt   readStartupConfigR   t
   gaftonmodet   yumt   i18nt   dummy_wrapperR   R   t   installroott
   _getsysvert   distroverpkgt   doLoggingSetupR0   t   doPluginSetupt
   pluginpatht   pluginconfpatht   readMainConfigR   t   history_record_packagesRu   t   addt   runt   yumvart   geteuidt   uidt   normpatht
   persistdirt   gett   _repos_persistdirt   doFileLogSetupt   logfileRl   t   debug(   R>   t   kwargst   conf_stt   argR,   R-   R/   R2   R3   R4   R5   R6   R7   R8   R9   R:   R<   R;   R=   t   startupconft   pkgname(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt
   _getConfig   s    	 
!				
"s   /dev/logc         C   s   t  j | | | | |  d S(   s   
        Perform logging related setup.

        @param debuglevel: Debug logging level to use.
        @param errorlevel: Error logging level to use.
        N(   t   logginglevelsR   (   R>   R4   R5   R8   R9   R:   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR   o  s    	c         C   s   t  j | | |  j  d  S(   N(   R   t
   setFileLogRv   (   R>   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR   |  s    c         C   s  | d k r" t j |  d } n  t | d |  j j } t   } y | j |  Wn+ t k
 r } t	 |  } t
 j |  n Xx| j   D]} | d	 k r q n  d }	 xQ | D]I }
 |
 t j k r q n  |
 t j k r q n  |
 d k r q n  |
 }	 Pq W|	 r3|  j j d | |	 | j |	  f  q n  y |  j | |  } Wn2 t
 j t
 j f k
 r}} |  j j |  q n" X| | _ | | _ |  j j | _ | j |  j k r*xv |  j | j j D]^ } t | |  s d } |  j j | | j | f  n  t | | t |  j | j |   qWn  | rC| |  rCq n  y |  j j  |  Wq t
 j k
 r} |  j j |  q Xq Wd S(
   s-   read in repositories from a config .repo filei   t   varst   maint	   installeds   -_.:s!   Bad id for repo: %s, byte = %s %ds-   Repo %s did not have a %s attr. before setoptN(   s   mains	   installed(!   R   R   t   statR   R   R   R   t   readfpR
   t   strR   t   ConfigErrort   sectionst   stringt   ascii_letterst   digitsRk   t   warningt   findt   readRepoConfigt	   RepoErrort   repo_config_aget   repofileR   t   base_persistdirt   idRn   t   itemsR   R   t   getattrRP   R   (   R>   t   repofnt   repo_aget   validatet
   confpp_objt   parsert   et   msgt   sectiont   badt   bytet   thisrepot   opt(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   getReposFromConfigFile  s\    			 *c         C   s   |  j  j } |  j |  j  j |  x |  j  j D] } t j j |  j  j d |  rl |  j  j d | } n  t j j	 |  r/ x_ t
 t j d |   D]A } t j |  d } | | k  r | } n  |  j | d | q Wq/ q/ Wd S(   s5   read in repositories from config main and .repo filesR+   s	   %s/*.repoi   R   N(   R   t   config_file_ageR   t   config_file_patht   reposdirR   R   R   R   t   isdirt   sortedt   globR   (   R>   R   R   R   t   thisrepo_age(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   getReposFromConfig  s      	c         C   s   t  j |  } y | j | | |  j  Wn5 t k
 r` } t d | | f  } t j |  n X| j s | | _ |  j	 j
 t d  |  n  t | j  | _ |  j j | _ | j j |  j j  | | _ | S(   s   Parse an INI file section for a repository.

        @param parser: ConfParser or similar to read INI file values from.
        @param section: INI file section to read.
        @return: YumRepository instance.
        s'   Repository %r: Error parsing config: %ss8   Repository %r is missing name in configuration, using id(   t   yumRepot   YumRepositoryt   populateR   t
   ValueErrorR   R   R   t   nameRk   t   errorR%   RK   t   basecachedirR   t   updatet   cfg(   R>   R   R   RO   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR     s    			c         C   s   t  j   |  _  d S(   s   Disable yum plugins
        N(   R0   t   DummyYumPlugins(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRo     s    c         C   sR   t  |  j t j  r* t t d    n  t j |  | | | | | |  |  _ d S(   s  Initialise and enable yum plugins. 

        Note: _getConfig() will initialise plugins if instructed to. Only
        call this method directly if not calling _getConfig() or calling
        doConfigSetup(init_plugins=False).

        @param optparser: The OptionParser instance for this run (optional)
        @param plugin_types: A sequence specifying the types of plugins to load.
            This should be a sequence containing one or more of the
            yum.plugins.TYPE_...  constants. If None (the default), all plugins
            will be loaded.
        @param searchpath: A list of directories to look in for plugins. A
            default will be used if no value is specified.
        @param confpath: A list of directories to look in for plugin
            configuration files. A default will be used if no value is
            specified.
        @param disabled_plugins: Plugins to be disabled    
        @param enabled_plugins: Plugins to be enabled
        s   plugins already initialisedN(   t
   isinstanceR0   t
   YumPluginst   RuntimeErrorR   (   R>   R3   R2   t
   searchpatht   confpathR6   R7   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR     s    c         C   s)   t  j t d  t j d d |  j   S(   Ns8   doRpmDBSetup() will go away in a future version of Yum.
R   i   (   R   R   R   R   R   t	   _getRpmDB(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doRpmDBSetup  s    c         C   s   |  j  d k r t j   } |  j j t j t d   t j	 d |  j
 j d |  j
 j d d |  j
 j  |  _  |  j j d t j   |  n  |  j  S(   s@   sets up a holder object for important information from the rpmdbs   Reading Local RPMDBR-   R<   R   s   rpmdb time: %0.3fN(   R^   R   R   Rl   t   logR   t   DEBUG_4R   t   rpmsackt   RPMDBPackageSackR   R   R   R   R   (   R>   t   rpmdb_st(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR     s    !c         C   s\   |  j  d k	 r+ d |  j  _ |  j  j   n  d |  _  d |  _ d |  _ d |  _ d |  _ d S(   s>   closes down the instances of the rpmdb we have wangling aroundN(   R^   R   t   tst   dropCachedDatat   _tsR]   R_   t   comps(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRx   *  s    				c         C   s   |  `  d  |  _  d  S(   N(   R   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt	   _deleteTs5  s    c         C   s/   t  j t d  t j d d |  j | t  S(   Ns7   doRepoSetup() will go away in a future version of Yum.
R   i   (   R   R   R   R   R   t	   _getReposR.   (   R>   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doRepoSetup9  s    c   	      C   s  t  |  d  r# |  j |  j   n  t  |  d  r|  j } |  ` |  j j | j  | j |  j _ |  j j | j	  |  j j
 | j  | j |  j _ | j |  j _ | j |  j _ | j d k	 r |  j j | j  n  | j d k	 r|  j j | j  qn  | rt  t d  rt  t j d  ri  } x |  j j   D] } | j sUq@n  t j j | j  } | | k r| | | <q@n  | j | | j k rq@n  d } t j | | | | f  q@Wn  t j   } |  j j |  |  j  j! d t j   |  n  |  j S(   sB    For each enabled repository set up the basics of the repository. Rs   t   grabbert   pycurls/   sslclientcert basename shared between %s and %ss   repo time: %0.3fN("   R   R   R   Rs   RQ   t   setProgressBarRD   RE   t   setFailureCallbackRF   t   setInterruptCallbackRG   RH   RI   RJ   RK   R   t   setCacheDirRL   t   setCachet
   urlgrabberR   RP   RR   t   sslclientcertR   R   t   basenameR   R   R   t   doSetupRl   R   (	   R>   R   R  Rs   t   cert_basenamesRO   t   bnR   t   repo_st(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR   ?  sH    		
!!c         C   s   |  `  t |   |  _  d  S(   N(   RP   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt	   _delRepost  s    c         C   s5   t  j t d  t j d d |  j d | d |  S(   Ns7   doSackSetup() will go away in a future version of Yum.
R   i   t   archlistR   (   R   R   R   R   R   t	   _getSacks(   R>   R  R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doSackSetupx  s    c         C   s  |  j  d k	 r" | d k r" |  j  S| d k r7 d } n |  j j |  } |  j j t d   t j   } | s |  j j	 } n  i  } x | D] } d | | <q W|  j j
   j |  |  j j d |  |  j j
   s |  j j
   S|  j j
   |  _  |  j   |  j  j |  | d k r0|  j j   } n  x( | D]  } |  j |  |  j |  q7W|  j j d  |  j  j   |  j   |  j j d t j   |  |  j  S(   sz   populates the package sacks for information from our repositories,
           takes optional archlist for archs to includet   enableds   Setting up Package Sacksi   t   whicht   excludes   pkgsack time: %0.3fN(   Rb   R   RQ   t	   findReposRl   R   R   R   R;   R  t   getPackageSackt   setCompatArchst   populateSackt   excludePackagest   excludeArchsRR   t   includePackagesR0   R   t   buildIndexest   costExcludePackages(   R>   R  R   RQ   t   sack_stt   archdictR;   RO   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  ~  s:    	

c         C   so   d |  _ x_ |  j j j   D]K } t | d  r> | j   q t j t d  t d  t	 j
 d d q Wd S(   sz   reset the package sacks back to zero - making sure to nuke the ones
           in the repo objects, too - where it matterst
   _resetSacks2   repo object for repo %s lacks a _resetSack method
s%   therefore this repo cannot be reset.
R   i   N(   R   Rb   RQ   t   valuesR   R  R   R   R   R   R   (   R>   RO   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt	   _delSacks  s    	
c         C   s)   t  j t d  t j d d |  j   S(   Ns9   doUpdateSetup() will go away in a future version of Yum.
R   i   (   R   R   R   R   R   t   _getUpdates(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doUpdateSetup  s    c         C   s@  |  j  r |  j  S|  j j t d   t j   } t j j |  j j	   |  j
 j	    |  _  |  j j d k r} d |  j  _ n  t |  d  r |  j j |  j  _ |  ` nT |  j j r t j   } |  j
 j d t  |  j  _ |  j j d t j   |  n  |  j j |  j  _ |  j j |  j  _ |  j j |  j  _ |  j j |  j  _ |  j j |  j  _ |  j j |  j  _ t j   } |  j  j   |  j j d t j   |  |  j j rt j   } |  j  j   |  j j d t j   |  n  t j   } |  j  j    |  j j d	 t j   |  |  j j d
 t j   |  |  j  S(   sn   setups up the update object in the base class and fills out the
           updates, obsoletes and others listss   Building updates objecti   i   t   _up_obs_hackt   newests   up:Obs Init time: %0.3fs   up:simple updates time: %0.3fs   up:obs time: %0.3fs   up:condense time: %0.3fs   updates time: %0.3f(!   R_   Rl   R   R   R   t   rpmUtilst   updatest   Updatest   rpmdbt   simplePkgListt   pkgSackR   R4   R   R"  t   rawobsoletest	   obsoletest   returnObsoletesR.   R;   R   t   myarcht   multilibt   _is_multilibR  t	   _archlistt   compatarchest   _multilib_compat_archest	   exactarcht   exactarchlistt	   doUpdatest   doObsoletest   condenseUpdates(   R>   t   up_stt   obs_initt   up_pr_stt   obs_stt
   cond_up_st(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR     s@    	*	!!c         C   s2   t  j t d  t j d d d  |  _ |  j   S(   Ns8   doGroupSetup() will go away in a future version of Yum.
R   i   (   R   R   R   R   R   R   R   t
   _getGroups(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doGroupSetup  s    	c         C   sK   | d  k r> |  j r> x# |  j j   D] } t | _ q% Wq> n  | |  _ d  S(   N(   R   RP   t   listGroupsEnabledRV   t   groups_addedR`   (   R>   t   valRO   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt
   _setGroups  s
    	c   	      C   s0  |  j  r |  j  St j   } |  j j t j t d   g  } |  j x |  j j	   D]w } | j
 rw | j |  qU n  | j   s t j d |  n  y | j   } Wn t j k
 r } qU X| j |  qU W|  j j } t j d |  |  _  x | D] } | j
 rq n  |  j j t j t d  |  | j   } | r\t j | d d | j } n  y |  j  j |  WnK t j t j f k
 r} t d  | t |  f } |  j j |  q Xt | _
 q W|  j  j  d k rt j t d	   n  |  j  j! |  j" j#    |  j j$ d
 t j   |  |  j  S(   s   create the groups object that will store the comps metadata
           finds the repos with groups, gets their comps data and merge it
           into the group objects   Getting group metadatas   Repository '%s' not yet setupt   overwrite_groupss%   Adding group file from repository: %ss
   groups.xmlt   cacheds1   Failed to add groups file for repository: %s - %si    s%   No Groups Available in any repositorys   group time: %0.3f(%   R`   R   Rl   R   R   R   R   R)  RQ   R?  R@  t   appendt   readyR   R   t   getGroupLocationt   RepoMDErrorR   RC  R   t   Compst	   getGroupst   misct   repo_gen_decompressRL   R   t   GroupsErrort   CompsExceptionR   Rk   t   criticalR.   t
   compscountt   compileR'  R(  R   (	   R>   t   group_stt   reposWithGroupsRO   t   groupremoteR   t	   overwritet	   groupfileR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR=    sP    			c         C   sW  t  j    } |  j j t j t d   |  j d k r2t j	 j
   |  _ x |  j j   D] } d | j j   k rz qY n  |  j j t j t d  |  yD | j d  } t j | d d | j } |  j j | j |  WqY t j t j f k
 r*} t d  | t |  f } |  j j |  qY XqY Wn  |  j j d t  j    |  |  j S(	   sT    create the tags object used to search/report from the pkgtags 
            metadatas   Getting pkgtags metadatat   pkgtagss   Adding tags from repository: %ss   pkgtags.sqliteRD  s.   Failed to add Pkg Tags for repository: %s - %ss   tags time: %0.3fN(   R   Rl   R   R   R   R   Rd   R   R   t	   pkgtag_dbt   PackageTagsRQ   RR   t   repoXMLt	   fileTypest
   retrieveMDRK  RL  RL   R   R   R   R   t   PkgTagsErrorR   Rk   RO  R   (   R>   t   tag_stRO   t   tag_mdt
   tag_sqliteR   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _getTagsL  s*    	c         C   sM   |  j  d k rF |  j j d } t j j d |  j j d |  |  _  n  |  j  S(   se   auto create the history object that to access/append the transaction
           history information. s   /historyR-   t   db_pathN(   Ra   R   R   R   R   R|   t
   YumHistoryR   (   R>   t   pdb_path(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _getHistoryn  s
    t   fgetc         C   s
   |  j    S(   N(   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   <lambda>x  s    t   fsetc         C   s   t  |  d |  S(   NRP   (   R   (   R>   t   value(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  y  s    t   fdelc         C   s
   |  j    S(   N(   R  (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  z  s    t   docs0   Repo Storage object - object of yum repositoriesc         C   s
   |  j    S(   N(   R  (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  |  s    c         C   s   t  |  d |  S(   NRb   (   R   (   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  }  s    c         C   s
   |  j    S(   N(   R  (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  ~  s    s3   Package sack object - object of yum package objectsc         C   s
   |  j    S(   N(   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d |  S(   NR\   (   R   (   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d d   S(   NR\   (   R   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s   Yum Config Objectc         C   s
   |  j    S(   N(   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d |  S(   NR^   (   R   (   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d d   S(   NR^   (   R   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s   RpmSack objectc         C   s
   |  j    S(   N(   t
   _getTsInfo(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   |  j  |  S(   N(   t
   _setTsInfo(   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s
   |  j    S(   N(   t
   _delTsInfo(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s"   Transaction Set information objectc         C   s
   |  j    S(   N(   t   _getActionTs(   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s
   |  j    S(   N(   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s   TransactionSet objectc         C   s
   |  j    S(   N(   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d |  S(   NR_   (   R   (   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d d   S(   NR_   (   R   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s   Updates Objectc         C   s
   |  j    S(   N(   R=  (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   |  j  |  S(   N(   RB  (   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d d   S(   NR`   (   R   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s   Yum Component/groups objectc         C   s
   |  j    S(   N(   Re  (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d |  S(   NRa   (   R   (   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d d   S(   NRa   (   R   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s   Yum History Objectc         C   s
   |  j    S(   N(   Ra  (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d |  S(   NRd   (   R   (   R>   Ri  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         C   s   t  |  d d   S(   NRd   (   R   R   (   R>   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s   Yum Package Tags Objectc         C   s   t  } |  j ri xW |  j j   D]C } | | j j k r\ d | j j | k rS q qb t } q t } q Wn  | r t d  } |  j j	 t
 j |  |  j j d d  n  d S(   s   convenience function to populate the repos with the filelist metadata
           it also is simply to only emit a log if anything actually gets populatedt	   filelistss)   Importing additional filelist informationt   mdtypeN(   RV   R)  RQ   RR   RT   t   addedR.   R   Rl   R   R   t   INFO_2R  (   R>   t	   necessaryRO   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doSackFilelistPopulate  s    		c         C   sy   |  j  j d d  r d Sd	 \ } } t |  d  rX |  j j d |  j j d } } n  | t d  | | | f  d S(
   s^    Output a message that the tool requires the yum-utils package,
            if not installed. R   s	   yum-utilsNt    t   termt   boldt   normals5   The program %s%s%s is found in the yum-utils package.(   Rv  Rv  (   R'  t   containsR   Rw  t   MODER   (   R>   t   funct   progt   hibegt   hiend(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   yumUtilsMsg  s    $c         C   sN  | r` t  j d |  j j  r` t d  } |  j j |  |  j |  j j d  t j	 d  n  |  j
 j d  t j   } |  j   \ } } |  j   |  j j r |  j j t j t d   |  j   n  d } | d k r|  j j rt  j |  j j    } n  d |  j _ |  j | |  \ } } |  j
 j d d	 | d
 | |  j j r|  j | d k  \ } } |  j | | d t \ } } n  |  j j d k	 r|  j j j   n  | d k |  _  g  } | d k r|  j j! r|  j" j# r|  j j$ d t%  } n  i  } xe | D]] }	 |  j& |	 j'  r/qn  |	 j( | k rW|	 j' g | |	 j( <qn  | |	 j( j) |	 j'  qWg  }
 g  } x | D] } t* | |  d k rxO |  j j+ | g  D]5 } |  j j$ | j, t-  rqn  | | j) |  qWn  | | d } xN | | d D]> } | j. |  r+qn  t d  } | j) | | | f  qWqW| rtd } t |  _  | } n  t/ t0 g } g  } | d k r|  j j rt1 |  j j  } |  j j$ d |  } n  i  } x | D] }	 | d k	 r|	 j, | k rn: | d k	 r|	 j( | d k rqn |	 j( | k r3qn  |	 j( | k rRg  | |	 j( <n  | |	 j( j) |	 j,  qWx |  j j+ | j2    D]w } | d k	 r| j( | d k r| | | d k rqn  | j( | k rqn  | j, | | j( k r| | j( =qqWx | j2   D] } | d k	 rJ| | d k rJ| | | d k rJqn  xj |  j j3 d |  D]S }	 |	 j( | k r{q`n  |	 j, | | j( k rq`n  |	 j4 t% k r`| | j( =q`q`WqW| rd } g  } x+ t5 |  D] } | j) t d  |  qWt |  _  n  | d k r&|  j6 d t7  n  |  j j8 d t j   |  | | f S(   s   go through the packages in the transaction set, find them in the
           packageSack or rpmdb, and pack up the ts accordinglyt
   yumlibpathsv   There are unfinished transactions remaining. You might consider running yum-complete-transaction first to finish them.s   yum-complete-transactioni   t
   preresolves*   --> Finding unneeded leftover dependenciesi   t   postresolvet   rescodet   restringi   t   clear_skippedi    s%   Protected multilib versions: %s != %sR   s)   Trying to remove "%s", which is protectedt   autos   Depsolve time: %0.3fN(9   RK  t   find_unfinished_transactionsR   R   R   Rk   RO  R  R   t   sleepR0   R   t   resolveDepst   _limit_installonly_pkgst   clean_requirements_on_removeRl   R   R   Rs  t   _remove_old_depsR   t   protected_packagest   get_running_kernel_pkgtupR'  t
   readOnlyTSR   t   _doSkipBrokent   tsInfot   changedRV   R)  R   t   _depsolving_failedt   protected_multilibR;   R.  t   getMembersWithStatet   TS_INSTALL_STATESt   allowedMultipleInstallst   poR   RE  t   lent   searchNamesRW   t   TS_REMOVE_STATESt   verEQt   TS_OBSOLETEDt   TS_ERASERt   t   keyst
   matchNaevrt   output_stateR   t   save_tsR.   R   (   R>   t   unfinished_transactions_checkR   t   ds_stR  R  t   kern_pkgtupt   txmbrst   verst   txmbrt   finet	   xrestringR   t   pkgt   firstt   othert   protect_statest	   protectedt   bad_togot   ipkg(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   buildTransaction  s    
!$			c         C   s   |  j  j ry | d k ry | r* g  |  _ n  t j   } |  j | |  \ } } |  j   |  j j d t j   |  n  | | f S(   s!    do skip broken if it is enabled i   s   Skip-Broken time: %0.3f(   R   t   skip_brokenRf   R   t   _skipPackagesWithProblemst   _printTransactionRl   R   (   R>   R  R  R  t   sb_st(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  V  s    
!c            s     f d   }   f d     d } t    } t     | } d } xt  j  d k r| d k r| d 7}  j j   d  _  j j d |  | d k r  j j d  Pn   j	    j
   } t   j  }	 t    }
 xR  j D]G \ } } }  j j | j  s.| | | |
  q | | | |
  q Wxc |
 D][ }  j |  } xC | D]; } | j |  |  k re| j d k re  |  qeqeWqIW|
 s| d 7} | d	 k rPq j j d
   j j d t  n   j t d t \ } } t   j  } |	 | t    k rk| d 7} | d	 k rEPqq j j d   j j d t  n d } | d k rK  j j d   j j d t   j    j    j   \ } } qK qK W| d k r{ j j d |   j j t d   g  | D] } | ^ q	} | j   x@ | D]8 } t d  t |  | j j f }  j j |  q,W j j |  n  j j d  d | f S| | f S(   s=    Remove the packages with depsolve errors and depsolve again c            s+   |  s
 d  S j  |  | |    |   d  S(   N(   t   _getPackagesToRemove(   R  t   depTreet   toRemove(   t   _remove_from_sackR>   (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _removeh  s    c            s    j  |   } xw | D]o } |  j d k r |   k r  j j d t |     j j |   j j | j    j	 |  q q Wd  S(   NR   s.   SKIPBROKEN: removing %s from pkgSack & updates(
   t   _getPackagesToRemoveAllArcht   repoidRl   R   R   R)  t
   delPackaget   upRW   R   (   R  t   pkgsR  (   t   removed_from_sackR>   (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  o  s    i    i   s1   SKIPBROKEN: ########### Round %i ################i   s   SKIPBROKEN: Too many loops R   i   sE   SKIPBROKEN: resetting already resolved packages (no packages to skip)t   hardt   skipping_brokensI   SKIPBROKEN: resetting already resolved packages (transaction not changed)s0   SKIPBROKEN: sanity check the current transactions   SKIPBROKEN: took %i rounds s1   
Packages skipped because of dependency problems:s       %s from %ss$   Skip-broken could not solve problemsN(   Rt   R  t   po_with_problemsR'  t   transactionResetR   t   installedFileRequiresRl   R   R  t   _buildDepTreeR  R   RW   t   _skipFromTransactionR   R  t   resetResolvedR.   R  t   _checkMissingObsoletedt   _checkUpdatedLeftoverst   infoR   t   sortR   RO   R   Rf   t   extend(   R>   R  R  R  t   countt
   skipped_pot   orig_restringt   loopingR  t   startTsR  R  t   wpot   errt   skippedt   skipt   endTst   pt   skipped_listR   (    (   R  R  R>   s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  e  s|    		$
	
	




"
c         C   sG   | r
 d  S| d | d | d | d | d f } d  | k rC d  S| S(   NR   R;   t   epocht   versiont   release(   R   (   R>   R  t
   nevra_dictRW   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _add_not_found  s    c         C   s9   |  j  | |  } | d  k r" d  St |  |  j | <d  S(   N(   R  R   R!   Rg   (   R>   R  R  RW   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _add_not_found_a  s    c         C   s9   |  j  | |  } | d  k r" d  St |  |  j | <d  S(   N(   R  R   R!   Rh   (   R>   R  R  RW   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _add_not_found_i  s    c         C   s   x |  j  j d t t g  D] } x^ | j D]S } |  j  j | j  s, |  j  j | | j	  } |  j
 j d | | j	 f  q, q, Wx\ | j D]Q } |  j  j | j  s |  j
 j d | j	 | f  |  j  j | j	 j  q q Wq Wd S(   s    
        If multiple packages is obsoleting the same package
        then the TS_OBSOLETED can get removed from the transaction
        so we must make sure that they, exist and else create them
        s+   SKIPBROKEN: Added missing obsoleted %s (%s)s*   SKIPBROKEN: Remove extra obsoleted %s (%s)N(   R  R  R   t   TS_OBSOLETINGR  R+  R   RW   t   addObsoletedR  Rl   R   t   obsoleted_byt   remove(   R>   R  R  t   obs(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    "$c         C   s   x |  j  j d t g  D]e } x\ | j D]Q } |  j  j | j  s) |  j j d | j	 | f  |  j  j
 | j	 j  q) q) Wq Wd S(   s    
        If multiple packages is updated the same package
        and this package get removed because of an dep issue
        then make sure that all the TS_UPDATED get removed.
        s(   SKIPBROKEN: Remove extra updated %s (%s)N(   R  R  R   t
   TS_UPDATEDt
   updated_byR   RW   Rl   R   R  R  (   R>   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s
    c   
      C   s   g  } |  j  j r | j \ } } } } } xd |  j  j D]F } | | | | | f } |  j j | | | | |  }	 | j |	  q7 Wn | j |  | S(   s,    get all compatible arch packages in pkgSack(   R;   R.  RW   R  R)  t   searchNevraR  RE  (
   R>   R  R  t   nt   aR   t   vt   rRW   t   matched(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  
  s    c         C   s   g  } | j  \ } } } } } x |  j j D]r } | | | | | f } |  j j |  r+ xB |  j j |  D]+ }	 |	 j }
 |  j |
  } | j |  qk Wq+ q+ W| S(   N(	   RW   R;   R  R  R   t
   getMembersR  t   _removePoFromTransactionR  (   R>   R  R  R  R  R   R  R  RW   R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    	c         C   sn   g  } |  j  j | j  rj |  j j d t |   |  j  j | j  | j d k sj | j |  qj n  | S(   Ns(   SKIPBROKEN: removing %s from transactionR   (	   R  R   RW   Rl   R   R   R  R  RE  (   R>   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  )  s    c         C   sN   i  } xA |  j  D]6 } x- | j D]" } | j | g   j | j  q  Wq W| S(   s&    create a dictionary with po and deps (   R  t
   depends_ont
   setdefaultRE  R  (   R>   R  R  t   dep(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  2  s
    $c         C   s@   x9 | j    D]+ \ } } | GHx | D] } d G| GHq% Wq Wd  S(   Ns   	(   t	   iteritems(   R>   t   treeR  t   lR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _printDepTree;  s    c         C   s  i d t  6d t 6d t 6d t 6d t 6d t 6d t 6d t 6} |  j j	 t
 j d	 t |  j   x t |  j  D] } d
 | | j | j f } |  j j	 t
 j |  xI t t | j   D]2 \ } } d | | f } |  j j	 t
 j |  q Wqq W|  j j	 t
 j d d d  d  S(   NR   t   installt   trueinstallt   eraset	   obsoletedt
   obsoletingt	   availablet   updateds/   SKIPBROKEN: Current Transaction : %i member(s) s   SKIPBROKEN:  %-11s : %s s%   SKIPBROKEN:                   %s : %ss   SKIPBROKEN:%si<   t   =(   t	   TS_UPDATEt
   TS_INSTALLt   TS_TRUEINSTALLR  R  R  t   TS_AVAILABLER  Rl   R   R   t   DEBUG_2R  R  R   R  R  Rt   t	   relatedto(   R>   t   stateR  R   R  t   rel(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  A  s     

#"c         C   s   | j  |  x |  j j | j  D]{ } x8 | j | j D]& } | j  |  |  j | | |  q: Wx7 | j D], \ } } | j  |  |  j | | |  qn Wq# W|  j | | |  d S(   s2   
        get the (related) pos to remove.
        N(   R   R  R  RW   R%  R+  t   _getDepsToRemoveR  (   R>   R  t   deptreeR  R  R  t   relativet   relation(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  U  s    c         C   s   x | j  | g   D]n } xE |  j j | j  D]. } x% | j | j D] } | j |  qF Wq/ W| j |  |  j | | |  q Wd  S(   N(   R   R  R  RW   R%  R+  R   R	  (   R>   R  R
  R  R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR	  d  s    c            s*   d  k r |  j j  n  | d  k r6 d d g } n  | d  k rc t d       f d   } n  | r|  t d   n  t |  t g   t t    f k r t |  } n t | g  } t d   | D  } d } g  } | j t d   ri t d	  d
 6t d  d 6}	 x |  j j   D]| }
 |
 j	 j
 | k rFq(n  |
 j d k rt } x* |
 j D] } | j
 | k ret } PqeqeW| rq(qn  | j |
  q(Wn  | j t d   r/t |  j j  } xZ |  j j |  D]C }
 |
 j	 j
 | k rqn  |
 j j
 | k rqn  | j |
  qWn  | j t d   rxW |  j j   D]C }
 |
 j	 j
 | k rrqTn  |
 j j
 | k rqTn  | j |
  qTWn  | j t d   rx? |  j j   D]+ }
 |
 j	 j
 | k rqn  | j |
  qWn  | t |   x t |  D] }
  |
  qW| S(   Nt   dependenciest
   duplicatessF   ** Found %d pre-existing rpmdb problem(s), 'yum check' output follows:c            s   |  p    |   S(   N(    (   t   problems(   R   t   out(    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  v  s    s&   Warning: RPMDB altered outside of yum.c         s   s   |  ] } | j  Vq d  S(   N(   RW   (   t   .0R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pys	   <genexpr>  s    i    t   alls   missing requirest   requiress   installed conflictt	   conflictsR  t   provides(   s   allR  (   s   allR  (   s   alls	   obsoleted(   s   alls   provides(   R   Rk   R   R   t   typeRt   t   intersectionR'  t   check_dependenciesR  RW   t   problemR.   R  RV   RE  R   t   installonlypkgst   check_duplicatest	   duplicatet   check_obsoletedt	   obsoletert   check_providesR  R   (   R>   R  R   t   chkcmdt   headert   ignore_pkgst   ignore_pkgtupst   rct   probst   prob2uit   probt   foundt   rest   iopkgs(    (   R   R  s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _rpmdb_warn_checksl  sl    '	c         C   s  |  j  j d  x4 |  j j   D]# } | j r  |  j j d  Pq  q  W|  j j si |  j	 j
 t j  r{ |  j j   } nt |  j  } |  j j d |  } |  j j d t  d } |  j j   } | d k	 r | j } n  g  } | d k s | | k rU|  j j d t  }	 g  |	 D] }
 |
 j ^ q} | d k	 } |  j d | d |  } n  d } t |  d  r|  j rd	 j |  j  } n- t |  d
  r|  j rd	 j |  j  } n  |  j j   } |  j j  | | t |  j  |  j! | |  |  j"   t |  d  r|  j#   n  |  j  j d  |  j j$ |  |  j% d k	 rt& |  j% d  j'   } |  j j( d |  y t) j* |  j%  Wqt+ t, f k
 r} qXn  d |  _% |  j	 j | j- d  } t. j/   } d | _0 | d k rnt1 |  d k r!t2 d  } |  j3 j4 |  d | _0 n |  j j r|  j	 j
 t j  rg  | D] } t5 t6 |   ^ qJ} |  j  j d  |  j j7 | d d | n  |  j8 j9 t2 d   x" | D] } |  j8 j9 | d  qWt: j; d t2 d  d |   |  j j< r|  j	 j
 t j  r|  j=   n  xv d D]n } t | |  r$t> | |  } y t. j? |  Wqt+ t, f k
 r} |  j8 j9 t2 d  |  qXq$q$W|  j	 j
 t j  s| j0 r|  j j@   n |  j jA t |  j   |  j  j d  |  j	 j
 t j  s|  jB |  n  | S(   s6   takes an rpm callback object, performs the transactiont   pretranss   yum-metadata-parsert   patternst	   main_onlyi    R   R"  t   argst    t   cmdst   _shell_history_writet   historybeginR  t   saved_txRv  sI   Warning: scriptlet or other non-fatal errors occurred during transaction.i   t
   historyendi   t   errorss   Transaction couldn't start:R   s   Could not run transaction.t	   ts_all_fnt
   ts_done_fns$   Failed to remove transaction file %st	   posttransN(   R7  R8  (C   R0   R   RQ   RR   t   _xml2sqlite_localRu   R   R   t   history_recordR   t   isTsFlagSetR   t   RPMTRANS_FLAG_TESTR  t   futureRpmDBVersiont   listR'  t   returnPackagest   simpleVersionR.   R|   t   lastR   t   end_rpmdbversionR  R  R  R+  R   R/  t   joinR1  t   begRf   t   _store_config_in_historyR2  t   transactionResultVersionRe   t   opent   readt   write_addon_dataR   t   unlinkt   IOErrort   OSErrorRE   RK  t   GenericHoldert   return_codeR  R   Rl   R   R%   R&   t   endRk   RO  R   t   YumRPMTransErrort	   keepcachet   cleanUsedHeadersPackagesR   t   unlink_fR   t   dropCachedDataPostTransactiont   verifyTransaction(   R>   Rz   RO   t   frpmdbvt   using_pkgs_patst
   using_pkgst   rpmdbvt   lastdbvt   rpmdb_problemsR  R  R"  t   output_warnt   cmdlinet
   savetx_msgR   R6  t   resultobjectt	   errstringt   xt   herrorst   iR,   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   runTransaction  s    	
		"%	%	c         C   s  t  j    } |  j j d  x/|  j D]$} | j t k r& |  j j d | j  s |  j	 j
 t d | j   t | _ q& n  |  j | j  } | j } | j | j _ | j | j _ |  j j d | j _ t |  d  r|  j rd j |  j  | j _ n3 t |  d  r4|  j r4d j |  j  | j _ n  | j   } | d k	 r{t | d  | j _ t | d	  | j _ n  t  | t!  ry[ t" j# | j$    } t t% | j&   } t t% | j'   }	 | | j _( |	 | j _) WqqXn  | j* d k	 r| j* | j _+ n  t | j, d
  r| j, j- }
 |
 r^|
 j. d k	 r^t |
 j.  | j _( n  |
 rt |
 j/  | j _) qn  t0 j1   } | j2 s| j3 s| j4 r&| j2 r| j2 d } n | j3 r| j3 d } n | } d | j k r| j j5 | j _5 n  | d k	 rGt |  | j _6 qGqJ| d k	 rJt |  | j _5 qJq& q& Wx |  j D] } | j t k rpqX| j t7 k r|  j j d | j  r|  j j8 d | j d t  s|  j	 j
 t d | j   t | _ qXqn  |  j j9 j: d | j  } | j;   qX|  j< j= t> j? d | j  qXW|  j j d  |  j j@ d tA  d } |  j jB r|  jC jD tE jF  rd } | d k	 r| jG } n  |  j j d  |  jH jI | |  n  |  j jJ   |  j< jK d t  j    |  d S(   sn   checks that the transaction did what we expected it to do. Also 
           propagates our external yumdb infot   preverifytransR  s+   %s was supposed to be installed but is not!R<   R/  R0  R1  i    i   RZ  t   installed_byRW   t   output_statess)   %s was supposed to be removed but is not!s   What is this? %st   postverifytransR.  iR5  s   VerifyTransaction time: %0.3fN(L   R   R0   R   R  R  R  R'  Rz  R  Rk   RO  R   t	   TS_FAILEDt   getInstalledPackageObjectRW   R  t
   yumdb_infot	   from_repot   reasonR   R   R<   R   R/  RD  t   command_lineR1  t   returnIdSumR   R   t   checksum_typet   checksum_dataR   R   R   R   t   localPkgR   t   st_ctimet   st_mtimet   from_repo_revisiont   from_repo_timestampt   xattr_origin_urlt
   origin_urlRO   RZ  t   revisiont	   timestampRK  t   getloginuidR%  t
   downgradest	   reinstallRg  t
   changed_byR  R  t   yumdbt   get_packaget   cleanRl   R   R   R  RA  R.   R;  R   R<  R   R=  RO  R|   RP  R   R   (   R>   R`  t   vt_stR  R  t   rpot   csumt   stt   lp_ctimet   lp_mtimet   mdt   loginuidt   opot
   yumdb_itemRZ  t   ret(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRV  %  s    		 					!"c   	      C   s   i  } x3 |  j  j   D]" } | j | j g   j |  q Wt |  d k rR d St } d } g  } xw t |  D]i } | r xC | | D]4 } t | |  j   } | j	 j
 | j | d |  q Wn  | j | |  t } qq Wd S(   s    Create an excluder for repos. with higher cost. Eg.
            repo-A:cost=1 repo-B:cost=2 ... here we setup an excluder on repo-B
            that looks for pkgs in repo-B.i   Ns   yum.costexcludess   exclude.pkgtup.in(   RQ   RR   R  RS   RE  R  RV   R   RM   RT   t   addPackageExcluderR   R  R.   (	   R>   t   costsR  t   donet   exidt   oreposRS   RO   t   yce(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s      c         C   s   d |  j  j k r d S| sM d |  j  j k r2 d S|  j  j } d } d } n8 | j |  j  j k rf d S| j   } | j } d | } d } xA | D]9 } | d 7} d | | f } |  j j | | d	 |  q Wd S(
   s   removes packages from packageSacks based on global exclude lists,
           command line excludes and per-repository excludes, takes optional 
           repo object to use.R  NR   s   yum.excludepkgss   yum.excludepkgs.i    i   s   %s.%us   exclude.match(   R   t   disable_excludesR  R   R   t   getExcludePkgListR)  R  (   R>   RO   t   excludelistR  t   exid_begR  t   matchR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s$    		

c         C   s   | j    } t |  d k r" d Sd } |  j j | j | d  d } xD | D]< } | d 7} d d | f } |  j j | j | d |  qN Wd	 } |  j j | j | d
  d S(   sz   removes packages from packageSacks based on list of packages, to include.
           takes repoid as a mandatory argument.i    Ns   yum.includepkgs.1s   mark.washedi   s   %s.%us   yum.includepkgs.2s
   wash.matchs   yum.includepkgs.3s   exclude.marked(   t   getIncludePkgListR  R)  R  R   (   R>   RO   t   includelistR  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    
 c         C   s  |  j  j d k rC |  j  j r" d S|  j  j } t j j |  } n |  j  j } | d | } t j j |  } t	 t j
    } x`|  j | | d  sy t | d  } WnD t t f k
 r } t d  | | f } t j t j |   n Xy t | j    } Wn t k
 r)|  j |  q X| t j
   k r@Pn  y t j | d  Wn^ t k
 r} | d t j k r|  j |  qt d  | } t j t j | |   q Xt d  | | f } t j d | |   q W| |  _ d S(	   sA   perform the yum locking, raise yum-based exceptions, not OSErrorsi    NR+   i  R  s   Could not open lock %s: %ss#   Unable to check if PID %s is actives4   Existing lock %s: another copy is running as pid %s.(   R   R   RL   RK   R   R   R  R   R   R   t   getpidt   _lockRH  RL  RM  R   R   t	   LockErrort   errnot   EPERMR   t   readlineR   t   _unlockt   killt   ESRCHRc   (   R>   t   lockfileR-   t   mypidt   fdR   R   t   oldpid(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doLock  s>      c         C   s   t  |  d  r d S|  j j d k r. d } n  | d k	 rW |  j j } | d | } n |  j d k rj d S|  j } |  j |  d |  _ d S(   s   do the unlock for yumRr   Ni    R+   (   R   R   R   R   R   Rc   R  (   R>   R  R-   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRy     s    		Rv  i  c         C   s   t  j j |  } yR t  j j |  s= t  j | d d n  t  j | t  j t  j Bt  j B|  } Wnc t	 k
 r } | j
 t
 j k s t d  | t |  f } t j | j
 | t |    n  d SXt  j | |  t  j |  d Sd  S(   Nt   modei  s    Could not create lock at %s: %s i    i   (   R   R   t   dirnameR   t   makedirsRH  t   O_EXCLt   O_CREATt   O_WRONLYRM  R  t   EEXISTR   R   R   R  R   t   writeRw   (   R>   t   filenamet   contentsR  t   lockdirR  R   t   errmsg(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  )  s    *!c         C   s   t  j |  d  S(   N(   RK  RT  (   R>   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  :  s    c   	      C   s/  t  } t |  t j k r' | j } n  | | j   k rE | | _ n  | j   sZ t } n3 t	 |  j
 j   |  } | j | j k r t } n  | r+t j |  d } t | j  } | | k r | j j r | j | j j  r t j |  q n  | r$t d  | j j } t d |   q+t  Sn  t S(   s   verifies the package is what we expect it to be
           raiseError  = defaults to 0 - if 1 then will raise
           a URLGrabError if the file does not check out.
           otherwise it returns false for a failure, true for successi   s\   Package does not match intended download. Suggestion: run yum --enablerepo=%s clean metadatai(   RV   R  t   typest   InstanceTypeR  Rs  t	   localpatht   verifyLocalPkgR.   R   R'  R  RW   R   R   t   longt   sizeRO   RL   t
   startswithRK   RK  R   R   R   (	   R>   t   foR  t
   raiseErrort   failedt   ylpt   cursizet   totsizeR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt	   verifyPkg=  s*    		c         C   sl   y t  j | |  } Wn+ t j k
 rC } t d t d    n X| | k rh t d t d    n  d S(   sH   Verify the checksum of the file versus the 
           provided checksumis   Could not perform checksumis   Package does not match checksumi    (   RK  t   checksumR   t	   MiscErrorR   R   (   R>   R  t   checksumTypeR  t   filesumR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   verifyChecksumh  s    c      
      s  d   } i      f d   } |  j  j   |  j j d d | t } g  } d } x | D] }	 t |	 d  r |	 j d k r qZ n  |	 j   }
 t j	 j
 |
  r|  j |
 |	 t  s |	 j j rt } | |	 t d  |	 j j  qq|  j j t d	  |	 f  qZ n  | j |	  | |	 j 7} |  j j s;| rZ   rZ   SqZ W| j |  t t j d
  rt |  d k rt j j |  n  t j   } d } d } t   } x| D]}	 |	 j   }
 | d 7} t j	 j
 |
  r~|  j |
 |	 t  rP|  j j t d	  |	 f  | |	 j 8} t t j d
  rt j j | |  qqn  t j	 j |
  |	 j k r~t j |
  q~n  |  j |	 d f i  f } t j |	 j j   } | j! | j" t# |	 j  k r| |	 t d  |	 j j  t$ | j! | j"  t$ |	 j  f  qn  y$| d k rL| rL| |	 j k rLt j	 j% |	 j&  } n( d | t |  t j	 j% |	 j&  f } |	 j j' |	 d | d | d |	 j j( d k } | |	 j 7} t t j d
  rt j j | |  n  |	 j) | k r"|  j* |	  \ } } | d k r"|  j j+ d |  q"n  | j, |	 j)  Wn) t- j. k
 r^} | |	 t/ |   qX| |	 _0 |	   k r  |	 =qqWt t j d
  rt j j d  n  | d  k	 r  r| | | |  n  |  j j d d | d   t t j2 d  rt j2 j3   n    S(   Nc         S   s   |  j    } | j    } | d  k r= | d  k r= t |  |  S| d  k rM d S| d  k r] d S| | k  rm d S| | k r} d Sd S(   Nii   i    (   t
   getDiscNumR   t   cmp(   t   apot   bpoR  t   b(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt	   mediasortw  s    c            s     j  |  g   j |  d  S(   N(   R  RE  (   R  R   (   R6  (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   adderror  s    t   predownloadt   pkglisti    t   pkgtypet   locals4   package fails checksum but caching is enabled for %ss   using local copy of %st   text_meter_total_sizei   sK   Insufficient space in download directory %s
    * free   %s
    * needed %ss   (%s/%s): %st	   checkfunct   textRL   t   nones   %st   postdownloadR6  t   reset_curl_obj(4   R|   Rw   R0   R   RV   R   R  Rs  R   R   R   R  RO   RL   R.   R   R   Rl   R   RE  R  R   R  R  t   progressR  R  R   Rt   t   getsizeRK  t   statvfst   pkgdirt   f_bavailt   f_bsizeR  R   R  t   relativepatht
   getPackaget   http_cachingR  t   sigCheckPkgR   R   R   R   R   R  R   R   R  (   R>   R  RE   t   callback_totalR  R  t   repo_cachedt   remote_pkgst   remote_sizeR  R  t   beg_downloadRd  t
   local_sizet
   done_reposR  t   dirstatR  t   mylocalt   resultR  R   (    (   R6  s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   downloadPkgsv  s    		

	"
	c         C   s   t  |  t j k r! | j } n  y t j |  } | d } Wn< t j t f k
 r| | ru t d t	 d    q} d Sn Xt
 |  } | j | j k r | r t d d   q d Sn  d S(   s/   check the header out via it's naevr, internallyi    is   Header is not complete.s'   Header does not match intended downloadi   (   R  R  R  R  R   t   readHeaderListFromFileR   t
   IndexErrorR   R   R   RW   (   R>   R  R  R  t   hlistt   hdrt   yip(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   verifyHeader  s    c   
      C   s  t  | d  r" | j d k r" d Si  } | j   } |  j j | j  } t j j |  r y |  j	 | | d d } Wn  t
 k
 r } t j |  q X| | _ d Sn( |  j j r t j t d  | j  n  |  j r |  j j | j  n  yh t j j | j  st j | j  n  |  j	 | d f i  f } | j | d | d | j d	 k } Wn[ t j k
 r} | }	 y t j |  Wn t k
 r} t j |	  qXt j |	  n X| | _ d Sd S(
   sw   download a header from a package object.
           output based on callback, raise yum.Errors.YumBaseError on problemsR  R  NR  i   sK   Header not in local cache and caching-only mode enabled. Cannot download %sR  RL   R  (   R   R  t   localHdrRQ   t   getRepoR  R   R   R   R  R   RK  RT  t   hdrpathR   RL   R   R   R   t
   dsCallbackt   downloadHeaderR   t   hdrdirR  t	   getHeaderR  RM  (
   R>   R  R6  R  RO   R  R   R  R  t   saved_repo_error(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s@    		 	c   
      C   s  |  j  r t } d } n\ t | d  rK | j d k rK |  j j } d } n) |  j j | j  } | j	 } | j
 } | r|  j j   } t j j | | j    } t j j | j    } | d k r d } d }	 q| d k r| r d } n d } t d  | }	 q| d k r0d } t d  | }	 q| d	 k rj| rKd } n d } d } t d
  | }	 q| d k rd } t d  | }	 qn d } d }	 | |	 f S(   s  
        Take a package object and attempt to verify GPG signature if required

        Returns (result, error_string) where result is:
            - 0 - GPG signature verifies ok or verification is not required.
            - 1 - GPG verification failed but installation of the right GPG key
                  might help.
            - 2 - Fatal GPG verification error, give up.
        i    R  R  Rv  i   i   s"   Public key for %s is not installeds   Problem opening package %si   s    Public key for %s is not trustedi   s   Package %s is not signed(   Rm   RV   R   R  R   t   localpkg_gpgcheckRQ   R  R  t   gpgcheckt   gpgkeyR'  R  R$  t	   miscutilst   checkSigRs  R   R   R  R   (
   R>   R  t   checkt	   hasgpgkeyRO   R   t	   sigresultt   localfnR  R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  L  sH    
							c         C   s  g  } x |  j  D] } | j j t k r. q n  | j j d k rF q n  | j j |  j j k rd q n  |  j j | j j } t } x* | j D] } | j d  r t	 } Pq q W| r | j
 | j j   g  q | j j | j
 | j j   | j j   g  q Wx | D] } t j j |  s'q	n  y t j |  Wn/ t k
 ri} |  j j t d  |  q	q	X|  j j t j t d  |  q	Wd  S(   NR   s   file:s   Cannot remove %ss
   %s removed(   R  R  R  R  R  RQ   RV   t   baseurlR  R.   R  R  Rx  Rs  R   R   R   RK  RT  RM  Rk   R   R   Rl   R   R   R   (   R>   t   filelistR  RO   R  t   uR,   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRS    s8    
)c         C   s   d g } |  j  | d d  S(   NR  R  R!  (   t   _cleanFiles(   R>   t   exts(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   cleanHeaders  s    	c         C   s   d g } |  j  | d d  S(   NR   R  t   package(   R  (   R>   R	  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   cleanPackages  s    	c         C   s"   d d d g } |  j  | d d  S(   Nt   sqlites
   sqlite.bz2s   sqlite-journalRK   (   R  (   R>   R	  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   cleanSqlite  s    c         C   s(   d d d d d g } |  j  | d d  S(   Ns   xml.gzt   xmlt   cachecookies   mirrorlist.txtt   ascRK   t   metadata(   R  (   R>   R	  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   cleanMetadata  s    c         C   s   d d g } |  j  | d d  S(   NR  s   mirrorlist.txtRK   R  (   R  (   R>   R	  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   cleanExpireCache  s    c         C   sP   |  j  j d } t j j |  s+ g  } n t j | d g   } |  j d |  S(   Ns   /rpmdb-indexes/Rv  R'  (   R   R   R   R   R   RK  t   getFileListt   _cleanFilelist(   R>   RK   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt
   cleanRpmDB  s
    	c         C   s   g  } xs | D]k } xb |  j  j   D]Q } t | |  } t j j |  r# t j j |  r# t j | | |  } q# q# Wq W|  j	 | |  S(   N(
   RQ   RR   R   R   R   R   R   RK  R  R  (   R>   R	  t   pathattrt   filetypeR  t   extRO   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    $ c         C   s   d } x | D]x } y t  j |  Wn2 t k
 rX } |  j j t d  | |  q q X|  j j t j	 t d  | |  | d 7} q Wt
 d d |  | | f } d | g f S(   Ni    s   Cannot remove %s file %ss   %s file %s removedi   s   %d %s file removeds   %d %s files removed(   RK  RT  RM  Rk   RO  R   Rl   R   R   R   t   P_(   R>   R  R  t   removedt   itemR   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    R  c   *      C   s  | d k r |  j j } n  t j d |  } g  } g  } g  } g  }	 g  }
 g  } g  } g  } g  } | } | d k r i  } i  } xz |  j j d | d |  D]] } | | | j <| r q n  | j | j	 f } | | k s | j
 | |  r | | | <q q W| j   } | r.|  j j d | d |  } n< y |  j j d | d |  } Wn t j k
 rig  } n XxD| D] } | r| j | k r| j |  q| j |  qq| j | j	 f } | j | k r| j |  qq| | k s| j
 | |  r| j |  qq|	 j |  qqWn| d k rQx |  j j   D] \ } } } } } |  j j d | d | d | d	 | d
 |  } t |  d k r|
 j | d  |  j j t j t d  | d  q<t |  d k r|
 j | d  q<|  j j t j t d  | | | | |  q<W| rt |
 | d | \ } } } | | }
 qn`| d k r{|  j j d | d |  } n6| d k r| r|  j j d | d |  } n< y |  j j d | d |  } Wn t j k
 rg  } n Xx| D] } | r/|  j j d |  r| j |  q| j |  q|  j j | j d | j	 } | rlt | d t d }  n  | s| j
 |   r| j |  q| j |   r| j |  q|	 j |  qWn| d k r@|  j j d | d |  } t  |  } x|  j j d | d |  D]% } | j | k r| j |  qqWnq| d k rd |  j _! x |  j j"   D] \ }! }" |! \ } } } } } |  j j d | d | d	 | d
 | d |  }# |  j# |"  }$ x. |# D]& } | j |  | j | |$ f  qWqhW| rt | | d | \ } } } | | } t  |  }% g  }& x9 | D]1 \ } }$ | |% k r`qBn  |& j | |$ f  qBW|& } n  | st$ |  } t  |  }' g  }& x9 | D]1 \ } }$ | |' k rqn  |& j | |$ f  qW|& } qn | d k rt% j%   }( |( |  j j& d }) | r<|  j j d | d |  } n< y |  j j d | d |  } Wn t j k
 rwg  } n Xx6 | D]+ } t' | j(  |) k r| j |  qqWn  | | _) | | _* | | _+ |	 | _, |
 | _- | | _! | | _. | | _& | | _/ | S(   sB   generates lists of packages, un-reduced, based on pkgnarrow optiont   iterR  R-  t   ignore_caseR%  R   R;   R  t   verR  i   i    s,   More than one identical match in sack for %ss*   Nothing matches %s.%s %s:%s-%s from updatet	   casematchR   R  R  t   reverset   extrasR+  t   recentiQ N(0   R   R   t   showdupesfromreposRK  RN  R'  R@  RW   R   R;   t   verGTR  R)  t   returnNewestByNameArchR   t   PackageSackErrorRE  R  t   getUpdatesListR  R  Rl   R   R   t   DEBUG_1R   R   Rz  R   R.   R  R(  Rt   R+  t   getObsoletesTuplesRk  R   R   R$  R   t   filetimeR   R  t   reinstall_availablet   old_availableR%  t   obsoletesTuplesR#  (*   R>   t	   pkgnarrowR-  t   showdupsR  t   yghR   R  R-  R.  R%  R+  R/  R$  R#  t   ict   dinstt   ndinstR  t   keyt   availR  R  R  R   R  R  t   matchest
   exactmatchR  t	   unmatchedt   ipkgst   latestRW   t   instTupR  t   instpot   matched_obsoletest   nobsoletesTuplest   filtt   nowt   recentlimit(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doPackageLists  s"   
%	 
	-
	
									c         C   s   i  } x | D] } i  | | <| j  } | j   | | } xo | D]g } | \ } } }	 | j d  rk qA n  g  }
 x* |  j | | |	  D] } |
 j |  q W|
 | | <qA Wq W| S(   s   
        Return the dependencies for a given package object list, as well
        possible solutions for those dependencies.
           
        Returns the deps as a dict of dicts::
            packageobject = [reqs] = [list of satisfying pkgs]
        s   rpmlib((   R  R  R  t   whatProvidesRE  (   R>   R  t   resultsR  t   reqst
   pkgresultst   reqR  t   fR  t
   satisfiersR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   findDeps	  s    	
	

c   %      #   s  g  } x'  D] } | j  t j | |   q Wi  }	 g  }
 g  } g   i   d } i    xX | D]P } | j  |   j  | j    |  | j   <  j | |  | d 8} qa Wx3 |  j j j   D] } |
 j | j	 | |   q W   f d   } | |
 |	  | rK|  j
 j	   d t }
 |  j   | |
 |	  ~
 n  i  } | r|  j   }
 x |
 D] } d } g  } g  } xv |
 | D]j \ } } | t |  7} | j   |  | j |  | | k rg  | | <n  | | j  | | f  qWqmW~
 n  |	 j   rxxa |	 j   D]P } xG | D]? \ } } } | | k rVg  | | <n  | | j  | | f  q.Wq!Wn  i  }	 x | D] } g  } g  } x2 | | D]& \ } } | j |  | j |  qWt j |  } t j |  } t |  } | |	 k rg  |	 | <n  |	 | j  | | | f  qWt j d   d   } | rl  f d     f d   } n  i  } xt t |	   D]} d	 } x0t |	 | d  D]}  | r|  \ }! }" }# n |  d j |  d j f | k rqn  |  d j |  d j f }$ | d	 k s5| d |$ k rG| | d |   rG|$ |  f } qn  | d \ }! }" }# | d |$ k rsd	 } n |$ |  f } | r|! |" |# f Vn |! |# f V| sd | |! j |! j f <qqW| d	 k	 r| d \ }! }" }# | r|! |" |# f Vq|! |# f VqqWd	 S(
   s   Generator method to lighten memory load for some searches.
           This is the preferred search function to use. Setting keys to True
           will use the search keys that matched in the sorting, and return
           the search keys in the results. i    i   c   	         s   x |  D] \ } } t    } g  } | | k r; g  | | <n  xv  D]n } xe   D]] } t t | |   } | rO | j   j |  d k rO | j |  | j  |  qO qO WqB Wt |  d k r | | j | | | f  q q Wd  S(   Nii    (   Rt   R%   R   t   lowerR   RE  R   R  (	   t   tmprest   sorted_listsR  R  t   tmpkeyst	   tmpvaluest   st   fieldRi  (   t   fieldst   rcl2ct   real_crit_lower(    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   results2sorted_lists	  s    	 !t   loweredc         S   s   t  S(   N(   R.   (   Rb  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  =
  s    c            sM   t    f d   |  d D  t |  d  d j t |  d   |  d f S(   Nc         3   s   |  ] }   | Vq d  S(   N(    (   R  t   y(   t   critweights(    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pys	   <genexpr>A
  s    i   i   t    i    (   t   sumR  RD  R   (   Rb  (   RZ  (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  A
  s   c            s     |   d    |  d  k S(   Ni(    (   Rb  RY  (   t	   sort_func(    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg  C
  s    R6  N(   RE  t   RPM_TO_SQLITER   RM  R  R)  t   sacksR  R  t"   searchPrimaryFieldsMultipleStringsR'  R.   Rx   t   searchPackageTagsR  RK  t   uniquet   operatort
   itemgettert   reversedR   R   R   R;   (%   R>   RT  t   criteriaR1  R  t
   searchtagst   searchrpmdbt
   sql_fieldsRJ  RO  RN  t	   real_critt
   critweightRR  RT   RW  t   results_by_pkgR  R  t	   matchkeyst
   tagresultsR  t   taglistR  t   kR  t   totkeyst   totvalst   dupt   yieldedRA  RB  t   sl_valsR  t   kst   vst   na(    (   RZ  RT  RU  RV  R]  s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   searchGenerator	  s    	
"	 /	c   	      C   s   i  } x | D] } | j    } |  j j |  } xu | j   D]g \ } } |  j j d |  } | sk q> n  | d } | | k r g  | | <n  | | j | | f  q> Wq W| S(   NR   i    (   RM  RW  t   search_tagsR   R)  R  RE  (	   R>   Rf  RF  t   cR)  R   Ro  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRa  g
  s    
c         C   s   t  j t d  t j d d i  } |  j | |  } xT | D]L \ } } | r` | | |  n  | | k ry g  | | <n  | | j |  q> W| S(   s  Search specified fields for matches to criteria
           optional callback specified to print out results
           as you go. Callback is a simple function of:
           callback(po, matched values list). It will 
           just return a dict of dict[po]=matched values listso   searchPackages() will go away in a future version of Yum.                      Use searchGenerator() instead. 
R   i   (   R   R   R   R   R   Ry  R  (   R>   RT  Rf  RE   R8  t	   match_genR  t   matched_strings(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   searchPackagesw
  s    	c      	   C   sh  d   } i  } xi| D]a} t  |  } | |  \ } } | sX t }	 |  j |  }
 n t }	 |  j j | t  }
 |  j j t j	 t
 d d t |
   t |
   xt |
  D]} |  j j t j t d  |  g  } |	 r | j |  n  | r| r| j |  n  | r~| r~|  j j t j t d   xD | j | j | j D]( } t j | |  rO| j |  qOqOWn  |  j j t j t d   x | j D]v \ } } \ } } } t j | | | | | f f  } |	 st j | |  st j | |  r| j |  qqqWt |  d k r | rf| rV| rV| | | |  qf| | |  n  | | | <q q Wq Wd d	 d
 g } d
 g } x| D]} | |  \ } } | s8|  j |  }
 t }	 x|
 D]] } | g } t |  d k r| r$| r| | | |  q$| | |  n  | | | <qqWqt }	 |  j }
 | rV| } n | } t j t j |   } x t |
  D] } g  } g  } xa | D]Y } t | |  } | d  k rqn  t |  t j  k r| j! |  q| j |  qWx- | D]% } | j" |  r| j |  qqWt |  d k r| rO| | |  n  | | | <qqWqW| S(   Nc         S   sV   t  j |   s7 t } |  d d k r. t } qL t } n t } t  j |   } | | f S(   Ni    R+   (   RK  t   re_globRV   R.   t   re_filename(   R   t   isglobt	   canBeFile(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt	   _arg_data
  s    		s   Searching %d packages   Searching %d packagess   searching package %ss   searching in file entriess   searching in provides entriesi    R  t   dirnamest   provides_names(#   R%   R.   t   returnPackagesByDepRV   R)  t	   searchAllRl   R   R   R*  R  R  R   R  R   RE  t   dirlistR  t	   ghostlistt   fnmatchR  RK  t   prco_tuple_to_stringt   returnInstalledPackagesByDepR'  t   reRQ  t	   translateR   R   R  R  t   ListTypeR  R  (   R>   R/  RE   t   callback_has_matchforR  R8  R   R  R  t   usedDepStringt   whereR  RQ  t   thisfilet   p_namet   p_flagt   p_et   p_vt   p_rt   provRo  t   taglist_provonlyt   arg_taglistt	   arg_regext
   searchlistt   tagt   tagdataR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   searchPackageProvides
  s    	""!$				c         C   s  g  } g  } |  j  j d k r3 t j t d   n  | d k rN |  j  j } n" |  j  j d j |  d | } xx | D]p } | j	 r | r | j
 r | j |  q q | j |  qw | r | j
 r | j |  q qw | j |  qw Wt |  t |  f S(   s   returns two lists of groups, installed groups and available groups
           optional 'uservisible' bool to tell it whether or not to return
           only groups marked as uservisiblei    s3   No group data available for configured repositoriest   ,t   case_sensitiveN(   R   RP  R   RM  R   R   t   groupst   return_groupsRD  R   t   user_visibleRE  R   (   R>   t   uservisibleR-  R  R   R  t   grpst   grp(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   doGroupLists  s&    
			c   	      C   s   g  } |  j  j |  } | s= t j t d  t |   n  x} | D]u } t | _ | j } xZ | j D]O } |  j	 d | d t  } | j
 |  x! | D] } | j j | j  q Wqf WqD W| S(   s1   mark all the packages in this group to be removeds   No Group named %s existsR   t   silence_warnings(   R   R  R   RM  R   R%   R.   t   toremovet   packagesR  R  R  RE  t   groupid(	   R>   t   grpidt   txmbrs_usedt   thesegroupst	   thisgroupR  R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   groupRemove&  s    		c         C   s+  |  j  j |  } | s7 t j t d  t |   n  x | D] } t | _ | j } x | j D] } x |  j	 D] } | j
 j | k rp | j
 j t k rp y | j j |  Wn9 t k
 r |  j j t j t d  | j
 |  qp n Xt | j  d k r|  j	 j | j
 j  qqp qp Wq` Wq> Wd S(   s3   unmark any packages in the group from being removeds   No Group named %s existss%   package %s was not marked in group %si    N(   R   R  R   RM  R   R%   RV   R  R  R  R  R   R  R  R  R  R   Rl   R   R   R*  R  RW   (   R>   R  R  R  R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   groupUnremove:  s$    		$c         C   s  |  j  j |  s1 t j t d  t |   n  g  } |  j  j |  } | sn t j t d  t |   n  |  j j } | r | } n  x| D]} | j	 r q n  t
 | _	 g  } d | k r | j | j  n  d | k r | j | j  n  d | k r| j | j  n  t |  }	 x | D] }
 |  j j t j t d  |
 | j  y |  j d |
  } Wn/ t j k
 r} |  j j t d  |
  q$X| j |  x! | D] } | j j | j  qWq$W|  j j } | d k	 r| } n  d } | rx| j j   D]\ } } |  j |  ry |  j d |  } Wn t j k
 rSq	n& X| |  j j  k ryg  |  j j  | <n  | j |  x; | D]3 } | j j | j  |  j j  | j | j!  qWq	n  |  j" j# d |  } | r	|  j$ j% r^|  j j& d	 k r^g  } |  j$ j' } | j d
  x- | D]% }
 |
 j$ | k r)| j |
  q)q)W| } q^n  t( |  } | t |  7} | |  j j  k rg  |  j j  | <n  |  j j  | j |  q	q	Wn  t |  |	 k r |  j) j* t d  | j  | r|  j) j* t d  |  qq q W| S(   s\  mark all the packages in the group to be installed
           returns a list of transaction members it added to the transaction 
           set
           Optionally take:
           group_package_types=List - overrides self.conf.group_package_types
           enable_group_conditionals=Bool - overrides self.conf.enable_group_conditionals
        s   No Group named %s existst	   mandatoryt   defaultt   optionals   Adding package %s from group %sR   s-   No package named %s available to be installedi    t   bestt   noarchs-   Warning: Group %s does not have any packages.sD   Group %s does have %u conditional packages, which may get installed.N(+   R   t	   has_groupR   RM  R   R%   R  R   t   group_package_typest   selectedR.   R  t   mandatory_packagest   default_packagest   optional_packagesR  Rl   R   R   R  R  R  t   InstallErrorR   R  RE  t   enable_group_conditionalsR   t   conditional_packagesR  t   isPackageInstalledR  t   conditionalsR  R)  R  R;   R.  t   multilib_policyt   legit_multi_archesR   Rk   RO  (   R>   R  R  R  R  R  t   package_typesR  R  t
   old_txmbrsR  R  R   R  t   group_conditionalst   count_cond_testt   condreqt   condt   useR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   selectGroupU  s    					!#c   	      C   s  |  j  j |  s1 t j t d  t |   n  |  j  j |  } | sh t j t d  t |   n  x/| D]'} t | _ x| j	 D]
} |  j
 j d t  } x | D] } | j j | k r q n  | s!y | j j |  Wq!t k
 r|  j j t j t d  | j |  q q!Xn  | s<t | j  d k r |  j
 j | j j  x9 |  j
 j j | j g   D] } |  j
 j | j  qnWq q Wq Wqo Wd S(   s   Without the force option set, this removes packages from being
            installed that were added as part of installing one of the
            group(s). If the force option is set, then all installing packages
            in the group(s) are force removed from the transaction. s   No Group named %s existss%   package %s was not marked in group %si    N(   R   R  R   RM  R   R%   R  RV   R  R  R  R  R   R  R  R   R  R  R   Rl   R   R   R*  R  RW   R  R   (	   R>   R  t   forceR  R  R   R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   deselectGroup  s0    	
"c         C   s   x$ |  j  D] } | j | k r
 | Sq
 W|  j j |  } t |  d k r |  j | |  | re d St j t	 d  t
 |   n  t |  d k r | d } n
 | d } | S(   s  retrieves a packageObject from a pkgtuple - if we need
           to pick and choose which one is best we better call out
           to some method from here to pick the best pkgobj if there are
           more than one response - right now it's more rudimentary.i    s2   Package tuple %s could not be found in packagesacki   N(   Rp   RW   R)  t   searchPkgTupleR  R  R   R   t   DepErrorR   R   (   R>   RW   t   allow_missingR  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   getPackageObject  s    
c         C   sa   |  j  j |  } t |  d k rS |  j | |  t j t d  t |   n  | d } | S(   s    Returns a YumInstalledPackage object for the pkgtup specified, or
            raises an exception. You should use this instead of
            searchPkgTuple() if you are assuming there is a value. i    s,   Package tuple %s could not be found in rpmdb(   R'  R  R  R  R   t
   RpmDBErrorR   R   (   R>   RW   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRk    s    
c         C   s   |  j  j d } t j j |  r& d St j j d |  j  j  } | j	 t
 j t
 j B | j d d  } | j   } ~ ~ | d k r d St j j |  } t j j |  s t j |  n  t | d  } | j   ~ d Sd S(	   sb   checks for the presence of gpg keys in the rpmdb
           returns 0 if no keys returns 1 if keyss   /.gpgkeyschecked.yumi   R-   R   s
   gpg-pubkeyi    t   wN(   R   RK   R   R   R   R$  t   transactiont   initReadOnlyTransactionR   t   pushVSFlagsR   t   _RPMVSF_NOSIGNATURESt   _RPMVSF_NODIGESTSt   dbMatchR  R  R  RH  Rw   (   R>   t   gpgkeyscheckedt   mytst   idxR  t   mydirR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   gpgKeyCheck	  s$    
c         C   s   | s
 g  St  |  t j k r1 | \ } } } n | } d } d } | d d k r | j   } t |  d k r | \ } } } | t k r t j t	 d  t
 |   n  t | } q n  |  j j | | |  j   S(   s~   Pass in a generic [build]require string and this function will 
           pass back the packages it finds providing that dep.i    R+   i   s   Invalid version flag from: %sN(   R  R  t	   TupleTypeR   t   splitR  t   SYMBOLFLAGSR   t   YumBaseErrorR   R   R)  t   getProvidesR  (   R>   t	   depstringt   depnamet   depflagst   depvert	   dep_splitt
   flagsymbol(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  $  s    c         C   s   | } t  |  t j k r* t |  } n  y |  j |  } Wn* t j k
 ri t j t d  |  n Xt |  } |  j	 | j
    } | d k r t j t d  |  n  | S(   s   Pass in a generic [build]require string and this function will 
           pass back the best(or first) package it finds providing that dep.s   No Package found for %sN(   R  R  t   StringTypesR   R  R   R  R   R   t   _bestPackageFromListR'  R   (   R>   R  Ra  R  t   psR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   returnPackageByDepA  s    c         C   s   | s
 g  St  |  t j k r1 | \ } } } n | } d } d } | d d k r | j   } t |  d k r | \ } } } | t k r t j t	 d  t
 |   n  t | } q n  |  j j | | |  j   S(   s   Pass in a generic [build]require string and this function will 
           pass back the installed packages it finds providing that dep.i    R+   i   s   Invalid version flag from: %sN(   R  R  R  R   R  R  R  R   R  R   R   R'  R  R  (   R>   R  R  R  R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  V  s    c         C   sN   t  |  d k r d St  |  d k r0 | d S|  j | d  } | d d S(   s   take list of package objects and return the best package object.
           If the list is empty, return None. 
           
           Note: this is not aware of multilib so make sure you're only
           passing it packages of a single arch group.i    i   N(   R  R   t   _compare_providers(   R>   R  t   bestlist(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  s  s    c         C   s  g  } |  j  j |  } g  } g  } g  } xq | D]i }	 |	 j  | k rL q1 q1 |	 j  d k rk | j |	  q1 t d |	 j   r | j |	  q1 | j |	  q1 W|  j |  }
 |  j |  } |  j |  } | r |
 r | r |
 j | j k r d } n  | d k r3|
 r| j |
  n  | r| j |  qn |
 r|  j |
 | g  } | j  d k rm| j |  q|
 r| j |
  n  | r| j |  qnW | r|  j | | g  } | j  d k r| j |  q| j |  n | j |  | S(   s   Takes a list of packages, returns the best packages.
           This function is multilib aware so that it will not compare
           multilib to singlelib packagesR  R;   N(   R;   t   get_arch_listRE  R   R  R   R   (   R>   R  R;   t   single_namet
   returnlistt   compatArchListt   multiLibt	   singleLibR  R  t   multit   singlet   noR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   bestPackagesFromList  sL    $	    c            sS   j  d
 k	 r*  j j  j g  } n  j j s: d
 St  d  s t j   } t	 j
 j g  g   }  j j d t  | _  j j d t j   |  |  _ n   j j  j g  }  j | k rO|  j } g  } x4 | D], } t  j | d  s | j |  q q W| r,| } n  t |  d k rx| d } g  | D]  }	 | d |	 d k rO|	 ^ qO} n  t |  d k rd   }
 | j |
  | d } g  | D] }	 |
 | |	  s|	 ^ q} n  t |  d k rd         f d   } | j |  n  x3 | D]+ }	  j |	 d	 t } | d
 k	 r| SqWd
 Sd
 S(   s    Given a package return the package it's obsoleted by and so
            we should install instead. Or None if there isn't one. R"  R#  s   Obs Init time: %0.3fi   i    c         S   sI   |  \ } } } } } | \ } } }	 }
 } t  | | | f |	 |
 | f  S(   N(   R   (   Rb  RY  t   n1t   a1t   e1t   v1t   r1t   n2t   a2t   e2t   v2t   r2(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt	   _sort_ver  s    c         S   s:   t  |  |  } | s d St  |  |  } | s2 d S| | S(   Ni    (   R   (   t   carchR  R  t   res1t   res2(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _sort_arch_i  s    c            se   |  \ } } } } } | \ } } }	 }
 }    j  | |  } | rI | S   j  j | |  } | S(   N(   R;   t   bestarch(   Rb  RY  R  R  R  R  R   R  R  R  R  R  R  (   R
  R  R>   (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt
   _sort_arch  s    R  N(   R_   R   R  t   checkForObsoleteRW   R   R+  R   R   R$  R%  R&  R)  R,  R.   R*  Rl   R   R"  R   R;   RE  R  R  R  (   R>   R  t   thispkgobsdictR9  R  R  t   oobsoletingt   opkgtupR  RW   R  R  R  (    (   R
  R  R>   s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _pkg2obspkg  sP    		
#	
	c         C   s   | } t  } x{ t r | |  } | d k r8 | r8 d S| d k rH | S| |  } | d k rd | St } | |  } | | k r d Sq Wd S(   s    Generic comp. sci. test for looping, walk the list with two pointers
            moving one twice as fast as the other. If they are ever == you have
            a loop. If loop we return None, if no loop the last element. N(   RV   R.   R   (   R>   t   nodet	   next_funct   slowR  t   next(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt
   _test_loop
  s    	   c         C   s   | d d k s t   | d } g  } xs |  j j |  D]_ } y# |  j | j  } | j |  Wq9 t j j k
 r |  j	 j
 t d  |  q9 q9 Xq9 W| S(   sD    Do groupinstall via. leading @ on the cmd line, for install/update.i    t   @i   s!   Warning: Group %s does not exist.(   t   AssertionErrorR   R  R  R  R  R   R   RM  Rk   RO  R   (   R>   t   patternt   group_stringt	   tx_returnt   groupR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _at_groupinstall  s    
c         C   s}   | d d k s t   | d } g  } y |  j |  } Wn0 t j j k
 rk |  j j t d  |  n X| j |  | S(   s;    Do groupremove via. leading @ on the cmd line, for remove.i    R  i   s   No group named %s exists(	   R  R  R   R   RM  Rk   RO  R   R  (   R>   R  R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _at_groupremove*  s    
c         C   s   | d d k s t   | d } |  j j |  } | sW t j t d  t |   n  t   } x | D] } | j | j	  qg W|  j
 j |  S(   s8    Do downgrade of a group via. leading @ on the cmd line.i    R  i   s   No Group named %s exists(   R  R   R  R   RM  R   R%   Rt   R   R  R)  R  (   R>   R  R  R  t   pkgnamesR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _at_groupdowngrade9  s    
	c         C   s]   | d d k s t   | d } | rM | d d k rM | d } |  j |  S|  j j |  S(   s5    Remove things from the transaction, like kickstart. i    t   -i   R  (   R  R  R  t   deselect(   R>   R  t   pat(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _minus_deselectF  s    

c         c   s   |  j  j s d St | t  sq xn |  j j d | j  D]2 \ } } | j | k r8 |  j |  } | Vq8 q8 Wn x |  j	 |  D] } | Vq Wd S(   s;    Return the pkgs. that are obsoleted by the po we pass in. NR   (
   R   R+  R   R   R  t   getObsoletersTuplesR   RW   Rk  t   _find_obsoletees_direct(   R>   R  t   obstupt   inst_tupt   installed_pkgR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _find_obsoleteesQ  s    %c         c   sR   xK | j  D]@ } x7 |  j j d |  D]  } | j | g  r& | Vq& q& Wq
 Wd S(   s<   Return the pkgs. that are obsoleted by the po we pass in. This works
            directly on the package data, for two reasons:
            1. Consulting .up. has a slow setup for small/fast ops.
            2. We need this work even if obsoletes are turned off, because rpm
               will be doing it for us. R   N(   t   obsoletes_namesR'  R  t   obsoletedBy(   R>   R  t   obs_nR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR&  _  s    c         G   s=   x6 | D]. } | |  j  j k r |  j  j j |  q q Wd S(   sB    Add all of the passed flags to the tsInfo.probFilterFlags array. N(   R  t   probFilterFlagsRE  (   R>   t   flagst   flag(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _add_prob_flagsj  s    c         K   s  g  } t  } | rU t | t  s0 t | t  r@ | j |  qt j t d   n`| sp t j t d   n  d | k r| d r | d d d k r |  j | d  S| d r | d d d k r |  j	 | d  St
 } | d g } |  j j d | d t   } | j |  | s7| d } |  j j t d	  |  y |  j |  } Wn9 t j j k
 r} |  j j t d
  t |   qX| rt j |  r|  j | d t
 } n  | r| j |  qq7n` |  j |  }	 |  j j d |	 d d |	 d d |	 d d |	 d d |	 d  } |  j | |	  | r|  j j r | sZ|	 d r |  j j d k ri  }
 g  } g  } |  j j  } | j d  xG | D]? } | j | k rd |
 | j! <| j |  q| j |  qWx- | D]% } | j! |
 k r| j |  qqW| } qq n  t" |  } i  } xD | D]< } | j! | k ra| g | | j! <q9| | j! j |  q9Wg  } x* | j#   D] } | j |  j |   qW| } n  | sd | k r|  j$ j d | d g d t   } n  d | k r|  j$ j d | d  } n  d | k r@|  j$ j d | d d  } n  t  rsx* | D] } |  j j% t d  |  qMWn  | r}g  St j t d   n  g  } xR| D]J} |  j& j' d | j(  r|  j& j) | j( t*  r|  j j+ t, j- t d  |  | j |  j& j. d | j(   qqn  |  j$ j/ | j! g  rn| j( |  j0 j1 k rn|  j2 d |  } | j |  qn  d" } |  j j4 r|  j5 | |  j6  } n  | d" k	 rd" } |  j$ j d | j!  } | j7 | d d } | r| d } n  | r|  j j% t d  | |  qd | k rY| j8 | d  sY|  j j% t d  | j! | j!  qqYn  |  j j% t d  | j! | j! |  | j |  j9 d |   qn  |  j$ j: d |  r|  j& j) | j( t;  s|  j j% t d   |  qqn  |  j< |  st
 } xQ |  j$ j d | j! d | j  D]. } t  } |  j& j) | j( t;  r#t
 } Pq#q#W| s|  j j% t d!  |  |  j2 d |  } | j |  qqn  xk |  j$ j d | j! d | j  D]H } | j= |  r|  j> t? j@ t? jA t? jB  |  j& jC | j(  PqqWxY |  j$ j d | j!  D]? } | jD |  r#tE | j | j  r#|  j> t? jF  Pq#q#WtG |  jH |   } | rxe | D]; } |  j& jI | |  } |  j& jJ | |  | j |  qWq|  j& jK |  } | j |  qW| S(#   s  try to mark for install the item specified. Uses provided package 
           object, if available. If not it uses the kwargs and gets the best
           packages from the keyword options provided 
           returns the list of txmbr of the items it installs
           
           s0   Package Object was not a package object instances   Nothing specified to installR  i    R!  R  R-  R  s3   Checking for virtual provide or file-provide for %ss   No Match for argument: %sR  R   R  R;   R   R  R  R  R  R  i   RW   s&   Package %s installed and not availables"   No package(s) available to installs)   Package: %s  - already in transaction setR  t   limits8   Package %s is obsoleted by %s which is already installedt   provides_forsW   Package %s is obsoleted by %s, but obsoleting package does not provide for requirementss;   Package %s is obsoleted by %s, trying to install %s insteads/   Package %s already installed and latest versions;   Package matching %s already installed. Checking for update.N(L   RV   R   R   R   RE  R   R  R   R$  R  R.   R)  R@  R  Rl   R   R  R   R  Rk   RO  R%   RK  R  R  t   _nevra_kwarg_parseR  R  R;   R.  R   R  R  R   R   R  R'  R   R  R   RW   R  R  R   R   R*  R  R  R  t   updating_dictR   R   R+  R  R  R,  R3  R  Rz  R  R  R  R1  R   t   RPMPROB_FILTER_REPLACEPKGt   RPMPROB_FILTER_REPLACENEWFILESt   RPMPROB_FILTER_REPLACEOLDFILESR  R&  R   t   RPMPROB_FILTER_OLDPACKAGER?  R&  t   addObsoletingR  t
   addInstall(   R>   R  R   R  t   was_patternt   patst   mypkgsR   R   R  t   pkgs_by_nameR  t	   not_addedR  R  t	   pkgbynamet   lstR  R  t   obsoleting_pkgt   already_obsR(  R  t   obs_pkgst	   obsoleteeR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  p  s(   	
$	  			(	(
%c         C   s   t  | j d   } t  | j d   } g  } x | j |  D] } |  j j |   } x | D]y } xp | | D]d }	 | j d |	  sp | j | j f }
 x3 |  j j	 |
  D] } | j
 |  j d |   q WPqp qp Wq_ Wq@ W| S(   s    Check for any difference in the provides of the old and new update
            that is needed by the transaction. If so we "update" those pkgs
            too, to the latest version. R  R  (   Rt   t
   returnPrcot
   differenceR  t   getRequirest   inPrcoRangeR   R;   R)  R'  R  R   (   R>   t   opkgt   npkgt   oprovst   nprovsR  R  RG  R  RI  t   naTup(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _check_new_update_providesX  s    c   
      C   s   t  } x |  j j | t g  D] } d } x | j D]z } | j |  rW | d 7} q5 xU |  j j | j  D]> } |  j j | j	 j  |  j
 | j	 |  }	 | j |	  qm Wq5 W| r t } q |  j j | j	 j  q W| S(   s   We return True if there is a newer package already in the
            transaction. If there is an older one, we remove it (and update any
            deps. that aren't satisfied by the newer pkg) and return False so
            we'll update to this newer pkg. i    i   (   RV   R  R  R  R  t   verLER  RW   R  R  RP  R  R.   (
   R>   RW   t   available_pkgR  R(  R  R  R  t   ntxmbrt   txs(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _newer_update_in_transj  s    		c         C   s\   |  j  j | |  } | r+ | j |  n  d | j k rX | j j d k rX d | _ n  | S(   NRn  R  (   R  t	   addUpdatet   setAsDepRl  Rn  (   R>   t   requiringPot   upkgR  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _add_up_txmbr  s    !c   %      K   s
  g  } | r| r|  j  j t j t d   |  j j   } |  j j rc |  j j	 d d  } n g  } x | D] \ } }	 |  j
 | d t }
 |
 d k r qp n  |  j |
 |  j  } | d k	 r | }
 n  |  j |	  } |  j j |
 |  } |  j j | |
  | r| j |  n  | j |  qp Wx | D] \ } } |  j j d |  rv|  j  j t j t d  |  q2|  j
 | d t } | d k rq2n  | j |  j d |   q2W| Sg  } g  } | r| j d k r| j |  q| j |  nd	 | k r| d	 r:| d	 d
 d k r:|  j | d	  S| d	 ri| d	 d
 d k ri|  j | d	  S| d	 } | s|  j j d | g  } n |  j j d | g  } | rG| rGg  } y+ | r|  j |  } n |  j |  } Wn3 t  j! j" k
 r } |  j# j$ t d  |  n X| r7| j |  qG| j |  n  y5 | rYg  } n" | d	 g } |  j j% d |  } Wn t! j& k
 rg  } n X| j |  | r| r|  j# j$ t d  t' |   qn|  j( |  } |  j j) d | d d | d d | d d | d d | d  } | s|  j j) d | d d | d d | d d | d d | d  } |  j* | |  t+ |  d k r|  j, | |  } t- d   |  } q| s|  j# j. t d  |  j/ |   qn  |  j j rax | D] } |  j j0 j1 | j2 g   } g  } xB | D]: } |  j
 | d t }
 |
 d k rVq)n  | j |
  q)Wx- t3 |  D] }
 | j |  j4 d |
   qtWqWx | D] } x |  j5 |  D] } | j2 } |  j j | |  } | r| j |  n  | j |  |  j j |  r4|  j  j t j t d  |  q|  j j | |  } | j |  qWqWn  x| D]z} xq|  j j6 j1 | j2 g   D]T} |  j
 | d t } | d k rqn  |  j j | j2  r|  j  j t j t d  | j2  q| j2 |  j j7 d | j8  k rx |  j5 |  D]d } |  j j9 | |  } | rT| j |  n  |  j j | |  |  j j | |  | j |  q#Wq|  j j: | j2 t;  r|  j j< | j2  n  |  j= | | |  } | j |  qWqhWx`| D]X} |  j | |  j  }
 |
 d k	 rR|  j  j t j t d  |  | j |  j d |
   qn  x |  j j> j1 | j2 g   D] }  |  j j |   r|  j  j t j t d  |   qn|  j? |  | |  r|  j  j t j t d  |   qn|  j |   }! |  j j: |  t;  r	|  j j< |   n  |  j= | | |!  } | j |  qnW|  j j) d | j8 d | j@  }" |" r	|  jA |  r	tB |"  d }" n  x |" D] }# |  j j |# j2  r	|  j  j t j t d  |# j2  q	|  j? |# j2 | |  r
|  j  j t j t d  |# j2  q	|# jC |  r	|  j= | | |#  } | j |  q	q	WqWxq | D]i } x` |  j j) d | j8  D]F }$ |$ | jD k ro
|  jE | jF |$  r
|  j jG |$ | jF  q
qo
qo
WqP
W| S(   su  try to mark for update the item(s) specified. 
            po is a package object - if that is there, mark it for update,
            if possible
            else use **kwargs to match the package needing update
            if nothing is specified at all then attempt to update everything
            
            returns the list of txmbr of the items it marked for updates   Updating EverythingR#  i   R  RW   s>   Not Updating Package that is already obsoleted: %s.%s %s:%s-%sR  R   R  i    R!  R  R-  s   %ss   No Match for argument: %sR   R  R;   R   R  R  R  c         S   s   |  d S(   Ni    (    (   Rb  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    s!   No package matched to upgrade: %ss,   Package is already obsoleted: %s.%s %s:%s-%ss*   Not Updating Package that is obsoleted: %ss<   Not Updating Package that is already updated: %s.%s %s:%s-%siN(H   Rl   R   R   R  R   R  t   getUpdatesTuplesR   R+  R+  R  R.   R   R  R  Rk  R  R:  R  RW  RE  t   isObsoletedR  R   R  R$  R  R'  R@  R)  R  R  R   R   R  Rk   RO  R'  R(  R%   R4  R  R  R  R  t   mapR   t   _ui_nevra_dictt   obsoleted_dictR   RW   R   R  R*  t   updatesdictt   getObsoletesListR   RV  R  R  R  RZ  R5  RU  R;   R  R   t   verLTR%  t   _does_this_updateR  t
   addUpdated(%   R>   R  RX  t	   update_toR   R  R%  R+  R  R   RC  t   topkgR)  R  t   newt   oldt   instpkgst	   availpkgsR   t
   depmatchesR   t   mR=  R  t   obs_tupsRE  RW   RR  t   obsoleted_pkgR  t   updatingRF  R  t   updated_pkgt   pot_updatedR  t   i_pkg(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR     sJ   		
	
&(	!	#"!	"			!	$c         K   s&  | r | r t  j d  n  g  } g  } | r; | g } nd | k r| d rv | d d d k rv |  j | d  S| d r | d d d k r |  j | d  S|  j j | d g  \ } } } | j |  | j |  | r4g  } | d }	 y |  j |	  } Wn3 t j  j	 k
 r?} |  j
 j t d  |  n X| sut |	  }	 |  j
 j t d  t |	   q| j |  q4n |  j |  }
 |  j j d |
 d d	 |
 d	 d
 |
 d
 d |
 d d |
 d  } |  j | |
  t |  d k r4| j d t  s4|  j
 j t d  |  j |
   q4n  |  j j   } t j |  } x | D] } |  j j r| j | k r|  j
 j t d  |  qYn  |  j j | j  rxM |  j j | j  D]3 } |  j
 j  t d  |  |  j j! | j  qWn  |  j j" |  } | j# |  qYW| S(   s   try to find and mark for remove the specified package(s) -
            if po is specified then that package object (if it is installed) 
            will be marked for removal.
            if no po then look at kwargs, if neither then raise an exceptions   Nothing specified to removeR  i    R!  R  s   %ss   No Match for argument: %sR   R  R;   R   R  R  R  R  s    No package matched to remove: %ss   Skipping the running kernel: %ss    Removing %s from the transaction($   R   t   RemoveErrorR$  R  R'  t   matchPackageNamesR  R  R   R  Rk   RO  R   R%   R4  R  R  R  R   RV   R   R^  R  RK  R  R   R  RW   R  R  R  R   R  R  t   addEraseRE  (   R>   R  R   R  R  R   Rl  R  Rk  R   R  R   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s^    "
#(c         C   s  g  } g  } g  } g  } | s y1 t  |  d |  j j   d | d t j j } Wn. t j k
 r |  j j	 t
 d  |  | SX|  j j t j t
 d  | j |  n  | j d d k r |  j j	 t
 d  |  | S| j |  j j k r|  j j	 t
 d	  | | j  | S|  j j rg| j |  j j | j   } | rg|  j j	 t
 d
  | | d  | Sn  |  j j d | j  }	 t |	  d k r| r|  j j t
 d  | j  | S| j |  n  xa|	 D]Y}
 | j |
  rF|
 j |  j j k r0| j |
 j k r | j | |
 f  qC| j |  q'| j | |
 f  q| j |
  r| j |
 j k rt | j  st |
 j  r| r|  j j t
 d  | j | j  q| j |  q'| j |  q|  j  |  r| r
|  j j t
 d  | j | j  q'| j |  q| j |  qW| g  | D] } | d ^ q5} |  j! | |  r{|  j j" t
 d  |  | SxY | D]Q } |  j j t j t
 d  | j  |  j# j |  | j$ |  j% d |   qWxh | D]` \ } } |  j j t j t
 d  | j |  |  j# j |  |  j& d |  } | j$ |  qWx0 | D]( } |  j j t j t
 d  | j  qIWx | D]x } | j' j r|| j r|xY |  j( | j'  D]B } |  j) j* | | j'  | j j |  |  j) j+ | j' |  qWq|q|W| S(   sE  
        handles installs/updates of rpms provided on the filesystem in a
        local dir (ie: not from a repo)

        Return the added transaction members.

        @param pkg: a path to an rpm file on disk.
        @param po: A YumLocalPackage
        @param updateonly: Whether or not true installs are valid.
        R   t   urlt   uas   Cannot open: %s. Skipping.s   Examining %s: %st   payloadformatt   drpms+   Cannot localinstall deltarpm: %s. Skipping.sG   Cannot add package %s to transaction. Not a compatible architecture: %ssB   Cannot install package %s. It is obsoleted by installed package %si    R   sR   Package %s not installed, cannot update it. Run yum install to install it instead.sU   Package %s.%s not installed, cannot update it. Run yum install to install it instead.s   Excluding %ss   Marking %s to be installedR  s   Marking %s as an update to %ss&   %s: does not update installed package.(,   R    R'  R  R(   t   optst
   user_agentR   R  Rk   RO  R   Rl   R   R   Rs  R  R  R;   R  R   R+  R,  t   searchObsoletesR   R  R  R   RE  R&  R4  R  R   R  t   _is_local_excludeR   Rp   R  R  R   R  R*  R  R  R:  (   R>   R  R  t
   updateonlyR  t   installpkgst
   updatepkgst   donothingpkgst
   obsoleterst   installedByKeyR)  Rb  t
   check_pkgst   oldpoR  R  t   obs_pkg(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   installLocal  s     %%!!c         C   s
  | s y1 t  |  d |  j j   d | d t j j } Wn. t j k
 rg |  j j	 t
 d  |  g  SX|  j j t j t
 d  | j |  n  | j |  j j k r |  j j	 t
 d  | | j  g  S|  j | | g  r |  j j t
 d  |  g  S|  j d |  S(	   s   
        handles reinstall of rpms provided on the filesystem in a
        local dir (ie: not from a repo)

        Return the added transaction members.

        @param pkg: a path to an rpm file on disk.
        @param po: A YumLocalPackage
        R   Rv  Rw  s   Cannot open file: %s. Skipping.s   Examining %s: %ssG   Cannot add package %s to transaction. Not a compatible architecture: %ss   Excluding %sR  (   R    R'  R  R(   Rz  R{  R   R  Rk   RO  R   Rl   R   R   Rs  R  R;   R  R}  R   R~  (   R>   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   reinstallLocalY  s     c         K   s  |  j  t j t j t j  g  } | rG | j |  j d | j   n | j |  j |    | sx t j	 t
 d   n  t |  } g  } g  } g  } x | D] } |  j j }	 t |  j _ t | t  r |  j d |  }
 n |  j d | j  }
 |	 |  j _ t |
  d k r_|  j j | j  | j |  | j t | j   | j | j  q n  | j |
  q W| r| rt j t
 d  d j |  d |  n  | j |  | S(   sf   Setup the problem filters to allow a reinstall to work, then
           pass everything off to installRW   s2   Problem in reinstall: no package matched to removeR  i    s6   Problem in reinstall: no package %s matched to installs   , t   failed_pkgs(   R1  R   R6  R7  R8  R  R  RW   R   t   ReinstallRemoveErrorR   R  R   R+  RV   R   R   R  R  RE  R   R  t   ReinstallInstallErrorRD  (   R>   R  R   t   tx_mbrst   templent   new_membersR  R  R  t   old_conf_obst   members(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR~  y  s>    
+c         C   s
  | s y1 t  |  d |  j j   d | d t j j } Wn. t j k
 rg |  j j	 t
 d  |  g  SX|  j j t j t
 d  | j |  n  | j |  j j k r |  j j	 t
 d  | | j  g  S|  j | | g  r |  j j t
 d  |  g  S|  j d |  S(	   s   
        handles downgrades of rpms provided on the filesystem in a
        local dir (ie: not from a repo)

        Return the added transaction members.

        @param pkg: a path to an rpm file on disk.
        @param po: A YumLocalPackage
        R   Rv  Rw  s   Cannot open file: %s. Skipping.s   Examining %s: %ssG   Cannot add package %s to transaction. Not a compatible architecture: %ss   Excluding %sR  (   R    R'  R  R(   Rz  R{  R   R  Rk   RO  R   Rl   R   R   Rs  R  R;   R  R}  R   t	   downgrade(   R>   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   downgradeLocal  s     c         C   s   d |  j  j k s$ d |  j  j k r( t Sg  } t |  j  j  d k rw t | |  j  j d d \ } } } | | } n  | | k r t St S(   s0   returns True if the local pkg should be excludedR  R   i    R!  i   (   R   R  RV   R  R  R   R.   (   R>   R  R  t   toexcR9  R  R:  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR}    s    $c         K   s  | r | r t  j d  n  t } | r5 | g } nud | k rJ| d rp | d d d k rp |  j | d  S| d r | d d d k r |  j | d  } t } q|  j j d | d g d t  } | s| d } |  j j	 t
 d  |  y |  j |  } WqGt j  j k
 rC} |  j j t
 d	  t |   qGXqn` |  j |  } |  j j d
 | d
 d | d d | d d | d d | d  } |  j | |  | s.g  } d | k r|  j j d | d g d t  } n  d
 | k r|  j j d
 | d
  } n  | rg  St  j t
 d   n  t   }	 g  }
 x | D] } |  j |  r| j | j f |	 k rt
 d  | } |  j j t j |  n  |	 j | j | j f  qDn  |
 j |  qDW|
 } t   } x | D] } | j | j  qW|  j j t |   } i  } i  } x t  |  D] } | j | k sZ| j! | | j d  rm| g | | j <n1 | j" | | j d  r| | j j |  n  | | | j | j f <q+Wi  } xt  |  D]} | j | j f } d } | | k r| | } n[ | j | k r]xI | | j D]7 } t$ | j | j  s| } | j | j f } PqqWn  | d k r| |	 k r| r| j | k rt
 d  | } |  j j |  n  |	 j |  qn  | j% |  r| |	 k rt
 d  | } |  j j |  n  |	 j |  qn  |	 j |  | j& | k rJ| j' | | j&  rJqn  | | | j& <qWg  } xh | D]` } | j& | k rqhn  |  j( j) | | j& |  } | sqhn  |  j* t+ j,  | j- |  qhW| S(   s    Try to downgrade a package. Works like:
            % yum shell <<EOL
            remove  abcd
            install abcd-<old-version>
            run
            EOL s   Nothing specified to downgradeR  i    R!  R  R-  R  s3   Checking for virtual provide or file-provide for %ss   No Match for argument: %sR   R  R;   R   R  R  R  s$   No package(s) available to downgrades1   Package %s is allowed multiple installs, skippings"   No Match for available package: %ss%   Only Upgrade available on package: %sN(.   R   t   DowngradeErrorRV   R$  R   R.   R)  R@  Rl   R   R   R  R   R  Rk   RO  R%   R4  R  R  R'  Rt   R  R   R;   R   R   Rs  R   RE  R  R?  R   R&  R  R   R   t   verGERW   RQ  R  t   addDowngradeR1  R   R9  R  (   R>   R  R   t   doing_group_pkgst   apkgsR   R   R  R  t
   warned_nast   tapkgsR  R   t
   apkg_namesR;  t   latest_installed_nat   latest_installed_nt   downgrade_apkgsRx  t   lipkgt   tlipkgR  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    		
*


		c         C   s   |  d } |  d } |  d } |  d } |  d } | rZ | rZ | rZ d | | | f } nV | r| | r| d | | | f } n4 | r | r d | | f } n | r | } n d	 } | r | r d | | f S| r d
 | S| r | Sd S(   NR   R  R  R  R;   s   %s:%s-%ss   %s-%ss   %s:%sRv  s   *-%ss	   <unknown>(    (   R  R  R   R  R  R  t   evr(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR^  a  s*    




	c         C   s  i  } d | k ra | d \ } } } } } | | d <| | d <| | d <| | d <| | d <| S| j  d  | d <| j  d  | d <| j  d  | d <| j  d  | d <| d d  k r | j  d  | d <n  | j  d  | d <| d d  k r| j  d  | d <n  | S(	   NRW   R   R  R;   R  R  R   R  (   R   R   (   R>   R   t
   returndictR  R  R   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR4  {  s&    




c         C   s  |  j  j } t |  j  _ t } xA | j D]6 } | j d k r( |  j d | j  r^ t } q^ q( q( Wxx | j D]m } | j d k rl y" |  j d | j  r t } n  Wq t	 j
 j k
 r |  j j t d  |  q Xql ql WxZ | j D]O } | j d k r |  j d | j  rt } q6|  j j t d  |  q q WxA | j D]6 } | j d k rD|  j d | j  rzt } qzqDqDWxA | j D]6 } | j d
 k r|  j d | j  rt } qqqW| |  j  _ | S(   s[    Given a valid historical transaction object, try and repeat
            that transaction. t	   ReinstallRW   t	   Downgrades   Failed to downgrade: %st   Updates   Failed to upgrade: %st   Installs   True-Installt
   Obsoletingt   Erase(   R  s   True-InstallR  (   R   R+  RV   t
   trans_dataR  R~  RW   R.   R  R   R   R  Rk   RO  R   R   R  R  (   R>   R  R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   history_redo  s:    $	 c         C   su  |  j  j } t |  j  _ t } xA | j D]6 } | j d k r( |  j d | j  r^ t } q^ q( q( Wxx | j D]m } | j d k rl y" |  j d | j  r t } n  Wq t	 j
 j k
 r |  j j t d  |  q Xql ql WxZ | j D]O } | j d k r |  j d | j  rt } q6|  j j t d  |  q q Wx\ | j D]Q } | j d k rD|  j j | j  rtqDn  |  j d | j  rt } qqDqDWxA | j D]6 } | j d k r|  j d | j  rt } qqqWxA | j D]6 } | j d k r|  j d | j  rt } qqqWxA | j D]6 } | j d k r+|  j d | j  rat } qaq+q+W| |  j  _ | S(   sY    Given a valid historical transaction object, try and undo
            that transaction. R  RW   t   Updateds   Failed to downgrade: %st
   Downgradeds   Failed to upgrade: %sR  s   Dep-InstallR  s   True-Installt	   ObsoletedR  (   s   Dep-Installs   Installs   True-Install(   R   R+  RV   R  R  R~  RW   R.   R  R   R   R  Rk   RO  R   R   R  R  R  R  (   R>   R  R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   history_undo  sN    $	 c         C   s  t  } t d  | } |  j j t j |  y` t j |  } | d k r` i d d 6} d } n | j	   } | j
 d } t j | |  }	 Wn> t j j k
 r }
 t j t d  t t |
     n Xd } t  } | r| r| j r|  j | d | j yB t j | d  } | j	   } | j
 d	 } t j | |  } Wn t j j k
 rg}
 d } n X| rt j | t j |	  | j  st j t d
  | | j
 f   qt d  } |  j j t j |  t } qn  y t j |	 d t } Wn> t k
 r;}
 t j t d  | t t |
   f   n Xg  } x | D] } i  } xA d D]9 } | | k rt j t d  |  n  | | | | <q\Wt j | d  j   | d <| | d <t |  | d <| j  |  qIW| S(   s   
        Retrieve a key file
        @param keyurl: url to the key to retrieve
        Returns a list of dicts with all the keyinfo
        s   Retrieving key from %si'  R2  s   global/gpgkeys   /gpgkeys   GPG key retrieval failed: RE   s   .ascs
   /gpgkeysigs>   GPG key signature on key %s does not match CA Key for repo: %ss,   GPG key signature verified against CA Key(s)t   multiples   Invalid GPG Key from %s: %st   keyidR{  t   useridt   fingerprintt   raw_keys2   GPG key parsing failed: key does not have value %st   hexkeyidt	   valid_sigt   has_sigN(   R  s	   timestamps   useridR  R  (!   RV   R   Rl   R   R   Rs  RK  t   to_utf8R   t   _default_graboptsR   R  t   urlreadR   R   R   R  R%   R   t   gpgcakeyt   getCAKeyForRepoRH   t   urlopent   valid_detached_sigt   StringIOt   gpgcadirR.   t   getgpgkeyinfoR   t   keyIdToRPMVert   uppert   boolRE  (   R>   t   keyurlRO   t   getSigt   key_installedR   Rv  Rz  R  t   rawkeyR   t   sigfileR  t	   keys_infoR  t   keyinfot   thiskeyR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _retrievePublicKey  sf    	
	% 

t   GPGc      	   C   s   d  } | j d  r | t d  } |  j j |  } | r t |  d } t d  | | d t | d  | | j | j	 d d  f } q n  | d  k r t d  | | d t | d  | j	 d d  f } n  |  j
 j d	 |  d  S(
   Ns   file:isB   Importing %s key 0x%s:
 Userid : %s
 Package: %s (%s)
 From   : %sR  R  s   file://Rv  s0   Importing %s key 0x%s:
 Userid: "%s"
 From  : %ss   %s(   R   R  R  R'  t   searchFilesR   R   R%   t   ui_from_repot   replaceRk   RO  (   R>   R  R  t   keytypeR   t   fnameR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _getKeyImportMessage=  s    			c         C   s  |  j  j | j  } | j } t } t } x| D]} |  j | |  }	 x|	 D]}
 |  j j   } t j	 | |
 d |
 d  d k r |  j
 j t d  | |
 d f  qP n  | j r |
 d r |
 d r t } n |  j |
 |  t } |  j j rt } nr | rR| i | d 6|
 d	 d	 6|
 d d 6| d
 6|
 d d 6|
 d d 6 } n# | ru| | |
 d	 |
 d  } n  | st } qP n  |  j j   } | j t j |
 d   } | d k rt j t d  |  n  |  j
 j t d   t } qP Wq1 W| r| rt j t d   n  | s?t j t d  | j  n  |  j |  \ } } | d k r|  j
 j t d   t j |  n  d S(   s  
        Retrieve a key for a package. If needed, prompt for if the key should
        be imported using askcb.
        
        @param po: Package object to retrieve the key of.
        @param askcb: Callback function to use for asking for permission to
                      import a key. This is verification, but also "choice".
                      Takes arguments of the po, the userid for the key, and
                      the keyid.
        @param fullaskcb: Callback function to use for asking for permission to
                          import a key. This is verification, but also "choice".
                          Differs from askcb in that it gets passed a
                          dictionary so that we can expand the values passed.
        R  R{  i    s)   GPG key at %s (0x%s) is already installedR  R  R  R  R  R  R  R  s   Key import failed (code %d)s   Key imported successfullys   Didn't install any keyss   The GPG keys listed for the "%s" repository are already installed but they are not correct for this package.
Check that the correct key URLs are configured for this repository.s+   Import of key(s) didn't help, wrong key(s)?N(   RQ   R  R  R  RV   R  R'  R  RK  t   keyInstalledRk   R  R   R  R.   R  R   t	   assumeyest   pgpImportPubkeyt
   procgpgkeyR   R  R   R  (   R>   R  t   askcbt	   fullaskcbRO   t   keyurlsR  t   user_cb_failR  R  R  R   R$  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   getKeyForPackageS  s\    	#			c         C   s  t  } t  } x| D]} |  j | | d | }	 x|	 D]~}
 t t |
 d   d d !j   t j |  k r |  j j t	 d  | |
 d f  t
 } q9 n  | r$| j d } d } g  } y( t | d	  j   } | j d
  } Wn t t f k
 rn Xt |
 d  | k rPt
 } qPn, d } | j rP|
 d rP|
 d rPt
 } n  | s|  j |
 | |  t  } |  j j rt
 } nO | r| i | d 6|
 d d 6|
 d d 6| d 6|
 d d 6|
 d d 6 } n  | st
 } q9 qn  t j |
 d |
 d d | } | s#t j t	 d   n  |  j j t	 d   t
 } | r9 | r9 |
 d | k rt | d  } y- | j |
 d d
  | j   | j   Wqt t f k
 rqXqq9 q9 Wq W| r| rt j t	 d  |  n  | st j t	 d  | j  n  d S(   sL  
        Retrieve a key for a repository If needed, prompt for if the key should
        be imported using callback
        
        @param repo: Repository object to retrieve the key of.
        @param destdir: destination of the gpg pub ring
        @param keyurl_list: list of urls for gpg keys
        @param is_cakey: bool - are we pulling in a ca key or not
        @param callback: Callback function to use for asking for permission to
                         import a key. This is verification, but also "choice".
                         Takes a dictionary of key info.
        R  R  i   is(   GPG key at %s (0x%s) is already importedR  s   /imported_cakeyst   CAR  s   
R  R  R  RO   R  R  R  R{  R  t   gpgdirs   Key import faileds   Key imported successfullyR  s#   Didn't install any keys for repo %ss   The GPG keys listed for the "%s" repository are already installed but they are not correct.
Check that the correct key URLs are configured for this repository.N(   RV   R  t   hexR   R  RK  t   return_keyids_from_pubringRk   R  R   R.   R   RH  RI  R  RL  RM  R   R  R  R   R  t   import_key_to_pubringR   R  R  t   flushRw   R   (   R>   RO   t   destdirt   keyurl_listt   is_cakeyRE   R  R  R  R  R  t   ikfR  t   cakeyst   cakeys_dR$  R  t   ikfo(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _getAnyKeyForRepo  sr    2			 
	c         C   s)   |  j  | | j | j d t d | d S(   sV  
        Retrieve a key for a repository If needed, prompt for if the key should
        be imported using callback
        
        @param repo: Repository object to retrieve the key of.
        @param callback: Callback function to use for asking for verification
                          of a key. Takes a dictionary of key info.
        R  RE   N(   R  R  R  RV   (   R>   RO   RE   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   getKeyForRepo  s    	c         C   s)   |  j  | | j | j d t d | d S(   sV  
        Retrieve a key for a repository If needed, prompt for if the key should
        be imported using callback
        
        @param repo: Repository object to retrieve the key of.
        @param callback: Callback function to use for asking for verification
                          of a key. Takes a dictionary of key info.
        R  RE   N(   R  R  R  R.   (   R>   RO   RE   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  
  s    
c         C   s  d   } |  j  j d k  r d Sg  } |  j j   } t j |  \ } } t |  j  j  } x.|  j j	   D]} | j
 d k r qk n  | j r qk n  t | j g | j j  } | j |  s qk n  |  j j d | j  }	 | |	  }	 t |	  |  j  j d k  rqk n  t |	  |  j  j d }
 x_ |	 D]W } | j | j f | | f k rWq-n  |
 d k rgPn  | j | | f  |
 d 8}
 q-Wqk Wx6 | D]. \ } } |  j j |  } | j j |  qWd S(	   s    Limit packages based on conf.installonly_limit, if any of the
            packages being installed have a provide in conf.installonlypkgs.
            New in 3.2.24: Obey yumdb_info.installonly data. c         S   s   g  } g  } g  } x t  |   D] } d | j k rG | j |  q n  | j j d k r_ q n  t rx | j |  q n  | j j d k r | j |  q | j j d k r | j |  q | j |  q W| | | S(   sa    Allow the admin to specify some overrides fo installonly pkgs.
                using the yumdb. t   installonlyt   keeps   remove-firsts   remove-last(   R   Rl  RE  R  R.   (   R  t   ret_begt   ret_midt   ret_endR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   _sort_and_filter_installonly  s$    i   NRd  R  R   i    (   Rd  R  (   R   t   installonly_limitR'  R  RK  t"   get_running_kernel_version_releaseRt   R  R  R  t   ts_stateR~  R   R  R  R  R  R  R  R  RE  Ru  R  (   R>   R  R  R   t   cur_kernel_vt   cur_kernel_rt   install_only_namesRl  t   po_namesR   t   numleftR  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s<    		c         C   s   | s t  j   } n  | j t  j  |  j |  } | d k rc | j t  j  |  j | |  n  | j t  j  |  j	 | d | | j t  j
  |  j | d | d S(   s  
        Process the current Transaction
        - Download Packages
        - Check GPG Signatures.
        - Run Test RPM Transaction
        - Run RPM Transaction
        
        callback.event method is called at start/end of each process.
        
        @param callback: callback object (must have an event method)
        @param rpmTestDisplay: Name of display class to use in RPM Test Transaction 
        @param rpmDisplay: Name of display class to use in RPM Transaction 
        t   displayN(   t	   callbackst   ProcessTransNoOutputCallbackt   eventt   PT_DOWNLOADt   _downloadPackagesR   t   PT_GPGCHECKt   _checkSignaturest   PT_TEST_TRANSt   _doTestTransactiont   PT_TRANSACTIONt   _doTransaction(   R>   RE   t   rpmTestDisplayt
   rpmDisplayR  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   processTransactiona  s    c         C   s  t  d   t d   |  j j     } t |  d k r= d S| j t j |  y |  j	 |  } Wn& t
 k
 r t j t d  g  n Xt |  d k rt d  g } xI | D]A } t j | |  } x% | D] } | j d | | f  q Wq Wt j |  n  | S(   s/    Download the need packages in the Transaction c         S   s   |  j  S(   N(   R  (   Rb  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    c         S   s   |  j  d k S(   NRd  R  (   Rd  R  (   R  (   R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRg    s    i    s!   Unable to find a suitable mirror.s3   Errors were encountered while downloading packages.s   %s: %sN(   R]  t   filterR  R  R  R   R  R  t   PT_DOWNLOAD_PKGSR  R  R   R  R   RK  Rb  RE  t   YumDownloadError(   R>   RE   t   dlpkgsR%  t   errstrR6  R6  R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s"    c         C   sj   xc | D][ } |  j  |  \ } } | d k r4 q q | d k rV |  j | |  j  q t j |  q Wd S(   s/    The the signatures of the downloaded packages i    i   (   R  R  t   _askForGPGKeyImportR   t   YumGPGCheckError(   R>   R  RE   R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    c         C   s   t  S(   su    
        Ask for GPGKeyImport 
        This need to be overloaded in a subclass to make GPG Key import work
        (   RV   (   R>   R  R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    c         C   s  |  j    |  j } d |  _ |  j d d  |  j j t j t d   |  j	   } | rt
 } x) | D]! } | j d  r qg n  t } qg W| r t d  g } | j |  t j |  n  t d  g } | j |  | j t d  |  j j  t j |  n  i  } x' d g D] }	 t |  j |	  | |	 <qWt |  d	 t
 }
 | rY| |
 _ n  |  j j |
 d
 | } ~
 t |  d k rt d  } x | D] } | d | 7} qWt j |  n  |  ` | |  _ d S(   s    Do the RPM test transaction t   keepoldi    s   Running Transaction Checks   rpmlib(s'   ERROR You need to update rpm to handle:s)   ERROR with transaction check vs depsolve:s   Please report this error at %st   diskspacecheckt   testR   s   Test Transaction Errors: s     %s
N(   t   initActionTsR  R   t
   populateTsRl   R   R   Rs  R   t   _run_rpm_checkR.   R  RV   R  R   t   YumRPMCheckErrorRE  R   t   bugtracker_urlR   R#   R  R   R  R  t   YumTestTransactionError(   R>   RE   R  t   dscbt   msgst   rpmlib_onlyR   t   retmsgst   tsConft   featuret   testcbt   tserrorsRa  t   descr(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    sJ    
		
c         C   sl   |  j    |  j d d  |  j j   |  j j   t |  d t } | rX | | _ n  |  j d |  d S(   s    do the RPM Transaction R  i    R  Rz   N(	   R  R  R   R  t   orderR#   R$   R  Re  (   R>   RE   R  Rz   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s    
c         C   sD   g  } |  j  j   x* |  j  j   D] } | j t |   q# W| S(   N(   R   R  R  RE  R&   (   R>   RF  R'  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR    s
    c   
      K   s  t  j |  } | | _ |  j j | _ | j d t  } | r g  } | r x< | D]+ } | rR | j t	 | |  j j
   qR qR Wn | } | | _ n  | r | r t	 | |  j j
  } n  | | _ n  | j d |  j j  t | _ d | _ |  j j | _ |  j j | _ |  j j | _ |  j j | _ x= | j   D]/ }	 t | |	  sRq7n  t | |	 | |	  q7W|  j j |  |  j j | j  | S(   s  add and enable a repo with just a baseurl/mirrorlist and repoid
           requires repoid and at least one of baseurl and mirrorlist
           additional optional kwargs are:
           variable_convert=bool (defaults to true)
           and any other attribute settable to the normal repo setup
           ex: metadata_expire, enable_groups, gpgcheck, cachedir, etc
           returns the repo object it addedt   variable_convertRL   i    (   R   R   R   R   RK   R   R   R.   RE  R   R   R  t
   mirrorlistt   setupRL   t   enablegroupst   metadata_expireR  t   repo_gpgcheckR   R   R  R   R   RQ   R   t
   enableRepoR   (
   R>   R  t   baseurlsR$  R   t   newrepot   var_convertt   replacedR  R6  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   add_enable_repo  s<    
	&		 s   /$basearch/$releaseverc         C   s  | r t  j   d k r t S| d k r; t  j d  } n  | d k rP d } n  y t j | |  } Wn? t t f k
 r } |  j	 j
 t d  t |   d } n X| d k r t S| t | |  j j  7} t |  d  r | |  j _ n |  j j |  | |  j _ t S(   sW    Set a new cache dir, using misc.getCacheDir() and var. replace
            on suffix. i    t   TMPDIRs   /var/tmps   Could not set cachedir: %sRs   N(   R   R   R.   R   t   getenvRK  t   getCacheDirRL  RM  Rk   RO  R   R   RV   R   R   R   R   Rs   RK   RQ   R  (   R>   R  t   tmpdirt   reuset   suffixRK   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  0  s&    	 
c         C   sx   | j  | j  k r t S| j |  r) t S| j |  j j k rB t St j j | j | j  ra t S|  j |  rt t St S(   s   returns True if pkg1 can update pkg2, False if not. 
           This only checks if it can be an update it does not check if
           it is obsoleting or anything else.(	   R   RV   RQ  R;   R  R$  R   R  R.   (   R>   t   pkg1t   pkg2(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRc  L  s    c         C   sm   |  j  j d |  j j    d } x1 |  j j   D]  } | | j   7} | d 7} q2 W|  j  j d |  d  S(   Ns   config-mainRv  s   
s   config-repos(   R|   RJ  R   t   dumpRQ   RR   (   R>   t   myreposRO   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRF  ^  s    c         C   s   |  j  j d d | | S(   s2    Callback to call a plugin hook for pkg.verify(). t   verify_package(   R0   R   (   R>   R9  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   verify_plugins_cbf  s    c   
      C   s:  |  j  j rD | r, |  j j t d   d St j t d    n  | s d t j d  } t	 j
 d d d |  \ } } t j | d  } n t | d  } | |  _ d	 |  j j d
 t  d } | d	 |  j j   7} |  j  j d k r | d 7} n` | d	 t |  j j    7} x@ |  j j   D]/ } | d | j t | j  | j j f 7} q(W| d	 t |  j  j    7} x' |  j  j   D] } | | j   7} qWy | j |  | j    Wnv t! t" f k
 r5}	 d |  _ | r|  j j t d  | t# |	  f  q6t j t d  | t# |	  f   n Xd S(   s9   saves out a transaction to .yumtx file to be loaded laters>   Dependencies not solved. Will not save unresolved transaction.Ns   yum_save_tx-%ss   %Y-%m-%d-%H-%MR4  s   .yumtxt   prefixR  s   %s
R.  i    s   0
s	   %s:%s:%s
s&   Could not save transaction file %s: %s($   R  t   _unresolvedMembersRk   RO  R   R   R  R   t   strftimet   tempfilet   mkstempR   t   fdopenRH  Re   R'  RA  R.   R   t
   getTsFlagsR)  R   R  RQ   RR   R   RT   RZ  Rz  R  t   _dumpR  Rw   RL  RM  R   (
   R>   R  R  R;  R  RJ  R   R  R  R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  k  s:    	-	)c      	   C   s  y t  | d  j   } Wn> t t f k
 rY } t j t d  | t |  f   n X| d% k ru |  j	 j
 } n  | d% k r |  j	 j } n  | d j   } | t |  j j d t  d  k r"t d  } | r | t d  7} |  j j t |   q"| t d  7} t j |   n  y t | d j    } Wn4 t t f k
 rr} t d	  } t j |   n X|  j j |  t | d
 j    }	 g  }
 d |	 } x1 | d | !D]" } |
 j | j   j d   qWt | | j    } | d } d } t } d% } x| | D]} | j   } | j d  r| r|  j j |  | |  j j k r| r|  j j j |  qn  t } | j d  d j   j d  \ } } t | j    } t  | j   j d   } y_ | t! k r|  j" |  } n= | t# k r|  j$ |  } n t d |  } t j |   Wn` t j k
 r} t } t d t |  | f  } | st j |   q|  j j |  qX| d 7} t% j& |  } | | _' qn  | j   } | j d d  \ } } | j(   } | d& k rW| j   j)   } | d k r5t* | | t  q| d k rt* | | t  qn| d k rt* | | t | j     ng| d k r| j+ j, | j d   n?| d' k rx0| j   j d  D] } | j d  \ } } yO | d  k r|  j" t  | j d    } n |  j$ t  | j d    } WnH t j k
 r} t d! t |  | f  } |  j j |  t } qXt- | |  } | j |  t* | | |  qWn5| d" k rx&| j d  D] } | j d  \ } } | j d  \ } } yO | d  k r0|  j" t  | j d    } n |  j$ t  | j d    } WnH t j k
 r} t d! t |  | f  } |  j j |  t } qXt- | |  } | j | | f  t* | | |  qWn t* | | | j    | rt } qqW|  j j |  | |  j j k r4|  j j j |  n  | | k rIt } n  | rt d#  } | r| t d$  7} |  j j |  q| t d  7} t j |   n  |  j j.   S((   s&   loads a transaction from a .yumtx fileR  s/   Could not access/read saved transaction %s : %si    R.  s0   rpmdb ver mismatched saved transaction version, s    ignoring, as requested.s
    aborting.i   s+   cannot find tsflags or tsflags not integer.i   i   t   :s   mbr:R0  R  s(   Found txmbr in unknown current state: %ss$   Could not find txmbr: %s in state %st   isDepR~  t   falset   trueR  R  R  R  t   downgraded_byR}  R%  R+  R  R  Rd  s(   Could not find txmbr: %s from origin: %sR  sC   Transaction members, relations are missing or ts has been modified,s-    ignoring, as requested. You must redepsolve!N(   RD  s	   reinstall(   s
   updated_bys   obsoleted_byRG  s
   downgradess   updatess	   obsoletess
   depends_on(/   RH  t	   readlinesRL  RM  R   R  R   R   R   R   t   loadts_ignorerpmt   loadts_ignoremissingt   stripR'  RA  R.   Rk   RO  R   R   R  R   t   setFlagsRE  R  RV   t   rstripR  R  R   R<  R  R   R  Rk  R  R  R}   t   TransactionMembert   current_statet   lstripRM  R   R  R  R   R  (   R>   R  t	   ignorerpmt   ignoremissingt   dataR   t   rpmvR   t   tsflagst   numreposRQ   t   rindexR  t   numpkgst   pkgstartt   pkgcountt   pkgprobt   curpkgR  t
   missinganyRW   RO  R  Rp  R  t   pkgspect   origint   curlistR  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   load_ts  s    )%
 
(
		!"
!"
	c      	   C   sV  t    } t    } g  |  j j d t  D] } | j ^ q( } i  } x! |  j j   D] } t | | <qS Wx| D]} x| j   D]} | j	 j
 d d  d k r t | | <q n  | | k r q n  |  j | | |  r q n  t }	 x& | j   D] }
 |
 | k r q q q WxL | j D]A \ } } } |  j j | | |  j   rt }	 t | | <PqqWxJ | j | j D]8 } |  j j | d d	  j   rnt | | <t }	 PqnqnW|	 s d | j | j f GH|  j d |  } xP | D]E } | j d |  | j | k r| j | j  n  | j |  qWq q Wqn W|  j j t j d t |   d S(
   s   take the set of pkgs being removed and remove any pkgs which are:
           1. not required anymore
           2. marked as a 'dep' in the 'reason' in the yumdb. Rh  Rn  Rv  R  s6   ---> Marking %s to be removed - no longer needed by %sR  s+   Found and removing %s unneeded dependenciesN(   NNN(   Rt   R  R  R  R  R'  R@  R.   t   required_packagesRl  R   RV   t   _has_needed_revdepst   requiring_packagesR  t   getNewRequiresR  R  R  R   R   R  RW  RE  R   Rl   R   R   Rs  R  (   R>   t   found_leavest   checkedt   tt   beingremovedt   okay_to_removeRd  R  t   requiredt   still_neededt	   requiringt   provnt   provft   provevrR,   R  R  (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyR  C  sL    		+



c         C   s  | | s- |  j  j t j t d  |  t S|  j  j t j t d  |  i  } x! |  j j   D] } t | | <qb Wx | D] } t | | <q} Wg  } | j	 |  x| r| d } | | sP| | s |  j  j t j t d  |  t | | <t S| j
 j d d  d k rC|  j  j t j t d  | |  t | | <t St | | <n  t } | j   }	 x/ |	 D]' }
 | |
 si| j	 |
  t } PqiqiW| r | j   q q W|  j  j t j t d  |  t S(	   Ns2   %s has been visited already and cannot be removed.s   Examining revdeps of %siRn  Rv  R  s*   %s has revdep %s which was user-installed.s!   %s has no user-installed revdeps.(   Rl   R   R   R  R   R.   R'  R@  RV   RE  Rl  R   Rd  t   pop(   R>   R  Ri  t   ok_to_removet   visitedR  t   stackR\  t   all_leaves_visitedt   leavest   leaf(    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRc    sD    
	



"

(   R@   RA   RB   R?   R{   Rw   R   R   R.   R0   R1   R   R   R   R   R   R   R   R   Ro   R   R   R   Rx   R   R   RV   R   R  R  R  R  R!  R   R>  RB  R=  Ra  Re  t   propertyRQ   R)  R   R'  R  R   R  R   R|   RW  Ru  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R	  R+  Re  RV  R  R  R  t   YUM_PID_FILER  Ry   R  R  R  R  R  R  R  R  RS  R
  R  R  R  R  R  R  R  RD  RL  Ry  Ra  R~  R  R  R  R  R  R  R  Rk  R  R  R  R  R  R  R  R  R  R  R   R$  R*  R&  R1  R  RP  RU  RZ  R   R  R  R  R~  R  R}  R  t   staticmethodR^  R4  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R.  R  Rc  RF  R:  R  Ra  R  Rc  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyRY      s~  	$					u	C								5	:			0				=	"	
																																n	
														C	um		/		+			.	;	%											!	v"		b&						@	F											 F , 			%	4MUW	K 			3	4				)	?(    (    (    (_   RB   R   t   os.pathR   R	   R  R  R  R   R   R  Ri   t   logging.configRc  R>  t   yum.i18nR   R   R   R  R   R
   R   R   R   t   rpmUtils.updatesR$  t   rpmUtils.archR   R   R   R   t   rpmUtils.miscutilsR   t   rpmUtils.transactionR   RX  RQ   R   RK  R   R   R   R}   R  t   urlgrabber.grabberR   R   t   urlgrabber.progressR   t   packageSackR   R   R   RZ   R0   R   R   R  t   yum.historyR   t   simplefilterR   R  R   R   R   R   R   R    R!   t	   constantst   yum.rpmtransR#   R$   R%   R&   R   R  RN   R'   R(   t   __version__R   R  R   R   R    Rz  R{  R*   RC   RM   R[   RY   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/__init__.pyt   <module>   sx   	"
.                                                                                                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python2.7/dist-packages/yum/callbacks.py                                                    0100644 0000000 0000000 00000011072 12451005146 020215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# imports

import logging 
from urlgrabber.progress import BaseMeter,format_time,format_number


# ProcessTransaction States

PT_DOWNLOAD        = 10    # Start Download
PT_DOWNLOAD_PKGS   = 11    # Packages to download
PT_GPGCHECK        = 20    # Start Checkin Package Signatures
PT_TEST_TRANS      = 30    # Start Test Transaction
PT_TRANSACTION     = 40    # Start Transaction

PT_MESSAGES = { PT_DOWNLOAD    : "Downloading Packages",
                PT_GPGCHECK    : "Check Package Signatures",
                PT_TEST_TRANS  : "Running Test Transaction",
                PT_TRANSACTION : "Running Transaction"}



class ProcessTransBaseCallback:
    
    def __init__(self):
        self.logger = logging.getLogger('yum.verbose.ProcessTrasactionBaseCallback')
        
    def event(self,state,data=None):
        if state in PT_MESSAGES.keys():
            self.logger.info(PT_MESSAGES[state])

class ProcessTransNoOutputCallback:
    def __init__(self):
        pass
         
    def event(self,state,data=None):
        pass
    
class DownloadBaseCallback( BaseMeter ):
    """ 
    This is class is a base class to use by implement a download progress
    handler to be used with YumBase.repos.setProgressBar.
    
    Example:
    
    from yum.callbacks import DownloadBaseCallback
    
    class MyDownloadCallback(  DownloadBaseCallback ):

        def updateProgress(self,name,frac,fread,ftime):
            '''
            Update the progressbar
            @param name: filename
            @param frac: Progress fracment (0 -> 1)
            @param fread: formated string containing BytesRead
            @param ftime : formated string containing remaining or elapsed time
            '''
            pct = int( frac*100 )
            print " %s : %s " % (name,pct)


    if __name__ == '__main__':
        my = YumBase()
        my.doConfigSetup()
        dnlcb = MyDownloadCallback()
        my.repos.repos.setProgressBar( dnlcb )
        for pkg in my.pkgSack:
            print pkg.name

    """
    
    def __init__(self):
        BaseMeter.__init__( self )
        self.totSize = ""   # Total size to download in a formatted string (Kb, MB etc)
        
    def update( self, amount_read, now=None ):
        BaseMeter.update( self, amount_read, now )

    def _do_start( self, now=None ):
        name = self._getName()
        self.updateProgress(name,0.0,"","")
        if not self.size is None:
            self.totSize = format_number( self.size )

    def _do_update( self, amount_read, now=None ):
        fread = format_number( amount_read )
        name = self._getName()
        if self.size is None:
            # Elapsed time
            etime = self.re.elapsed_time()
            fetime = format_time( etime )
            frac = 0.0
            self.updateProgress(name,frac,fread,fetime)
        else:
            # Remaining time
            rtime = self.re.remaining_time()
            frtime = format_time( rtime )
            frac = self.re.fraction_read()
            self.updateProgress(name,frac,fread,frtime)


    def _do_end( self, amount_read, now=None ):
        total_time = format_time( self.re.elapsed_time() )
        total_size = format_number( amount_read )
        name = self._getName()
        self.updateProgress(name,1.0,total_size,total_time)

    def _getName(self):
        '''
        Get the name of the package being downloaded
        '''
        if self.text and type( self.text ) == type( "" ):
            name = self.text
        else:
            name = self.basename
        return name

    def updateProgress(self,name,frac,fread,ftime):
        '''
         Update the progressbar (Overload in child class)
        @param name: filename
        @param frac: Progress fracment (0 -> 1)
        @param fread: formated string containing BytesRead
        @param ftime : formated string containing remaining or elapsed time
        '''
        pass
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python2.7/dist-packages/yum/callbacks.pyc                                                   0100644 0000000 0000000 00000012225 13077704344 020374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s   d  d l  Z  d  d l m Z m Z m Z d Z d Z d Z d Z d Z	 i d e 6d	 e 6d
 e 6d e	 6Z
 d d d     YZ d d d     YZ d e f d     YZ d S(   iN(   t	   BaseMetert   format_timet   format_numberi
   i   i   i   i(   s   Downloading Packagess   Check Package Signaturess   Running Test Transactions   Running Transactiont   ProcessTransBaseCallbackc           B   s   e  Z d    Z d d  Z RS(   c         C   s   t  j d  |  _ d  S(   Ns)   yum.verbose.ProcessTrasactionBaseCallback(   t   loggingt	   getLoggert   logger(   t   self(    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyt   __init__'   s    c         C   s-   | t  j   k r) |  j j t  |  n  d  S(   N(   t   PT_MESSAGESt   keysR   t   info(   R   t   statet   data(    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyt   event*   s    N(   t   __name__t
   __module__R   t   NoneR   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   %   s   	t   ProcessTransNoOutputCallbackc           B   s   e  Z d    Z d d  Z RS(   c         C   s   d  S(   N(    (   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   /   s    c         C   s   d  S(   N(    (   R   R   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   2   s    N(   R   R   R   R   R   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   .   s   	t   DownloadBaseCallbackc           B   sY   e  Z d  Z d   Z d d  Z d d  Z d d  Z d d  Z d   Z	 d   Z
 RS(	   s   
    This is class is a base class to use by implement a download progress
    handler to be used with YumBase.repos.setProgressBar.
    
    Example:
    
    from yum.callbacks import DownloadBaseCallback
    
    class MyDownloadCallback(  DownloadBaseCallback ):

        def updateProgress(self,name,frac,fread,ftime):
            '''
            Update the progressbar
            @param name: filename
            @param frac: Progress fracment (0 -> 1)
            @param fread: formated string containing BytesRead
            @param ftime : formated string containing remaining or elapsed time
            '''
            pct = int( frac*100 )
            print " %s : %s " % (name,pct)


    if __name__ == '__main__':
        my = YumBase()
        my.doConfigSetup()
        dnlcb = MyDownloadCallback()
        my.repos.repos.setProgressBar( dnlcb )
        for pkg in my.pkgSack:
            print pkg.name

    c         C   s   t  j |   d |  _ d  S(   Nt    (   R    R   t   totSize(   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   V   s    c         C   s   t  j |  | |  d  S(   N(   R    t   update(   R   t   amount_readt   now(    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   Z   s    c         C   sJ   |  j    } |  j | d d d  |  j d  k	 rF t |  j  |  _ n  d  S(   Ng        R   (   t   _getNamet   updateProgresst   sizeR   R   R   (   R   R   t   name(    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyt	   _do_start]   s    c   
      C   s   t  |  } |  j   } |  j d  k ra |  j j   } t |  } d } |  j | | | |  n@ |  j j   } t |  }	 |  j j	   } |  j | | | |	  d  S(   Ng        (
   R   R   R   R   t   ret   elapsed_timeR   R   t   remaining_timet   fraction_read(
   R   R   R   t   freadR   t   etimet   fetimet   fract   rtimet   frtime(    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyt
   _do_updatec   s    c         C   sG   t  |  j j    } t |  } |  j   } |  j | d | |  d  S(   Ng      ?(   R   R   R   R   R   R   (   R   R   R   t
   total_timet
   total_sizeR   (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyt   _do_endt   s    c         C   s=   |  j  r0 t |  j   t d  k r0 |  j  } n	 |  j } | S(   s>   
        Get the name of the package being downloaded
        R   (   t   textt   typet   basename(   R   R   (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   z   s    $	c         C   s   d S(   s  
         Update the progressbar (Overload in child class)
        @param name: filename
        @param frac: Progress fracment (0 -> 1)
        @param fread: formated string containing BytesRead
        @param ftime : formated string containing remaining or elapsed time
        N(    (   R   R   R%   R"   t   ftime(    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR      s    N(   R   R   t   __doc__R   R   R   R   R(   R+   R   R   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyR   5   s   		
(    (    (   R   t   urlgrabber.progressR    R   R   t   PT_DOWNLOADt   PT_DOWNLOAD_PKGSt   PT_GPGCHECKt   PT_TEST_TRANSt   PT_TRANSACTIONR	   R   R   R   (    (    (    s1   /usr/lib/python2.7/dist-packages/yum/callbacks.pyt   <module>   s   

	                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python2.7/dist-packages/yum/comps.py                                                        0100644 0000000 0000000 00000050442 12451005146 017423  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University

import types
import sys
from constants import *
from Errors import CompsException
#FIXME - compsexception isn't caught ANYWHERE so it's pointless to raise it
# switch all compsexceptions to grouperrors after api break
import fnmatch
import re
from yum.i18n import to_unicode
from misc import get_my_lang_code
from yum.misc import cElementTree_iterparse as iterparse 

lang_attr = '{http://www.w3.org/XML/1998/namespace}lang'

def parse_boolean(strng):
    return BOOLEAN_STATES.get(strng.lower(), False)

def parse_number(strng):
    return int(strng)

class CompsObj(object):
    """ Group/Category helper object. """

    # Could be the same as ui_name?
    def __str__(self):
        """ Return the "name" of the object for the C locale. """
        return self.name

    @property
    def ui_name(self):
        """ Return the "name" of the object for the current locale. """
        return self.nameByLang(get_my_lang_code())
    
    @property
    def ui_description(self):
        """ Return the "description" of the object for the current locale. """
        return self.descriptionByLang(get_my_lang_code())

    def __cmp__(self, other):
        if other is None:
            return 1

        if self.display_order > other.display_order:
            return 1
        if self.display_order < other.display_order:
            return -1

        return cmp(self.ui_name, other.ui_name)

    def _expand_languages(self, lang):
        import gettext
        languages = [lang]

        if 'C' not in languages:
            languages.append('C')
         
        # now normalize and expand the languages
        nelangs = []
        for lang in languages:
            for nelang in gettext._expand_lang(lang):
                if nelang not in nelangs:
                    nelangs.append(nelang)
        return nelangs
        
    def nameByLang(self, lang):

        for langcode in self._expand_languages(lang):
            if langcode in self.translated_name:
                return to_unicode(self.translated_name[langcode])

        return to_unicode(self.name)

    def descriptionByLang(self, lang):
        for langcode in self._expand_languages(lang):
            if langcode in self.translated_description:
                return to_unicode(self.translated_description[langcode])
        return to_unicode(self.description)


class Group(CompsObj):
    """ Group object parsed from group data in each repo. and merged. """

    def __init__(self, elem=None):
        self.user_visible = True
        self.default = False
        self.selected = False
        self.name = ""
        self.description = ""
        self.translated_name = {}
        self.translated_description = {}
        self.mandatory_packages = {}
        self.optional_packages = {}
        self.default_packages = {}
        self.conditional_packages = {}
        self.langonly = None ## what the hell is this?
        self.groupid = None
        self.display_order = 1024
        self.installed = False
        self.toremove = False

        if elem:
            self.parse(elem)

    def _packageiter(self):
        # Gah, FIXME: real iterator/class
        lst = self.mandatory_packages.keys() + \
              self.optional_packages.keys() + \
              self.default_packages.keys() + \
              self.conditional_packages.keys()

        return lst

    packages = property(_packageiter)

    def parse(self, elem):
        for child in elem:

            if child.tag == 'id':
                myid = child.text
                if self.groupid is not None:
                    raise CompsException
                self.groupid = myid
            
            elif child.tag == 'name':
                text = child.text
                if text:
                    text = text.encode('utf8')
                
                lang = child.attrib.get(lang_attr)
                if lang:
                    self.translated_name[lang] = text
                else:
                    self.name = text
    
    
            elif child.tag == 'description':
                text = child.text
                if text:
                    text = text.encode('utf8')
                    
                lang = child.attrib.get(lang_attr)
                if lang:
                    self.translated_description[lang] = text
                else:
                    if text:
                        self.description = text
    
            elif child.tag == 'uservisible':
                self.user_visible = parse_boolean(child.text)
    
            elif child.tag == 'display_order':
                self.display_order = parse_number(child.text)

            elif child.tag == 'default':
                self.default = parse_boolean(child.text)
    
            elif child.tag in ['langonly', 'lang_only']: 
                text = child.text
                if self.langonly is not None:
                    raise CompsException
                self.langonly = text
    
            elif child.tag == 'packagelist':
                self.parse_package_list(child)
    
    def parse_package_list(self, packagelist_elem):
        for child in packagelist_elem:
            if child.tag == 'packagereq':
                genre = child.attrib.get('type')
                if not genre:
                    genre = u'mandatory'

                if genre not in ('mandatory', 'default', 'optional', 'conditional'):
                    # just ignore bad package lines
                    continue

                package = child.text
                if genre == 'mandatory':
                    self.mandatory_packages[package] = 1
                elif genre == 'default':
                    self.default_packages[package] = 1
                elif genre == 'optional':
                    self.optional_packages[package] = 1
                elif genre == 'conditional':
                    self.conditional_packages[package] = child.attrib.get('requires')



    def add(self, obj):
        """Add another group object to this object"""
    
        # we only need package lists and any translation that we don't already
        # have
        
        for pkg in obj.mandatory_packages:
            self.mandatory_packages[pkg] = 1
        for pkg in obj.default_packages:
            self.default_packages[pkg] = 1
        for pkg in obj.optional_packages:
            self.optional_packages[pkg] = 1
        for pkg in obj.conditional_packages:
            self.conditional_packages[pkg] = obj.conditional_packages[pkg]
        
        # Handle cases where a comps.xml without name & decription tags
        # has been setup first, so the name & decription for this object is blank.
            
        
        if self.name == '' and obj.name != '':
            self.name = obj.name

        if self.description == '' and obj.description != '':
            self.description = obj.description
            
        # name and description translations
        for lang in obj.translated_name:
            if lang not in self.translated_name:
                self.translated_name[lang] = obj.translated_name[lang]
        
        for lang in obj.translated_description:
            if lang not in self.translated_description:
                self.translated_description[lang] = obj.translated_description[lang]
        
    def xml(self):
        """write out an xml stanza for the group object"""
        msg ="""        
  <group>
   <id>%s</id>
   <default>%s</default>
   <uservisible>%s</uservisible>
   <display_order>%s</display_order>\n""" % (self.groupid, str(self.default).lower(), 
                                  str(self.user_visible).lower(), self.display_order)
   
        if self.langonly:
            msg += """   <langonly>%s</langonly>""" % self.langonly
            
        msg +="""   <name>%s</name>\n""" % self.name
        for (lang, val) in sorted(self.translated_name.items()):
            msg += """   <name xml:lang="%s">%s</name>\n""" % (lang, val)
        
        msg += """   <description>%s</description>\n""" % self.description
        for (lang, val) in sorted(self.translated_description.items()):
            msg += """   <description xml:lang="%s">%s</description>\n""" % (lang, val)

        msg += """    <packagelist>\n"""
        for pkg in sorted(self.mandatory_packages):
            msg += """      <packagereq type="mandatory">%s</packagereq>\n""" % pkg
        for pkg in sorted(self.default_packages):
            msg += """      <packagereq type="default">%s</packagereq>\n""" % pkg
        for pkg in sorted(self.optional_packages):
            msg += """      <packagereq type="optional">%s</packagereq>\n""" % pkg
        for (pkg, req) in sorted(self.conditional_packages.items()):
            msg += """      <packagereq type="conditional" requires="%s">%s</packagereq>\n""" % (req, pkg)
        msg += """    </packagelist>\n"""
        msg += """  </group>"""

        return msg      


class Category(CompsObj):
    """ Category object parsed from group data in each repo. and merged. """

    def __init__(self, elem=None):
        self.name = ""
        self.categoryid = None
        self.description = ""
        self.translated_name = {}
        self.translated_description = {}
        self.display_order = 1024
        self._groups = {}        

        if elem:
            self.parse(elem)
            
    def _groupiter(self):
        return self._groups.keys()
    
    groups = property(_groupiter)
    
    def parse(self, elem):
        for child in elem:
            if child.tag == 'id':
                myid = child.text
                if self.categoryid is not None:
                    raise CompsException
                self.categoryid = myid

            elif child.tag == 'name':
                text = child.text
                if text:
                    text = text.encode('utf8')
                    
                lang = child.attrib.get(lang_attr)
                if lang:
                    self.translated_name[lang] = text
                else:
                    self.name = text
    
            elif child.tag == 'description':
                text = child.text
                if text:
                    text = text.encode('utf8')
                    
                lang = child.attrib.get(lang_attr)
                if lang:
                    self.translated_description[lang] = text
                else:
                    self.description = text
            
            elif child.tag == 'grouplist':
                self.parse_group_list(child)

            elif child.tag == 'display_order':
                self.display_order = parse_number(child.text)

    def parse_group_list(self, grouplist_elem):
        for child in grouplist_elem:
            if child.tag == 'groupid':
                groupid = child.text
                self._groups[groupid] = 1

    def add(self, obj):
        """Add another category object to this object"""
    
        for grp in obj.groups:
            self._groups[grp] = 1
        
        # name and description translations
        for lang in obj.translated_name:
            if lang not in self.translated_name:
                self.translated_name[lang] = obj.translated_name[lang]
        
        for lang in obj.translated_description:
            if lang not in self.translated_description:
                self.translated_description[lang] = obj.translated_description[lang]

    def xml(self):
        """write out an xml stanza for the category object"""
        msg ="""        
  <category>
   <id>%s</id>
   <display_order>%s</display_order>\n""" % (self.categoryid, self.display_order)
   
        msg +="""   <name>%s</name>\n""" % self.name
        for (lang, val) in self.translated_name.items():
            msg += """   <name xml:lang="%s">%s</name>\n""" % (lang, val)
        
        msg += """   <description>%s</description>\n""" % self.description
        for (lang, val) in self.translated_description.items():
            msg += """    <description xml:lang="%s">%s</description>\n""" % (lang, val)

        msg += """    <grouplist>\n"""
        for grp in self.groups:
            msg += """     <groupid>%s</groupid>\n""" % grp
        msg += """    </grouplist>\n"""
        msg += """  </category>\n"""

        return msg                
        

class Comps(object):
    def __init__(self, overwrite_groups=False):
        self._groups = {}
        self._categories = {}
        self.compscount = 0
        self.overwrite_groups = overwrite_groups
        self.compiled = False # have groups been compiled into avail/installed 
                              # lists, yet.


    def get_groups(self):
        grps = self._groups.values()
        grps.sort(key=lambda x: (x.display_order, x.name))
        return grps
        
    def get_categories(self):
        cats = self._categories.values()
        cats.sort(key=lambda x: (x.display_order, x.name))
        return cats
    
    groups = property(get_groups)
    categories = property(get_categories)
    
    def has_group(self, grpid):
        exists = self.return_groups(grpid)
            
        if exists:
            return True
            
        return False
    
    def return_group(self, grpid):
        """Return the first group which matches"""
        grps = self.return_groups(grpid)
        if grps:
            return grps[0]

        return None

    def return_groups(self, group_pattern, case_sensitive=False):
        """return all groups which match either by glob or exact match"""
        returns = {}

        for item in group_pattern.split(','):
            item = item.strip()
            if item in self._groups:
                thisgroup = self._groups[item]
                returns[thisgroup.groupid] = thisgroup
                continue
            
            if case_sensitive:
                match = re.compile(fnmatch.translate(item)).match
            else:
                match = re.compile(fnmatch.translate(item), flags=re.I).match

            done = False
            for group in self.groups:
                for name in group.name, group.groupid, group.ui_name:
                    if match(name):
                        done = True
                        returns[group.groupid] = group
                        break
            if done:
                continue

            # If we didn't match to anything in the current locale, try others
            for group in self.groups:
                for name in group.translated_name.values():
                    if match(name):
                        returns[group.groupid] = group
                        break

        return returns.values()

    #  This is close to returnPackages() etc. API ... need to std. these names
    # the above return_groups uses different, but equal, API.
    def return_categories(self, pattern, ignore_case=True):
        """return all categories which match either by glob or exact match"""
        returns = {}

        for item in pattern.split(','):
            item = item.strip()
            if item in self._categories:
                cat = self._categories[item]
                returns[cat.categoryid] = cat
                continue

            if not ignore_case:
                match = re.compile(fnmatch.translate(item)).match
            else:
                match = re.compile(fnmatch.translate(item), flags=re.I).match

            done = False
            for cat in self.categories:
                for name in cat.name, cat.categoryid, cat.ui_name:
                    if match(name):
                        done = True
                        returns[cat.categoryid] = cat
                        break
            if done:
                continue

            for cat in self.categories:
                for name in cat.translated_name.values():
                    if match(name):
                        returns[cat.categoryid] = cat
                        break

        return returns.values()

    def add_group(self, group):
        if group.groupid in self._groups:
            thatgroup = self._groups[group.groupid]
            thatgroup.add(group)
        else:
            self._groups[group.groupid] = group

    def add_category(self, category):
        if category.categoryid in self._categories:
            thatcat = self._categories[category.categoryid]
            thatcat.add(category)
        else:
            self._categories[category.categoryid] = category

    def add(self, srcfile = None):
        if not srcfile:
            raise CompsException
            
        if type(srcfile) in types.StringTypes:
            # srcfile is a filename string
            try:
                infile = open(srcfile, 'rt')
            except IOError, e:
                raise CompsException, 'open(%s): #%u %s' % (srcfile, e.errno, e.strerror)
        else:
            # srcfile is a file object
            infile = srcfile
        
        self.compscount += 1
        self.compiled = False
        
        parser = iterparse(infile)
        try:
            for event, elem in parser:
                if elem.tag == "group":
                    group = Group(elem)
                    self.add_group(group)
                if elem.tag == "category":
                    category = Category(elem)
                    self.add_category(category)
        except SyntaxError, e:
            raise CompsException, "comps file is empty/damaged"
            
        del parser
        
    def compile(self, pkgtuplist):
        """ compile the groups into installed/available groups """
        
        # convert the tuple list to a simple dict of pkgnames
        inst_pkg_names = {}
        for (n,a,e,v,r) in pkgtuplist:
            inst_pkg_names[n] = 1
        

        for group in self.groups:
            # if there are mandatory packages in the group, then make sure
            # they're all installed.  if any are missing, then the group
            # isn't installed.
            if len(group.mandatory_packages) > 0:
                group.installed = True
                for pkgname in group.mandatory_packages:
                    if pkgname not in inst_pkg_names:
                        group.installed = False
                        break
            # if it doesn't have any of those then see if it has ANY of the
            # optional/default packages installed.
            # If so - then the group is installed
            else:
                check_pkgs = group.optional_packages.keys() + group.default_packages.keys() + group.conditional_packages.keys()
                group.installed = False
                for pkgname in check_pkgs:
                    if pkgname in inst_pkg_names:
                        group.installed = True
                        break
        
        self.compiled = True
    
    def xml(self):
        """returns the xml of the comps files in this class, merged"""

        if not self._groups and not self._categories:
            return ""
            
        msg = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE comps PUBLIC "-//Red Hat, Inc.//DTD Comps info//EN" "comps.dtd">
<comps>
""" 
 
        for g in self.get_groups():
            msg += g.xml()
        for c in self.get_categories():
            msg += c.xml()

        msg += """\n</comps>\n"""
        
        return msg
            
        
        
def main():

    try:
        print sys.argv[1]
        p = Comps()
        for srcfile in sys.argv[1:]:
            p.add(srcfile)

        for group in p.groups:
            print group
            for pkg in group.packages:
                print '  ' + pkg
        
        for category in p.categories:
            print category.name
            for group in category.groups:
                print '  ' + group
                
    except IOError:
        print >> sys.stderr, "newcomps.py: No such file:\'%s\'" % sys.argv[1]
        sys.exit(1)
        
if __name__ == '__main__':
    main()

                                                                                                                                                                                                                              usr/lib/python2.7/dist-packages/yum/comps.pyc                                                       0100644 0000000 0000000 00000041651 13077704344 017603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  d l  Z  d  d l Z d  d l Td  d l m Z d  d l Z d  d l Z d  d l m Z d  d l	 m
 Z
 d  d l m Z d Z d   Z d	   Z d
 e f d     YZ d e f d     YZ d e f d     YZ d e f d     YZ d   Z e d k r	e   n  d S(   iN(   t   *(   t   CompsException(   t
   to_unicode(   t   get_my_lang_code(   t   cElementTree_iterparses*   {http://www.w3.org/XML/1998/namespace}langc         C   s   t  j |  j   t  S(   N(   t   BOOLEAN_STATESt   gett   lowert   False(   t   strng(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   parse_boolean   s    c         C   s
   t  |   S(   N(   t   int(   R	   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   parse_number"   s    t   CompsObjc           B   sY   e  Z d  Z d   Z e d    Z e d    Z d   Z d   Z d   Z	 d   Z
 RS(   s    Group/Category helper object. c         C   s   |  j  S(   s3    Return the "name" of the object for the C locale. (   t   name(   t   self(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   __str__)   s    c         C   s   |  j  t    S(   s9    Return the "name" of the object for the current locale. (   t
   nameByLangR   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   ui_name-   s    c         C   s   |  j  t    S(   s@    Return the "description" of the object for the current locale. (   t   descriptionByLangR   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   ui_description2   s    c         C   sO   | d  k r d S|  j | j k r& d S|  j | j k  r< d St |  j | j  S(   Ni   i(   t   Nonet   display_ordert   cmpR   (   R   t   other(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   __cmp__7   s    c         C   s   d d  l  } | g } d | k r1 | j d  n  g  } xD | D]< } x3 | j |  D]" } | | k rT | j |  qT qT Wq> W| S(   Nit   C(   t   gettextt   appendt   _expand_lang(   R   t   langR   t	   languagest   nelangst   nelang(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   _expand_languagesB   s    	c         C   sG   x7 |  j  |  D]& } | |  j k r t |  j |  Sq Wt |  j  S(   N(   R"   t   translated_nameR   R   (   R   R   t   langcode(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR   Q   s    c         C   sG   x7 |  j  |  D]& } | |  j k r t |  j |  Sq Wt |  j  S(   N(   R"   t   translated_descriptionR   t   description(   R   R   R$   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR   Y   s    (   t   __name__t
   __module__t   __doc__R   t   propertyR   R   R   R"   R   R   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR   %   s   				t   Groupc           B   sS   e  Z d  Z d d  Z d   Z e e  Z d   Z d   Z	 d   Z
 d   Z RS(   s?    Group object parsed from group data in each repo. and merged. c         C   s   t  |  _ t |  _ t |  _ d |  _ d |  _ i  |  _ i  |  _ i  |  _	 i  |  _
 i  |  _ i  |  _ d  |  _ d  |  _ d |  _ t |  _ t |  _ | r |  j |  n  d  S(   Nt    i   (   t   Truet   user_visibleR   t   defaultt   selectedR   R&   R#   R%   t   mandatory_packagest   optional_packagest   default_packagest   conditional_packagesR   t   langonlyt   groupidR   t	   installedt   toremovet   parse(   R   t   elem(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   __init__c   s$    																c         C   s:   |  j  j   |  j j   |  j j   |  j j   } | S(   N(   R1   t   keysR2   R3   R4   (   R   t   lst(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   _packageiterx   s    &c         C   s  x| D]} | j  d k rI | j } |  j d  k	 r= t  n  | |  _ q | j  d k r | j } | ry | j d  } n  | j j t  } | r | |  j	 | <q| |  _
 q | j  d k r| j } | r | j d  } n  | j j t  } | r| |  j | <q| r| |  _ qq | j  d k r>t | j  |  _ q | j  d k rbt | j  |  _ q | j  d k rt | j  |  _ q | j  d k r| j } |  j d  k	 rt  n  | |  _ q | j  d
 k r |  j |  q q Wd  S(   Nt   idR   t   utf8R&   t   uservisibleR   R/   R5   t	   lang_onlyt   packagelist(   s   langonlyRB   (   t   tagt   textR6   R   R   t   encodet   attribR   t	   lang_attrR#   R   R%   R&   R
   R.   R   R   R/   R5   t   parse_package_list(   R   R:   t   childt   myidRE   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR9      sH    						c         C   s   x | D] } | j  d k r | j j d  } | s= d } n  | d
 k rO q n  | j } | d k rt d |  j | <q | d k r d |  j | <q | d k r d |  j | <q | d k r | j j d	  |  j | <q q q Wd  S(   Nt
   packagereqt   typeu	   mandatoryt	   mandatoryR/   t   optionalt   conditionali   t   requires(   RN   s   defaultRO   RP   (   RD   RG   R   RE   R1   R3   R2   R4   (   R   t   packagelist_elemRJ   t   genret   package(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyRI      s     		c         C   s]  x | j  D] } d |  j  | <q
 Wx | j D] } d |  j | <q+ Wx | j D] } d |  j | <qL Wx% | j D] } | j | |  j | <qm W|  j d k r | j d k r | j |  _ n  |  j d k r | j d k r | j |  _ n  x7 | j D], } | |  j k r | j | |  j | <q q Wx7 | j D], } | |  j k r)| j | |  j | <q)q)Wd S(   s'   Add another group object to this objecti   R,   N(   R1   R3   R2   R4   R   R&   R#   R%   (   R   t   objt   pkgR   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   add   s$    c         C   s  d |  j  t |  j  j   t |  j  j   |  j f } |  j rW | d |  j 7} n  | d |  j 7} x7 t |  j	 j
    D]  \ } } | d | | f 7} q~ W| d |  j 7} x7 t |  j j
    D]  \ } } | d | | f 7} q W| d 7} x% t |  j  D] } | d | 7} qWx% t |  j  D] } | d	 | 7} q/Wx% t |  j  D] } | d
 | 7} qWWx7 t |  j j
    D]  \ } } | d | | f 7} qW| d 7} | d 7} | S(   s,   write out an xml stanza for the group objects           
  <group>
   <id>%s</id>
   <default>%s</default>
   <uservisible>%s</uservisible>
   <display_order>%s</display_order>
s      <langonly>%s</langonly>s      <name>%s</name>
s!      <name xml:lang="%s">%s</name>
s!      <description>%s</description>
s/      <description xml:lang="%s">%s</description>
s       <packagelist>
s3         <packagereq type="mandatory">%s</packagereq>
s1         <packagereq type="default">%s</packagereq>
s2         <packagereq type="optional">%s</packagereq>
sC         <packagereq type="conditional" requires="%s">%s</packagereq>
s       </packagelist>
s
     </group>(   R6   t   strR/   R   R.   R   R5   R   t   sortedR#   t   itemsR&   R%   R1   R3   R2   R4   (   R   t   msgR   t   valRV   t   req(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   xml   s,    	""
"

N(   R'   R(   R)   R   R;   R>   R*   t   packagesR9   RI   RW   R^   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR+   `   s   			3		"t   Categoryc           B   sS   e  Z d  Z d d  Z d   Z e e  Z d   Z d   Z	 d   Z
 d   Z RS(   sB    Category object parsed from group data in each repo. and merged. c         C   sY   d |  _  d  |  _ d |  _ i  |  _ i  |  _ d |  _ i  |  _ | rU |  j |  n  d  S(   NR,   i   (	   R   R   t
   categoryidR&   R#   R%   R   t   _groupsR9   (   R   R:   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR;     s    							c         C   s   |  j  j   S(   N(   Rb   R<   (   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt
   _groupiter"  s    c         C   s\  xU| D]M} | j  d k rI | j } |  j d  k	 r= t  n  | |  _ q | j  d k r | j } | ry | j d  } n  | j j t  } | r | |  j	 | <qT| |  _
 q | j  d k r| j } | r | j d  } n  | j j t  } | r| |  j | <qT| |  _ q | j  d k r0|  j |  q | j  d k r t | j  |  _ q q Wd  S(   NR?   R   R@   R&   t	   grouplistR   (   RD   RE   Ra   R   R   RF   RG   R   RH   R#   R   R%   R&   t   parse_group_listR   R   (   R   R:   RJ   RK   RE   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR9   '  s4    				c         C   s=   x6 | D]. } | j  d k r | j } d |  j | <q q Wd  S(   NR6   i   (   RD   RE   Rb   (   R   t   grouplist_elemRJ   R6   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyRe   K  s    	c         C   s   x | j  D] } d |  j | <q
 Wx7 | j D], } | |  j k r+ | j | |  j | <q+ q+ Wx7 | j D], } | |  j k re | j | |  j | <qe qe Wd S(   s*   Add another category object to this objecti   N(   t   groupsRb   R#   R%   (   R   RU   t   grpR   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyRW   Q  s    c         C   s   d |  j  |  j f } | d |  j 7} x1 |  j j   D]  \ } } | d | | f 7} q7 W| d |  j 7} x1 |  j j   D]  \ } } | d | | f 7} q| W| d 7} x |  j D] } | d | 7} q W| d 7} | d	 7} | S(
   s/   write out an xml stanza for the category objectsJ           
  <category>
   <id>%s</id>
   <display_order>%s</display_order>
s      <name>%s</name>
s!      <name xml:lang="%s">%s</name>
s!      <description>%s</description>
s0       <description xml:lang="%s">%s</description>
s       <grouplist>
s        <groupid>%s</groupid>
s       </grouplist>
s     </category>
(   Ra   R   R   R#   RZ   R&   R%   Rg   (   R   R[   R   R\   Rh   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR^   `  s    


N(   R'   R(   R)   R   R;   Rc   R*   Rg   R9   Re   RW   R^   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR`     s   		$		t   Compsc           B   s   e  Z e d   Z d   Z d   Z e e  Z e e  Z d   Z	 d   Z
 e d  Z e d  Z d   Z d   Z d d	  Z d
   Z d   Z RS(   c         C   s1   i  |  _  i  |  _ d |  _ | |  _ t |  _ d  S(   Ni    (   Rb   t   _categoriest
   compscountt   overwrite_groupsR   t   compiled(   R   Rl   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR;   y  s
    				c         C   s&   |  j  j   } | j d d    | S(   Nt   keyc         S   s   |  j  |  j f S(   N(   R   R   (   t   x(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   <lambda>  s    (   Rb   t   valuest   sort(   R   t   grps(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt
   get_groups  s    c         C   s&   |  j  j   } | j d d    | S(   NRn   c         S   s   |  j  |  j f S(   N(   R   R   (   Ro   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyRp     s    (   Rj   Rq   Rr   (   R   t   cats(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   get_categories  s    c         C   s   |  j  |  } | r t St S(   N(   t   return_groupsR-   R   (   R   t   grpidt   exists(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt	   has_group  s    c         C   s!   |  j  |  } | r | d Sd S(   s$   Return the first group which matchesi    N(   Rw   R   (   R   Rx   Rs   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   return_group  s    c   
      C   sd  i  } xQ| j  d  D]@} | j   } | |  j k rW |  j | } | | | j <q n  | r{ t j t j |   j } n$ t j t j |  d t j	 j } t
 } xW |  j D]L } xC | j | j | j f D]) }	 | |	  r t } | | | j <Pq q Wq W| rq n  xH |  j D]= } x4 | j j   D]# }	 | |	  r+| | | j <Pq+q+WqWq W| j   S(   s;   return all groups which match either by glob or exact matcht   ,t   flags(   t   splitt   stripRb   R6   t   ret   compilet   fnmatcht	   translatet   matcht   IR   Rg   R   R   R-   R#   Rq   (
   R   t   group_patternt   case_sensitivet   returnst   itemt	   thisgroupR   t   donet   groupR   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyRw     s2    $c   	      C   sd  i  } xQ| j  d  D]@} | j   } | |  j k rW |  j | } | | | j <q n  | s{ t j t j |   j } n$ t j t j |  d t j	 j } t
 } xW |  j D]L } xC | j | j | j f D]) } | |  r t } | | | j <Pq q Wq W| rq n  xH |  j D]= } x4 | j j   D]# } | |  r+| | | j <Pq+q+WqWq W| j   S(   s?   return all categories which match either by glob or exact matchR|   R}   (   R~   R   Rj   Ra   R   R   R   R   R   R   R   t
   categoriesR   R   R-   R#   Rq   (	   R   t   patternt   ignore_caseR   R   t   catR   R   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   return_categories  s2    $c         C   sF   | j  |  j k r2 |  j | j  } | j |  n | |  j | j  <d  S(   N(   R6   Rb   RW   (   R   R   t	   thatgroup(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt	   add_group  s    c         C   sF   | j  |  j k r2 |  j | j  } | j |  n | |  j | j  <d  S(   N(   Ra   Rj   RW   (   R   t   categoryt   thatcat(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   add_category  s    c   	      C   s-  | s t   n  t |  t j k rl y t | d  } Wqr t k
 rh } t  d | | j | j f  qr Xn | } |  j d 7_ t	 |  _
 t |  } yq xj | D]b \ } } | j d k r t |  } |  j |  n  | j d k r t |  } |  j |  q q WWn t k
 r%} t  d  n X~ d  S(   Nt   rts   open(%s): #%u %si   R   R   s   comps file is empty/damaged(   R   RM   t   typest   StringTypest   opent   IOErrort   errnot   strerrorRk   R   Rm   t	   iterparseRD   R+   R   R`   R   t   SyntaxError(	   R   t   srcfilet   infilet   et   parsert   eventR:   R   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyRW     s,    	#	c         C   s   i  } x' | D] \ } } } } } d | | <q Wx |  j  D] } t | j  d k r t | _ x | j D] }	 |	 | k rh t | _ Pqh qh Wq: | j j   | j j   | j	 j   }
 t | _ x' |
 D] }	 |	 | k r t | _ Pq q Wq: Wt |  _
 d S(   s4    compile the groups into installed/available groups i   i    N(   Rg   t   lenR1   R-   R7   R   R2   R<   R3   R4   Rm   (   R   t
   pkgtuplistt   inst_pkg_namest   nt   aR   t   vt   rR   t   pkgnamet
   check_pkgs(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR     s"    		)		c         C   sz   |  j  r |  j r d Sd } x$ |  j   D] } | | j   7} q+ Wx$ |  j   D] } | | j   7} qR W| d 7} | S(   s8   returns the xml of the comps files in this class, mergedR,   sz   <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE comps PUBLIC "-//Red Hat, Inc.//DTD Comps info//EN" "comps.dtd">
<comps>
s
   
</comps>
(   Rb   Rj   Rt   R^   Rv   (   R   R[   t   gt   c(    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyR^   3  s    
N(   R'   R(   R   R;   Rt   Rv   R*   Rg   R   Rz   R{   Rw   R-   R   R   R   R   RW   R   R^   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyRi   x  s   					%"			 c          C   s   y t  j d GHt   }  x" t  j d D] } |  j |  q& Wx3 |  j D]( } | GHx | j D] } d | GHq\ WqG Wx6 |  j D]+ } | j GHx | j D] } d | GHq Wq} WWn6 t k
 r t  j	 d t  j d IJt  j
 d  n Xd  S(   Ni   s     s   newcomps.py: No such file:'%s'(   t   syst   argvRi   RW   Rg   R_   R   R   R   t   stderrt   exit(   t   pR   R   RV   R   (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   mainI  s     	t   __main__(   R   R   t	   constantst   ErrorsR   R   R   t   yum.i18nR   t   miscR   t   yum.miscR   R   RH   R
   R   t   objectR   R+   R`   Ri   R   R'   (    (    (    s-   /usr/lib/python2.7/dist-packages/yum/comps.pyt   <module>   s$   
		;e	                                                                                       usr/lib/python2.7/dist-packages/yum/config.py                                                       0100644 0000000 0000000 00000110504 12451005146 017543  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -t

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2002 Duke University 

"""
Configuration parser and default values for yum.
"""
_use_iniparse = True

import os
import sys
import warnings
import rpm
import copy
import urlparse
import shlex
from parser import ConfigPreProcessor, varReplace
try:
    from iniparse import INIConfig
    from iniparse.compat import NoSectionError, NoOptionError, ParsingError
    from iniparse.compat import RawConfigParser as ConfigParser
except ImportError:
    _use_iniparse = False
if not _use_iniparse:
    from ConfigParser import NoSectionError, NoOptionError, ParsingError
    from ConfigParser import ConfigParser
import rpmUtils.transaction
import Errors
import types
from misc import get_uuid, read_in_items_from_dot_dir

# Alter/patch these to change the default checking...
__pkgs_gpgcheck_default__ = False
__repo_gpgcheck_default__ = False

class Option(object):
    '''
    This class handles a single Yum configuration file option. Create
    subclasses for each type of supported configuration option.
    
    Python descriptor foo (__get__ and __set__) is used to make option
    definition easy and consise.
    '''

    def __init__(self, default=None, parse_default=False):
        self._setattrname()
        self.inherit = False
        if parse_default:
            default = self.parse(default)
        self.default = default

    def _setattrname(self):
        '''Calculate the internal attribute name used to store option state in
        configuration instances.
        '''
        self._attrname = '__opt%d' % id(self)

    def __get__(self, obj, objtype):
        '''Called when the option is read (via the descriptor protocol). 

        @param obj: The configuration instance to modify.
        @param objtype: The type of the config instance (not used).
        @return: The parsed option value or the default value if the value
            wasn't set in the configuration file.
        '''
        # xemacs highlighting hack: '
        if obj is None:
            return self

        return getattr(obj, self._attrname, None)

    def __set__(self, obj, value):
        '''Called when the option is set (via the descriptor protocol). 

        @param obj: The configuration instance to modify.
        @param value: The value to set the option to.
        @return: Nothing.
        '''
        # Only try to parse if it's a string
        if isinstance(value, basestring):
            try:
                value = self.parse(value)
            except ValueError, e:
                # Add the field name onto the error
                raise ValueError('Error parsing "%s = %r": %s' % (self._optname,
                                                                 value, str(e)))
        setattr(obj, self._attrname, value)

    def setup(self, obj, name):
        '''Initialise the option for a config instance. 
        This must be called before the option can be set or retrieved. 

        @param obj: BaseConfig (or subclass) instance.
        @param name: Name of the option.
        '''
        self._optname = name
        setattr(obj, self._attrname, copy.copy(self.default))

    def clone(self):
        '''Return a safe copy of this Option instance
        '''
        new = copy.copy(self)
        new._setattrname()
        return new

    def parse(self, s):
        '''Parse the string value to the Option's native value.

        @param s: Raw string value to parse.
        @return: Validated native value.
    
        Will raise ValueError if there was a problem parsing the string.
        Subclasses should override this.
        '''
        return s

    def tostring(self, value):
        '''Convert the Option's native value to a string value.

        @param value: Native option value.
        @return: String representation of input.

        This does the opposite of the parse() method above.
        Subclasses should override this.
        '''
        return str(value)

def Inherit(option_obj):
    '''Clone an Option instance for the purposes of inheritance. The returned
    instance has all the same properties as the input Option and shares items
    such as the default value. Use this to avoid redefinition of reused
    options.

    @param option_obj: Option instance to inherit.
    @return: New Option instance inherited from the input.
    '''
    new_option = option_obj.clone()
    new_option.inherit = True
    return new_option

class ListOption(Option):

    """
    An option containing a list of strings.
    """

    def __init__(self, default=None, parse_default=False):
        if default is None:
            default = []
        super(ListOption, self).__init__(default, parse_default)

    def parse(self, s):
        """Converts a string from the config file to a workable list, parses
           globdir: paths as foo.d-style dirs

        Commas and spaces are used as separators for the list
        """
        # we need to allow for the '\n[whitespace]' continuation - easier
        # to sub the \n with a space and then read the lines
        s = s.replace('\n', ' ')
        s = s.replace(',', ' ')
        results = []
        for item in s.split():
            if item.startswith('glob:'):
                thisglob = item.replace('glob:', '')
                results.extend(read_in_items_from_dot_dir(thisglob))
                continue
            results.append(item)

        return results

    def tostring(self, value):
        return '\n '.join(value)

class UrlOption(Option):
    '''
    This option handles lists of URLs with validation of the URL scheme.
    '''

    def __init__(self, default=None, schemes=('http', 'ftp', 'file', 'https'), 
            allow_none=False):
        super(UrlOption, self).__init__(default)
        self.schemes = schemes
        self.allow_none = allow_none

    def parse(self, url):
        url = url.strip()

        # Handle the "_none_" special case
        if url.lower() == '_none_':
            if self.allow_none:
                return None
            else:
                raise ValueError('"_none_" is not a valid value')

        # Check that scheme is valid
        (s,b,p,q,f,o) = urlparse.urlparse(url)
        if s not in self.schemes:
            raise ValueError('URL must be %s not "%s"' % (self._schemelist(), s))

        return url

    def _schemelist(self):
        '''Return a user friendly list of the allowed schemes
        '''
        if len(self.schemes) < 1:
            return 'empty'
        elif len(self.schemes) == 1:
            return self.schemes[0]
        else:
            return '%s or %s' % (', '.join(self.schemes[:-1]), self.schemes[-1])

class UrlListOption(ListOption):
    '''
    Option for handling lists of URLs with validation of the URL scheme.
    '''

    def __init__(self, default=None, schemes=('http', 'ftp', 'file', 'https'),
                 parse_default=False):
        super(UrlListOption, self).__init__(default, parse_default)

        # Hold a UrlOption instance to assist with parsing
        self._urloption = UrlOption(schemes=schemes)
        
    def parse(self, s):
        out = []
        s = s.replace('\n', ' ')
        s = s.replace(',', ' ')
        items = [ item.replace(' ', '%20') for item in shlex.split(s) ]
        tmp = []
        for item in items:
            if item.startswith('glob:'):
                thisglob = item.replace('glob:', '')
                tmp.extend(read_in_items_from_dot_dir(thisglob))
                continue
            tmp.append(item)

        for url in super(UrlListOption, self).parse(' '.join(tmp)):
            out.append(self._urloption.parse(url))
        return out


class IntOption(Option):

    """
    An option representing an integer value.
    """

    def __init__(self, default=None, range_min=None, range_max=None):
        super(IntOption, self).__init__(default)
        self._range_min = range_min
        self._range_max = range_max
        
    def parse(self, s):
        try:
            val = int(s)
        except (ValueError, TypeError), e:
            raise ValueError('invalid integer value')
        if self._range_max is not None and val > self._range_max:
            raise ValueError('out of range integer value')
        if self._range_min is not None and val < self._range_min:
            raise ValueError('out of range integer value')
        return val

class PositiveIntOption(IntOption):

    """
    An option representing a positive integer value, where 0 can have a special
    represention.
    """

    def __init__(self, default=None, range_min=0, range_max=None,
                 names_of_0=None):
        super(PositiveIntOption, self).__init__(default, range_min, range_max)
        self._names0 = names_of_0

    def parse(self, s):
        if s in self._names0:
            return 0
        return super(PositiveIntOption, self).parse(s)

class SecondsOption(Option):

    """
    An option representing an integer value of seconds, or a human readable
    variation specifying days, hours, minutes or seconds until something
    happens. Works like BytesOption.
    Note that due to historical president -1 means "never", so this accepts
    that and allows the word never too.

    Valid inputs: 100, 1.5m, 90s, 1.2d, 1d, 0xF, 0.1, -1, never
    Invalid inputs: -10, -0.1, 45.6Z, 1d6h, 1day, 1y

    Return value will always be an integer
    """
    MULTS = {'d': 60 * 60 * 24, 'h' : 60 * 60, 'm' : 60, 's': 1}

    def parse(self, s):
        if len(s) < 1:
            raise ValueError("no value specified")

        if s == "-1" or s == "never": # Special cache timeout, meaning never
            return -1
        if s[-1].isalpha():
            n = s[:-1]
            unit = s[-1].lower()
            mult = self.MULTS.get(unit, None)
            if not mult:
                raise ValueError("unknown unit '%s'" % unit)
        else:
            n = s
            mult = 1

        try:
            n = float(n)
        except (ValueError, TypeError), e:
            raise ValueError('invalid value')

        if n < 0:
            raise ValueError("seconds value may not be negative")

        return int(n * mult)

class BoolOption(Option):

    """
    An option representing a boolean value.

    The value can be one of 0, 1, yes, no, true, or false.
    """

    def parse(self, s):
        s = s.lower()
        if s in ('0', 'no', 'false'):
            return False
        elif s in ('1', 'yes', 'true'):
            return True
        else:
            raise ValueError('invalid boolean value')

    def tostring(self, value):
        if value:
            return "1"
        else:
            return "0"

class FloatOption(Option):
    """
    An option representing a numeric float value.
    """
    def parse(self, s):
        try:
            return float(s.strip())
        except (ValueError, TypeError):
            raise ValueError('invalid float value')

class SelectionOption(Option):
    '''Handles string values where only specific values are allowed
    '''
    def __init__(self, default=None, allowed=(), mapper={}):
        super(SelectionOption, self).__init__(default)
        self._allowed = allowed
        self._mapper  = mapper
        
    def parse(self, s):
        if s in self._mapper:
            s = self._mapper[s]
        if s not in self._allowed:
            raise ValueError('"%s" is not an allowed value' % s)
        return s

class CaselessSelectionOption(SelectionOption):
    ''' Mainly for compat. with BoolOption, works like SelectionOption but
        lowers input case. '''

    def parse(self, s):
        return super(CaselessSelectionOption, self).parse(s.lower())

class BytesOption(Option):

    """
    An option representing a value in bytes.

    The value may be given in bytes, kilobytes, megabytes, or gigabytes.
    """
    # Multipliers for unit symbols
    MULTS = {
        'k': 1024,
        'm': 1024*1024,
        'g': 1024*1024*1024,
    }

    def parse(self, s):
        """Parse a friendly bandwidth option to bytes

        The input should be a string containing a (possibly floating point)
        number followed by an optional single character unit. Valid units are
        'k', 'M', 'G'. Case is ignored.
       
        Valid inputs: 100, 123M, 45.6k, 12.4G, 100K, 786.3, 0
        Invalid inputs: -10, -0.1, 45.6L, 123Mb

        Return value will always be an integer

        1k = 1024 bytes.

        ValueError will be raised if the option couldn't be parsed.
        """
        if len(s) < 1:
            raise ValueError("no value specified")

        if s[-1].isalpha():
            n = s[:-1]
            unit = s[-1].lower()
            mult = self.MULTS.get(unit, None)
            if not mult:
                raise ValueError("unknown unit '%s'" % unit)
        else:
            n = s
            mult = 1
             
        try:
            n = float(n)
        except ValueError:
            raise ValueError("couldn't convert '%s' to number" % n)

        if n < 0:
            raise ValueError("bytes value may not be negative")

        return int(n * mult)

class ThrottleOption(BytesOption):

    """
    An option representing a bandwidth throttle value. See
    ThrottleOption.parse for acceptable input values.
    """

    def parse(self, s):
        """Get a throttle option. 

        Input may either be a percentage or a "friendly bandwidth value" as
        accepted by the BytesOption.

        Valid inputs: 100, 50%, 80.5%, 123M, 45.6k, 12.4G, 100K, 786.0, 0
        Invalid inputs: 100.1%, -4%, -500

        Return value will be a int if a bandwidth value was specified or a
        float if a percentage was given.

        ValueError will be raised if input couldn't be parsed.
        """
        if len(s) < 1:
            raise ValueError("no value specified")

        if s[-1] == '%':
            n = s[:-1]
            try:
                n = float(n)
            except ValueError:
                raise ValueError("couldn't convert '%s' to number" % n)
            if n < 0 or n > 100:
                raise ValueError("percentage is out of range")
            return n / 100.0
        else:
            return BytesOption.parse(self, s)

class BaseConfig(object):
    '''
    Base class for storing configuration definitions. Subclass when creating
    your own definitons.
    '''

    def __init__(self):
        self._section = None

        for name in self.iterkeys():
            option = self.optionobj(name)
            option.setup(self, name)

    def __str__(self):
        out = []
        out.append('[%s]' % self._section)
        for name, value in self.iteritems():
            out.append('%s: %r' % (name, value))
        return '\n'.join(out)

    def populate(self, parser, section, parent=None):
        '''Set option values from a INI file section.

        @param parser: ConfParser instance (or subclass)
        @param section: INI file section to read use.
        @param parent: Optional parent BaseConfig (or subclass) instance to use
            when doing option value inheritance.
        '''
        self.cfg = parser
        self._section = section

        if parser.has_section(section):
            opts = set(parser.options(section))
        else:
            opts = set()
        for name in self.iterkeys():
            option = self.optionobj(name)
            value = None
            if name in opts:
                value = parser.get(section, name)
            else:
                # No matching option in this section, try inheriting
                if parent and option.inherit:
                    value = getattr(parent, name)
               
            if value is not None:
                setattr(self, name, value)

    def optionobj(cls, name, exceptions=True):
        '''Return the Option instance for the given name
        '''
        obj = getattr(cls, name, None)
        if isinstance(obj, Option):
            return obj
        elif exceptions:
            raise KeyError
        else:
            return None
    optionobj = classmethod(optionobj)

    def isoption(cls, name):
        '''Return True if the given name refers to a defined option 
        '''
        return cls.optionobj(name, exceptions=False) is not None
    isoption = classmethod(isoption)

    def iterkeys(self):
        '''Yield the names of all defined options in the instance.
        '''
        for name in dir(self):
            if self.isoption(name):
                yield name

    def iteritems(self):
        '''Yield (name, value) pairs for every option in the instance.

        The value returned is the parsed, validated option value.
        '''
        # Use dir() so that we see inherited options too
        for name in self.iterkeys():
            yield (name, getattr(self, name))

    def write(self, fileobj, section=None, always=()):
        '''Write out the configuration to a file-like object

        @param fileobj: File-like object to write to
        @param section: Section name to use. If not-specified the section name
            used during parsing will be used.
        @param always: A sequence of option names to always write out.
            Options not listed here will only be written out if they are at
            non-default values. Set to None to dump out all options.
        '''
        # Write section heading
        if section is None:
            if self._section is None:
                raise ValueError("not populated, don't know section")
            section = self._section

        # Updated the ConfigParser with the changed values    
        cfgOptions = self.cfg.options(section)
        for name,value in self.iteritems():
            option = self.optionobj(name)
            if always is None or name in always or option.default != value or name in cfgOptions :
                self.cfg.set(section,name, option.tostring(value))
        # write the updated ConfigParser to the fileobj.
        self.cfg.write(fileobj)

    def getConfigOption(self, option, default=None):
        warnings.warn('getConfigOption() will go away in a future version of Yum.\n'
                'Please access option values as attributes or using getattr().',
                DeprecationWarning)
        if hasattr(self, option):
            return getattr(self, option)
        return default

    def setConfigOption(self, option, value):
        warnings.warn('setConfigOption() will go away in a future version of Yum.\n'
                'Please set option values as attributes or using setattr().',
                DeprecationWarning)
        if hasattr(self, option):
            setattr(self, option, value)
        else:
            raise Errors.ConfigError, 'No such option %s' % option

class StartupConf(BaseConfig):
    '''
    Configuration option definitions for yum.conf's [main] section that are
    required early in the initialisation process or before the other [main]
    options can be parsed. 
    '''
    # xemacs highlighting hack: '
    debuglevel = IntOption(2, 0, 10)
    errorlevel = IntOption(2, 0, 10)

    distroverpkg = Option('redhat-release')
    installroot = Option('/')
    config_file_path = Option('/etc/yum/yum.conf')
    plugins = BoolOption(False)
    pluginpath = ListOption(['/usr/share/yum-plugins', '/usr/lib/yum-plugins'])
    pluginconfpath = ListOption(['/etc/yum/pluginconf.d'])
    gaftonmode = BoolOption(False)
    syslog_ident = Option()
    syslog_facility = Option('LOG_USER')
    syslog_device = Option('/dev/log')
    persistdir = Option('/var/lib/yum')
    
class YumConf(StartupConf):
    '''
    Configuration option definitions for yum.conf\'s [main] section.

    Note: see also options inherited from StartupConf
    '''
    retries = PositiveIntOption(10, names_of_0=["<forever>"])
    recent = IntOption(7, range_min=0)

    cachedir = Option('/var/cache/yum')

    keepcache = BoolOption(True)
    logfile = Option('/var/log/yum.log')
    reposdir = ListOption(['/etc/yum/repos.d', '/etc/yum.repos.d'])

    commands = ListOption()
    exclude = ListOption()
    failovermethod = Option('roundrobin')
    proxy = UrlOption(schemes=('http', 'ftp', 'https'), allow_none=True)
    proxy_username = Option()
    proxy_password = Option()
    username = Option()
    password = Option()
    installonlypkgs = ListOption(['kernel', 'kernel-bigmem',
            'kernel-enterprise','kernel-smp', 'kernel-modules', 'kernel-debug',
            'kernel-unsupported', 'kernel-source', 'kernel-devel', 'kernel-PAE',
            'kernel-PAE-debug'])
    # NOTE: If you set this to 2, then because it keeps the current kernel it
    # means if you ever install an "old" kernel it'll get rid of the newest one
    # so you probably want to use 3 as a minimum ... if you turn it on.
    installonly_limit = PositiveIntOption(0, range_min=2,
                                          names_of_0=["0", "<off>"])
    kernelpkgnames = ListOption(['kernel','kernel-smp', 'kernel-enterprise',
            'kernel-bigmem', 'kernel-BOOT', 'kernel-PAE', 'kernel-PAE-debug'])
    exactarchlist = ListOption(['kernel', 'kernel-smp',
            'kernel-hugemem', 'kernel-enterprise', 'kernel-bigmem',
            'kernel-devel', 'kernel-PAE', 'kernel-PAE-debug'])
    tsflags = ListOption()

    assumeyes = BoolOption(False)
    alwaysprompt = BoolOption(True)
    exactarch = BoolOption(True)
    tolerant = BoolOption(True)
    diskspacecheck = BoolOption(True)
    overwrite_groups = BoolOption(False)
    keepalive = BoolOption(True)
    # FIXME: rename gpgcheck to pkgs_gpgcheck
    gpgcheck = BoolOption(__pkgs_gpgcheck_default__)
    repo_gpgcheck = BoolOption(__repo_gpgcheck_default__)
    localpkg_gpgcheck = BoolOption(__pkgs_gpgcheck_default__)
    obsoletes = BoolOption(True)
    showdupesfromrepos = BoolOption(False)
    enabled = BoolOption(True)
    enablegroups = BoolOption(True)
    enable_group_conditionals = BoolOption(True)
    groupremove_leaf_only = BoolOption(False)
    group_package_types = ListOption(['mandatory', 'default'])
    
    timeout = FloatOption(30.0) # FIXME: Should use variation of SecondsOption

    bandwidth = BytesOption(0)
    throttle = ThrottleOption(0)

    http_caching = SelectionOption('all', ('none', 'packages', 'all'))
    metadata_expire = SecondsOption(60 * 60 * 6) # Time in seconds (6h).
    # Time in seconds (1 day). NOTE: This isn't used when using metalinks
    mirrorlist_expire = SecondsOption(60 * 60 * 24)
    # XXX rpm_check_debug is unused, left around for API compatibility for now
    rpm_check_debug = BoolOption(True)
    disable_excludes = ListOption()    
    skip_broken = BoolOption(False)
    #  Note that "instant" is the old behaviour, but group:primary is very
    # similar but better :).
    mdpolicy = ListOption(['group:primary'])
    #  ('instant', 'group:all', 'group:main', 'group:small', 'group:primary'))
    multilib_policy = SelectionOption('all',('best', 'all'))
                 # all == install any/all arches you can
                 # best == use the 'best  arch' for the system
                 
    bugtracker_url = Option('http://yum.baseurl.org/report')

    color = SelectionOption('auto', ('auto', 'never', 'always'),
                            mapper={'on' : 'always', 'yes' : 'always',
                                    '1' : 'always', 'true' : 'always',
                                    'off' : 'never', 'no' : 'never',
                                    '0' : 'never', 'false' : 'never',
                                    'tty' : 'auto', 'if-tty' : 'auto'})
    color_list_installed_older = Option('bold')
    color_list_installed_newer = Option('bold,yellow')
    color_list_installed_reinstall = Option('normal')
    color_list_installed_extra = Option('bold,red')

    color_list_available_upgrade = Option('bold,blue')
    color_list_available_downgrade = Option('dim,cyan')
    color_list_available_reinstall = Option('bold,underline,green')
    color_list_available_install = Option('normal')

    color_update_installed = Option('normal')
    color_update_local     = Option('bold')
    color_update_remote    = Option('normal')

    color_search_match = Option('bold')
    
    sslcacert = Option()
    sslverify = BoolOption(True)
    sslclientcert = Option()
    sslclientkey = Option()

    history_record = BoolOption(True)
    history_record_packages = ListOption(['yum', 'rpm'])

    rpmverbosity = Option('info')

    protected_packages = ListOption("yum, glob:/etc/yum/protected.d/*.conf",
                                    parse_default=True)
    protected_multilib = BoolOption(True)
    exit_on_lock = BoolOption(False)
    
    loadts_ignoremissing = BoolOption(False)
    loadts_ignorerpm = BoolOption(False)
    
    clean_requirements_on_remove = BoolOption(False)


    history_list_view = SelectionOption('single-user-commands',
                                        ('single-user-commands', 'users',
                                         'commands'),
                                     mapper={'cmds'          : 'commands',
                                             'default' :'single-user-commands'})
    _reposlist = []

    def dump(self):
        output = '[main]\n'
        # we exclude all vars which start with _ or are in this list:
        excluded_vars = ('cfg', 'uid', 'yumvar', 'progress_obj', 'failure_obj',
                         'disable_excludes', 'config_file_age', 'config_file_path',
                         )
        for attr in dir(self):
            if attr.startswith('_'):
                continue
            if attr in excluded_vars:
                continue
            if isinstance(getattr(self, attr), types.MethodType):
                continue
            res = getattr(self, attr)
            if not res and type(res) not in (type(False), type(0)):
                res = ''
            if type(res) == types.ListType:
                res = ',\n   '.join(res)
            output = output + '%s = %s\n' % (attr, res)

        return output

class RepoConf(BaseConfig):
    '''
    Option definitions for repository INI file sections.
    '''

    __cached_keys = set()
    def iterkeys(self):
        '''Yield the names of all defined options in the instance.
        '''
        ck = self.__cached_keys
        if not isinstance(self, RepoConf):
            ck = set()
        if not ck:
            ck.update(list(BaseConfig.iterkeys(self)))

        for name in self.__cached_keys:
            yield name

    name = Option()
    enabled = Inherit(YumConf.enabled)
    baseurl = UrlListOption()
    mirrorlist = UrlOption()
    metalink   = UrlOption()
    mediaid = Option()
    gpgkey = UrlListOption()
    gpgcakey = UrlListOption()
    exclude = ListOption() 
    includepkgs = ListOption() 

    proxy = Inherit(YumConf.proxy)
    proxy_username = Inherit(YumConf.proxy_username)
    proxy_password = Inherit(YumConf.proxy_password)
    retries = Inherit(YumConf.retries)
    failovermethod = Inherit(YumConf.failovermethod)
    username = Inherit(YumConf.username)
    password = Inherit(YumConf.password)

    # FIXME: rename gpgcheck to pkgs_gpgcheck
    gpgcheck = Inherit(YumConf.gpgcheck)
    repo_gpgcheck = Inherit(YumConf.repo_gpgcheck)
    keepalive = Inherit(YumConf.keepalive)
    enablegroups = Inherit(YumConf.enablegroups)

    bandwidth = Inherit(YumConf.bandwidth)
    throttle = Inherit(YumConf.throttle)
    timeout = Inherit(YumConf.timeout)
    http_caching = Inherit(YumConf.http_caching)
    metadata_expire = Inherit(YumConf.metadata_expire)
    mirrorlist_expire = Inherit(YumConf.mirrorlist_expire)
    # NOTE: metalink expire _must_ be the same as metadata_expire, due to the
    #       checksumming of the repomd.xml.
    mdpolicy = Inherit(YumConf.mdpolicy)
    cost = IntOption(1000)
    
    sslcacert = Inherit(YumConf.sslcacert)
    sslverify = Inherit(YumConf.sslverify)
    sslclientcert = Inherit(YumConf.sslclientcert)
    sslclientkey = Inherit(YumConf.sslclientkey)

    skip_if_unavailable = BoolOption(False)
    
class VersionGroupConf(BaseConfig):
    pkglist = ListOption()
    run_with_packages = BoolOption(False)


def readStartupConfig(configfile, root):
    '''
    Parse Yum's main configuration file and return a StartupConf instance.
    
    This is required in order to access configuration settings required as Yum
    starts up.

    @param configfile: The path to yum.conf.
    @param root: The base path to use for installation (typically '/')
    @return: A StartupConf instance.

    May raise Errors.ConfigError if a problem is detected with while parsing.
    '''

    # ' xemacs syntax hack

    StartupConf.installroot.default = root
    startupconf = StartupConf()
    startupconf.config_file_path = configfile
    parser = ConfigParser()
    confpp_obj = ConfigPreProcessor(configfile)
    try:
        parser.readfp(confpp_obj)
    except ParsingError, e:
        raise Errors.ConfigError("Parsing file failed: %s" % e)
    startupconf.populate(parser, 'main')

    # Check that plugin paths are all absolute
    for path in startupconf.pluginpath:
        if not path[0] == '/':
            raise Errors.ConfigError("All plugin search paths must be absolute")
    # Stuff this here to avoid later re-parsing
    startupconf._parser = parser
    # setup the release ver here
    startupconf.releasever = _getsysver(startupconf.installroot, startupconf.distroverpkg)
    uuidfile = '%s/%s/uuid' % (startupconf.installroot, startupconf.persistdir)
    startupconf.uuid = get_uuid(uuidfile)

    return startupconf

def readMainConfig(startupconf):
    '''
    Parse Yum's main configuration file

    @param startupconf: StartupConf instance as returned by readStartupConfig()
    @return: Populated YumConf instance.
    '''
    
    # ' xemacs syntax hack

    # Set up substitution vars
    yumvars = _getEnvVar()
    yumvars['basearch'] = startupconf.basearch
    yumvars['arch'] = startupconf.arch
    yumvars['releasever'] = startupconf.releasever
    yumvars['uuid'] = startupconf.uuid
    # Note: We don't setup the FS yumvars here, because we want to be able to
    #       use the core yumvars in persistdir. Which is the base of FS yumvars.
    
    # Read [main] section
    yumconf = YumConf()
    yumconf.populate(startupconf._parser, 'main')

    # Apply the installroot to directory options
    def _apply_installroot(yumconf, option):
        path = getattr(yumconf, option)
        ir_path = yumconf.installroot + path
        ir_path = ir_path.replace('//', '/') # os.path.normpath won't fix this and
                                             # it annoys me
        ir_path = varReplace(ir_path, yumvars)
        setattr(yumconf, option, ir_path)
    
    # Read the FS yumvars
    try:
        dir_fsvars = yumconf.installroot + "/etc/yum/vars/"
        fsvars = os.listdir(dir_fsvars)
    except OSError:
        fsvars = []
    for fsvar in fsvars:
        if os.path.islink(dir_fsvars + fsvar):
            continue
        try:
            val = open(dir_fsvars + fsvar).readline()
            if val and val[-1] == '\n':
                val = val[:-1]
        except (OSError, IOError):
            continue
        yumvars[fsvar] = val

    # These can use the above FS yumvars
    for option in ('cachedir', 'logfile', 'persistdir'):
        _apply_installroot(yumconf, option)

    # Add in some extra attributes which aren't actually configuration values 
    yumconf.yumvar = yumvars
    yumconf.uid = 0
    yumconf.cache = 0
    yumconf.progess_obj = None
    
    # items related to the originating config file
    yumconf.config_file_path = startupconf.config_file_path
    if os.path.exists(startupconf.config_file_path):
        yumconf.config_file_age = os.stat(startupconf.config_file_path)[8]
    else:
        yumconf.config_file_age = 0
    
    # propagate the debuglevel and errorlevel values:
    yumconf.debuglevel = startupconf.debuglevel
    yumconf.errorlevel = startupconf.errorlevel
    
    return yumconf

def readVersionGroupsConfig(configfile="/etc/yum/version-groups.conf"):
    parser = ConfigParser()
    confpp_obj = ConfigPreProcessor(configfile)
    try:
        parser.readfp(confpp_obj)
    except ParsingError, e:
        raise Errors.ConfigError("Parsing file failed: %s" % e)
    ret = {}
    for section in parser.sections():
        ret[section] = VersionGroupConf()
        ret[section].populate(parser, section)
    return ret


def getOption(conf, section, name, option):
    '''Convenience function to retrieve a parsed and converted value from a
    ConfigParser.

    @param conf: ConfigParser instance or similar
    @param section: Section name
    @param name: Option name
    @param option: Option instance to use for conversion.
    @return: The parsed value or default if value was not present.

    Will raise ValueError if the option could not be parsed.
    '''
    try: 
        val = conf.get(section, name)
    except (NoSectionError, NoOptionError):
        return option.default
    return option.parse(val)

def _getEnvVar():
    '''Return variable replacements from the environment variables YUM0 to YUM9

    The result is intended to be used with parser.varReplace()
    '''
    yumvar = {}
    for num in range(0, 10):
        env = 'YUM%d' % num
        val = os.environ.get(env, '')
        if val:
            yumvar[env.lower()] = val
    return yumvar

def _getsysver(installroot, distroverpkg):
    '''Calculate the release version for the system.

    @param installroot: The value of the installroot option.
    @param distroverpkg: The value of the distroverpkg option.
    @return: The release version as a string (eg. '4' for FC4)
    '''
    ts = rpmUtils.transaction.initReadOnlyTransaction(root=installroot)
    ts.pushVSFlags(~(rpm._RPMVSF_NOSIGNATURES|rpm._RPMVSF_NODIGESTS))
    try:
        idx = ts.dbMatch('provides', distroverpkg)
    except TypeError, e:
        # This is code for "cannot open rpmdb"
        # this is for pep 352 compliance on python 2.6 and above :(
        if sys.hexversion < 0x02050000:
            if hasattr(e,'message'):
                raise Errors.YumBaseError("Error: " + str(e.message))
            else:
                raise Errors.YumBaseError("Error: " + str(e))
        raise Errors.YumBaseError("Error: " + str(e))
    except rpm.error, e:
        # This is the "new" code for "cannot open rpmdb", 4.8.0 ish
        raise Errors.YumBaseError("Error: " + str(e))
    # we're going to take the first one - if there is more than one of these
    # then the user needs a beating
    if idx.count() == 0:
        releasever = '$releasever'
    else:
        hdr = idx.next()
        releasever = hdr['version']
        del hdr
    del idx
    del ts
    return releasever

def writeRawRepoFile(repo,only=None):
    """
    Writes changes in a repo object back to a .repo file.
    @param repo: Repo Object
    @param only: List of attributes to work on (None = All)
    It work by reading the repo file, changes the values there shall be changed and write it back to disk.
    """

    if not _use_iniparse:
        return

    ini = INIConfig(open(repo.repofile))
    # b/c repoids can have $values in them we need to map both ways to figure
    # out which one is which
    section_id = repo.id
    if repo.id not in ini._sections:
        for sect in ini._sections.keys():
            if varReplace(sect, repo.yumvar) == repo.id:
                section_id = sect
    
    # Updated the ConfigParser with the changed values    
    cfgOptions = repo.cfg.options(repo.id)
    for name,value in repo.iteritems():
        if value is None: # Proxy
            continue

        if only is not None and name not in only:
            continue

        option = repo.optionobj(name)
        ovalue = option.tostring(value)
        #  If the value is the same, but just interpreted ... when we don't want
        # to keep the interpreted values.
        if (name in ini[section_id] and
            ovalue == varReplace(ini[section_id][name], yumvar)):
            ovalue = ini[section_id][name]

        if name not in cfgOptions and option.default == value:
            continue

        ini[section_id][name] = ovalue
    fp =file(repo.repofile,"w")               
    fp.write(str(ini))
    fp.close()

#def main():
#    mainconf = readMainConfig(readStartupConfig('/etc/yum/yum.conf', '/'))
#    print mainconf.cachedir
#
#if __name__ == '__main__':
#    main()
                                                                                                                                                                                            usr/lib/python2.7/dist-packages/yum/config.pyc                                                      0100644 0000000 0000000 00000110076 13077704344 017725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s)  d  Z  e Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 m Z m Z y@ d d l m Z d d l m Z m Z m Z d d l m Z Wn e k
 r e Z n Xe sd d l m Z m Z m Z d d l m Z n  d d l Z d d l Z d d l Z d d l m Z m Z e Z e Z d	 e  f d
     YZ! d   Z" d e! f d     YZ# d e! f d     YZ$ d e# f d     YZ% d e! f d     YZ& d e& f d     YZ' d e! f d     YZ( d e! f d     YZ) d e! f d     YZ* d e! f d     YZ+ d e+ f d     YZ, d  e! f d!     YZ- d" e- f d#     YZ. d$ e  f d%     YZ/ d& e/ f d'     YZ0 d( e0 f d)     YZ1 d* e/ f d+     YZ2 d, e/ f d-     YZ3 d.   Z4 d/   Z5 d0 d1  Z6 d2   Z7 d3   Z8 d4   Z9 d d5  Z; d S(6   s2   
Configuration parser and default values for yum.
iN(   t   ConfigPreProcessort
   varReplace(   t	   INIConfig(   t   NoSectionErrort   NoOptionErrort   ParsingError(   t   RawConfigParser(   t   ConfigParser(   t   get_uuidt   read_in_items_from_dot_dirt   Optionc           B   s\   e  Z d  Z d	 e d  Z d   Z d   Z d   Z d   Z	 d   Z
 d   Z d   Z RS(
   s   
    This class handles a single Yum configuration file option. Create
    subclasses for each type of supported configuration option.
    
    Python descriptor foo (__get__ and __set__) is used to make option
    definition easy and consise.
    c         C   s8   |  j    t |  _ | r+ |  j |  } n  | |  _ d  S(   N(   t   _setattrnamet   Falset   inheritt   parset   default(   t   selfR   t   parse_default(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   __init__:   s
    
	c         C   s   d t  |   |  _ d S(   sm   Calculate the internal attribute name used to store option state in
        configuration instances.
        s   __opt%dN(   t   idt	   _attrname(   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   A   s    c         C   s#   | d k r |  St | |  j d  S(   sC  Called when the option is read (via the descriptor protocol). 

        @param obj: The configuration instance to modify.
        @param objtype: The type of the config instance (not used).
        @return: The parsed option value or the default value if the value
            wasn't set in the configuration file.
        N(   t   Nonet   getattrR   (   R   t   objt   objtype(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   __get__G   s    	c         C   st   t  | t  r] y |  j |  } Wq] t k
 rY } t d |  j | t |  f   q] Xn  t | |  j |  d S(   s   Called when the option is set (via the descriptor protocol). 

        @param obj: The configuration instance to modify.
        @param value: The value to set the option to.
        @return: Nothing.
        s   Error parsing "%s = %r": %sN(   t
   isinstancet
   basestringR   t
   ValueErrort   _optnamet   strt   setattrR   (   R   R   t   valuet   e(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   __set__U   s    c         C   s,   | |  _  t | |  j t j |  j   d S(   s   Initialise the option for a config instance. 
        This must be called before the option can be set or retrieved. 

        @param obj: BaseConfig (or subclass) instance.
        @param name: Name of the option.
        N(   R   R   R   t   copyR   (   R   R   t   name(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   setupf   s    	c         C   s   t  j  |   } | j   | S(   s3   Return a safe copy of this Option instance
        (   R#   R   (   R   t   new(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   clonep   s    
c         C   s   | S(   s  Parse the string value to the Option's native value.

        @param s: Raw string value to parse.
        @return: Validated native value.
    
        Will raise ValueError if there was a problem parsing the string.
        Subclasses should override this.
        (    (   R   t   s(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   w   s    	c         C   s
   t  |  S(   s   Convert the Option's native value to a string value.

        @param value: Native option value.
        @return: String representation of input.

        This does the opposite of the parse() method above.
        Subclasses should override this.
        (   R   (   R   R    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   tostring   s    	N(   t   __name__t
   __module__t   __doc__R   R   R   R   R   R"   R%   R'   R   R)   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR
   1   s   				
		c         C   s   |  j    } t | _ | S(   s]  Clone an Option instance for the purposes of inheritance. The returned
    instance has all the same properties as the input Option and shares items
    such as the default value. Use this to avoid redefinition of reused
    options.

    @param option_obj: Option instance to inherit.
    @return: New Option instance inherited from the input.
    (   R'   t   TrueR   (   t
   option_objt
   new_option(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   Inherit   s    		t
   ListOptionc           B   s/   e  Z d  Z d e d  Z d   Z d   Z RS(   s1   
    An option containing a list of strings.
    c         C   s2   | d  k r g  } n  t t |   j | |  d  S(   N(   R   t   superR1   R   (   R   R   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR      s    	c         C   s   | j  d d  } | j  d d  } g  } x[ | j   D]M } | j d  rw | j  d d  } | j t |   q7 n  | j |  q7 W| S(   s   Converts a string from the config file to a workable list, parses
           globdir: paths as foo.d-style dirs

        Commas and spaces are used as separators for the list
        s   
t    t   ,s   glob:t    (   t   replacet   splitt
   startswitht   extendR	   t   append(   R   R(   t   resultst   itemt   thisglob(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR      s    c         C   s   d j  |  S(   Ns   
 (   t   join(   R   R    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR)      s    N(   R*   R+   R,   R   R   R   R   R)   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR1      s   	t	   UrlOptionc           B   s2   e  Z d  Z d d	 e d  Z d   Z d   Z RS(
   sN   
    This option handles lists of URLs with validation of the URL scheme.
    t   httpt   ftpt   filet   httpsc         C   s,   t  t |   j |  | |  _ | |  _ d  S(   N(   R2   R?   R   t   schemest
   allow_none(   R   R   RD   RE   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR      s    	c         C   s   | j    } | j   d k r: |  j r+ d  St d   n  t j |  \ } } } } } } | |  j k r t d |  j   | f   n  | S(   Nt   _none_s   "_none_" is not a valid values   URL must be %s not "%s"(   t   stript   lowerRE   R   R   t   urlparseRD   t   _schemelist(   R   t   urlR(   t   bt   pt   qt   ft   o(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR      s    	!c         C   sb   t  |  j  d k  r d St  |  j  d k r9 |  j d Sd d j |  j d   |  j d f Sd S(   s;   Return a user friendly list of the allowed schemes
        i   t   emptyi    s   %s or %ss   , iN(   t   lenRD   R>   (   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRJ      s
    N(   R@   RA   s   fileRC   (   R*   R+   R,   R   R   R   R   RJ   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR?      s
   	t   UrlListOptionc           B   s)   e  Z d  Z d d e d  Z d   Z RS(	   sN   
    Option for handling lists of URLs with validation of the URL scheme.
    R@   RA   RB   RC   c         C   s/   t  t |   j | |  t d |  |  _ d  S(   NRD   (   R2   RS   R   R?   t
   _urloption(   R   R   RD   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR      s    c         C   s   g  } | j  d d  } | j  d d  } g  t j |  D] } | j  d d  ^ q: } g  } xU | D]M } | j d  r | j  d d  } | j t |   qe n  | j |  qe WxB t t |   j	 d j
 |   D] } | j |  j j	 |   q W| S(   Ns   
R3   R4   s   %20s   glob:R5   (   R6   t   shlexR7   R8   R9   R	   R:   R2   RS   R   R>   RT   (   R   R(   t   outR<   t   itemst   tmpR=   RK   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR      s    .(N(   s   https   ftps   files   https(   R*   R+   R,   R   R   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRS      s   t	   IntOptionc           B   s)   e  Z d  Z d d d d  Z d   Z RS(   s2   
    An option representing an integer value.
    c         C   s,   t  t |   j |  | |  _ | |  _ d  S(   N(   R2   RY   R   t
   _range_mint
   _range_max(   R   R   t	   range_mint	   range_max(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    	c         C   s   y t  |  } Wn% t t f k
 r7 } t d   n X|  j d  k	 re | |  j k re t d   n  |  j d  k	 r | |  j k  r t d   n  | S(   Ns   invalid integer values   out of range integer value(   t   intR   t	   TypeErrorR[   R   RZ   (   R   R(   t   valR!   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    N(   R*   R+   R,   R   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRY      s   t   PositiveIntOptionc           B   s,   e  Z d  Z d d d d d  Z d   Z RS(   sg   
    An option representing a positive integer value, where 0 can have a special
    represention.
    i    c         C   s)   t  t |   j | | |  | |  _ d  S(   N(   R2   Ra   R   t   _names0(   R   R   R\   R]   t
   names_of_0(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    c         C   s)   | |  j  k r d St t |   j |  S(   Ni    (   Rb   R2   Ra   R   (   R   R(   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   "  s    N(   R*   R+   R,   R   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRa     s   	t   SecondsOptionc           B   s9   e  Z d  Z i d
 d 6d d 6d d 6d d 6Z d   Z RS(   s  
    An option representing an integer value of seconds, or a human readable
    variation specifying days, hours, minutes or seconds until something
    happens. Works like BytesOption.
    Note that due to historical president -1 means "never", so this accepts
    that and allows the word never too.

    Valid inputs: 100, 1.5m, 90s, 1.2d, 1d, 0xF, 0.1, -1, never
    Invalid inputs: -10, -0.1, 45.6Z, 1d6h, 1day, 1y

    Return value will always be an integer
    i<   i   t   dt   ht   mi   R(   c         C   s  t  |  d k  r! t d   n  | d k s9 | d k r= d S| d j   r | d  } | d j   } |  j j | d   } | s t d |   q n | } d } y t |  } Wn% t t f k
 r } t d   n X| d k  r t d	   n  t	 | |  S(
   Ni   s   no value specifieds   -1t   neveris   unknown unit '%s's   invalid valuei    s!   seconds value may not be negative(
   RR   R   t   isalphaRH   t   MULTSt   getR   t   floatR_   R^   (   R   R(   t   nt   unitt   multR!   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   7  s&    
i  iQ i  (   R*   R+   R,   Rj   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRd   '  s   "t
   BoolOptionc           B   s    e  Z d  Z d   Z d   Z RS(   sm   
    An option representing a boolean value.

    The value can be one of 0, 1, yes, no, true, or false.
    c         C   s<   | j    } | d k r t S| d	 k r, t St d   d  S(
   Nt   0t   not   falset   1t   yest   trues   invalid boolean value(   Rq   s   noRs   (   Rt   s   yesRv   (   RH   R   R-   R   (   R   R(   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   Y  s    c         C   s   | r
 d Sd Sd  S(   NRt   Rq   (    (   R   R    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR)   b  s    (   R*   R+   R,   R   R)   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRp   Q  s   		t   FloatOptionc           B   s   e  Z d  Z d   Z RS(   s7   
    An option representing a numeric float value.
    c         C   s>   y t  | j    SWn# t t f k
 r9 t d   n Xd  S(   Ns   invalid float value(   Rl   RG   R   R_   (   R   R(   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   l  s    (   R*   R+   R,   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRw   h  s   t   SelectionOptionc           B   s)   e  Z d  Z d d i  d  Z d   Z RS(   sA   Handles string values where only specific values are allowed
    c         C   s,   t  t |   j |  | |  _ | |  _ d  S(   N(   R2   Rx   R   t   _allowedt   _mapper(   R   R   t   allowedt   mapper(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   u  s    	c         C   sE   | |  j  k r |  j  | } n  | |  j k rA t d |   n  | S(   Ns   "%s" is not an allowed value(   Rz   Ry   R   (   R   R(   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   z  s
    N(    (   R*   R+   R,   R   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRx   r  s   t   CaselessSelectionOptionc           B   s   e  Z d  Z d   Z RS(   s_    Mainly for compat. with BoolOption, works like SelectionOption but
        lowers input case. c         C   s   t  t |   j | j    S(   N(   R2   R}   R   RH   (   R   R(   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    (   R*   R+   R,   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR}     s   t   BytesOptionc           B   s2   e  Z d  Z i d d 6d d 6d d 6Z d   Z RS(	   s|   
    An option representing a value in bytes.

    The value may be given in bytes, kilobytes, megabytes, or gigabytes.
    i   t   kRg   t   gc         C   s   t  |  d k  r! t d   n  | d j   r| | d  } | d j   } |  j j | d  } | s t d |   q n | } d } y t |  } Wn! t k
 r t d |   n X| d k  r t d   n  t | |  S(	   s  Parse a friendly bandwidth option to bytes

        The input should be a string containing a (possibly floating point)
        number followed by an optional single character unit. Valid units are
        'k', 'M', 'G'. Case is ignored.
       
        Valid inputs: 100, 123M, 45.6k, 12.4G, 100K, 786.3, 0
        Invalid inputs: -10, -0.1, 45.6L, 123Mb

        Return value will always be an integer

        1k = 1024 bytes.

        ValueError will be raised if the option couldn't be parsed.
        i   s   no value specifiedis   unknown unit '%s's   couldn't convert '%s' to numberi    s   bytes value may not be negativeN(	   RR   R   Ri   RH   Rj   Rk   R   Rl   R^   (   R   R(   Rm   Rn   Ro   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s"    
i   i   i   @(   R*   R+   R,   Rj   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR~     s   
t   ThrottleOptionc           B   s   e  Z d  Z d   Z RS(   sv   
    An option representing a bandwidth throttle value. See
    ThrottleOption.parse for acceptable input values.
    c         C   s   t  |  d k  r! t d   n  | d d k r | d  } y t |  } Wn! t k
 rn t d |   n X| d k  s | d k r t d   n  | d	 St j |  |  Sd
 S(   s  Get a throttle option. 

        Input may either be a percentage or a "friendly bandwidth value" as
        accepted by the BytesOption.

        Valid inputs: 100, 50%, 80.5%, 123M, 45.6k, 12.4G, 100K, 786.0, 0
        Invalid inputs: 100.1%, -4%, -500

        Return value will be a int if a bandwidth value was specified or a
        float if a percentage was given.

        ValueError will be raised if input couldn't be parsed.
        i   s   no value specifiedit   %s   couldn't convert '%s' to numberi    id   s   percentage is out of rangeg      Y@N(   RR   R   Rl   R~   R   (   R   R(   Rm   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    
(   R*   R+   R,   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s   t
   BaseConfigc           B   s   e  Z d  Z d   Z d   Z d d  Z e d  Z e	 e  Z d   Z
 e	 e
  Z
 d   Z d   Z d d d  Z d d	  Z d
   Z RS(   sk   
    Base class for storing configuration definitions. Subclass when creating
    your own definitons.
    c         C   sC   d  |  _ x3 |  j   D]% } |  j |  } | j |  |  q Wd  S(   N(   R   t   _sectiont   iterkeyst	   optionobjR%   (   R   R$   t   option(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    	c         C   s[   g  } | j  d |  j  x1 |  j   D]# \ } } | j  d | | f  q' Wd j |  S(   Ns   [%s]s   %s: %rs   
(   R:   R   t	   iteritemsR>   (   R   RV   R$   R    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   __str__  s
    c         C   s   | |  _  | |  _ | j |  r9 t | j |   } n	 t   } x |  j   D]| } |  j |  } d } | | k r | j | |  } n! | r | j	 r t
 | |  } n  | d k	 rO t |  | |  qO qO Wd S(   s$  Set option values from a INI file section.

        @param parser: ConfParser instance (or subclass)
        @param section: INI file section to read use.
        @param parent: Optional parent BaseConfig (or subclass) instance to use
            when doing option value inheritance.
        N(   t   cfgR   t   has_sectiont   sett   optionsR   R   R   Rk   R   R   R   (   R   t   parsert   sectiont   parentt   optsR$   R   R    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   populate  s    			c         C   s<   t  |  | d  } t | t  r% | S| r4 t  n d Sd S(   s6   Return the Option instance for the given name
        N(   R   R   R   R
   t   KeyError(   t   clsR$   t
   exceptionsR   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    	c         C   s   |  j  | d t d k	 S(   sB   Return True if the given name refers to a defined option 
        R   N(   R   R   R   (   R   R$   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   isoption  s    c         c   s2   x+ t  |   D] } |  j |  r | Vq q Wd S(   s@   Yield the names of all defined options in the instance.
        N(   t   dirR   (   R   R$   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   #  s    c         c   s/   x( |  j    D] } | t |  |  f Vq Wd S(   s   Yield (name, value) pairs for every option in the instance.

        The value returned is the parsed, validated option value.
        N(   R   R   (   R   R$   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   *  s    c         C   s   | d k r6 |  j d k r* t d   n  |  j } n  |  j j |  } x~ |  j   D]p \ } } |  j |  } | d k s | | k s | j | k s | | k rU |  j j | | | j	 |   qU qU W|  j j
 |  d S(   s  Write out the configuration to a file-like object

        @param fileobj: File-like object to write to
        @param section: Section name to use. If not-specified the section name
            used during parsing will be used.
        @param always: A sequence of option names to always write out.
            Options not listed here will only be written out if they are at
            non-default values. Set to None to dump out all options.
        s!   not populated, don't know sectionN(   R   R   R   R   R   R   R   R   R   R)   t   write(   R   t   fileobjR   t   alwayst
   cfgOptionsR$   R    R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   3  s    3&c         C   s0   t  j d t  t |  |  r, t |  |  S| S(   Nsx   getConfigOption() will go away in a future version of Yum.
Please access option values as attributes or using getattr().(   t   warningst   warnt   DeprecationWarningt   hasattrR   (   R   R   R   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   getConfigOptionL  s
    	c         C   sF   t  j d t  t |  |  r2 t |  | |  n t j d |  d  S(   Nsu   setConfigOption() will go away in a future version of Yum.
Please set option values as attributes or using setattr().s   No such option %s(   R   R   R   R   R   t   Errorst   ConfigError(   R   R   R    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   setConfigOptionT  s
    	N(    (   R*   R+   R,   R   R   R   R   R-   R   t   classmethodR   R   R   R   R   R   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s   		
				t   StartupConfc           B   s   e  Z d  Z e d d d  Z e d d d  Z e d  Z e d  Z e d  Z	 e
 e  Z e d d g  Z e d	 g  Z e
 e  Z e   Z e d
  Z e d  Z e d  Z RS(   s   
    Configuration option definitions for yum.conf's [main] section that are
    required early in the initialisation process or before the other [main]
    options can be parsed. 
    i   i    i
   s   redhat-releaset   /s   /etc/yum/yum.confs   /usr/share/yum-pluginss   /usr/lib/yum-pluginss   /etc/yum/pluginconf.dt   LOG_USERs   /dev/logs   /var/lib/yum(   R*   R+   R,   RY   t
   debuglevelt
   errorlevelR
   t   distroverpkgt   installroott   config_file_pathRp   R   t   pluginsR1   t
   pluginpatht   pluginconfpatht
   gaftonmodet   syslog_identt   syslog_facilityt   syslog_devicet
   persistdir(    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   ]  s   	t   YumConfc           B   s  e  Z d  Z e d d d g Z e d d d Z e d  Z e	 e
  Z e d  Z e d	 d
 g  Z e   Z e   Z e d  Z e d dK d e
  Z e   Z e   Z e   Z e   Z e d d d d d d d d d d d g  Z e d d d d d d g Z e d d d d d d d g  Z e d d d  d d d d d g  Z e   Z e	 e  Z e	 e
  Z e	 e
  Z  e	 e
  Z! e	 e
  Z" e	 e  Z# e	 e
  Z$ e	 e%  Z& e	 e'  Z( e	 e%  Z) e	 e
  Z* e	 e  Z+ e	 e
  Z, e	 e
  Z- e	 e
  Z. e	 e  Z/ e d! d" g  Z0 e1 d#  Z2 e3 d  Z4 e5 d  Z6 e7 d$ dL  Z8 e9 dN  Z: e9 dP  Z; e	 e
  Z< e   Z= e	 e  Z> e d* g  Z? e7 d$ dQ  Z@ e d,  ZA e7 d- dR d0 i
 d/ d1 6d/ d2 6d/ d3 6d/ d4 6d. d5 6d. d6 6d. d 6d. d7 6d- d8 6d- d9 6ZB e d:  ZC e d;  ZD e d<  ZE e d=  ZF e d>  ZG e d?  ZH e d@  ZI e d<  ZJ e d<  ZK e d:  ZL e d<  ZM e d:  ZN e   ZO e	 e
  ZP e   ZQ e   ZR e	 e
  ZS e dA dB g  ZT e dC  ZU e dD dE e
 ZV e	 e
  ZW e	 e  ZX e	 e  ZY e	 e  ZZ e	 e  Z[ e7 dF dS d0 i dH dI 6dF d" 6Z\ g  Z] dJ   Z^ RS(T   s   
    Configuration option definitions for yum.conf's [main] section.

    Note: see also options inherited from StartupConf
    i
   Rc   s	   <forever>i   R\   i    s   /var/cache/yums   /var/log/yum.logs   /etc/yum/repos.ds   /etc/yum.repos.dt
   roundrobinRD   R@   RA   RC   RE   t   kernels   kernel-bigmems   kernel-enterprises
   kernel-smps   kernel-moduless   kernel-debugs   kernel-unsupporteds   kernel-sources   kernel-devels
   kernel-PAEs   kernel-PAE-debugi   Rq   s   <off>s   kernel-BOOTs   kernel-hugememt	   mandatoryR   g      >@t   allt   nonet   packagesi<   i   i   s   group:primaryt   bests   http://yum.baseurl.org/reportt   autoRh   R   R|   t   onRu   Rt   Rv   t   offRr   Rs   t   ttys   if-ttyt   bolds   bold,yellowt   normals   bold,reds	   bold,blues   dim,cyans   bold,underline,greent   yumt   rpmt   infos%   yum, glob:/etc/yum/protected.d/*.confR   s   single-user-commandst   userst   commandst   cmdsc         C   s   d } d } x t  |   D] } | j d
  r4 q n  | | k rF q n  t t |  |  t j  rg q n  t |  |  } | r t |  t t  t d  f k r d } n  t |  t j k r d j	 |  } n  | d | | f } q W| S(   Ns   [main]
R   t   uidt   yumvart   progress_objt   failure_objt   disable_excludest   config_file_ageR   t   _i    R5   s   ,
   s   %s = %s
(   s   cfgs   uids   yumvarR   R   s   disable_excludess   config_file_ages   config_file_path(
   R   R8   R   R   t   typest
   MethodTypet   typeR   t   ListTypeR>   (   R   t   outputt   excluded_varst   attrt   res(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   dump  s"     +	(   s   https   ftps   https(   R   R   s   alli  i`T  i  iQ (   R   s   all(   R   s   nevers   always(   s   single-user-commandsR   s   commands(_   R*   R+   R,   Ra   t   retriesRY   t   recentR
   t   cachedirRp   R-   t	   keepcachet   logfileR1   t   reposdirR   t   excludet   failovermethodR?   t   proxyt   proxy_usernamet   proxy_passwordt   usernamet   passwordt   installonlypkgst   installonly_limitt   kernelpkgnamest   exactarchlistt   tsflagsR   t	   assumeyest   alwayspromptt	   exactarcht   tolerantt   diskspacecheckt   overwrite_groupst	   keepalivet   __pkgs_gpgcheck_default__t   gpgcheckt   __repo_gpgcheck_default__t   repo_gpgcheckt   localpkg_gpgcheckt	   obsoletest   showdupesfromrepost   enabledt   enablegroupst   enable_group_conditionalst   groupremove_leaf_onlyt   group_package_typesRw   t   timeoutR~   t	   bandwidthR   t   throttleRx   t   http_cachingRd   t   metadata_expiret   mirrorlist_expiret   rpm_check_debugR   t   skip_brokent   mdpolicyt   multilib_policyt   bugtracker_urlt   colort   color_list_installed_oldert   color_list_installed_newert   color_list_installed_reinstallt   color_list_installed_extrat   color_list_available_upgradet   color_list_available_downgradet   color_list_available_reinstallt   color_list_available_installt   color_update_installedt   color_update_localt   color_update_remotet   color_search_matcht	   sslcacertt	   sslverifyt   sslclientcertt   sslclientkeyt   history_recordt   history_record_packagest   rpmverbosityt   protected_packagest   protected_multilibt   exit_on_lockt   loadts_ignoremissingt   loadts_ignorerpmt   clean_requirements_on_removet   history_list_viewt
   _reposlistR   (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR   s  s   																 
t   RepoConfc           B   s  e  Z d  Z e   Z d   Z e   Z e e	 j
  Z
 e   Z e   Z e   Z e   Z e   Z e   Z e   Z e   Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j  Z e e	 j   Z  e e	 j!  Z! e e	 j"  Z" e e	 j#  Z# e e	 j$  Z$ e e	 j%  Z% e e	 j&  Z& e e	 j'  Z' e( d  Z) e e	 j*  Z* e e	 j+  Z+ e e	 j,  Z, e e	 j-  Z- e. e/  Z0 RS(   s>   
    Option definitions for repository INI file sections.
    c         c   sf   |  j  } t |  t  s$ t   } n  | sI | j t t j |     n  x |  j  D] } | VqS Wd S(   s@   Yield the names of all defined options in the instance.
        N(   t   _RepoConf__cached_keysR   R%  R   t   updatet   listR   R   (   R   t   ckR$   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR     s    	i  (1   R*   R+   R,   R   R&  R   R
   R$   R0   R   R   RS   t   baseurlR?   t
   mirrorlistt   metalinkt   mediaidt   gpgkeyt   gpgcakeyR1   R   t   includepkgsR   R   R   R   R   R   R   R   R   R   R   R   R   R   R  R  R  R  RY   t   costR  R  R  R  Rp   R   t   skip_if_unavailable(    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR%    sJ   											t   VersionGroupConfc           B   s   e  Z e   Z e e  Z RS(    (   R*   R+   R1   t   pkglistRp   R   t   run_with_packages(    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR3  I  s   	c         C   s   | t  j _ t    } |  | _ t   } t |   } y | j |  Wn& t k
 rl } t j	 d |   n X| j
 | d  x3 | j D]( } | d d k s t j	 d   q q W| | _ t | j | j  | _ d | j | j f } t |  | _ | S(   s  
    Parse Yum's main configuration file and return a StartupConf instance.
    
    This is required in order to access configuration settings required as Yum
    starts up.

    @param configfile: The path to yum.conf.
    @param root: The base path to use for installation (typically '/')
    @return: A StartupConf instance.

    May raise Errors.ConfigError if a problem is detected with while parsing.
    s   Parsing file failed: %st   maini    R   s(   All plugin search paths must be absolutes
   %s/%s/uuid(   R   R   R   R   R   R    t   readfpR   R   R   R   R   t   _parsert
   _getsysverR   t
   releaseverR   R   t   uuid(   t
   configfilet   roott   startupconfR   t
   confpp_objR!   t   patht   uuidfile(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   readStartupConfigN  s$    				c            s  t      |  j   d <|  j   d <|  j   d <|  j   d <t   } | j |  j d    f d   } y  | j d } t	 j
 |  } Wn t k
 r g  } n Xx | D] } t	 j j | |  r q n  y= t | |  j   } | r| d d	 k r| d  } n  Wn t t f k
 r$q n X|   | <q Wx d D] } | | |  q:W  | _ d | _ d | _ d | _ |  j | _ t	 j j |  j  rt	 j |  j  d | _ n	 d | _ |  j | _ |  j | _ | S(   s   
    Parse Yum's main configuration file

    @param startupconf: StartupConf instance as returned by readStartupConfig()
    @return: Populated YumConf instance.
    t   basearcht   archR:  R;  R6  c            sQ   t  |  |  } |  j | } | j d d  } t |    } t |  | |  d  S(   Ns   //R   (   R   R   R6   R   R   (   t   yumconfR   R@  t   ir_path(   t   yumvars(    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   _apply_installroot  s
    s   /etc/yum/vars/is   
R   R   R   i    i   (   s   cachedirs   logfiles
   persistdirN(   t
   _getEnvVarRC  RD  R:  R;  R   R   R8  R   t   ost   listdirt   OSErrorR@  t   islinkt   opent   readlinet   IOErrorR   R   t   cacheR   t   progess_objR   t   existst   statR   R   R   (   R>  RE  RH  t
   dir_fsvarst   fsvarst   fsvarR`   R   (    (   RG  s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   readMainConfigv  sH    			
					s   /etc/yum/version-groups.confc         C   s   t    } t |   } y | j |  Wn& t k
 rN } t j d |   n Xi  } x5 | j   D]' } t   | | <| | j | |  qb W| S(   Ns   Parsing file failed: %s(	   R   R    R7  R   R   R   t   sectionsR3  R   (   R<  R   R?  R!   t   retR   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   readVersionGroupsConfig  s    	c         C   sA   y |  j  | |  } Wn t t f k
 r3 | j SX| j |  S(   s  Convenience function to retrieve a parsed and converted value from a
    ConfigParser.

    @param conf: ConfigParser instance or similar
    @param section: Section name
    @param name: Option name
    @param option: Option instance to use for conversion.
    @return: The parsed value or default if value was not present.

    Will raise ValueError if the option could not be parsed.
    (   Rk   R   R   R   R   (   t   confR   R$   R   R`   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt	   getOption  s
    c          C   s\   i  }  xO t  d d  D]> } d | } t j j | d  } | r | |  | j   <q q W|  S(   s   Return variable replacements from the environment variables YUM0 to YUM9

    The result is intended to be used with parser.varReplace()
    i    i
   s   YUM%dR5   (   t   rangeRJ  t   environRk   RH   (   R   t   numt   envR`   (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyRI    s    
c         C   s7  t  j j d |   } | j t j t j B y | j d |  } Wn t k
 r } t	 j
 d k  r t | d  r t j d t | j    q t j d t |    n  t j d t |    n/ t j k
 r } t j d t |    n X| j   d k rd } n | j   } | d } ~ ~ ~ | S(	   s   Calculate the release version for the system.

    @param installroot: The value of the installroot option.
    @param distroverpkg: The value of the distroverpkg option.
    @return: The release version as a string (eg. '4' for FC4)
    R=  t   providesi  t   messages   Error: i    s   $releasevert   version(   t   rpmUtilst   transactiont   initReadOnlyTransactiont   pushVSFlagsR   t   _RPMVSF_NOSIGNATURESt   _RPMVSF_NODIGESTSt   dbMatchR_   t   syst
   hexversionR   R   t   YumBaseErrorR   Rc  t   errort   countt   next(   R   R   t   tst   idxR!   R:  t   hdr(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyR9    s(    	
c         C   s  t  s
 d St t |  j   } |  j } |  j | j k r{ x> | j j   D]* } t | |  j  |  j k rJ | } qJ qJ Wn  |  j	 j
 |  j  } x |  j   D] \ } } | d k r q n  | d k	 r | | k r q n  |  j |  } | j |  }	 | | | k r5|	 t | | | t  k r5| | | }	 n  | | k rV| j | k rVq n  |	 | | | <q Wt |  j d  }
 |
 j t |   |
 j   d S(   s  
    Writes changes in a repo object back to a .repo file.
    @param repo: Repo Object
    @param only: List of attributes to work on (None = All)
    It work by reading the repo file, changes the values there shall be changed and write it back to disk.
    Nt   w(   t   _use_iniparseR   RN  t   repofileR   t	   _sectionst   keysR   R   R   R   R   R   R   R)   R   RB   R   R   t   close(   t   repot   onlyt   init
   section_idt   sectR   R$   R    R   t   ovaluet   fp(    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   writeRawRepoFile  s2    	(<   R,   R-   Rv  RJ  Rl  R   R   R#   RI   RU   R   R    R   t   iniparseR   t   iniparse.compatR   R   R   R   R   t   ImportErrorR   t   rpmUtils.transactionRe  R   R   t   miscR   R	   R   R   t   objectR
   R0   R1   R?   RS   RY   Ra   Rd   Rp   Rw   Rx   R}   R~   R   R   R   R   R%  R3  RB  RX  R[  R]  RI  R9  R   R  (    (    (    s.   /usr/lib/python2.7/dist-packages/yum/config.pyt   <module>   sd   
\	"&*
5$|=	(	H			#                                                                                                                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python2.7/dist-packages/yum/constants.py                                                    0100644 0000000 0000000 00000007235 12451005146 020320  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""
Yum constants. Usually dealing with rpm magic numbers.
"""

#Constants
YUM_PID_FILE = '/var/run/yum.pid'

#transaction set states
TS_UPDATE = 10
TS_INSTALL = 20
TS_TRUEINSTALL = 30
TS_ERASE = 40
TS_OBSOLETED = 50
TS_OBSOLETING = 60
TS_AVAILABLE = 70
TS_UPDATED = 90
TS_FAILED = 100

TS_INSTALL_STATES = [TS_INSTALL, TS_TRUEINSTALL, TS_UPDATE, TS_OBSOLETING]
TS_REMOVE_STATES = [TS_ERASE, TS_OBSOLETED, TS_UPDATED]

# Transaction Relationships
TR_UPDATES = 1
TR_UPDATEDBY = 2
TR_OBSOLETES = 3
TR_OBSOLETEDBY = 4
TR_DEPENDS = 5
TR_DEPENDSON = 6

# Transaction Member Sort Colors
# Each node in a topological sort is colored
# White nodes are unseen, black nodes are seen
# grey nodes are in progress
TX_WHITE = 0
TX_GREY = 1
TX_BLACK = 2

# package object file types
PO_FILE = 1
PO_DIR = 2
PO_GHOST = 3
PO_CONFIG = 4
PO_DOC = 5

# package object package types
PO_REMOTEPKG = 1
PO_LOCALPKG = 2
PO_INSTALLEDPKG = 3

# FLAGS
SYMBOLFLAGS = {'>':'GT', '<':'LT', '=': 'EQ', '==': 'EQ', '>=':'GE', '<=':'LE'}
LETTERFLAGS = {'GT':'>', 'LT':'<', 'EQ':'=', 'GE': '>=', 'LE': '<='}

# Constants for plugin config option registration
PLUG_OPT_STRING = 0
PLUG_OPT_INT = 1
PLUG_OPT_FLOAT = 2
PLUG_OPT_BOOL = 3

PLUG_OPT_WHERE_MAIN = 0
PLUG_OPT_WHERE_REPO = 1
PLUG_OPT_WHERE_ALL = 2

# version of sqlite database schemas
DBVERSION = '10'

# boolean dict:
BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True,
                  '0': False, 'no': False, 'false': False, 'off': False}

RPM_TO_SQLITE = { 'packagesize' : 'size_package',
                 'archivesize' : 'size_archive',
                 'installedsize' : 'size_installed',
                 'buildtime' : 'time_build',
                 'hdrstart' : 'rpm_header_start',
                 'hdrend' : 'rpm_header_end',
                 'basepath' : 'location_base',
                 'relativepath': 'location_href',
                 'filetime' : 'time_file',
                 'packager' : 'rpm_packager',
                 'group' : 'rpm_group',
                 'buildhost' : 'rpm_buildhost',
                 'sourcerpm' : 'rpm_sourcerpm',
                 'vendor' : 'rpm_vendor',
                 'license' : 'rpm_license'
                        }

#  Cut over for when we should just give up and load everything.
#  The main problem here is not so much SQLite dying (although that happens
# at large values: http://sqlite.org/limits.html#max_variable_number) but that
# but SQLite going really slow when it gets medium sized values (much slower
# than just loading everything and filtering it in python).
PATTERNS_MAX = 8
#  We have another value here because name is indexed and sqlite is _much_
# faster even at large numbers of patterns.
PATTERNS_INDEXED_MAX = 128

RPM_CHECKSUM_TYPES = { 1:'md5', 2:'sha1', 8:'sha256', 9:'sha384', 10:'sha512',
                       11:'sha224' } # from RFC 4880


# for repo verification/checks
REPO_PROBLEM_REPOMD=1
REPO_PROBLEM_METADATA=2
REPO_PROBLEM_COMPS=3
REPO_PROBLEM_OTHER=4
REPO_PROBLEM_PACKAGE=5
                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python2.7/dist-packages/yum/constants.pyc                                                   0100644 0000000 0000000 00000005064 13077704344 020474  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s]  d  Z  d Z d Z d Z d Z d Z d Z d Z d Z d	 Z	 d
 Z
 e e e e g Z e e e	 g Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z i d d 6d d 6d d 6d d 6d d 6d d 6Z i d d 6d d 6d d 6d d 6d d 6Z d Z  d Z! d Z" d Z# d Z$ d Z% d Z& d Z' i e( d 6e( d 6e( d  6e( d! 6e) d" 6e) d# 6e) d$ 6e) d% 6Z* i d& d' 6d( d) 6d* d+ 6d, d- 6d. d/ 6d0 d1 6d2 d3 6d4 d5 6d6 d7 6d8 d9 6d: d; 6d< d= 6d> d? 6d@ dA 6dB dC 6Z+ dD Z, dE Z- i dF d 6dG d 6dH dD 6dI dJ 6dK d 6dL dM 6Z. d Z/ d Z0 d Z1 d Z2 d Z3 dN S(O   s8   
Yum constants. Usually dealing with rpm magic numbers.
s   /var/run/yum.pidi
   i   i   i(   i2   i<   iF   iZ   id   i   i   i   i   i   i   i    t   GTt   >t   LTt   <t   EQt   =s   ==t   GEs   >=t   LEs   <=t   10t   1t   yest   truet   ont   0t   not   falset   offt   size_packaget   packagesizet   size_archivet   archivesizet   size_installedt   installedsizet
   time_buildt	   buildtimet   rpm_header_startt   hdrstartt   rpm_header_endt   hdrendt   location_baset   basepatht   location_hreft   relativepatht	   time_filet   filetimet   rpm_packagert   packagert	   rpm_groupt   groupt   rpm_buildhostt	   buildhostt   rpm_sourcerpmt	   sourcerpmt
   rpm_vendort   vendort   rpm_licenset   licensei   i   t   md5t   sha1t   sha256t   sha384i	   t   sha512t   sha224i   N(4   t   __doc__t   YUM_PID_FILEt	   TS_UPDATEt
   TS_INSTALLt   TS_TRUEINSTALLt   TS_ERASEt   TS_OBSOLETEDt   TS_OBSOLETINGt   TS_AVAILABLEt
   TS_UPDATEDt	   TS_FAILEDt   TS_INSTALL_STATESt   TS_REMOVE_STATESt
   TR_UPDATESt   TR_UPDATEDBYt   TR_OBSOLETESt   TR_OBSOLETEDBYt
   TR_DEPENDSt   TR_DEPENDSONt   TX_WHITEt   TX_GREYt   TX_BLACKt   PO_FILEt   PO_DIRt   PO_GHOSTt	   PO_CONFIGt   PO_DOCt   PO_REMOTEPKGt   PO_LOCALPKGt   PO_INSTALLEDPKGt   SYMBOLFLAGSt   LETTERFLAGSt   PLUG_OPT_STRINGt   PLUG_OPT_INTt   PLUG_OPT_FLOATt   PLUG_OPT_BOOLt   PLUG_OPT_WHERE_MAINt   PLUG_OPT_WHERE_REPOt   PLUG_OPT_WHERE_ALLt	   DBVERSIONt   Truet   Falset   BOOLEAN_STATESt   RPM_TO_SQLITEt   PATTERNS_MAXt   PATTERNS_INDEXED_MAXt   RPM_CHECKSUM_TYPESt   REPO_PROBLEM_REPOMDt   REPO_PROBLEM_METADATAt   REPO_PROBLEM_COMPSt   REPO_PROBLEM_OTHERt   REPO_PROBLEM_PACKAGE(    (    (    s1   /usr/lib/python2.7/dist-packages/yum/constants.pyt   <module>   s   0)

&
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python2.7/dist-packages/yum/depsolve.py                                                     0100644 0000000 0000000 00000167002 12451005146 020124  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -t
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University 

"""
Dependency resolution module for yum.
"""

import os.path
import types
import logging

import rpmUtils.transaction
import rpmUtils.miscutils
from rpmUtils.arch import archDifference, canCoinstall
import misc
from misc import unique, version_tuple_to_string
from transactioninfo import TransactionMember
import rpm

from packageSack import ListPackageSack
from constants import *
import packages
import logginglevels
import Errors
import warnings
warnings.simplefilter("ignore", Errors.YumFutureDeprecationWarning)

from yum import _, _rpm_ver_atleast

try:
    assert max(2, 4) == 4
except:
    # Python-2.4.x doesn't have min/max ... *sigh*
    def min(x, *args): 
        for y in args:
            if x > y: x = y
        return x
    def max(x, *args):
        for y in args:
            if x < y: x = y
        return x
flags = {"GT": rpm.RPMSENSE_GREATER,
         "GE": rpm.RPMSENSE_EQUAL | rpm.RPMSENSE_GREATER,
         "LT": rpm.RPMSENSE_LESS,
         "LE": rpm.RPMSENSE_LESS | rpm.RPMSENSE_EQUAL,
         "EQ": rpm.RPMSENSE_EQUAL,
         None: 0 }

class Depsolve(object):

    """
    Dependency resolving class.
    """

    def __init__(self):
        self._ts = None
        self._tsInfo = None
        self.dsCallback = None
        # Callback-style switch, default to legacy (hdr, file) mode
        self.use_txmbr_in_callback = False
        self.logger = logging.getLogger("yum.Depsolve")
        self.verbose_logger = logging.getLogger("yum.verbose.Depsolve")

        self.path = []
        self.loops = []

        self.installedFileRequires = None
        self.installedUnresolvedFileRequires = None

    def doTsSetup(self):
        warnings.warn(_('doTsSetup() will go away in a future version of Yum.\n'),
                Errors.YumFutureDeprecationWarning, stacklevel=2)
        return self._getTs()
        
    def _getTs(self, remove_only=False):
        """setup all the transaction set storage items we'll need
           This can't happen in __init__ b/c we don't know our installroot
           yet"""
        
        if self._tsInfo != None and self._ts != None:
            if not remove_only and self._tsInfo.pkgSack is None:
                self._tsInfo.setDatabases(self.rpmdb, self.pkgSack)
            return
            
        if not self.conf.installroot:
            raise Errors.YumBaseError, _('Setting up TransactionSets before config class is up')
        
        self._getTsInfo(remove_only)
        self.initActionTs()
    
    def _getTsInfo(self, remove_only=False):
        """ remove_only param. says if we are going to do _only_ remove(s) in
            the transaction. If so we don't need to setup the remote repos. """
        if self._tsInfo is None:
            self._tsInfo = self._transactionDataFactory()
            if remove_only:
                pkgSack = None
            else:
                pkgSack = self.pkgSack
            self._tsInfo.setDatabases(self.rpmdb, pkgSack)
            self._tsInfo.installonlypkgs = self.conf.installonlypkgs # this kinda sucks
            # this REALLY sucks, sadly (needed for group conditionals)
            self._tsInfo.install_method = self.install
            self._tsInfo.update_method = self.update
            self._tsInfo.remove_method = self.remove
        return self._tsInfo

    def _setTsInfo(self, value):
        self._tsInfo = value

    def _delTsInfo(self):
        self._tsInfo = None
        
    def _getActionTs(self):
        if not self._ts:
            self.initActionTs()
        return self._ts
        

    def initActionTs(self):
        """sets up the ts we'll use for all the work"""
        
        self._ts = rpmUtils.transaction.TransactionWrapper(self.conf.installroot)
        ts_flags_to_rpm = { 'noscripts': rpm.RPMTRANS_FLAG_NOSCRIPTS,
                            'notriggers': rpm.RPMTRANS_FLAG_NOTRIGGERS,
                            'nodocs': rpm.RPMTRANS_FLAG_NODOCS,
                            'test': rpm.RPMTRANS_FLAG_TEST,
                            'justdb': rpm.RPMTRANS_FLAG_JUSTDB,
                            'repackage': rpm.RPMTRANS_FLAG_REPACKAGE}
        # This is only in newer rpm.org releases
        if hasattr(rpm, 'RPMTRANS_FLAG_NOCONTEXTS'):
            ts_flags_to_rpm['nocontexts'] = rpm.RPMTRANS_FLAG_NOCONTEXTS
        
        self._ts.setFlags(0) # reset everything.
        
        for flag in self.conf.tsflags:
            if flag in ts_flags_to_rpm:
                self._ts.addTsFlag(ts_flags_to_rpm[flag])
            else:
                self.logger.critical(_('Invalid tsflag in config file: %s'), flag)

        probfilter = 0
        for flag in self.tsInfo.probFilterFlags:
            probfilter |= flag
        self._ts.setProbFilter(probfilter)

    def whatProvides(self, name, flags, version):
        """searches the packageSacks for what provides the arguments
           returns a ListPackageSack of providing packages, possibly empty"""

        self.verbose_logger.log(logginglevels.DEBUG_1, _('Searching pkgSack for dep: %s'),
            name)
        defSack = ListPackageSack(self.pkgSack.searchProvides((name, flags, version)))
        return defSack
        
    def allowedMultipleInstalls(self, po):
        """takes a packageObject, returns 1 or 0 depending on if the package 
           should/can be installed multiple times with different vers
           like kernels and kernel modules, for example"""

        iopkgs = set(self.conf.installonlypkgs)
        if po.name in iopkgs:
            return True
        
        for prov in po.provides_names:
            if prov in iopkgs:
                return True
        
        return False

    def populateTs(self, test=0, keepold=1):
        """take transactionData class and populate transaction set"""

        if self.dsCallback: self.dsCallback.transactionPopulation()
        ts_elem = {}
        
        if self.ts.ts is None:
            self.initActionTs()
            
        if keepold:
            for te in self.ts:
                epoch = te.E()
                if epoch is None:
                    epoch = '0'
                pkginfo = (te.N(), te.A(), epoch, te.V(), te.R())
                if te.Type() == 1:
                    mode = 'i'
                elif te.Type() == 2:
                    mode = 'e'
                
                ts_elem[(pkginfo, mode)] = 1
                
        for txmbr in self.tsInfo.getMembers():
            self.verbose_logger.log(logginglevels.DEBUG_3, _('Member: %s'), txmbr)
            if txmbr.ts_state in ['u', 'i']:
                if (txmbr.pkgtup, 'i') in ts_elem:
                    continue
                rpmfile = txmbr.po.localPkg()
                if os.path.exists(rpmfile):
                    hdr = txmbr.po.returnHeaderFromPackage()
                else:
                    self.downloadHeader(txmbr.po)
                    hdr = txmbr.po.returnLocalHeader()

                if txmbr.ts_state == 'u':
                    if self.allowedMultipleInstalls(txmbr.po):
                        self.verbose_logger.log(logginglevels.DEBUG_2,
                            _('%s converted to install'), txmbr.po)
                        txmbr.ts_state = 'i'
                        txmbr.output_state = TS_INSTALL

                # New-style callback with just txmbr instead of full headers?
                if self.use_txmbr_in_callback:
                    cbkey = txmbr
                else:
                    cbkey = (hdr, rpmfile)
                
                self.ts.addInstall(hdr, cbkey, txmbr.ts_state)
                self.verbose_logger.log(logginglevels.DEBUG_1,
                    _('Adding Package %s in mode %s'), txmbr.po, txmbr.ts_state)
                if self.dsCallback:
                    dscb_ts_state = txmbr.ts_state
                    if dscb_ts_state == 'u' and txmbr.downgrades:
                        dscb_ts_state = 'd'
                    self.dsCallback.pkgAdded(txmbr.pkgtup, dscb_ts_state)
            
            elif txmbr.ts_state in ['e']:
                if (txmbr.pkgtup, txmbr.ts_state) in ts_elem:
                    continue
                self.ts.addErase(txmbr.po.idx)
                if self.dsCallback:
                    if txmbr.downgraded_by:
                        continue
                    self.dsCallback.pkgAdded(txmbr.pkgtup, 'e')
                self.verbose_logger.log(logginglevels.DEBUG_1,
                    _('Removing Package %s'), txmbr.po)

    def _dscb_procReq(self, po, niceformatneed):
        """ Call the callback for processing requires, call the nicest one
            available. """
        if not self.dsCallback:
            return

        if hasattr(self.dsCallback, 'procReqPo'):
            self.dsCallback.procReqPo(po, niceformatneed)
        else:
            self.dsCallback.procReq(po.name, niceformatneed)

    def _processReq(self, po, requirement):
        """processes a Requires dep from the resolveDeps functions, returns a tuple
           of (CheckDeps, missingdep, conflicts, errors) the last item is an array
           of error messages"""
        
        errormsgs = []

        needname, flags, needversion = requirement
        niceformatneed = rpmUtils.miscutils.formatRequire(needname, needversion, flags)
        self.verbose_logger.log(logginglevels.DEBUG_1, _('%s requires: %s'), po, niceformatneed)
        self._dscb_procReq(po, niceformatneed)

        try:    
            if po.repo.id != "installed":
                CheckDeps, missingdep = self._requiringFromTransaction(po, requirement, errormsgs)
            else:
                CheckDeps, missingdep = self._requiringFromInstalled(po, requirement, errormsgs)
    
            # Check packages with problems
            if missingdep:
                self.po_with_problems.add((po,self._working_po,errormsgs[-1]))
            
    
        except Errors.DepError,e:
            # FIXME: This is a hack, it don't solve the problem
            # of tries to update to a package the have been removed from the
            # pkgSack because of dep problems.
            # The real solution is to remove the package from the updates, when
            # it is remove from the pkgSack
            self.po_with_problems.add((po,self._working_po,str(e)))
            CheckDeps = 1
            missingdep = 0

        return (CheckDeps, missingdep, errormsgs)

    @staticmethod
    def _prco_req_nfv2req(rn, rf, rv):
        return (rn, flags[rf], version_tuple_to_string(rv))

    def _prco_req2req(self, req):
        return self._prco_req_nfv2req(req[0], req[1], req[2])
            
    def _err_missing_requires(self, reqPo, reqTup):
        if hasattr(self.dsCallback, 'format_missing_requires'):
            msg = self.dsCallback.format_missing_requires(reqPo, reqTup)
            if msg is not None: # PK
                return self.dsCallback.format_missing_requires(reqPo, reqTup)
        (needname, needflags, needversion) = reqTup
        ui_req = rpmUtils.miscutils.formatRequire(needname, needversion,
                                                  needflags)
        return _('%s requires %s') % (reqPo, ui_req)

    def _requiringFromInstalled(self, requiringPo, requirement, errorlist):
        """processes the dependency resolution for a dep where the requiring 
           package is installed"""

        checkdeps = 0
        missingdep = 0
        
        if self.tsInfo.getMembersWithState(requiringPo.pkgtup, TS_REMOVE_STATES):
            return checkdeps, missingdep

        name, arch, epoch, ver, rel = requiringPo.pkgtup

        needname, needflags, needversion = requirement
        niceformatneed = rpmUtils.miscutils.formatRequire(needname, needversion, needflags)


        # we must first find out why the requirement is no longer there
        # we must find out what provides/provided it from the rpmdb (if anything)
        # then check to see if that thing is being acted upon by the transaction set
        # if it is then we need to find out what is being done to it and act accordingly
        needmode = None # mode in the transaction of the needed pkg (if any)
        needpo = None
        providers = []
        
        if (needname, needflags, needversion) in self.cheaterlookup:
            self.verbose_logger.log(logginglevels.DEBUG_2, _('Needed Require has already been looked up, cheating'))
            cheater_po = self.cheaterlookup[(needname, needflags, needversion)]
            providers = [cheater_po]
        
        elif self.rpmdb.contains(name=needname):
            txmbrs = self.tsInfo.matchNaevr(name=needname)
            for txmbr in txmbrs:
                providers.append(txmbr.po)

        else:
            self.verbose_logger.log(logginglevels.DEBUG_2, _('Needed Require is not a package name. Looking up: %s'), niceformatneed)
            providers = self.rpmdb.getProvides(needname, needflags, needversion)

        for inst_po in providers:
            self._working_po = inst_po # store the last provider
            inst_str = '%s.%s %s:%s-%s' % inst_po.pkgtup
            (i_n, i_a, i_e, i_v, i_r) = inst_po.pkgtup
            self.verbose_logger.log(logginglevels.DEBUG_2,
                _('Potential Provider: %s'), inst_str)
            thismode = self.tsInfo.getMode(name=i_n, arch=i_a, 
                            epoch=i_e, ver=i_v, rel=i_r)

            if thismode is None and i_n in self.conf.exactarchlist:
                # check for mode by the same name+arch
                thismode = self.tsInfo.getMode(name=i_n, arch=i_a)
            
            if thismode is None and i_n not in self.conf.exactarchlist:
                # check for mode by just the name
                thismode = self.tsInfo.getMode(name=i_n)

            # if this package is being obsoleted, it's just like if it's
            # being upgraded as far as checking for other providers
            if thismode is None:
                if filter(lambda x: x.obsoleted_by,
                          self.tsInfo.matchNaevr(i_n, i_a, i_e, i_v, i_r)):
                    thismode = 'u'

            if thismode is not None:
                needmode = thismode

                self.cheaterlookup[(needname, needflags, needversion)] = inst_po
                self.verbose_logger.log(logginglevels.DEBUG_2, _('Mode is %s for provider of %s: %s'),
                    needmode, niceformatneed, inst_str)
                break
                    
        self.verbose_logger.log(logginglevels.DEBUG_2, _('Mode for pkg providing %s: %s'), 
            niceformatneed, needmode)

        if needmode in ['ud']: # the thing it needs is being updated or obsoleted away 
            # try to update the requiring package in hopes that all this problem goes away :(
            self.verbose_logger.log(logginglevels.DEBUG_2, _('Trying to update %s to resolve dep'), requiringPo)
            # if the required pkg was updated, not obsoleted, then try to
            # only update the requiring po
            origobs = self.conf.obsoletes
            self.conf.obsoletes = 0
            txmbrs = self.update(po=requiringPo, requiringPo=requiringPo)
            self.conf.obsoletes = origobs
            if not txmbrs:
                txmbrs = self.update(po=requiringPo, requiringPo=requiringPo)
                if not txmbrs:
                    msg = self._err_missing_requires(requiringPo, requirement)
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('No update paths found for %s. Failure!'), requiringPo)
                    return self._requiringFromTransaction(requiringPo, requirement, errorlist)
            checkdeps = 1

        if needmode in ['od']: # the thing it needs is being updated or obsoleted away 
            # try to update the requiring package in hopes that all this problem goes away :(
            self.verbose_logger.log(logginglevels.DEBUG_2, _('Trying to update %s to resolve dep'), requiringPo)
            txmbrs = self.update(po=requiringPo, requiringPo=requiringPo)
            if not txmbrs:
                msg = self._err_missing_requires(requiringPo, requirement)
                self.verbose_logger.log(logginglevels.DEBUG_2, _('No update paths found for %s. Failure!'), requiringPo)
                return self._requiringFromTransaction(requiringPo, requirement, errorlist)
            checkdeps = 1

            
        if needmode in ['e']:
            self.verbose_logger.log(logginglevels.DEBUG_2, _('TSINFO: %s package requiring %s marked as erase'),
                requiringPo, needname)
            txmbrs = self.remove(po=requiringPo)
            for txmbr in txmbrs:
                txmbr.setAsDep(po=inst_po)
            checkdeps = 1
        
        if needmode in ['i', 'u']:
            newupdates = self.update(name=name, epoch=epoch, version=ver, release=rel,
                                     requiringPo=requiringPo)
            txmbrs = self.tsInfo.getMembersWithState(requiringPo.pkgtup, TS_REMOVE_STATES)
            if newupdates and txmbrs:
                if txmbrs[0].output_state == TS_OBSOLETED:
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('TSINFO: Obsoleting %s with %s to resolve dep.'),
                                            requiringPo, txmbrs[0].obsoleted_by[0])
                else:
                    self.verbose_logger.log(logginglevels.DEBUG_2, _('TSINFO: Updating %s to resolve dep.'), requiringPo)
                    # If the requirement is still there, try and solve it again
                    # so we don't lose it
                    for pkg in txmbrs[0].updated_by:
                        if requirement in map(self._prco_req2req, pkg.returnPrco('requires')):
                            return True, missingdep + self._requiringFromTransaction(pkg, requirement, errorlist)[1]
                checkdeps = True
                return checkdeps, missingdep
            self.verbose_logger.log(logginglevels.DEBUG_2, _('Cannot find an update path for dep for: %s'), niceformatneed)
            return self._requiringFromTransaction(requiringPo, requirement, errorlist)
            

        if needmode is None:
            reqpkg = (name, ver, rel, None)
            if self.pkgSack is None:
                return self._requiringFromTransaction(requiringPo, requirement, errorlist)
            else:
                msg = self._err_missing_requires(requiringPo, requirement)
                self.verbose_logger.log(logginglevels.DEBUG_2, msg)
                checkdeps = 0
                missingdep = 1
                errorlist.append(msg)

        return checkdeps, missingdep
        
    def _quickWhatProvides(self, name, flags, version):
        if self._last_req is None:
            return False

        if flags == 0:
            flags = None
        if type(version) in (types.StringType, types.NoneType, types.UnicodeType):
            (r_e, r_v, r_r) = rpmUtils.miscutils.stringToVersion(version)
        elif type(version) in (types.TupleType, types.ListType): # would this ever be a ListType?
            (r_e, r_v, r_r) = version
        
        # Quick lookup, lots of reqs for one pkg:
        po = self._last_req
        if po.checkPrco('provides', (name, flags, (r_e, r_v, r_r))):
            self.verbose_logger.debug(_('Quick matched %s to require for %s'), po, name)
            return True
        return False
        
    def _requiringFromTransaction(self, requiringPo, requirement, errorlist):
        """processes the dependency resolution for a dep where requiring 
           package is in the transaction set"""
        
        (name, arch, epoch, version, release) = requiringPo.pkgtup
        (needname, needflags, needversion) = requirement
        checkdeps = 0
        missingdep = 0
        upgraded = {}

        #~ - if it's not available from some repository:
        #~     - mark as unresolveable.
        #
        #~ - if it's available from some repo:
        #~    - if there is an another version of the package currently installed then
        #        - if the other version is marked in the transaction set
        #           - if it's marked as erase
        #              - mark the dep as unresolveable
         
        #           - if it's marked as update or install
        #              - check if the version for this requirement:
        #                  - if it is higher 
        #                       - mark this version to be updated/installed
        #                       - remove the other version from the transaction set
        #                       - tell the transaction set to be rebuilt
        #                  - if it is lower
        #                       - mark the dep as unresolveable
        #                   - if they are the same
        #                       - be confused but continue

        if self._quickWhatProvides(needname, needflags, needversion):
            return checkdeps, missingdep

        provSack = self.whatProvides(needname, needflags, needversion)
        # get rid of things that are already in the rpmdb - b/c it's pointless to use them here

        for pkg in provSack.returnPackages():
            if self.rpmdb.contains(po=pkg): # is it already installed?
                self.verbose_logger.log(logginglevels.DEBUG_2, _('%s is in providing packages but it is already installed, removing.'), pkg)
                provSack.delPackage(pkg)
                continue

            # we need to check to see, if we have anything similar to it (name-wise)
            # installed or in the ts, and this isn't a package that allows multiple installs
            # then if it's newer, fine - continue on, if not, then we're unresolveable
            # cite it and exit

            tspkgs = []
            if not self.allowedMultipleInstalls(pkg):
                # from ts
                tspkgs = self.tsInfo.matchNaevr(name=pkg.name)
                for tspkg in tspkgs:
                    if not canCoinstall(pkg.arch, tspkg.po.arch): # a comparable arch
                        if tspkg.po.verGT(pkg):
                            msg = _('Potential resolving package %s has newer instance in ts.') % pkg
                            self.verbose_logger.log(logginglevels.DEBUG_2, msg)
                            provSack.delPackage(pkg)
                            continue
                        elif tspkg.po.verLT(pkg):
                            upgraded.setdefault(pkg.pkgtup, []).append(tspkg.pkgtup)
                
                # from rpmdb
                dbpkgs = self.rpmdb.searchNevra(name=pkg.name)
                for dbpkg in dbpkgs:
                    if dbpkg.verGT(pkg) and not canCoinstall(pkg.arch, dbpkg.arch):
                        msg = _('Potential resolving package %s has newer instance installed.') % pkg
                        self.verbose_logger.log(logginglevels.DEBUG_2, msg)
                        provSack.delPackage(pkg)
                        continue

        if len(provSack) == 0: # unresolveable
            missingdep = 1
            msg = self._err_missing_requires(requiringPo, requirement)
            errorlist.append(msg)
            return checkdeps, missingdep
        
        # iterate the provSack briefly, if we find the package is already in the 
        # tsInfo then just skip this run
        for pkg in provSack.returnPackages():
            (n,a,e,v,r) = pkg.pkgtup
            pkgmode = self.tsInfo.getMode(name=n, arch=a, epoch=e, ver=v, rel=r)
            if pkgmode in ['i', 'u']:
                self.verbose_logger.log(logginglevels.DEBUG_2,
                    _('%s already in ts, skipping this one'), pkg)
                self._last_req = pkg
                return checkdeps, missingdep

        # find the best one 

        # try updating the already install pkgs
        results = []
        for pkg in provSack.returnNewestByName():
            tresults = self.update(requiringPo=requiringPo, name=pkg.name,
                                   epoch=pkg.epoch, version=pkg.version,
                                   rel=pkg.rel)
            #  Note that this does "interesting" things with multilib. We can
            # have say A.i686 and A.x86_64, and if we hit "A.i686" first,
            # .update() will actually update "A.x86_64" which will then fail
            # the pkg == txmbr.po test below, but then they'll be nothing to
            # update when we get around to A.x86_64 ... so this entire loop
            # fails.
            #  Keeping results through the loop and thus. testing each pkg
            # against all txmbr's from previous runs "fixes" this.
            results.extend(tresults)
            for txmbr in results:
                if pkg == txmbr.po:
                    checkdeps = True
                    self._last_req = pkg
                    return checkdeps, missingdep

        pkgs = provSack.returnPackages()
        if len(pkgs) == 1: # Minor opt.
            best = pkgs[0]
        else:
            #  Always do compare providers for multiple pkgs, it deals with
            # newest etc. ... so no need to do NewestNameArch() ... and it
            # stops compare_providers from being clever.
            pkgresults = self._compare_providers(pkgs, requiringPo)
            best = pkgresults[0][0]
        
        if self.rpmdb.contains(po=best): # is it already installed?
            missingdep = 1
            checkdeps = 0
            msg = self._err_missing_requires(requiringPo, requirement)
            errorlist.append(msg)
            return checkdeps, missingdep
        
                
        # FIXME - why can't we look up in the transaction set for the requiringPkg
        # and know what needs it that way and provide a more sensible dep structure in the txmbr
        inst = self.rpmdb.searchNevra(name=best.name, arch=best.arch)
        if len(inst) > 0: 
            self.verbose_logger.debug(_('TSINFO: Marking %s as update for %s') %(best,
                requiringPo))
            # FIXME: we should probably handle updating multiple packages...
            txmbr = self.tsInfo.addUpdate(best, inst[0])
            txmbr.setAsDep(po=requiringPo)
            txmbr.reason = "dep"
            checkdeps = True
            self._last_req = best
        else:
            self.verbose_logger.debug(_('TSINFO: Marking %s as install for %s'), best,
                requiringPo)
            reqtuple = misc.string_to_prco_tuple(needname + str(needflags) + needversion)
            txmbrs = self.install(best, provides_for=reqtuple)
            for txmbr in txmbrs:
                txmbr.setAsDep(po=requiringPo)
                txmbr.reason = "dep"
                self._last_req = txmbr.po

                # if we had other packages with this name.arch that we found
                # before, they're not going to be installed anymore, so we
                # should mark them to be re-checked
                if txmbr.pkgtup in upgraded:
                    map(self.tsInfo.remove, upgraded[txmbr.pkgtup])
            if not txmbrs:
                missingdep = 1
                checkdeps = 0
                msg = self._err_missing_requires(requiringPo, requirement)
                errorlist.append(msg)
            else:
                checkdeps = 1
        
        return checkdeps, missingdep

    def _dscb_procConflict(self, po, niceformatneed):
        """ Call the callback for processing requires, call the nicest one
            available. """
        if not self.dsCallback:
            return

        if hasattr(self.dsCallback, 'procConflictPo'):
            self.dsCallback.procConflictPo(po, niceformatneed)
        else:
            self.dsCallback.procConflict(po.name, niceformatneed)

    def _processConflict(self, po, conflict, conflicting_po):
        """processes a Conflict dep from the resolveDeps() method"""

        CheckDeps = True
        errormsgs = []

        needname, flags, needversion = conflict
        (name, arch, epoch, ver, rel) = po.pkgtup

        niceformatneed = rpmUtils.miscutils.formatRequire(needname, needversion, flags)
        self._dscb_procConflict(po, niceformatneed)

        length = len(self.tsInfo)
        if flags & rpm.RPMSENSE_LESS:
            self.update(name=conflicting_po.name)
            txmbrs = self.tsInfo.getMembersWithState(conflicting_po.pkgtup, TS_REMOVE_STATES)
            if len(self.tsInfo) != length and txmbrs:
                return CheckDeps, errormsgs
        elif flags & rpm.RPMSENSE_GREATER:
            self.update(name=name)
            txmbrs = self.tsInfo.getMembersWithState(po.pkgtup, TS_REMOVE_STATES)
            if len(self.tsInfo) != length and txmbrs:
                return CheckDeps, errormsgs

        self.update(name=conflicting_po.name)
        txmbrs = self.tsInfo.getMembersWithState(conflicting_po.pkgtup, TS_REMOVE_STATES)
        if len(self.tsInfo) != length and txmbrs:
            return CheckDeps, errormsgs
        self.update(name=name)
        txmbrs = self.tsInfo.getMembersWithState(po.pkgtup, TS_REMOVE_STATES)
        if len(self.tsInfo) != length and txmbrs:
            return CheckDeps, errormsgs

        msg = '%s conflicts with %s' % (name, str(conflicting_po))
        errormsgs.append(msg)
        self.verbose_logger.log(logginglevels.DEBUG_1, msg)
        CheckDeps = False
        # report the conflicting po, so skip-broken can remove it
        self.po_with_problems.add((po,conflicting_po,errormsgs[-1]))
        return CheckDeps, errormsgs

    def _undoDepInstalls(self):
        # clean up after ourselves in the case of failures
        for txmbr in self.tsInfo:
            if txmbr.isDep:
                self.tsInfo.remove(txmbr.pkgtup)

    def prof_resolveDeps(self):
        fn = "anaconda.prof.0"
        import hotshot, hotshot.stats
        prof = hotshot.Profile(fn)
        rc = prof.runcall(self.resolveDeps)
        prof.close()
        print "done running depcheck"
        stats = hotshot.stats.load(fn)
        stats.strip_dirs()
        stats.sort_stats('time', 'calls')
        stats.print_stats(20)
        return rc

    def cprof_resolveDeps(self):
        import cProfile, pstats
        prof = cProfile.Profile()
        rc = prof.runcall(self.resolveDeps)
        prof.dump_stats("yumprof")
        print "done running depcheck"

        p = pstats.Stats('yumprof')
        p.strip_dirs()
        p.sort_stats('time')
        p.print_stats(20)
        return rc

    def resolveDeps(self, full_check=True, skipping_broken=False):

        if not len(self.tsInfo):
            return (0, [_('Success - empty transaction')])

        self.po_with_problems = set()
        self._working_po = None
        self._last_req = None
        self.tsInfo.resetResolved(hard=False)

        CheckDeps = True
        CheckRemoves = full_check
        CheckInstalls = full_check

        missingdep = 0
        errors = []

        if self.dsCallback: self.dsCallback.start()

        while True:

            CheckDeps = True

            # check Requires
            while CheckDeps:
                self.cheaterlookup = {}
                if self.dsCallback: self.dsCallback.tscheck()
                CheckDeps, checkinstalls, checkremoves, missing = self._resolveRequires(errors)
                CheckInstalls |= checkinstalls
                CheckRemoves |= checkremoves


            # check global FileRequires
            self._working_po = None # reset the working po
            if CheckRemoves:
                CheckRemoves = False
                for po, dep in self._checkFileRequires():
                    (checkdep, missing, errormsgs) = self._processReq(po, dep)
                    CheckDeps |= checkdep
                    errors += errormsgs

                if CheckDeps:
                    if self.dsCallback: self.dsCallback.restartLoop()
                    self.verbose_logger.log(logginglevels.DEBUG_1, _('Restarting Loop'))
                    continue

            # check Conflicts
            self._working_po = None # reset the working po
            if CheckInstalls:
                CheckInstalls = False
                for conflict in self._checkConflicts():
                    (checkdep, errormsgs) = self._processConflict(*conflict)
                    CheckDeps |= checkdep
                    errors += errormsgs
                    if checkdep:
                        break # The next conflict might be the same pkg

                if CheckDeps:
                    if self.dsCallback: self.dsCallback.restartLoop()
                    self.verbose_logger.log(logginglevels.DEBUG_1, _('Restarting Loop'))
                    continue

            break

        # FIXME: this doesn't belong here at all...
        for txmbr in self.tsInfo.getMembers():
            if self.allowedMultipleInstalls(txmbr.po) and \
                   txmbr.ts_state == 'u':
                self.verbose_logger.log(logginglevels.DEBUG_2,
                                        _('%s converted to install'),
                                        txmbr.po)
                txmbr.ts_state = 'i'
                txmbr.output_state = TS_INSTALL

        if self.dsCallback:
            if not self.conf.skip_broken:
                self.dsCallback.end()
            elif not skipping_broken and not errors:
                self.dsCallback.end()
        self.verbose_logger.log(logginglevels.DEBUG_1, _('Dependency Process ending'))

        self.tsInfo.changed = False
        if len(errors) > 0:
            errors = unique(errors)
            #  We immediately display this in cli, so don't show it twice.
            # Plus skip-broken can get here N times. Might be worth keeping
            # around for debugging?
            done = set() # Same as the unique above
            for po,wpo,err in self.po_with_problems:
                if (po,err) in done:
                    continue
                done.add((po, err))
                self.verbose_logger.log(logginglevels.DEBUG_4,
                    "SKIPBROKEN: %s from %s has depsolving problems" % (po, po.repoid))
                err = err.replace('\n', '\n  --> ')
                self.verbose_logger.log(logginglevels.DEBUG_4,"SKIPBROKEN:  --> %s" % err)
            return (1, errors)

        if not len(self.tsInfo):
            return (0, [_('Success - empty transaction')])
        
        return (2, [_('Success - deps resolved')])

    def _resolveRequires(self, errors):
        any_missing = False
        CheckDeps = False
        CheckInstalls = False
        CheckRemoves = False
        # we need to check the opposite of install and remove for regular
        # tsInfo members vs removed members
        for txmbr in self.tsInfo.getUnresolvedMembers():

            if self.dsCallback and txmbr.ts_state:
                dscb_ts_state = txmbr.ts_state
                if txmbr.downgrades:
                    dscb_ts_state = 'd'
                if dscb_ts_state == 'u' and txmbr.reinstall:
                    dscb_ts_state = 'r'
                if dscb_ts_state == 'u':
                    if txmbr.output_state == TS_OBSOLETING:
                        dscb_ts_state = 'o'
                    elif not txmbr.updates:
                        dscb_ts_state = 'i'
                self.dsCallback.pkgAdded(txmbr.pkgtup, dscb_ts_state)
            self.verbose_logger.log(logginglevels.DEBUG_2,
                                    _("Checking deps for %s") %(txmbr,))

            # store the primary po we currently are working on 
            # so we can store it in self.po_with_problems.
            # it is useful when an update is breaking an require of an installed package
            # then we want to know who is causing the problem, not just who is having the problem. 
            if not txmbr.updates and txmbr.relatedto:
                self._working_po = txmbr.relatedto[0][0]
            else:
                self._working_po = txmbr.po
           
            if (txmbr.output_state in TS_INSTALL_STATES) == (txmbr.po.state != None):
                thisneeds = self._checkInstall(txmbr)
                CheckInstalls = True
            else:
                thisneeds = self._checkRemove(txmbr)
                CheckRemoves = True

            missing_in_pkg = False
            for po, dep in thisneeds:
                if txmbr.downgraded_by: # Don't try to chain remove downgrades
                    msg = self._err_missing_requires(po, dep)
                    self.verbose_logger.log(logginglevels.DEBUG_2, msg)
                    errors.append(msg)
                    self.po_with_problems.add((po,self._working_po,errors[-1]))
                    missing_in_pkg = 1
                    continue

                (checkdep, missing, errormsgs) = self._processReq(po, dep)
                CheckDeps |= checkdep
                errors += errormsgs
                missing_in_pkg |= missing

            if not missing_in_pkg:
                self.tsInfo.markAsResolved(txmbr)

            any_missing |= missing_in_pkg

        return CheckDeps, CheckInstalls, CheckRemoves, any_missing

    @staticmethod
    def _sort_req_key(pkgtup):
        """ Get a sort key for a package requires from most "narrow" to least,
            this tries to ensure that if we have two reqs like
            "libfoo = 1.2.3-4" and "foo-api" (which is also provided by
            libxyz-foo) that we'll get just libfoo.
            There are other similar cases this "handles"."""

        mapper = {'EQ' : 1, 'LT' : 2, 'LE' : 3, 'GT' : 4, 'GE' : 5, None : 99}
        flagscore = mapper.get(pkgtup[1], 10)

        # This is pretty magic, basically we want an explicit:
        #
        #  Requires: foo
        #
        # ...to happen before the implicit:
        #
        #  Requires: libfoo.so.0()
        #
        # ...because sometimes the libfoo.so.0() is provided by multiple
        # packages. Do we need more magic for other implicit deps. here?

        namescore = 0
        if pkgtup[0].startswith("lib") and \
                (pkgtup[0].endswith("()") or pkgtup[0].endswith("()(64bit)")):
            namescore = 99 # Processes these last

        return (flagscore, namescore)

    def _checkInstall(self, txmbr):
        txmbr_reqs = txmbr.po.returnPrco('requires')

        # if this is an update, we should check what the old
        # requires were to make things faster
        oldreqs = []
        for oldpo in txmbr.updates:
            oldreqs.extend(oldpo.returnPrco('requires'))
        oldreqs = set(oldreqs)

        ret = []
        for req in sorted(txmbr_reqs, key=self._sort_req_key):
            if req[0].startswith('rpmlib('):
                continue
            if req in oldreqs:
                continue
            
            self.verbose_logger.log(logginglevels.DEBUG_2, _("looking for %s as a requirement of %s"), req, txmbr)
            provs = self.tsInfo.getProvides(*req)
            #  The self provides should mostly be caught before here now, but
            # at least config() crack still turns up, it's not that
            # expensive to just do it, and we really don't want "false positive"
            # requires for compare_providers().
            if not provs and not txmbr.po.inPrcoRange('provides', req):
                ret.append( (txmbr.po, self._prco_req2req(req)) )
                continue

            #Add relationship
            for po in provs:
                if txmbr.name == po.name:
                    continue
                for member in self.tsInfo.getMembersWithState(
                    pkgtup=po.pkgtup, output_states=TS_INSTALL_STATES):
                    member.relatedto.append((txmbr.po, 'dependson'))

        return ret

    def _checkRemove(self, txmbr):
        po = txmbr.po
        provs = po.returnPrco('provides')

        # if this is an update, we should check what the new package
        # provides to make things faster
        newpoprovs = {}
        for newpo in txmbr.updated_by + txmbr.obsoleted_by:
            for p in newpo.provides:
                newpoprovs[p] = 1
        ret = []
        
        # iterate over the provides of the package being removed
        # and see what's actually going away
        for prov in provs:
            if prov[0].startswith('rpmlib('): # ignore rpmlib() provides
                continue
            if prov in newpoprovs:
                continue
            # FIXME: This is probably the best place to fix the postfix rename
            # problem long term (post .21) ... see compare_providers.
            for pkg, hits in self.tsInfo.getRequires(*prov).iteritems():
                # See the docs, this is to make groupremove "more useful".
                if (self.conf.groupremove_leaf_only and txmbr.groups and
                    txmbr.output_state == TS_ERASE):
                    cb = self.dsCallback
                    if cb and hasattr(cb, 'groupRemoveReq'):
                        cb.groupRemoveReq(pkg, hits)
                    #  We don't undo anything else here ... hopefully that's
                    # fine.
                    self.tsInfo.remove(txmbr.pkgtup)
                    return []

                for hit in hits:
                    # See if the update solves the problem...
                    found = False
                    for newpo in txmbr.updated_by:
                        if newpo.checkPrco('provides', hit):
                            found = True
                            break
                    if found: continue
                    for newpo in txmbr.obsoleted_by:
                        if newpo.checkPrco('provides', hit):
                            found = True
                            break
                    if found: continue

                    # It doesn't, so see what else might...
                    rn, rf, rv = hit
                    if not self.tsInfo.getProvides(rn, rf, rv):
                        ret.append( (pkg, self._prco_req_nfv2req(rn, rf, rv)) )
        return ret

    def _checkFileRequires(self):
        fileRequires = set()
        nfileRequires = set() # These need to be looked up in the rpmdb.
        reverselookup = {}
        ret = []

        # generate list of file requirement in rpmdb
        if self.installedFileRequires is None:
            self.installedFileRequires, \
              self.installedUnresolvedFileRequires, \
              self.installedFileProviders = self.rpmdb.fileRequiresData()

        # get file requirements from packages not deleted
        todel = []
        for pkgtup, files in self.installedFileRequires.iteritems():
            if self._tsInfo.getMembersWithState(pkgtup, output_states=TS_REMOVE_STATES):
                todel.append(pkgtup)
            else:
                fileRequires.update(files)
                for filename in files:
                    reverselookup.setdefault(filename, []).append(pkgtup)
        for pkgtup in todel:
            del self.installedFileRequires[pkgtup]

        fileRequires -= self.installedUnresolvedFileRequires

        # get file requirements from new packages
        for txmbr in self._tsInfo.getMembersWithState(output_states=TS_INSTALL_STATES):
            for name, flag, evr in txmbr.po.requires:
                if name.startswith('/'):
                    pt = txmbr.po.pkgtup
                    self.installedFileRequires.setdefault(pt, []).append(name)
                    # check if file requires was already unresolved in update
                    if name in self.installedUnresolvedFileRequires:
                        already_broken = False
                        for oldpo in txmbr.updates:
                            if oldpo.checkPrco('requires', (name, None, (None, None, None))):
                                already_broken = True
                                break
                        if already_broken:
                            continue
                    if name not in fileRequires:
                        nfileRequires.add(name)
                    fileRequires.add(name)
                    reverselookup.setdefault(name, []).append(txmbr.po.pkgtup)

        todel = []
        for fname in self.installedFileProviders:
            niFP_fname = []
            for pkgtup in self.installedFileProviders[fname]:
                if self._tsInfo.getMembersWithState(pkgtup, output_states=TS_REMOVE_STATES):
                    continue
                niFP_fname.append(pkgtup)

            if not niFP_fname:
                todel.append(fname)
                continue

            self.installedFileProviders[fname] = niFP_fname
        for fname in todel:
            del self.installedFileProviders[fname]

        # check the file requires
        iFP = self.installedFileProviders
        for filename in fileRequires:
            # In theory we need this to be:
            #
            # nprov, filename in iFP (or new), oprov
            #
            # ...this keeps the cache exactly the same as the non-cached data.
            # However that also means that we'll always need the filelists, so
            # we do:
            #
            # filename in iFP (if found return), oprov (if found return),
            # nprov
            #
            # ...this means we'll always get the same _result_ (as we only need
            # to know if _something_ provides), but our cache will be off on
            # what does/doesn't provide the file.
            if filename in self.installedFileProviders:
                continue

            oprov = self.tsInfo.getOldProvides(filename)
            if oprov:
                iFP.setdefault(filename, []).extend([po.pkgtup for po in oprov])
                continue

            nprov = self.tsInfo.getNewProvides(filename)
            if nprov:
                iFP.setdefault(filename, []).extend([po.pkgtup for po in nprov])
                continue 

            for pkgtup in reverselookup[filename]:
                po = self.tsInfo.getMembersWithState(pkgtup, TS_INSTALL_STATES)
                if po:
                    po = po[0].po # Should only have one
                else:
                    po = self.getInstalledPackageObject(pkgtup)
                ret.append( (po, (filename, 0, '')) )

        self.rpmdb.transactionCacheFileRequires(self.installedFileRequires, 
                                        self.installedUnresolvedFileRequires,
                                        self.installedFileProviders,
                                        ret)

        return ret

    def _checkConflicts(self):
        ret = [ ]
        cpkgs = []
        for po in self.rpmdb.returnConflictPackages():
            if self.tsInfo.getMembersWithState(po.pkgtup, output_states=TS_REMOVE_STATES):
                continue
            conflicts = po.returnPrco('conflicts')
            if not conflicts: # We broke this due to dbMatch() usage.
                continue
            cpkgs.append(po)
            for conflict in conflicts:
                (r, f, v) = conflict
                for conflicting_po in self.tsInfo.getNewProvides(r, f, v):
                    if conflicting_po.pkgtup[0] == po.pkgtup[0] and conflicting_po.pkgtup[2:] == po.pkgtup[2:]:
                        continue
                    ret.append( (po, self._prco_req_nfv2req(r, f, v),
                                 conflicting_po) )
        for txmbr in self.tsInfo.getMembersWithState(output_states=TS_INSTALL_STATES):
            po = txmbr.po
            done = False
            for conflict in txmbr.po.returnPrco('conflicts'):
                if not done:
                    cpkgs.append(txmbr.po)
                    done = True
                (r, f, v) = conflict
                for conflicting_po in self.tsInfo.getProvides(r, f, v):
                    if conflicting_po.pkgtup[0] == po.pkgtup[0] and conflicting_po.pkgtup[2:] == po.pkgtup[2:]:
                        continue
                    ret.append( (po, self._prco_req_nfv2req(r, f, v),
                                 conflicting_po) )

        if _rpm_ver_atleast((4, 9, 0)):
            return ret # Don't need the conflicts cache anymore

        self.rpmdb.transactionCacheConflictPackages(cpkgs)
        return ret

    def isPackageInstalled(self, pkgname):
        lst = self.tsInfo.matchNaevr(name = pkgname)
        for txmbr in lst:
            if txmbr.output_state in TS_INSTALL_STATES:
                return True

        if len(lst) > 0:
            # if we get here then it's in the tsInfo for an erase or obsoleted
            #  --> not going to be installed
            return False

        if not self.rpmdb.contains(name=pkgname):
            return False

        return True
    _isPackageInstalled = isPackageInstalled

    def _compare_providers(self, pkgs, reqpo):
        """take the list of pkgs and score them based on the requesting package
           return a dictionary of po=score"""
        self.verbose_logger.log(logginglevels.DEBUG_4,
              _("Running compare_providers() for %s") %(str(pkgs)))
        
        def _common_prefix_len(x, y, minlen=2):
            num = min(len(x), len(y))
            for off in range(num):
                if x[off] != y[off]:
                    return max(off, minlen)
            return max(num, minlen)

        def _common_sourcerpm(x, y):
            if not hasattr(x, 'sourcerpm'):
                return False
            if not hasattr(y, 'sourcerpm'):
                return False
            return x.sourcerpm == y.sourcerpm

        def _compare_arch_distance(x, y, req_compare_arch):
            # take X and Y package objects
            # determine which has a closer archdistance to compare_arch
            # if they are equal to compare_arch, compare which is closer to the 
            # running arch
            # return the package which is closer or None for equal, or equally useless
            
            x_dist = archDifference(req_compare_arch, x.arch)
            if self.arch.multilib: # only go to the next one if we're multilib - 
                if x_dist == 0: # can't really use best's arch anyway...
                    self.verbose_logger.log(logginglevels.DEBUG_4,
                        _("better arch in po %s") %(y))
                    return y # just try the next one - can't be much worse

            y_dist = archDifference(req_compare_arch, y.arch)
            if y_dist > 0 and x_dist > y_dist:
                self.verbose_logger.log(logginglevels.DEBUG_4,
                    _("better arch in po %s") %(y))

                return y
            if y_dist == x_dist:
                return None
            return x

        #  Actual start of _compare_providers().

        # Do a NameArch filtering, based on repo. __cmp__
        unique_nevra_pkgs = {}
        for pkg in pkgs:
            if (pkg.pkgtup in unique_nevra_pkgs and
                unique_nevra_pkgs[pkg.pkgtup].repo <= pkg.repo):
                continue
            unique_nevra_pkgs[pkg.pkgtup] = pkg
        pkgs = unique_nevra_pkgs.values()
            
        pkgresults = {}

        for pkg in pkgs:
            pkgresults[pkg] = 0
        
        # hand this off to our plugins
        self.plugins.run("compare_providers", providers_dict=pkgresults, 
                                      reqpo=reqpo)
        
        for pkg in pkgresults.keys():
            rpmdbpkgs = self.rpmdb.searchNevra(name=pkg.name)
            if rpmdbpkgs:
                #  We only want to count things as "installed" if they are
                # older than what we are comparing, because this then an update
                # so we give preference. If they are newer then obsoletes/etc.
                # could play a part ... this probably needs a better fix.
                newest = sorted(rpmdbpkgs)[-1]
                if newest.verLT(pkg):
                    # give pkgs which are updates just a SLIGHT edge
                    # we should also make sure that any pkg
                    # we are giving an edge to is not obsoleted by
                    # something else in the transaction. :(
                    # there are many ways I hate this - this is but one
                    pkgresults[pkg] += 5
                elif newest.verEQ(pkg):
                    #  We get here from bestPackagesFromList(), give a giant
                    # bump to stuff that is already installed.
                    pkgresults[pkg] += 1000
                elif newest.verGT(pkg):
                    # if the version we're looking at is older than what we have installed
                    # score it down like we would an obsoleted pkg
                    pkgresults[pkg] -= 1024
            else:
                # just b/c they're not installed pkgs doesn't mean they should
                # be ignored entirely. Just not preferred
                pass

        pkgs = pkgresults.keys()
            
        # go through each pkg and compare to others
        # if it is same skip it
        # if the pkg is obsoleted by any other of the packages
        # then add  -1024 to its score
        # don't need to look for mutual obsoletes b/c each package
        # is evaluated against all the others, so mutually obsoleting
        # packages will have their scores diminished equally
        
        # compare the arch vs each other pkg
        #   give each time it returns with a better arch a +5

        # look for common source vs the reqpo - give a +10 if it has it

        # look for common_prefix_len - add the length*2 to the score
        
        # add the negative of the length of the name to the score
        
        
        lpos = {}
        for po in pkgs:
            for nextpo in pkgs:
                if po == nextpo:
                    continue

                #  If this package isn't the latest version of said package,
                # treat it like it's obsoleted. The problem here is X-1
                # accidentally provides FOO, so you release X-2 without the
                # provide, but X-1 is still picked over a real provider.
                if po.name not in lpos:
                    lpos[po.name] = self.pkgSack.returnNewestByName(po.name)[:1]
                if not lpos[po.name] or not po.verEQ(lpos[po.name][0]):
                    pkgresults[po] -= 1024

                obsoleted = False
                if po.obsoletedBy([nextpo]):
                    obsoleted = True
                    pkgresults[po] -= 1024
                                
                    self.verbose_logger.log(logginglevels.DEBUG_4,
                        _("%s obsoletes %s") % (nextpo, po))

                if reqpo:
                    arches = (reqpo.arch, self.arch.bestarch)
                else:
                    arches = (self.arch.bestarch,)
                
                for thisarch in arches:
                    res = _compare_arch_distance(po, nextpo, thisarch)
                    if not res:
                        continue
                    self.verbose_logger.log(logginglevels.DEBUG_4,                   
                       _('archdist compared %s to %s on %s\n  Winner: %s' % (po, nextpo, thisarch, res)))

                    if res == po:
                        pkgresults[po] += 5

            # End of O(N*N): for nextpo in pkgs:
            if _common_sourcerpm(po, reqpo):
                self.verbose_logger.log(logginglevels.DEBUG_4,
                    _('common sourcerpm %s and %s' % (po, reqpo)))
                pkgresults[po] += 20
            if self.isPackageInstalled(po.base_package_name):
                self.verbose_logger.log(logginglevels.DEBUG_4,
                    _('base package %s is installed for %s' % (po.base_package_name, po)))
                pkgresults[po] += 5 # Same as before - - but off of base package name
            if reqpo:
                cpl = _common_prefix_len(po.name, reqpo.name)
                if cpl > 2:
                    self.verbose_logger.log(logginglevels.DEBUG_4,
                        _('common prefix of %s between %s and %s' % (cpl, po, reqpo)))
                
                    pkgresults[po] += cpl*2
                
        #  If we have more than one "best", see what would happen if we picked
        # each package ... ie. what things do they require that _aren't_ already
        # installed/to-be-installed. In theory this can screw up due to:
        #   pkgA => requires pkgX
        #   pkgB => requires pkgY, requires pkgZ
        # ...but pkgX requires 666 other things. Going recursive is
        # "non-trivial" though, python != prolog. This seems to do "better"
        # from simple testing though.
        bestnum = max(pkgresults.values())
        rec_depsolve = {}
        for po in pkgs:
            if pkgresults[po] != bestnum:
                continue
            rec_depsolve[po] = 0
        if len(rec_depsolve) > 1:
            for po in rec_depsolve:
                fake_txmbr = TransactionMember(po)

                #  Note that this is just requirements, so you could also have
                # 4 requires for a single package. This might be fixable, if
                # needed, but given the above it's probably better to leave it
                # like this.
                reqs = self._checkInstall(fake_txmbr)
                rec_depsolve[po] = len(reqs)

            bestnum = min(rec_depsolve.values())
            self.verbose_logger.log(logginglevels.DEBUG_4,
                                    _('requires minimal: %d') % bestnum)
            for po in rec_depsolve:
                if rec_depsolve[po] == bestnum:
                    self.verbose_logger.log(logginglevels.DEBUG_4,
                            _(' Winner: %s') % po)
                    pkgresults[po] += 1
                else:
                    num = rec_depsolve[po]
                    self.verbose_logger.log(logginglevels.DEBUG_4,
                            _(' Loser(with %d): %s') % (num, po))

        #  We don't want to decide to use a "shortest first", if something else
        # has told us to pick something else. But we want to pick between
        # multiple "best" packages. So we spike all the best packages (so
        # only those can win) and then bump them down by package name length.
        bestnum = max(pkgresults.values())
        for po in pkgs:
            if pkgresults[po] != bestnum:
                continue
            pkgresults[po] += 1000
            pkgresults[po] += (len(po.name)*-1)

        bestorder = sorted(pkgresults.items(),
                           key=lambda x: (x[1], x[0]), reverse=True)
        self.verbose_logger.log(logginglevels.DEBUG_4,
                _('Best Order: %s' % str(bestorder)))

        return bestorder
                                    
       


class DepCheck(object):
    """object that YumDepsolver uses to see what things are needed to close
       the transaction set. attributes: requires, conflicts are a list of 
       requires are conflicts in the current transaction set. Each item in the
       lists are a requires or conflicts object"""
    def __init__(self):
        self.requires = []
        self.conflicts = []

    def addRequires(self, po, req_tuple_list):
        # fixme - do checking for duplicates or additions in here to zip things along
        reqobj = Requires(po, req_tuple_list)
        self.requires.append(reqobj)
    
    def addConflicts(self, conflict_po_list, conflict_item):
        confobj = Conflicts(conflict_po_list, conflict_item)
        self.conflicts.append(confobj)

class Requires(object):

    """
    A pure data class for holding a package and the list of things it
    requires.
    """

    def __init__(self, pkg,requires):
        self.pkg = pkg # po of requiring pkg
        self.requires = requires # list of things it requires that are un-closed in the ts


class Conflicts(object):

    """
    A pure data class for holding a package and the list of things it
    conflicts.
    """

    def __init__(self, pkglist, conflict):
        self.pkglist = pkglist # list of conflicting package objects
        self.conflict = conflict # what the conflict was between them
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/lib/python2.7/dist-packages/yum/depsolve.pyc                                                    0100644 0000000 0000000 00000107503 13077704344 020302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l m	 Z	 m
 Z
 d d l Z d d l m Z m Z d d l m Z d d l Z d d l m Z d d l Td d l Z d d l Z d d l Z d d l Z e j d e j  d d	 l m Z m Z y e d
 d  d k s't  Wn d   Z d   Z n Xi e j  d 6e j! e j  Bd 6e j" d 6e j" e j! Bd 6e j! d 6d e# 6Z$ d e% f d     YZ& d e% f d     YZ' d e% f d     YZ( d e% f d     YZ) d S(   s'   
Dependency resolution module for yum.
iN(   t   archDifferencet   canCoinstall(   t   uniquet   version_tuple_to_string(   t   TransactionMember(   t   ListPackageSack(   t   *t   ignore(   t   _t   _rpm_ver_atleasti   i   c         G   s*   x# | D] } |  | k r | }  q q W|  S(   N(    (   t   xt   argst   y(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   min/   s     c         G   s*   x# | D] } |  | k  r | }  q q W|  S(   N(    (   R
   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   max3   s     t   GTt   GEt   LTt   LEt   EQi    t   Depsolvec           B   s[  e  Z d  Z d   Z d   Z e d  Z e d  Z d   Z d   Z	 d   Z
 d   Z d	   Z d
   Z d d d  Z d   Z d   Z e d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z e e d  Z d   Z e d    Z  d   Z! d   Z" d    Z# d!   Z$ d"   Z% e% Z& d#   Z' RS($   s%   
    Dependency resolving class.
    c         C   sp   d  |  _ d  |  _ d  |  _ t |  _ t j d  |  _ t j d  |  _	 g  |  _
 g  |  _ d  |  _ d  |  _ d  S(   Ns   yum.Depsolves   yum.verbose.Depsolve(   t   Nonet   _tst   _tsInfot
   dsCallbackt   Falset   use_txmbr_in_callbackt   loggingt	   getLoggert   loggert   verbose_loggert   patht   loopst   installedFileRequirest   installedUnresolvedFileRequires(   t   self(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   __init__D   s    							c         C   s)   t  j t d  t j d d |  j   S(   Ns5   doTsSetup() will go away in a future version of Yum.
t
   stackleveli   (   t   warningst   warnR   t   Errorst   YumFutureDeprecationWarningt   _getTs(   R#   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt	   doTsSetupS   s    c         C   s   |  j  d k rW |  j d k rW | rS |  j  j d k rS |  j  j |  j |  j  n  d S|  j j sx t j	 t
 d   n  |  j |  |  j   d S(   s   setup all the transaction set storage items we'll need
           This can't happen in __init__ b/c we don't know our installroot
           yetNs4   Setting up TransactionSets before config class is up(   R   R   R   t   pkgSackt   setDatabasest   rpmdbt   conft   installrootR(   t   YumBaseErrorR   t
   _getTsInfot   initActionTs(   R#   t   remove_only(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR*   X   s    c         C   s   |  j  d k r |  j   |  _  | r- d } n	 |  j } |  j  j |  j |  |  j j |  j  _ |  j |  j  _	 |  j
 |  j  _ |  j |  j  _ n  |  j  S(   s    remove_only param. says if we are going to do _only_ remove(s) in
            the transaction. If so we don't need to setup the remote repos. N(   R   R   t   _transactionDataFactoryR,   R-   R.   R/   t   installonlypkgst   installt   install_methodt   updatet   update_methodt   removet   remove_method(   R#   R4   R,   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR2   h   s    		c         C   s   | |  _  d  S(   N(   R   (   R#   t   value(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt
   _setTsInfoy   s    c         C   s   d  |  _ d  S(   N(   R   R   (   R#   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt
   _delTsInfo|   s    c         C   s   |  j  s |  j   n  |  j  S(   N(   R   R3   (   R#   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _getActionTs   s    	c         C   s  t  j j |  j j  |  _ i t j d 6t j d 6t j	 d 6t j
 d 6t j d 6t j d 6} t t d  r| t j | d <n  |  j j d	  xP |  j j D]B } | | k r |  j j | |  q |  j j t d
  |  q Wd	 } x |  j j D] } | | O} q W|  j j |  d S(   s)   sets up the ts we'll use for all the workt	   noscriptst
   notriggerst   nodocst   testt   justdbt	   repackaget   RPMTRANS_FLAG_NOCONTEXTSt
   nocontextsi    s!   Invalid tsflag in config file: %sN(   t   rpmUtilst   transactiont   TransactionWrapperR/   R0   R   t   rpmt   RPMTRANS_FLAG_NOSCRIPTSt   RPMTRANS_FLAG_NOTRIGGERSt   RPMTRANS_FLAG_NODOCSt   RPMTRANS_FLAG_TESTt   RPMTRANS_FLAG_JUSTDBt   RPMTRANS_FLAG_REPACKAGEt   hasattrRG   t   setFlagst   tsflagst	   addTsFlagR   t   criticalR   t   tsInfot   probFilterFlagst   setProbFilter(   R#   t   ts_flags_to_rpmt   flagt
   probfilter(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR3      s$    



c         C   sD   |  j  j t j t d  |  t |  j j | | | f   } | S(   s   searches the packageSacks for what provides the arguments
           returns a ListPackageSack of providing packages, possibly emptys   Searching pkgSack for dep: %s(   R   t   logt   logginglevelst   DEBUG_1R   R   R,   t   searchProvides(   R#   t   namet   flagst   versiont   defSack(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   whatProvides   s    !c         C   sM   t  |  j j  } | j | k r% t Sx! | j D] } | | k r/ t Sq/ Wt S(   s   takes a packageObject, returns 1 or 0 depending on if the package 
           should/can be installed multiple times with different vers
           like kernels and kernel modules, for example(   t   setR/   R6   Rb   t   Truet   provides_namesR   (   R#   t   pot   iopkgst   prov(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   allowedMultipleInstalls   s    i    i   c         C   sG  |  j  r |  j  j   n  i  } |  j j d k r> |  j   n  | r x |  j D] } | j   } | d k ru d } n  | j   | j   | | j   | j	   f } | j
   d k r d } n | j
   d k r d } n  d | | | f <qN Wn  xQ|  j j   D]@} |  j j t j t d  |  | j d k r| j d f | k rNq n  | j j   }	 t j j |	  r| j j   }
 n |  j | j  | j j   }
 | j d k r|  j | j  r|  j j t j t d  | j  d | _ t | _ qn  |  j  r| } n |
 |	 f } |  j j! |
 | | j  |  j j t j" t d	  | j | j  |  j  r?| j } | d k r| j# rd
 } n  |  j  j$ | j |  q?q | j d k r | j | j f | k rq n  |  j j% | j j&  |  j  r| j' rq n  |  j  j$ | j d  n  |  j j t j" t d  | j  q q Wd S(   s7   take transactionData class and populate transaction sett   0i   t   ii   t   es
   Member: %st   us   %s converted to installs   Adding Package %s in mode %st   ds   Removing Package %sN(   Rq   Ro   (   Rp   ((   R   t   transactionPopulationt   tsR   R3   t   Et   Nt   At   Vt   Rt   TypeRX   t
   getMembersR   R^   R_   t   DEBUG_3R   t   ts_statet   pkgtupRj   t   localPkgt   osR   t   existst   returnHeaderFromPackaget   downloadHeadert   returnLocalHeaderRm   t   DEBUG_2t
   TS_INSTALLt   output_stateR   t
   addInstallR`   t
   downgradest   pkgAddedt   addEraset   idxt   downgraded_by(   R#   RD   t   keepoldt   ts_elemt   tet   epocht   pkginfot   modet   txmbrt   rpmfilet   hdrt   cbkeyt   dscb_ts_state(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt
   populateTs   sj    	 	-										c         C   sO   |  j  s d St |  j  d  r5 |  j  j | |  n |  j  j | j |  d S(   sW    Call the callback for processing requires, call the nicest one
            available. Nt	   procReqPo(   R   RS   R   t   procReqRb   (   R#   Rj   t   niceformatneed(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _dscb_procReq   s
    	c         C   s+  g  } | \ } } } t  j j | | |  } |  j j t j t d  | |  |  j | |  yx | j	 j
 d k r |  j | | |  \ } }	 n |  j | | |  \ } }	 |	 r |  j j | |  j | d f  n  WnD t j k
 r}
 |  j j | |  j t |
  f  d } d }	 n X| |	 | f S(   s   processes a Requires dep from the resolveDeps functions, returns a tuple
           of (CheckDeps, missingdep, conflicts, errors) the last item is an array
           of error messagess   %s requires: %st	   installedii   i    (   RI   t	   miscutilst   formatRequireR   R^   R_   R`   R   R   t   repot   idt   _requiringFromTransactiont   _requiringFromInstalledt   po_with_problemst   addt   _working_poR(   t   DepErrort   str(   R#   Rj   t   requirementt	   errormsgst   neednameRc   t   needversionR   t	   CheckDepst
   missingdepRp   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _processReq  s     "'"
c         C   s   |  t  | t |  f S(   N(   Rc   R   (   t   rnt   rft   rv(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _prco_req_nfv2req)  s    c         C   s   |  j  | d | d | d  S(   Ni    i   i   (   R   (   R#   t   req(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _prco_req2req-  s    c         C   s   t  |  j d  rI |  j j | |  } | d  k	 rI |  j j | |  Sn  | \ } } } t j j | | |  } t d  | | f S(   Nt   format_missing_requiress   %s requires %s(   RS   R   R   R   RI   R   R   R   (   R#   t   reqPot   reqTupt   msgR   t	   needflagsR   t   ui_req(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _err_missing_requires0  s    	c   "      C   s  d } d } |  j  j | j t  r. | | f S| j \ } } } }	 }
 | \ } } } t j j | | |  } d } d } g  } | | | f |  j k r |  j	 j
 t j t d   |  j | | | f } | g } n |  j j d |  r#|  j  j d |  } xX | D] } | j | j  qWn7 |  j	 j
 t j t d  |  |  j j | | |  } x| D]} | |  _ d | j } | j \ } } } } } |  j	 j
 t j t d  |  |  j  j d | d | d | d	 | d
 |  } | d k r| |  j j k r|  j  j d | d |  } n  | d k rS| |  j j k rS|  j  j d |  } n  | d k rt d   |  j  j | | | | |   rd } qn  | d k	 ra| } | |  j | | | f <|  j	 j
 t j t d  | | |  PqaqaW|  j	 j
 t j t d  | |  | d  k r|  j	 j
 t j t d  |  |  j j } d |  j _ |  j d | d |  } | |  j _ | s|  j d | d |  } | s|  j | |  } |  j	 j
 t j t d  |  |  j | | |  Sn  d } n  | d! k r}|  j	 j
 t j t d  |  |  j d | d |  } | st|  j | |  } |  j	 j
 t j t d  |  |  j | | |  Sd } n  | d" k r|  j	 j
 t j t d  | |  |  j d |  } x | D] } | j d |  qWd } n  | d# k r?|  j d | d | d |	 d |
 d |  } |  j  j | j t  } | r| r| d j t  k r|  j	 j
 t j t d  | | d j! d  ny |  j	 j
 t j t d  |  xW | d j" D]H }  | t# |  j$ |  j% d   k rt& | |  j |  | |  d f SqWt& } | | f S|  j	 j
 t j t d  |  |  j | | |  S| d k r| |	 |
 d f }! |  j' d k r|  j | | |  S|  j | |  } |  j	 j
 t j |  d } d } | j |  n  | | f S($   sb   processes the dependency resolution for a dep where the requiring 
           package is installedi    s3   Needed Require has already been looked up, cheatingRb   s4   Needed Require is not a package name. Looking up: %ss   %s.%s %s:%s-%ss   Potential Provider: %st   archR   t   vert   relc         S   s   |  j  S(   N(   t   obsoleted_by(   R
   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   <lambda>t  s    Rq   s!   Mode is %s for provider of %s: %ss   Mode for pkg providing %s: %st   uds"   Trying to update %s to resolve depRj   t   requiringPos&   No update paths found for %s. Failure!i   t   odRp   s/   TSINFO: %s package requiring %s marked as eraseRo   Rd   t   releases-   TSINFO: Obsoleting %s with %s to resolve dep.s#   TSINFO: Updating %s to resolve dep.t   requiress*   Cannot find an update path for dep for: %sN(   R   (   R   (   Rp   (   Ro   Rq   ((   RX   t   getMembersWithStateR~   t   TS_REMOVE_STATESRI   R   R   R   t   cheaterlookupR   R^   R_   R   R   R.   t   containst
   matchNaevrt   appendRj   t   getProvidesR   t   getModeR/   t   exactarchlistt   filtert	   obsoletesR9   R   R   R;   t   setAsDepR   t   TS_OBSOLETEDR   t
   updated_byt   mapR   t
   returnPrcoRh   R,   ("   R#   R   R   t	   errorlistt	   checkdepsR   Rb   R   R   R   R   R   R   R   R   t   needmodet   needpot	   providerst
   cheater_pot   txmbrsR   t   inst_pot   inst_strt   i_nt   i_at   i_et   i_vt   i_rt   thismodet   origobsR   t
   newupdatest   pkgt   reqpkg(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR   :  s    
		!
		
	!	!%
c         C   s   |  j  d  k r t S| d k r( d  } n  t |  t j t j t j f k rj t j	 j
 |  \ } } } n0 t |  t j t j f k r | \ } } } n  |  j  } | j d | | | | | f f  r |  j j t d  | |  t St S(   Ni    t   providess"   Quick matched %s to require for %s(   t	   _last_reqR   R   t   typet   typest
   StringTypet   NoneTypet   UnicodeTypeRI   R   t   stringToVersiont	   TupleTypet   ListTypet	   checkPrcoR   t   debugR   Rh   (   R#   Rb   Rc   Rd   t   r_et   r_vt   r_rRj   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _quickWhatProvides  s    	$	$c   %      C   s  | j  \ } } } } } | \ }	 }
 } d } d } i  } |  j |	 |
 |  rX | | f S|  j |	 |
 |  } x| j   D]} |  j j d |  r |  j j t j	 t
 d  |  | j |  qz n  g  } |  j |  sz |  j j d | j  } x | D] } t | j | j j  s | j j |  rdt
 d  | } |  j j t j	 |  | j |  q q| j j |  r| j | j  g   j | j   qq q W|  j j d | j  } xo | D]d } | j |  rt | j | j  rt
 d  | } |  j j t j	 |  | j |  qqqWqz qz Wt |  d k rnd } |  j | |  } | j |  | | f Sx | j   D] } | j  \ } } } } } |  j j d | d | d	 | d
 | d |  } | d k r{|  j j t j	 t
 d  |  | |  _ | | f Sq{Wg  } x | j   D] } |  j d | d | j d	 | j d | j d | j   } | j! |  x6 | D]. } | | j k rkt" } | |  _ | | f SqkWqW| j   } t |  d k r| d }  n  |  j# | |  }! |! d d }  |  j j d |   r6d } d } |  j | |  } | j |  | | f S|  j j d |  j d |  j  }" t |"  d k r|  j j$ t
 d  |  | f  |  j j% |  |" d  } | j& d |  d | _' t" } |  |  _ n |  j j$ t
 d  |  |  t( j) |	 t* |
  |  }# |  j+ |  d |# }$ x_ |$ D]W } | j& d |  d | _' | j |  _ | j  | k r"t, |  j j- | | j   q"q"W|$ sd } d } |  j | |  } | j |  n d } | | f S(   sk   processes the dependency resolution for a dep where requiring 
           package is in the transaction seti    Rj   sB   %s is in providing packages but it is already installed, removing.Rb   s8   Potential resolving package %s has newer instance in ts.s<   Potential resolving package %s has newer instance installed.i   R   R   R   R   Ro   Rq   s#   %s already in ts, skipping this oneR   Rd   s#   TSINFO: Marking %s as update for %st   deps$   TSINFO: Marking %s as install for %st   provides_for(   Ro   Rq   (.   R~   R   Rf   t   returnPackagesR.   R   R   R^   R_   R   R   t
   delPackageRm   RX   R   Rb   R   R   Rj   t   verGTt   verLTt
   setdefaultR   t   searchNevrat   lenR   R   R   t   returnNewestByNameR9   R   Rd   R   t   extendRh   t   _compare_providersR   t	   addUpdateR   t   reasont   misct   string_to_prco_tupleR   R7   R   R;   (%   R#   R   R   R   Rb   R   R   Rd   R   R   R   R   R   R   t   upgradedt   provSackR   t   tspkgst   tspkgR   t   dbpkgst   dbpkgt   nt   aRp   t   vt   rt   pkgmodet   resultst   tresultsR   t   pkgst   bestt
   pkgresultst   instt   reqtupleR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR     s    
)%
-			
!		!c         C   sO   |  j  s d St |  j  d  r5 |  j  j | |  n |  j  j | j |  d S(   sW    Call the callback for processing requires, call the nicest one
            available. Nt   procConflictPo(   R   RS   R  t   procConflictRb   (   R#   Rj   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _dscb_procConflict  s
    	c         C   s*  t  } g  } | \ } } } | j \ }	 }
 } } } t j j | | |  } |  j | |  t |  j  } | t j	 @r |  j
 d | j  |  j j | j t  } t |  j  | k r'| r'| | f Sn] | t j @r'|  j
 d |	  |  j j | j t  } t |  j  | k r'| r'| | f Sn  |  j
 d | j  |  j j | j t  } t |  j  | k rw| rw| | f S|  j
 d |	  |  j j | j t  } t |  j  | k r| r| | f Sd |	 t |  f } | j |  |  j j t j |  t } |  j j | | | d f  | | f S(   s6   processes a Conflict dep from the resolveDeps() methodRb   s   %s conflicts with %si(   Rh   R~   RI   R   R   R  R  RX   RL   t   RPMSENSE_LESSR9   Rb   R   R   t   RPMSENSE_GREATERR   R   R   R^   R_   R`   R   R   R   (   R#   Rj   t   conflictt   conflicting_poR   R   R   Rc   R   Rb   R   R   R   R   R   t   lengthR   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _processConflict  s>    

c         C   s7   x0 |  j  D]% } | j r
 |  j  j | j  q
 q
 Wd  S(   N(   RX   t   isDepR;   R~   (   R#   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _undoDepInstalls  s    	c         C   s   d } d d  l  } d d  l } | j |  } | j |  j  } | j   d GH| j j |  } | j   | j	 d d  | j
 d  | S(   Ns   anaconda.prof.0is   done running depcheckt   timet   callsi   (   t   hotshott   hotshot.statst   Profilet   runcallt   resolveDepst   closet   statst   loadt
   strip_dirst
   sort_statst   print_stats(   R#   t   fnR*  t   proft   rcR0  (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   prof_resolveDeps  s    

c         C   s   d d  l  } d d  l } | j   } | j |  j  } | j d  d GH| j d  } | j   | j d  | j	 d  | S(   Nit   yumprofs   done running depcheckR(  i   (
   t   cProfilet   pstatsR,  R-  R.  t
   dump_statst   StatsR2  R3  R4  (   R#   R:  R;  R6  R7  t   p(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   cprof_resolveDeps  s    
c         C   s!  t  |  j  s" d t d  g f St   |  _ d  |  _ d  |  _ |  j j d t	  t
 } | } | } d } g  } |  j r |  j j   n  xt
 rCt
 } x[ | r i  |  _ |  j r |  j j   n  |  j |  \ } } }	 }
 | | O} | |	 O} q Wd  |  _ | rt	 } xI |  j   D]; \ } } |  j | |  \ } }
 } | | O} | | 7} qW| r|  j rw|  j j   n  |  j j t j t d   q qn  d  |  _ | r?t	 } xG |  j   D]9 } |  j |   \ } } | | O} | | 7} | rPqqW| r?|  j r|  j j   n  |  j j t j t d   q q?n  Pq Wxo |  j j   D]^ } |  j | j  rT| j d k rT|  j j t j t d  | j  d | _ t | _ qTqTW|  j r|  j  j! s|  j j"   q| r| r|  j j"   qn  |  j j t j t d   t	 |  j _# t  |  d k rt$ |  } t   } x |  j D] \ } } } | | f | k r|qUn  | j% | | f  |  j j t j& d	 | | j' f  | j( d
 d  } |  j j t j& d |  qUWd | f St  |  j  sd t d  g f Sd t d  g f S(   Ni    s   Success - empty transactiont   hards   Restarting LoopRq   s   %s converted to installRo   s   Dependency Process endings.   SKIPBROKEN: %s from %s has depsolving problemss   
s   
  --> s   SKIPBROKEN:  --> %si   i   s   Success - deps resolved()   R  RX   R   Rg   R   R   R   R   t   resetResolvedR   Rh   R   t   startR   t   tscheckt   _resolveRequirest   _checkFileRequiresR   t   restartLoopR   R^   R_   R`   t   _checkConflictsR%  R{   Rm   Rj   R}   R   R   R   R/   t   skip_brokent   endt   changedR   R   t   DEBUG_4t   repoidt   replace(   R#   t
   full_checkt   skipping_brokenR   t   CheckRemovest   CheckInstallsR   t   errorst   checkinstallst   checkremovest   missingRj   R   t   checkdepR   R"  R   t   donet   wpot   err(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR.    s    			 				 
	
	 		

	 		
			
c         C   si  t  } t  } t  } t  } x>|  j j   D]-} |  j r | j r | j } | j r[ d } n  | d k ry | j ry d } n  | d k r | j t k r d } q | j	 s d } q n  |  j j
 | j |  n  |  j j t j t d  | f  | j	 r| j r| j d d |  _ n | j |  _ | j t k | j j d  k k r]|  j |  } t } n |  j |  } t } t  }	 x | D] \ }
 } | j r|  j |
 |  } |  j j t j |  | j |  |  j j |
 |  j | d f  d	 }	 qn  |  j |
 |  \ } } } | | O} | | 7} |	 | O}	 qW|	 sK|  j j  |  n  | |	 O} q( W| | | | f S(
   NRr   Rq   R  t   oRo   s   Checking deps for %si    ii   (!   R   RX   t   getUnresolvedMembersR   R}   R   t	   reinstallR   t   TS_OBSOLETINGt   updatesR   R~   R   R^   R_   R   R   t	   relatedtoR   Rj   t   TS_INSTALL_STATESt   stateR   t   _checkInstallRh   t   _checkRemoveR   R   R   R   R   R   t   markAsResolved(   R#   RR  t   any_missingR   RQ  RP  R   R   t	   thisneedst   missing_in_pkgRj   R   R   RV  RU  R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyRD  ;  sX    						!		 

c         C   s   i d d 6d d 6d d 6d d 6d	 d
 6d d 6} | j |  d d  } d } |  d j d  r |  d j d  s |  d j d  r d } n  | | f S(   s8   Get a sort key for a package requires from most "narrow" to least,
            this tries to ensure that if we have two reqs like
            "libfoo = 1.2.3-4" and "foo-api" (which is also provided by
            libxyz-foo) that we'll get just libfoo.
            There are other similar cases this "handles".i   R   i   R   i   R   i   R   i   R   ic   i
   i    t   libs   ()s	   ()(64bit)N(   R   t   gett
   startswitht   endswith(   R~   t   mappert	   flagscoret	   namescore(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _sort_req_keyy  s    0&	c   
      C   s  | j  j d  } g  } x' | j D] } | j | j d   q" Wt |  } g  } x)t | d |  j D]} | d j d  r qj n  | | k r qj n  |  j j	 t
 j t d  | |  |  j j |   } | r| j  j d |  r| j | j  |  j |  f  qj n  xh | D]` } | j | j k r6qn  x? |  j j d | j d t  D] }	 |	 j j | j  d	 f  qUWqWqj W| S(
   NR   t   keyi    s   rpmlib(s%   looking for %s as a requirement of %sR   R~   t   output_statest	   dependson(   Rj   R   R^  R  Rg   t   sortedRo  Rj  R   R^   R_   R   R   RX   R   t   inPrcoRangeR   R   Rb   R   R~   R`  R_  (
   R#   R   t
   txmbr_reqst   oldreqst   oldpot   retR   t   provsRj   t   member(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyRb    s.    "%c      	   C   s  | j  } | j d  } i  } x6 | j | j D]$ } x | j D] } d | | <q? Wq/ Wg  } x| D]} | d j d  r qd n  | | k r qd n  xm|  j j |   j   D]S\ }	 }
 |  j	 j
 r&| j r&| j t k r&|  j } | rt | d  r| j |	 |
  n  |  j j | j  g  Sx |
 D] } t } x- | j D]" } | j d |  rCt } PqCqCW| ruq-n  x- | j D]" } | j d |  rt } PqqW| rq-n  | \ } } } |  j j | | |  s-| j |	 |  j | | |  f  q-q-Wq Wqd W| S(   NR   i   i    s   rpmlib(t   groupRemoveReq(   Rj   R   R   R   R   Rj  RX   t   getRequirest	   iteritemsR/   t   groupremove_leaf_onlyt   groupsR   t   TS_ERASER   RS   R{  R;   R~   R   R   Rh   R   R   R   (   R#   R   Rj   Ry  t
   newpoprovst   newpoR>  Rx  Rl   R   t   hitst   cbt   hitt   foundR   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyRc    sL    	%	  1c      
   C   s  t    } t    } i  } g  } |  j d  k rQ |  j j   \ |  _ |  _ |  _ n  g  } x| |  j j   D]k \ } } |  j j	 | d t
 r | j |  qg | j |  x' | D] } | j | g   j |  q Wqg Wx | D] } |  j | =q W| |  j 8} x|  j j	 d t  D]}	 x |	 j j D] \ }
 } } |
 j d  r'|	 j j } |  j j | g   j |
  |
 |  j k rt } x6 |	 j D]+ } | j d |
 d  d f  rt } PqqW| rq'qn  |
 | k r| j |
  n  | j |
  | j |
 g   j |	 j j  q'q'WqWg  } x |  j D]u } g  } x@ |  j | D]1 } |  j j	 | d t
 rkqGn  | j |  qGW| s| j |  q-n  | |  j | <q-Wx | D] } |  j | =qW|  j } x(| D] } | |  j k rqn  |  j j |  } | r9| j | g   j g  | D] } | j ^ q qn  |  j j |  } | r| j | g   j g  | D] } | j ^ qj qn  xh | | D]\ } |  j j	 | t  } | r| d j } n |  j |  } | j | | d d f f  qWqW|  j j |  j |  j |  j |  | S(   NRq  t   /R   i    t    (   NNN(   Rg   R!   R   R.   t   fileRequiresDataR"   t   installedFileProvidersR}  R   R   R   R   R9   R  R`  Rj   R   Rj  R~   R   R^  R   Rh   R   RX   t   getOldProvidesR  t   getNewProvidest   getInstalledPackageObjectt   transactionCacheFileRequires(   R#   t   fileRequirest   nfileRequirest   reverselookupRx  t   todelR~   t   filest   filenameR   Rb   R\   t   evrt   ptt   already_brokenRw  t   fnamet
   niFP_fnamet   iFPt   oprovRj   t   nprov(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyRE    s    		$!	*	//$c      	   C   s1  g  } g  } x|  j  j   D] } |  j j | j d t rC q n  | j d  } | s^ q n  | j |  x | D] } | \ } } } x |  j j | | |  D]e }	 |	 j d | j d k r |	 j d | j d k r q n  | j | |  j	 | | |  |	 f  q Wqr Wq Wx |  j j d t
  D] }
 |
 j } t } x |
 j j d  D] } | st| j |
 j  t } n  | \ } } } x |  j j | | |  D]e }	 |	 j d | j d k r|	 j d | j d k rqn  | j | |  j	 | | |  |	 f  qWqOWq'Wt d  r| S|  j  j |  | S(   NRq  t	   conflictsi    i   i   i	   (   i   i	   i    (   R.   t   returnConflictPackagesRX   R   R~   R   R   R   R  R   R`  Rj   R   Rh   R   R	   t    transactionCacheConflictPackages(   R#   Rx  t   cpkgsRj   R  R"  R  t   fR  R#  R   RW  (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyRG  [  sB    4		4c         C   sl   |  j  j d |  } x! | D] } | j t k r t Sq Wt |  d k rO t S|  j j d |  sh t St S(   NRb   i    (	   RX   R   R   R`  Rh   R  R   R.   R   (   R#   t   pkgnamet   lstR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   isPackageInstalled  s    c            sF    j  j t j t d  t |   d d  } d   }   f d   } i  } xI | D]A } | j | k r | | j j | j k r qW n  | | | j <qW W| j   } i  } x | D] } d | | <q W  j	 j
 d d | d	 | x | j   D] }   j j d
 | j  }	 |	 r t |	  d }
 |
 j |  rH| | c d 7<q|
 j |  rj| | c d 7<q|
 j |  r| | c d 8<qq q W| j   } i  } x| D]} x| D]} | | k rqn  | j | k r  j j | j  d  | | j <n  | | j s,| j | | j d  r?| | c d 8<n  t } | j | g  rt } | | c d 8<  j  j t j t d  | | f  n  | r| j   j j f } n   j j f } xw | D]o } | | | |  } | sqn    j  j t j t d | | | | f   | | k r| | c d 7<qqWqW| | |  r  j  j t j t d | | f   | | c d 7<n    j | j  r  j  j t j t d | j | f   | | c d 7<n  | r| | j | j  } | d k rA  j  j t j t d | | | f   | | c | d 7<qAqqWt | j    } i  } x. | D]& } | | | k rqdn  d | | <qdWt |  d k rx9 | D]1 } t |  }   j |  } t |  | | <qWt  | j    }   j  j t j t d  |  x | D]y } | | | k r^  j  j t j t d  |  | | c d 7<q| | }   j  j t j t d  | | f  qWn  t | j    } xQ | D]I } | | | k rqn  | | c d 7<| | c t | j  d 7<qWt | j!   d d   d t }   j  j t j t d t |    | S(   so   take the list of pkgs and score them based on the requesting package
           return a dictionary of po=scores"   Running compare_providers() for %si   c         S   s`   t  t |   t |   } x5 t |  D]' } |  | | | k r( t | |  Sq( Wt | |  S(   N(   R   R  t   rangeR   (   R
   R   t   minlent   numt   off(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _common_prefix_len  s
    c         S   s6   t  |  d  s t St  | d  s& t S|  j | j k S(   Nt	   sourcerpm(   RS   R   R  (   R
   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _common_sourcerpm  s
    c            s   t  | |  j  }   j j rQ | d k rQ   j j t j t d  |  | Sn  t  | | j  } | d k r | | k r   j j t j t d  |  | S| | k r d  S|  S(   Ni    s   better arch in po %s(	   R    R   t   multilibR   R^   R_   RK  R   R   (   R
   R   t   req_compare_archt   x_distt   y_dist(   R#   (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   _compare_arch_distance  s    i    t   compare_providerst   providers_dictt   reqpoRb   ii   i  i   i   s   %s obsoletes %ss-   archdist compared %s to %s on %s
  Winner: %ss   common sourcerpm %s and %si   s#   base package %s is installed for %ss%   common prefix of %s between %s and %ss   requires minimal: %ds    Winner: %ss    Loser(with %d): %sRp  c         S   s   |  d |  d f S(   Ni   i    (    (   R
   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR   j  s    t   reverses   Best Order: %s("   R   R^   R_   RK  R   R   R~   R   t   valuest   pluginst   runt   keysR.   R  Rb   Rs  R   t   verEQR   R,   R  R   t   obsoletedByRh   R   t   bestarchR  t   base_package_nameR   R  R   Rb  R   t   items(   R#   R  R  R  R  R  t   unique_nevra_pkgsR   R  t	   rpmdbpkgst   newestt   lposRj   t   nextpot	   obsoletedt   archest   thisarcht   rest   cplt   bestnumt   rec_depsolvet
   fake_txmbrt   reqsR  t	   bestorder(    (   R#   s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR    s    	#)

!((   t   __name__t
   __module__t   __doc__R$   R+   R   R*   R2   R>   R?   R@   R3   Rf   Rm   R   R   R   t   staticmethodR   R   R   R   R   R   R  R%  R'  R8  R?  Rh   R.  RD  Ro  Rb  Rc  RE  RG  R  t   _isPackageInstalledR  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR   >   sF   									C		#		
					)			g	>	%	5	k	%	t   DepCheckc           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   s  object that YumDepsolver uses to see what things are needed to close
       the transaction set. attributes: requires, conflicts are a list of 
       requires are conflicts in the current transaction set. Each item in the
       lists are a requires or conflicts objectc         C   s   g  |  _  g  |  _ d  S(   N(   R   R  (   R#   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR$   x  s    	c         C   s#   t  | |  } |  j j |  d  S(   N(   t   RequiresR   R   (   R#   Rj   t   req_tuple_listt   reqobj(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   addRequires|  s    c         C   s#   t  | |  } |  j j |  d  S(   N(   t	   ConflictsR  R   (   R#   t   conflict_po_listt   conflict_itemt   confobj(    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   addConflicts  s    (   R  R  R  R$   R  R  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR  s  s   		R  c           B   s   e  Z d  Z d   Z RS(   sY   
    A pure data class for holding a package and the list of things it
    requires.
    c         C   s   | |  _  | |  _ d  S(   N(   R   R   (   R#   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR$     s    	(   R  R  R  R$   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR    s   R  c           B   s   e  Z d  Z d   Z RS(   sZ   
    A pure data class for holding a package and the list of things it
    conflicts.
    c         C   s   | |  _  | |  _ d  S(   N(   t   pkglistR"  (   R#   R  R"  (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR$     s    	(   R  R  R  R$   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyR    s   (*   R  t   os.pathR   R   R   t   rpmUtils.transactionRI   t   rpmUtils.miscutilst   rpmUtils.archR    R   R	  R   R   t   transactioninfoR   RL   t   packageSackR   t	   constantst   packagesR_   R(   R&   t   simplefilterR)   t   yumR   R	   R   t   AssertionErrorR   R!  t   RPMSENSE_EQUALR   R   Rc   t   objectR   R  R  R  (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/depsolve.pyt   <module>   sL   
	


     :                                                                                                                                                                                             usr/lib/python2.7/dist-packages/yum/failover.py                                                     0100644 0000000 0000000 00000006454 12451005146 020115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2003 Jack Neely, NC State University

# Here we define a base class for failover methods.  The idea here is that each
# failover method uses a class derived from the base class so yum only has to
# worry about calling get_serverurl() and server_failed() and these classes will 
# figure out which URL to cough up based on the failover method.

import random

class baseFailOverMethod:

    def __init__(self, repo):
        self.repo = repo
        self.failures = 0
    
    def get_serverurl(self, i=None):
        """Returns a serverurl based on this failover method or None 
           if complete failure.  If i is given it is a direct index
           to pull a server URL from instead of using the failures 
           counter."""
        return None
        
    def server_failed(self):
        "Tells the failover method that the current server is failed."
        self.failures = self.failures + 1
        
    def reset(self, i=0):
        "Reset the failures counter to a given index."
        self.failures = i

    def get_index(self):
        """Returns the current number of failures which is also the
           index into the list this object represents.  ger_serverurl()
           should always be used to translate an index into a URL
           as this object may change how indexs map.  (See RoundRobin)"""

        return self.failures
   
    def len(self):
        """Returns the how many URLs we've got to cycle through."""

        return len(self.repo.urls)
        
            

class priority(baseFailOverMethod):

    """Chooses server based on the first success in the list."""
    
    def get_serverurl(self, i=None):
        "Returns a serverurl based on this failover method or None if complete failure."
        
        if i == None:
            index = self.failures
        else:
            index = i
        
        if index >= len(self.repo.urls):
            return None
        
        return self.repo.urls[index]
        
        
    
class roundRobin(baseFailOverMethod):

    """Chooses server based on a round robin."""
    
    def __init__(self, repo):
        baseFailOverMethod.__init__(self, repo)
        random.seed()
        self.offset = random.randint(0, 37)
    
    def get_serverurl(self, i=None):
        "Returns a serverurl based on this failover method or None if complete failure."

        if i == None:
            index = self.failures
        else:
            index = i
        
        if index >= len(self.repo.urls):
            return None
        
        rr = (index + self.offset) % len(self.repo.urls)
        return self.repo.urls[rr]   

# SDG
                                                                                                                                                                                                                    usr/lib/python2.7/dist-packages/yum/failover.pyc                                                    0100644 0000000 0000000 00000006777 13077704344 020303  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   sO   d  d l  Z  d d d     YZ d e f d     YZ d e f d     YZ d S(	   iNt   baseFailOverMethodc           B   sD   e  Z d    Z d d  Z d   Z d d  Z d   Z d   Z RS(   c         C   s   | |  _  d |  _ d  S(   Ni    (   t   repot   failures(   t   selfR   (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyt   __init__   s    	c         C   s   d S(   s   Returns a serverurl based on this failover method or None 
           if complete failure.  If i is given it is a direct index
           to pull a server URL from instead of using the failures 
           counter.N(   t   None(   R   t   i(    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyt   get_serverurl   s    c         C   s   |  j  d |  _  d S(   s<   Tells the failover method that the current server is failed.i   N(   R   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyt   server_failed%   s    i    c         C   s   | |  _  d S(   s,   Reset the failures counter to a given index.N(   R   (   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyt   reset)   s    c         C   s   |  j  S(   s	  Returns the current number of failures which is also the
           index into the list this object represents.  ger_serverurl()
           should always be used to translate an index into a URL
           as this object may change how indexs map.  (See RoundRobin)(   R   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyt	   get_index-   s    c         C   s   t  |  j j  S(   s5   Returns the how many URLs we've got to cycle through.(   t   lenR   t   urls(   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyR   5   s    N(	   t   __name__t
   __module__R   R   R   R   R	   R
   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyR       s   			t   priorityc           B   s   e  Z d  Z d d  Z RS(   s6   Chooses server based on the first success in the list.c         C   sH   | d k r |  j } n | } | t |  j j  k r: d S|  j j | S(   sN   Returns a serverurl based on this failover method or None if complete failure.N(   R   R   R   R   R   (   R   R   t   index(    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyR   @   s    N(   R   R   t   __doc__R   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyR   <   s   t
   roundRobinc           B   s#   e  Z d  Z d   Z d d  Z RS(   s&   Chooses server based on a round robin.c         C   s3   t  j |  |  t j   t j d d  |  _ d  S(   Ni    i%   (   R    R   t   randomt   seedt   randintt   offset(   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyR   S   s    
c         C   se   | d k r |  j } n | } | t |  j j  k r: d S| |  j t |  j j  } |  j j | S(   sN   Returns a serverurl based on this failover method or None if complete failure.N(   R   R   R   R   R   R   (   R   R   R   t   rr(    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyR   X   s    N(   R   R   R   R   R   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyR   O   s   	(    (   R   R    R   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/failover.pyt   <module>   s   $ usr/lib/python2.7/dist-packages/yum/history.py                                                      0100644 0000000 0000000 00000144760 12451005146 020012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -t
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Copyright 2009 Red Hat
#
# James Antill <james@fedoraproject.org>

import time
import os, os.path
import glob
from weakref import proxy as weakref

from sqlutils import sqlite, executeSQL, sql_esc_glob
import yum.misc as misc
import yum.constants
from yum.constants import *
from yum.packages import YumInstalledPackage, YumAvailablePackage, PackageObject
from yum.i18n import to_unicode, to_utf8

from rpmUtils.arch import getBaseArch

_history_dir = '/var/lib/yum/history'

# NOTE: That we don't list TS_FAILED, because pkgs shouldn't go into the
#       transaction with that. And if they come out with that we don't want to
#       match them to anything anyway.
_stcode2sttxt = {TS_UPDATE : 'Update',
                 TS_UPDATED : 'Updated', 
                 TS_ERASE: 'Erase',
                 TS_INSTALL: 'Install', 
                 TS_TRUEINSTALL : 'True-Install',
                 TS_OBSOLETED: 'Obsoleted',
                 TS_OBSOLETING: 'Obsoleting'}

_sttxt2stcode = {'Update' : TS_UPDATE,
                 'Updated' : TS_UPDATED, 
                 'Erase' : TS_ERASE,
                 'Install' : TS_INSTALL, 
                 'True-Install' : TS_TRUEINSTALL,
                 'Dep-Install' : TS_INSTALL,
                 'Reinstall' : TS_INSTALL, # Broken
                 'Downgrade' : TS_INSTALL, # Broken
                 'Downgraded' : TS_INSTALL, # Broken
                 'Obsoleted' : TS_OBSOLETED,
                 'Obsoleting' : TS_OBSOLETING}

# ---- horrible Copy and paste from sqlitesack ----

def _setupHistorySearchSQL(patterns=None, ignore_case=False):
    """Setup need_full and patterns for _yieldSQLDataList, also see if
       we can get away with just using searchNames(). """

    if patterns is None:
        patterns = []

    fields = ['name', 'sql_nameArch', 'sql_nameVerRelArch',
              'sql_nameVer', 'sql_nameVerRel',
              'sql_envra', 'sql_nevra']
    need_full = False
    for pat in patterns:
        if yum.misc.re_full_search_needed(pat):
            need_full = True
            break

    pat_max = PATTERNS_MAX
    if not need_full:
        fields = ['name']
        pat_max = PATTERNS_INDEXED_MAX
    if len(patterns) > pat_max:
        patterns = []
    if ignore_case:
        patterns = sql_esc_glob(patterns)
    else:
        tmp = []
        need_glob = False
        for pat in patterns:
            if misc.re_glob(pat):
                tmp.append((pat, 'glob'))
                need_glob = True
            else:
                tmp.append((pat, '='))
        if not need_full and not need_glob and patterns:
            return (need_full, patterns, fields, True)
        patterns = tmp
    return (need_full, patterns, fields, False)
# ---- horrible Copy and paste from sqlitesack ----

class YumHistoryPackage(PackageObject):

    def __init__(self, name, arch, epoch, version, release, checksum=None):
        self.name    = name
        self.version = version
        self.release = release
        self.epoch   = epoch
        self.arch    = arch
        self.pkgtup = (self.name, self.arch,
                       self.epoch, self.version, self.release)
        if checksum is None:
            self._checksums = [] # (type, checksum, id(0,1)
        else:
            chk = checksum.split(':')
            self._checksums = [(chk[0], chk[1], 0)] # (type, checksum, id(0,1))
        # Needed for equality comparisons in PackageObject
        self.repoid = "<history>"

class YumHistoryPackageState(YumHistoryPackage):
    def __init__(self, name,arch, epoch,version,release, state, checksum=None):
        YumHistoryPackage.__init__(self, name,arch, epoch,version,release,
                                   checksum)
        self.done  = None
        self.state = state

        self.repoid = '<history>'


class YumHistoryRpmdbProblem(PackageObject):
    """ Class representing an rpmdb problem that existed at the time of the
        transaction. """

    def __init__(self, history, rpid, problem, text):
        self._history = weakref(history)

        self.rpid = rpid
        self.problem = problem
        self.text = text

        self._loaded_P = None

    def __cmp__(self, other):
        if other is None:
            return 1
        ret = cmp(self.problem, other.problem)
        if ret: return -ret
        ret = cmp(self.rpid, other.rpid)
        return ret

    def _getProbPkgs(self):
        if self._loaded_P is None:
            self._loaded_P = sorted(self._history._old_prob_pkgs(self.rpid))
        return self._loaded_P

    packages = property(fget=lambda self: self._getProbPkgs())


class YumHistoryTransaction:
    """ Holder for a history transaction. """

    def __init__(self, history, row):
        self._history = weakref(history)

        self.tid              = row[0]
        self.beg_timestamp    = row[1]
        self.beg_rpmdbversion = row[2]
        self.end_timestamp    = row[3]
        self.end_rpmdbversion = row[4]
        self.loginuid         = row[5]
        self.return_code      = row[6]

        self._loaded_TW = None
        self._loaded_TD = None
        self._loaded_TS = None

        self._loaded_PROB = None

        self._have_loaded_CMD = False # cmdline can validly be None
        self._loaded_CMD = None

        self._loaded_ER = None
        self._loaded_OT = None

        self.altered_lt_rpmdb = None
        self.altered_gt_rpmdb = None

    def __cmp__(self, other):
        if other is None:
            return 1
        ret = cmp(self.beg_timestamp, other.beg_timestamp)
        if ret: return -ret
        ret = cmp(self.end_timestamp, other.end_timestamp)
        if ret: return ret
        ret = cmp(self.tid, other.tid)
        return -ret

    def _getTransWith(self):
        if self._loaded_TW is None:
            self._loaded_TW = sorted(self._history._old_with_pkgs(self.tid))
        return self._loaded_TW
    def _getTransData(self):
        if self._loaded_TD is None:
            self._loaded_TD = sorted(self._history._old_data_pkgs(self.tid))
        return self._loaded_TD
    def _getTransSkip(self):
        if self._loaded_TS is None:
            self._loaded_TS = sorted(self._history._old_skip_pkgs(self.tid))
        return self._loaded_TS

    trans_with = property(fget=lambda self: self._getTransWith())
    trans_data = property(fget=lambda self: self._getTransData())
    trans_skip = property(fget=lambda self: self._getTransSkip())

    def _getProblems(self):
        if self._loaded_PROB is None:
            self._loaded_PROB = sorted(self._history._old_problems(self.tid))
        return self._loaded_PROB

    rpmdb_problems = property(fget=lambda self: self._getProblems())

    def _getCmdline(self):
        if not self._have_loaded_CMD:
            self._have_loaded_CMD = True
            self._loaded_CMD = self._history._old_cmdline(self.tid)
        return self._loaded_CMD

    cmdline = property(fget=lambda self: self._getCmdline())

    def _getErrors(self):
        if self._loaded_ER is None:
            self._loaded_ER = self._history._load_errors(self.tid)
        return self._loaded_ER
    def _getOutput(self):
        if self._loaded_OT is None:
            self._loaded_OT = self._history._load_output(self.tid)
        return self._loaded_OT

    errors     = property(fget=lambda self: self._getErrors())
    output     = property(fget=lambda self: self._getOutput())

class YumMergedHistoryTransaction(YumHistoryTransaction):
    def __init__(self, obj):
        self._merged_tids = set([obj.tid])
        self._merged_objs = [obj]

        self.beg_timestamp    = obj.beg_timestamp
        self.beg_rpmdbversion = obj.beg_rpmdbversion
        self.end_timestamp    = obj.end_timestamp
        self.end_rpmdbversion = obj.end_rpmdbversion

        self._loaded_TW = None
        self._loaded_TD = None
        #  Hack, this is difficult ... not sure if we want to list everything
        # that was skipped. Just those things which were skipped and then not
        # updated later ... or nothing. Nothing is much easier.
        self._loaded_TS = []

        self._loaded_PROB = None

        self._have_loaded_CMD = False # cmdline can validly be None
        self._loaded_CMD = None

        self._loaded_ER = None
        self._loaded_OT = None

        self.altered_lt_rpmdb = None
        self.altered_gt_rpmdb = None

    def _getAllTids(self):
        return sorted(self._merged_tids)
    tid         = property(fget=lambda self: self._getAllTids())

    def _getLoginUIDs(self):
        ret = set((tid.loginuid for tid in self._merged_objs))
        if len(ret) == 1:
            return list(ret)[0]
        return sorted(ret)
    loginuid    = property(fget=lambda self: self._getLoginUIDs())

    def _getReturnCodes(self):
        ret_codes = set((tid.return_code for tid in self._merged_objs))
        if len(ret_codes) == 1 and 0 in ret_codes:
            return 0
        if 0 in ret_codes:
            ret_codes.remove(0)
        return sorted(ret_codes)
    return_code = property(fget=lambda self: self._getReturnCodes())

    def _getTransWith(self):
        ret = []
        filt = set()
        for obj in self._merged_objs:
            for pkg in obj.trans_with:
                if pkg.pkgtup in filt:
                    continue
                filt.add(pkg.pkgtup)
                ret.append(pkg)
        return sorted(ret)

    # This is the real tricky bit, we want to "merge" so that:
    #     pkgA-1 => pkgA-2
    #     pkgA-2 => pkgA-3
    #     pkgB-1 => pkgB-2
    #     pkgB-2 => pkgB-1
    # ...becomes:
    #     pkgA-1 => pkgA-3
    #     pkgB-1 => pkgB-1 (reinstall)
    # ...note that we just give up if "impossible" things happen, Eg.
    #     pkgA-1 => pkgA-2
    #     pkgA-4 => pkgA-5
    @staticmethod
    def _p2sk(pkg, state=None):
        """ Take a pkg and return the key for it's state lookup. """
        if state is None:
            state = pkg.state
        #  Arch is needed so multilib. works, dito. getBaseArch() -- (so .i586
        # => .i686 moves are seen)
        return (pkg.name, getBaseArch(pkg.arch), state)

    @staticmethod
    def _list2dict(pkgs):
        pkgtup2pkg   = {}
        pkgstate2pkg = {}
        for pkg in pkgs:
            key = YumMergedHistoryTransaction._p2sk(pkg)
            pkgtup2pkg[pkg.pkgtup] = pkg
            pkgstate2pkg[key]      = pkg
        return pkgtup2pkg, pkgstate2pkg
    @staticmethod
    def _conv_pkg_state(pkg, state):
        npkg = YumHistoryPackageState(pkg.name, pkg.arch,
                                      pkg.epoch,pkg.version,pkg.release, state)
        npkg._checksums = pkg._checksums
        npkg.done = pkg.done
        if _sttxt2stcode[npkg.state] in TS_INSTALL_STATES:
            npkg.state_installed = True
        if _sttxt2stcode[npkg.state] in TS_REMOVE_STATES:
            npkg.state_installed = False
        return npkg
    @staticmethod
    def _get_pkg(sk, pkgstate2pkg):
        if type(sk) != type((0,1)):
            sk = YumMergedHistoryTransaction._p2sk(sk)
        if sk not in pkgstate2pkg:
            return None
        return pkgstate2pkg[sk]
    def _move_pkg(self, sk, nstate, pkgtup2pkg, pkgstate2pkg):
        xpkg = self._get_pkg(sk, pkgstate2pkg)
        if xpkg is None:
            return
        del pkgstate2pkg[self._p2sk(xpkg)]
        xpkg = self._conv_pkg_state(xpkg, nstate)
        pkgtup2pkg[xpkg.pkgtup] = xpkg
        pkgstate2pkg[self._p2sk(xpkg)] = xpkg

    def _getTransData(self):
        def _get_pkg_f(sk):
            return self._get_pkg(sk, fpkgstate2pkg)
        def _get_pkg_n(sk):
            return self._get_pkg(sk, npkgstate2pkg)
        def _move_pkg_f(sk, nstate):
            self._move_pkg(sk, nstate, fpkgtup2pkg, fpkgstate2pkg)
        def _move_pkg_n(sk, nstate):
            self._move_pkg(sk, nstate, npkgtup2pkg, npkgstate2pkg)
        def _del1_n(pkg):
            del npkgtup2pkg[pkg.pkgtup]
            key = self._p2sk(pkg)
            if key in npkgstate2pkg: # For broken rpmdbv's and installonly
                del npkgstate2pkg[key]
        def _del1_f(pkg):
            del fpkgtup2pkg[pkg.pkgtup]
            key = self._p2sk(pkg)
            if key in fpkgstate2pkg: # For broken rpmdbv's and installonly
                del fpkgstate2pkg[key]
        def _del2(fpkg, npkg):
            assert fpkg.pkgtup == npkg.pkgtup
            _del1_f(fpkg)
            _del1_n(npkg)
        fpkgtup2pkg   = {}
        fpkgstate2pkg = {}
        #  We need to go from oldest to newest here, so we can see what happened
        # in the correct chronological order.
        for obj in self._merged_objs:
            npkgtup2pkg, npkgstate2pkg = self._list2dict(obj.trans_data)

            # Handle Erase => Install, as update/reinstall/downgrade
            for key in list(fpkgstate2pkg.keys()):
                (name, arch, state) = key
                if state not in  ('Obsoleted', 'Erase'):
                    continue
                fpkg = fpkgstate2pkg[key]
                for xstate in ('Install', 'True-Install', 'Dep-Install',
                               'Obsoleting'):
                    npkg = _get_pkg_n(self._p2sk(fpkg, xstate))
                    if npkg is not None:
                        break
                else:
                    continue

                if False: pass
                elif fpkg > npkg:
                    _move_pkg_f(fpkg, 'Downgraded')
                    if xstate != 'Obsoleting':
                        _move_pkg_n(npkg, 'Downgrade')
                elif fpkg < npkg:
                    _move_pkg_f(fpkg, 'Updated')
                    if xstate != 'Obsoleting':
                        _move_pkg_n(npkg, 'Update')
                else:
                    _del1_f(fpkg)
                    if xstate != 'Obsoleting':
                        _move_pkg_n(npkg, 'Reinstall')

            sametups = set(npkgtup2pkg.keys()).intersection(fpkgtup2pkg.keys())
            for pkgtup in sametups:
                if pkgtup not in fpkgtup2pkg or pkgtup not in npkgtup2pkg:
                    continue
                fpkg = fpkgtup2pkg[pkgtup]
                npkg = npkgtup2pkg[pkgtup]
                if False: pass
                elif fpkg.state == 'Reinstall':
                    if npkg.state in ('Reinstall', 'Erase', 'Obsoleted',
                                      'Downgraded', 'Updated'):
                        _del1_f(fpkg)
                elif fpkg.state in ('Obsoleted', 'Erase'):
                    #  Should be covered by above loop which deals with
                    # all goood state changes.
                    good_states = ('Install', 'True-Install', 'Dep-Install',
                                   'Obsoleting')
                    assert npkg.state not in good_states

                elif fpkg.state in ('Install', 'True-Install', 'Dep-Install'):
                    if False: pass
                    elif npkg.state in ('Erase', 'Obsoleted'):
                        _del2(fpkg, npkg)
                    elif npkg.state == 'Updated':
                        _del2(fpkg, npkg)
                        #  Move '*Install' state along to newer pkg. (not for
                        # obsoletes).
                        _move_pkg_n(self._p2sk(fpkg, 'Update'), fpkg.state)
                    elif npkg.state == 'Downgraded':
                        _del2(fpkg, npkg)
                        #  Move '*Install' state along to newer pkg. (not for
                        # obsoletes).
                        _move_pkg_n(self._p2sk(fpkg, 'Downgrade'), fpkg.state)

                elif fpkg.state in ('Downgrade', 'Update', 'Obsoleting'):
                    if False: pass
                    elif npkg.state == 'Reinstall':
                        _del1_n(npkg)
                    elif npkg.state in ('Erase', 'Obsoleted'):
                        _del2(fpkg, npkg)

                        # Move 'Erase'/'Obsoleted' state to orig. pkg.
                        _move_pkg_f(self._p2sk(fpkg, 'Updated'),    npkg.state)
                        _move_pkg_f(self._p2sk(fpkg, 'Downgraded'), npkg.state)

                    elif npkg.state in ('Downgraded', 'Updated'):
                        xfpkg = _get_pkg_f(self._p2sk(fpkg, 'Updated'))
                        if xfpkg is None:
                            xfpkg = _get_pkg_f(self._p2sk(fpkg, 'Downgraded'))
                        if xfpkg is None:
                            if fpkg.state != 'Obsoleting':
                                continue
                            # Was an Install*/Reinstall with Obsoletes
                            xfpkg = fpkg
                        xnpkg = _get_pkg_n(self._p2sk(npkg, 'Update'))
                        if xnpkg is None:
                            xnpkg = _get_pkg_n(self._p2sk(npkg, 'Downgrade'))
                        if xnpkg is None:
                            xnpkg = _get_pkg_n(self._p2sk(npkg, 'Obsoleting'))
                        if xnpkg is None:
                            continue

                        #  Now we have 4 pkgs, f1, f2, n1, n2, and 3 pkgtups
                        # f2.pkgtup == n1.pkgtup. So we need to find out if
                        # f1 => n2 is an Update or a Downgrade.
                        _del2(fpkg, npkg)
                        if xfpkg == xnpkg:
                            nfstate = 'Reinstall'
                            if 'Obsoleting' in (fpkg.state, xnpkg.state):
                                nfstate = 'Obsoleting'
                            if xfpkg != fpkg:
                                _move_pkg_f(xfpkg, nfstate)
                            _del1_n(xnpkg)
                        elif xfpkg < xnpkg:
                            # Update...
                            nfstate = 'Updated'
                            nnstate = 'Update'
                            if 'Obsoleting' in (fpkg.state, xnpkg.state):
                                nnstate = 'Obsoleting'
                            if xfpkg != fpkg:
                                _move_pkg_f(xfpkg, nfstate)
                            _move_pkg_n(xnpkg, nnstate)
                        else:
                            # Downgrade...
                            nfstate = 'Downgraded'
                            nnstate = 'Downgrade'
                            if 'Obsoleting' in (fpkg.state, xnpkg.state):
                                nnstate = 'Obsoleting'
                            if xfpkg != fpkg:
                                _move_pkg_f(xfpkg, nfstate)
                            _move_pkg_n(xnpkg, nnstate)

            for x in npkgtup2pkg:
                fpkgtup2pkg[x] = npkgtup2pkg[x]
            for x in npkgstate2pkg:
                fpkgstate2pkg[x] = npkgstate2pkg[x]
        return sorted(fpkgtup2pkg.values())

    def _getProblems(self):
        probs = set()
        for tid in self._merged_objs:
            for prob in tid.rpmdb_problems:
                probs.add(prob)
        return sorted(probs)

    def _getCmdline(self):
        cmdlines = []
        for tid in self._merged_objs:
            if not tid.cmdline:
                continue
            if cmdlines and cmdlines[-1] == tid.cmdline:
                continue
            cmdlines.append(tid.cmdline)
        if not cmdlines:
            return None
        return cmdlines

    def _getErrors(self):
        ret = []
        for obj in self._merged_objs:
            ret.extend(obj.errors)
        return ret
    def _getOutput(self):
        ret = []
        for obj in self._merged_objs:
            ret.extend(obj.output)
        return ret

    def merge(self, obj):
        if obj.tid in self._merged_tids:
            return # Already done, signal an error?

        self._merged_tids.add(obj.tid)
        self._merged_objs.append(obj)
        # Oldest first...
        self._merged_objs.sort(reverse=True)

        if self.beg_timestamp > obj.beg_timestamp:
            self.beg_timestamp    = obj.beg_timestamp
            self.beg_rpmdbversion = obj.beg_rpmdbversion
        if self.end_timestamp < obj.end_timestamp:
            self.end_timestamp    = obj.end_timestamp
            self.end_rpmdbversion = obj.end_rpmdbversion


class YumHistory:
    """ API for accessing the history sqlite data. """

    def __init__(self, root='/', db_path=_history_dir):
        self._conn = None
        
        self.conf = yum.misc.GenericHolder()
        if not os.path.normpath(db_path).startswith(root):
            self.conf.db_path  = os.path.normpath(root + '/' + db_path)
        else:
            self.conf.db_path = os.path.normpath('/' + db_path)
        self.conf.writable = False
        self.conf.readable = True

        if not os.path.exists(self.conf.db_path):
            try:
                os.makedirs(self.conf.db_path)
            except (IOError, OSError), e:
                # some sort of useful thing here? A warning?
                return
            self.conf.writable = True
        else:
            if os.access(self.conf.db_path, os.W_OK):
                self.conf.writable = True

        DBs = glob.glob('%s/history-*-*-*.sqlite' % self.conf.db_path)
        self._db_file = None
        for d in reversed(sorted(DBs)):
            fname = os.path.basename(d)
            fname = fname[len("history-"):-len(".sqlite")]
            pieces = fname.split('-', 4)
            if len(pieces) != 3:
                continue
            try:
                map(int, pieces)
            except ValueError:
                continue

            self._db_date = '%s-%s-%s' % (pieces[0], pieces[1], pieces[2])
            self._db_file = d
            break

        if self._db_file is None:
            self._create_db_file()
        
        # make an addon path for where we're going to stick 
        # random additional history info - probably from plugins and what-not
        self.conf.addon_path = self.conf.db_path + '/' + self._db_date
        if not os.path.exists(self.conf.addon_path):
            try:
                os.makedirs(self.conf.addon_path)
            except (IOError, OSError), e:
                # some sort of useful thing here? A warning?
                return
        else:
            if os.access(self.conf.addon_path, os.W_OK):
                self.conf.writable = True


    def __del__(self):
        self.close()

    def _get_cursor(self):
        if self._conn is None:
            if not self.conf.readable:
                return None

            try:
                self._conn = sqlite.connect(self._db_file)
            except (sqlite.OperationalError, sqlite.DatabaseError):
                self.conf.readable = False
                return None

            #  Note that this is required due to changing the history DB in the
            # callback for removed txmbrs ... which happens inside the chroot,
            # as against all our other access which is outside the chroot. So
            # we need sqlite to not open the journal.
            #  In theory this sucks, as history could be shared. In reality
            # it's deep yum stuff and there should only be one yum.
            executeSQL(self._conn.cursor(), "PRAGMA locking_mode = EXCLUSIVE")

        return self._conn.cursor()
    def _commit(self):
        return self._conn.commit()

    def close(self):
        if self._conn is not None:
            self._conn.close()
            self._conn = None

    def _pkgtup2pid(self, pkgtup, checksum=None):
        cur = self._get_cursor()
        executeSQL(cur, """SELECT pkgtupid, checksum FROM pkgtups
                           WHERE name=? AND arch=? AND
                                 epoch=? AND version=? AND release=?""", pkgtup)
        for sql_pkgtupid, sql_checksum in cur:
            if checksum is None and sql_checksum is None:
                return sql_pkgtupid
            if checksum is None:
                continue
            if sql_checksum is None:
                continue
            if checksum == sql_checksum:
                return sql_pkgtupid
        
        (n,a,e,v,r) = pkgtup
        (n,a,e,v,r) = (to_unicode(n),to_unicode(a),
                       to_unicode(e),to_unicode(v),to_unicode(r))
        if checksum is not None:
            res = executeSQL(cur,
                             """INSERT INTO pkgtups
                                (name, arch, epoch, version, release, checksum)
                                VALUES (?, ?, ?, ?, ?, ?)""", (n,a,e,v,r,
                                                               checksum))
        else:
            res = executeSQL(cur,
                             """INSERT INTO pkgtups
                                (name, arch, epoch, version, release)
                                VALUES (?, ?, ?, ?, ?)""", (n,a,e,v,r))
        return cur.lastrowid
    def _apkg2pid(self, po):
        csum = po.returnIdSum()
        if csum is not None:
            csum = "%s:%s" % (str(csum[0]), str(csum[1]))
        return self._pkgtup2pid(po.pkgtup, csum)
    def _ipkg2pid(self, po):
        csum = None
        yumdb = po.yumdb_info
        if 'checksum_type' in yumdb and 'checksum_data' in yumdb:
            csum = "%s:%s" % (yumdb.checksum_type, yumdb.checksum_data)
        return self._pkgtup2pid(po.pkgtup, csum)
    def pkg2pid(self, po):
        if isinstance(po, YumInstalledPackage):
            return self._ipkg2pid(po)
        if isinstance(po, YumAvailablePackage):
            return self._apkg2pid(po)
        return self._pkgtup2pid(po.pkgtup, None)

    @staticmethod
    def txmbr2state(txmbr):
        state = None
        if txmbr.output_state in (TS_INSTALL, TS_TRUEINSTALL):
            if txmbr.reinstall:
                state = 'Reinstall'
            elif txmbr.downgrades:
                state = 'Downgrade'
        if txmbr.output_state == TS_ERASE:
            if txmbr.downgraded_by:
                state = 'Downgraded'
        if state is None:
            state = _stcode2sttxt.get(txmbr.output_state)
            if state == 'Install' and txmbr.isDep:
                state = 'Dep-Install'
        return state

    def trans_with_pid(self, pid):
        cur = self._get_cursor()
        if cur is None:
            return None
        res = executeSQL(cur,
                         """INSERT INTO trans_with_pkgs
                         (tid, pkgtupid)
                         VALUES (?, ?)""", (self._tid, pid))
        return cur.lastrowid

    def trans_skip_pid(self, pid):
        cur = self._get_cursor()
        if cur is None or not self._update_db_file_2():
            return None
        
        res = executeSQL(cur,
                         """INSERT INTO trans_skip_pkgs
                         (tid, pkgtupid)
                         VALUES (?, ?)""", (self._tid, pid))
        return cur.lastrowid

    def trans_data_pid_beg(self, pid, state):
        assert state is not None
        if not hasattr(self, '_tid') or state is None:
            return # Not configured to run
        cur = self._get_cursor()
        if cur is None:
            return # Should never happen, due to above
        res = executeSQL(cur,
                         """INSERT INTO trans_data_pkgs
                         (tid, pkgtupid, state)
                         VALUES (?, ?, ?)""", (self._tid, pid, state))
        return cur.lastrowid
    def trans_data_pid_end(self, pid, state):
        # State can be none here, Eg. TS_FAILED from rpmtrans
        if not hasattr(self, '_tid') or state is None:
            return # Not configured to run

        cur = self._get_cursor()
        if cur is None:
            return # Should never happen, due to above
        res = executeSQL(cur,
                         """UPDATE trans_data_pkgs SET done = ?
                         WHERE tid = ? AND pkgtupid = ? AND state = ?
                         """, ('TRUE', self._tid, pid, state))
        self._commit()

    def _trans_rpmdb_problem(self, problem):
        if not hasattr(self, '_tid'):
            return # Not configured to run
        cur = self._get_cursor()
        if cur is None or not self._update_db_file_2():
            return None
        # str(problem) doesn't work if problem contains unicode(),
        # unicode(problem) doesn't work in python 2.4.x ... *sigh*.
        uproblem = to_unicode(problem.__str__())
        res = executeSQL(cur,
                         """INSERT INTO trans_rpmdb_problems
                         (tid, problem, msg)
                         VALUES (?, ?, ?)""", (self._tid,
                                               problem.problem,
                                               uproblem))
        rpid = cur.lastrowid

        if not rpid:
            return rpid

        pkgs = {}
        pkg = problem.pkg
        pkgs[pkg.pkgtup] = pkg
        if problem.problem == 'conflicts':
            for pkg in problem.conflicts:
                pkgs[pkg.pkgtup] = pkg
        if problem.problem == 'duplicates':
            pkgs[problem.duplicate.pkgtup] = problem.duplicate

        for pkg in pkgs.values():
            pid = self.pkg2pid(pkg)
            if pkg.pkgtup == problem.pkg.pkgtup:
                main = 'TRUE'
            else:
                main = 'FALSE'
            res = executeSQL(cur,
                             """INSERT INTO trans_prob_pkgs
                             (rpid, pkgtupid, main)
                             VALUES (?, ?, ?)""", (rpid, pid, main))

        return rpid

    def _trans_cmdline(self, cmdline):
        if not hasattr(self, '_tid'):
            return # Not configured to run
        cur = self._get_cursor()
        if cur is None or not self._update_db_file_2():
            return None
        res = executeSQL(cur,
                         """INSERT INTO trans_cmdline
                         (tid, cmdline)
                         VALUES (?, ?)""", (self._tid, to_unicode(cmdline)))
        return cur.lastrowid

    def beg(self, rpmdb_version, using_pkgs, txmbrs, skip_packages=[],
            rpmdb_problems=[], cmdline=None):
        cur = self._get_cursor()
        if cur is None:
            return
        res = executeSQL(cur,
                         """INSERT INTO trans_beg
                            (timestamp, rpmdb_version, loginuid)
                            VALUES (?, ?, ?)""", (int(time.time()),
                                                    str(rpmdb_version),
                                                    yum.misc.getloginuid()))
        self._tid = cur.lastrowid

        for pkg in using_pkgs:
            pid = self._ipkg2pid(pkg)
            self.trans_with_pid(pid)
        
        for txmbr in txmbrs:
            pid   = self.pkg2pid(txmbr.po)
            state = self.txmbr2state(txmbr)
            self.trans_data_pid_beg(pid, state)
        
        for pkg in skip_packages:
            pid   = self.pkg2pid(pkg)
            self.trans_skip_pid(pid)

        for problem in rpmdb_problems:
            self._trans_rpmdb_problem(problem)

        if cmdline:
            self._trans_cmdline(cmdline)

        self._commit()

    def _log_errors(self, errors):
        cur = self._get_cursor()
        if cur is None:
            return
        for error in errors:
            error = to_unicode(error)
            executeSQL(cur,
                       """INSERT INTO trans_error
                          (tid, msg) VALUES (?, ?)""", (self._tid, error))
        self._commit()

    def log_scriptlet_output(self, data, msg):
        """ Note that data can be either a real pkg. ... or not. """
        if msg is None or not hasattr(self, '_tid'):
            return # Not configured to run

        cur = self._get_cursor()
        if cur is None:
            return # Should never happen, due to above
        for error in msg.splitlines():
            error = to_unicode(error)
            executeSQL(cur,
                       """INSERT INTO trans_script_stdout
                          (tid, line) VALUES (?, ?)""", (self._tid, error))
        self._commit()

    def _load_errors(self, tid):
        cur = self._get_cursor()
        executeSQL(cur,
                   """SELECT msg FROM trans_error
                      WHERE tid = ?
                      ORDER BY mid ASC""", (tid,))
        ret = []
        for row in cur:
            ret.append(row[0])
        return ret

    def _load_output(self, tid):
        cur = self._get_cursor()
        executeSQL(cur,
                   """SELECT line FROM trans_script_stdout
                      WHERE tid = ?
                      ORDER BY lid ASC""", (tid,))
        ret = []
        for row in cur:
            ret.append(row[0])
        return ret

    def end(self, rpmdb_version, return_code, errors=None):
        assert return_code or not errors
        if not hasattr(self, '_tid'):
            return # Failed at beg() time
        cur = self._get_cursor()
        if cur is None:
            return # Should never happen, due to above
        res = executeSQL(cur,
                         """INSERT INTO trans_end
                            (tid, timestamp, rpmdb_version, return_code)
                            VALUES (?, ?, ?, ?)""", (self._tid,int(time.time()),
                                                     str(rpmdb_version),
                                                     return_code))
        self._commit()
        if not return_code:
            #  Simple hack, if the transaction finished. Note that this
            # catches the erase cases (as we still don't get pkgtups for them),
            # Eg. Updated elements.
            executeSQL(cur,
                       """UPDATE trans_data_pkgs SET done = ?
                          WHERE tid = ?""", ('TRUE', self._tid,))
            self._commit()
        if errors is not None:
            self._log_errors(errors)
        del self._tid

    def write_addon_data(self, dataname, data):
        """append data to an arbitrary-named file in the history 
           addon_path/transaction id location,
           returns True if write succeeded, False if not"""
        
        if not hasattr(self, '_tid'):
            # maybe we should raise an exception or a warning here?
            return False
        
        if not dataname:
            return False
        
        if not data:
            return False
            
        # make sure the tid dir exists
        tid_dir = self.conf.addon_path + '/' + str(self._tid)

        if self.conf.writable and not os.path.exists(tid_dir):
            try:
                os.makedirs(tid_dir, mode=0700)
            except (IOError, OSError), e:
                # emit a warning/raise an exception?
                return False
        
        # cleanup dataname
        safename = dataname.replace('/', '_')
        data_fn = tid_dir + '/' + safename
        try:
            # open file in append
            fo = open(data_fn, 'w+')
            # write data
            fo.write(to_utf8(data))
            # flush data
            fo.flush()
            fo.close()
        except (IOError, OSError), e:
            return False
        # return
        return True
        
    def return_addon_data(self, tid, item=None):
        hist_and_tid = self.conf.addon_path + '/' + str(tid) + '/'
        addon_info = glob.glob(hist_and_tid + '*')
        addon_names = [ i.replace(hist_and_tid, '') for i in addon_info ]
        if not item:
            return addon_names
        
        if item not in addon_names:
            # XXX history needs SOME kind of exception, or warning, I think?
            return None
        
        fo = open(hist_and_tid + item, 'r')
        data = fo.read()
        fo.close()
        return data
        
    def _old_with_pkgs(self, tid):
        cur = self._get_cursor()
        executeSQL(cur,
                   """SELECT name, arch, epoch, version, release, checksum
                      FROM trans_with_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE tid = ?
                      ORDER BY name ASC, epoch ASC""", (tid,))
        ret = []
        for row in cur:
            obj = YumHistoryPackage(row[0],row[1],row[2],row[3],row[4], row[5])
            ret.append(obj)
        return ret
    def _old_data_pkgs(self, tid):
        cur = self._get_cursor()
        executeSQL(cur,
                   """SELECT name, arch, epoch, version, release,
                             checksum, done, state
                      FROM trans_data_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE tid = ?
                      ORDER BY name ASC, epoch ASC, state DESC""", (tid,))
        ret = []
        for row in cur:
            obj = YumHistoryPackageState(row[0],row[1],row[2],row[3],row[4],
                                         row[7], row[5])
            obj.done     = row[6] == 'TRUE'
            obj.state_installed = None
            if _sttxt2stcode[obj.state] in TS_INSTALL_STATES:
                obj.state_installed = True
            if _sttxt2stcode[obj.state] in TS_REMOVE_STATES:
                obj.state_installed = False
            ret.append(obj)
        return ret
    def _old_skip_pkgs(self, tid):
        cur = self._get_cursor()
        if cur is None or not self._update_db_file_2():
            return []
        executeSQL(cur,
                   """SELECT name, arch, epoch, version, release, checksum
                      FROM trans_skip_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE tid = ?
                      ORDER BY name ASC, epoch ASC""", (tid,))
        ret = []
        for row in cur:
            obj = YumHistoryPackage(row[0],row[1],row[2],row[3],row[4], row[5])
            ret.append(obj)
        return ret
    def _old_prob_pkgs(self, rpid):
        cur = self._get_cursor()
        if cur is None or not self._update_db_file_2():
            return []
        executeSQL(cur,
                   """SELECT name, arch, epoch, version, release, checksum, main
                      FROM trans_prob_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE rpid = ?
                      ORDER BY name ASC, epoch ASC""", (rpid,))
        ret = []
        for row in cur:
            obj = YumHistoryPackage(row[0],row[1],row[2],row[3],row[4], row[5])
            obj.main = row[6] == 'TRUE'
            ret.append(obj)
        return ret

    def _old_problems(self, tid):
        cur = self._get_cursor()
        if cur is None or not self._update_db_file_2():
            return []
        executeSQL(cur,
                   """SELECT rpid, problem, msg
                      FROM trans_rpmdb_problems
                      WHERE tid = ?
                      ORDER BY problem ASC, rpid ASC""", (tid,))
        ret = []
        for row in cur:
            obj = YumHistoryRpmdbProblem(self, row[0], row[1], row[2])
            ret.append(obj)
        return ret

    def _old_cmdline(self, tid):
        cur = self._get_cursor()
        if cur is None or not self._update_db_file_2():
            return None
        executeSQL(cur,
                   """SELECT cmdline
                      FROM trans_cmdline
                      WHERE tid = ?""", (tid,))
        ret = []
        for row in cur:
            return row[0]
        return None

    def old(self, tids=[], limit=None, complete_transactions_only=False):
        """ Return a list of the last transactions, note that this includes
            partial transactions (ones without an end transaction). """
        cur = self._get_cursor()
        if cur is None:
            return []
        sql =  """SELECT tid,
                         trans_beg.timestamp AS beg_ts,
                         trans_beg.rpmdb_version AS beg_rv,
                         trans_end.timestamp AS end_ts,
                         trans_end.rpmdb_version AS end_rv,
                         loginuid, return_code
                  FROM trans_beg JOIN trans_end USING(tid)"""
        # NOTE: sqlite doesn't do OUTER JOINs ... *sigh*. So we have to do it
        #       ourself.
        if not complete_transactions_only:
            sql =  """SELECT tid,
                             trans_beg.timestamp AS beg_ts,
                             trans_beg.rpmdb_version AS beg_rv,
                             NULL, NULL,
                             loginuid, NULL
                      FROM trans_beg"""
        params = None
        if tids and len(tids) <= yum.constants.PATTERNS_INDEXED_MAX:
            params = tids = list(set(tids))
            sql += " WHERE tid IN (%s)" % ", ".join(['?'] * len(tids))
        sql += " ORDER BY beg_ts DESC, tid ASC"
        if limit is not None:
            sql += " LIMIT " + str(limit)
        executeSQL(cur, sql, params)
        ret = []
        tid2obj = {}
        for row in cur:
            if tids and len(tids) > yum.constants.PATTERNS_INDEXED_MAX:
                if row[0] not in tids:
                    continue
            obj = YumHistoryTransaction(self, row)
            tid2obj[row[0]] = obj
            ret.append(obj)

        sql =  """SELECT tid,
                         trans_end.timestamp AS end_ts,
                         trans_end.rpmdb_version AS end_rv,
                         return_code
                  FROM trans_end"""
        params = tid2obj.keys()
        if len(params) > yum.constants.PATTERNS_INDEXED_MAX:
            executeSQL(cur, sql)
        else:
            sql += " WHERE tid IN (%s)" % ", ".join(['?'] * len(params))
            executeSQL(cur, sql, params)
        for row in cur:
            if row[0] not in tid2obj:
                continue
            tid2obj[row[0]].end_timestamp    = row[1]
            tid2obj[row[0]].end_rpmdbversion = row[2]
            tid2obj[row[0]].return_code      = row[3]

        # Go through backwards, and see if the rpmdb versions match
        las = None
        for obj in reversed(ret):
            cur_rv = obj.beg_rpmdbversion
            las_rv = None
            if las is not None:
                las_rv = las.end_rpmdbversion
            if las_rv is None or cur_rv is None or (las.tid + 1) != obj.tid:
                pass
            elif las_rv != cur_rv:
                obj.altered_lt_rpmdb = True
                las.altered_gt_rpmdb = True
            else:
                obj.altered_lt_rpmdb = False
                las.altered_gt_rpmdb = False
            las = obj

        return ret

    def last(self, complete_transactions_only=True):
        """ This is the last full transaction. So any incomplete transactions
            do not count, by default. """
        ret = self.old([], 1, complete_transactions_only)
        if not ret:
            return None
        assert len(ret) == 1
        return ret[0]

    def _yieldSQLDataList(self, patterns, fields, ignore_case):
        """Yields all the package data for the given params. """

        cur = self._get_cursor()
        qsql = _FULL_PARSE_QUERY_BEG

        pat_sqls = []
        pat_data = []
        for (pattern, rest) in patterns:
            for field in fields:
                if ignore_case:
                    pat_sqls.append("%s LIKE ?%s" % (field, rest))
                else:
                    pat_sqls.append("%s %s ?" % (field, rest))
                pat_data.append(pattern)
        assert pat_sqls

        qsql += " OR ".join(pat_sqls)
        executeSQL(cur, qsql, pat_data)
        for x in cur:
            yield x

    def search(self, patterns, ignore_case=True):
        """ Search for history transactions which contain specified
            packages al. la. "yum list". Returns transaction ids. """
        # Search packages ... kind of sucks that it's search not list, pkglist?

        cur = self._get_cursor()
        if cur is None:
            return set()

        data = _setupHistorySearchSQL(patterns, ignore_case)
        (need_full, npatterns, fields, names) = data

        ret = []
        pkgtupids = set()

        if npatterns:
            for row in self._yieldSQLDataList(npatterns, fields, ignore_case):
                pkgtupids.add(row[0])
        else:
            # Too many patterns, *sigh*
            pat_max = PATTERNS_MAX
            if not need_full:
                pat_max = PATTERNS_INDEXED_MAX
            for npatterns in yum.misc.seq_max_split(patterns, pat_max):
                data = _setupHistorySearchSQL(npatterns, ignore_case)
                (need_full, nps, fields, names) = data
                assert nps
                for row in self._yieldSQLDataList(nps, fields, ignore_case):
                    pkgtupids.add(row[0])

        sql =  """SELECT tid FROM trans_data_pkgs WHERE pkgtupid IN """
        sql += "(%s)" % ",".join(['?'] * len(pkgtupids))
        params = list(pkgtupids)
        tids = set()
        if len(params) > yum.constants.PATTERNS_INDEXED_MAX:
            executeSQL(cur, """SELECT tid FROM trans_data_pkgs""")
            for row in cur:
                if row[0] in params:
                    tids.add(row[0])
            return tids
        if not params:
            return tids
        executeSQL(cur, sql, params)
        for row in cur:
            tids.add(row[0])
        return tids

    _update_ops_2 = ['''\
\
 CREATE TABLE trans_skip_pkgs (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups);
''', '''\
\
 CREATE TABLE trans_cmdline (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     cmdline TEXT NOT NULL);
''', '''\
\
 CREATE TABLE trans_rpmdb_problems (
     rpid INTEGER PRIMARY KEY,
     tid INTEGER NOT NULL REFERENCES trans_beg,
     problem TEXT NOT NULL, msg TEXT NOT NULL);
''', '''\
\
 CREATE TABLE trans_prob_pkgs (
     rpid INTEGER NOT NULL REFERENCES trans_rpmdb_problems,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups,
     main BOOL NOT NULL DEFAULT FALSE);
''', '''\
\
 CREATE VIEW vtrans_data_pkgs AS
     SELECT tid,name,epoch,version,release,arch,pkgtupid,
            state,done,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM trans_data_pkgs JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
''', '''\
\
 CREATE VIEW vtrans_with_pkgs AS
     SELECT tid,name,epoch,version,release,arch,pkgtupid,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM trans_with_pkgs JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
''', '''\
\
 CREATE VIEW vtrans_skip_pkgs AS
     SELECT tid,name,epoch,version,release,arch,pkgtupid,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM trans_skip_pkgs JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
''', # NOTE: Old versions of sqlite don't like the normal way to do the next
     #       view. So we do it with the select. It's for debugging only, so
     #       no big deal.
'''\
\
 CREATE VIEW vtrans_prob_pkgs2 AS
     SELECT tid,rpid,name,epoch,version,release,arch,pkgtups.pkgtupid,
            main,problem,msg,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM (SELECT * FROM trans_prob_pkgs,trans_rpmdb_problems WHERE
           trans_prob_pkgs.rpid=trans_rpmdb_problems.rpid)
           JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
''']

    def _update_db_file_2(self):
        """ Update to version 2 of history, includes trans_skip_pkgs. """
        if not self.conf.writable:
            return False

        if hasattr(self, '_cached_updated_2'):
            return self._cached_updated_2

        cur = self._get_cursor()
        if cur is None:
            return False

        executeSQL(cur, "PRAGMA table_info(trans_skip_pkgs)")
        #  If we get anything, we're fine. There might be a better way of
        # saying "anything" but this works.
        for ob in cur:
            break
        else:
            for op in self._update_ops_2:
                cur.execute(op)
            self._commit()
        self._cached_updated_2 = True
        return True

    def _create_db_file(self):
        """ Create a new history DB file, populating tables etc. """

        self._db_date = time.strftime('%Y-%m-%d')
        _db_file = '%s/%s-%s.%s' % (self.conf.db_path,
                                    'history',
                                    self._db_date,
                                    'sqlite')
        if self._db_file == _db_file:
            os.rename(_db_file, _db_file + '.old')
            # Just in case ... move the journal file too.
            if os.path.exists(_db_file + '-journal'):
                os.rename(_db_file  + '-journal', _db_file + '-journal.old')
        self._db_file = _db_file
        
        if self.conf.writable and not os.path.exists(self._db_file):
            # make them default to 0600 - sysadmin can change it later
            # if they want
            fo = os.open(self._db_file, os.O_CREAT, 0600)
            os.close(fo)
                
        cur = self._get_cursor()
        ops = ['''\
 CREATE TABLE trans_beg (
     tid INTEGER PRIMARY KEY,
     timestamp INTEGER NOT NULL, rpmdb_version TEXT NOT NULL,
     loginuid INTEGER);
''', '''\
 CREATE TABLE trans_end (
     tid INTEGER PRIMARY KEY REFERENCES trans_beg,
     timestamp INTEGER NOT NULL, rpmdb_version TEXT NOT NULL,
     return_code INTEGER NOT NULL);
''', '''\
\
 CREATE TABLE trans_with_pkgs (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups);
''', '''\
\
 CREATE TABLE trans_error (
     mid INTEGER PRIMARY KEY,
     tid INTEGER NOT NULL REFERENCES trans_beg,
     msg TEXT NOT NULL);
''', '''\
 CREATE TABLE trans_script_stdout (
     lid INTEGER PRIMARY KEY,
     tid INTEGER NOT NULL REFERENCES trans_beg,
     line TEXT NOT NULL);
''', '''\
\
 CREATE TABLE trans_data_pkgs (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups,
     done BOOL NOT NULL DEFAULT FALSE, state TEXT NOT NULL);
''', '''\
\
 CREATE TABLE pkgtups (
     pkgtupid INTEGER PRIMARY KEY,     name TEXT NOT NULL, arch TEXT NOT NULL,
     epoch TEXT NOT NULL, version TEXT NOT NULL, release TEXT NOT NULL,
     checksum TEXT);
''', '''\
 CREATE INDEX i_pkgtup_naevr ON pkgtups (name, arch, epoch, version, release);
''']
        for op in ops:
            cur.execute(op)
        for op in self._update_ops_2:
            cur.execute(op)
        self._commit()

# Pasted from sqlitesack
_FULL_PARSE_QUERY_BEG = """
SELECT pkgtupid,name,epoch,version,release,arch,
  name || "." || arch AS sql_nameArch,
  name || "-" || version || "-" || release || "." || arch AS sql_nameVerRelArch,
  name || "-" || version AS sql_nameVer,
  name || "-" || version || "-" || release AS sql_nameVerRel,
  epoch || ":" || name || "-" || version || "-" || release || "." || arch AS sql_envra,
  name || "-" || epoch || ":" || version || "-" || release || "." || arch AS sql_nevra
  FROM pkgtups
  WHERE 
"""
                usr/lib/python2.7/dist-packages/yum/history.pyc                                                     0100644 0000000 0000000 00000127161 13077704344 020164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z m Z m	 Z	 d  d l
 j Z d  d l Z d  d l Td  d l m Z m Z m Z d  d l m Z m Z d  d l m Z d Z i d	 e 6d
 e 6d e 6d e 6d e 6d e 6d e 6Z i e d	 6e d
 6e d 6e d 6e d 6e d 6e d 6e d 6e d 6e d 6e d 6Z  e! e" d  Z# d e f d     YZ$ d e$ f d     YZ% d e f d     YZ& d f  d     YZ' d e' f d     YZ( d f  d      YZ) d! Z* d S("   iN(   t   proxy(   t   sqlitet
   executeSQLt   sql_esc_glob(   t   *(   t   YumInstalledPackaget   YumAvailablePackaget   PackageObject(   t
   to_unicodet   to_utf8(   t   getBaseArchs   /var/lib/yum/historyt   Updatet   Updatedt   Eraset   Installs   True-Installt	   Obsoletedt
   Obsoletings   Dep-Installt	   Reinstallt	   Downgradet
   Downgradedc         C   sF  |  d
 k r g  }  n  d d d d d d d g } t } x* |  D]" } t j j |  r= t } Pq= q= Wt } | s d g } t } n  t |   | k r g  }  n  | r t	 |   }  n g  } t } xL |  D]D } t j
 |  r | j | d f  t } q | j | d	 f  q W| r0| r0|  r0| |  | t f S| }  | |  | t f S(   sv   Setup need_full and patterns for _yieldSQLDataList, also see if
       we can get away with just using searchNames(). t   namet   sql_nameArcht   sql_nameVerRelArcht   sql_nameVert   sql_nameVerRelt	   sql_envrat	   sql_nevrat   globt   =N(   t   Nonet   Falset   yumt   misct   re_full_search_neededt   Truet   PATTERNS_MAXt   PATTERNS_INDEXED_MAXt   lenR   t   re_globt   append(   t   patternst   ignore_caset   fieldst	   need_fullt   patt   pat_maxt   tmpt	   need_glob(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _setupHistorySearchSQL=   s:    						t   YumHistoryPackagec           B   s   e  Z d d   Z RS(   c         C   s   | |  _  | |  _ | |  _ | |  _ | |  _ |  j  |  j |  j |  j |  j f |  _ | d  k rl g  |  _ n, | j d  } | d | d d f g |  _ d |  _	 d  S(   Nt   :i    i   s	   <history>(
   R   t   versiont   releaset   epocht   archt   pkgtupR   t
   _checksumst   splitt   repoid(   t   selfR   R6   R5   R3   R4   t   checksumt   chk(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   __init__f   s    					N(   t   __name__t
   __module__R   R>   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR1   d   s   t   YumHistoryPackageStatec           B   s   e  Z d d   Z RS(   c         C   s>   t  j |  | | | | | |  d  |  _ | |  _ d |  _ d  S(   Ns	   <history>(   R1   R>   R   t   donet   stateR:   (   R;   R   R6   R5   R3   R4   RC   R<   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR>   w   s
    		N(   R?   R@   R   R>   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRA   v   s   t   YumHistoryRpmdbProblemc           B   s;   e  Z d  Z d   Z d   Z d   Z e d d    Z RS(   sZ    Class representing an rpmdb problem that existed at the time of the
        transaction. c         C   s7   t  |  |  _ | |  _ | |  _ | |  _ d  |  _ d  S(   N(   t   weakreft   _historyt   rpidt   problemt   textR   t	   _loaded_P(   R;   t   historyRG   RH   RI   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR>      s
    			c         C   sI   | d  k r d St |  j | j  } | r0 | St |  j | j  } | S(   Ni   (   R   t   cmpRH   RG   (   R;   t   othert   ret(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   __cmp__   s     c         C   s7   |  j  d  k r0 t |  j j |  j   |  _  n  |  j  S(   N(   RJ   R   t   sortedRF   t   _old_prob_pkgsRG   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getProbPkgs   s    !t   fgetc         C   s
   |  j    S(   N(   RR   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   <lambda>   s    (   R?   R@   t   __doc__R>   RO   RR   t   propertyt   packages(    (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRD      s
   				t   YumHistoryTransactionc           B   s   e  Z d  Z d   Z d   Z d   Z d   Z d   Z e d d    Z	 e d d    Z
 e d d	    Z d
   Z e d d    Z d   Z e d d    Z d   Z d   Z e d d    Z e d d    Z RS(   s#    Holder for a history transaction. c         C   s   t  |  |  _ | d |  _ | d |  _ | d |  _ | d |  _ | d |  _ | d |  _ | d |  _ d  |  _
 d  |  _ d  |  _ d  |  _ t |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   Ni    i   i   i   i   i   i   (   RE   RF   t   tidt   beg_timestampt   beg_rpmdbversiont   end_timestampt   end_rpmdbversiont   loginuidt   return_codeR   t
   _loaded_TWt
   _loaded_TDt
   _loaded_TSt   _loaded_PROBR   t   _have_loaded_CMDt   _loaded_CMDt
   _loaded_ERt
   _loaded_OTt   altered_lt_rpmdbt   altered_gt_rpmdb(   R;   RK   t   row(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR>      s$    									c         C   si   | d  k r d St |  j | j  } | r0 | St |  j | j  } | rO | St |  j | j  } | S(   Ni   (   R   RL   RZ   R\   RY   (   R;   RM   RN   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRO      s      c         C   s7   |  j  d  k r0 t |  j j |  j   |  _  n  |  j  S(   N(   R`   R   RP   RF   t   _old_with_pkgsRY   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getTransWith   s    !c         C   s7   |  j  d  k r0 t |  j j |  j   |  _  n  |  j  S(   N(   Ra   R   RP   RF   t   _old_data_pkgsRY   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getTransData   s    !c         C   s7   |  j  d  k r0 t |  j j |  j   |  _  n  |  j  S(   N(   Rb   R   RP   RF   t   _old_skip_pkgsRY   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getTransSkip   s    !RS   c         C   s
   |  j    S(   N(   Rl   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT      s    c         C   s
   |  j    S(   N(   Rn   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT      s    c         C   s
   |  j    S(   N(   Rp   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT      s    c         C   s7   |  j  d  k r0 t |  j j |  j   |  _  n  |  j  S(   N(   Rc   R   RP   RF   t   _old_problemsRY   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getProblems   s    !c         C   s
   |  j    S(   N(   Rr   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT      s    c         C   s4   |  j  s- t |  _  |  j j |  j  |  _ n  |  j S(   N(   Rd   R"   RF   t   _old_cmdlineRY   Re   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getCmdline   s    		c         C   s
   |  j    S(   N(   Rt   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT      s    c         C   s1   |  j  d  k r* |  j j |  j  |  _  n  |  j  S(   N(   Rf   R   RF   t   _load_errorsRY   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt
   _getErrors   s    c         C   s1   |  j  d  k r* |  j j |  j  |  _  n  |  j  S(   N(   Rg   R   RF   t   _load_outputRY   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt
   _getOutput   s    c         C   s
   |  j    S(   N(   Rv   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT      s    c         C   s
   |  j    S(   N(   Rx   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT      s    (   R?   R@   RU   R>   RO   Rl   Rn   Rp   RV   t
   trans_witht
   trans_datat
   trans_skipRr   t   rpmdb_problemsRt   t   cmdlineRv   Rx   t   errorst   output(    (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRX      s"   		
							t   YumMergedHistoryTransactionc           B   s   e  Z d    Z d   Z e d d    Z d   Z e d d    Z d   Z e d d    Z	 d   Z
 e d d	   Z e d
    Z e d    Z e d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z RS(   c         C   s   t  | j g  |  _ | g |  _ | j |  _ | j |  _ | j |  _ | j |  _ d  |  _	 d  |  _
 g  |  _ d  |  _ t |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  |  _ d  S(   N(   t   setRY   t   _merged_tidst   _merged_objsRZ   R[   R\   R]   R   R`   Ra   Rb   Rc   R   Rd   Re   Rf   Rg   Rh   Ri   (   R;   t   obj(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR>      s     									c         C   s   t  |  j  S(   N(   RP   R   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getAllTids  s    RS   c         C   s
   |  j    S(   N(   R   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT     s    c         C   sC   t  d   |  j D  } t |  d k r9 t |  d St |  S(   Nc         s   s   |  ] } | j  Vq d  S(   N(   R^   (   t   .0RY   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pys	   <genexpr>  s    i   i    (   R   R   R%   t   listRP   (   R;   RN   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getLoginUIDs  s    c         C   s
   |  j    S(   N(   R   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT     s    c         C   sa   t  d   |  j D  } t |  d k r; d | k r; d Sd | k rW | j d  n  t |  S(   Nc         s   s   |  ] } | j  Vq d  S(   N(   R_   (   R   RY   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pys	   <genexpr>  s    i   i    (   R   R   R%   t   removeRP   (   R;   t	   ret_codes(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _getReturnCodes  s    c         C   s
   |  j    S(   N(   R   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRT     s    c         C   ss   g  } t    } xW |  j D]L } xC | j D]8 } | j | k rD q) n  | j | j  | j |  q) Wq Wt |  S(   N(   R   R   Ry   R7   t   addR'   RP   (   R;   RN   t   filtR   t   pkg(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRl      s    	c         C   s1   | d k r |  j } n  |  j t |  j  | f S(   s6    Take a pkg and return the key for it's state lookup. N(   R   RC   R   R
   R6   (   R   RC   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _p2sk6  s    c         C   sM   i  } i  } x4 |  D], } t  j |  } | | | j <| | | <q W| | f S(   N(   R   R   R7   (   t   pkgst
   pkgtup2pkgt   pkgstate2pkgR   t   key(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt
   _list2dict?  s    c         C   s   t  |  j |  j |  j |  j |  j |  } |  j | _ |  j | _ t | j	 t
 k ra t | _ n  t | j	 t k r t | _ n  | S(   N(   RA   R   R6   R5   R3   R4   R8   RB   t   _sttxt2stcodeRC   t   TS_INSTALL_STATESR"   t   state_installedt   TS_REMOVE_STATESR   (   R   RC   t   npkg(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _conv_pkg_stateH  s    c         C   sB   t  |   t  d  k r* t j |   }  n  |  | k r: d  S| |  S(   Ni    i   (   i    i   (   t   typeR   R   R   (   t   skR   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _get_pkgS  s
    c         C   sh   |  j  | |  } | d  k r" d  S| |  j |  =|  j | |  } | | | j <| | |  j |  <d  S(   N(   R   R   R   R   R7   (   R;   R   t   nstateR   R   t   xpkg(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt	   _move_pkgZ  s    c            sP    f d   }   f d   }    f d   }    f d   }    f d       f d        f d   } i   i   x j  D]}  j | j  \   x t  j    D]} | \ } }	 }
 |
 d k r q n   | } x9 d D]. } |  j | |   } | d  k	 r	Pq	q	Wq t rGq | | k r| | d  | d k r| | d  qq | | k  r| | d  | d k r| | d  qq   |  | d k r | | d  q q Wt  j    j	  j    } x| D]} |  k s	|  k r-q	n   | }  | } t rJq	| j
 d k rx| j
 d k r  |  qq	| j
 d k rd } | j
 | k st  q	| j
 d k rUt rq| j
 d k r| | |  q| j
 d k r| | |  |  j | d  | j
  q| j
 d k r| | |  |  j | d  | j
  qq	| j
 d k r	t rmq| j
 d k r |  q| j
 d k r| | |  |  j | d  | j
  |  j | d  | j
  q| j
 d k r|  j | d   } | d  k r.|  j | d   } n  | d  k rX| j
 d k rOq	n  | } n  |  j | d   } | d  k r|  j | d   } n  | d  k r|  j | d   } n  | d  k rq	n  | | |  | | k r9d } d | j
 | j
 f k rd } n  | | k r,| | |  n   |  q| | k  rd } d } d | j
 | j
 f k rrd } n  | | k r| | |  n  | | |  qd } d } d | j
 | j
 f k rd } n  | | k r| | |  n  | | |  qq	q	Wx  D] }  |  | <qWx  D] }  |  | <q$Wq Wt  j    S(   Nc            s    j  |     S(   N(   R   (   R   (   t   fpkgstate2pkgR;   (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt
   _get_pkg_fd  s    c            s    j  |     S(   N(   R   (   R   (   t   npkgstate2pkgR;   (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt
   _get_pkg_nf  s    c            s    j  |  |     d  S(   N(   R   (   R   R   (   R   t   fpkgtup2pkgR;   (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _move_pkg_fh  s    c            s    j  |  |     d  S(   N(   R   (   R   R   (   R   t   npkgtup2pkgR;   (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _move_pkg_nj  s    c            s3    |  j  = j |   } |   k r/   | =n  d  S(   N(   R7   R   (   R   R   (   R   R   R;   (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _del1_nl  s    
c            s3    |  j  = j |   } |   k r/   | =n  d  S(   N(   R7   R   (   R   R   (   R   R   R;   (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _del1_fq  s    
c            s0   |  j  | j  k s t    |    |  d  S(   N(   R7   t   AssertionError(   t   fpkgR   (   R   R   (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _del2v  s    
R   R   R   s   True-Installs   Dep-InstallR   R   R   R   R   R   (   R   R   (   R   s   True-Installs   Dep-InstallR   (   R   R   R   R   R   (   R   R   (   R   s   True-Installs   Dep-InstallR   (   R   s   True-Installs   Dep-Install(   R   R   (   R   R   R   (   R   R   (   R   R   (   R   R   Rz   R   t   keysR   R   R   R   t   intersectionRC   R   RP   t   values(   R;   R   R   R   R   R   R   R   R   R6   RC   R   t   xstateR   t   sametupsR7   t   good_statest   xfpkgt   xnpkgt   nfstatet   nnstatet   x(    (   R   R   R   R   R   R   R;   s/   /usr/lib/python2.7/dist-packages/yum/history.pyRn   c  s    

 
!

 	  " 				c         C   sH   t    } x2 |  j D]' } x | j D] } | j |  q# Wq Wt |  S(   N(   R   R   R|   R   RP   (   R;   t   probsRY   t   prob(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRr     s
    	c         C   sf   g  } xO |  j  D]D } | j s% q n  | rD | d | j k rD q n  | j | j  q W| sb d  S| S(   Ni(   R   R}   R'   R   (   R;   t   cmdlinesRY   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRt     s    	c         C   s.   g  } x! |  j  D] } | j | j  q W| S(   N(   R   t   extendR~   (   R;   RN   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRv     s    c         C   s.   g  } x! |  j  D] } | j | j  q W| S(   N(   R   R   R   (   R;   RN   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRx     s    c         C   s   | j  |  j k r d  S|  j j | j   |  j j |  |  j j d t  |  j | j k ry | j |  _ | j |  _ n  |  j	 | j	 k  r | j	 |  _	 | j
 |  _
 n  d  S(   Nt   reverse(   RY   R   R   R   R'   t   sortR"   RZ   R[   R\   R]   (   R;   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   merge  s    N(   R?   R@   R>   R   RV   RY   R   R^   R   R_   Rl   t   staticmethodR   R   R   R   R   R   Rn   Rr   Rt   Rv   Rx   R   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR      s(   													t
   YumHistoryc           B   s  e  Z d  Z d e d  Z d   Z d   Z d   Z d   Z d. d  Z
 d   Z d	   Z d
   Z e d    Z d   Z d   Z d   Z d   Z d   Z d   Z g  g  d. d  Z d   Z d   Z d   Z d   Z d. d  Z d   Z d. d  Z d   Z d   Z d   Z  d   Z! d   Z" d   Z# g  d. e$ d   Z% e& d!  Z' d"   Z( e& d#  Z) d$ d% d& d' d( d) d* d+ g Z* d,   Z+ d-   Z, RS(/   s,    API for accessing the history sqlite data. t   /c         C   s  d  |  _ t j j   |  _ t j j |  j	 |  sY t j j | d |  |  j _
 n t j j d |  |  j _
 t |  j _ t |  j _ t j j |  j j
  s y t j |  j j
  Wn t t f k
 r } d  SXt |  j _ n* t j |  j j
 t j  rt |  j _ n  t j d |  j j
  } d  |  _ x t t |   D] } t j j |  } | t d  t d  !} | j d d  } t |  d k rqGn  y t t |  Wn t k
 rqGn Xd | d	 | d
 | d f |  _ | |  _ PqGW|  j d  k r|  j    n  |  j j
 d |  j |  j _! t j j |  j j!  sy t j |  j j!  Wqt t f k
 r} d  SXn* t j |  j j! t j  rt |  j _ n  d  S(   NR   s   %s/history-*-*-*.sqlites   history-s   .sqlitet   -i   i   s   %s-%s-%si    i   i   ("   R   t   _connR   R    t   GenericHoldert   conft   ost   patht   normpatht
   startswitht   db_pathR   t   writableR"   t   readablet   existst   makedirst   IOErrort   OSErrort   accesst   W_OKR   t   _db_filet   reversedRP   t   basenameR%   R9   t   mapt   intt
   ValueErrort   _db_datet   _create_db_filet
   addon_path(   R;   t   rootR   t   et   DBst   dt   fnamet   pieces(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR>   0  sP    	#	"	c         C   s   |  j    d  S(   N(   t   close(   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   __del__h  s    c         C   s   |  j  d  k r~ |  j j s d  Sy t j |  j  |  _  Wn* t j t j f k
 rd t	 |  j _ d  SXt
 |  j  j   d  n  |  j  j   S(   Ns   PRAGMA locking_mode = EXCLUSIVE(   R   R   R   R   R   t   connectR   t   OperationalErrort   DatabaseErrorR   R   t   cursor(   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _get_cursork  s    c         C   s   |  j  j   S(   N(   R   t   commit(   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _commit  s    c         C   s,   |  j  d  k	 r( |  j  j   d  |  _  n  d  S(   N(   R   R   R   (   R;   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR     s    c      	   C   s5  |  j    } t | d |  xd | D]\ \ } } | d  k rK | d  k rK | S| d  k r] q# n  | d  k ro q# n  | | k r# | Sq# W| \ } } } }	 }
 t |  t |  t |  t |	  t |
  f \ } } } }	 }
 | d  k	 rt | d | | | |	 |
 | f  } n! t | d | | | |	 |
 f  } | j S(   Ns   SELECT pkgtupid, checksum FROM pkgtups
                           WHERE name=? AND arch=? AND
                                 epoch=? AND version=? AND release=?s   INSERT INTO pkgtups
                                (name, arch, epoch, version, release, checksum)
                                VALUES (?, ?, ?, ?, ?, ?)s   INSERT INTO pkgtups
                                (name, arch, epoch, version, release)
                                VALUES (?, ?, ?, ?, ?)(   R   R   R   R   t	   lastrowid(   R;   R7   R<   t   curt   sql_pkgtupidt   sql_checksumt   nt   aR   t   vt   rt   res(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _pkgtup2pid  s,    
0c         C   sR   | j    } | d  k	 r? d t | d  t | d  f } n  |  j | j |  S(   Ns   %s:%si    i   (   t   returnIdSumR   t   strR   R7   (   R;   t   pot   csum(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt	   _apkg2pid  s    'c         C   sS   d  } | j } d | k r@ d | k r@ d | j | j f } n  |  j | j |  S(   Nt   checksum_typet   checksum_datas   %s:%s(   R   t
   yumdb_infoR   R   R   R7   (   R;   R   R   t   yumdb(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt	   _ipkg2pid  s
    	c         C   sK   t  | t  r |  j |  St  | t  r8 |  j |  S|  j | j d   S(   N(   t
   isinstanceR   R   R   R   R   R7   R   (   R;   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   pkg2pid  s
    c         C   s   d  } |  j t t f k rB |  j r- d } qB |  j rB d } qB n  |  j t k rf |  j rf d } qf n  | d  k r t j	 |  j  } | d k r |  j
 r d } q n  | S(   NR   R   R   R   s   Dep-Install(   R   t   output_statet
   TS_INSTALLt   TS_TRUEINSTALLt	   reinstallt
   downgradest   TS_ERASEt   downgraded_byt   _stcode2sttxtt   gett   isDep(   t   txmbrRC   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   txmbr2state  s    				c         C   s>   |  j    } | d  k r d  St | d |  j | f  } | j S(   Nsk   INSERT INTO trans_with_pkgs
                         (tid, pkgtupid)
                         VALUES (?, ?)(   R   R   R   t   _tidR   (   R;   t   pidR   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   trans_with_pid  s    c         C   sK   |  j    } | d  k s% |  j   r) d  St | d |  j | f  } | j S(   Nsk   INSERT INTO trans_skip_pkgs
                         (tid, pkgtupid)
                         VALUES (?, ?)(   R   R   t   _update_db_file_2R   R  R   (   R;   R  R   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   trans_skip_pid  s    c         C   ss   | d  k	 s t  t |  d  s. | d  k r2 d  S|  j   } | d  k rN d  St | d |  j | | f  } | j S(   NR  su   INSERT INTO trans_data_pkgs
                         (tid, pkgtupid, state)
                         VALUES (?, ?, ?)(   R   R   t   hasattrR   R   R  R   (   R;   R  RC   R   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   trans_data_pid_beg  s    c         C   sk   t  |  d  s | d  k r  d  S|  j   } | d  k r< d  St | d d |  j | | f  } |  j   d  S(   NR  s   UPDATE trans_data_pkgs SET done = ?
                         WHERE tid = ? AND pkgtupid = ? AND state = ?
                         t   TRUE(   R  R   R   R   R  R   (   R;   R  RC   R   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   trans_data_pid_end  s    c   
      C   s_  t  |  d  s d  S|  j   } | d  k s8 |  j   r< d  St | j    } t | d |  j | j | f  } | j	 } | s | Si  } | j
 } | | | j <| j d k r x! | j D] } | | | j <q Wn  | j d k r | j | | j j <n  xb | j   D]T } |  j |  } | j | j
 j k r6d }	 n d }	 t | d | | |	 f  } qW| S(   NR  sw   INSERT INTO trans_rpmdb_problems
                         (tid, problem, msg)
                         VALUES (?, ?, ?)t	   conflictst
   duplicatesR  t   FALSEs}   INSERT INTO trans_prob_pkgs
                             (rpid, pkgtupid, main)
                             VALUES (?, ?, ?)(   R  R   R   R  R   t   __str__R   R  RH   R   R   R7   R  t	   duplicateR   R  (
   R;   RH   R   t   uproblemR   RG   R   R   R  t   main(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _trans_rpmdb_problem  s:    				c         C   sd   t  |  d  s d  S|  j   } | d  k s8 |  j   r< d  St | d |  j t |  f  } | j S(   NR  sh   INSERT INTO trans_cmdline
                         (tid, cmdline)
                         VALUES (?, ?)(   R  R   R   R  R   R  R   R   (   R;   R}   R   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _trans_cmdline!  s    c         C   s<  |  j    } | d  k r d  St | d t t j    t |  t j j   f  } | j	 |  _
 x* | D]" }	 |  j |	  }
 |  j |
  qe Wx? | D]7 } |  j | j  }
 |  j |  } |  j |
 |  q Wx* | D]" }	 |  j |	  }
 |  j |
  q Wx | D] } |  j |  qW| r.|  j |  n  |  j   d  S(   Ns   INSERT INTO trans_beg
                            (timestamp, rpmdb_version, loginuid)
                            VALUES (?, ?, ?)(   R   R   R   R   t   timeR   R   R    t   getloginuidR   R  R   R  R  R   R  R  R  R  R  R   (   R;   t   rpmdb_versiont
   using_pkgst   txmbrst   skip_packagesR|   R}   R   R   R   R  R  RC   RH   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   beg-  s.    	c         C   s`   |  j    } | d  k r d  Sx3 | D]+ } t |  } t | d |  j | f  q# W|  j   d  S(   NsJ   INSERT INTO trans_error
                          (tid, msg) VALUES (?, ?)(   R   R   R   R   R  R   (   R;   R~   R   t   error(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _log_errorsO  s    c         C   s   | d k s t |  d  r  d S|  j   } | d k r< d Sx9 | j   D]+ } t |  } t | d |  j | f  qI W|  j   d S(   s6    Note that data can be either a real pkg. ... or not. R  NsS   INSERT INTO trans_script_stdout
                          (tid, line) VALUES (?, ?)(   R   R  R   t
   splitlinesR   R   R  R   (   R;   t   datat   msgR   R'  (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   log_scriptlet_outputZ  s    c         C   sK   |  j    } t | d | f  g  } x | D] } | j | d  q, W| S(   Nsf   SELECT msg FROM trans_error
                      WHERE tid = ?
                      ORDER BY mid ASCi    (   R   R   R'   (   R;   RY   R   RN   Rj   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRu   i  s    c         C   sK   |  j    } t | d | f  g  } x | D] } | j | d  q, W| S(   Nso   SELECT line FROM trans_script_stdout
                      WHERE tid = ?
                      ORDER BY lid ASCi    (   R   R   R'   (   R;   RY   R   RN   Rj   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRw   t  s    c         C   s   | s | s t   t |  d  s& d  S|  j   } | d  k rB d  St | d |  j t t j    t |  | f  } |  j	   | s t | d d |  j f  |  j	   n  | d  k	 r |  j
 |  n  |  ` d  S(   NR  s   INSERT INTO trans_end
                            (tid, timestamp, rpmdb_version, return_code)
                            VALUES (?, ?, ?, ?)sK   UPDATE trans_data_pkgs SET done = ?
                          WHERE tid = ?R  (   R   R  R   R   R   R  R   R   R   R   R(  (   R;   R"  R_   R~   R   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   end  s$    	
c         C   s  t  |  d  s t S| s t S| s' t S|  j j d t |  j  } |  j j r t j j	 |  r y t j
 | d d Wq t t f k
 r } t SXn  | j d d  } | d | } y: t | d  } | j t |   | j   | j   Wn t t f k
 r} t SXt S(   s   append data to an arbitrary-named file in the history 
           addon_path/transaction id location,
           returns True if write succeeded, False if notR  R   t   modei  t   _s   w+(   R  R   R   R   R   R  R   R   R   R   R   R   R   t   replacet   opent   writeR	   t   flushR   R"   (   R;   t   datanameR*  t   tid_dirR   t   safenamet   data_fnt   fo(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   write_addon_data  s,    
c   	      C   s   |  j  j d t |  d } t j | d  } g  | D] } | j | d  ^ q8 } | s` | S| | k rp d  St | | d  } | j   } | j   | S(   NR   R   t    R   (	   R   R   R   R   R0  R   R1  t   readR   (	   R;   RY   t   itemt   hist_and_tidt
   addon_infot   it   addon_namesR8  R*  (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   return_addon_data  s    %
c      	   C   sz   |  j    } t | d | f  g  } xN | D]F } t | d | d | d | d | d | d  } | j |  q, W| S(   Ns   SELECT name, arch, epoch, version, release, checksum
                      FROM trans_with_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE tid = ?
                      ORDER BY name ASC, epoch ASCi    i   i   i   i   i   (   R   R   R1   R'   (   R;   RY   R   RN   Rj   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRk     s    3c      
   C   s   |  j    } t | d | f  g  } x | D] } t | d | d | d | d | d | d | d  } | d	 d
 k | _ d  | _ t | j t k r t	 | _ n  t | j t
 k r t | _ n  | j |  q, W| S(   Ns	  SELECT name, arch, epoch, version, release,
                             checksum, done, state
                      FROM trans_data_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE tid = ?
                      ORDER BY name ASC, epoch ASC, state DESCi    i   i   i   i   i   i   i   R  (   R   R   RA   RB   R   R   R   RC   R   R"   R   R   R'   (   R;   RY   R   RN   Rj   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRm     s    &	c      	   C   s   |  j    } | d  k s% |  j   r) g  St | d | f  g  } xN | D]F } t | d | d | d | d | d | d  } | j |  qI W| S(   Ns   SELECT name, arch, epoch, version, release, checksum
                      FROM trans_skip_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE tid = ?
                      ORDER BY name ASC, epoch ASCi    i   i   i   i   i   (   R   R   R  R   R1   R'   (   R;   RY   R   RN   Rj   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRo     s    3c      	   C   s   |  j    } | d  k s% |  j   r) g  St | d | f  g  } xa | D]Y } t | d | d | d | d | d | d  } | d d	 k | _ | j |  qI W| S(
   Ns   SELECT name, arch, epoch, version, release, checksum, main
                      FROM trans_prob_pkgs JOIN pkgtups USING(pkgtupid)
                      WHERE rpid = ?
                      ORDER BY name ASC, epoch ASCi    i   i   i   i   i   i   R  (   R   R   R  R   R1   R  R'   (   R;   RG   R   RN   Rj   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRQ      s    3c         C   s   |  j    } | d  k s% |  j   r) g  St | d | f  g  } x< | D]4 } t |  | d | d | d  } | j |  qI W| S(   Ns   SELECT rpid, problem, msg
                      FROM trans_rpmdb_problems
                      WHERE tid = ?
                      ORDER BY problem ASC, rpid ASCi    i   i   (   R   R   R  R   RD   R'   (   R;   RY   R   RN   Rj   R   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRq     s    !c         C   s\   |  j    } | d  k s% |  j   r) d  St | d | f  g  } x | D] } | d SWd  S(   Ns[   SELECT cmdline
                      FROM trans_cmdline
                      WHERE tid = ?i    (   R   R   R  R   (   R;   RY   R   RN   Rj   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyRs     s    	c         C   s  |  j    } | d k r g  Sd } | s1 d } n  d } | r t |  t j j k r t t |   } } | d d j d g t |   7} n  | d 7} | d k	 r | d t	 |  7} n  t
 | | |  g  } i  } xo | D]g }	 | rt |  t j j k r|	 d | k rq qn  t |  |	  }
 |
 | |	 d <| j |
  q Wd	 } | j   } t |  t j j k rt
 | |  n4 | d d j d g t |   7} t
 | | |  xc | D][ }	 |	 d | k rqn  |	 d
 | |	 d _ |	 d | |	 d _ |	 d | |	 d _ qWd } x t |  D] }
 |
 j } d } | d k	 ra| j } n  | d k s| d k s| j d
 |
 j k rn3 | | k rt |
 _ t | _ n t |
 _ t | _ |
 } q4W| S(   s    Return a list of the last transactions, note that this includes
            partial transactions (ones without an end transaction). s]  SELECT tid,
                         trans_beg.timestamp AS beg_ts,
                         trans_beg.rpmdb_version AS beg_rv,
                         trans_end.timestamp AS end_ts,
                         trans_end.rpmdb_version AS end_rv,
                         loginuid, return_code
                  FROM trans_beg JOIN trans_end USING(tid)s  SELECT tid,
                             trans_beg.timestamp AS beg_ts,
                             trans_beg.rpmdb_version AS beg_rv,
                             NULL, NULL,
                             loginuid, NULL
                      FROM trans_begs    WHERE tid IN (%s)s   , t   ?s    ORDER BY beg_ts DESC, tid ASCs    LIMIT i    s   SELECT tid,
                         trans_end.timestamp AS end_ts,
                         trans_end.rpmdb_version AS end_rv,
                         return_code
                  FROM trans_endi   i   i   N(   R   R   R%   R   t	   constantsR$   R   R   t   joinR   R   RX   R'   R   R\   R]   R_   R   R[   RY   R"   Rh   Ri   R   (   R;   t   tidst   limitt   complete_transactions_onlyR   t   sqlt   paramsRN   t   tid2objRj   R   t   last   cur_rvt   las_rv(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   old,  sd    	'
	$	.			
c         C   s?   |  j  g  d |  } | s d St |  d k s7 t  | d S(   si    This is the last full transaction. So any incomplete transactions
            do not count, by default. i   i    N(   RN  R   R%   R   (   R;   RG  RN   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   lasty  s
    c         c   s   |  j    } t } g  } g  } xi | D]a \ } }	 xR | D]J }
 | r^ | j d |
 |	 f  n | j d |
 |	 f  | j |  q8 Wq% W| s t  | d j |  7} t | | |  x | D] } | Vq Wd S(   s2   Yields all the package data for the given params. s   %s LIKE ?%ss   %s %s ?s    OR N(   R   t   _FULL_PARSE_QUERY_BEGR'   R   RD  R   (   R;   R(   R*   R)   R   t   qsqlt   pat_sqlst   pat_datat   patternt   restt   fieldR   (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   _yieldSQLDataList  s    c         C   s  |  j    } | d k r t   St | |  } | \ } } } } g  }	 t   }
 | r x |  j | | |  D] } |
 j | d  qk Wn t } | s t } n  x{ t j	 j
 | |  D]d } t | |  } | \ } } } } | s t  x. |  j | | |  D] } |
 j | d  q Wq Wd } | d d j d g t |
   7} t |
  } t   } t |  t j j k rt | d  x2 | D]* } | d | k r| j | d  qqW| S| s| St | | |  x | D] } | j | d  qW| S(   s{    Search for history transactions which contain specified
            packages al. la. "yum list". Returns transaction ids. i    s2   SELECT tid FROM trans_data_pkgs WHERE pkgtupid IN s   (%s)t   ,RB  s   SELECT tid FROM trans_data_pkgsN(   R   R   R   R0   RW  R   R#   R$   R   R    t   seq_max_splitR   RD  R%   R   RC  R   (   R;   R(   R)   R   R*  R+   t	   npatternsR*   t   namesRN   t	   pkgtupidsRj   R-   t   npsRH  RI  RE  (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   search  sF    		$	s    CREATE TABLE trans_skip_pkgs (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups);
sk    CREATE TABLE trans_cmdline (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     cmdline TEXT NOT NULL);
s    CREATE TABLE trans_rpmdb_problems (
     rpid INTEGER PRIMARY KEY,
     tid INTEGER NOT NULL REFERENCES trans_beg,
     problem TEXT NOT NULL, msg TEXT NOT NULL);
s    CREATE TABLE trans_prob_pkgs (
     rpid INTEGER NOT NULL REFERENCES trans_rpmdb_problems,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups,
     main BOOL NOT NULL DEFAULT FALSE);
s'   CREATE VIEW vtrans_data_pkgs AS
     SELECT tid,name,epoch,version,release,arch,pkgtupid,
            state,done,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM trans_data_pkgs JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
s   CREATE VIEW vtrans_with_pkgs AS
     SELECT tid,name,epoch,version,release,arch,pkgtupid,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM trans_with_pkgs JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
s   CREATE VIEW vtrans_skip_pkgs AS
     SELECT tid,name,epoch,version,release,arch,pkgtupid,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM trans_skip_pkgs JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
s   CREATE VIEW vtrans_prob_pkgs2 AS
     SELECT tid,rpid,name,epoch,version,release,arch,pkgtups.pkgtupid,
            main,problem,msg,
            name || '-' || epoch || ':' ||
            version || '-' || release || '.' || arch AS nevra
     FROM (SELECT * FROM trans_prob_pkgs,trans_rpmdb_problems WHERE
           trans_prob_pkgs.rpid=trans_rpmdb_problems.rpid)
           JOIN pkgtups USING(pkgtupid)
     ORDER BY name;
c         C   s   |  j  j s t St |  d  r& |  j S|  j   } | d k rB t St | d  x: | D] } PqV Wx |  j D] } | j	 |  qk W|  j
   t |  _ t S(   s;    Update to version 2 of history, includes trans_skip_pkgs. t   _cached_updated_2s"   PRAGMA table_info(trans_skip_pkgs)N(   R   R   R   R  R_  R   R   R   t   _update_ops_2t   executeR   R"   (   R;   R   t   obt   op(    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR    s    
	c         C   sU  t  j d  |  _ d |  j j d |  j d f } |  j | k r t j | | d  t j j	 | d  r t j | d | d  q n  | |  _ |  j j
 r t j j	 |  j  r t j |  j t j d  } t j |  n  |  j   } d	 d
 d d d d d d g } x | D] } | j |  qWx |  j D] } | j |  q0W|  j   d S(   s6    Create a new history DB file, populating tables etc. s   %Y-%m-%ds   %s/%s-%s.%sRK   R   s   .olds   -journals   -journal.oldi  s    CREATE TABLE trans_beg (
     tid INTEGER PRIMARY KEY,
     timestamp INTEGER NOT NULL, rpmdb_version TEXT NOT NULL,
     loginuid INTEGER);
s    CREATE TABLE trans_end (
     tid INTEGER PRIMARY KEY REFERENCES trans_beg,
     timestamp INTEGER NOT NULL, rpmdb_version TEXT NOT NULL,
     return_code INTEGER NOT NULL);
s    CREATE TABLE trans_with_pkgs (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups);
s    CREATE TABLE trans_error (
     mid INTEGER PRIMARY KEY,
     tid INTEGER NOT NULL REFERENCES trans_beg,
     msg TEXT NOT NULL);
s    CREATE TABLE trans_script_stdout (
     lid INTEGER PRIMARY KEY,
     tid INTEGER NOT NULL REFERENCES trans_beg,
     line TEXT NOT NULL);
s    CREATE TABLE trans_data_pkgs (
     tid INTEGER NOT NULL REFERENCES trans_beg,
     pkgtupid INTEGER NOT NULL REFERENCES pkgtups,
     done BOOL NOT NULL DEFAULT FALSE, state TEXT NOT NULL);
s    CREATE TABLE pkgtups (
     pkgtupid INTEGER PRIMARY KEY,     name TEXT NOT NULL, arch TEXT NOT NULL,
     epoch TEXT NOT NULL, version TEXT NOT NULL, release TEXT NOT NULL,
     checksum TEXT);
sO    CREATE INDEX i_pkgtup_naevr ON pkgtups (name, arch, epoch, version, release);
N(   R   t   strftimeR   R   R   R   R   t   renameR   R   R   R1  t   O_CREATR   R   Ra  R`  R   (   R;   R   R8  R   t   opsRc  (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR     s6    
	"	N(-   R?   R@   RU   t   _history_dirR>   R   R   R   R   R   R   R   R   R  R   R  R  R  R  R  R  R  R&  R(  R,  Ru   Rw   R-  R9  RA  Rk   Rm   Ro   RQ   Rq   Rs   R   RN  R"   RO  RW  R^  R`  R  R   (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyR   -  s\   8								
				*	!					)						M		4			s  
SELECT pkgtupid,name,epoch,version,release,arch,
  name || "." || arch AS sql_nameArch,
  name || "-" || version || "-" || release || "." || arch AS sql_nameVerRelArch,
  name || "-" || version AS sql_nameVer,
  name || "-" || version || "-" || release AS sql_nameVerRel,
  epoch || ":" || name || "-" || version || "-" || release || "." || arch AS sql_envra,
  name || "-" || epoch || ":" || version || "-" || release || "." || arch AS sql_nevra
  FROM pkgtups
  WHERE 
(+   R   R   t   os.pathR   RE   R    t   sqlutilsR   R   R   t   yum.miscR    t   yum.constantsR   t   yum.packagesR   R   R   t   yum.i18nR   R	   t   rpmUtils.archR
   Rh  t	   TS_UPDATEt
   TS_UPDATEDR  R  R  t   TS_OBSOLETEDt   TS_OBSOLETINGR	  R   R   R   R0   R1   RA   RD   RX   R   R   RP  (    (    (    s/   /usr/lib/python2.7/dist-packages/yum/history.pyt   <module>   sR   




'
S >   D                                                                                                                                                                                                                                                                                                                                                                                                               usr/lib/python2.7/dist-packages/yum/i18n.py                                                         0100644 0000000 0000000 00000046632 12451005146 017067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


def dummy_wrapper(str):
    '''
    Dummy Translation wrapper, just returning the same string.
    '''
    return to_unicode(str)

def dummyP_wrapper(str1, str2, n):
    '''
    Dummy Plural Translation wrapper, just returning the singular or plural
    string.
    '''
    if n == 1:
        return str1
    else:
        return str2

# This is ported from ustr_utf8_* which I got from:
#     http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
#  I've tried to leave it close to the original C (same names etc.) so that
# it is easy to read/compare both versions...

# ----------------------------- BEG utf8 -----------------------------
# This is an implementation of wcwidth() and wcswidth() (defined in
# IEEE Std 1002.1-2001) for Unicode.
#
# http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html
# http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
#
# In fixed-width output devices, Latin characters all occupy a single
# "cell" position of equal width, whereas ideographic CJK characters
# occupy two such cells. Interoperability between terminal-line
# applications and (teletype-style) character terminals using the
# UTF-8 encoding requires agreement on which character should advance
# the cursor by how many cell positions. No established formal
# standards exist at present on which Unicode character shall occupy
# how many cell positions on character terminals. These routines are
# a first attempt of defining such behavior based on simple rules
# applied to data provided by the Unicode Consortium.
#
# [...]
#
# Markus Kuhn -- 2007-05-26 (Unicode 5.0)
#
# Permission to use, copy, modify, and distribute this software
# for any purpose and without fee is hereby granted. The author
# disclaims all warranties with regard to this software.
#
# Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c

def __utf8_bisearch(ucs, table):
    """ auxiliary function for binary search in interval table. """

    min = 0
    max = len(table) - 1
    if ucs < table[min][0] or ucs > table[max][1]:
        return False

    while max >= min:
        mid = (min + max) / 2
        if ucs > table[mid][1]:
            min = mid + 1
        elif ucs < table[mid][0]:
            max = mid - 1
        else:
            return True

    return False


# sorted list of non-overlapping intervals of non-spacing characters
# generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c"
__combining = (
    ( 0x0300, 0x036F ), ( 0x0483, 0x0486 ), ( 0x0488, 0x0489 ),
    ( 0x0591, 0x05BD ), ( 0x05BF, 0x05BF ), ( 0x05C1, 0x05C2 ),
    ( 0x05C4, 0x05C5 ), ( 0x05C7, 0x05C7 ), ( 0x0600, 0x0603 ),
    ( 0x0610, 0x0615 ), ( 0x064B, 0x065E ), ( 0x0670, 0x0670 ),
    ( 0x06D6, 0x06E4 ), ( 0x06E7, 0x06E8 ), ( 0x06EA, 0x06ED ),
    ( 0x070F, 0x070F ), ( 0x0711, 0x0711 ), ( 0x0730, 0x074A ),
    ( 0x07A6, 0x07B0 ), ( 0x07EB, 0x07F3 ), ( 0x0901, 0x0902 ),
    ( 0x093C, 0x093C ), ( 0x0941, 0x0948 ), ( 0x094D, 0x094D ),
    ( 0x0951, 0x0954 ), ( 0x0962, 0x0963 ), ( 0x0981, 0x0981 ),
    ( 0x09BC, 0x09BC ), ( 0x09C1, 0x09C4 ), ( 0x09CD, 0x09CD ),
    ( 0x09E2, 0x09E3 ), ( 0x0A01, 0x0A02 ), ( 0x0A3C, 0x0A3C ),
    ( 0x0A41, 0x0A42 ), ( 0x0A47, 0x0A48 ), ( 0x0A4B, 0x0A4D ),
    ( 0x0A70, 0x0A71 ), ( 0x0A81, 0x0A82 ), ( 0x0ABC, 0x0ABC ),
    ( 0x0AC1, 0x0AC5 ), ( 0x0AC7, 0x0AC8 ), ( 0x0ACD, 0x0ACD ),
    ( 0x0AE2, 0x0AE3 ), ( 0x0B01, 0x0B01 ), ( 0x0B3C, 0x0B3C ),
    ( 0x0B3F, 0x0B3F ), ( 0x0B41, 0x0B43 ), ( 0x0B4D, 0x0B4D ),
    ( 0x0B56, 0x0B56 ), ( 0x0B82, 0x0B82 ), ( 0x0BC0, 0x0BC0 ),
    ( 0x0BCD, 0x0BCD ), ( 0x0C3E, 0x0C40 ), ( 0x0C46, 0x0C48 ),
    ( 0x0C4A, 0x0C4D ), ( 0x0C55, 0x0C56 ), ( 0x0CBC, 0x0CBC ),
    ( 0x0CBF, 0x0CBF ), ( 0x0CC6, 0x0CC6 ), ( 0x0CCC, 0x0CCD ),
    ( 0x0CE2, 0x0CE3 ), ( 0x0D41, 0x0D43 ), ( 0x0D4D, 0x0D4D ),
    ( 0x0DCA, 0x0DCA ), ( 0x0DD2, 0x0DD4 ), ( 0x0DD6, 0x0DD6 ),
    ( 0x0E31, 0x0E31 ), ( 0x0E34, 0x0E3A ), ( 0x0E47, 0x0E4E ),
    ( 0x0EB1, 0x0EB1 ), ( 0x0EB4, 0x0EB9 ), ( 0x0EBB, 0x0EBC ),
    ( 0x0EC8, 0x0ECD ), ( 0x0F18, 0x0F19 ), ( 0x0F35, 0x0F35 ),
    ( 0x0F37, 0x0F37 ), ( 0x0F39, 0x0F39 ), ( 0x0F71, 0x0F7E ),
    ( 0x0F80, 0x0F84 ), ( 0x0F86, 0x0F87 ), ( 0x0F90, 0x0F97 ),
    ( 0x0F99, 0x0FBC ), ( 0x0FC6, 0x0FC6 ), ( 0x102D, 0x1030 ),
    ( 0x1032, 0x1032 ), ( 0x1036, 0x1037 ), ( 0x1039, 0x1039 ),
    ( 0x1058, 0x1059 ), ( 0x1160, 0x11FF ), ( 0x135F, 0x135F ),
    ( 0x1712, 0x1714 ), ( 0x1732, 0x1734 ), ( 0x1752, 0x1753 ),
    ( 0x1772, 0x1773 ), ( 0x17B4, 0x17B5 ), ( 0x17B7, 0x17BD ),
    ( 0x17C6, 0x17C6 ), ( 0x17C9, 0x17D3 ), ( 0x17DD, 0x17DD ),
    ( 0x180B, 0x180D ), ( 0x18A9, 0x18A9 ), ( 0x1920, 0x1922 ),
    ( 0x1927, 0x1928 ), ( 0x1932, 0x1932 ), ( 0x1939, 0x193B ),
    ( 0x1A17, 0x1A18 ), ( 0x1B00, 0x1B03 ), ( 0x1B34, 0x1B34 ),
    ( 0x1B36, 0x1B3A ), ( 0x1B3C, 0x1B3C ), ( 0x1B42, 0x1B42 ),
    ( 0x1B6B, 0x1B73 ), ( 0x1DC0, 0x1DCA ), ( 0x1DFE, 0x1DFF ),
    ( 0x200B, 0x200F ), ( 0x202A, 0x202E ), ( 0x2060, 0x2063 ),
    ( 0x206A, 0x206F ), ( 0x20D0, 0x20EF ), ( 0x302A, 0x302F ),
    ( 0x3099, 0x309A ), ( 0xA806, 0xA806 ), ( 0xA80B, 0xA80B ),
    ( 0xA825, 0xA826 ), ( 0xFB1E, 0xFB1E ), ( 0xFE00, 0xFE0F ),
    ( 0xFE20, 0xFE23 ), ( 0xFEFF, 0xFEFF ), ( 0xFFF9, 0xFFFB ),
    ( 0x10A01, 0x10A03 ), ( 0x10A05, 0x10A06 ), ( 0x10A0C, 0x10A0F ),
    ( 0x10A38, 0x10A3A ), ( 0x10A3F, 0x10A3F ), ( 0x1D167, 0x1D169 ),
    ( 0x1D173, 0x1D182 ), ( 0x1D185, 0x1D18B ), ( 0x1D1AA, 0x1D1AD ),
    ( 0x1D242, 0x1D244 ), ( 0xE0001, 0xE0001 ), ( 0xE0020, 0xE007F ),
    ( 0xE0100, 0xE01EF ))

def __utf8_ucp_width(ucs):
    """ Get the textual width of a ucs character. """

    # test for 8-bit control characters
    if ucs == 0:
        return 0

    if ucs < 32 or (ucs >= 0x7f and ucs < 0xa0):
        return (-1)

    if __utf8_bisearch(ucs, __combining):
        return 0

    # if we arrive here, ucs is not a combining or C0/C1 control character

    return (1 + 
      (ucs >= 0x1100 and
       (ucs <= 0x115f or                     # Hangul Jamo init. consonants
        ucs == 0x2329 or ucs == 0x232a or
        (ucs >= 0x2e80 and ucs <= 0xa4cf and
         ucs != 0x303f) or                   # CJK ... Yi
        (ucs >= 0xac00 and ucs <= 0xd7a3) or # Hangul Syllables
        (ucs >= 0xf900 and ucs <= 0xfaff) or # CJK Compatibility Ideographs
        (ucs >= 0xfe10 and ucs <= 0xfe19) or # Vertical forms
        (ucs >= 0xfe30 and ucs <= 0xfe6f) or # CJK Compatibility Forms
        (ucs >= 0xff00 and ucs <= 0xff60) or # Fullwidth Forms
        (ucs >= 0xffe0 and ucs <= 0xffe6) or
        (ucs >= 0x20000 and ucs <= 0x2fffd) or
        (ucs >= 0x30000 and ucs <= 0x3fffd))))


def __utf8_iter_ints(msg):
    for byte in to_utf8(msg):
        yield ord(byte)
def __utf8_iter_ucs(msg):
    uiter = __utf8_iter_ints(msg)
    for byte0 in uiter:
        if byte0 < 0x80:             # 0xxxxxxx
            yield (byte0, 1)
        elif (byte0 & 0xe0) == 0xc0: # 110XXXXx 10xxxxxx
            byte1 = uiter.next()
            if (((byte1 & 0xc0) != 0x80) or
                ((byte0 & 0xfe) == 0xc0)):                          # overlong?
                yield (None, 2)
                return
            yield ((((byte0 & 0x1f) << 6) | (byte1 & 0x3f)), 2)
        elif (byte0 & 0xf0) == 0xe0: # 1110XXXX 10Xxxxxx 10xxxxxx
            byte1 = uiter.next()
            byte2 = uiter.next()
            if (((byte1 & 0xc0) != 0x80) or ((byte2 & 0xc0) != 0x80) or
                ((byte0 == 0xe0) and ((byte1 & 0xe0) == 0x80)) or   # overlong?
                ((byte0 == 0xed) and ((byte1 & 0xe0) == 0xa0)) or   # surrogate?
                ((byte0 == 0xef) and  (byte1 == 0xbf) and
                 ((byte2 & 0xfe) == 0xbe))): # U+FFFE or U+FFFF?
                yield (None, 3)
                return
            yield ((((byte0 & 0x0f) << 12) | ((byte1 & 0x3f) << 6) |
                   (byte2 & 0x3f)), 3)
        elif (byte0 & 0xf8) == 0xf0: # 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx
            byte1 = uiter.next()
            byte2 = uiter.next()
            byte3 = uiter.next()
            if (((byte1 & 0xc0) != 0x80) or
                ((byte2 & 0xc0) != 0x80) or
                ((byte3 & 0xc0) != 0x80) or
                ((byte0 == 0xf0) and ((byte1 & 0xf0) == 0x80)) or # overlong?
                ((byte0 == 0xf4) and (byte1 > 0x8f)) or           # > U+10FFFF?
                (byte0 > 0xf4)):                                  # > U+10FFFF?
                yield (None, 4)
                return

            yield ((((byte0 & 0x07) << 18) | ((byte1 & 0x3f) << 12) |
                    ((byte2 & 0x3f) <<  6) |  (byte3 & 0x3f)), 4)
        else:
            yield (None, 1)
            return

def utf8_width(msg):
    """ Get the textual width of a utf8 string. """
    ret = 0
    for (ucs, bytes) in __utf8_iter_ucs(msg):
        if ucs is None:
            ret += bytes # Ugly ... should not feed bad utf8
        else:
            ret += __utf8_ucp_width(ucs)
    return ret

def utf8_width_chop(msg, chop=None):
    """ Return the textual width of a utf8 string, chopping it to a specified
        value. This is what you want to use instead of %.*s, as it does the
        "right" thing with regard to utf-8 sequences. Eg.
        "%.*s" % (10, msg)   <= becomes => "%s" % (utf8_width_chop(msg, 10)) """

    if chop is None or utf8_width(msg) <= chop:
        return utf8_width(msg), msg

    ret = 0
    passed_unicode = isinstance(msg, unicode)
    msg_bytes = 0
    msg = to_utf8(msg)
    for (ucs, bytes) in __utf8_iter_ucs(msg):
        if ucs is None:
            width = bytes # Ugly ... should not feed bad utf8
        else:
            width = __utf8_ucp_width(ucs)

        if chop is not None and (ret + width) > chop:
            msg = msg[:msg_bytes]
            break
        ret += width
        msg_bytes += bytes

    if passed_unicode:
        msg = to_unicode(msg)

    return ret, msg

def utf8_width_fill(msg, fill, chop=None, left=True, prefix='', suffix=''):
    """ Expand a utf8 msg to a specified "width" or chop to same.
        Expansion can be left or right. This is what you want to use instead of
        %*.*s, as it does the "right" thing with regard to utf-8 sequences.
        prefix and suffix should be used for "invisible" bytes, like
        highlighting.
        Eg.
        "%-*.*s" % (10, 20, msg)
           <= becomes =>
        "%s" % (utf8_width_fill(msg, 10, 20)).

        "%20.10s" % (msg)
           <= becomes =>
        "%s" % (utf8_width_fill(msg, 20, 10, left=False)).

        "%s%.10s%s" % (prefix, msg, suffix)
           <= becomes =>
        "%s" % (utf8_width_fill(msg, 0, 10, prefix=prefix, suffix=suffix)).
        """
    passed_msg = msg
    width, msg = utf8_width_chop(msg, chop)

    if width >= fill:
        if prefix or suffix:
            msg = ''.join([prefix, msg, suffix])
    else:
        extra = " " * (fill - width)
        if left:
            msg = ''.join([prefix, msg, suffix, extra])
        else:
            msg = ''.join([extra, prefix, msg, suffix])

    if isinstance(passed_msg, unicode):
        return to_unicode(msg)

    return msg

def utf8_valid(msg):
    """ Return True/False is the text is valid utf8. """
    for (ucs, bytes) in __utf8_iter_ucs(msg):
        if ucs is None:
            return False
    return True

def _utf8_width_le(width, *args):
    """ Minor speed hack, we often want to know "does X fit in Y". It takes
        "a while" to work out a utf8_width() (see above), and we know that a
        utf8 character is always <= byte. So given:

        assert bytes >= characters
        characters <= width?

        ...we can change to:

        bytes <= width or characters <= width

        ...and bytes are much faster. """
    # This assumes that all args. are utf8.
    ret = 0
    for arg in args:
        ret += len(arg)
    if ret <= width:
        return True
    ret = 0
    for arg in args:
        ret += utf8_width(arg)
    return ret <= width

def utf8_text_wrap(text, width=70, initial_indent='', subsequent_indent=''):
    """ Works like we want textwrap.wrap() to work, uses utf-8 data and
        doesn't screw up lists/blocks/etc. """
    # Tested with:
    # yum info robodoc gpicview php-pear-Net-Socket wmctrl ustr moreutils
    #          mediawiki-HNP ocspd insight yum mousepad
    # ...at 120, 80 and 40 chars.
    # Also, notable among lots of others, searching for "\n  ":
    #   exim-clamav, jpackage-utils, tcldom, synaptics, "quake3",
    #   perl-Class-Container, ez-ipupdate, perl-Net-XMPP, "kipi-plugins",
    #   perl-Apache-DBI, netcdf, python-configobj, "translate-toolkit", alpine,
    #   "udunits", "conntrack-tools"
    #
    # Note that, we "fail" on:
    #   alsa-plugins-jack, setools*, dblatex, uisp, "perl-Getopt-GUI-Long",
    #   suitesparse, "synce-serial", writer2latex, xenwatch, ltsp-utils

    passed_unicode = isinstance(text, unicode)

    def _indent_at_beg(line):
        count = 0
        byte = 'X'
        for byte in line:
            if byte != ' ':
                break
            count += 1
        if byte not in ("-", "*", ".", "o", '\xe2'):
            return count, 0
        list_chr = utf8_width_chop(line[count:], 1)[1]
        if list_chr in ("-", "*", ".", "o",
                        "\xe2\x80\xa2", "\xe2\x80\xa3", "\xe2\x88\x98"):
            nxt = _indent_at_beg(line[count+len(list_chr):])
            nxt = nxt[1] or nxt[0]
            if nxt:
                return count, count + 1 + nxt
        return count, 0

    initial_indent = to_utf8(initial_indent)
    subsequent_indent = to_utf8(subsequent_indent)

    text = to_utf8(text).rstrip('\n')
    lines = to_utf8(text).replace('\t', ' ' * 8).split('\n')

    ret = []
    indent = initial_indent
    wrap_last = False
    csab = 0
    cspc_indent = 0
    for line in lines:
        line = line.rstrip(' ')
        (lsab, lspc_indent) = (csab, cspc_indent)
        (csab, cspc_indent) = _indent_at_beg(line)
        force_nl = False # We want to stop wrapping under "certain" conditions:
        if wrap_last and cspc_indent:      # if line starts a list or
            force_nl = True
        if wrap_last and csab == len(line):# is empty line
            force_nl = True
        if wrap_last and not lspc_indent:  # if line doesn't continue a list and
            if csab >= 4 and csab != lsab: # is "block indented"
                force_nl = True
        if force_nl:
            ret.append(indent.rstrip(' '))
            indent = subsequent_indent
            wrap_last = False
        if csab == len(line): # empty line, remove spaces to make it easier.
            line = ''
        if wrap_last:
            line = line.lstrip(' ')
            cspc_indent = lspc_indent

        if _utf8_width_le(width, indent, line):
            wrap_last = False
            ret.append(indent + line)
            indent = subsequent_indent
            continue

        wrap_last = True
        words = line.split(' ')
        line = indent
        spcs = cspc_indent
        if not spcs and csab >= 4:
            spcs = csab
        for word in words:
            if (not _utf8_width_le(width, line, word) and
                utf8_width(line) > utf8_width(subsequent_indent)):
                ret.append(line.rstrip(' '))
                line = subsequent_indent + ' ' * spcs
            line += word
            line += ' '
        indent = line.rstrip(' ') + ' '
    if wrap_last:
        ret.append(indent.rstrip(' '))

    if passed_unicode:
        return map(to_unicode, ret)
    return ret

def utf8_text_fill(text, *args, **kwargs):
    """ Works like we want textwrap.fill() to work, uses utf-8 data and
        doesn't screw up lists/blocks/etc. """
    return '\n'.join(utf8_text_wrap(text, *args, **kwargs))
# ----------------------------- END utf8 -----------------------------

def to_unicode(obj, encoding='utf-8', errors='replace'):
    ''' convert a 'str' to 'unicode' '''
    if isinstance(obj, basestring):
        if not isinstance(obj, unicode):
            obj = unicode(obj, encoding, errors)
    return obj

def to_utf8(obj, errors='replace'):
    '''convert 'unicode' to an encoded utf-8 byte string '''
    if isinstance(obj, unicode):
        obj = obj.encode('utf-8', errors)
    return obj

# Don't use this, to_unicode should just work now
def to_unicode_maybe(obj, encoding='utf-8', errors='replace'):
    ''' Don't ask don't tell, only use when you must '''
    try:
        return to_unicode(obj, encoding, errors)
    except UnicodeEncodeError:
        return obj

def to_str(obj):
    """ Convert something to a string, if it isn't one. """
    # NOTE: unicode counts as a string just fine. We just want objects to call
    # their __str__ methods.
    if not isinstance(obj, basestring):
        obj = str(obj)
    return obj

def str_eq(a, b):
    """ convert between unicode and not and compare them, w/o warning or being annoying"""
    if isinstance(a, unicode) == isinstance(b, unicode):
        if a == b: # stupid python...
            return True
    elif to_utf8(a) == to_utf8(b):
        return True
    
    return False
    
try: 
    '''
    Setup the yum translation domain and make _() and P_() translation wrappers
    available.
    using ugettext to make sure translated strings are in Unicode.
    '''
    import gettext
    t = gettext.translation('yum', fallback=True)
    _ = t.ugettext
    P_ = t.ungettext
except:
    '''
    Something went wrong so we make a dummy _() wrapper there is just
    returning the same text
    '''
    _ = dummy_wrapper
    P_ = dummyP_wrapper

if __name__ == "__main__":
    import sys

    def out(arg):
        arg = to_utf8(arg)
        print "UTF8 :", arg
        print "len  :", len(arg)
        arg = to_unicode(arg)
        print "USC  :", arg
        print "len  :", len(arg)
        print "valid:", utf8_valid(arg)
        print "width:", utf8_width(arg)
        print "4.8  :", "%s%s%s" % ('<', utf8_width_fill(arg,  4,  8), '>')
        print "4.3  :", "%s%s%s" % ('<', utf8_width_fill(arg,  4,  3), '>')
        print "4.2  :", "%s%s%s" % ('<', utf8_width_fill(arg,  4,  2), '>')
        print "4.1  :", "%s%s%s" % ('<', utf8_width_fill(arg,  4,  1), '>')
        print "3.3  :", "%s%s%s" % ('<', utf8_width_fill(arg,  3,  3), '>')
        print "3.2  :", "%s%s%s" % ('<', utf8_width_fill(arg,  3,  2), '>')
        print "3.1  :", "%s%s%s" % ('<', utf8_width_fill(arg,  3,  1), '>')
        print "40.79:", "%s%s%s" % ('<', utf8_width_fill(arg, 40, 79), '>')
        print "40.20:", "%s%s%s" % ('<', utf8_width_fill(arg, 40, 20), '>')
        print ''

    print " ---- Arguments/str ---- "
    for arg in sys.argv[1:]:
        out(arg)

    print " ---- Arguments/gettext ---- "
    for arg in sys.argv[1:]:
        try:
            arg = _(arg)
        except UnicodeDecodeError:
            continue
        out(arg)

    if len(sys.argv) > 2:
        print " ---- Arguments/str/all ---- "
        out(sys.argv[1] % sys.argv[2:])

        print " ---- Arguments/gettext/all ---- "
        try:
            arg = _(sys.argv[1]) % map(_, sys.argv[2:])
        except UnicodeDecodeError:
            sys.exit(0)
        out(arg)
                                                                                                      usr/lib/python2.7/dist-packages/yum/i18n.pyc                                                        0100644 0000000 0000000 00000036652 13077704344 017246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d    Z  d   Z d   Z ddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzd{d|d}d~dddddddddddddddddddddddddddddf Z d   Z d   Z d   Z d   Z dd  Z	 de
 d d d  Z d   Z d   Z d d d d  Z d   Z d d d  Z d d  Z d d d  Z d   Z d   Z y7 ddl Z e j dde
 Z e j Z e j Z Wn e  Z e Z n Xe dk rddl Z d  Z dGHx e j dD] Z  e e   qWd	GHxF e j dD]7 Z  y e e   Z  Wn e! k
 rMq!n Xe e   q!We" e j  d
k rdGHe e j de j d
 dGHy+ e e j d e# e e j d
 Z  Wn e! k
 re j$ d n Xe e   qn  dS(  c         C   s
   t  |   S(   sD   
    Dummy Translation wrapper, just returning the same string.
    (   t
   to_unicode(   t   str(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   dummy_wrapper   s    c         C   s   | d k r |  S| Sd S(   s]   
    Dummy Plural Translation wrapper, just returning the singular or plural
    string.
    i   N(    (   t   str1t   str2t   n(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   dummyP_wrapper   s    c         C   s   d } t  |  d } |  | | d k  s> |  | | d k rB t Sxd | | k r | | d } |  | | d k r | d } qE |  | | d k  r | d } qE t SqE Wt S(   s9    auxiliary function for binary search in interval table. i    i   i   (   t   lent   Falset   True(   t   ucst   tablet   mint   maxt   mid(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   __utf8_bisearchB   s    (i   io  i  i  i  i  i  i  i  i  i  i  i  i  i   i  i  i  iK  i^  ip  i  i  i  i  i  i  i  i  i0  iJ  i  i  i  i  i	  i	  i<	  iA	  iH	  iM	  iQ	  iT	  ib	  ic	  i	  i	  i	  i	  i	  i	  i	  i
  i
  i<
  iA
  iB
  iG
  iH
  iK
  iM
  ip
  iq
  i
  i
  i
  i
  i
  i
  i
  i
  i
  i
  i  i<  i?  iA  iC  iM  iV  i  i  i  i>  i@  iF  iH  iJ  iM  iU  iV  i  i  i  i  i  i  i  iA  iC  iM  i  i  i  i  i1  i4  i:  iG  iN  i  i  i  i  i  i  i  i  i  i5  i7  i9  iq  i~  i  i  i  i  i  i  i  i  i  i-  i0  i2  i6  i7  i9  iX  iY  i`  i  i_  i  i  i2  i4  iR  iS  ir  is  i  i  i  i  i  i  i  i  i  i  i  i   i"  i'  i(  i2  i9  i;  i  i  i   i  i4  i6  i:  i<  iB  ik  is  i  i  i  i  i   i   i*   i.   i`   ic   ij   io   i   i   i*0  i/0  i0  i0  i  i  i%  i&  i  i   i  i   i#  i  i  i  i
 i
 i
 i
 i
 i
 i8
 i:
 i?
 ig ii is i i i i i iB iD i  i   i  i  i c         C   sa  |  d k r d S|  d k  s4 |  d k r8 |  d k  r8 d St  |  t  rK d Sd |  d k o_|  d k p_|  d	 k p_|  d
 k p_|  d k r |  d k r |  d k p_|  d k r |  d k p_|  d k r |  d k p_|  d k r |  d k p_|  d k r|  d k p_|  d k r|  d k p_|  d k r2|  d k p_|  d k rJ|  d k p_|  d k o_|  d k S(   s+    Get the textual width of a ucs character. i    i    i   i   ii   i   i_  i)#  i*#  i.  iϤ  i?0  i   i  i   i  i  i  i0  io  i   i`  i  i  i   i i   i (   R   t   __combining(   R
   (    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   __utf8_ucp_width   s(    $c         c   s&   x t  |   D] } t |  Vq Wd  S(   N(   t   to_utf8t   ord(   t   msgt   byte(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   __utf8_iter_ints   s    c         c   se  t  |   } xR| D]J} | d k  r3 | d f Vq | d @d k r | j   } | d @d k so | d @d k rx d Vd  S| d @d >| d	 @Bd f Vq | d
 @d k rq| j   } | j   } | d @d k s>| d @d k s>| d k r | d @d k s>| d k r| d @d k s>| d k rG| d k rG| d @d k rGd Vd  S| d @d >| d	 @d >B| d	 @Bd f Vq | d @d
 k rT| j   } | j   } | j   } | d @d k s| d @d k s| d @d k s| d
 k r| d
 @d k s| d k r	| d k s| d k rd Vd  S| d @d >| d	 @d >B| d	 @d >B| d	 @Bd f Vq d Vd  Sq Wd  S(   Ni   i   i   i   i   i   i   i   i?   i   i   i   i   i   i   i   i   i   i   i   i   i   i   i   (   Ni   (   Ni   (   Ni   (   Ni   (   R   t   nextt   None(   R   t   uitert   byte0t   byte1t   byte2t   byte3(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   __utf8_iter_ucs   sL     6c         C   sP   d } xC t  |   D]5 \ } } | d k r8 | | 7} q | t |  7} q W| S(   s)    Get the textual width of a utf8 string. i    N(   R   R   R   (   R   t   retR
   t   bytes(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt
   utf8_width   s    c         C   s   | d k s t |   | k r. t |   |  f Sd } t |  t  } d } t |   }  xy t |   D]k \ } } | d k r | } n t |  } | d k	 r | | | k r |  |  }  Pn  | | 7} | | 7} qb W| r t |   }  n  | |  f S(   s   Return the textual width of a utf8 string, chopping it to a specified
        value. This is what you want to use instead of %.*s, as it does the
        "right" thing with regard to utf-8 sequences. Eg.
        "%.*s" % (10, msg)   <= becomes => "%s" % (utf8_width_chop(msg, 10)) i    N(   R   R!   t
   isinstancet   unicodeR   R   R   R    (   R   t   chopR   t   passed_unicodet	   msg_bytesR
   R    t   width(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   utf8_width_chop   s$    	

t    c   	      C   s   |  } t  |  |  \ } }  | | k rQ | s3 | r d j | |  | g  }  q nM d | | } | r d j | |  | | g  }  n d j | | |  | g  }  t | t  r t |   S|  S(   s   Expand a utf8 msg to a specified "width" or chop to same.
        Expansion can be left or right. This is what you want to use instead of
        %*.*s, as it does the "right" thing with regard to utf-8 sequences.
        prefix and suffix should be used for "invisible" bytes, like
        highlighting.
        Eg.
        "%-*.*s" % (10, 20, msg)
           <= becomes =>
        "%s" % (utf8_width_fill(msg, 10, 20)).

        "%20.10s" % (msg)
           <= becomes =>
        "%s" % (utf8_width_fill(msg, 20, 10, left=False)).

        "%s%.10s%s" % (prefix, msg, suffix)
           <= becomes =>
        "%s" % (utf8_width_fill(msg, 0, 10, prefix=prefix, suffix=suffix)).
        R)   t    (   R(   t   joinR"   R#   R    (	   R   t   fillR$   t   leftt   prefixt   suffixt
   passed_msgR'   t   extra(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   utf8_width_fill   s    
c         C   s1   x* t  |   D] \ } } | d k r t Sq Wt S(   s.    Return True/False is the text is valid utf8. N(   R   R   R   R	   (   R   R
   R    (    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt
   utf8_valid$  s    c         G   sh   d } x | D] } | t  |  7} q W| |  k r7 t Sd } x | D] } | t |  7} qD W| |  k S(   s{   Minor speed hack, we often want to know "does X fit in Y". It takes
        "a while" to work out a utf8_width() (see above), and we know that a
        utf8 character is always <= byte. So given:

        assert bytes >= characters
        characters <= width?

        ...we can change to:

        bytes <= width or characters <= width

        ...and bytes are much faster. i    (   R   R	   R!   (   R'   t   argsR   t   arg(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   _utf8_width_le+  s    iF   c            s  t  |  t  }   f d     t |  } t |  } t |   j d  }  t |   j d d	  j d  } g  } | } t } d }	 d }
 x	| D]} | j d  } |	 |
 } }   |  \ }	 }
 t } | r |
 r t } n  | r|	 t |  k rt } n  | r2| r2|	 d k r2|	 | k r2t } q2n  | r]| j	 | j d   | } t } n  |	 t |  k rxd } n  | r| j
 d  } | }
 n  t | | |  rt } | j	 | |  | } q n  t } | j d  } | } |
 } | r|	 d k r|	 } n  xt | D]l } t | | |  rgt |  t |  k rg| j	 | j d   | d | } n  | | 7} | d 7} qW| j d  d } q W| r| j	 | j d   n  | rt t |  S| S(
   sl    Works like we want textwrap.wrap() to work, uses utf-8 data and
        doesn't screw up lists/blocks/etc. c            s   d } d } x( |  D]  } | d k r) Pn  | d 7} q W| d k rM | d f St  |  | d  d } | d k r   |  | t |   } | d p | d } | r | | d | f Sn  | d f S(   Ni    t   XR*   i   t   -t   *t   .t   os   s   •s   ‣s   ∘(   R8   R9   R:   R;   s   (   R8   R9   R:   R;   s   •s   ‣s   ∘(   R(   R   (   t   linet   countR   t   list_chrt   nxt(   t   _indent_at_beg(    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyR@   V  s     
	s   
s   	R*   i   i    i   R)   s           (   R"   R#   R   t   rstript   replacet   splitR   R	   R   t   appendt   lstripR6   R!   t   mapR    (   t   textR'   t   initial_indentt   subsequent_indentR%   t   linesR   t   indentt	   wrap_lastt   csabt   cspc_indentR<   t   lsabt   lspc_indentt   force_nlt   wordst   spcst   word(    (   R@   s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   utf8_text_wrapC  sp    !						
c         O   s   d j  t |  | |   S(   sl    Works like we want textwrap.fill() to work, uses utf-8 data and
        doesn't screw up lists/blocks/etc. s   
(   R+   RU   (   RG   R4   t   kwargs(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   utf8_text_fill  s    s   utf-8RB   c         C   s:   t  |  t  r6 t  |  t  s6 t |  | |  }  q6 n  |  S(   s    convert a 'str' to 'unicode' (   R"   t
   basestringR#   (   t   objt   encodingt   errors(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyR      s    c         C   s(   t  |  t  r$ |  j d |  }  n  |  S(   s2   convert 'unicode' to an encoded utf-8 byte string s   utf-8(   R"   R#   t   encode(   RY   R[   (    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyR     s    c         C   s-   y t  |  | |  SWn t k
 r( |  SXd S(   s.    Don't ask don't tell, only use when you must N(   R    t   UnicodeEncodeError(   RY   RZ   R[   (    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   to_unicode_maybe  s    c         C   s"   t  |  t  s t |   }  n  |  S(   s1    Convert something to a string, if it isn't one. (   R"   RX   R   (   RY   (    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   to_str  s    c         C   sQ   t  |  t  t  | t  k r1 |  | k rM t Sn t |   t |  k rM t St S(   sP    convert between unicode and not and compare them, w/o warning or being annoying(   R"   R#   R	   R   R   (   t   at   b(    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   str_eq  s    iNt   yumt   fallbackt   __main__c         C   s  t  |   }  d G|  GHd Gt |   GHt |   }  d G|  GHd Gt |   GHd Gt |   GHd Gt |   GHd Gd d t |  d	 d
  d f GHd Gd d t |  d	 d  d f GHd Gd d t |  d	 d  d f GHd Gd d t |  d	 d  d f GHd Gd d t |  d d  d f GHd Gd d t |  d d  d f GHd Gd d t |  d d  d f GHd Gd d t |  d d  d f GHd Gd d t |  d d  d f GHd GHd  S(   Ns   UTF8 :s   len  :s   USC  :s   valid:s   width:s   4.8  :s   %s%s%st   <i   i   t   >s   4.3  :i   s   4.2  :i   s   4.1  :i   s   3.3  :s   3.2  :s   3.1  :s   40.79:i(   iO   s   40.20:i   R)   (   R   R   R    R3   R!   R2   (   R5   (    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   out  s$    		"""""""""s    ---- Arguments/str ---- i   s    ---- Arguments/gettext ---- i   s    ---- Arguments/str/all ---- s!    ---- Arguments/gettext/all ---- i    (   i   io  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i   i  (   i  i  (   iK  i^  (   ip  ip  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i0  iJ  (   i  i  (   i  i  (   i	  i	  (   i<	  i<	  (   iA	  iH	  (   iM	  iM	  (   iQ	  iT	  (   ib	  ic	  (   i	  i	  (   i	  i	  (   i	  i	  (   i	  i	  (   i	  i	  (   i
  i
  (   i<
  i<
  (   iA
  iB
  (   iG
  iH
  (   iK
  iM
  (   ip
  iq
  (   i
  i
  (   i
  i
  (   i
  i
  (   i
  i
  (   i
  i
  (   i
  i
  (   i  i  (   i<  i<  (   i?  i?  (   iA  iC  (   iM  iM  (   iV  iV  (   i  i  (   i  i  (   i  i  (   i>  i@  (   iF  iH  (   iJ  iM  (   iU  iV  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   iA  iC  (   iM  iM  (   i  i  (   i  i  (   i  i  (   i1  i1  (   i4  i:  (   iG  iN  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i5  i5  (   i7  i7  (   i9  i9  (   iq  i~  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i-  i0  (   i2  i2  (   i6  i7  (   i9  i9  (   iX  iY  (   i`  i  (   i_  i_  (   i  i  (   i2  i4  (   iR  iS  (   ir  is  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i  i  (   i   i"  (   i'  i(  (   i2  i2  (   i9  i;  (   i  i  (   i   i  (   i4  i4  (   i6  i:  (   i<  i<  (   iB  iB  (   ik  is  (   i  i  (   i  i  (   i   i   (   i*   i.   (   i`   ic   (   ij   io   (   i   i   (   i*0  i/0  (   i0  i0  (   i  i  (   i  i  (   i%  i&  (   i  i  (   i   i  (   i   i#  (   i  i  (   i  i  (   i
 i
 (   i
 i
 (   i
 i
 (   i8
 i:
 (   i?
 i?
 (   ig ii (   is i (   i i (   i i (   iB iD (   i  i  (   i   i  (   i  i (%   R   R   R   R   R   R   R   R!   R   R(   R	   R2   R3   R6   RU   RW   R    R   R^   R_   Rb   t   gettextt   translationt   tt   ugettextt   _t	   ungettextt   P_t   __name__t   sysRh   t   argvR5   t   UnicodeDecodeErrorR   RF   t   exit(    (    (    s,   /usr/lib/python2.7/dist-packages/yum/i18n.pyt   <module>   s   		+																																																				+	
%		a			
	
	+                                                                                      usr/lib/python2.7/dist-packages/yum/logginglevels.py                                                0100644 0000000 0000000 00000017462 12451005146 021150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


"""
Custom logging levels for finer-grained logging using python's standard
logging module.
"""

import os
import socket
import sys
import logging
import logging.handlers

INFO_1 = 19
INFO_2 = 18

DEBUG_1 = 9
DEBUG_2 = 8
DEBUG_3 = 7
DEBUG_4 = 6

logging.addLevelName(INFO_1, "INFO_1")
logging.addLevelName(INFO_2, "INFO_2")

logging.addLevelName(DEBUG_1, "DEBUG_1")
logging.addLevelName(DEBUG_2, "DEBUG_2")
logging.addLevelName(DEBUG_3, "DEBUG_3")
logging.addLevelName(DEBUG_4, "DEBUG_4")

# High level to effectively turn off logging.
# For compatability with the old logging system.
__NO_LOGGING = 100
logging.raiseExceptions = False

from logging.handlers import SysLogHandler as syslog_module

syslog = None

# Mostly borrowed from original yum-updated.py
_syslog_facility_map = { "KERN"   : syslog_module.LOG_KERN,
                         "USER"   : syslog_module.LOG_USER,
                         "MAIL"   : syslog_module.LOG_MAIL,
                         "DAEMON" : syslog_module.LOG_DAEMON,
                         "AUTH"   : syslog_module.LOG_AUTH,
                         "LPR"    : syslog_module.LOG_LPR,
                         "NEWS"   : syslog_module.LOG_NEWS,
                         "UUCP"   : syslog_module.LOG_UUCP,
                         "CRON"   : syslog_module.LOG_CRON,
                         "LOCAL0" : syslog_module.LOG_LOCAL0,
                         "LOCAL1" : syslog_module.LOG_LOCAL1,
                         "LOCAL2" : syslog_module.LOG_LOCAL2,
                         "LOCAL3" : syslog_module.LOG_LOCAL3,
                         "LOCAL4" : syslog_module.LOG_LOCAL4,
                         "LOCAL5" : syslog_module.LOG_LOCAL5,
                         "LOCAL6" : syslog_module.LOG_LOCAL6,
                         "LOCAL7" : syslog_module.LOG_LOCAL7,}
def syslogFacilityMap(facility):
    if type(facility) == int:
        return facility
    elif facility.upper() in _syslog_facility_map:
        return _syslog_facility_map[facility.upper()]
    elif (facility.upper().startswith("LOG_") and
          facility[4:].upper() in _syslog_facility_map):
        return _syslog_facility_map[facility[4:].upper()]
    return _syslog_facility_map["USER"]

def logLevelFromErrorLevel(error_level):
    """ Convert an old-style error logging level to the new style. """
    error_table = { -1 : __NO_LOGGING, 0 : logging.CRITICAL, 1 : logging.ERROR,
        2 : logging.WARNING}
    
    return __convertLevel(error_level, error_table)

def logLevelFromDebugLevel(debug_level):
    """ Convert an old-style debug logging level to the new style. """
    debug_table = {-1 : __NO_LOGGING, 0 : logging.INFO, 1 : INFO_1, 2 : INFO_2,
        3 : logging.DEBUG, 4 : DEBUG_1, 5 : DEBUG_2, 6 : DEBUG_3, 7 : DEBUG_4}

    return __convertLevel(debug_level, debug_table)

def __convertLevel(level, table):
    """ Convert yum logging levels using a lookup table. """
    # Look up level in the table.
    try:
        new_level = table[level]
    except KeyError:
        keys = table.keys()
        # We didn't find the level in the table, check if it's smaller
        # than the smallest level
        if level < keys[0]:
            new_level = table[keys[0]]
        # Nope. So it must be larger.
        else:
            new_level =  table[keys[-2]]

    return new_level

def setDebugLevel(level):
    converted_level = logLevelFromDebugLevel(level)
    logging.getLogger("yum.verbose").setLevel(converted_level)
    
def setErrorLevel(level):
    converted_level = logLevelFromErrorLevel(level)
    logging.getLogger("yum").setLevel(converted_level)

_added_handlers = False
def doLoggingSetup(debuglevel, errorlevel,
                   syslog_ident=None, syslog_facility=None,
                   syslog_device='/dev/log'):
    """
    Configure the python logger.
    
    errorlevel is optional. If provided, it will override the logging level
    provided in the logging config file for error messages.
    debuglevel is optional. If provided, it will override the logging level
    provided in the logging config file for debug messages.
    """
    global _added_handlers

    #logging.basicConfig() # this appears to not change anything in our 
    # logging setup - disabling this b/c of the behaviors in yum ticket 525
    # -skvidal
    

    if _added_handlers:
        if debuglevel is not None:
            setDebugLevel(debuglevel)
        if errorlevel is not None:  
            setErrorLevel(errorlevel)
        return

    plainformatter = logging.Formatter("%(message)s")
    
    console_stdout = logging.StreamHandler(sys.stdout)
    console_stdout.setFormatter(plainformatter)
    verbose = logging.getLogger("yum.verbose")
    verbose.propagate = False
    verbose.addHandler(console_stdout)
        
    console_stderr = logging.StreamHandler(sys.stderr)
    console_stderr.setFormatter(plainformatter)
    logger = logging.getLogger("yum")
    logger.propagate = False
    logger.addHandler(console_stderr)
   
    filelogger = logging.getLogger("yum.filelogging")
    filelogger.setLevel(logging.INFO)
    filelogger.propagate = False

    global syslog
    if syslog_device:
        address = None
        if ":" in syslog_device:
            address = syslog_device.rsplit(":", 1)
            address = (address[0], int(address[1]))
        elif os.path.exists(syslog_device):
            address = syslog_device
        if address:
            try:
                facil = syslogFacilityMap(syslog_facility or "USER")
                syslog = logging.handlers.SysLogHandler(address, facil)
            except socket.error:
                if syslog is not None:
                    syslog.close()
            else:
                setLoggingApp(syslog_ident or "yum")
                filelogger.addHandler(syslog)
    _added_handlers = True

    if debuglevel is not None:
        setDebugLevel(debuglevel)
    if errorlevel is not None:  
        setErrorLevel(errorlevel)

def setFileLog(uid, logfile, cleanup=None):
    # TODO: When python's logging config parser doesn't blow up
    # when the user is non-root, put this in the config file.
    # syslog-style log
    if uid == 0:
        try:
            # For installroot etc.
            logdir = os.path.dirname(logfile)
            if not os.path.exists(logdir):
                os.makedirs(logdir, mode=0755)
            
            if not os.path.exists(logfile):
                f = open(logfile, 'w')
                os.chmod(logfile, 0600) # making sure umask doesn't catch us up
                f.close()
                
            filelogger = logging.getLogger("yum.filelogging")
            filehandler = logging.FileHandler(logfile)
            formatter = logging.Formatter("%(asctime)s %(message)s",
                "%b %d %H:%M:%S")
            filehandler.setFormatter(formatter)
            filelogger.addHandler(filehandler)
            if not cleanup is None:
                cleanup.append(lambda: filelogger.removeHandler(filehandler))
        except IOError:
            logging.getLogger("yum").critical('Cannot open logfile %s', logfile)

def setLoggingApp(app):
    if syslog:
        syslogformatter = logging.Formatter(app + "[%(process)d]: %(message)s")
        syslog.setFormatter(syslogformatter)
                                                                                                                                                                                                              usr/lib/python2.7/dist-packages/yum/logginglevels.pyc                                               0100644 0000000 0000000 00000014656 13077704344 021330  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d Z d Z d Z d Z	 d Z
 d Z e j e d	  e j e d
  e j e d  e j e	 d  e j e
 d  e j e d  d Z e e _ d d l m Z d a i e j d 6e j d 6e j d 6e j d 6e j d 6e j d 6e j d 6e j d 6e j d 6e j d 6e j d 6e j d 6e j  d 6e j! d 6e j" d 6e j# d  6e j$ d! 6Z% d"   Z& d#   Z' d$   Z( d%   Z) d&   Z* d'   Z+ e a, d d d( d)  Z- d d*  Z. d+   Z/ d S(,   sY   
Custom logging levels for finer-grained logging using python's standard
logging module.
iNi   i   i	   i   i   i   t   INFO_1t   INFO_2t   DEBUG_1t   DEBUG_2t   DEBUG_3t   DEBUG_4id   (   t   SysLogHandlert   KERNt   USERt   MAILt   DAEMONt   AUTHt   LPRt   NEWSt   UUCPt   CRONt   LOCAL0t   LOCAL1t   LOCAL2t   LOCAL3t   LOCAL4t   LOCAL5t   LOCAL6t   LOCAL7c         C   s{   t  |   t k r |  S|  j   t k r6 t |  j   S|  j   j d  rs |  d j   t k rs t |  d j   St d S(   Nt   LOG_i   R   (   t   typet   intt   uppert   _syslog_facility_mapt
   startswith(   t   facility(    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   syslogFacilityMapG   s    c         C   s8   i t  d 6t j d 6t j d 6t j d 6} t |  |  S(   s<    Convert an old-style error logging level to the new style. ii    i   i   (   t   __NO_LOGGINGt   loggingt   CRITICALt   ERRORt   WARNINGt   __convertLevel(   t   error_levelt   error_table(    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   logLevelFromErrorLevelQ   s    c         C   sX   i	 t  d 6t j d 6t d 6t d 6t j d 6t d 6t d 6t d 6t	 d	 6} t
 |  |  S(
   s<    Convert an old-style debug logging level to the new style. ii    i   i   i   i   i   i   i   (   R    R!   t   INFOR    R   t   DEBUGR   R   R   R   R%   (   t   debug_levelt   debug_table(    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   logLevelFromDebugLevelX   s    ")c         C   sa   y | |  } WnL t  k
 r\ | j   } |  | d k  rK | | d } q] | | d } n X| S(   s2    Convert yum logging levels using a lookup table. i    i(   t   KeyErrort   keys(   t   levelt   tablet	   new_levelR/   (    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyR%   _   s    c         C   s&   t  |   } t j d  j |  d  S(   Ns   yum.verbose(   R-   R!   t	   getLoggert   setLevel(   R0   t   converted_level(    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   setDebugLevelp   s    c         C   s&   t  |   } t j d  j |  d  S(   Nt   yum(   R(   R!   R3   R4   (   R0   R5   (    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   setErrorLevelt   s    s   /dev/logc         C   s  t  r< |  d k	 r t |   n  | d k	 r8 t |  n  d St j d  } t j t j  } | j	 |  t j
 d  } t | _ | j |  t j t j  } | j	 |  t j
 d  }	 t |	 _ |	 j |  t j
 d  }
 |
 j t j  t |
 _ | rd } d | k rB| j d d  } | d t | d  f } n t j j |  r]| } n  | ry+ t | prd	  } t j j | |  a Wn- t j k
 rt d k	 rt j   qqXt | pd  |
 j t  qn  t a  |  d k	 r t |   n  | d k	 rt |  n  d S(
   s;  
    Configure the python logger.
    
    errorlevel is optional. If provided, it will override the logging level
    provided in the logging config file for error messages.
    debuglevel is optional. If provided, it will override the logging level
    provided in the logging config file for debug messages.
    Ns   %(message)ss   yum.verboseR7   s   yum.fileloggingt   :i   i    R   (   t   _added_handlerst   NoneR6   R8   R!   t	   Formattert   StreamHandlert   syst   stdoutt   setFormatterR3   t   Falset	   propagatet
   addHandlert   stderrR4   R)   t   rsplitR   t   ost   patht   existsR   t   handlersR   t   syslogt   sockett   errort   closet   setLoggingAppt   True(   t
   debuglevelt
   errorlevelt   syslog_identt   syslog_facilityt   syslog_devicet   plainformattert   console_stdoutt   verboset   console_stderrt   loggert
   fileloggert   addresst   facil(    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   doLoggingSetupy   sR    				c            s.  |  d k r*y t  j j |  } t  j j |  sI t  j | d d n  t  j j |  s t | d  } t  j | d  | j   n  t j	 d   t j
 |    t j d d  }   j |   j    | d  k	 r | j    f d	    n  Wq*t k
 r&t j	 d
  j d |  q*Xn  d  S(   Ni    t   modei  t   wi  s   yum.fileloggings   %(asctime)s %(message)ss   %b %d %H:%M:%Sc              s    j     S(   N(   t   removeHandler(    (   t   filehandlerRZ   (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   <lambda>   s    R7   s   Cannot open logfile %s(   RF   RG   t   dirnameRH   t   makedirst   opent   chmodRM   R!   R3   t   FileHandlerR<   R@   RC   R;   t   appendt   IOErrort   critical(   t   uidt   logfilet   cleanupt   logdirt   ft	   formatter(    (   Ra   RZ   s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt
   setFileLog   s&    		 c         C   s-   t  r) t j |  d  } t  j |  n  d  S(   Ns   [%(process)d]: %(message)s(   RJ   R!   R<   R@   (   t   appt   syslogformatter(    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyRN      s    (0   t   __doc__RF   RK   R>   R!   t   logging.handlersR    R   R   R   R   R   t   addLevelNameR    RA   t   raiseExceptionsR   t   syslog_moduleR;   RJ   t   LOG_KERNt   LOG_USERt   LOG_MAILt
   LOG_DAEMONt   LOG_AUTHt   LOG_LPRt   LOG_NEWSt   LOG_UUCPt   LOG_CRONt
   LOG_LOCAL0t
   LOG_LOCAL1t
   LOG_LOCAL2t
   LOG_LOCAL3t
   LOG_LOCAL4t
   LOG_LOCAL5t
   LOG_LOCAL6t
   LOG_LOCAL7R   R   R(   R-   R%   R6   R8   R:   R]   Rq   RN   (    (    (    s5   /usr/lib/python2.7/dist-packages/yum/logginglevels.pyt   <module>   sb   	














	
					B                                                                                  usr/lib/python2.7/dist-packages/yum/mdparser.py                                                     0100644 0000000 0000000 00000014410 12451005146 020112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2005 Duke University 

import gzip
try:
    from xml.etree import cElementTree
except ImportError:
    import cElementTree
iterparse = cElementTree.iterparse

from cStringIO import StringIO
import warnings

import Errors

#TODO: document everything here

class MDParser:

    def __init__(self, filename):

        # Set up mapping of meta types to handler classes 
        handlers = {
            '{http://linux.duke.edu/metadata/common}metadata': PrimaryEntry,
            '{http://linux.duke.edu/metadata/filelists}filelists': FilelistsEntry,
            '{http://linux.duke.edu/metadata/other}otherdata': OtherEntry,
        }
            
        self.total = None
        self.count = 0
        self._handlercls = None

        # Read in type, set package node handler and get total number of
        # packages
        if filename[-3:] == '.gz': fh = gzip.open(filename, 'r')
        else: fh = open(filename, 'r')
        parser = iterparse(fh, events=('start', 'end'))
        self.reader = parser.__iter__()
        event, elem = self.reader.next()
        self._handlercls = handlers.get(elem.tag, None)
        if not self._handlercls:
            raise ValueError('Unknown repodata type "%s" in %s' % (
                elem.tag, filename))
        # Get the total number of packages
        self.total = int(elem.get('packages', 0))

    def __iter__(self):
        return self

    def next(self):
        for event, elem in self.reader:
            if event == 'end' and elem.tag[-7:] == 'package':
                self.count += 1
                return self._handlercls(elem)
        raise StopIteration


class BaseEntry:
    def __init__(self, elem):
        self._p = {} 

    def __getitem__(self, k):
        return self._p[k]

    def keys(self):
        return self._p.keys()

    def values(self):
        return self._p.values()

    def has_key(self, k):
        warnings.warn('has_key() will go away in a future version of Yum.\n',
                      Errors.YumFutureDeprecationWarning, stacklevel=2)
        return k in self._p

    def __iter__(self):
        return iter(self._p)

    def __str__(self):
        out = StringIO()
        keys = self.keys()
        keys.sort()
        for k in keys:
            line = u'%s=%s\n' % (k, self[k])
            out.write(line.encode('utf8'))
        return out.getvalue()

    def _bn(self, qn):
        if qn.find('}') == -1: return qn 
        return qn.split('}')[1]
        
    def _prefixprops(self, elem, prefix):
        ret = {}
        for key in elem.attrib:
            ret[prefix + '_' + self._bn(key)] = elem.attrib[key]
        return ret

class PrimaryEntry(BaseEntry):
    def __init__(self, elem):
        BaseEntry.__init__(self, elem)
        # Avoid excess typing :)
        p = self._p

        self.prco = {}
        self.files = {}

        for child in elem:
            name = self._bn(child.tag)
            if name in ('name', 'arch', 'summary', 'description', 'url', 
                    'packager'): 
                p[name] = child.text

            elif name == 'version': 
                p.update(child.attrib)

            elif name in ('time', 'size'):
                p.update(self._prefixprops(child, name))

            elif name in ('checksum', 'location'): 
                p.update(self._prefixprops(child, name))
                p[name + '_value'] = child.text
                if name == 'location' and "location_base" not in p:
                    p["location_base"] = None
            
            elif name == 'format': 
                self.setFormat(child)

        p['pkgId'] = p['checksum_value']
        elem.clear()

    def setFormat(self, elem):

        # Avoid excessive typing :)
        p = self._p

        for child in elem:
            name = self._bn(child.tag)

            if name in ('license', 'vendor', 'group', 'buildhost',
                        'sourcerpm'):
                p[name] = child.text

            elif name in ('provides', 'requires', 'conflicts', 
                          'obsoletes'):
                self.prco[name] = self.getPrco(child)

            elif name == 'header-range':
                p.update(self._prefixprops(child, 'rpm_header'))

            elif name == 'file':
                file_type = child.get('type', 'file')
                path = child.text
                self.files[path] = file_type

    def getPrco(self, elem):
        members = []
        for child in elem:
            members.append(child.attrib)
        return members
        
        
class FilelistsEntry(BaseEntry):
    def __init__(self, elem):
        BaseEntry.__init__(self, elem)
        self._p['pkgId'] = elem.attrib['pkgid']
        self.files = {}
        for child in elem:
            name = self._bn(child.tag)
            if name == 'file':
                file_type = child.get('type', 'file')
                path = child.text
                self.files[path] = file_type
        elem.clear()
                
class OtherEntry(BaseEntry):
    def __init__(self, elem):
        BaseEntry.__init__(self, elem)
        self._p['pkgId'] = elem.attrib['pkgid']
        self._p['changelog'] = []
        for child in elem:
            name = self._bn(child.tag)
            if name == 'changelog':
                entry = child.attrib
                entry['value'] = child.text
                self._p['changelog'].append(entry)
        elem.clear()



def test():
    import sys

    parser = MDParser(sys.argv[1])

    for pkg in parser:
        print '-' * 40
        print pkg

    print 'read: %s packages (%s suggested)' % (parser.count, parser.total)

if __name__ == '__main__':
    test()
                                                                                                                                                                                                                                                        usr/lib/python2.7/dist-packages/yum/mdparser.pyc                                                    0100644 0000000 0000000 00000017122 13077704344 020273  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s   d  d l  Z  y d  d l m Z Wn e k
 r? d  d l Z n Xe j Z d  d l m Z d  d l Z d  d l Z d d d     YZ	 d d d     YZ
 d e
 f d	     YZ d
 e
 f d     YZ d e
 f d     YZ d   Z e d k r e   n  d S(   iN(   t   cElementTree(   t   StringIOt   MDParserc           B   s#   e  Z d    Z d   Z d   Z RS(   c         C   s   i t  d 6t d 6t d 6} d  |  _ d |  _ d  |  _ | d d k r[ t j | d  } n t | d  } t	 | d d } | j
   |  _ |  j j   \ } } | j | j d   |  _ |  j s t d | j | f   n  t | j d d   |  _ d  S(   Ns/   {http://linux.duke.edu/metadata/common}metadatas3   {http://linux.duke.edu/metadata/filelists}filelistss/   {http://linux.duke.edu/metadata/other}otherdatai    is   .gzt   rt   eventst   startt   ends    Unknown repodata type "%s" in %st   packages(   s   starts   end(   t   PrimaryEntryt   FilelistsEntryt
   OtherEntryt   Nonet   totalt   countt   _handlerclst   gzipt   opent	   iterparset   __iter__t   readert   nextt   gett   tagt
   ValueErrort   int(   t   selft   filenamet   handlerst   fht   parsert   eventt   elem(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   __init__"   s$    
			 	c         C   s   |  S(   N(    (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR   =   s    c         C   s_   xR |  j  D]G \ } } | d k r
 | j d d k r
 |  j d 7_ |  j |  Sq
 Wt  d  S(   NR   it   packagei   (   R   R   R   R   t   StopIteration(   R   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR   @   s
    (   t   __name__t
   __module__R    R   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR       s   		t	   BaseEntryc           B   sY   e  Z d    Z d   Z d   Z d   Z d   Z d   Z d   Z d   Z	 d   Z
 RS(	   c         C   s   i  |  _  d  S(   N(   t   _p(   R   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR    I   s    c         C   s   |  j  | S(   N(   R&   (   R   t   k(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   __getitem__L   s    c         C   s   |  j  j   S(   N(   R&   t   keys(   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR)   O   s    c         C   s   |  j  j   S(   N(   R&   t   values(   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR*   R   s    c         C   s&   t  j d t j d d | |  j k S(   Ns3   has_key() will go away in a future version of Yum.
t
   stackleveli   (   t   warningst   warnt   Errorst   YumFutureDeprecationWarningR&   (   R   R'   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   has_keyU   s    	c         C   s   t  |  j  S(   N(   t   iterR&   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR   Z   s    c         C   sd   t    } |  j   } | j   x8 | D]0 } d | |  | f } | j | j d   q& W| j   S(   Nu   %s=%s
t   utf8(   R   R)   t   sortt   writet   encodet   getvalue(   R   t   outR)   R'   t   line(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   __str__]   s    	
c         C   s*   | j  d  d k r | S| j d  d S(   Nt   }ii   (   t   findt   split(   R   t   qn(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   _bnf   s     c         C   s@   i  } x3 | j  D]( } | j  | | | d |  j |  <q W| S(   Nt   _(   t   attribR>   (   R   R   t   prefixt   rett   key(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   _prefixpropsj   s    &(   R#   R$   R    R(   R)   R*   R0   R   R9   R>   RD   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR%   H   s   									R   c           B   s#   e  Z d    Z d   Z d   Z RS(   c         C   sG  t  j |  |  |  j } i  |  _ i  |  _ x | D] } |  j | j  } | d k rf | j | | <q2 | d k r | j | j	  q2 | d k r | j |  j
 | |   q2 | d k r| j |  j
 | |   | j | | d <| d k r'd | k r'd  | d <q'q2 | d k r2 |  j |  q2 q2 W| d | d <| j   d  S(   Nt   namet   archt   summaryt   descriptiont   urlt   packagert   versiont   timet   sizet   checksumt   locationt   _valuet   location_baset   formatt   checksum_valuet   pkgId(   s   nameRF   RG   RH   RI   RJ   (   RL   s   size(   RN   RO   (   R%   R    R&   t   prcot   filesR>   R   t   textt   updateR@   RD   R   t	   setFormatt   clear(   R   R   t   pt   childRE   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR    q   s,    				c         C   s   |  j  } x | D] } |  j | j  } | d k rD | j | | <q | d k ri |  j |  |  j | <q | d
 k r | j |  j | d   q | d k r | j d d  } | j } | |  j	 | <q q Wd  S(   Nt   licenset   vendort   groupt	   buildhostt	   sourcerpmt   providest   requirest	   conflictst	   obsoletess   header-ranget
   rpm_headert   filet   type(   s   licenseR^   s   groupR`   Ra   (   Rb   Rc   Rd   Re   (
   R&   R>   R   RW   t   getPrcoRU   RX   RD   R   RV   (   R   R   R[   R\   RE   t	   file_typet   path(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyRY      s    				c         C   s+   g  } x | D] } | j  | j  q W| S(   N(   t   appendR@   (   R   R   t   membersR\   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyRi      s    (   R#   R$   R    RY   Ri   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR   p   s   	 	R	   c           B   s   e  Z d    Z RS(   c         C   s   t  j |  |  | j d |  j d <i  |  _ xW | D]O } |  j | j  } | d k r4 | j d d  } | j } | |  j | <q4 q4 W| j	   d  S(   Nt   pkgidRT   Rg   Rh   (
   R%   R    R@   R&   RV   R>   R   R   RW   RZ   (   R   R   R\   RE   Rj   Rk   (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR       s    		(   R#   R$   R    (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR	      s   R
   c           B   s   e  Z d    Z RS(   c         C   s   t  j |  |  | j d |  j d <g  |  j d <xY | D]Q } |  j | j  } | d k r8 | j } | j | d <|  j d j |  q8 q8 W| j   d  S(   NRn   RT   t	   changelogt   value(	   R%   R    R@   R&   R>   R   RW   Rl   RZ   (   R   R   R\   RE   t   entry(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR       s    	(   R#   R$   R    (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyR
      s   c          C   sW   d d  l  }  t |  j d  } x | D] } d d GH| GHq& Wd | j | j f GHd  S(   Nii   t   -i(   s    read: %s packages (%s suggested)(   t   sysR   t   argvR   R   (   Rs   R   t   pkg(    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   test   s    		t   __main__(    (    (   R   t	   xml.etreeR    t   ImportErrorR   t	   cStringIOR   R,   R.   R   R%   R   R	   R
   Rv   R#   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/mdparser.pyt   <module>   s    	((@	                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/lib/python2.7/dist-packages/yum/metalink.py                                                     0100644 0000000 0000000 00000022442 12451005146 020105  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -t
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Copyright 2008 Red Hat
#
# James Antill <james@fedoraproject.org>

# Parse the new MirrorManager metalink output:

import sys
import os
import time
from urlgrabber.progress import format_number

import Errors

from yum.misc import cElementTree_xmlparse as xmlparse

class MetaLinkRepoErrorParseFail(Errors.RepoError):
    """ An exception thrown for an unparsable MetaLinkRepoMD file. """
    pass

__XML_NS_ML__ = 'http://www.metalinker.org/'
__XML_NS_MM__ = 'http://fedorahosted.org/mirrormanager'
__XML_FMT__   = {'ml' : __XML_NS_ML__,
                 'mm' : __XML_NS_MM__}

__ML_FILE_ELEMENT__ = """\
{%(ml)s}files/{%(ml)s}file\
""" % __XML_FMT__
__ML_OLD_FILE_ELEMENTS__ = """\
{%(mm)s}alternates/{%(mm)s}alternate\
""" % __XML_FMT__
__ML_RESOURCES__ = """\
{%(ml)s}resources\
""" % __XML_FMT__

class MetaLinkFile:
    """ Parse the file metadata out of a metalink file. """

    def __init__(self, elem):
        # We aren't "using" any of these, just storing them.
        chksums = set(["md5", 'sha1', 'sha256', 'sha512'])

        for celem in elem:
            if False: pass
            elif celem.tag == "{%s}timestamp" % __XML_NS_MM__:
                self.timestamp = int(celem.text)
            elif celem.tag == "{%s}size" % __XML_NS_ML__:
                self.size = int(celem.text)
            elif celem.tag == "{%s}verification" % __XML_NS_ML__:
                self.chksums = {}
                for helem in celem:
                    if (helem.tag == "{%s}hash"  % __XML_NS_ML__ and
                        helem.get("type") in chksums):
                        self.chksums[helem.get("type").lower()] = helem.text

        if not hasattr(self, 'timestamp'):
            raise MetaLinkRepoErrorParseFail, "No timestamp for file"
        if not hasattr(self, 'size'):
            raise MetaLinkRepoErrorParseFail, "No size for file"
        if not hasattr(self, 'chksums'):
            raise MetaLinkRepoErrorParseFail, "No verifications for file"

    def __str__(self):
        return """\
Timestamp: %s
Size:      %5s (%d)
MD5:       %s
SHA1:      %s
SHA256:    %s
SHA512:    %s
""" % (time.ctime(self.timestamp), format_number(self.size), self.size,
       self.md5, self.sha1, self.sha256, self.sha512)

    def _get_md5(self):
        return self.chksums.get('md5', '')
    md5 = property(_get_md5)
    def _get_sha1(self):
        return self.chksums.get('sha1', '')
    sha1 = property(_get_sha1)
    def _get_sha256(self):
        return self.chksums.get('sha256', '')
    sha256 = property(_get_sha256)
    def _get_sha512(self):
        return self.chksums.get('sha512', '')
    sha512 = property(_get_sha512)

    def __cmp__(self, other):
        if other is None:
            return 1
        ret = cmp(self.timestamp, other.timestamp)
        if ret:
            return -ret
        ret = cmp(self.size, other.size)
        if ret:
            return ret
        ret = cmp(self.md5, other.md5)
        if ret:
            return ret
        ret = cmp(self.sha1, other.sha1)
        if ret:
            return ret
        ret = cmp(self.sha256, other.sha256)
        if ret:
            return ret
        ret = cmp(self.sha512, other.sha512)
        if ret:
            return ret
        return 0


class MetaLinkURL:
    """ Parse the URL metadata out of a metalink file. """

    def __init__(self, elem, max_connections):
        assert elem.tag == '{%s}url' % __XML_NS_ML__

        self.max_connections = max_connections

        self.url        = elem.text
        self.preference = int(elem.get("preference", -1))
        self.protocol   = elem.get("type") # This is the "std" attribute name
        self.location   = elem.get("location")
        self.private    = elem.get("{%s}private" % __XML_NS_MM__, "false")
        self.private    = self.private.lower() == "true"

        if self.protocol is None: # Try for the old MM protocol attribute
            self.protocol   = elem.get("protocol")

    def __str__(self):
        return """\
URL:             %s
Preference:      %d
Max-Connections: %d
Protocol:        %s
Location:        %s
Private:         %s
""" % (self.url, self.preference, self.max_connections,
       self.protocol, self.location, self.private)

    def __cmp__(self, other):
        if other is None:
            return 1
        ret = cmp(self.preference, other.preference)
        if ret:
            return -ret
        ret = cmp(self.protocol == "https", other.protocol == "https")
        if ret:
            return -ret
        ret = cmp(self.protocol == "http", other.protocol == "http")
        if ret:
            return -ret
        return cmp(self.url, other.url)

    def usable(self):
        if self.protocol is None:
            return False
        if not self.url:
            return False
        return True

class MetaLinkRepoMD:
    """ Parse a metalink file for repomd.xml. """

    def __init__(self, filename):
        self.name   = None
        self.repomd = None
        self.old_repomds = []
        self.mirrors = []
        if not os.path.exists(filename):
            raise MetaLinkRepoErrorParseFail, "File %s does not exist" %filename
        try:
            root = xmlparse(filename)
        except SyntaxError:
            raise MetaLinkRepoErrorParseFail, "File %s is not XML" % filename

        for elem in root.findall(__ML_FILE_ELEMENT__):
            name = elem.get('name')
            if os.path.basename(name) != 'repomd.xml':
                continue

            if self.name is not None and self.name != name:
                raise MetaLinkRepoErrorParseFail, "Different paths for repomd file"
            self.name = name

            repomd = MetaLinkFile(elem)

            if self.repomd is not None and self.repomd != repomd:
                raise MetaLinkRepoErrorParseFail, "Different data for repomd file"
            self.repomd = repomd

            for celem in elem.findall(__ML_OLD_FILE_ELEMENTS__):
                self.old_repomds.append(MetaLinkFile(celem))

            for celem in elem.findall(__ML_RESOURCES__):
                max_connections = int(celem.get("maxconnections"))
                for uelem in celem:
                    if uelem.tag == "{%s}url"  % __XML_NS_ML__:
                        self.mirrors.append(MetaLinkURL(uelem, max_connections))

        self.old_repomds.sort()
        self.mirrors.sort()

        if self.repomd is None:
            raise MetaLinkRepoErrorParseFail, "No repomd file"
        if len(self.mirrors) < 1:
            raise MetaLinkRepoErrorParseFail, "No mirror"

    def urls(self):
        """ Iterate plain urls for the mirrors, like the old mirrorlist. """

        # Get the hostname from a url, stripping away any usernames/passwords
        # Borrowd from fastestmirror
        url2host = lambda url: url.split('/')[2].split('@')[-1]
        hosts = set() # Don't want multiple urls for one host in plain mode
                      # The list of URLs is sorted, so http is before ftp

        for mirror in self.mirrors:
            url = mirror.url

            # This is what yum supports atm. ... no rsync etc.
            if url.startswith("file:"):
                pass
            elif (url.startswith("http:") or url.startswith("ftp:") or
                  url.startswith("https:")):
                host = url2host(url)
                if host in hosts:
                    continue
                hosts.add(host)
            else:
                continue

            #  The mirror urls in the metalink file are for repomd.xml so it
            # gives a list of mirrors for that one file, but we want the list
            # of mirror baseurls. Joy of reusing other people's stds. :)
            if not url.endswith("/repodata/repomd.xml"):
                continue
            yield url[:-len("/repodata/repomd.xml")]

    def __str__(self):
        ret = str(self.repomd)
        done = False
        for orepomd in self.old_repomds:
            if not done: ret += "%s\n" % ("-" * 79)
            if done:     ret += "\n"
            done = True
            ret += str(orepomd)
        done = False
        for url in self.mirrors:
            if not done: ret += "%s\n" % ("-" * 79)
            if done:     ret += "\n"
            done = True
            ret += str(url)
        return ret


def main():
    """ MetaLinkRepoMD test function. """

    def usage():
        print >> sys.stderr, "Usage: %s <metalink> ..." % sys.argv[0]
        sys.exit(1)

    if len(sys.argv) < 2:
        usage()

    for filename in sys.argv[1:]:
        if not os.path.exists(filename):
            print "No such file:", filename
            continue

        print "File:", filename
        print MetaLinkRepoMD(filename)
        print ''

if __name__ == '__main__':
    main()
                                                                                                                                                                                                                              usr/lib/python2.7/dist-packages/yum/metalink.pyc                                                    0100644 0000000 0000000 00000021517 13077704344 020265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  d l  Z  d  d l Z d  d l Z d  d l m Z d  d l Z d  d l m Z d e j	 f d     YZ
 d Z d Z i e d 6e d	 6Z d
 e Z d e Z d e Z d d d     YZ d d d     YZ d d d     YZ d   Z e d k r e   n  d S(   iN(   t   format_number(   t   cElementTree_xmlparset   MetaLinkRepoErrorParseFailc           B   s   e  Z d  Z RS(   s<    An exception thrown for an unparsable MetaLinkRepoMD file. (   t   __name__t
   __module__t   __doc__(    (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR      s   s   http://www.metalinker.org/s%   http://fedorahosted.org/mirrormanagert   mlt   mms   {%(ml)s}files/{%(ml)s}files$   {%(mm)s}alternates/{%(mm)s}alternates   {%(ml)s}resourcest   MetaLinkFilec           B   s}   e  Z d  Z d   Z d   Z d   Z e e  Z d   Z e e  Z	 d   Z
 e e
  Z d   Z e e  Z d   Z RS(   s1    Parse the file metadata out of a metalink file. c         C   sQ  t  d d d d g  } x | D] } t r. q | j d t k rV t | j  |  _ q | j d t k r~ t | j  |  _ q | j d t k r i  |  _	 x[ | D]P } | j d t k r | j
 d	  | k r | j |  j	 | j
 d	  j   <q q Wq q Wt |  d
  st d  n  t |  d  s2t d  n  t |  d  sMt d  n  d  S(   Nt   md5t   sha1t   sha256t   sha512s   {%s}timestamps   {%s}sizes   {%s}verifications   {%s}hasht   typet	   timestamps   No timestamp for filet   sizes   No size for filet   chksumss   No verifications for file(   t   sett   Falset   tagt   __XML_NS_MM__t   intt   textR   t   __XML_NS_ML__R   R   t   gett   lowert   hasattrR   (   t   selft   elemR   t   celemt   helem(    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   __init__5   s(     	-c         C   sA   d t  j |  j  t |  j  |  j |  j |  j |  j |  j f S(   NsZ   Timestamp: %s
Size:      %5s (%d)
MD5:       %s
SHA1:      %s
SHA256:    %s
SHA512:    %s
(	   t   timet   ctimeR   R    R   R	   R
   R   R   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   __str__M   s    $c         C   s   |  j  j d d  S(   NR	   t    (   R   R   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   _get_md5X   s    c         C   s   |  j  j d d  S(   NR
   R#   (   R   R   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt	   _get_sha1[   s    c         C   s   |  j  j d d  S(   NR   R#   (   R   R   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   _get_sha256^   s    c         C   s   |  j  j d d  S(   NR   R#   (   R   R   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   _get_sha512a   s    c         C   s   | d  k r d St |  j | j  } | r0 | St |  j | j  } | rO | St |  j | j  } | rn | St |  j | j  } | r | St |  j | j  } | r | St |  j | j  } | r | Sd S(   Ni   i    (   t   Nonet   cmpR   R   R	   R
   R   R   (   R   t   othert   ret(    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   __cmp__e   s*    (   R   R   R   R   R"   R$   t   propertyR	   R%   R
   R&   R   R'   R   R,   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR   2   s   						t   MetaLinkURLc           B   s2   e  Z d  Z d   Z d   Z d   Z d   Z RS(   s0    Parse the URL metadata out of a metalink file. c         C   s   | j  d t k s t  | |  _ | j |  _ t | j d d   |  _ | j d  |  _	 | j d  |  _
 | j d t d  |  _ |  j j   d k |  _ |  j	 d  k r | j d	  |  _	 n  d  S(
   Ns   {%s}urlt
   preferenceiR   t   locations   {%s}privatet   falset   truet   protocol(   R   R   t   AssertionErrort   max_connectionsR   t   urlR   R   R/   R3   R0   R   t   privateR   R(   (   R   R   R5   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR      s    	c         C   s,   d |  j  |  j |  j |  j |  j |  j f S(   Nsx   URL:             %s
Preference:      %d
Max-Connections: %d
Protocol:        %s
Location:        %s
Private:         %s
(   R6   R/   R5   R3   R0   R7   (   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR"      s    c         C   s   | d  k r d St |  j | j  } | r0 | St |  j d k | j d k  } | r\ | St |  j d k | j d k  } | r | St |  j | j  S(   Ni   t   httpst   http(   R(   R)   R/   R3   R6   (   R   R*   R+   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR,      s    !!c         C   s$   |  j  d  k r t S|  j s  t St S(   N(   R3   R(   R   R6   t   True(   R   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   usable   s
    	(   R   R   R   R   R"   R,   R;   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR.   }   s
   			t   MetaLinkRepoMDc           B   s)   e  Z d  Z d   Z d   Z d   Z RS(   s'    Parse a metalink file for repomd.xml. c   	      C   s)  d  |  _ d  |  _ g  |  _ g  |  _ t j j |  sF t d |  n  y t	 |  } Wn t
 k
 rv t d |  n XxU| j t  D]D} | j d  } t j j |  d k r q n  |  j d  k	 r |  j | k r t d  n  | |  _ t |  } |  j d  k	 r#|  j | k r#t d  n  | |  _ x- | j t  D] } |  j j t |   q<Wxl | j t  D][ } t | j d   } x= | D]5 } | j d t k r|  j j t | |   qqWqlWq W|  j j   |  j j   |  j d  k rt d	  n  t |  j  d
 k  r%t d  n  d  S(   Ns   File %s does not exists   File %s is not XMLt   names
   repomd.xmls   Different paths for repomd files   Different data for repomd filet   maxconnectionss   {%s}urls   No repomd filei   s	   No mirror(   R(   R=   t   repomdt   old_repomdst   mirrorst   ost   patht   existsR   t   xmlparset   SyntaxErrort   findallt   __ML_FILE_ELEMENT__R   t   basenameR   t   __ML_OLD_FILE_ELEMENTS__t   appendt   __ML_RESOURCES__R   R   R   R.   t   sortt   len(	   R   t   filenamet   rootR   R=   R?   R   R5   t   uelem(    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR      sD    						(c         c   s   d   } t    } x |  j D] } | j } | j d  r= n^ | j d  sj | j d  sj | j d  r | |  } | | k r q n  | j |  n q | j d  s q n  | t d   Vq Wd S(   s>    Iterate plain urls for the mirrors, like the old mirrorlist. c         S   s   |  j  d  d j  d  d S(   Nt   /i   t   @i(   t   split(   R6   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   <lambda>   s    s   file:s   http:s   ftp:s   https:s   /repodata/repomd.xmlN(   R   RA   R6   t
   startswitht   addt   endswithRN   (   R   t   url2hostt   hostst   mirrorR6   t   host(    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   urls   s     			c         C   s   t  |  j  } t } xU |  j D]J } | s@ | d d d 7} n  | rS | d 7} n  t } | t  |  7} q Wt } xU |  j D]J } | s | d d d 7} n  | r | d 7} n  t } | t  |  7} q} W| S(   Ns   %s
t   -iO   s   
(   t   strR?   R   R@   R:   RA   (   R   R+   t   donet   orepomdR6   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR"      s$        (   R   R   R   R   R]   R"   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyR<      s   	,	c          C   s~   d   }  t  t j  d k  r( |    n  xO t j d D]@ } t j j |  s] d G| GHq6 n  d G| GHt |  GHd GHq6 Wd S(   s    MetaLinkRepoMD test function. c           S   s)   t  j d t  j d IJt  j d  d  S(   Ns   Usage: %s <metalink> ...i    i   (   t   syst   stderrt   argvt   exit(    (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   usage  s    i   i   s   No such file:s   File:R#   N(   RN   Rb   Rd   RB   RC   RD   R<   (   Rf   RO   (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   main  s    	
		t   __main__(    (    (    (   Rb   RB   R    t   urlgrabber.progressR    t   Errorst   yum.miscR   RE   t	   RepoErrorR   R   R   t   __XML_FMT__RH   RJ   RL   R   R.   R<   Rg   R   (    (    (    s0   /usr/lib/python2.7/dist-packages/yum/metalink.pyt   <module>   s&   




K2_	                                                                                                                                                                                 usr/lib/python2.7/dist-packages/yum/misc.py                                                         0100644 0000000 0000000 00000110574 12451005146 017240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python -tt
"""
Assorted utility functions for yum.
"""

import types
import os
import os.path
from cStringIO import StringIO
import base64
import struct
import re
import errno
import Errors
import constants
import pgpmsg
import tempfile
import glob
import pwd
import fnmatch
import bz2
import gzip
import shutil
_available_compression = ['gz', 'bz2']
try:
    import lzma
    _available_compression.append('xz')
except ImportError:
    lzma = None

from rpmUtils.miscutils import stringToVersion, flagToString
from stat import *
try:
    import gpgme
    import gpgme.editutil
except ImportError:
    gpgme = None
try:
    import hashlib
    _available_checksums = set(['md5', 'sha1', 'sha256', 'sha384', 'sha512'])
    _default_checksums = ['sha256']
except ImportError:
    # Python-2.4.z ... gah!
    import sha
    import md5
    _available_checksums = set(['md5', 'sha1'])
    _default_checksums = ['sha1']
    class hashlib:

        @staticmethod
        def new(algo):
            if algo == 'md5':
                return md5.new()
            if algo == 'sha1':
                return sha.new()
            raise ValueError, "Bad checksum type"

from Errors import MiscError
# These are API things, so we can't remove them even if they aren't used here.
# pylint: disable-msg=W0611
from i18n import to_utf8, to_unicode
# pylint: enable-msg=W0611

_share_data_store   = {}
_share_data_store_u = {}
def share_data(value):
    """ Take a value and use the same value from the store,
        if the value isn't in the store this one becomes the shared version. """
    #  We don't want to change the types of strings, between str <=> unicode
    # and hash('a') == hash(u'a') ... so use different stores.
    #  In theory eventaully we'll have all of one type, but don't hold breath.
    store = _share_data_store
    if isinstance(value, unicode):
        store = _share_data_store_u
    # hahahah, of course the above means that:
    #   hash(('a', 'b')) == hash((u'a', u'b'))
    # ...which we have in deptuples, so just screw sharing those atm.
    if type(value) == types.TupleType:
        return value
    return store.setdefault(value, value)

def unshare_data():
    global _share_data_store
    global _share_data_store_u
    _share_data_store   = {}
    _share_data_store_u = {}

_re_compiled_glob_match = None
def re_glob(s):
    """ Tests if a string is a shell wildcard. """
    # TODO/FIXME maybe consider checking if it is a stringsType before going on - otherwise
    # returning None
    global _re_compiled_glob_match
    if _re_compiled_glob_match is None:
        _re_compiled_glob_match = re.compile('[*?]|\[.+\]').search
    return _re_compiled_glob_match(s)

_re_compiled_filename_match = None
def re_filename(s):
    """ Tests if a string could be a filename. We still get negated character
        classes wrong (are they supported), and ranges in character classes. """
    global _re_compiled_filename_match
    if _re_compiled_filename_match is None:
        _re_compiled_filename_match = re.compile('[/*?]|\[[^]]*/[^]]*\]').match
    return _re_compiled_filename_match(s)

def re_primary_filename(filename):
    """ Tests if a filename string, can be matched against just primary.
        Note that this can produce false negatives (but not false
        positives). Note that this is a superset of re_primary_dirname(). """
    if re_primary_dirname(filename):
        return True
    if filename == '/usr/lib/sendmail':
        return True
    return False

def re_primary_dirname(dirname):
    """ Tests if a dirname string, can be matched against just primary. Note
        that this is a subset of re_primary_filename(). """
    if 'bin/' in dirname:
        return True
    if dirname.startswith('/etc/'):
        return True
    return False

_re_compiled_full_match = None
def re_full_search_needed(s):
    """ Tests if a string needs a full nevra match, instead of just name. """
    global _re_compiled_full_match
    if _re_compiled_full_match is None:
        # A glob, or a "." or "-" separator, followed by something (the ".")
        one = re.compile('.*([-.*?]|\[.+\]).').match
        # Any epoch, for envra
        two = re.compile('[0-9]+:').match
        _re_compiled_full_match = (one, two)
    for rec in _re_compiled_full_match:
        if rec(s):
            return True
    return False

def re_remote_url(s):
    """ Tests if a string is a "remote" URL, http, https, ftp. """
    s = s.lower()
    if s.startswith("http://"):
        return True
    if s.startswith("https://"):
        return True
    if s.startswith("ftp://"):
        return True
    return False

###########
# Title: Remove duplicates from a sequence
# Submitter: Tim Peters 
# From: http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560
def unique(s):
    """Return a list of the elements in s, but without duplicates.

    For example, unique([1,2,3,1,2,3]) is some permutation of [1,2,3],
    unique("abcabc") some permutation of ["a", "b", "c"], and
    unique(([1, 2], [2, 3], [1, 2])) some permutation of
    [[2, 3], [1, 2]].

    For best speed, all sequence elements should be hashable.  Then
    unique() will usually work in linear time.

    If not possible, the sequence elements should enjoy a total
    ordering, and if list(s).sort() doesn't raise TypeError it's
    assumed that they do enjoy a total ordering.  Then unique() will
    usually work in O(N*log2(N)) time.

    If that's not possible either, the sequence elements must support
    equality-testing.  Then unique() will usually work in quadratic
    time.
    """

    n = len(s)
    if n == 0:
        return []

    # Try using a set first, as that's the fastest and will usually
    # work.  If it doesn't work, it will usually fail quickly, so it
    # usually doesn't cost much to *try* it.  It requires that all the
    # sequence elements be hashable, and support equality comparison.
    try:
        u = set(s)
    except TypeError:
        pass
    else:
        return list(u)

    # We can't hash all the elements.  Second fastest is to sort,
    # which brings the equal elements together; then duplicates are
    # easy to weed out in a single pass.
    # NOTE:  Python's list.sort() was designed to be efficient in the
    # presence of many duplicate elements.  This isn't true of all
    # sort functions in all languages or libraries, so this approach
    # is more effective in Python than it may be elsewhere.
    try:
        t = list(s)
        t.sort()
    except TypeError:
        del t  # move on to the next method
    else:
        assert n > 0
        last = t[0]
        lasti = i = 1
        while i < n:
            if t[i] != last:
                t[lasti] = last = t[i]
                lasti += 1
            i += 1
        return t[:lasti]

    # Brute force is all that's left.
    u = []
    for x in s:
        if x not in u:
            u.append(x)
    return u

class Checksums:
    """ Generate checksum(s), on given pieces of data. Producing the
        Length and the result(s) when complete. """

    def __init__(self, checksums=None, ignore_missing=False, ignore_none=False):
        if checksums is None:
            checksums = _default_checksums
        self._sumalgos = []
        self._sumtypes = []
        self._len = 0

        done = set()
        for sumtype in checksums:
            if sumtype == 'sha':
                sumtype = 'sha1'
            if sumtype in done:
                continue

            if sumtype in _available_checksums:
                sumalgo = hashlib.new(sumtype)
            elif ignore_missing:
                continue
            else:
                raise MiscError, 'Error Checksumming, bad checksum type %s' % sumtype
            done.add(sumtype)
            self._sumtypes.append(sumtype)
            self._sumalgos.append(sumalgo)
        if not done and not ignore_none:
            raise MiscError, 'Error Checksumming, no valid checksum type'

    def __len__(self):
        return self._len

    # Note that len(x) is assert limited to INT_MAX, which is 2GB on i686.
    length = property(fget=lambda self: self._len)

    def update(self, data):
        self._len += len(data)
        for sumalgo in self._sumalgos:
            sumalgo.update(data)

    def read(self, fo, size=2**16):
        data = fo.read(size)
        self.update(data)
        return data

    def hexdigests(self):
        ret = {}
        for sumtype, sumdata in zip(self._sumtypes, self._sumalgos):
            ret[sumtype] = sumdata.hexdigest()
        return ret

    def hexdigest(self, checksum=None):
        if checksum is None:
            if not self._sumtypes:
                return None
            checksum = self._sumtypes[0]
        if checksum == 'sha':
            checksum = 'sha1'
        return self.hexdigests()[checksum]

    def digests(self):
        ret = {}
        for sumtype, sumdata in zip(self._sumtypes, self._sumalgos):
            ret[sumtype] = sumdata.digest()
        return ret

    def digest(self, checksum=None):
        if checksum is None:
            if not self._sumtypes:
                return None
            checksum = self._sumtypes[0]
        if checksum == 'sha':
            checksum = 'sha1'
        return self.digests()[checksum]


class AutoFileChecksums:
    """ Generate checksum(s), on given file/fileobject. Pretending to be a file
        object (overrrides read). """

    def __init__(self, fo, checksums, ignore_missing=False, ignore_none=False):
        self._fo       = fo
        self.checksums = Checksums(checksums, ignore_missing, ignore_none)

    def __getattr__(self, attr):
        return getattr(self._fo, attr)

    def read(self, size=-1):
        return self.checksums.read(self._fo, size)


def checksum(sumtype, file, CHUNK=2**16, datasize=None):
    """takes filename, hand back Checksum of it
       sumtype = md5 or sha/sha1/sha256/sha512 (note sha == sha1)
       filename = /path/to/file
       CHUNK=65536 by default"""
     
    # chunking brazenly lifted from Ryan Tomayko
    try:
        if type(file) not in types.StringTypes:
            fo = file # assume it's a file-like-object
        else:           
            fo = open(file, 'r', CHUNK)

        data = Checksums([sumtype])
        while data.read(fo, CHUNK):
            if datasize is not None and data.length > datasize:
                break

        if type(file) is types.StringType:
            fo.close()
            del fo
            
        # This screws up the length, but that shouldn't matter. We only care
        # if this checksum == what we expect.
        if datasize is not None and datasize != data.length:
            return '!%u!%s' % (datasize, data.hexdigest(sumtype))

        return data.hexdigest(sumtype)
    except (IOError, OSError), e:
        raise MiscError, 'Error opening file for checksum: %s' % file

def getFileList(path, ext, filelist):
    """Return all files in path matching ext, store them in filelist, 
       recurse dirs return list object"""
    
    extlen = len(ext)
    try:
        dir_list = os.listdir(path)
    except OSError, e:
        raise MiscError, ('Error accessing directory %s, %s') % (path, e)
        
    for d in dir_list:
        if os.path.isdir(path + '/' + d):
            filelist = getFileList(path + '/' + d, ext, filelist)
        else:
            if not ext or d[-extlen:].lower() == '%s' % (ext):
                newpath = os.path.normpath(path + '/' + d)
                filelist.append(newpath)
                    
    return filelist

class GenericHolder:
    """Generic Holder class used to hold other objects of known types
       It exists purely to be able to do object.somestuff, object.someotherstuff
       or object[key] and pass object to another function that will 
       understand it"""

    def __init__(self, iter=None):
        self.__iter = iter
       
    def __iter__(self):
        if self.__iter is not None:
            return iter(self[self.__iter])

    def __getitem__(self, item):
        if hasattr(self, item):
            return getattr(self, item)
        else:
            raise KeyError, item

def procgpgkey(rawkey):
    '''Convert ASCII armoured GPG key to binary
    '''
    # TODO: CRC checking? (will RPM do this anyway?)
    
    # Normalise newlines
    rawkey = re.sub('\r\n?', '\n', rawkey)

    # Extract block
    block = StringIO()
    inblock = 0
    pastheaders = 0
    for line in rawkey.split('\n'):
        if line.startswith('-----BEGIN PGP PUBLIC KEY BLOCK-----'):
            inblock = 1
        elif inblock and line.strip() == '':
            pastheaders = 1
        elif inblock and line.startswith('-----END PGP PUBLIC KEY BLOCK-----'):
            # Hit the end of the block, get out
            break
        elif pastheaders and line.startswith('='):
            # Hit the CRC line, don't include this and stop
            break
        elif pastheaders:
            block.write(line+'\n')
  
    # Decode and return
    return base64.decodestring(block.getvalue())

def getgpgkeyinfo(rawkey, multiple=False):
    '''Return a dict of info for the given ASCII armoured key text

    Returned dict will have the following keys: 'userid', 'keyid', 'timestamp'

    Will raise ValueError if there was a problem decoding the key.
    '''
    # Catch all exceptions as there can be quite a variety raised by this call
    key_info_objs = []
    try:
        keys = pgpmsg.decode_multiple_keys(rawkey)
    except Exception, e:
        raise ValueError(str(e))
    if len(keys) == 0:
        raise ValueError('No key found in given key data')
    
    for key in keys:    
        keyid_blob = key.public_key.key_id()

        info = {
            'userid': key.user_id,
            'keyid': struct.unpack('>Q', keyid_blob)[0],
            'timestamp': key.public_key.timestamp,
            'fingerprint' : key.public_key.fingerprint,
            'raw_key' : key.raw_key,
            'has_sig' : False,
            'valid_sig': False,
        }

        # Retrieve the timestamp from the matching signature packet 
        # (this is what RPM appears to do) 
        for userid in key.user_ids[0]:
            if not isinstance(userid, pgpmsg.signature):
                continue

            if userid.key_id() == keyid_blob:
                # Get the creation time sub-packet if available
                if hasattr(userid, 'hashed_subpaks'):
                    tspkt = \
                        userid.get_hashed_subpak(pgpmsg.SIG_SUB_TYPE_CREATE_TIME)
                    if tspkt != None:
                        info['timestamp'] = int(tspkt[1])
                        break
        key_info_objs.append(info)
    if multiple:      
        return key_info_objs
    else:
        return key_info_objs[0]
        

def keyIdToRPMVer(keyid):
    '''Convert an integer representing a GPG key ID to the hex version string
    used by RPM
    '''
    return "%08x" % (keyid & 0xffffffffL)


def keyInstalled(ts, keyid, timestamp):
    '''
    Return if the GPG key described by the given keyid and timestamp are
    installed in the rpmdb.  

    The keyid and timestamp should both be passed as integers.
    The ts is an rpm transaction set object

    Return values:
        - -1      key is not installed
        - 0       key with matching ID and timestamp is installed
        - 1       key with matching ID is installed but has a older timestamp
        - 2       key with matching ID is installed but has a newer timestamp

    No effort is made to handle duplicates. The first matching keyid is used to 
    calculate the return result.
    '''
    # Convert key id to 'RPM' form
    keyid = keyIdToRPMVer(keyid)

    # Search
    for hdr in ts.dbMatch('name', 'gpg-pubkey'):
        if hdr['version'] == keyid:
            installedts = int(hdr['release'], 16)
            if installedts == timestamp:
                return 0
            elif installedts < timestamp:
                return 1    
            else:
                return 2

    return -1

def import_key_to_pubring(rawkey, keyid, cachedir=None, gpgdir=None, make_ro_copy=True):
    # FIXME - cachedir can be removed from this method when we break api
    if gpgme is None:
        return False
    
    if not gpgdir:
        gpgdir = '%s/gpgdir' % cachedir
    
    if not os.path.exists(gpgdir):
        os.makedirs(gpgdir)
    
    key_fo = StringIO(rawkey) 
    os.environ['GNUPGHOME'] = gpgdir
    # import the key
    ctx = gpgme.Context()
    fp = open(os.path.join(gpgdir, 'gpg.conf'), 'wb')
    fp.write('')
    fp.close()
    ctx.import_(key_fo)
    key_fo.close()
    # ultimately trust the key or pygpgme is definitionally stupid
    k = ctx.get_key(keyid)
    gpgme.editutil.edit_trust(ctx, k, gpgme.VALIDITY_ULTIMATE)
    
    if make_ro_copy:

        rodir = gpgdir + '-ro'
        if not os.path.exists(rodir):
            os.makedirs(rodir, mode=0755)
            for f in glob.glob(gpgdir + '/*'):
                basename = os.path.basename(f)
                ro_f = rodir + '/' + basename
                shutil.copy(f, ro_f)
                os.chmod(ro_f, 0755)
            fp = open(rodir + '/gpg.conf', 'w', 0755)
            # yes it is this stupid, why do you ask?
            opts="""lock-never    
no-auto-check-trustdb    
trust-model direct
no-expensive-trust-checks
no-permission-warning         
preserve-permissions
"""
            fp.write(opts)
            fp.close()

        
    return True
    
def return_keyids_from_pubring(gpgdir):
    if gpgme is None or not os.path.exists(gpgdir):
        return []

    os.environ['GNUPGHOME'] = gpgdir
    ctx = gpgme.Context()
    keyids = []
    for k in ctx.keylist():
        for subkey in k.subkeys:
            if subkey.can_sign:
                keyids.append(subkey.keyid)

    return keyids

def valid_detached_sig(sig_file, signed_file, gpghome=None):
    """takes signature , file that was signed and an optional gpghomedir"""

    if gpgme is None:
        return False

    if gpghome:
        if not os.path.exists(gpghome):
            return False
        os.environ['GNUPGHOME'] = gpghome

    if hasattr(sig_file, 'read'):
        sig = sig_file
    else:
        sig = open(sig_file, 'r')
    if hasattr(signed_file, 'read'):
        signed_text = signed_file
    else:
        signed_text = open(signed_file, 'r')
    plaintext = None
    ctx = gpgme.Context()

    try:
        sigs = ctx.verify(sig, signed_text, plaintext)
    except gpgme.GpgmeError, e:
        return False
    else:
        if not sigs:
            return False
        # is there ever a case where we care about a sig beyond the first one?
        thissig = sigs[0]
        if not thissig:
            return False

        if thissig.validity in (gpgme.VALIDITY_FULL, gpgme.VALIDITY_MARGINAL,
                                gpgme.VALIDITY_ULTIMATE):
            return True

    return False

def getCacheDir(tmpdir='/var/tmp', reuse=True, prefix='yum-'):
    """return a path to a valid and safe cachedir - only used when not running
       as root or when --tempcache is set"""
    
    uid = os.geteuid()
    try:
        usertup = pwd.getpwuid(uid)
        username = usertup[0]
    except KeyError:
        return None # if it returns None then, well, it's bollocksed

    if reuse:
        # check for /var/tmp/yum-username-* - 
        prefix = '%s%s-' % (prefix, username)
        dirpath = '%s/%s*' % (tmpdir, prefix)
        cachedirs = sorted(glob.glob(dirpath))
        for thisdir in cachedirs:
            stats = os.lstat(thisdir)
            if S_ISDIR(stats[0]) and S_IMODE(stats[0]) == 448 and stats[4] == uid:
                return thisdir

    # make the dir (tempfile.mkdtemp())
    cachedir = tempfile.mkdtemp(prefix=prefix, dir=tmpdir)
    return cachedir
        
def sortPkgObj(pkg1 ,pkg2):
    """sorts a list of yum package objects by name"""
    if pkg1.name > pkg2.name:
        return 1
    elif pkg1.name == pkg2.name:
        return 0
    else:
        return -1
        
def newestInList(pkgs):
    """ Return the newest in the list of packages. """
    ret = [ pkgs.pop() ]
    newest = ret[0]
    for pkg in pkgs:
        if pkg.verGT(newest):
            ret = [ pkg ]
            newest = pkg
        elif pkg.verEQ(newest):
            ret.append(pkg)
    return ret

def version_tuple_to_string(evrTuple):
    """
    Convert a tuple representing a package version to a string.

    @param evrTuple: A 3-tuple of epoch, version, and release.

    Return the string representation of evrTuple.
    """
    (e, v, r) = evrTuple
    s = ""
    
    if e not in [0, '0', None]:
        s += '%s:' % e
    if v is not None:
        s += '%s' % v
    if r is not None:
        s += '-%s' % r
    return s

def prco_tuple_to_string(prcoTuple):
    """returns a text string of the prco from the tuple format"""
    
    (name, flag, evr) = prcoTuple
    flags = {'GT':'>', 'GE':'>=', 'EQ':'=', 'LT':'<', 'LE':'<='}
    if flag is None:
        return name
    
    return '%s %s %s' % (name, flags[flag], version_tuple_to_string(evr))

def string_to_prco_tuple(prcoString):
    """returns a prco tuple (name, flags, (e, v, r)) for a string"""

    if type(prcoString) == types.TupleType:
        (n, f, v) = prcoString
    else:
        n = prcoString
        f = v = None
        
        # We love GPG keys as packages, esp. awesome provides like:
        #  gpg(Fedora (13) <fedora@fedoraproject.org>)
        if n[0] != '/' and not n.startswith("gpg("):
            # not a file dep - look at it for being versioned
            prco_split = n.split()
            if len(prco_split) == 3:
                n, f, v = prco_split
    
    # now we have 'n, f, v' where f and v could be None and None
    if f is not None and f not in constants.LETTERFLAGS:
        if f not in constants.SYMBOLFLAGS:
            try:
                f = flagToString(int(f))
            except (ValueError,TypeError), e:
                raise Errors.MiscError, 'Invalid version flag: %s' % f
        else:
            f = constants.SYMBOLFLAGS[f]

    if type(v) in (types.StringType, types.NoneType, types.UnicodeType):
        (prco_e, prco_v, prco_r) = stringToVersion(v)
    elif type(v) in (types.TupleType, types.ListType):
        (prco_e, prco_v, prco_r) = v
    
    #now we have (n, f, (e, v, r)) for the thing specified
    return (n, f, (prco_e, prco_v, prco_r))

def refineSearchPattern(arg):
    """Takes a search string from the cli for Search or Provides
       and cleans it up so it doesn't make us vomit"""
    
    if re.search('[*{}?+]|\[.+\]', arg):
        restring = fnmatch.translate(arg)
    else:
        restring = re.escape(arg)
        
    return restring


def _decompress_chunked(source, dest, ztype):

    if ztype not in _available_compression:
        msg = "%s compression not available" % ztype
        raise Errors.MiscError, msg
    
    if ztype == 'bz2':
        s_fn = bz2.BZ2File(source, 'r')
    elif ztype == 'xz':
        s_fn = lzma.LZMAFile(source, 'r')
    elif ztype == 'gz':
        s_fn = gzip.GzipFile(source, 'r')
    
    
    destination = open(dest, 'w')

    while True:
        try:
            data = s_fn.read(1024000)
        except IOError:
            break
        
        if not data: break

        try:
            destination.write(data)
        except (OSError, IOError), e:
            msg = "Error writing to file %s: %s" % (dest, str(e))
            raise Errors.MiscError, msg
    
    destination.close()
    s_fn.close()
    
def bunzipFile(source,dest):
    """ Extract the bzipped contents of source to dest. """
    _decompress_chunked(source, dest, ztype='bz2')
    
def get_running_kernel_pkgtup(ts):
    """This takes the output of uname and figures out the pkgtup of the running
       kernel (name, arch, epoch, version, release)."""
    ver = os.uname()[2]

    # we glob for the file that MIGHT have this kernel
    # and then look up the file in our rpmdb.
    fns = sorted(glob.glob('/boot/vmlinuz*%s*' % ver))
    for fn in fns:
        mi = ts.dbMatch('basenames', fn)
        for h in mi:
            e = h['epoch']
            if h['epoch'] is None:
                e = '0'
            return (h['name'], h['arch'], e, h['version'], h['release'])
    
    return (None, None, None, None, None)
 
def get_running_kernel_version_release(ts):
    """This takes the output of uname and figures out the (version, release)
    tuple for the running kernel."""
    pkgtup = get_running_kernel_pkgtup(ts)
    if pkgtup[0] is not None:
        return (pkgtup[3], pkgtup[4])
    return (None, None)

def find_unfinished_transactions(yumlibpath='/var/lib/yum'):
    """returns a list of the timestamps from the filenames of the unfinished 
       transactions remaining in the yumlibpath specified.
    """
    timestamps = []    
    tsallg = '%s/%s' % (yumlibpath, 'transaction-all*')
    tsdoneg = '%s/%s' % (yumlibpath, 'transaction-done*')
    tsalls = glob.glob(tsallg)
    tsdones = glob.glob(tsdoneg)

    for fn in tsalls:
        if fn.endswith('disabled'):
            continue
        trans = os.path.basename(fn)
        timestamp = trans.replace('transaction-all.','')
        timestamps.append(timestamp)

    timestamps.sort()
    return timestamps
    
def find_ts_remaining(timestamp, yumlibpath='/var/lib/yum'):
    """this function takes the timestamp of the transaction to look at and 
       the path to the yum lib dir (defaults to /var/lib/yum)
       returns a list of tuples(action, pkgspec) for the unfinished transaction
       elements. Returns an empty list if none.

    """
    
    to_complete_items = []
    tsallpath = '%s/%s.%s' % (yumlibpath, 'transaction-all', timestamp)    
    tsdonepath = '%s/%s.%s' % (yumlibpath,'transaction-done', timestamp)
    tsdone_items = []

    if not os.path.exists(tsallpath):
        # something is wrong, here, probably need to raise _something_
        return to_complete_items    

            
    if os.path.exists(tsdonepath):
        tsdone_fo = open(tsdonepath, 'r')
        tsdone_items = tsdone_fo.readlines()
        tsdone_fo.close()     
    
    tsall_fo = open(tsallpath, 'r')
    tsall_items = tsall_fo.readlines()
    tsall_fo.close()
    
    for item in tsdone_items:
        # this probably shouldn't happen but it's worth catching anyway
        if item not in tsall_items:
            continue        
        tsall_items.remove(item)
        
    for item in tsall_items:
        item = item.replace('\n', '')
        if item == '':
            continue
        try:
            (action, pkgspec) = item.split()
        except ValueError, e:
            msg = "Transaction journal  file %s is corrupt." % (tsallpath)
            raise Errors.MiscError, msg
        to_complete_items.append((action, pkgspec))
    
    return to_complete_items

def seq_max_split(seq, max_entries):
    """ Given a seq, split into a list of lists of length max_entries each. """
    ret = []
    num = len(seq)
    seq = list(seq) # Trying to use a set/etc. here is bad
    beg = 0
    while num > max_entries:
        end = beg + max_entries
        ret.append(seq[beg:end])
        beg += max_entries
        num -= max_entries
    ret.append(seq[beg:])
    return ret

def _ugly_utf8_string_hack(item):
    """hands back a unicoded string"""
    # this is backward compat for handling non-utf8 filenames 
    # and content inside packages. :(
    # content that xml can cope with but isn't really kosher

    # if we're anything obvious - do them first
    if item is None:
        return ''
    elif isinstance(item, unicode):    
        return item
    
    # this handles any bogon formats we see
    du = False
    try:
        x = unicode(item, 'ascii')
        du = True
    except UnicodeError:
        encodings = ['utf-8', 'iso-8859-1', 'iso-8859-15', 'iso-8859-2']
        for enc in encodings:
            try:
                x = unicode(item, enc)
            except UnicodeError:
                pass
                
            else:
                if x.encode(enc) == item:
                    if enc != 'utf-8':
                        print '\n%s encoding on %s\n' % (enc, item)
                    return x.encode('utf-8')
    
    
    # Kill bytes (or libxml will die) not in the small byte portion of:
    #  http://www.w3.org/TR/REC-xml/#NT-Char
    # we allow high bytes, if it passed the utf8 check above. Eg.
    # good chars = #x9 | #xA | #xD | [#x20-...]
    newitem = ''
    bad_small_bytes = range(0, 8) + [11, 12] + range(14, 32)
    for char in item:
        if ord(char) in bad_small_bytes:
            pass # Just ignore these bytes...
        elif not du and ord(char) > 127:
            newitem = newitem + '?' # byte by byte equiv of escape
        else:
            newitem = newitem + char
    return newitem

__cached_saxutils = None
def to_xml(item, attrib=False):
    global __cached_saxutils
    if __cached_saxutils is None:
        import xml.sax.saxutils
        __cached_saxutils = xml.sax.saxutils

    item = _ugly_utf8_string_hack(item)
    item = to_utf8(item)
    item = item.rstrip()
    if attrib:
        item = __cached_saxutils.escape(item, entities={'"':"&quot;"})
    else:
        item = __cached_saxutils.escape(item)
    return item

def unlink_f(filename):
    """ Call os.unlink, but don't die if the file isn't there. This is the main
        difference between "rm -f" and plain "rm". """
    try:
        os.unlink(filename)
    except OSError, e:
        if e.errno != errno.ENOENT:
            raise

def stat_f(filename):
    """ Call os.stat(), but don't die if the file isn't there. Returns None. """
    try:
        return os.stat(filename)
    except OSError, e:
        if e.errno not in (errno.ENOENT, errno.ENOTDIR):
            raise
        return None

def _getloginuid():
    """ Get the audit-uid/login-uid, if available. None is returned if there
        was a problem. Note that no caching is done here. """
    #  We might normally call audit.audit_getloginuid(), except that requires
    # importing all of the audit module. And it doesn't work anyway: BZ 518721
    try:
        fo = open("/proc/self/loginuid")
    except IOError:
        return None
    data = fo.read()
    try:
        return int(data)
    except ValueError:
        return None

_cached_getloginuid = None
def getloginuid():
    """ Get the audit-uid/login-uid, if available. None is returned if there
        was a problem. The value is cached, so you don't have to save it. """
    global _cached_getloginuid
    if _cached_getloginuid is None:
        _cached_getloginuid = _getloginuid()
    return _cached_getloginuid


# ---------- i18n ----------
import locale
import sys
def setup_locale(override_codecs=True, override_time=False):
    # This test needs to be before locale.getpreferredencoding() as that
    # does setlocale(LC_CTYPE, "")
    try:
        locale.setlocale(locale.LC_ALL, '')
        # set time to C so that we output sane things in the logs (#433091)
        if override_time:
            locale.setlocale(locale.LC_TIME, 'C')
    except locale.Error, e:
        # default to C locale if we get a failure.
        print >> sys.stderr, 'Failed to set locale, defaulting to C'
        os.environ['LC_ALL'] = 'C'
        locale.setlocale(locale.LC_ALL, 'C')
        
    if override_codecs:
        import codecs
        sys.stdout = codecs.getwriter(locale.getpreferredencoding())(sys.stdout)
        sys.stdout.errors = 'replace'


def get_my_lang_code():
    try:
        mylang = locale.getlocale(locale.LC_MESSAGES)
    except ValueError, e:
        # This is RHEL-5 python crack, Eg. en_IN can't be parsed properly
        mylang = (None, None)
    if mylang == (None, None): # odd :)
        mylang = 'C'
    else:
        mylang = '.'.join(mylang)
    
    return mylang
    
def return_running_pids():
    """return list of running processids, excluding this one"""
    mypid = os.getpid()
    pids = []
    for fn in glob.glob('/proc/[0123456789]*'):
        if mypid == os.path.basename(fn):
            continue
        pids.append(os.path.basename(fn))
    return pids

def get_open_files(pid):
    """returns files open from this pid"""
    files = []
    maps_f = '/proc/%s/maps' % pid
    try:
        maps = open(maps_f, 'r')
    except (IOError, OSError), e:
        return files

    for line in maps:
        if line.find('fd:') == -1:
            continue
        line = line.replace('\n', '')
        slash = line.find('/')
        filename = line[slash:]
        filename = filename.replace('(deleted)', '') #only mildly retarded
        filename = filename.strip()
        if filename not in files:
            files.append(filename)
    
    cli_f = '/proc/%s/cmdline' % pid
    try:
        cli = open(cli_f, 'r')
    except (IOError, OSError), e:
        return files
    
    cmdline = cli.read()
    if cmdline.find('\00') != -1:
        cmds = cmdline.split('\00')
        for i in cmds:
            if i.startswith('/'):
                files.append(i)

    return files

def get_uuid(savepath):
    """create, store and return a uuid. If a stored one exists, report that
       if it cannot be stored, return a random one"""
    if os.path.exists(savepath):
        return open(savepath, 'r').read()
    else:
        try:
            from uuid import uuid4
        except ImportError:
            myid = open('/proc/sys/kernel/random/uuid', 'r').read()
        else:
            myid = str(uuid4())
        
        try:
            sf = open(savepath, 'w')
            sf.write(myid)
            sf.flush()
            sf.close()
        except (IOError, OSError), e:
            pass
        
        return myid
        
def decompress(filename, dest=None, fn_only=False, check_timestamps=False):
    """take a filename and decompress it into the same relative location.
       if the file is not compressed just return the file"""
    
    out = dest
    if not dest:
        out = filename
        
    if filename.endswith('.gz'):
        ztype='gz'
        if not dest: 
            out = filename.replace('.gz', '')

    elif filename.endswith('.bz') or filename.endswith('.bz2'):
        ztype='bz2'
        if not dest:
            if filename.endswith('.bz'):
                out = filename.replace('.bz','')
            else:
                out = filename.replace('.bz2', '')
    
    elif filename.endswith('.xz'):
        ztype='xz'
        if not dest:
            out = filename.replace('.xz', '')
        
    else:
        out = filename # returning the same file since it is not compressed
        ztype = None
    
    if ztype and not fn_only:
        if check_timestamps:
            fi = stat_f(filename)
            fo = stat_f(out)
            if fi and fo and fo.st_mtime > fi.st_mtime:
                return out

        _decompress_chunked(filename, out, ztype)
        
    return out
    
def repo_gen_decompress(filename, generated_name, cached=False):
    """ This is a wrapper around decompress, where we work out a cached
        generated name, and use check_timestamps. filename _must_ be from
        a repo. and generated_name is the type of the file. """
    dest = os.path.dirname(filename)
    dest += '/gen'
    if not os.path.exists(dest):
        os.makedirs(dest, mode=0755)
    dest += '/' + generated_name
    return decompress(filename, dest=dest, check_timestamps=True,fn_only=cached)
    
def read_in_items_from_dot_dir(thisglob, line_as_list=True):
    """takes a glob of a dir (like /etc/foo.d/*.foo)
       returns a list of all the lines in all the files matching
       that glob, ignores comments and blank lines,
       optional paramater 'line_as_list tells whether to
       treat each line as a space or comma-separated list, defaults to True"""
    results = []
    for fname in glob.glob(thisglob):
        for line in open(fname):
            if re.match('\s*(#|$)', line):
                continue
            line = line.rstrip() # no more trailing \n's
            line = line.lstrip() # be nice
            if not line:
                continue
            if line_as_list:
                line = line.replace('\n', ' ')
                line = line.replace(',', ' ')
                results.extend(line.split())
                continue
            results.append(line)
    return results

__cached_cElementTree = None
def _cElementTree_import():
    """ Importing xElementTree all the time, when we often don't need it, is a
        huge timesink. This makes python -c 'import yum' suck. So we hide it
        behind this function. And have accessors. """
    global __cached_cElementTree
    if __cached_cElementTree is None:
        try:
            from xml.etree import cElementTree
        except ImportError:
            import cElementTree
        __cached_cElementTree = cElementTree

def cElementTree_iterparse(filename):
    """ Lazily load/run: cElementTree.iterparse """
    _cElementTree_import()
    return __cached_cElementTree.iterparse(filename)

def cElementTree_xmlparse(filename):
    """ Lazily load/run: cElementTree.parse """
    _cElementTree_import()
    return __cached_cElementTree.parse(filename)
                                                                                                                                    usr/lib/python2.7/dist-packages/yum/misc.pyc                                                        0100644 0000000 0000000 00000106226 13077704344 017415  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
f
Tc           @   s  d  Z  d d l Z d d l Z d d l Z d d l m Z d d l Z d d l Z d d l Z d d l	 Z	 d d l
 Z
 d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d g Z y d d l Z e j d  Wn e k
 r$d Z n Xd d l m Z m Z d d l Ty d d l Z d d l Z Wn e k
 rzd Z n Xy4 d d l Z e  d	 d
 d d d g  Z! d g Z" WnW e k
 rd d l# Z# d d l$ Z$ e  d	 d
 g  Z! d
 g Z" d dN d     YZ n Xd d l
 m% Z% d d l& m' Z' m( Z( i  a) i  a* d   Z+ d   Z, d a- d   Z. d a/ d   Z0 d   Z1 d   Z2 d a3 d   Z4 d   Z5 d   Z6 d dO d     YZ7 d dP d     YZ8 dQ d d!  Z9 d"   Z: d# dR d$     YZ; d%   Z< e= d&  Z> d'   Z? d(   Z@ d d eA d)  ZB d*   ZC d d+  ZD d, eA d- d.  ZE d/   ZF d0   ZG d1   ZH d2   ZI d3   ZJ d4   ZK d5   ZL d6   ZM d7   ZN d8   ZO d9 d:  ZP d9 d;  ZQ d<   ZR d=   ZS d aT e= d>  ZU d?   ZV d@   ZW dA   ZX d aY dB   ZZ d d l[ Z[ d d l\ Z\ eA e= dC  Z] dD   Z^ dE   Z_ dF   Z` dG   Za d e= e= dH  Zb e= dI  Zc eA dJ  Zd d ae dK   Zf dL   Zg dM   Zh d S(S   s%   
Assorted utility functions for yum.
iN(   t   StringIOt   gzt   bz2t   xz(   t   stringToVersiont   flagToString(   t   *t   md5t   sha1t   sha256t   sha384t   sha512t   hashlibc           B   s   e  Z e d     Z RS(   c         C   s9   |  d k r t  j   S|  d k r, t j   St d  d  S(   NR   R   s   Bad checksum type(   R   t   newt   shat
   ValueError(   t   algo(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR   2   s
    

(   t   __name__t
   __module__t   staticmethodR   (    (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR   0   s   (   t	   MiscError(   t   to_utf8t
   to_unicodec         C   sG   t  } t |  t  r t } n  t |   t j k r7 |  S| j |  |   S(   s    Take a value and use the same value from the store,
        if the value isn't in the store this one becomes the shared version. (   t   _share_data_storet
   isinstancet   unicodet   _share_data_store_ut   typet   typest	   TupleTypet
   setdefault(   t   valuet   store(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt
   share_dataB   s    	c           C   s   i  a  i  a d  S(   N(   R   R   (    (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   unshare_dataR   s    c         C   s+   t  d k r! t j d  j a  n  t  |   S(   s(    Tests if a string is a shell wildcard. s   [*?]|\[.+\]N(   t   _re_compiled_glob_matcht   Nonet   ret   compilet   search(   t   s(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   re_globY   s    c         C   s+   t  d k r! t j d  j a  n  t  |   S(   s    Tests if a string could be a filename. We still get negated character
        classes wrong (are they supported), and ranges in character classes. s   [/*?]|\[[^]]*/[^]]*\]N(   t   _re_compiled_filename_matchR$   R%   R&   t   match(   R(   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   re_filenamec   s    c         C   s$   t  |   r t S|  d k r  t St S(   s    Tests if a filename string, can be matched against just primary.
        Note that this can produce false negatives (but not false
        positives). Note that this is a superset of re_primary_dirname(). s   /usr/lib/sendmail(   t   re_primary_dirnamet   Truet   False(   t   filename(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   re_primary_filenamek   s
    c         C   s'   d |  k r t  S|  j d  r# t  St S(   s~    Tests if a dirname string, can be matched against just primary. Note
        that this is a subset of re_primary_filename(). s   bin/s   /etc/(   R.   t
   startswithR/   (   t   dirname(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR-   u   s
    c         C   sd   t  d k r? t j d  j } t j d  j } | | f a  n  x t  D] } | |   rF t SqF Wt S(   sC    Tests if a string needs a full nevra match, instead of just name. s   .*([-.*?]|\[.+\]).s   [0-9]+:N(   t   _re_compiled_full_matchR$   R%   R&   R+   R.   R/   (   R(   t   onet   twot   rec(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   re_full_search_needed   s    c         C   sI   |  j    }  |  j d  r t S|  j d  r2 t S|  j d  rE t St S(   s8    Tests if a string is a "remote" URL, http, https, ftp. s   http://s   https://s   ftp://(   t   lowerR2   R.   R/   (   R(   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   re_remote_url   s    c         C   s,  t  |   } | d k r g  Sy t |   } Wn t k
 r? n Xt |  Sy t |   } | j   Wn t k
 rz ~ n{ X| d k s t  | d } d } } xI | | k  r | | | k r | | | | <} | d 7} n  | d 7} q W| |  Sg  } x* |  D]" } | | k r| j |  qqW| S(   s  Return a list of the elements in s, but without duplicates.

    For example, unique([1,2,3,1,2,3]) is some permutation of [1,2,3],
    unique("abcabc") some permutation of ["a", "b", "c"], and
    unique(([1, 2], [2, 3], [1, 2])) some permutation of
    [[2, 3], [1, 2]].

    For best speed, all sequence elements should be hashable.  Then
    unique() will usually work in linear time.

    If not possible, the sequence elements should enjoy a total
    ordering, and if list(s).sort() doesn't raise TypeError it's
    assumed that they do enjoy a total ordering.  Then unique() will
    usually work in O(N*log2(N)) time.

    If that's not possible either, the sequence elements must support
    equality-testing.  Then unique() will usually work in quadratic
    time.
    i    i   (   t   lent   sett	   TypeErrort   listt   sortt   AssertionErrort   append(   R(   t   nt   ut   tt   lastt   lastit   it   x(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   unique   s6    
	

t	   Checksumsc           B   sz   e  Z d  Z d e e d  Z d   Z e d d    Z d   Z	 d d  Z
 d	   Z d d
  Z d   Z d d  Z RS(   sn    Generate checksum(s), on given pieces of data. Producing the
        Length and the result(s) when complete. c         C   s   | d  k r t } n  g  |  _ g  |  _ d |  _ t   } x | D] } | d k r[ d } n  | | k rm q@ n  | t k r t j |  } n | r q@ n t	 d |  | j
 |  |  j j |  |  j j |  q@ W| r | r t	 d  n  d  S(   Ni    R   R   s(   Error Checksumming, bad checksum type %ss*   Error Checksumming, no valid checksum type(   R$   t   _default_checksumst	   _sumalgost	   _sumtypest   _lenR<   t   _available_checksumsR   R   R   t   addRA   (   t   selft	   checksumst   ignore_missingt   ignore_nonet   donet   sumtypet   sumalgo(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   __init__   s*    						c         C   s   |  j  S(   N(   RN   (   RQ   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   __len__   s    t   fgetc         C   s   |  j  S(   N(   RN   (   RQ   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   <lambda>   s    c         C   s:   |  j  t |  7_  x |  j D] } | j |  q Wd  S(   N(   RN   R;   RL   t   update(   RQ   t   dataRW   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR\     s    i   i   c         C   s    | j  |  } |  j |  | S(   N(   t   readR\   (   RQ   t   fot   sizeR]   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR^     s    c         C   s@   i  } x3 t  |  j |  j  D] \ } } | j   | | <q W| S(   N(   t   zipRM   RL   t	   hexdigest(   RQ   t   retRV   t   sumdata(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt
   hexdigests  s    "c         C   sL   | d  k r) |  j s d  S|  j d } n  | d k r> d } n  |  j   | S(   Ni    R   R   (   R$   RM   Re   (   RQ   t   checksum(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyRb     s    		c         C   s@   i  } x3 t  |  j |  j  D] \ } } | j   | | <q W| S(   N(   Ra   RM   RL   t   digest(   RQ   Rc   RV   Rd   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   digests  s    "c         C   sL   | d  k r) |  j s d  S|  j d } n  | d k r> d } n  |  j   | S(   Ni    R   R   (   R$   RM   Rh   (   RQ   Rf   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyRg   !  s    		Ni   (   R   R   t   __doc__R$   R/   RX   RY   t   propertyt   lengthR\   R^   Re   Rb   Rh   Rg   (    (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyRJ      s   					t   AutoFileChecksumsc           B   s2   e  Z d  Z e e d  Z d   Z d d  Z RS(   sk    Generate checksum(s), on given file/fileobject. Pretending to be a file
        object (overrrides read). c         C   s"   | |  _  t | | |  |  _ d  S(   N(   t   _foRJ   RR   (   RQ   R_   RR   RS   RT   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyRX   /  s    	c         C   s   t  |  j |  S(   N(   t   getattrRm   (   RQ   t   attr(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   __getattr__3  s    ic         C   s   |  j  j |  j |  S(   N(   RR   R^   Rm   (   RQ   R`   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR^   6  s    (   R   R   Ri   R/   RX   Rp   R^   (    (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyRl   +  s   	i   i   c         C   s  y t  |  t j k r! | } n t | d |  } t |  g  } x5 | j | |  ry | d k	 rE | j | k rE PqE qE Wt  |  t j k r | j	   ~ n  | d k	 r | | j k r d | | j
 |   f S| j
 |   SWn& t t f k
 r} t d |  n Xd S(   s   takes filename, hand back Checksum of it
       sumtype = md5 or sha/sha1/sha256/sha512 (note sha == sha1)
       filename = /path/to/file
       CHUNK=65536 by defaultt   rs   !%u!%ss#   Error opening file for checksum: %sN(   R   R   t   StringTypest   openRJ   R^   R$   Rk   t
   StringTypet   closeRb   t   IOErrort   OSErrorR   (   RV   t   filet   CHUNKt   datasizeR_   R]   t   e(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyRf   :  s     	
c         C   s   t  |  } y t j |   } Wn& t k
 rG } t d |  | f  n Xx | D] } t j j |  d |  r t |  d | | |  } qO | s | | j   d | k rO t j j	 |  d |  } | j
 |  qO qO W| S(   sf   Return all files in path matching ext, store them in filelist, 
       recurse dirs return list objects    Error accessing directory %s, %st   /s   %s(   R;   t   ost   listdirRw   R   t   patht   isdirt   getFileListR9   t   normpathRA   (   R   t   extt   filelistt   extlent   dir_listR{   t   dt   newpath(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR   Y  s    "t   GenericHolderc           B   s,   e  Z d  Z d d  Z d   Z d   Z RS(   s   Generic Holder class used to hold other objects of known types
       It exists purely to be able to do object.somestuff, object.someotherstuff
       or object[key] and pass object to another function that will 
       understand itc         C   s   | |  _  d  S(   N(   t   _GenericHolder__iter(   RQ   t   iter(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyRX   s  s    c         C   s$   |  j  d  k	 r  t |  |  j   Sd  S(   N(   R   R$   R   (   RQ   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   __iter__v  s    c         C   s)   t  |  |  r t |  |  St |  d  S(   N(   t   hasattrRn   t   KeyError(   RQ   t   item(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   __getitem__z  s    N(   R   R   Ri   R$   RX   R   R   (    (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyR   m  s   	c         C   s   t  j d d |   }  t   } d } d } x |  j d  D] } | j d  rX d } q: | ry | j   d k ry d } q: | r | j d  r Pq: | r | j d  r Pq: | r: | j | d  q: q: Wt j | j	    S(	   s-   Convert ASCII armoured GPG key to binary
    s   
?s   
i    s$   -----BEGIN PGP PUBLIC KEY BLOCK-----i   t    s"   -----END PGP PUBLIC KEY BLOCK-----t   =(
   R%   t   subR    t   splitR2   t   stript   writet   base64t   decodestringt   getvalue(   t   rawkeyt   blockt   inblockt   pastheaderst   line(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt
   procgpgkey  s     			c   
      C   s  g  } y t  j |   } Wn% t k
 r@ } t t |    n Xt |  d k rb t d   n  x| D]} | j j   } i | j d 6t	 j
 d |  d d 6| j j d 6| j j d 6| j d 6t d	 6t d
 6} x | j d D]{ } t | t  j  sq n  | j   | k r t | d  r`| j t  j  }	 |	 d k r]t |	 d  | d <Pq]q`q q W| j |  qi W| r| S| d Sd S(   s   Return a dict of info for the given ASCII armoured key text

    Returned dict will have the following keys: 'userid', 'keyid', 'timestamp'

    Will raise ValueError if there was a problem decoding the key.
    i    s   No key found in given key datat   userids   >Qt   keyidt	   timestampt   fingerprintt   raw_keyt   has_sigt	   valid_sigt   hashed_subpaksi   N(   t   pgpmsgt   decode_multiple_keyst	   ExceptionR   t   strR;   t
   public_keyt   key_idt   user_idt   structt   unpackR   R   R   R/   t   user_idsR   t	   signatureR   t   get_hashed_subpakt   SIG_SUB_TYPE_CREATE_TIMER$   t   intRA   (
   R   t   multiplet   key_info_objst   keysR{   t   keyt
   keyid_blobt   infoR   t   tspkt(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   getgpgkeyinfo  s<    


c         C   s   d |  d @S(   s[   Convert an integer representing a GPG key ID to the hex version string
    used by RPM
    s   %08xl    (    (   R   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   keyIdToRPMVer  s    c         C   sw   t  |  } xd |  j d d  D]P } | d | k r t | d d  } | | k rX d S| | k  rh d Sd Sq q Wd	 S(
   sd  
    Return if the GPG key described by the given keyid and timestamp are
    installed in the rpmdb.  

    The keyid and timestamp should both be passed as integers.
    The ts is an rpm transaction set object

    Return values:
        - -1      key is not installed
        - 0       key with matching ID and timestamp is installed
        - 1       key with matching ID is installed but has a older timestamp
        - 2       key with matching ID is installed but has a newer timestamp

    No effort is made to handle duplicates. The first matching keyid is used to 
    calculate the return result.
    t   names
   gpg-pubkeyt   versiont   releasei   i    i   i   i(   R   t   dbMatchR   (   t   tsR   R   t   hdrt   installedts(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   keyInstalled  s    c         C   s  t  d  k r t S| s# d | } n  t j j |  sE t j |  n  t |   } | t j d <t  j	   } t
 t j j | d  d  } | j d  | j   | j |  | j   | j |  } t  j j | | t  j  | r| d }	 t j j |	  st j |	 d d x[ t j | d	  D]F }
 t j j |
  } |	 d
 | } t j |
 |  t j | d  q'Wt
 |	 d d d  } d } | j |  | j   qn  t S(   Ns	   %s/gpgdirt	   GNUPGHOMEs   gpg.conft   wbR   s   -rot   modei  s   /*R|   s	   /gpg.conft   ws   lock-never    
no-auto-check-trustdb    
trust-model direct
no-expensive-trust-checks
no-permission-warning         
preserve-permissions
(   t   gpgmeR$   R/   R}   R   t   existst   makedirsR    t   environt   ContextRs   t   joinR   Ru   t   import_t   get_keyt   editutilt
   edit_trustt   VALIDITY_ULTIMATEt   globt   basenamet   shutilt   copyt   chmodR.   (   R   R   t   cachedirt   gpgdirt   make_ro_copyt   key_fot   ctxt   fpt   kt   rodirt   fR   t   ro_ft   opts(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   import_key_to_pubring  s<    


c         C   s   t  d  k s t j j |   r# g  S|  t j d <t  j   } g  } xD | j   D]6 } x- | j D]" } | j	 r_ | j
 | j  q_ q_ WqO W| S(   NR   (   R   R$   R}   R   R   R   R   t   keylistt   subkeyst   can_signRA   R   (   R   R   t   keyidsR   t   subkey(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   return_keyids_from_pubring(  s    	c   
      C   s  t  d k r t S| r< t j j |  s, t S| t j d <n  t |  d  rT |  } n t |  d  } t | d  r{ | } n t | d  } d } t  j	   } y | j
 | | |  } Wn t  j k
 r } t SX| s t S| d }	 |	 s t S|	 j t  j t  j t  j f k rt St S(   sA   takes signature , file that was signed and an optional gpghomedirR   R^   Rq   i    N(   R   R$   R/   R}   R   R   R   R   Rs   R   t   verifyt
   GpgmeErrort   validityt   VALIDITY_FULLt   VALIDITY_MARGINALR   R.   (
   t   sig_filet   signed_filet   gpghomet   sigt   signed_textt	   plaintextR   t   sigsR{   t   thissig(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   valid_detached_sig6  s6    		
s   /var/tmps   yum-c         C   s   t  j   } y t j |  } | d } Wn t k
 r= d SX| r d | | f } d |  | f } t t j |   } xZ | D]O } t  j |  }	 t	 |	 d  r t
 |	 d  d k r |	 d | k r | Sq Wn  t j d | d |   }
 |
 S(	   sq   return a path to a valid and safe cachedir - only used when not running
       as root or when --tempcache is seti    s   %s%s-s   %s/%s*i  i   t   prefixt   dirN(   R}   t   geteuidt   pwdt   getpwuidR   R$   t   sortedR   t   lstatt   S_ISDIRt   S_IMODEt   tempfilet   mkdtemp(   t   tmpdirt   reuseR   t   uidt   usertupt   usernamet   dirpatht	   cachedirst   thisdirt   statsR   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   getCacheDir^  s     6c         C   s4   |  j  | j  k r d S|  j  | j  k r, d Sd Sd S(   s+   sorts a list of yum package objects by namei   i    iN(   R   (   t   pkg1t   pkg2(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt
   sortPkgObjw  s
    c         C   sn   |  j    g } | d } xN |  D]F } | j |  rG | g } | } q  | j |  r  | j |  q  q  W| S(   s,    Return the newest in the list of packages. i    (   t   popt   verGTt   verEQRA   (   t   pkgsRc   t   newestt   pkg(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   newestInList  s    
		c         C   sp   |  \ } } } d } | d k r2 | d | 7} n  | d k	 rO | d | 7} n  | d k	 rl | d | 7} n  | S(	   s   
    Convert a tuple representing a package version to a string.

    @param evrTuple: A 3-tuple of epoch, version, and release.

    Return the string representation of evrTuple.
    R   i    t   0s   %s:s   %ss   -%sN(   i    R  N(   R$   (   t   evrTupleR{   t   vRq   R(   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   version_tuple_to_string  s    c         C   sc   |  \ } } } i d d 6d d 6d d 6d d 6d	 d
 6} | d k rH | Sd | | | t |  f S(   s7   returns a text string of the prco from the tuple formatt   >t   GTs   >=t   GER   t   EQt   <t   LTs   <=t   LEs   %s %s %sN(   R$   R  (   t	   prcoTupleR   t   flagt   evrt   flags(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   prco_tuple_to_string  s
    )c   	      C   s  t  |   t j k r' |  \ } } } nc |  } d } } | d d k r | j d  r | j   } t |  d k r | \ } } } q n  | d k	 r	| t j k r	| t j	 k r y t
 t |   } Wqt t f k
 r } t j d |  qXq	t j	 | } n  t  |  t j t j t j f k rEt |  \ } } } n0 t  |  t j t j f k ru| \ } } } n  | | | | | f f S(   s:   returns a prco tuple (name, flags, (e, v, r)) for a stringi    R|   s   gpg(i   s   Invalid version flag: %sN(   R   R   R   R$   R2   R   R;   t	   constantst   LETTERFLAGSt   SYMBOLFLAGSR   R   R   R=   t   ErrorsR   Rt   t   NoneTypet   UnicodeTypeR   t   ListType(	   t
   prcoStringRB   R   R  t
   prco_splitR{   t   prco_et   prco_vt   prco_r(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   string_to_prco_tuple  s(    
 $c         C   s7   t  j d |   r$ t j |   } n t  j |   } | S(   sm   Takes a search string from the cli for Search or Provides
       and cleans it up so it doesn't make us vomits   [*{}?+]|\[.+\](   R%   R'   t   fnmatcht	   translatet   escape(   t   argt   restring(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   refineSearchPattern  s    c         C   s=  | t  k r% d | } t j |  n  | d k rF t j |  d  } nB | d k rg t j |  d  } n! | d k r t j |  d  } n  t	 | d  } x t
 r$y | j d  } Wn t k
 r Pn X| s Pn  y | j |  Wq t t f k
 r } d | t |  f } t j |  q Xq W| j   | j   d  S(	   Ns   %s compression not availableR   Rq   R   R   R   i  s   Error writing to file %s: %s(   t   _available_compressionR-  R   R   t   BZ2Filet   lzmat   LZMAFilet   gzipt   GzipFileRs   R.   R^   Rv   R   Rw   R   Ru   (   t   sourcet   destt   ztypet   msgt   s_fnt   destinationR]   R{   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   _decompress_chunked  s0    
	 
c         C   s   t  |  | d d d S(   s1    Extract the bzipped contents of source to dest. RE  R   N(   RI  (   RC  RD  (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt
   bunzipFile  s    c         C   s   t  j   d } t t j d |   } xt | D]l } |  j d |  } xQ | D]I } | d } | d d
 k rx d } n  | d | d | | d | d	 f SWq0 Wd S(   s}   This takes the output of uname and figures out the pkgtup of the running
       kernel (name, arch, epoch, version, release).i   s   /boot/vmlinuz*%s*t	   basenamest   epochR  R   t   archR   R   N(   NNNNN(   R}   t   unameR   R   R   R$   (   R   t   vert   fnst   fnt   mit   hR{   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   get_running_kernel_pkgtup  s    
	(c         C   s2   t  |   } | d d k	 r. | d | d f Sd S(   sg   This takes the output of uname and figures out the (version, release)
    tuple for the running kernel.i    i   i   N(   NN(   RT  R$   (   R   t   pkgtup(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt"   get_running_kernel_version_release  s    s   /var/lib/yumc   	      C   s   g  } d |  d f } d |  d f } t  j  |  } t  j  |  } xT | D]L } | j d  rf qK n  t j j |  } | j d d  } | j |  qK W| j   | S(   s   returns a list of the timestamps from the filenames of the unfinished 
       transactions remaining in the yumlibpath specified.
    s   %s/%ss   transaction-all*s   transaction-done*t   disableds   transaction-all.R   (   R   t   endswithR}   R   R   t   replaceRA   R?   (	   t
   yumlibpatht
   timestampst   tsallgt   tsdonegt   tsallst   tsdonesRQ  t   transR   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   find_unfinished_transactions  s    
c         C   se  g  } d | d |  f } d | d |  f } g  } t  j j |  sH | St  j j |  r t | d  } | j   } | j   n  t | d  } | j   } | j   x- | D]% }	 |	 | k r q n  | j |	  q Wx | D] }	 |	 j d d  }	 |	 d k rq n  y |	 j   \ }
 } Wn) t	 k
 rI} d | } t
 j |  n X| j |
 | f  q W| S(   s  this function takes the timestamp of the transaction to look at and 
       the path to the yum lib dir (defaults to /var/lib/yum)
       returns a list of tuples(action, pkgspec) for the unfinished transaction
       elements. Returns an empty list if none.

    s   %s/%s.%ss   transaction-alls   transaction-doneRq   s   
R   s(   Transaction journal  file %s is corrupt.(   R}   R   R   Rs   t	   readlinesRu   t   removeRY  R   R   R-  R   RA   (   R   RZ  t   to_complete_itemst	   tsallpatht
   tsdonepatht   tsdone_itemst	   tsdone_fot   tsall_fot   tsall_itemsR   t   actiont   pkgspecR{   RF  (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   find_ts_remaining+  s8    

c         C   s~   g  } t  |   } t |   }  d } xB | | k rh | | } | j |  | | ! | | 7} | | 8} q' W| j |  |  | S(   sE    Given a seq, split into a list of lists of length max_entries each. i    (   R;   R>   RA   (   t   seqt   max_entriesRc   t   numt   begt   end(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   seq_max_splitY  s    

c         C   sf  |  d k r d St |  t  r# |  St } y t |  d  } t } Wn t k
 r d d d d g } xy | D]m } y t |  |  } Wn t k
 r qk X| j |  |  k rk | d k r d | |  f GHn  | j d  Sqk Wn Xd } t d d	  d
 d g t d d  } xS |  D]K } t |  | k r.q| rTt |  d k rT| d } q| | } qW| S(   s   hands back a unicoded stringR   t   asciis   utf-8s
   iso-8859-1s   iso-8859-15s
   iso-8859-2s   
%s encoding on %s
i    i   i   i   i   i    i   t   ?N(	   R$   R   R   R/   R.   t   UnicodeErrort   encodet   ranget   ord(   R   t   duRH   t	   encodingst   enct   newitemt   bad_small_bytest   char(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   _ugly_utf8_string_hackg  s8    
&c         C   s   t  d  k r' d d  l } | j j a  n  t |   }  t |   }  |  j   }  | rp t  j |  d i d d 6}  n t  j |   }  |  S(   Nit   entitiess   &quot;t   "(	   t   __cached_saxutilsR$   t   xml.sax.saxutilst   saxt   saxutilsR  R   t   rstripR9  (   R   t   attribt   xml(    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   to_xml  s    c         C   sC   y t  j |   Wn+ t k
 r> } | j t j k r?   q? n Xd S(   s|    Call os.unlink, but don't die if the file isn't there. This is the main
        difference between "rm -f" and plain "rm". N(   R}   t   unlinkRw   t   errnot   ENOENT(   R0   R{   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   unlink_f  s
    c         C   sM   y t  j |   SWn5 t k
 rH } | j t j t j f k rD   n  d SXd S(   sF    Call os.stat(), but don't die if the file isn't there. Returns None. N(   R}   t   statRw   R  R  t   ENOTDIRR$   (   R0   R{   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   stat_f  s    c          C   sX   y t  d  }  Wn t k
 r$ d SX|  j   } y t |  SWn t k
 rS d SXd S(   s    Get the audit-uid/login-uid, if available. None is returned if there
        was a problem. Note that no caching is done here. s   /proc/self/loginuidN(   Rs   Rv   R$   R^   R   R   (   R_   R]   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   _getloginuid  s    c           C   s   t  d k r t   a  n  t  S(   s    Get the audit-uid/login-uid, if available. None is returned if there
        was a problem. The value is cached, so you don't have to save it. N(   t   _cached_getloginuidR$   R  (    (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   getloginuid  s    c         C   s   y3 t  j t  j d  | r2 t  j t  j d  n  WnC t  j k
 rx } t j d IJd t j d <t  j t  j d  n X|  r d d  l	 } | j
 t  j    t j  t _ d t j _ n  d  S(   NR   t   Cs%   Failed to set locale, defaulting to Ct   LC_ALLiRY  (   t   localet	   setlocaleR  t   LC_TIMEt   Errort   syst   stderrR}   R   t   codecst	   getwritert   getpreferredencodingt   stdoutt   errors(   t   override_codecst   override_timeR{   R  (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   setup_locale  s    !c          C   sZ   y t  j t  j  }  Wn t k
 r1 } d }  n X|  d k rG d }  n d j |   }  |  S(   NR  t   .(   NN(   NN(   R  t	   getlocalet   LC_MESSAGESR   R$   R   (   t   mylangR{   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   get_my_lang_code  s    
	c          C   sg   t  j   }  g  } xN t j d  D]= } |  t  j j |  k rF q" n  | j t  j j |   q" W| S(   s5   return list of running processids, excluding this ones   /proc/[0123456789]*(   R}   t   getpidR   R   R   RA   (   t   mypidt   pidsRQ  (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   return_running_pids  s    c         C   sr  g  } d |  } y t  | d  } Wn t t f k
 r? } | SXx | D] } | j d  d k rh qG n  | j d d  } | j d  } | | } | j d d  } | j   } | | k rG | j |  qG qG Wd	 |  } y t  | d  }	 Wn t t f k
 r
} | SX|	 j   }
 |
 j d
  d k rn|
 j d
  } x0 | D]% } | j	 d  rB| j |  qBqBWn  | S(   s    returns files open from this pids   /proc/%s/mapsRq   s   fd:is   
R   R|   s	   (deleted)s   /proc/%s/cmdlinet    (
   Rs   Rv   Rw   t   findRY  R   RA   R^   R   R2   (   t   pidt   filest   maps_ft   mapsR{   R   t   slashR0   t   cli_ft   clit   cmdlinet   cmdsRG   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   get_open_files  s8    


c         C   s   t  j j |   r% t |  d  j   Sy d d l m } Wn& t k
 ra t d d  j   } n Xt |    } y4 t |  d  } | j	 |  | j
   | j   Wn t t f k
 r } n X| Sd S(   sw   create, store and return a uuid. If a stored one exists, report that
       if it cannot be stored, return a random oneRq   i(   t   uuid4s   /proc/sys/kernel/random/uuidR   N(   R}   R   R   Rs   R^   t   uuidR  t   ImportErrorR   R   t   flushRu   Rv   Rw   (   t   savepathR  t   myidt   sfR{   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   get_uuid"  s    
c         C   sT  | } | s |  } n  |  j  d  rH d } | s |  j d d  } q n |  j  d  sf |  j  d  r d } | s |  j  d  r |  j d d  } q |  j d d  } q n? |  j  d  r d } | s |  j d d  } q n |  } d	 } | rP| rP| r=t |   } t |  } | r=| r=| j | j k r=| Sn  t |  | |  n  | S(
   s|   take a filename and decompress it into the same relative location.
       if the file is not compressed just return the files   .gzR   R   s   .bzs   .bz2R   s   .xzR   N(   RX  RY  R$   R  t   st_mtimeRI  (   R0   RD  t   fn_onlyt   check_timestampst   outRE  t   fiR_   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt
   decompress9  s6    	c         C   sn   t  j j |   } | d 7} t  j j |  sD t  j | d d n  | d | 7} t |  d | d t d | S(   s    This is a wrapper around decompress, where we work out a cached
        generated name, and use check_timestamps. filename _must_ be from
        a repo. and generated_name is the type of the file. s   /genR   i  R|   RD  R  R  (   R}   R   R3   R   R   R  R.   (   R0   t   generated_namet   cachedRD  (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   repo_gen_decompressb  s    
c         C   s   g  } x t  j  |   D] } x t |  D] } t j d |  rG q) n  | j   } | j   } | sk q) n  | r | j d d  } | j d d  } | j | j    q) n  | j	 |  q) Wq W| S(   s'  takes a glob of a dir (like /etc/foo.d/*.foo)
       returns a list of all the lines in all the files matching
       that glob, ignores comments and blank lines,
       optional paramater 'line_as_list tells whether to
       treat each line as a space or comma-separated list, defaults to Trues   \s*(#|$)s   
t    t   ,(
   R   Rs   R%   R+   R  t   lstripRY  t   extendR   RA   (   t   thisglobt   line_as_listt   resultst   fnameR   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   read_in_items_from_dot_dirm  s     c          C   sM   t  d k rI y d d l m }  Wn t k
 r? d d l }  n X|  a  n  d S(   s    Importing xElementTree all the time, when we often don't need it, is a
        huge timesink. This makes python -c 'import yum' suck. So we hide it
        behind this function. And have accessors. i(   t   cElementTreeN(   t   __cached_cElementTreeR$   t	   xml.etreeR  R  (   R  (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   _cElementTree_import  s    c         C   s   t    t j |   S(   s)    Lazily load/run: cElementTree.iterparse (   R  R  t	   iterparse(   R0   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   cElementTree_iterparse  s    c         C   s   t    t j |   S(   s%    Lazily load/run: cElementTree.parse (   R  R  t   parse(   R0   (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   cElementTree_xmlparse  s    (    (    (    i   (    (i   Ri   R   R}   t   os.patht	   cStringIOR    R   R   R%   R  R-  R*  R   R  R   R   R7  R   RA  R   R=  R?  RA   R  R$   t   rpmUtils.miscutilsR   R   R  R   t   gpgme.editutilR   R<   RO   RK   R   R   R   t   i18nR   R   R   R   R!   R"   R#   R)   R*   R,   R1   R-   R4   R8   R:   RI   RJ   Rl   Rf   R   R   R   R/   R   R   R   R.   R   R   R   R  R  R  R  R)  R6  R<  RI  RJ  RT  RV  Ra  Rm  Rs  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  (    (    (    s,   /usr/lib/python2.7/dist-packages/yum/misc.pyt   <module>   s   


	
						
					BM		2		!1	(					
	#		!			.		/						
		
	#	)		                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python2.7/dist-packages/yum/packageSack.py                                                  0100644 0000000 0000000 00000121627 12451005146 020503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/python -tt
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# Copyright 2006 Duke University

"""
Classes for manipulating and querying groups of packages.
"""

from Errors import PackageSackError
import warnings
import re
import fnmatch
import misc
from packages import parsePackages
import rpmUtils.miscutils
from rpmUtils.miscutils import compareEVR

class PackageSackVersion:
    def __init__(self):
        self._num = 0
        self._chksum = misc.Checksums(['sha1'])

    def __str__(self):
        return "%u:%s" % (self._num, self._chksum.hexdigest())

    def __eq__(self, other):
        if other is None: return False
        if type(other) in (type(''), type(u'')):
            return str(self) == other
        if self._num != other._num: return False
        if self._chksum.digest() != other._chksum.digest(): return False
        return True
    def __ne__(self, other):
        return not (self == other)

    def update(self, pkg, csum):
        self._num += 1
        self._chksum.update(str(pkg))
        if csum is not None:
            self._chksum.update(csum[0])
            self._chksum.update(csum[1])


class PackageSackBase(object):
    """Base class that provides the interface for PackageSacks."""
    def __init__(self):
        self.added = {}

    def __len__(self):
        return len(self.returnPackages())
        
    def __iter__(self):
        ret = self.returnPackages()
        if hasattr(ret, '__iter__'):
            return ret.__iter__()
        else:
            return iter(ret)

    def __cmp__(self, other):
        if other is None:
            return 1

        s_repos = list(self.added)
        o_repos = list(other.added)
        if len(s_repos) != len(o_repos):
            return len(s_repos) - len(o_repos)
        for (s_repo, o_repo) in zip(sorted(s_repos), sorted(o_repos)):
            ret = cmp(s_repo, o_repo)
            if ret:
                return ret
        return 0

    def setCompatArchs(self, compatArchs):
        raise NotImplementedError()

    def populate(self, repo, mdtype, callback, cacheOnly):
        raise NotImplementedError()

    def packagesByTuple(self, pkgtup):
        """return a list of package objects by (n,a,e,v,r) tuple"""
        warnings.warn('packagesByTuple() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)
        
        return self.searchPkgTuple(pkgtup)
        
        
    def searchNevra(self, name=None, epoch=None, ver=None, rel=None, arch=None):
        """return list of pkgobjects matching the nevra requested"""
        raise NotImplementedError()

    def searchNames(self, names=[], return_pkgtups=False):
        raise NotImplementedError()

    def searchPO(self, po):
        """return list of package objects matching the name, epoch, ver, rel,
           arch of the package object passed in"""
           
        return self.searchNevra(name=po.name, epoch=po.epoch, ver=po.ver, 
                                rel=po.rel, arch=po.arch)
    
    def searchPkgTuple(self, pkgtup):
        """return list of pkgobject matching the (n,a,e,v,r) tuple"""
        (n,a,e,v,r) = pkgtup
        return self.searchNevra(name=n, arch=a, epoch=e, ver=v, rel=r)
        
    def contains(self, name=None, arch=None, epoch=None, ver=None, rel=None, po=None):
        """return if there are any packages in the sack that match the given NAEVR 
           or the NAEVR of the given po"""
        if po:
            name = po.name
            arch = po.arch
            epoch = po.epoch
            ver = po.version
            rel = po.release
        return bool(self.searchNevra(name=name, arch=arch, epoch=epoch, ver=ver, rel=rel))

    def getProvides(self, name, flags=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }"""
        raise NotImplementedError()

    def getRequires(self, name, flags=None, version=(None, None, None)):
        """return dict { packages -> list of matching requires }"""
        raise NotImplementedError()

    def searchRequires(self, name):
        """return list of package requiring the name (any evr and flag)"""
        raise NotImplementedError()

    def searchProvides(self, name):
        """return list of package providing the name (any evr and flag)"""
        raise NotImplementedError()

    def searchConflicts(self, name):
        """return list of package conflicting with the name (any evr and flag)"""
        raise NotImplementedError()

    def searchObsoletes(self, name):
        """return list of package obsoleting the name (any evr and flag)"""
        raise NotImplementedError()

    def returnObsoletes(self, newest=False):
        """returns a dict of obsoletes dict[obsoleting pkgtuple] = [list of obs]"""
        raise NotImplementedError()

    def have_fastReturnFileEntries(self):
        """ Is calling pkg.returnFileEntries(primary_only=True) faster than
            using searchFiles(). """
        raise NotImplementedError()

    def searchFiles(self, name):
        """return list of packages by filename"""
        raise NotImplementedError()

    def addPackage(self, obj):
        """add a pkgobject to the packageSack"""
        raise NotImplementedError()

    def buildIndexes(self):
        """builds the useful indexes for searching/querying the packageSack
           This should be called after all the necessary packages have been
           added/deleted"""
        raise NotImplementedError()

    def delPackage(self, obj):
        """delete a pkgobject"""
        raise NotImplementedError()

    def returnPackages(self, repoid=None, patterns=None, ignore_case=False):
        """return list of all packages"""
        raise NotImplementedError()

    def addPackageExcluder(self, repoid, excluderid, excluder, *args):
        """ Add an "excluder" for all packages in the repo/sack. Can basically
            do anything based on nevra, changes lots of exclude decisions from
            "preload package; test; delPackage" into "load excluder".
            Excluderid is used so the caller doesn't have to track
            "have I loaded the excluder for this repo.", it's probably only
            useful when repoid is None ... if it turns out utterly worthless
            then it's still not a huge wart. """
        raise NotImplementedError()

    def simpleVersion(self, main_only=False, groups={}):
        """ Return a simple version for all available packages. """
        def _up_revs(arepos, repoid, rev, pkg, csum):
            arevs = arepos.setdefault(repoid, {})
            rpsv = arevs.setdefault(None, PackageSackVersion())
            rpsv.update(pkg, csum)
            if rev is not None:
                rpsv = arevs.setdefault(rev, PackageSackVersion())
                rpsv.update(pkg, csum)

        main = PackageSackVersion()
        arepos = {}
        main_grps = {}
        arepos_grps = {}
        for pkg in sorted(self.returnPackages()):
            csum = pkg.returnIdSum()
            main.update(pkg, csum)

            for group in groups:
                if pkg.name in groups[group]:
                    if group not in main_grps:
                        main_grps[group] = PackageSackVersion()
                        arepos_grps[group] = {}
                    main_grps[group].update(pkg, csum)

            if main_only:
                continue

            rev = pkg.repo.repoXML.revision
            _up_revs(arepos, pkg.repoid, rev, pkg, csum)
            for group in groups:
                if pkg.name in groups[group]:
                    _up_revs(arepos_grps[group], pkg.repoid, rev, pkg, csum)

        if groups:
            return [main, arepos, main_grps, arepos_grps]
        return [main, arepos]

    def returnNewestByNameArch(self, naTup=None,
                               patterns=None, ignore_case=False):
        """return list of newest packages based on name, arch matching
           this means(in name.arch form): foo.i386 and foo.noarch are not
           compared to each other for highest version only foo.i386 and
           foo.i386 will be compared
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. """
        raise NotImplementedError()

    def returnNewestByName(self, name=None, patterns=None, ignore_case=False):
        """return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version."""
        raise NotImplementedError()

    def simplePkgList(self, patterns=None, ignore_case=False):
        """returns a list of pkg tuples (n, a, e, v, r)"""
        raise NotImplementedError()

    def printPackages(self):
        raise NotImplementedError()

    def excludeArchs(self, archlist):
        """exclude incompatible arches. archlist is a list of compatible arches"""
        raise NotImplementedError()

    def searchPackages(self, fields, criteria_re, callback):
        raise NotImplementedError()

    def searchAll(self, arg, query_type):
        raise NotImplementedError()
    
    def matchPackageNames(self, pkgspecs):
        """take a list strings and match the packages in the sack against it
           this will match against:
           name
           name.arch
           name-ver-rel.arch
           name-ver
           name-ver-rel
           epoch:name-ver-rel.arch
           name-epoch:ver-rel.arch
           
           return [exact matches], [glob matches], [unmatch search terms]
           """
        # Setup match() for the search we're doing
        matched = []
        exactmatch = []
        unmatched = set(pkgspecs)

        specs = {}
        for p in pkgspecs:
            if misc.re_glob(p):
                restring = fnmatch.translate(p)
                specs[p] = re.compile(restring)
            else:
                specs[p] = p

        #  We don't use simplePkgList() here because that loads all of the
        # rpmdb, if we are Eg. doing a "remove PackageKit".
        pkgs = self.returnPackages(patterns=unmatched)
        for pkgtup in [pkg.pkgtup for pkg in pkgs]:
            (n,a,e,v,r) = pkgtup
            names = set((
                n, 
                '%s.%s' % (n, a),
                '%s-%s-%s.%s' % (n, v, r, a),
                '%s-%s' % (n, v),
                '%s-%s-%s' % (n, v, r),
                '%s:%s-%s-%s.%s' % (e, n, v, r, a),
                '%s-%s:%s-%s.%s' % (n, e, v, r, a),
                ))
                
            for (term,query) in specs.items():
                if term == query:
                    if query in names:
                        exactmatch.append(self.searchPkgTuple(pkgtup)[0])
                        unmatched.discard(term)
                else:
                    for n in names:
                        if query.match(n):
                            matched.append(self.searchPkgTuple(pkgtup)[0])
                            unmatched.discard(term)
        return misc.unique(exactmatch), misc.unique(matched), list(unmatched)

    def returnLeafNodes(self, repoid=None):
        """returns a list of package objects that are not required by
           any other package in this repository"""
           
        def _return_all_provides(po):
            """ Return all the provides, via. yield. """
            # These are done one by one, so that we get lazy loading
            for prov in po.provides_names:
                yield prov
            for prov in po.filelist:
                yield prov
            for prov in po.dirlist:
                yield prov
            for prov in po.ghostlist:
                yield prov

        # fixme - maybe cache this list?
        
        req = {}
        orphans = []

        # prebuild the req dict    
        for po in self.returnPackages(repoid=repoid):
            if not po.requires_names:
                continue
            for r in po.requires_names:
                if r not in req:
                    req[r] = set()
                if len(req[r]) > 1: #  We only need to know if another pkg.
                    continue        # reqs. the provide. So 2 pkgs. is enough.
                req[r].add(po.name)
     
        for po in self.returnPackages(repoid=repoid):
            preq = 0
            for p in _return_all_provides(po):
                if p in req:
                    #  If this pkg provides something that is required by
                    # anything but itself (or another version of itself) it
                    # isn't an orphan.
                    if len(req[p]) > 1 or po.name not in req[p]:
                        preq += 1
                        break
        
            if preq == 0:
                orphans.append(po)
        
        return orphans

class MetaSack(PackageSackBase):
    """Represents the aggregate of multiple package sacks, such that they can
       all be treated as one unified sack."""

    def __init__(self):
        PackageSackBase.__init__(self)
        self.sacks = {}
        self.compatarchs = None

    def __len__(self):
        ret = 0
        for sack in sorted(self.sacks.values()):
            ret += len(sack)
        return ret

    def dropCachedData(self):
        for sack in self.sacks.values():
            if hasattr(sack, 'dropCachedData'):
                sack.dropCachedData()

    def addSack(self, repoid, sack):
        """Adds a repository's packageSack to this MetaSack."""
        self.sacks[repoid] = sack

        # Make sure the new sack follows the same rules we have been given.
        sack.setCompatArchs(self.compatarchs)

    def populate(self, repo, mdtype, callback, cacheOnly):
        self.sacks[repo.id].populate(repo, mdtype, callback, cacheOnly)

    def setCompatArchs(self, compatArchs):
        for sack in self.sacks.values():
            sack.setCompatArchs(compatArchs)

    def packagesByTuple(self, pkgtup):
        """return a list of package objects by (n,a,e,v,r) tuple"""
        warnings.warn('packagesByTuple() will go away in a future version of Yum.\n',
                DeprecationWarning, stacklevel=2)
        return self._computeAggregateListResult("packagesByTuple", pkgtup)

    def searchNevra(self, name=None, epoch=None, ver=None, rel=None, arch=None):
        """return list of pkgobjects matching the nevra requested"""
        return self._computeAggregateListResult("searchNevra", name, epoch, ver, rel, arch)

    def searchNames(self, names=[], return_pkgtups=False):
        return self._computeAggregateListResult("searchNames", names, return_pkgtups)

    def getProvides(self, name, flags=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }"""
        return self._computeAggregateDictResult("getProvides", name, flags, version)

    def getRequires(self, name, flags=None, version=(None, None, None)):
        """return dict { packages -> list of matching requires }"""
        return self._computeAggregateDictResult("getRequires", name, flags, version)

    def searchRequires(self, name):
        """return list of package requiring the name (any evr and flag)"""
        return self._computeAggregateListResult("searchRequires", name)

    def searchProvides(self, name):
        """return list of package providing the name (any evr and flag)"""
        return self._computeAggregateListResult("searchProvides", name)

    def searchConflicts(self, name):
        """return list of package conflicting with the name (any evr and flag)"""
        return self._computeAggregateListResult("searchConflicts", name)

    def searchObsoletes(self, name):
        """return list of package obsoleting the name (any evr and flag)"""
        return self._computeAggregateListResult("searchObsoletes", name)

    def returnObsoletes(self, newest=False):
        """returns a dict of obsoletes dict[obsoleting pkgtuple] = [list of obs]"""
        if not newest:
            return self._computeAggregateDictResult("returnObsoletes")
        
        obsdict = self._computeAggregateDictResult("returnObsoletes")

        names = set((obstup[0] for obstup in obsdict))
        nobsdict = {}
        last_name = ''
        last_pkg = None
        #  It takes about 0.2 of a second to convert these into packages, just
        # so we can sort them, which is ~40% of this functions time. So we sort
        # the pkgtups "by hand".
        def _pkgtup_nevr_cmp(x, y):
            """ Compare two pkgtup's (ignore arch): n, a, e, v, r. """
            ret = cmp(x[0], y[0])
            if ret: return ret
            # This is negated so we get higher versions first, in the list.
            return -compareEVR((x[2], x[3], x[4]), (y[2], y[3], y[4]))
        def _pkgtup_nevr_eq(x, y):
            return _pkgtup_nevr_cmp(x, y) == 0
        for pkgtup in sorted(self.searchNames(names, return_pkgtups=True),
                             cmp=_pkgtup_nevr_cmp):
            name = pkgtup[0]
            if last_name == name and not _pkgtup_nevr_eq(last_pkgtup, pkgtup):
                continue
            last_name = name
            last_pkgtup = pkgtup
            if pkgtup in obsdict:
                nobsdict[pkgtup] = obsdict[pkgtup]
        return nobsdict
        
    def searchFiles(self, name):
        """return list of packages by filename"""
        return self._computeAggregateListResult("searchFiles", name)

    def addPackage(self, obj):
        """Add a pkgobject to the packageSack.  This is a meaningless operation
           for the MetaSack."""
        pass

    def buildIndexes(self):
        """builds the useful indexes for searching/querying the packageSack
           This should be called after all the necessary packages have been
           added/deleted"""
        for sack in self.sacks.values():
            sack.buildIndexes()

    def delPackage(self, obj):
        """Delete a pkgobject if it exists in every sub-sack."""
        obj.repo.sack.delPackage(obj)


    def returnPackages(self, repoid=None, patterns=None, ignore_case=False):
        """Returns a list of packages. Note that the packages are
           always filtered to those matching the patterns/case. An optional
           repoid allows you to easily get data for a specific repo. """
        if not repoid:
            return self._computeAggregateListResult("returnPackages",
                                                    None, patterns, ignore_case)
        return self.sacks[repoid].returnPackages(patterns=patterns,
                                                 ignore_case=ignore_case)

    def addPackageExcluder(self, repoid, excluderid, excluder, *args):
        """ Add an "excluder" for all packages in the repo/sack. Can basically
            do anything based on nevra, changes lots of exclude decisions from
            "preload package; test; delPackage" into "load excluder".
            Excluderid is used so the caller doesn't have to track
            "have I loaded the excluder for this repo.", it's probably only
            useful when repoid is None ... if it turns out utterly worthless
            then it's still not a huge wart. """
        if not repoid:
            calr = self._computeAggregateListResult
            return calr("addPackageExcluder", None, excluderid, excluder, *args)
        return self.sacks[repoid].addPackageExcluder(None,
                                                     excluderid,excluder, *args)

    def returnNewestByNameArch(self, naTup=None,
                               patterns=None, ignore_case=False):
        """return list of newest packages based on name, arch matching
           this means(in name.arch form): foo.i386 and foo.noarch are not
           compared to each other for highest version only foo.i386 and
           foo.i386 will be compared.
           Note that given: foo-1.i386; foo-2.i386 and foo-3.x86_64
           The last _two_ pkgs will be returned, not just one of them. """
        calr = self._computeAggregateListResult
        pkgs = calr("returnNewestByNameArch", naTup, patterns, ignore_case)
        pkgs = packagesNewestByNameArch(pkgs)
        if not pkgs and (naTup or patterns):
            ui_pats = ", ".join(patterns or [])
            raise PackageSackError, 'No Package Matching %s' % ui_pats
        return pkgs
                
    def returnNewestByName(self, name=None, patterns=None, ignore_case=False):
        """return list of newest packages based on name matching
           this means(in name.arch form): foo.i386 and foo.noarch will
           be compared to each other for highest version."""
        pkgs = self._computeAggregateListResult("returnNewestByName", name,
                                                patterns, ignore_case)
        pkgs = packagesNewestByName(pkgs)
        if not pkgs and (name or patterns):
            if name:
                ui_pats = name
            else:
                ui_pats = ", ".join(patterns or [])
            raise PackageSackError, 'No Package Matching %s' % ui_pats
        return pkgs
        
    def simplePkgList(self, patterns=None, ignore_case=False):
        """returns a list of pkg tuples (n, a, e, v, r)"""
        return self._computeAggregateListResult("simplePkgList",
                                                patterns, ignore_case)

    def printPackages(self):
        for sack in self.sacks.values():
            sack.printPackages()

    def excludeArchs(self, archlist):
        """exclude incompatible arches. archlist is a list of compatible arches"""
        for sack in self.sacks.values():
            sack.excludeArchs(archlist)

    def searchPackages(self, fields, criteria_re, callback):
        return self._computeAggregateDictResult("searchPackages", fields, criteria_re, callback)

    def searchAll(self, arg, query_type):
        return self._computeAggregateListResult("searchAll", arg, query_type)

    def matchPackageNames(self, pkgspecs):
        matched = []
        exactmatch = []
        unmatched = None
        for sack in self.sacks.values():
            if hasattr(sack, "matchPackageNames"):
                e, m, u = [], [], []
                try:
                    e, m, u = sack.matchPackageNames(pkgspecs)
                except PackageSackError:
                    continue

                exactmatch.extend(e)
                matched.extend(m)
                if unmatched is None:
                    unmatched = set(u)
                else:
                    unmatched = unmatched.intersection(set(u))

        matched = misc.unique(matched)
        exactmatch = misc.unique(exactmatch)
        if unmatched is None:
            unmatched = []
        else:
            unmatched = list(unmatched)
        return exactmatch, matched, unmatched

    def _computeAggregateListResult(self, methodName, *args):
        result = []
        for sack in sorted(self.sacks.values()):
            if hasattr(sack, methodName):
                method = getattr(sack, methodName)
                try:
                    sackResult = apply(method, args)
                except PackageSackError:
                    continue

                if sackResult:
                    result.extend(sackResult)

        return result

    def _computeAggregateDictResult(self, methodName, *args):
        result = {}
        for sack in sorted(self.sacks.values()):
            if hasattr(sack, methodName):
                method = getattr(sack, methodName)
                try:
                    sackResult = apply(method, args)
                except PackageSackError:
                    continue

                if sackResult:
                    result.update(sackResult)
        return result



class PackageSack(PackageSackBase):
    """represents sets (sacks) of Package Objects"""
    def __init__(self):
        self.nevra = {} #nevra[(Name, Epoch, Version, Release, Arch)] = []
        self.obsoletes = {} #obs[obsoletename] = [pkg1, pkg2, pkg3] 
                 #the package lists are packages that obsolete the key name
        self.requires = {} #req[reqname] = [pkg1, pkg2, pkg3]
                 #the package lists are packages that require the key name
        self.provides = {} #ditto of above but for provides
        self.conflicts = {} #ditto of above but for conflicts
        self.filenames = {} # duh
        self.pkgsByRepo = {} #pkgsByRepo['repoid']= [pkg1, pkg2, pkg3]
        self.pkgsByID = {} #pkgsById[pkgid] = [pkg1, pkg2] (should really only ever be one value but
                           #you might have repos with the same package in them
        self.compatarchs = None # dict of compatible archs for addPackage
        self.indexesBuilt = 0
        
        
    def __len__(self):
        ret = 0
        for repo in self.pkgsByRepo:
            ret += len(self.pkgsByRepo[repo])
        return ret
    

    def _checkIndexes(self, failure='error'):
        """check to see if the indexes are built, if not do what failure demands
           either error out or build the indexes, default is to error out"""
           
        if not self.indexesBuilt:
            if failure == 'error':
                raise PackageSackError, 'Indexes not yet built, cannot search'
            elif failure == 'build':
                self.buildIndexes()

    def dropCachedData(self):
        """ Do nothing, mainly for the testing code. """
        self.clearIndexes()

    def setCompatArchs(self, compatarchs):
        self.compatarchs = compatarchs

    def searchNevra(self, name=None, epoch=None, ver=None, rel=None, arch=None):
        """return list of pkgobjects matching the nevra requested"""
        self._checkIndexes(failure='build')
        if (name, epoch, ver, rel, arch) in self.nevra:
            return self.nevra[(name, epoch, ver, rel, arch)]
        elif name is not None:
            pkgs = self.nevra.get((name, None, None, None, None), [])
        else: 
            pkgs = []
            for pkgsbyRepo in self.pkgsByRepo.itervalues():
                pkgs.extend(pkgsbyRepo)

        result = [ ]
        for po in pkgs:
            if ((name and name!=po.name) or
                (epoch and epoch!=po.epoch) or
                (ver and ver!=po.ver) or
                (rel and rel!=po.rel) or
                (arch and arch!=po.arch)):
                continue
            result.append(po)
        return result
        
    def searchNames(self, names=[], return_pkgtups=False):
        """return list of pkgobjects matching the names requested"""
        self._checkIndexes(failure='build')
        result = []
        done = set()
        for name in names:
            if name in done:
                continue
            done.add(name)
            result.extend(self.nevra.get((name, None, None, None, None), []))
        if return_pkgtups:
            return [pkg.pkgtup for pkg in result]
        return result

    def getProvides(self, name, flags=None, version=(None, None, None)):
        """return dict { packages -> list of matching provides }"""
        self._checkIndexes(failure='build')
        if version is None:
            version = (None, None, None)
        elif type(version) in (str, type(None), unicode):
            version = rpmUtils.miscutils.stringToVersion(version)
        result = { }
        for po in self.provides.get(name, []):
            hits = po.matchingPrcos('provides', (name, fla