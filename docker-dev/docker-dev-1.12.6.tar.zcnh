of the \f(CW\*(C`COMPRESSION_*\*(C'\fR values for members
from a zip file. However, this module can only handle members
whose data is in \s-1COMPRESSION_STORED\s0 or \s-1COMPRESSION_DEFLATED\s0
format.
.ie n .IP "desiredCompressionMethod( [ $method ] )" 4
.el .IP "desiredCompressionMethod( [ \f(CW$method\fR ] )" 4
.IX Item "desiredCompressionMethod( [ $method ] )"
.PD 0
.ie n .IP "desiredCompressionMethod( [ { compressionMethod => $method } ] )" 4
.el .IP "desiredCompressionMethod( [ { compressionMethod => \f(CW$method\fR } ] )" 4
.IX Item "desiredCompressionMethod( [ { compressionMethod => $method } ] )"
.PD
Get or set the member's \f(CW\*(C`desiredCompressionMethod\*(C'\fR. This is
the compression method that will be used when the member is
written. Returns prior desiredCompressionMethod. Only
\&\s-1COMPRESSION_DEFLATED\s0 or \s-1COMPRESSION_STORED\s0 are valid
arguments. Changing to \s-1COMPRESSION_STORED\s0 will change the
member desiredCompressionLevel to 0; changing to
\&\s-1COMPRESSION_DEFLATED\s0 will change the member
desiredCompressionLevel to \s-1COMPRESSION_LEVEL_DEFAULT.\s0
.ie n .IP "desiredCompressionLevel( [ $level ] )" 4
.el .IP "desiredCompressionLevel( [ \f(CW$level\fR ] )" 4
.IX Item "desiredCompressionLevel( [ $level ] )"
.PD 0
.ie n .IP "desiredCompressionLevel( [ { compressionLevel => $level } ] )" 4
.el .IP "desiredCompressionLevel( [ { compressionLevel => \f(CW$level\fR } ] )" 4
.IX Item "desiredCompressionLevel( [ { compressionLevel => $level } ] )"
.PD
Get or set the member's desiredCompressionLevel This is the
method that will be used to write. Returns prior
desiredCompressionLevel. Valid arguments are 0 through 9,
\&\s-1COMPRESSION_LEVEL_NONE, COMPRESSION_LEVEL_DEFAULT,
COMPRESSION_LEVEL_BEST_COMPRESSION,\s0 and
\&\s-1COMPRESSION_LEVEL_FASTEST. 0\s0 or \s-1COMPRESSION_LEVEL_NONE\s0 will
change the desiredCompressionMethod to \s-1COMPRESSION_STORED.\s0
All other arguments will change the desiredCompressionMethod
to \s-1COMPRESSION_DEFLATED.\s0
.IP "\fIexternalFileName()\fR" 4
.IX Item "externalFileName()"
Return the member's external file name, if any, or undef.
.IP "\fIfileName()\fR" 4
.IX Item "fileName()"
Get or set the member's internal filename. Returns the
(possibly new) filename. Names will have backslashes
converted to forward slashes, and will have multiple
consecutive slashes converted to single ones.
.IP "\fIlastModFileDateTime()\fR" 4
.IX Item "lastModFileDateTime()"
Return the member's last modification date/time stamp in
MS-DOS format.
.IP "\fIlastModTime()\fR" 4
.IX Item "lastModTime()"
Return the member's last modification date/time stamp,
converted to unix localtime format.
.Sp
.Vb 1
\&    print "Mod Time: " . scalar( localtime( $member\->lastModTime() ) );
.Ve
.IP "\fIsetLastModFileDateTimeFromUnix()\fR" 4
.IX Item "setLastModFileDateTimeFromUnix()"
Set the member's lastModFileDateTime from the given unix
time.
.Sp
.Vb 1
\&    $member\->setLastModFileDateTimeFromUnix( time() );
.Ve
.IP "\fIinternalFileAttributes()\fR" 4
.IX Item "internalFileAttributes()"
Return the internal file attributes field from the zip
header. This is only set for members read from a zip file.
.IP "\fIexternalFileAttributes()\fR" 4
.IX Item "externalFileAttributes()"
Return member attributes as read from the \s-1ZIP\s0 file. Note that
these are \s-1NOT UNIX\s0!
.ie n .IP "unixFileAttributes( [ $newAttributes ] )" 4
.el .IP "unixFileAttributes( [ \f(CW$newAttributes\fR ] )" 4
.IX Item "unixFileAttributes( [ $newAttributes ] )"
.PD 0
.ie n .IP "unixFileAttributes( [ { attributes => $newAttributes } ] )" 4
.el .IP "unixFileAttributes( [ { attributes => \f(CW$newAttributes\fR } ] )" 4
.IX Item "unixFileAttributes( [ { attributes => $newAttributes } ] )"
.PD
Get or set the member's file attributes using \s-1UNIX\s0 file
attributes. Returns old attributes.
.Sp
.Vb 1
\&    my $oldAttribs = $member\->unixFileAttributes( 0666 );
.Ve
.Sp
Note that the return value has more than just the file
permissions, so you will have to mask off the lowest bits for
comparisons.
.ie n .IP "localExtraField( [ $newField ] )" 4
.el .IP "localExtraField( [ \f(CW$newField\fR ] )" 4
.IX Item "localExtraField( [ $newField ] )"
.PD 0
.ie n .IP "localExtraField( [ { field => $newField } ] )" 4
.el .IP "localExtraField( [ { field => \f(CW$newField\fR } ] )" 4
.IX Item "localExtraField( [ { field => $newField } ] )"
.PD
Gets or sets the extra field that was read from the local
header. This is not set for a member from a zip file until
after the member has been written out. The extra field must
be in the proper format.
.ie n .IP "cdExtraField( [ $newField ] )" 4
.el .IP "cdExtraField( [ \f(CW$newField\fR ] )" 4
.IX Item "cdExtraField( [ $newField ] )"
.PD 0
.ie n .IP "cdExtraField( [ { field => $newField } ] )" 4
.el .IP "cdExtraField( [ { field => \f(CW$newField\fR } ] )" 4
.IX Item "cdExtraField( [ { field => $newField } ] )"
.PD
Gets or sets the extra field that was read from the central
directory header. The extra field must be in the proper
format.
.IP "\fIextraFields()\fR" 4
.IX Item "extraFields()"
Return both local and \s-1CD\s0 extra fields, concatenated.
.ie n .IP "fileComment( [ $newComment ] )" 4
.el .IP "fileComment( [ \f(CW$newComment\fR ] )" 4
.IX Item "fileComment( [ $newComment ] )"
.PD 0
.ie n .IP "fileComment( [ { comment => $newComment } ] )" 4
.el .IP "fileComment( [ { comment => \f(CW$newComment\fR } ] )" 4
.IX Item "fileComment( [ { comment => $newComment } ] )"
.PD
Get or set the member's file comment.
.IP "\fIhasDataDescriptor()\fR" 4
.IX Item "hasDataDescriptor()"
Get or set the data descriptor flag. If this is set, the
local header will not necessarily have the correct data
sizes. Instead, a small structure will be stored at the end
of the member data with these values. This should be
transparent in normal operation.
.IP "\fIcrc32()\fR" 4
.IX Item "crc32()"
Return the \s-1CRC\-32\s0 value for this member. This will not be set
for members that were constructed from strings or external
files until after the member has been written.
.IP "\fIcrc32String()\fR" 4
.IX Item "crc32String()"
Return the \s-1CRC\-32\s0 value for this member as an 8 character
printable hex string. This will not be set for members that
were constructed from strings or external files until after
the member has been written.
.IP "\fIcompressedSize()\fR" 4
.IX Item "compressedSize()"
Return the compressed size for this member. This will not be
set for members that were constructed from strings or
external files until after the member has been written.
.IP "\fIuncompressedSize()\fR" 4
.IX Item "uncompressedSize()"
Return the uncompressed size for this member.
.ie n .IP "password( [ $password ] )" 4
.el .IP "password( [ \f(CW$password\fR ] )" 4
.IX Item "password( [ $password ] )"
Returns the password for this member to be used on decryption.
If \f(CW$password\fR is given, it will set the password for the decryption.
.IP "\fIisEncrypted()\fR" 4
.IX Item "isEncrypted()"
Return true if this member is encrypted. The Archive::Zip
module does not currently support creation of encrypted
members. Decryption works more or less like this:
.Sp
.Vb 5
\&  my $zip = Archive::Zip\->new;
\&  $zip\->read ("encrypted.zip");
\&  for my $m (map { $zip\->memberNamed ($_) } $zip\->memberNames) {
\&      $m\->password ("secret");
\&      $m\->contents;  # is "" when password was wrong
.Ve
.Sp
That shows that the password has to be set per member, and not per
archive. This might change in the future.
.ie n .IP "isTextFile( [ $flag ] )" 4
.el .IP "isTextFile( [ \f(CW$flag\fR ] )" 4
.IX Item "isTextFile( [ $flag ] )"
.PD 0
.ie n .IP "isTextFile( [ { flag => $flag } ] )" 4
.el .IP "isTextFile( [ { flag => \f(CW$flag\fR } ] )" 4
.IX Item "isTextFile( [ { flag => $flag } ] )"
.PD
Returns true if I am a text file. Also can set the status if
given an argument (then returns old state). Note that this
module does not currently do anything with this flag upon
extraction or storage. That is, bytes are stored in native
format whether or not they came from a text file.
.IP "\fIisBinaryFile()\fR" 4
.IX Item "isBinaryFile()"
Returns true if I am a binary file. Also can set the status
if given an argument (then returns old state). Note that this
module does not currently do anything with this flag upon
extraction or storage. That is, bytes are stored in native
format whether or not they came from a text file.
.ie n .IP "extractToFileNamed( $fileName )" 4
.el .IP "extractToFileNamed( \f(CW$fileName\fR )" 4
.IX Item "extractToFileNamed( $fileName )"
.PD 0
.ie n .IP "extractToFileNamed( { name => $fileName } )" 4
.el .IP "extractToFileNamed( { name => \f(CW$fileName\fR } )" 4
.IX Item "extractToFileNamed( { name => $fileName } )"
.PD
Extract me to a file with the given name. The file will be
created with default modes. Directories will be created as
needed.
The \f(CW$fileName\fR argument should be a valid file name on your
file system.
Returns \s-1AZ_OK\s0 on success.
.IP "\fIisDirectory()\fR" 4
.IX Item "isDirectory()"
Returns true if I am a directory.
.IP "\fIwriteLocalHeaderRelativeOffset()\fR" 4
.IX Item "writeLocalHeaderRelativeOffset()"
Returns the file offset in bytes the last time I was written.
.IP "\fIwasWritten()\fR" 4
.IX Item "wasWritten()"
Returns true if I was successfully written. Reset at the
beginning of a write attempt.
.SS "Low-level member data reading"
.IX Subsection "Low-level member data reading"
It is possible to use lower-level routines to access member data
streams, rather than the extract* methods and \fIcontents()\fR. For
instance, here is how to print the uncompressed contents of a member
in chunks using these methods:
.PP
.Vb 10
\&    my ( $member, $status, $bufferRef );
\&    $member = $zip\->memberNamed( \*(Aqxyz.txt\*(Aq );
\&    $member\->desiredCompressionMethod( COMPRESSION_STORED );
\&    $status = $member\->rewindData();
\&    die "error $status" unless $status == AZ_OK;
\&    while ( ! $member\->readIsDone() )
\&    {
\&    ( $bufferRef, $status ) = $member\->readChunk();
\&    die "error $status"
\&                if $status != AZ_OK && $status != AZ_STREAM_END;
\&    # do something with $bufferRef:
\&    print $$bufferRef;
\&    }
\&    $member\->endRead();
.Ve
.ie n .IP "readChunk( [ $chunkSize ] )" 4
.el .IP "readChunk( [ \f(CW$chunkSize\fR ] )" 4
.IX Item "readChunk( [ $chunkSize ] )"
.PD 0
.ie n .IP "readChunk( [ { chunkSize => $chunkSize } ] )" 4
.el .IP "readChunk( [ { chunkSize => \f(CW$chunkSize\fR } ] )" 4
.IX Item "readChunk( [ { chunkSize => $chunkSize } ] )"
.PD
This reads the next chunk of given size from the member's
data stream and compresses or uncompresses it as necessary,
returning a reference to the bytes read and a status. If size
argument is not given, defaults to global set by
Archive::Zip::setChunkSize. Status is \s-1AZ_OK\s0 on success until
the last chunk, where it returns \s-1AZ_STREAM_END.\s0 Returns \f(CW\*(C`(
\&\e$bytes, $status)\*(C'\fR.
.Sp
.Vb 2
\&    my ( $outRef, $status ) = $self\->readChunk();
\&    print $$outRef if $status != AZ_OK && $status != AZ_STREAM_END;
.Ve
.IP "\fIrewindData()\fR" 4
.IX Item "rewindData()"
Rewind data and set up for reading data streams or writing
zip files. Can take options for \f(CW\*(C`inflateInit()\*(C'\fR or
\&\f(CW\*(C`deflateInit()\*(C'\fR, but this is not likely to be necessary.
Subclass overrides should call this method. Returns \f(CW\*(C`AZ_OK\*(C'\fR
on success.
.IP "\fIendRead()\fR" 4
.IX Item "endRead()"
Reset the read variables and free the inflater or deflater.
Must be called to close files, etc. Returns \s-1AZ_OK\s0 on success.
.IP "\fIreadIsDone()\fR" 4
.IX Item "readIsDone()"
Return true if the read has run out of data or encountered an error.
.IP "\fIcontents()\fR" 4
.IX Item "contents()"
Return the entire uncompressed member data or undef in scalar
context. When called in array context, returns \f(CW\*(C`( $string,
$status )\*(C'\fR; status will be \s-1AZ_OK\s0 on success:
.Sp
.Vb 4
\&    my $string = $member\->contents();
\&    # or
\&    my ( $string, $status ) = $member\->contents();
\&    die "error $status" unless $status == AZ_OK;
.Ve
.Sp
Can also be used to set the contents of a member (this may
change the class of the member):
.Sp
.Vb 1
\&    $member\->contents( "this is my new contents" );
.Ve
.ie n .IP "extractToFileHandle( $fh )" 4
.el .IP "extractToFileHandle( \f(CW$fh\fR )" 4
.IX Item "extractToFileHandle( $fh )"
.PD 0
.ie n .IP "extractToFileHandle( { fileHandle => $fh } )" 4
.el .IP "extractToFileHandle( { fileHandle => \f(CW$fh\fR } )" 4
.IX Item "extractToFileHandle( { fileHandle => $fh } )"
.PD
Extract (and uncompress, if necessary) the member's contents
to the given file handle. Return \s-1AZ_OK\s0 on success.
.SH "Archive::Zip::FileMember methods"
.IX Header "Archive::Zip::FileMember methods"
The Archive::Zip::FileMember class extends Archive::Zip::Member. It is the
base class for both ZipFileMember and NewFileMember classes. This class adds
an \f(CW\*(C`externalFileName\*(C'\fR and an \f(CW\*(C`fh\*(C'\fR member to keep track of the external
file.
.IP "\fIexternalFileName()\fR" 4
.IX Item "externalFileName()"
Return the member's external filename.
.IP "\fIfh()\fR" 4
.IX Item "fh()"
Return the member's read file handle. Automatically opens file if
necessary.
.SH "Archive::Zip::ZipFileMember methods"
.IX Header "Archive::Zip::ZipFileMember methods"
The Archive::Zip::ZipFileMember class represents members that have been read
from external zip files.
.IP "\fIdiskNumberStart()\fR" 4
.IX Item "diskNumberStart()"
Returns the disk number that the member's local header resides in.
Should be 0.
.IP "\fIlocalHeaderRelativeOffset()\fR" 4
.IX Item "localHeaderRelativeOffset()"
Returns the offset into the zip file where the member's local header
is.
.IP "\fIdataOffset()\fR" 4
.IX Item "dataOffset()"
Returns the offset from the beginning of the zip file to the member's
data.
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
Archive::Zip requires several other modules:
.PP
Carp
.PP
Compress::Raw::Zlib
.PP
Cwd
.PP
File::Basename
.PP
File::Copy
.PP
File::Find
.PP
File::Path
.PP
File::Spec
.PP
IO::File
.PP
IO::Seekable
.PP
Time::Local
.SH "BUGS AND CAVEATS"
.IX Header "BUGS AND CAVEATS"
.SS "When not to use Archive::Zip"
.IX Subsection "When not to use Archive::Zip"
If you are just going to be extracting zips (and/or other archives) you
are recommended to look at using Archive::Extract instead, as it is much
easier to use and factors out archive-specific functionality.
.SS "Try to avoid IO::Scalar"
.IX Subsection "Try to avoid IO::Scalar"
One of the most common ways to use Archive::Zip is to generate Zip files
in-memory. Most people use IO::Scalar for this purpose.
.PP
Unfortunately, as of 1.11 this module no longer works with IO::Scalar
as it incorrectly implements seeking.
.PP
Anybody using IO::Scalar should consider porting to IO::String,
which is smaller, lighter, and is implemented to be perfectly compatible
with regular seekable filehandles.
.PP
Support for IO::Scalar most likely will \fBnot\fR be restored in the
future, as IO::Scalar itself cannot change the way it is implemented
due to back-compatibility issues.
.SS "Wrong password for encrypted members"
.IX Subsection "Wrong password for encrypted members"
When an encrypted member is read using the wrong password, you currently
have to re-read the entire archive to try again with the correct password.
.SH "TO DO"
.IX Header "TO DO"
* auto-choosing storing vs compression
.PP
* extra field hooks (see notes.txt)
.PP
* check for duplicates on addition/renaming?
.PP
* Text file extraction (line end translation)
.PP
* Reading zip files from non-seekable inputs
  (Perhaps by proxying through IO::String?)
.PP
* separate unused constants into separate module
.PP
* cookbook style docs
.PP
* Handle tainted paths correctly
.PP
* Work on better compatibility with other \s-1IO::\s0 modules
.PP
* Support encryption
.PP
* More user-friendly decryption
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be reported via the \s-1CPAN\s0 bug tracker
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive\-Zip>
.PP
For other issues contact the maintainer
.SH "AUTHOR"
.IX Header "AUTHOR"
Currently maintained by Fred Moyer <fred@redhotpenguin.com>
.PP
Previously maintained by Adam Kennedy <adamk@cpan.org>
.PP
Previously maintained by Steve Peters <steve@fisharerojo.org>.
.PP
File attributes code by Maurice Aubrey <maurice@lovelyfilth.com>.
.PP
Originally by Ned Konz <nedkonz@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Some parts copyright 2006 \- 2012 Adam Kennedy.
.PP
Some parts copyright 2005 Steve Peters.
.PP
Original work copyright 2000 \- 2004 Ned Konz.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Look at Archive::Zip::MemberRead which is a wrapper that allows one to
read Zip archive members as if they were files.
.PP
Compress::Raw::Zlib, Archive::Tar, Archive::Extract
                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip5.16.3pm                         0100644 0001750 0001750 00000162532 12566241430 024047  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip 3"
.TH Archive::Zip 3 "2009-06-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip \- Provide an interface to ZIP archive files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   # Create a Zip file
\&   use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
\&   my $zip = Archive::Zip\->new();
\&   
\&   # Add a directory
\&   my $dir_member = $zip\->addDirectory( \*(Aqdirname/\*(Aq );
\&   
\&   # Add a file from a string with compression
\&   my $string_member = $zip\->addString( \*(AqThis is a test\*(Aq, \*(AqstringMember.txt\*(Aq );
\&   $string_member\->desiredCompressionMethod( COMPRESSION_DEFLATED );
\&   
\&   # Add a file from disk
\&   my $file_member = $zip\->addFile( \*(Aqxyz.pl\*(Aq, \*(AqAnotherName.pl\*(Aq );
\&   
\&   # Save the Zip file
\&   unless ( $zip\->writeToFileNamed(\*(AqsomeZip.zip\*(Aq) == AZ_OK ) {
\&       die \*(Aqwrite error\*(Aq;
\&   }
\&   
\&   # Read a Zip file
\&   my $somezip = Archive::Zip\->new();
\&   unless ( $somezip\->read( \*(AqsomeZip.zip\*(Aq ) == AZ_OK ) {
\&       die \*(Aqread error\*(Aq;
\&   }
\&   
\&   # Change the compression type for a file in the Zip
\&   my $member = $somezip\->memberNamed( \*(AqstringMember.txt\*(Aq );
\&   $member\->desiredCompressionMethod( COMPRESSION_STORED );
\&   unless ( $zip\->writeToFileNamed( \*(AqsomeOtherZip.zip\*(Aq ) == AZ_OK ) {
\&       die \*(Aqwrite error\*(Aq;
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Archive::Zip module allows a Perl program to create, manipulate, read,
and write Zip archive files.
.PP
Zip archives can be created, or you can read from existing zip files.
.PP
Once created, they can be written to files, streams, or strings. Members
can be added, removed, extracted, replaced, rearranged, and enumerated.
They can also be renamed or have their dates, comments, or other attributes
queried or modified. Their data can be compressed or uncompressed as needed.
.PP
Members can be created from members in existing Zip files, or from existing
directories, files, or strings.
.PP
This module uses the Compress::Raw::Zlib library to read and write the
compressed streams inside the files.
.PP
One can use Archive::Zip::MemberRead to read the zip file archive members
as if they were files.
.SS "File Naming"
.IX Subsection "File Naming"
Regardless of what your local file system uses for file naming, names in a
Zip file are in Unix format (\fIforward\fR slashes (/) separating directory
names, etc.).
.PP
\&\f(CW\*(C`Archive::Zip\*(C'\fR tries to be consistent with file naming conventions, and will
translate back and forth between native and Zip file names.
.PP
However, it can't guess which format names are in. So two rules control what
kind of file name you must pass various routines:
.IP "Names of files are in local format." 4
.IX Item "Names of files are in local format."
\&\f(CW\*(C`File::Spec\*(C'\fR and \f(CW\*(C`File::Basename\*(C'\fR are used for various file
operations. When you're referring to a file on your system, use its
file naming conventions.
.IP "Names of archive members are in Unix format." 4
.IX Item "Names of archive members are in Unix format."
This applies to every method that refers to an archive member, or
provides a name for new archive members. The \f(CW\*(C`extract()\*(C'\fR methods
that can take one or two names will convert from local to zip names
if you call them with a single name.
.SS "Archive::Zip Object Model"
.IX Subsection "Archive::Zip Object Model"
.SS "Overview"
.IX Subsection "Overview"
Archive::Zip::Archive objects are what you ordinarily deal with.
These maintain the structure of a zip file, without necessarily
holding data. When a zip is read from a disk file, the (possibly
compressed) data still lives in the file, not in memory. Archive
members hold information about the individual members, but not
(usually) the actual member data. When the zip is written to a
(different) file, the member data is compressed or copied as needed.
It is possible to make archive members whose data is held in a string
in memory, but this is not done when a zip file is read. Directory
members don't have any data.
.SS "Inheritance"
.IX Subsection "Inheritance"
.Vb 9
\&  Exporter
\&   Archive::Zip                            Common base class, has defs.
\&       Archive::Zip::Archive               A Zip archive.
\&       Archive::Zip::Member                Abstract superclass for all members.
\&           Archive::Zip::StringMember      Member made from a string
\&           Archive::Zip::FileMember        Member made from an external file
\&               Archive::Zip::ZipFileMember Member that lives in a zip file
\&               Archive::Zip::NewFileMember Member whose data is in a file
\&           Archive::Zip::DirectoryMember   Member that is a directory
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
.IP ":CONSTANTS" 4
.IX Item ":CONSTANTS"
Exports the following constants:
.Sp
\&\s-1FA_MSDOS\s0 \s-1FA_UNIX\s0 \s-1GPBF_ENCRYPTED_MASK\s0
\&\s-1GPBF_DEFLATING_COMPRESSION_MASK\s0 \s-1GPBF_HAS_DATA_DESCRIPTOR_MASK\s0
\&\s-1COMPRESSION_STORED\s0 \s-1COMPRESSION_DEFLATED\s0 \s-1IFA_TEXT_FILE_MASK\s0
\&\s-1IFA_TEXT_FILE\s0 \s-1IFA_BINARY_FILE\s0 \s-1COMPRESSION_LEVEL_NONE\s0
\&\s-1COMPRESSION_LEVEL_DEFAULT\s0 \s-1COMPRESSION_LEVEL_FASTEST\s0
\&\s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0
.IP ":MISC_CONSTANTS" 4
.IX Item ":MISC_CONSTANTS"
Exports the following constants (only necessary for extending the
module):
.Sp
\&\s-1FA_AMIGA\s0 \s-1FA_VAX_VMS\s0 \s-1FA_VM_CMS\s0 \s-1FA_ATARI_ST\s0 \s-1FA_OS2_HPFS\s0
\&\s-1FA_MACINTOSH\s0 \s-1FA_Z_SYSTEM\s0 \s-1FA_CPM\s0 \s-1FA_WINDOWS_NTFS\s0
\&\s-1GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK\s0
\&\s-1GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK\s0
\&\s-1GPBF_IS_COMPRESSED_PATCHED_DATA_MASK\s0 \s-1COMPRESSION_SHRUNK\s0
\&\s-1DEFLATING_COMPRESSION_NORMAL\s0 \s-1DEFLATING_COMPRESSION_MAXIMUM\s0
\&\s-1DEFLATING_COMPRESSION_FAST\s0 \s-1DEFLATING_COMPRESSION_SUPER_FAST\s0
\&\s-1COMPRESSION_REDUCED_1\s0 \s-1COMPRESSION_REDUCED_2\s0 \s-1COMPRESSION_REDUCED_3\s0
\&\s-1COMPRESSION_REDUCED_4\s0 \s-1COMPRESSION_IMPLODED\s0 \s-1COMPRESSION_TOKENIZED\s0
\&\s-1COMPRESSION_DEFLATED_ENHANCED\s0
\&\s-1COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED\s0
.IP ":ERROR_CODES" 4
.IX Item ":ERROR_CODES"
Explained below. Returned from most methods.
.Sp
\&\s-1AZ_OK\s0 \s-1AZ_STREAM_END\s0 \s-1AZ_ERROR\s0 \s-1AZ_FORMAT_ERROR\s0 \s-1AZ_IO_ERROR\s0
.SH "ERROR CODES"
.IX Header "ERROR CODES"
Many of the methods in Archive::Zip return error codes. These are implemented
as inline subroutines, using the \f(CW\*(C`use constant\*(C'\fR pragma. They can be imported
into your namespace using the \f(CW\*(C`:ERROR_CODES\*(C'\fR tag:
.PP
.Vb 1
\&  use Archive::Zip qw( :ERROR_CODES );
\&  
\&  ...
\&  
\&  unless ( $zip\->read( \*(Aqmyfile.zip\*(Aq ) == AZ_OK ) {
\&      die "whoops!";
\&  }
.Ve
.IP "\s-1AZ_OK\s0 (0)" 4
.IX Item "AZ_OK (0)"
Everything is fine.
.IP "\s-1AZ_STREAM_END\s0 (1)" 4
.IX Item "AZ_STREAM_END (1)"
The read stream (or central directory) ended normally.
.IP "\s-1AZ_ERROR\s0 (2)" 4
.IX Item "AZ_ERROR (2)"
There was some generic kind of error.
.IP "\s-1AZ_FORMAT_ERROR\s0 (3)" 4
.IX Item "AZ_FORMAT_ERROR (3)"
There is a format error in a \s-1ZIP\s0 file being read.
.IP "\s-1AZ_IO_ERROR\s0 (4)" 4
.IX Item "AZ_IO_ERROR (4)"
There was an \s-1IO\s0 error.
.SS "Compression"
.IX Subsection "Compression"
Archive::Zip allows each member of a \s-1ZIP\s0 file to be compressed (using the
Deflate algorithm) or uncompressed.
.PP
Other compression algorithms that some versions of \s-1ZIP\s0 have been able to
produce are not supported. Each member has two compression methods: the
one it's stored as (this is always \s-1COMPRESSION_STORED\s0 for string and external
file members), and the one you desire for the member in the zip file.
.PP
These can be different, of course, so you can make a zip member that is not
compressed out of one that is, and vice versa.
.PP
You can inquire about the current compression and set the desired
compression method:
.PP
.Vb 2
\&  my $member = $zip\->memberNamed( \*(Aqxyz.txt\*(Aq );
\&  $member\->compressionMethod();    # return current compression
\&  
\&  # set to read uncompressed
\&  $member\->desiredCompressionMethod( COMPRESSION_STORED );
\&  
\&  # set to read compressed
\&  $member\->desiredCompressionMethod( COMPRESSION_DEFLATED );
.Ve
.PP
There are two different compression methods:
.IP "\s-1COMPRESSION_STORED\s0" 4
.IX Item "COMPRESSION_STORED"
File is stored (no compression)
.IP "\s-1COMPRESSION_DEFLATED\s0" 4
.IX Item "COMPRESSION_DEFLATED"
File is Deflated
.SS "Compression Levels"
.IX Subsection "Compression Levels"
If a member's desiredCompressionMethod is \s-1COMPRESSION_DEFLATED\s0, you
can choose different compression levels. This choice may affect the
speed of compression and decompression, as well as the size of the
compressed member data.
.PP
.Vb 1
\&  $member\->desiredCompressionLevel( 9 );
.Ve
.PP
The levels given can be:
.IP "0 or \s-1COMPRESSION_LEVEL_NONE\s0" 4
.IX Item "0 or COMPRESSION_LEVEL_NONE"
This is the same as saying
.Sp
.Vb 1
\&  $member\->desiredCompressionMethod( COMPRESSION_STORED );
.Ve
.IP "1 .. 9" 4
.IX Item "1 .. 9"
1 gives the best speed and worst compression, and 9 gives the
best compression and worst speed.
.IP "\s-1COMPRESSION_LEVEL_FASTEST\s0" 4
.IX Item "COMPRESSION_LEVEL_FASTEST"
This is a synonym for level 1.
.IP "\s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0" 4
.IX Item "COMPRESSION_LEVEL_BEST_COMPRESSION"
This is a synonym for level 9.
.IP "\s-1COMPRESSION_LEVEL_DEFAULT\s0" 4
.IX Item "COMPRESSION_LEVEL_DEFAULT"
This gives a good compromise between speed and compression,
and is currently equivalent to 6 (this is in the zlib code).
This is the level that will be used if not specified.
.SH "Archive::Zip Methods"
.IX Header "Archive::Zip Methods"
The Archive::Zip class (and its invisible subclass Archive::Zip::Archive)
implement generic zip file functionality. Creating a new Archive::Zip object
actually makes an Archive::Zip::Archive object, but you don't have to worry
about this unless you're subclassing.
.SS "Constructor"
.IX Subsection "Constructor"
.IP "new( [$fileName] )" 4
.IX Item "new( [$fileName] )"
Make a new, empty zip archive.
.Sp
.Vb 1
\&    my $zip = Archive::Zip\->new();
.Ve
.Sp
If an additional argument is passed, \fInew()\fR will call \fIread()\fR
to read the contents of an archive:
.Sp
.Vb 1
\&    my $zip = Archive::Zip\->new( \*(Aqxyz.zip\*(Aq );
.Ve
.Sp
If a filename argument is passed and the read fails for any
reason, new will return undef. For this reason, it may be
better to call read separately.
.SS "Zip Archive Utility Methods"
.IX Subsection "Zip Archive Utility Methods"
These Archive::Zip methods may be called as functions or as object
methods. Do not call them as class methods:
.PP
.Vb 4
\&    $zip = Archive::Zip\->new();
\&    $crc = Archive::Zip::computeCRC32( \*(Aqghijkl\*(Aq );    # OK
\&    $crc = $zip\->computeCRC32( \*(Aqghijkl\*(Aq );            # also OK
\&    $crc = Archive::Zip\->computeCRC32( \*(Aqghijkl\*(Aq );    # NOT OK
.Ve
.ie n .IP "Archive::Zip::computeCRC32( $string [, $crc] )" 4
.el .IP "Archive::Zip::computeCRC32( \f(CW$string\fR [, \f(CW$crc\fR] )" 4
.IX Item "Archive::Zip::computeCRC32( $string [, $crc] )"
This is a utility function that uses the Compress::Raw::Zlib \s-1CRC\s0
routine to compute a \s-1CRC\-32\s0. You can get the \s-1CRC\s0 of a string:
.Sp
.Vb 1
\&    $crc = Archive::Zip::computeCRC32( $string );
.Ve
.Sp
Or you can compute the running \s-1CRC:\s0
.Sp
.Vb 3
\&    $crc = 0;
\&    $crc = Archive::Zip::computeCRC32( \*(Aqabcdef\*(Aq, $crc );
\&    $crc = Archive::Zip::computeCRC32( \*(Aqghijkl\*(Aq, $crc );
.Ve
.ie n .IP "Archive::Zip::setChunkSize( $number )" 4
.el .IP "Archive::Zip::setChunkSize( \f(CW$number\fR )" 4
.IX Item "Archive::Zip::setChunkSize( $number )"
Report or change chunk size used for reading and writing.
This can make big differences in dealing with large files.
Currently, this defaults to 32K. This also changes the chunk
size used for Compress::Raw::Zlib. You must call \fIsetChunkSize()\fR
before reading or writing. This is not exportable, so you
must call it like:
.Sp
.Vb 1
\&    Archive::Zip::setChunkSize( 4096 );
.Ve
.Sp
or as a method on a zip (though this is a global setting).
Returns old chunk size.
.IP "\fIArchive::Zip::chunkSize()\fR" 4
.IX Item "Archive::Zip::chunkSize()"
Returns the current chunk size:
.Sp
.Vb 1
\&    my $chunkSize = Archive::Zip::chunkSize();
.Ve
.IP "Archive::Zip::setErrorHandler( \e&subroutine )" 4
.IX Item "Archive::Zip::setErrorHandler( &subroutine )"
Change the subroutine called with error strings. This
defaults to \e&Carp::carp, but you may want to change it to
get the error strings. This is not exportable, so you must
call it like:
.Sp
.Vb 1
\&    Archive::Zip::setErrorHandler( \e&myErrorHandler );
.Ve
.Sp
If myErrorHandler is undef, resets handler to default.
Returns old error handler. Note that if you call Carp::carp
or a similar routine or if you're chaining to the default
error handler from your error handler, you may want to
increment the number of caller levels that are skipped (do
not just set it to a number):
.Sp
.Vb 1
\&    $Carp::CarpLevel++;
.Ve
.IP "Archive::Zip::tempFile( [$tmpdir] )" 4
.IX Item "Archive::Zip::tempFile( [$tmpdir] )"
Create a uniquely named temp file. It will be returned open
for read/write. If \f(CW$tmpdir\fR is given, it is used as the
name of a directory to create the file in. If not given,
creates the file using \f(CW\*(C`File::Spec::tmpdir()\*(C'\fR. Generally, you can
override this choice using the
.Sp
.Vb 1
\&    $ENV{TMPDIR}
.Ve
.Sp
environment variable. But see the File::Spec
documentation for your system. Note that on many systems, if you're
running in taint mode, then you must make sure that \f(CW$ENV{TMPDIR}\fR is
untainted for it to be used.
Will \fI\s-1NOT\s0\fR create \f(CW$tmpdir\fR if it doesn't exist (this is a change
from prior versions!). Returns file handle and name:
.Sp
.Vb 3
\&    my ($fh, $name) = Archive::Zip::tempFile();
\&    my ($fh, $name) = Archive::Zip::tempFile(\*(AqmyTempDir\*(Aq);
\&    my $fh = Archive::Zip::tempFile();  # if you don\*(Aqt need the name
.Ve
.SS "Zip Archive Accessors"
.IX Subsection "Zip Archive Accessors"
.IP "\fImembers()\fR" 4
.IX Item "members()"
Return a copy of the members array
.Sp
.Vb 1
\&    my @members = $zip\->members();
.Ve
.IP "\fInumberOfMembers()\fR" 4
.IX Item "numberOfMembers()"
Return the number of members I have
.IP "\fImemberNames()\fR" 4
.IX Item "memberNames()"
Return a list of the (internal) file names of the zip members
.ie n .IP "memberNamed( $string )" 4
.el .IP "memberNamed( \f(CW$string\fR )" 4
.IX Item "memberNamed( $string )"
Return ref to member whose filename equals given filename or
undef. \f(CW$string\fR must be in Zip (Unix) filename format.
.ie n .IP "membersMatching( $regex )" 4
.el .IP "membersMatching( \f(CW$regex\fR )" 4
.IX Item "membersMatching( $regex )"
Return array of members whose filenames match given regular
expression in list context. Returns number of matching
members in scalar context.
.Sp
.Vb 3
\&    my @textFileMembers = $zip\->membersMatching( \*(Aq.*\e.txt\*(Aq );
\&    # or
\&    my $numberOfTextFiles = $zip\->membersMatching( \*(Aq.*\e.txt\*(Aq );
.Ve
.IP "\fIdiskNumber()\fR" 4
.IX Item "diskNumber()"
Return the disk that I start on. Not used for writing zips,
but might be interesting if you read a zip in. This should be
0, as Archive::Zip does not handle multi-volume archives.
.IP "\fIdiskNumberWithStartOfCentralDirectory()\fR" 4
.IX Item "diskNumberWithStartOfCentralDirectory()"
Return the disk number that holds the beginning of the
central directory. Not used for writing zips, but might be
interesting if you read a zip in. This should be 0, as
Archive::Zip does not handle multi-volume archives.
.IP "\fInumberOfCentralDirectoriesOnThisDisk()\fR" 4
.IX Item "numberOfCentralDirectoriesOnThisDisk()"
Return the number of \s-1CD\s0 structures in the zipfile last read in.
Not used for writing zips, but might be interesting if you read a zip
in.
.IP "\fInumberOfCentralDirectories()\fR" 4
.IX Item "numberOfCentralDirectories()"
Return the number of \s-1CD\s0 structures in the zipfile last read in.
Not used for writing zips, but might be interesting if you read a zip
in.
.IP "\fIcentralDirectorySize()\fR" 4
.IX Item "centralDirectorySize()"
Returns central directory size, as read from an external zip
file. Not used for writing zips, but might be interesting if
you read a zip in.
.IP "\fIcentralDirectoryOffsetWRTStartingDiskNumber()\fR" 4
.IX Item "centralDirectoryOffsetWRTStartingDiskNumber()"
Returns the offset into the zip file where the \s-1CD\s0 begins. Not
used for writing zips, but might be interesting if you read a
zip in.
.IP "zipfileComment( [$string] )" 4
.IX Item "zipfileComment( [$string] )"
Get or set the zipfile comment. Returns the old comment.
.Sp
.Vb 2
\&    print $zip\->zipfileComment();
\&    $zip\->zipfileComment( \*(AqNew Comment\*(Aq );
.Ve
.IP "\fIeocdOffset()\fR" 4
.IX Item "eocdOffset()"
Returns the (unexpected) number of bytes between where the
\&\s-1EOCD\s0 was found and where it expected to be. This is normally
0, but would be positive if something (a virus, perhaps) had
added bytes somewhere before the \s-1EOCD\s0. Not used for writing
zips, but might be interesting if you read a zip in. Here is
an example of how you can diagnose this:
.Sp
.Vb 5
\&  my $zip = Archive::Zip\->new(\*(Aqsomefile.zip\*(Aq);
\&  if ($zip\->eocdOffset())
\&  {
\&    warn "A virus has added ", $zip\->eocdOffset, " bytes of garbage\en";
\&  }
.Ve
.Sp
The \f(CW\*(C`eocdOffset()\*(C'\fR is used to adjust the starting position of member
headers, if necessary.
.IP "\fIfileName()\fR" 4
.IX Item "fileName()"
Returns the name of the file last read from. If nothing has
been read yet, returns an empty string; if read from a file
handle, returns the handle in string form.
.SS "Zip Archive Member Operations"
.IX Subsection "Zip Archive Member Operations"
Various operations on a zip file modify members. When a member is
passed as an argument, you can either use a reference to the member
itself, or the name of a member. Of course, using the name requires
that names be unique within a zip (this is not enforced).
.ie n .IP "removeMember( $memberOrName )" 4
.el .IP "removeMember( \f(CW$memberOrName\fR )" 4
.IX Item "removeMember( $memberOrName )"
Remove and return the given member, or match its name and
remove it. Returns undef if member or name doesn't exist in this
Zip. No-op if member does not belong to this zip.
.ie n .IP "replaceMember( $memberOrName, $newMember )" 4
.el .IP "replaceMember( \f(CW$memberOrName\fR, \f(CW$newMember\fR )" 4
.IX Item "replaceMember( $memberOrName, $newMember )"
Remove and return the given member, or match its name and
remove it. Replace with new member. Returns undef if member or
name doesn't exist in this Zip, or if \f(CW$newMember\fR is undefined.
.Sp
It is an (undiagnosed) error to provide a \f(CW$newMember\fR that is a
member of the zip being modified.
.Sp
.Vb 4
\&    my $member1 = $zip\->removeMember( \*(Aqxyz\*(Aq );
\&    my $member2 = $zip\->replaceMember( \*(Aqabc\*(Aq, $member1 );
\&    # now, $member2 (named \*(Aqabc\*(Aq) is not in $zip,
\&    # and $member1 (named \*(Aqxyz\*(Aq) is, having taken $member2\*(Aqs place.
.Ve
.ie n .IP "extractMember( $memberOrName [, $extractedName ] )" 4
.el .IP "extractMember( \f(CW$memberOrName\fR [, \f(CW$extractedName\fR ] )" 4
.IX Item "extractMember( $memberOrName [, $extractedName ] )"
Extract the given member, or match its name and extract it.
Returns undef if member doesn't exist in this Zip. If
optional second arg is given, use it as the name of the
extracted member. Otherwise, the internal filename of the
member is used as the name of the extracted file or
directory.
If you pass \f(CW$extractedName\fR, it should be in the local file
system's format.
All necessary directories will be created. Returns \f(CW\*(C`AZ_OK\*(C'\fR
on success.
.ie n .IP "extractMemberWithoutPaths( $memberOrName [, $extractedName ] )" 4
.el .IP "extractMemberWithoutPaths( \f(CW$memberOrName\fR [, \f(CW$extractedName\fR ] )" 4
.IX Item "extractMemberWithoutPaths( $memberOrName [, $extractedName ] )"
Extract the given member, or match its name and extract it.
Does not use path information (extracts into the current
directory). Returns undef if member doesn't exist in this
Zip.
If optional second arg is given, use it as the name of the
extracted member (its paths will be deleted too). Otherwise,
the internal filename of the member (minus paths) is used as
the name of the extracted file or directory. Returns \f(CW\*(C`AZ_OK\*(C'\fR
on success.
.ie n .IP "addMember( $member )" 4
.el .IP "addMember( \f(CW$member\fR )" 4
.IX Item "addMember( $member )"
Append a member (possibly from another zip file) to the zip
file. Returns the new member. Generally, you will use
\&\fIaddFile()\fR, \fIaddDirectory()\fR, \fIaddFileOrDirectory()\fR, \fIaddString()\fR,
or \fIread()\fR to add members.
.Sp
.Vb 3
\&    # Move member named \*(Aqabc\*(Aq to end of zip:
\&    my $member = $zip\->removeMember( \*(Aqabc\*(Aq );
\&    $zip\->addMember( $member );
.Ve
.ie n .IP "updateMember( $memberOrName, $fileName )" 4
.el .IP "updateMember( \f(CW$memberOrName\fR, \f(CW$fileName\fR )" 4
.IX Item "updateMember( $memberOrName, $fileName )"
Update a single member from the file or directory named \f(CW$fileName\fR.
Returns the (possibly added or updated) member, if any; \f(CW\*(C`undef\*(C'\fR on
errors.
The comparison is based on \f(CW\*(C`lastModTime()\*(C'\fR and (in the case of a
non-directory) the size of the file.
.ie n .IP "addFile( $fileName [, $newName ] )" 4
.el .IP "addFile( \f(CW$fileName\fR [, \f(CW$newName\fR ] )" 4
.IX Item "addFile( $fileName [, $newName ] )"
Append a member whose data comes from an external file,
returning the member or undef. The member will have its file
name set to the name of the external file, and its
desiredCompressionMethod set to \s-1COMPRESSION_DEFLATED\s0. The
file attributes and last modification time will be set from
the file.
If the name given does not represent a readable plain file or
symbolic link, undef will be returned. \f(CW$fileName\fR must be
in the format required for the local file system.
The optional \f(CW$newName\fR argument sets the internal file name
to something different than the given \f(CW$fileName\fR. \f(CW$newName\fR,
if given, must be in Zip name format (i.e. Unix).
The text mode bit will be set if the contents appears to be
text (as returned by the \f(CW\*(C`\-T\*(C'\fR perl operator).
.Sp
\&\fI\s-1NOTE\s0\fR that you shouldn't (generally) use absolute path names
in zip member names, as this will cause problems with some zip
tools as well as introduce a security hole and make the zip
harder to use.
.ie n .IP "addDirectory( $directoryName [, $fileName ] )" 4
.el .IP "addDirectory( \f(CW$directoryName\fR [, \f(CW$fileName\fR ] )" 4
.IX Item "addDirectory( $directoryName [, $fileName ] )"
Append a member created from the given directory name. The
directory name does not have to name an existing directory.
If the named directory exists, the file modification time and
permissions are set from the existing directory, otherwise
they are set to now and permissive default permissions.
\&\f(CW$directoryName\fR must be in local file system format.
The optional second argument sets the name of the archive
member (which defaults to \f(CW$directoryName\fR). If given, it
must be in Zip (Unix) format.
Returns the new member.
.ie n .IP "addFileOrDirectory( $name [, $newName ] )" 4
.el .IP "addFileOrDirectory( \f(CW$name\fR [, \f(CW$newName\fR ] )" 4
.IX Item "addFileOrDirectory( $name [, $newName ] )"
Append a member from the file or directory named \f(CW$name\fR. If
\&\f(CW$newName\fR is given, use it for the name of the new member.
Will add or remove trailing slashes from \f(CW$newName\fR as needed.
\&\f(CW$name\fR must be in local file system format.
The optional second argument sets the name of the archive
member (which defaults to \f(CW$name\fR). If given, it must be in
Zip (Unix) format.
.ie n .IP "addString( $stringOrStringRef, $name )" 4
.el .IP "addString( \f(CW$stringOrStringRef\fR, \f(CW$name\fR )" 4
.IX Item "addString( $stringOrStringRef, $name )"
Append a member created from the given string or string
reference. The name is given by the second argument.
Returns the new member. The last modification time will be
set to now, and the file attributes will be set to permissive
defaults.
.Sp
.Vb 1
\&    my $member = $zip\->addString( \*(AqThis is a test\*(Aq, \*(Aqtest.txt\*(Aq );
.Ve
.ie n .IP "contents( $memberOrMemberName [, $newContents ] )" 4
.el .IP "contents( \f(CW$memberOrMemberName\fR [, \f(CW$newContents\fR ] )" 4
.IX Item "contents( $memberOrMemberName [, $newContents ] )"
Returns the uncompressed data for a particular member, or
undef.
.Sp
.Vb 1
\&    print "xyz.txt contains " . $zip\->contents( \*(Aqxyz.txt\*(Aq );
.Ve
.Sp
Also can change the contents of a member:
.Sp
.Vb 1
\&    $zip\->contents( \*(Aqxyz.txt\*(Aq, \*(AqThis is the new contents\*(Aq );
.Ve
.Sp
If called expecting an array as the return value, it will include
the status as the second value in the array.
.Sp
.Vb 1
\&    ($content, $status) = $zip\->contents( \*(Aqxyz.txt\*(Aq);
.Ve
.SS "Zip Archive I/O operations"
.IX Subsection "Zip Archive I/O operations"
A Zip archive can be written to a file or file handle, or read from
one.
.ie n .IP "writeToFileNamed( $fileName )" 4
.el .IP "writeToFileNamed( \f(CW$fileName\fR )" 4
.IX Item "writeToFileNamed( $fileName )"
Write a zip archive to named file. Returns \f(CW\*(C`AZ_OK\*(C'\fR on
success.
.Sp
.Vb 2
\&    my $status = $zip\->writeToFileNamed( \*(Aqxx.zip\*(Aq );
\&    die "error somewhere" if $status != AZ_OK;
.Ve
.Sp
Note that if you use the same name as an existing zip file
that you read in, you will clobber ZipFileMembers. So
instead, write to a different file name, then delete the
original.
If you use the \f(CW\*(C`overwrite()\*(C'\fR or \f(CW\*(C`overwriteAs()\*(C'\fR methods, you can
re-write the original zip in this way.
\&\f(CW$fileName\fR should be a valid file name on your system.
.ie n .IP "writeToFileHandle( $fileHandle [, $seekable] )" 4
.el .IP "writeToFileHandle( \f(CW$fileHandle\fR [, \f(CW$seekable\fR] )" 4
.IX Item "writeToFileHandle( $fileHandle [, $seekable] )"
Write a zip archive to a file handle. Return \s-1AZ_OK\s0 on
success. The optional second arg tells whether or not to try
to seek backwards to re-write headers. If not provided, it is
set if the Perl \f(CW\*(C`\-f\*(C'\fR test returns true. This could fail on
some operating systems, though.
.Sp
.Vb 4
\&    my $fh = IO::File\->new( \*(AqsomeFile.zip\*(Aq, \*(Aqw\*(Aq );
\&    unless ( $zip\->writeToFileHandle( $fh ) == AZ_OK ) {
\&        # error handling
\&    }
.Ve
.Sp
If you pass a file handle that is not seekable (like if
you're writing to a pipe or a socket), pass a false second
argument:
.Sp
.Vb 2
\&    my $fh = IO::File\->new( \*(Aq| cat > somefile.zip\*(Aq, \*(Aqw\*(Aq );
\&    $zip\->writeToFileHandle( $fh, 0 );   # fh is not seekable
.Ve
.Sp
If this method fails during the write of a member, that
member and all following it will return false from
\&\f(CW\*(C`wasWritten()\*(C'\fR. See \fIwriteCentralDirectory()\fR for a way to
deal with this.
If you want, you can write data to the file handle before
passing it to \fIwriteToFileHandle()\fR; this could be used (for
instance) for making self-extracting archives. However, this
only works reliably when writing to a real file (as opposed
to \s-1STDOUT\s0 or some other possible non-file).
.Sp
See examples/selfex.pl for how to write a self-extracting
archive.
.ie n .IP "writeCentralDirectory( $fileHandle [, $offset ] )" 4
.el .IP "writeCentralDirectory( \f(CW$fileHandle\fR [, \f(CW$offset\fR ] )" 4
.IX Item "writeCentralDirectory( $fileHandle [, $offset ] )"
Writes the central directory structure to the given file
handle.
.Sp
Returns \s-1AZ_OK\s0 on success. If given an \f(CW$offset\fR, will
seek to that point before writing. This can be used for
recovery in cases where writeToFileHandle or writeToFileNamed
returns an \s-1IO\s0 error because of running out of space on the
destination file.
.Sp
You can truncate the zip by seeking backwards and then writing the
directory:
.Sp
.Vb 10
\&    my $fh = IO::File\->new( \*(AqsomeFile.zip\*(Aq, \*(Aqw\*(Aq );
\&        my $retval = $zip\->writeToFileHandle( $fh );
\&    if ( $retval == AZ_IO_ERROR ) {
\&        my @unwritten = grep { not $_\->wasWritten() } $zip\->members();
\&        if (@unwritten) {
\&            $zip\->removeMember( $member ) foreach my $member ( @unwritten );
\&            $zip\->writeCentralDirectory( $fh,
\&            $unwritten[0]\->writeLocalHeaderRelativeOffset());
\&        }
\&    }
.Ve
.ie n .IP "overwriteAs( $newName )" 4
.el .IP "overwriteAs( \f(CW$newName\fR )" 4
.IX Item "overwriteAs( $newName )"
Write the zip to the specified file, as safely as possible.
This is done by first writing to a temp file, then renaming
the original if it exists, then renaming the temp file, then
deleting the renamed original if it exists. Returns \s-1AZ_OK\s0 if
successful.
.IP "\fIoverwrite()\fR" 4
.IX Item "overwrite()"
Write back to the original zip file. See \fIoverwriteAs()\fR above.
If the zip was not ever read from a file, this generates an
error.
.ie n .IP "read( $fileName )" 4
.el .IP "read( \f(CW$fileName\fR )" 4
.IX Item "read( $fileName )"
Read zipfile headers from a zip file, appending new members.
Returns \f(CW\*(C`AZ_OK\*(C'\fR or error code.
.Sp
.Vb 2
\&    my $zipFile = Archive::Zip\->new();
\&    my $status = $zipFile\->read( \*(Aq/some/FileName.zip\*(Aq );
.Ve
.ie n .IP "readFromFileHandle( $fileHandle, $filename )" 4
.el .IP "readFromFileHandle( \f(CW$fileHandle\fR, \f(CW$filename\fR )" 4
.IX Item "readFromFileHandle( $fileHandle, $filename )"
Read zipfile headers from an already-opened file handle,
appending new members. Does not close the file handle.
Returns \f(CW\*(C`AZ_OK\*(C'\fR or error code. Note that this requires a
seekable file handle; reading from a stream is not yet
supported.
.Sp
.Vb 5
\&    my $fh = IO::File\->new( \*(Aq/some/FileName.zip\*(Aq, \*(Aqr\*(Aq );
\&    my $zip1 = Archive::Zip\->new();
\&    my $status = $zip1\->readFromFileHandle( $fh );
\&    my $zip2 = Archive::Zip\->new();
\&    $status = $zip2\->readFromFileHandle( $fh );
.Ve
.SS "Zip Archive Tree operations"
.IX Subsection "Zip Archive Tree operations"
These used to be in Archive::Zip::Tree but got moved into
Archive::Zip. They enable operation on an entire tree of members or
files.
A usage example:
.PP
.Vb 2
\&  use Archive::Zip;
\&  my $zip = Archive::Zip\->new();
\&  
\&  # add all readable files and directories below . as xyz/*
\&  $zip\->addTree( \*(Aq.\*(Aq, \*(Aqxyz\*(Aq );
\&  
\&  # add all readable plain files below /abc as def/*
\&  $zip\->addTree( \*(Aq/abc\*(Aq, \*(Aqdef\*(Aq, sub { \-f && \-r } );
\&  
\&  # add all .c files below /tmp as stuff/*
\&  $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.c$\*(Aq );
\&  
\&  # add all .o files below /tmp as stuff/* if they aren\*(Aqt writable
\&  $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { ! \-w } );
\&  
\&  # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
\&  $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { \-s < 200 } );
\&  
\&  # and write them into a file
\&  $zip\->writeToFileNamed(\*(Aqxxx.zip\*(Aq);
\&  
\&  # now extract the same files into /tmpx
\&  $zip\->extractTree( \*(Aqstuff\*(Aq, \*(Aq/tmpx\*(Aq );
.Ve
.ie n .IP "$zip\->addTree( $root, $dest [,$pred] ) \*(-- Add tree of files to a zip" 4
.el .IP "\f(CW$zip\fR\->addTree( \f(CW$root\fR, \f(CW$dest\fR [,$pred] ) \*(-- Add tree of files to a zip" 4
.IX Item "$zip->addTree( $root, $dest [,$pred] )  Add tree of files to a zip"
\&\f(CW$root\fR is the root of the tree of files and directories to be
added. It is a valid directory name on your system. \f(CW$dest\fR is
the name for the root in the zip file (undef or blank means
to use relative pathnames). It is a valid \s-1ZIP\s0 directory name
(that is, it uses forward slashes (/) for separating
directory components). \f(CW$pred\fR is an optional subroutine
reference to select files: it is passed the name of the
prospective file or directory using \f(CW$_\fR, and if it returns
true, the file or directory will be included. The default is
to add all readable files and directories. For instance,
using
.Sp
.Vb 2
\&  my $pred = sub { /\e.txt/ };
\&  $zip\->addTree( \*(Aq.\*(Aq, \*(Aq\*(Aq, $pred );
.Ve
.Sp
will add all the .txt files in and below the current
directory, using relative names, and making the names
identical in the zipfile:
.Sp
.Vb 4
\&  original name           zip member name
\&  ./xyz                   xyz
\&  ./a/                    a/
\&  ./a/b                   a/b
.Ve
.Sp
To translate absolute to relative pathnames, just pass them
in: \f(CW$zip\fR\->addTree( '/c/d', 'a' );
.Sp
.Vb 4
\&  original name           zip member name
\&  /c/d/xyz                a/xyz
\&  /c/d/a/                 a/a/
\&  /c/d/a/b                a/a/b
.Ve
.Sp
Returns \s-1AZ_OK\s0 on success. Note that this will not follow
symbolic links to directories. Note also that this does not
check for the validity of filenames.
.Sp
Note that you generally \fIdon't\fR want to make zip archive member names
absolute.
.ie n .IP "$zip\->addTreeMatching( $root, $dest, $pattern [,$pred] )" 4
.el .IP "\f(CW$zip\fR\->addTreeMatching( \f(CW$root\fR, \f(CW$dest\fR, \f(CW$pattern\fR [,$pred] )" 4
.IX Item "$zip->addTreeMatching( $root, $dest, $pattern [,$pred] )"
\&\f(CW$root\fR is the root of the tree of files and directories to be
added \f(CW$dest\fR is the name for the root in the zip file (undef
means to use relative pathnames) \f(CW$pattern\fR is a (non-anchored)
regular expression for filenames to match \f(CW$pred\fR is an
optional subroutine reference to select files: it is passed
the name of the prospective file or directory in \f(CW$_\fR, and
if it returns true, the file or directory will be included.
The default is to add all readable files and directories. To
add all files in and below the current dirctory whose names
end in \f(CW\*(C`.pl\*(C'\fR, and make them extract into a subdirectory
named \f(CW\*(C`xyz\*(C'\fR, do this:
.Sp
.Vb 1
\&  $zip\->addTreeMatching( \*(Aq.\*(Aq, \*(Aqxyz\*(Aq, \*(Aq\e.pl$\*(Aq )
.Ve
.Sp
To add all \fIwritable\fR files in and below the dirctory named
\&\f(CW\*(C`/abc\*(C'\fR whose names end in \f(CW\*(C`.pl\*(C'\fR, and make them extract into
a subdirectory named \f(CW\*(C`xyz\*(C'\fR, do this:
.Sp
.Vb 1
\&  $zip\->addTreeMatching( \*(Aq/abc\*(Aq, \*(Aqxyz\*(Aq, \*(Aq\e.pl$\*(Aq, sub { \-w } )
.Ve
.Sp
Returns \s-1AZ_OK\s0 on success. Note that this will not follow
symbolic links to directories.
.ie n .IP "$zip\->updateTree( $root, [ $dest, [ $pred [, $mirror]]] );" 4
.el .IP "\f(CW$zip\fR\->updateTree( \f(CW$root\fR, [ \f(CW$dest\fR, [ \f(CW$pred\fR [, \f(CW$mirror\fR]]] );" 4
.IX Item "$zip->updateTree( $root, [ $dest, [ $pred [, $mirror]]] );"
Update a zip file from a directory tree.
.Sp
\&\f(CW\*(C`updateTree()\*(C'\fR takes the same arguments as \f(CW\*(C`addTree()\*(C'\fR, but first
checks to see whether the file or directory already exists in the zip
file, and whether it has been changed.
.Sp
If the fourth argument \f(CW$mirror\fR is true, then delete all my members
if corresponding files weren't found.
.Sp
Returns an error code or \s-1AZ_OK\s0 if all is well.
.ie n .IP "$zip\->\fIextractTree()\fR" 4
.el .IP "\f(CW$zip\fR\->\fIextractTree()\fR" 4
.IX Item "$zip->extractTree()"
.PD 0
.ie n .IP "$zip\->extractTree( $root )" 4
.el .IP "\f(CW$zip\fR\->extractTree( \f(CW$root\fR )" 4
.IX Item "$zip->extractTree( $root )"
.ie n .IP "$zip\->extractTree( $root, $dest )" 4
.el .IP "\f(CW$zip\fR\->extractTree( \f(CW$root\fR, \f(CW$dest\fR )" 4
.IX Item "$zip->extractTree( $root, $dest )"
.ie n .IP "$zip\->extractTree( $root, $dest, $volume )" 4
.el .IP "\f(CW$zip\fR\->extractTree( \f(CW$root\fR, \f(CW$dest\fR, \f(CW$volume\fR )" 4
.IX Item "$zip->extractTree( $root, $dest, $volume )"
.PD
If you don't give any arguments at all, will extract all the
files in the zip with their original names.
.Sp
If you supply one argument for \f(CW$root\fR, \f(CW\*(C`extractTree\*(C'\fR will extract
all the members whose names start with \f(CW$root\fR into the current
directory, stripping off \f(CW$root\fR first.
\&\f(CW$root\fR is in Zip (Unix) format.
For instance,
.Sp
.Vb 1
\&  $zip\->extractTree( \*(Aqa\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x as ./x
.Sp
a/b/c as ./b/c
.Sp
If you give two arguments, \f(CW\*(C`extractTree\*(C'\fR extracts all the members
whose names start with \f(CW$root\fR. It will translate \f(CW$root\fR into
\&\f(CW$dest\fR to construct the destination file name.
\&\f(CW$root\fR and \f(CW$dest\fR are in Zip (Unix) format.
For instance,
.Sp
.Vb 1
\&   $zip\->extractTree( \*(Aqa\*(Aq, \*(Aqd/e\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x to d/e/x
.Sp
a/b/c to d/e/b/c and ignore ax/d/e and d/e
.Sp
If you give three arguments, \f(CW\*(C`extractTree\*(C'\fR extracts all the members
whose names start with \f(CW$root\fR. It will translate \f(CW$root\fR into
\&\f(CW$dest\fR to construct the destination file name, and then it will
convert to local file system format, using \f(CW$volume\fR as the name of
the destination volume.
.Sp
\&\f(CW$root\fR and \f(CW$dest\fR are in Zip (Unix) format.
.Sp
\&\f(CW$volume\fR is in local file system format.
.Sp
For instance, under Windows,
.Sp
.Vb 1
\&   $zip\->extractTree( \*(Aqa\*(Aq, \*(Aqd/e\*(Aq, \*(Aqf:\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x to f:d/e/x
.Sp
a/b/c to f:d/e/b/c and ignore ax/d/e and d/e
.Sp
If you want absolute paths (the prior example used paths relative to
the current directory on the destination volume, you can specify these
in \f(CW$dest\fR:
.Sp
.Vb 1
\&   $zip\->extractTree( \*(Aqa\*(Aq, \*(Aq/d/e\*(Aq, \*(Aqf:\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x to f:\ed\ee\ex
.Sp
a/b/c to f:\ed\ee\eb\ec and ignore ax/d/e and d/e
.Sp
Returns an error code or \s-1AZ_OK\s0 if everything worked \s-1OK\s0.
.SH "MEMBER OPERATIONS"
.IX Header "MEMBER OPERATIONS"
.SS "Member Class Methods"
.IX Subsection "Member Class Methods"
Several constructors allow you to construct members without adding
them to a zip archive. These work the same as the \fIaddFile()\fR,
\&\fIaddDirectory()\fR, and \fIaddString()\fR zip instance methods described above,
but they don't add the new members to a zip.
.ie n .IP "Archive::Zip::Member\->newFromString( $stringOrStringRef [, $fileName] )" 4
.el .IP "Archive::Zip::Member\->newFromString( \f(CW$stringOrStringRef\fR [, \f(CW$fileName\fR] )" 4
.IX Item "Archive::Zip::Member->newFromString( $stringOrStringRef [, $fileName] )"
Construct a new member from the given string. Returns undef
on error.
.Sp
.Vb 2
\&    my $member = Archive::Zip::Member\->newFromString( \*(AqThis is a test\*(Aq,
\&                                                 \*(Aqxyz.txt\*(Aq );
.Ve
.ie n .IP "newFromFile( $fileName )" 4
.el .IP "newFromFile( \f(CW$fileName\fR )" 4
.IX Item "newFromFile( $fileName )"
Construct a new member from the given file. Returns undef on
error.
.Sp
.Vb 1
\&    my $member = Archive::Zip::Member\->newFromFile( \*(Aqxyz.txt\*(Aq );
.Ve
.ie n .IP "newDirectoryNamed( $directoryName [, $zipname ] )" 4
.el .IP "newDirectoryNamed( \f(CW$directoryName\fR [, \f(CW$zipname\fR ] )" 4
.IX Item "newDirectoryNamed( $directoryName [, $zipname ] )"
Construct a new member from the given directory.
\&\f(CW$directoryName\fR must be a valid name on your file system; it doesn't
have to exist.
.Sp
If given, \f(CW$zipname\fR will be the name of the zip member; it must be a
valid Zip (Unix) name. If not given, it will be converted from
\&\f(CW$directoryName\fR.
.Sp
Returns undef on error.
.Sp
.Vb 1
\&    my $member = Archive::Zip::Member\->newDirectoryNamed( \*(AqCVS/\*(Aq );
.Ve
.SS "Member Simple accessors"
.IX Subsection "Member Simple accessors"
These methods get (and/or set) member attribute values.
.IP "\fIversionMadeBy()\fR" 4
.IX Item "versionMadeBy()"
Gets the field from the member header.
.IP "fileAttributeFormat( [$format] )" 4
.IX Item "fileAttributeFormat( [$format] )"
Gets or sets the field from the member header. These are
\&\f(CW\*(C`FA_*\*(C'\fR values.
.IP "\fIversionNeededToExtract()\fR" 4
.IX Item "versionNeededToExtract()"
Gets the field from the member header.
.IP "\fIbitFlag()\fR" 4
.IX Item "bitFlag()"
Gets the general purpose bit field from the member header.
This is where the \f(CW\*(C`GPBF_*\*(C'\fR bits live.
.IP "\fIcompressionMethod()\fR" 4
.IX Item "compressionMethod()"
Returns the member compression method. This is the method
that is currently being used to compress the member data.
This will be \s-1COMPRESSION_STORED\s0 for added string or file
members, or any of the \f(CW\*(C`COMPRESSION_*\*(C'\fR values for members
from a zip file. However, this module can only handle members
whose data is in \s-1COMPRESSION_STORED\s0 or \s-1COMPRESSION_DEFLATED\s0
format.
.IP "desiredCompressionMethod( [$method] )" 4
.IX Item "desiredCompressionMethod( [$method] )"
Get or set the member's \f(CW\*(C`desiredCompressionMethod\*(C'\fR. This is
the compression method that will be used when the member is
written. Returns prior desiredCompressionMethod. Only
\&\s-1COMPRESSION_DEFLATED\s0 or \s-1COMPRESSION_STORED\s0 are valid
arguments. Changing to \s-1COMPRESSION_STORED\s0 will change the
member desiredCompressionLevel to 0; changing to
\&\s-1COMPRESSION_DEFLATED\s0 will change the member
desiredCompressionLevel to \s-1COMPRESSION_LEVEL_DEFAULT\s0.
.IP "desiredCompressionLevel( [$method] )" 4
.IX Item "desiredCompressionLevel( [$method] )"
Get or set the member's desiredCompressionLevel This is the
method that will be used to write. Returns prior
desiredCompressionLevel. Valid arguments are 0 through 9,
\&\s-1COMPRESSION_LEVEL_NONE\s0, \s-1COMPRESSION_LEVEL_DEFAULT\s0,
\&\s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0, and
\&\s-1COMPRESSION_LEVEL_FASTEST\s0. 0 or \s-1COMPRESSION_LEVEL_NONE\s0 will
change the desiredCompressionMethod to \s-1COMPRESSION_STORED\s0.
All other arguments will change the desiredCompressionMethod
to \s-1COMPRESSION_DEFLATED\s0.
.IP "\fIexternalFileName()\fR" 4
.IX Item "externalFileName()"
Return the member's external file name, if any, or undef.
.IP "\fIfileName()\fR" 4
.IX Item "fileName()"
Get or set the member's internal filename. Returns the
(possibly new) filename. Names will have backslashes
converted to forward slashes, and will have multiple
consecutive slashes converted to single ones.
.IP "\fIlastModFileDateTime()\fR" 4
.IX Item "lastModFileDateTime()"
Return the member's last modification date/time stamp in
MS-DOS format.
.IP "\fIlastModTime()\fR" 4
.IX Item "lastModTime()"
Return the member's last modification date/time stamp,
converted to unix localtime format.
.Sp
.Vb 1
\&    print "Mod Time: " . scalar( localtime( $member\->lastModTime() ) );
.Ve
.IP "\fIsetLastModFileDateTimeFromUnix()\fR" 4
.IX Item "setLastModFileDateTimeFromUnix()"
Set the member's lastModFileDateTime from the given unix
time.
.Sp
.Vb 1
\&    $member\->setLastModFileDateTimeFromUnix( time() );
.Ve
.IP "\fIinternalFileAttributes()\fR" 4
.IX Item "internalFileAttributes()"
Return the internal file attributes field from the zip
header. This is only set for members read from a zip file.
.IP "\fIexternalFileAttributes()\fR" 4
.IX Item "externalFileAttributes()"
Return member attributes as read from the \s-1ZIP\s0 file. Note that
these are \s-1NOT\s0 \s-1UNIX\s0!
.IP "unixFileAttributes( [$newAttributes] )" 4
.IX Item "unixFileAttributes( [$newAttributes] )"
Get or set the member's file attributes using \s-1UNIX\s0 file
attributes. Returns old attributes.
.Sp
.Vb 1
\&    my $oldAttribs = $member\->unixFileAttributes( 0666 );
.Ve
.Sp
Note that the return value has more than just the file
permissions, so you will have to mask off the lowest bits for
comparisions.
.IP "localExtraField( [$newField] )" 4
.IX Item "localExtraField( [$newField] )"
Gets or sets the extra field that was read from the local
header. This is not set for a member from a zip file until
after the member has been written out. The extra field must
be in the proper format.
.IP "cdExtraField( [$newField] )" 4
.IX Item "cdExtraField( [$newField] )"
Gets or sets the extra field that was read from the central
directory header. The extra field must be in the proper
format.
.IP "\fIextraFields()\fR" 4
.IX Item "extraFields()"
Return both local and \s-1CD\s0 extra fields, concatenated.
.IP "fileComment( [$newComment] )" 4
.IX Item "fileComment( [$newComment] )"
Get or set the member's file comment.
.IP "\fIhasDataDescriptor()\fR" 4
.IX Item "hasDataDescriptor()"
Get or set the data descriptor flag. If this is set, the
local header will not necessarily have the correct data
sizes. Instead, a small structure will be stored at the end
of the member data with these values. This should be
transparent in normal operation.
.IP "\fIcrc32()\fR" 4
.IX Item "crc32()"
Return the \s-1CRC\-32\s0 value for this member. This will not be set
for members that were constructed from strings or external
files until after the member has been written.
.IP "\fIcrc32String()\fR" 4
.IX Item "crc32String()"
Return the \s-1CRC\-32\s0 value for this member as an 8 character
printable hex string. This will not be set for members that
were constructed from strings or external files until after
the member has been written.
.IP "\fIcompressedSize()\fR" 4
.IX Item "compressedSize()"
Return the compressed size for this member. This will not be
set for members that were constructed from strings or
external files until after the member has been written.
.IP "\fIuncompressedSize()\fR" 4
.IX Item "uncompressedSize()"
Return the uncompressed size for this member.
.IP "\fIisEncrypted()\fR" 4
.IX Item "isEncrypted()"
Return true if this member is encrypted. The Archive::Zip
module does not currently create or extract encrypted
members.
.IP "isTextFile( [$flag] )" 4
.IX Item "isTextFile( [$flag] )"
Returns true if I am a text file. Also can set the status if
given an argument (then returns old state). Note that this
module does not currently do anything with this flag upon
extraction or storage. That is, bytes are stored in native
format whether or not they came from a text file.
.IP "\fIisBinaryFile()\fR" 4
.IX Item "isBinaryFile()"
Returns true if I am a binary file. Also can set the status
if given an argument (then returns old state). Note that this
module does not currently do anything with this flag upon
extraction or storage. That is, bytes are stored in native
format whether or not they came from a text file.
.ie n .IP "extractToFileNamed( $fileName )" 4
.el .IP "extractToFileNamed( \f(CW$fileName\fR )" 4
.IX Item "extractToFileNamed( $fileName )"
Extract me to a file with the given name. The file will be
created with default modes. Directories will be created as
needed.
The \f(CW$fileName\fR argument should be a valid file name on your
file system.
Returns \s-1AZ_OK\s0 on success.
.IP "\fIisDirectory()\fR" 4
.IX Item "isDirectory()"
Returns true if I am a directory.
.IP "\fIwriteLocalHeaderRelativeOffset()\fR" 4
.IX Item "writeLocalHeaderRelativeOffset()"
Returns the file offset in bytes the last time I was written.
.IP "\fIwasWritten()\fR" 4
.IX Item "wasWritten()"
Returns true if I was successfully written. Reset at the
beginning of a write attempt.
.SS "Low-level member data reading"
.IX Subsection "Low-level member data reading"
It is possible to use lower-level routines to access member data
streams, rather than the extract* methods and \fIcontents()\fR. For
instance, here is how to print the uncompressed contents of a member
in chunks using these methods:
.PP
.Vb 10
\&    my ( $member, $status, $bufferRef );
\&    $member = $zip\->memberNamed( \*(Aqxyz.txt\*(Aq );
\&    $member\->desiredCompressionMethod( COMPRESSION_STORED );
\&    $status = $member\->rewindData();
\&    die "error $status" unless $status == AZ_OK;
\&    while ( ! $member\->readIsDone() )
\&    {
\&    ( $bufferRef, $status ) = $member\->readChunk();
\&    die "error $status"
\&                if $status != AZ_OK && $status != AZ_STREAM_END;
\&    # do something with $bufferRef:
\&    print $$bufferRef;
\&    }
\&    $member\->endRead();
.Ve
.IP "readChunk( [$chunkSize] )" 4
.IX Item "readChunk( [$chunkSize] )"
This reads the next chunk of given size from the member's
data stream and compresses or uncompresses it as necessary,
returning a reference to the bytes read and a status. If size
argument is not given, defaults to global set by
Archive::Zip::setChunkSize. Status is \s-1AZ_OK\s0 on success until
the last chunk, where it returns \s-1AZ_STREAM_END\s0. Returns \f(CW\*(C`(
\&\e$bytes, $status)\*(C'\fR.
.Sp
.Vb 2
\&    my ( $outRef, $status ) = $self\->readChunk();
\&    print $$outRef if $status != AZ_OK && $status != AZ_STREAM_END;
.Ve
.IP "\fIrewindData()\fR" 4
.IX Item "rewindData()"
Rewind data and set up for reading data streams or writing
zip files. Can take options for \f(CW\*(C`inflateInit()\*(C'\fR or
\&\f(CW\*(C`deflateInit()\*(C'\fR, but this isn't likely to be necessary.
Subclass overrides should call this method. Returns \f(CW\*(C`AZ_OK\*(C'\fR
on success.
.IP "\fIendRead()\fR" 4
.IX Item "endRead()"
Reset the read variables and free the inflater or deflater.
Must be called to close files, etc. Returns \s-1AZ_OK\s0 on success.
.IP "\fIreadIsDone()\fR" 4
.IX Item "readIsDone()"
Return true if the read has run out of data or errored out.
.IP "\fIcontents()\fR" 4
.IX Item "contents()"
Return the entire uncompressed member data or undef in scalar
context. When called in array context, returns \f(CW\*(C`( $string,
$status )\*(C'\fR; status will be \s-1AZ_OK\s0 on success:
.Sp
.Vb 4
\&    my $string = $member\->contents();
\&    # or
\&    my ( $string, $status ) = $member\->contents();
\&    die "error $status" unless $status == AZ_OK;
.Ve
.Sp
Can also be used to set the contents of a member (this may
change the class of the member):
.Sp
.Vb 1
\&    $member\->contents( "this is my new contents" );
.Ve
.ie n .IP "extractToFileHandle( $fh )" 4
.el .IP "extractToFileHandle( \f(CW$fh\fR )" 4
.IX Item "extractToFileHandle( $fh )"
Extract (and uncompress, if necessary) the member's contents
to the given file handle. Return \s-1AZ_OK\s0 on success.
.SH "Archive::Zip::FileMember methods"
.IX Header "Archive::Zip::FileMember methods"
The Archive::Zip::FileMember class extends Archive::Zip::Member. It is the
base class for both ZipFileMember and NewFileMember classes. This class adds
an \f(CW\*(C`externalFileName\*(C'\fR and an \f(CW\*(C`fh\*(C'\fR member to keep track of the external
file.
.IP "\fIexternalFileName()\fR" 4
.IX Item "externalFileName()"
Return the member's external filename.
.IP "\fIfh()\fR" 4
.IX Item "fh()"
Return the member's read file handle. Automatically opens file if
necessary.
.SH "Archive::Zip::ZipFileMember methods"
.IX Header "Archive::Zip::ZipFileMember methods"
The Archive::Zip::ZipFileMember class represents members that have been read
from external zip files.
.IP "\fIdiskNumberStart()\fR" 4
.IX Item "diskNumberStart()"
Returns the disk number that the member's local header resides in.
Should be 0.
.IP "\fIlocalHeaderRelativeOffset()\fR" 4
.IX Item "localHeaderRelativeOffset()"
Returns the offset into the zip file where the member's local header
is.
.IP "\fIdataOffset()\fR" 4
.IX Item "dataOffset()"
Returns the offset from the beginning of the zip file to the member's
data.
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
Archive::Zip requires several other modules:
.PP
Carp
.PP
Compress::Raw::Zlib
.PP
Cwd
.PP
File::Basename
.PP
File::Copy
.PP
File::Find
.PP
File::Path
.PP
File::Spec
.PP
IO::File
.PP
IO::Seekable
.PP
Time::Local
.SH "BUGS AND CAVEATS"
.IX Header "BUGS AND CAVEATS"
.SS "When not to use Archive::Zip"
.IX Subsection "When not to use Archive::Zip"
If you are just going to be extracting zips (and/or other archives) you
are recommended to look at using Archive::Extract instead, as it is much
easier to use and factors out archive-specific functionality.
.SS "Try to avoid IO::Scalar"
.IX Subsection "Try to avoid IO::Scalar"
One of the most common ways to use Archive::Zip is to generate Zip files
in-memory. Most people have use IO::Scalar for this purpose.
.PP
Unfortunately, as of 1.11 this module no longer works with IO::Scalar
as it incorrectly implements seeking.
.PP
Anybody using IO::Scalar should consider porting to IO::String,
which is smaller, lighter, and is implemented to be perfectly compatible
with regular seekable filehandles.
.PP
Support for IO::Scalar most likely will \fBnot\fR be restored in the
future, as IO::Scalar itself cannot change the way it is implemented
due to back-compatibility issues.
.SH "TO DO"
.IX Header "TO DO"
* auto-choosing storing vs compression
.PP
* extra field hooks (see notes.txt)
.PP
* check for dups on addition/renaming?
.PP
* Text file extraction (line end translation)
.PP
* Reading zip files from non-seekable inputs
  (Perhaps by proxying through IO::String?)
.PP
* separate unused constants into separate module
.PP
* cookbook style docs
.PP
* Handle tainted paths correctly
.PP
* Work on better compatability with other \s-1IO::\s0 modules
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be reported via the \s-1CPAN\s0 bug tracker
.PP
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive\-Zip <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive-Zip>
.PP
For other issues contact the maintainer
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.PP
Previously maintained by Steve Peters <steve@fisharerojo.org>.
.PP
File attributes code by Maurice Aubrey <maurice@lovelyfilth.com>.
.PP
Originally by Ned Konz <nedkonz@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Some parts copyright 2006 \- 2009 Adam Kennedy.
.PP
Some parts copyright 2005 Steve Peters.
.PP
Original work copyright 2000 \- 2004 Ned Konz.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Look at Archive::Zip::MemberRead which is a wrapper that allows one to
read Zip archive members as if they were files.
.PP
Compress::Raw::Zlib, Archive::Tar, Archive::Extract
.PP
There is a Japanese translation of this
document at http://www.memb.jp/~deq/perl/doc\-ja/Archive\-Zip.html <http://www.memb.jp/~deq/perl/doc-ja/Archive-Zip.html>
that was done by \s-1DEQ\s0 <deq@oct.zaq.ne.jp> . Thanks!
                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip5.18.3pm                         0100644 0001750 0001750 00000214161 12566241430 024045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip 3"
.TH Archive::Zip 3 "2014-01-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip \- Provide an interface to ZIP archive files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   # Create a Zip file
\&   use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
\&   my $zip = Archive::Zip\->new();
\&
\&   # Add a directory
\&   my $dir_member = $zip\->addDirectory( \*(Aqdirname/\*(Aq );
\&
\&   # Add a file from a string with compression
\&   my $string_member = $zip\->addString( \*(AqThis is a test\*(Aq, \*(AqstringMember.txt\*(Aq );
\&   $string_member\->desiredCompressionMethod( COMPRESSION_DEFLATED );
\&
\&   # Add a file from disk
\&   my $file_member = $zip\->addFile( \*(Aqxyz.pl\*(Aq, \*(AqAnotherName.pl\*(Aq );
\&
\&   # Save the Zip file
\&   unless ( $zip\->writeToFileNamed(\*(AqsomeZip.zip\*(Aq) == AZ_OK ) {
\&       die \*(Aqwrite error\*(Aq;
\&   }
\&
\&   # Read a Zip file
\&   my $somezip = Archive::Zip\->new();
\&   unless ( $somezip\->read( \*(AqsomeZip.zip\*(Aq ) == AZ_OK ) {
\&       die \*(Aqread error\*(Aq;
\&   }
\&
\&   # Change the compression type for a file in the Zip
\&   my $member = $somezip\->memberNamed( \*(AqstringMember.txt\*(Aq );
\&   $member\->desiredCompressionMethod( COMPRESSION_STORED );
\&   unless ( $zip\->writeToFileNamed( \*(AqsomeOtherZip.zip\*(Aq ) == AZ_OK ) {
\&       die \*(Aqwrite error\*(Aq;
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Archive::Zip module allows a Perl program to create, manipulate, read,
and write Zip archive files.
.PP
Zip archives can be created, or you can read from existing zip files.
.PP
Once created, they can be written to files, streams, or strings. Members
can be added, removed, extracted, replaced, rearranged, and enumerated.
They can also be renamed or have their dates, comments, or other attributes
queried or modified. Their data can be compressed or uncompressed as needed.
.PP
Members can be created from members in existing Zip files, or from existing
directories, files, or strings.
.PP
This module uses the Compress::Raw::Zlib library to read and write the
compressed streams inside the files.
.PP
One can use Archive::Zip::MemberRead to read the zip file archive members
as if they were files.
.SS "File Naming"
.IX Subsection "File Naming"
Regardless of what your local file system uses for file naming, names in a
Zip file are in Unix format (\fIforward\fR slashes (/) separating directory
names, etc.).
.PP
\&\f(CW\*(C`Archive::Zip\*(C'\fR tries to be consistent with file naming conventions, and will
translate back and forth between native and Zip file names.
.PP
However, it can't guess which format names are in. So two rules control what
kind of file name you must pass various routines:
.IP "Names of files are in local format." 4
.IX Item "Names of files are in local format."
\&\f(CW\*(C`File::Spec\*(C'\fR and \f(CW\*(C`File::Basename\*(C'\fR are used for various file
operations. When you're referring to a file on your system, use its
file naming conventions.
.IP "Names of archive members are in Unix format." 4
.IX Item "Names of archive members are in Unix format."
This applies to every method that refers to an archive member, or
provides a name for new archive members. The \f(CW\*(C`extract()\*(C'\fR methods
that can take one or two names will convert from local to zip names
if you call them with a single name.
.SS "Archive::Zip Object Model"
.IX Subsection "Archive::Zip Object Model"
\fIOverview\fR
.IX Subsection "Overview"
.PP
Archive::Zip::Archive objects are what you ordinarily deal with.
These maintain the structure of a zip file, without necessarily
holding data. When a zip is read from a disk file, the (possibly
compressed) data still lives in the file, not in memory. Archive
members hold information about the individual members, but not
(usually) the actual member data. When the zip is written to a
(different) file, the member data is compressed or copied as needed.
It is possible to make archive members whose data is held in a string
in memory, but this is not done when a zip file is read. Directory
members don't have any data.
.SS "Inheritance"
.IX Subsection "Inheritance"
.Vb 9
\&  Exporter
\&   Archive::Zip                            Common base class, has defs.
\&       Archive::Zip::Archive               A Zip archive.
\&       Archive::Zip::Member                Abstract superclass for all members.
\&           Archive::Zip::StringMember      Member made from a string
\&           Archive::Zip::FileMember        Member made from an external file
\&               Archive::Zip::ZipFileMember Member that lives in a zip file
\&               Archive::Zip::NewFileMember Member whose data is in a file
\&           Archive::Zip::DirectoryMember   Member that is a directory
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
.IP ":CONSTANTS" 4
.IX Item ":CONSTANTS"
Exports the following constants:
.Sp
\&\s-1FA_MSDOS FA_UNIX GPBF_ENCRYPTED_MASK
GPBF_DEFLATING_COMPRESSION_MASK GPBF_HAS_DATA_DESCRIPTOR_MASK
COMPRESSION_STORED COMPRESSION_DEFLATED IFA_TEXT_FILE_MASK
IFA_TEXT_FILE IFA_BINARY_FILE COMPRESSION_LEVEL_NONE
COMPRESSION_LEVEL_DEFAULT COMPRESSION_LEVEL_FASTEST
COMPRESSION_LEVEL_BEST_COMPRESSION\s0
.IP ":MISC_CONSTANTS" 4
.IX Item ":MISC_CONSTANTS"
Exports the following constants (only necessary for extending the
module):
.Sp
\&\s-1FA_AMIGA FA_VAX_VMS FA_VM_CMS FA_ATARI_ST FA_OS2_HPFS
FA_MACINTOSH FA_Z_SYSTEM FA_CPM FA_WINDOWS_NTFS
GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK
GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK
GPBF_IS_COMPRESSED_PATCHED_DATA_MASK COMPRESSION_SHRUNK
DEFLATING_COMPRESSION_NORMAL DEFLATING_COMPRESSION_MAXIMUM
DEFLATING_COMPRESSION_FAST DEFLATING_COMPRESSION_SUPER_FAST
COMPRESSION_REDUCED_1 COMPRESSION_REDUCED_2 COMPRESSION_REDUCED_3
COMPRESSION_REDUCED_4 COMPRESSION_IMPLODED COMPRESSION_TOKENIZED
COMPRESSION_DEFLATED_ENHANCED
COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED\s0
.IP ":ERROR_CODES" 4
.IX Item ":ERROR_CODES"
Explained below. Returned from most methods.
.Sp
\&\s-1AZ_OK AZ_STREAM_END AZ_ERROR AZ_FORMAT_ERROR AZ_IO_ERROR\s0
.SH "ERROR CODES"
.IX Header "ERROR CODES"
Many of the methods in Archive::Zip return error codes. These are implemented
as inline subroutines, using the \f(CW\*(C`use constant\*(C'\fR pragma. They can be imported
into your namespace using the \f(CW\*(C`:ERROR_CODES\*(C'\fR tag:
.PP
.Vb 1
\&  use Archive::Zip qw( :ERROR_CODES );
\&
\&  ...
\&
\&  unless ( $zip\->read( \*(Aqmyfile.zip\*(Aq ) == AZ_OK ) {
\&      die "whoops!";
\&  }
.Ve
.IP "\s-1AZ_OK \\fIs0\fR\|(0)" 4
.IX Item "AZ_OK f(ISs0"
Everything is fine.
.IP "\s-1AZ_STREAM_END \\fIs0\fR\|(1)" 4
.IX Item "AZ_STREAM_END f(ISs0"
The read stream (or central directory) ended normally.
.IP "\s-1AZ_ERROR \\fIs0\fR\|(2)" 4
.IX Item "AZ_ERROR f(ISs0"
There was some generic kind of error.
.IP "\s-1AZ_FORMAT_ERROR \\fIs0\fR\|(3)" 4
.IX Item "AZ_FORMAT_ERROR f(ISs0"
There is a format error in a \s-1ZIP\s0 file being read.
.IP "\s-1AZ_IO_ERROR \\fIs0\fR\|(4)" 4
.IX Item "AZ_IO_ERROR f(ISs0"
There was an \s-1IO\s0 error.
.SS "Compression"
.IX Subsection "Compression"
Archive::Zip allows each member of a \s-1ZIP\s0 file to be compressed (using the
Deflate algorithm) or uncompressed.
.PP
Other compression algorithms that some versions of \s-1ZIP\s0 have been able to
produce are not supported. Each member has two compression methods: the
one it's stored as (this is always \s-1COMPRESSION_STORED\s0 for string and external
file members), and the one you desire for the member in the zip file.
.PP
These can be different, of course, so you can make a zip member that is not
compressed out of one that is, and vice versa.
.PP
You can inquire about the current compression and set the desired
compression method:
.PP
.Vb 2
\&  my $member = $zip\->memberNamed( \*(Aqxyz.txt\*(Aq );
\&  $member\->compressionMethod();    # return current compression
\&
\&  # set to read uncompressed
\&  $member\->desiredCompressionMethod( COMPRESSION_STORED );
\&
\&  # set to read compressed
\&  $member\->desiredCompressionMethod( COMPRESSION_DEFLATED );
.Ve
.PP
There are two different compression methods:
.IP "\s-1COMPRESSION_STORED\s0" 4
.IX Item "COMPRESSION_STORED"
File is stored (no compression)
.IP "\s-1COMPRESSION_DEFLATED\s0" 4
.IX Item "COMPRESSION_DEFLATED"
File is Deflated
.SS "Compression Levels"
.IX Subsection "Compression Levels"
If a member's desiredCompressionMethod is \s-1COMPRESSION_DEFLATED,\s0 you
can choose different compression levels. This choice may affect the
speed of compression and decompression, as well as the size of the
compressed member data.
.PP
.Vb 1
\&  $member\->desiredCompressionLevel( 9 );
.Ve
.PP
The levels given can be:
.IP "\(bu" 4
0 or \s-1COMPRESSION_LEVEL_NONE\s0
.Sp
This is the same as saying
.Sp
.Vb 1
\&  $member\->desiredCompressionMethod( COMPRESSION_STORED );
.Ve
.IP "\(bu" 4
1 .. 9
.Sp
1 gives the best speed and worst compression, and 9 gives the
best compression and worst speed.
.IP "\(bu" 4
\&\s-1COMPRESSION_LEVEL_FASTEST\s0
.Sp
This is a synonym for level 1.
.IP "\(bu" 4
\&\s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0
.Sp
This is a synonym for level 9.
.IP "\(bu" 4
\&\s-1COMPRESSION_LEVEL_DEFAULT\s0
.Sp
This gives a good compromise between speed and compression,
and is currently equivalent to 6 (this is in the zlib code).
This is the level that will be used if not specified.
.SH "Archive::Zip Methods"
.IX Header "Archive::Zip Methods"
The Archive::Zip class (and its invisible subclass Archive::Zip::Archive)
implement generic zip file functionality. Creating a new Archive::Zip object
actually makes an Archive::Zip::Archive object, but you don't have to worry
about this unless you're subclassing.
.SS "Constructor"
.IX Subsection "Constructor"
.IP "new( [$fileName] )" 4
.IX Item "new( [$fileName] )"
.PD 0
.ie n .IP "new( { filename => $fileName } )" 4
.el .IP "new( { filename => \f(CW$fileName\fR } )" 4
.IX Item "new( { filename => $fileName } )"
.PD
Make a new, empty zip archive.
.Sp
.Vb 1
\&    my $zip = Archive::Zip\->new();
.Ve
.Sp
If an additional argument is passed, \fInew()\fR will call \fIread()\fR
to read the contents of an archive:
.Sp
.Vb 1
\&    my $zip = Archive::Zip\->new( \*(Aqxyz.zip\*(Aq );
.Ve
.Sp
If a filename argument is passed and the read fails for any
reason, new will return undef. For this reason, it may be
better to call read separately.
.SS "Zip Archive Utility Methods"
.IX Subsection "Zip Archive Utility Methods"
These Archive::Zip methods may be called as functions or as object
methods. Do not call them as class methods:
.PP
.Vb 4
\&    $zip = Archive::Zip\->new();
\&    $crc = Archive::Zip::computeCRC32( \*(Aqghijkl\*(Aq );    # OK
\&    $crc = $zip\->computeCRC32( \*(Aqghijkl\*(Aq );            # also OK
\&    $crc = Archive::Zip\->computeCRC32( \*(Aqghijkl\*(Aq );    # NOT OK
.Ve
.ie n .IP "Archive::Zip::computeCRC32( $string [, $crc] )" 4
.el .IP "Archive::Zip::computeCRC32( \f(CW$string\fR [, \f(CW$crc\fR] )" 4
.IX Item "Archive::Zip::computeCRC32( $string [, $crc] )"
.PD 0
.ie n .IP "Archive::Zip::computeCRC32( { string => $string [, checksum => $crc ] } )" 4
.el .IP "Archive::Zip::computeCRC32( { string => \f(CW$string\fR [, checksum => \f(CW$crc\fR ] } )" 4
.IX Item "Archive::Zip::computeCRC32( { string => $string [, checksum => $crc ] } )"
.PD
This is a utility function that uses the Compress::Raw::Zlib \s-1CRC\s0
routine to compute a \s-1CRC\-32.\s0 You can get the \s-1CRC\s0 of a string:
.Sp
.Vb 1
\&    $crc = Archive::Zip::computeCRC32( $string );
.Ve
.Sp
Or you can compute the running \s-1CRC:\s0
.Sp
.Vb 3
\&    $crc = 0;
\&    $crc = Archive::Zip::computeCRC32( \*(Aqabcdef\*(Aq, $crc );
\&    $crc = Archive::Zip::computeCRC32( \*(Aqghijkl\*(Aq, $crc );
.Ve
.ie n .IP "Archive::Zip::setChunkSize( $number )" 4
.el .IP "Archive::Zip::setChunkSize( \f(CW$number\fR )" 4
.IX Item "Archive::Zip::setChunkSize( $number )"
.PD 0
.ie n .IP "Archive::Zip::setChunkSize( { chunkSize => $number } )" 4
.el .IP "Archive::Zip::setChunkSize( { chunkSize => \f(CW$number\fR } )" 4
.IX Item "Archive::Zip::setChunkSize( { chunkSize => $number } )"
.PD
Report or change chunk size used for reading and writing.
This can make big differences in dealing with large files.
Currently, this defaults to 32K. This also changes the chunk
size used for Compress::Raw::Zlib. You must call \fIsetChunkSize()\fR
before reading or writing. This is not exportable, so you
must call it like:
.Sp
.Vb 1
\&    Archive::Zip::setChunkSize( 4096 );
.Ve
.Sp
or as a method on a zip (though this is a global setting).
Returns old chunk size.
.IP "\fIArchive::Zip::chunkSize()\fR" 4
.IX Item "Archive::Zip::chunkSize()"
Returns the current chunk size:
.Sp
.Vb 1
\&    my $chunkSize = Archive::Zip::chunkSize();
.Ve
.IP "Archive::Zip::setErrorHandler( \e&subroutine )" 4
.IX Item "Archive::Zip::setErrorHandler( &subroutine )"
.PD 0
.IP "Archive::Zip::setErrorHandler( { subroutine => \e&subroutine } )" 4
.IX Item "Archive::Zip::setErrorHandler( { subroutine => &subroutine } )"
.PD
Change the subroutine called with error strings. This
defaults to \e&Carp::carp, but you may want to change it to
get the error strings. This is not exportable, so you must
call it like:
.Sp
.Vb 1
\&    Archive::Zip::setErrorHandler( \e&myErrorHandler );
.Ve
.Sp
If myErrorHandler is undef, resets handler to default.
Returns old error handler. Note that if you call Carp::carp
or a similar routine or if you're chaining to the default
error handler from your error handler, you may want to
increment the number of caller levels that are skipped (do
not just set it to a number):
.Sp
.Vb 1
\&    $Carp::CarpLevel++;
.Ve
.ie n .IP "Archive::Zip::tempFile( [ $tmpdir ] )" 4
.el .IP "Archive::Zip::tempFile( [ \f(CW$tmpdir\fR ] )" 4
.IX Item "Archive::Zip::tempFile( [ $tmpdir ] )"
.PD 0
.ie n .IP "Archive::Zip::tempFile( { tempDir => $tmpdir } )" 4
.el .IP "Archive::Zip::tempFile( { tempDir => \f(CW$tmpdir\fR } )" 4
.IX Item "Archive::Zip::tempFile( { tempDir => $tmpdir } )"
.PD
Create a uniquely named temp file. It will be returned open
for read/write. If \f(CW$tmpdir\fR is given, it is used as the
name of a directory to create the file in. If not given,
creates the file using \f(CW\*(C`File::Spec::tmpdir()\*(C'\fR. Generally, you can
override this choice using the
.Sp
.Vb 1
\&    $ENV{TMPDIR}
.Ve
.Sp
environment variable. But see the File::Spec
documentation for your system. Note that on many systems, if you're
running in taint mode, then you must make sure that \f(CW$ENV{TMPDIR}\fR is
untainted for it to be used.
Will \fI\s-1NOT\s0\fR create \f(CW$tmpdir\fR if it does not exist (this is a change
from prior versions!). Returns file handle and name:
.Sp
.Vb 3
\&    my ($fh, $name) = Archive::Zip::tempFile();
\&    my ($fh, $name) = Archive::Zip::tempFile(\*(AqmyTempDir\*(Aq);
\&    my $fh = Archive::Zip::tempFile();  # if you don\*(Aqt need the name
.Ve
.SS "Zip Archive Accessors"
.IX Subsection "Zip Archive Accessors"
.IP "\fImembers()\fR" 4
.IX Item "members()"
Return a copy of the members array
.Sp
.Vb 1
\&    my @members = $zip\->members();
.Ve
.IP "\fInumberOfMembers()\fR" 4
.IX Item "numberOfMembers()"
Return the number of members I have
.IP "\fImemberNames()\fR" 4
.IX Item "memberNames()"
Return a list of the (internal) file names of the zip members
.ie n .IP "memberNamed( $string )" 4
.el .IP "memberNamed( \f(CW$string\fR )" 4
.IX Item "memberNamed( $string )"
.PD 0
.ie n .IP "memberNamed( { zipName => $string } )" 4
.el .IP "memberNamed( { zipName => \f(CW$string\fR } )" 4
.IX Item "memberNamed( { zipName => $string } )"
.PD
Return ref to member whose filename equals given filename or
undef. \f(CW$string\fR must be in Zip (Unix) filename format.
.ie n .IP "membersMatching( $regex )" 4
.el .IP "membersMatching( \f(CW$regex\fR )" 4
.IX Item "membersMatching( $regex )"
.PD 0
.ie n .IP "membersMatching( { regex => $regex } )" 4
.el .IP "membersMatching( { regex => \f(CW$regex\fR } )" 4
.IX Item "membersMatching( { regex => $regex } )"
.PD
Return array of members whose filenames match given regular
expression in list context. Returns number of matching
members in scalar context.
.Sp
.Vb 3
\&    my @textFileMembers = $zip\->membersMatching( \*(Aq.*\e.txt\*(Aq );
\&    # or
\&    my $numberOfTextFiles = $zip\->membersMatching( \*(Aq.*\e.txt\*(Aq );
.Ve
.IP "\fIdiskNumber()\fR" 4
.IX Item "diskNumber()"
Return the disk that I start on. Not used for writing zips,
but might be interesting if you read a zip in. This should be
0, as Archive::Zip does not handle multi-volume archives.
.IP "\fIdiskNumberWithStartOfCentralDirectory()\fR" 4
.IX Item "diskNumberWithStartOfCentralDirectory()"
Return the disk number that holds the beginning of the
central directory. Not used for writing zips, but might be
interesting if you read a zip in. This should be 0, as
Archive::Zip does not handle multi-volume archives.
.IP "\fInumberOfCentralDirectoriesOnThisDisk()\fR" 4
.IX Item "numberOfCentralDirectoriesOnThisDisk()"
Return the number of \s-1CD\s0 structures in the zipfile last read in.
Not used for writing zips, but might be interesting if you read a zip
in.
.IP "\fInumberOfCentralDirectories()\fR" 4
.IX Item "numberOfCentralDirectories()"
Return the number of \s-1CD\s0 structures in the zipfile last read in.
Not used for writing zips, but might be interesting if you read a zip
in.
.IP "\fIcentralDirectorySize()\fR" 4
.IX Item "centralDirectorySize()"
Returns central directory size, as read from an external zip
file. Not used for writing zips, but might be interesting if
you read a zip in.
.IP "\fIcentralDirectoryOffsetWRTStartingDiskNumber()\fR" 4
.IX Item "centralDirectoryOffsetWRTStartingDiskNumber()"
Returns the offset into the zip file where the \s-1CD\s0 begins. Not
used for writing zips, but might be interesting if you read a
zip in.
.ie n .IP "zipfileComment( [ $string ] )" 4
.el .IP "zipfileComment( [ \f(CW$string\fR ] )" 4
.IX Item "zipfileComment( [ $string ] )"
.PD 0
.ie n .IP "zipfileComment( [ { comment => $string } ] )" 4
.el .IP "zipfileComment( [ { comment => \f(CW$string\fR } ] )" 4
.IX Item "zipfileComment( [ { comment => $string } ] )"
.PD
Get or set the zipfile comment. Returns the old comment.
.Sp
.Vb 2
\&    print $zip\->zipfileComment();
\&    $zip\->zipfileComment( \*(AqNew Comment\*(Aq );
.Ve
.IP "\fIeocdOffset()\fR" 4
.IX Item "eocdOffset()"
Returns the (unexpected) number of bytes between where the
\&\s-1EOCD\s0 was found and where it expected to be. This is normally
0, but would be positive if something (a virus, perhaps) had
added bytes somewhere before the \s-1EOCD.\s0 Not used for writing
zips, but might be interesting if you read a zip in. Here is
an example of how you can diagnose this:
.Sp
.Vb 5
\&  my $zip = Archive::Zip\->new(\*(Aqsomefile.zip\*(Aq);
\&  if ($zip\->eocdOffset())
\&  {
\&    warn "A virus has added ", $zip\->eocdOffset, " bytes of garbage\en";
\&  }
.Ve
.Sp
The \f(CW\*(C`eocdOffset()\*(C'\fR is used to adjust the starting position of member
headers, if necessary.
.IP "\fIfileName()\fR" 4
.IX Item "fileName()"
Returns the name of the file last read from. If nothing has
been read yet, returns an empty string; if read from a file
handle, returns the handle in string form.
.SS "Zip Archive Member Operations"
.IX Subsection "Zip Archive Member Operations"
Various operations on a zip file modify members. When a member is
passed as an argument, you can either use a reference to the member
itself, or the name of a member. Of course, using the name requires
that names be unique within a zip (this is not enforced).
.ie n .IP "removeMember( $memberOrName )" 4
.el .IP "removeMember( \f(CW$memberOrName\fR )" 4
.IX Item "removeMember( $memberOrName )"
.PD 0
.ie n .IP "removeMember( { memberOrZipName => $memberOrName } )" 4
.el .IP "removeMember( { memberOrZipName => \f(CW$memberOrName\fR } )" 4
.IX Item "removeMember( { memberOrZipName => $memberOrName } )"
.PD
Remove and return the given member, or match its name and
remove it. Returns undef if member or name does not exist in this
Zip. No-op if member does not belong to this zip.
.ie n .IP "replaceMember( $memberOrName, $newMember )" 4
.el .IP "replaceMember( \f(CW$memberOrName\fR, \f(CW$newMember\fR )" 4
.IX Item "replaceMember( $memberOrName, $newMember )"
.PD 0
.ie n .IP "replaceMember( { memberOrZipName => $memberOrName, newMember => $newMember } )" 4
.el .IP "replaceMember( { memberOrZipName => \f(CW$memberOrName\fR, newMember => \f(CW$newMember\fR } )" 4
.IX Item "replaceMember( { memberOrZipName => $memberOrName, newMember => $newMember } )"
.PD
Remove and return the given member, or match its name and
remove it. Replace with new member. Returns undef if member or
name does not exist in this Zip, or if \f(CW$newMember\fR is undefined.
.Sp
It is an (undiagnosed) error to provide a \f(CW$newMember\fR that is a
member of the zip being modified.
.Sp
.Vb 4
\&    my $member1 = $zip\->removeMember( \*(Aqxyz\*(Aq );
\&    my $member2 = $zip\->replaceMember( \*(Aqabc\*(Aq, $member1 );
\&    # now, $member2 (named \*(Aqabc\*(Aq) is not in $zip,
\&    # and $member1 (named \*(Aqxyz\*(Aq) is, having taken $member2\*(Aqs place.
.Ve
.ie n .IP "extractMember( $memberOrName [, $extractedName ] )" 4
.el .IP "extractMember( \f(CW$memberOrName\fR [, \f(CW$extractedName\fR ] )" 4
.IX Item "extractMember( $memberOrName [, $extractedName ] )"
.PD 0
.ie n .IP "extractMember( { memberOrZipName => $memberOrName [, name => $extractedName ] } )" 4
.el .IP "extractMember( { memberOrZipName => \f(CW$memberOrName\fR [, name => \f(CW$extractedName\fR ] } )" 4
.IX Item "extractMember( { memberOrZipName => $memberOrName [, name => $extractedName ] } )"
.PD
Extract the given member, or match its name and extract it.
Returns undef if member does not exist in this Zip. If
optional second arg is given, use it as the name of the
extracted member. Otherwise, the internal filename of the
member is used as the name of the extracted file or
directory.
If you pass \f(CW$extractedName\fR, it should be in the local file
system's format.
All necessary directories will be created. Returns \f(CW\*(C`AZ_OK\*(C'\fR
on success.
.ie n .IP "extractMemberWithoutPaths( $memberOrName [, $extractedName ] )" 4
.el .IP "extractMemberWithoutPaths( \f(CW$memberOrName\fR [, \f(CW$extractedName\fR ] )" 4
.IX Item "extractMemberWithoutPaths( $memberOrName [, $extractedName ] )"
.PD 0
.ie n .IP "extractMemberWithoutPaths( { memberOrZipName => $memberOrName [, name => $extractedName ] } )" 4
.el .IP "extractMemberWithoutPaths( { memberOrZipName => \f(CW$memberOrName\fR [, name => \f(CW$extractedName\fR ] } )" 4
.IX Item "extractMemberWithoutPaths( { memberOrZipName => $memberOrName [, name => $extractedName ] } )"
.PD
Extract the given member, or match its name and extract it.
Does not use path information (extracts into the current
directory). Returns undef if member does not exist in this
Zip.
If optional second arg is given, use it as the name of the
extracted member (its paths will be deleted too). Otherwise,
the internal filename of the member (minus paths) is used as
the name of the extracted file or directory. Returns \f(CW\*(C`AZ_OK\*(C'\fR
on success.
.ie n .IP "addMember( $member )" 4
.el .IP "addMember( \f(CW$member\fR )" 4
.IX Item "addMember( $member )"
.PD 0
.ie n .IP "addMember( { member => $member } )" 4
.el .IP "addMember( { member => \f(CW$member\fR } )" 4
.IX Item "addMember( { member => $member } )"
.PD
Append a member (possibly from another zip file) to the zip
file. Returns the new member. Generally, you will use
\&\fIaddFile()\fR, \fIaddDirectory()\fR, \fIaddFileOrDirectory()\fR, \fIaddString()\fR,
or \fIread()\fR to add members.
.Sp
.Vb 3
\&    # Move member named \*(Aqabc\*(Aq to end of zip:
\&    my $member = $zip\->removeMember( \*(Aqabc\*(Aq );
\&    $zip\->addMember( $member );
.Ve
.ie n .IP "updateMember( $memberOrName, $fileName )" 4
.el .IP "updateMember( \f(CW$memberOrName\fR, \f(CW$fileName\fR )" 4
.IX Item "updateMember( $memberOrName, $fileName )"
.PD 0
.ie n .IP "updateMember( { memberOrZipName => $memberOrName, name => $fileName } )" 4
.el .IP "updateMember( { memberOrZipName => \f(CW$memberOrName\fR, name => \f(CW$fileName\fR } )" 4
.IX Item "updateMember( { memberOrZipName => $memberOrName, name => $fileName } )"
.PD
Update a single member from the file or directory named \f(CW$fileName\fR.
Returns the (possibly added or updated) member, if any; \f(CW\*(C`undef\*(C'\fR on
errors.
The comparison is based on \f(CW\*(C`lastModTime()\*(C'\fR and (in the case of a
non-directory) the size of the file.
.ie n .IP "addFile( $fileName [, $newName, $compressionLevel ] )" 4
.el .IP "addFile( \f(CW$fileName\fR [, \f(CW$newName\fR, \f(CW$compressionLevel\fR ] )" 4
.IX Item "addFile( $fileName [, $newName, $compressionLevel ] )"
.PD 0
.ie n .IP "addFile( { filename => $fileName [, zipName => $newName, compressionLevel => $compressionLevel } ] )" 4
.el .IP "addFile( { filename => \f(CW$fileName\fR [, zipName => \f(CW$newName\fR, compressionLevel => \f(CW$compressionLevel\fR } ] )" 4
.IX Item "addFile( { filename => $fileName [, zipName => $newName, compressionLevel => $compressionLevel } ] )"
.PD
Append a member whose data comes from an external file,
returning the member or undef. The member will have its file
name set to the name of the external file, and its
desiredCompressionMethod set to \s-1COMPRESSION_DEFLATED.\s0 The
file attributes and last modification time will be set from
the file.
If the name given does not represent a readable plain file or
symbolic link, undef will be returned. \f(CW$fileName\fR must be
in the format required for the local file system.
The optional \f(CW$newName\fR argument sets the internal file name
to something different than the given \f(CW$fileName\fR. \f(CW$newName\fR,
if given, must be in Zip name format (i.e. Unix).
The text mode bit will be set if the contents appears to be
text (as returned by the \f(CW\*(C`\-T\*(C'\fR perl operator).
.Sp
\&\fI\s-1NOTE\s0\fR that you should not (generally) use absolute path names
in zip member names, as this will cause problems with some zip
tools as well as introduce a security hole and make the zip
harder to use.
.ie n .IP "addDirectory( $directoryName [, $fileName ] )" 4
.el .IP "addDirectory( \f(CW$directoryName\fR [, \f(CW$fileName\fR ] )" 4
.IX Item "addDirectory( $directoryName [, $fileName ] )"
.PD 0
.ie n .IP "addDirectory( { directoryName => $directoryName [, zipName => $fileName ] } )" 4
.el .IP "addDirectory( { directoryName => \f(CW$directoryName\fR [, zipName => \f(CW$fileName\fR ] } )" 4
.IX Item "addDirectory( { directoryName => $directoryName [, zipName => $fileName ] } )"
.PD
Append a member created from the given directory name. The
directory name does not have to name an existing directory.
If the named directory exists, the file modification time and
permissions are set from the existing directory, otherwise
they are set to now and permissive default permissions.
\&\f(CW$directoryName\fR must be in local file system format.
The optional second argument sets the name of the archive
member (which defaults to \f(CW$directoryName\fR). If given, it
must be in Zip (Unix) format.
Returns the new member.
.ie n .IP "addFileOrDirectory( $name [, $newName, $compressionLevel ] )" 4
.el .IP "addFileOrDirectory( \f(CW$name\fR [, \f(CW$newName\fR, \f(CW$compressionLevel\fR ] )" 4
.IX Item "addFileOrDirectory( $name [, $newName, $compressionLevel ] )"
.PD 0
.ie n .IP "addFileOrDirectory( { name => $name [, zipName => $newName, compressionLevel => $compressionLevel ] } )" 4
.el .IP "addFileOrDirectory( { name => \f(CW$name\fR [, zipName => \f(CW$newName\fR, compressionLevel => \f(CW$compressionLevel\fR ] } )" 4
.IX Item "addFileOrDirectory( { name => $name [, zipName => $newName, compressionLevel => $compressionLevel ] } )"
.PD
Append a member from the file or directory named \f(CW$name\fR. If
\&\f(CW$newName\fR is given, use it for the name of the new member.
Will add or remove trailing slashes from \f(CW$newName\fR as needed.
\&\f(CW$name\fR must be in local file system format.
The optional second argument sets the name of the archive
member (which defaults to \f(CW$name\fR). If given, it must be in
Zip (Unix) format.
.ie n .IP "addString( $stringOrStringRef, $name, [$compressionLevel] )" 4
.el .IP "addString( \f(CW$stringOrStringRef\fR, \f(CW$name\fR, [$compressionLevel] )" 4
.IX Item "addString( $stringOrStringRef, $name, [$compressionLevel] )"
.PD 0
.ie n .IP "addString( { string => $stringOrStringRef [, zipName => $name, compressionLevel => $compressionLevel ] } )" 4
.el .IP "addString( { string => \f(CW$stringOrStringRef\fR [, zipName => \f(CW$name\fR, compressionLevel => \f(CW$compressionLevel\fR ] } )" 4
.IX Item "addString( { string => $stringOrStringRef [, zipName => $name, compressionLevel => $compressionLevel ] } )"
.PD
Append a member created from the given string or string
reference. The name is given by the second argument.
Returns the new member. The last modification time will be
set to now, and the file attributes will be set to permissive
defaults.
.Sp
.Vb 1
\&    my $member = $zip\->addString( \*(AqThis is a test\*(Aq, \*(Aqtest.txt\*(Aq );
.Ve
.ie n .IP "contents( $memberOrMemberName [, $newContents ] )" 4
.el .IP "contents( \f(CW$memberOrMemberName\fR [, \f(CW$newContents\fR ] )" 4
.IX Item "contents( $memberOrMemberName [, $newContents ] )"
.PD 0
.ie n .IP "contents( { memberOrZipName => $memberOrMemberName [, contents => $newContents ] } )" 4
.el .IP "contents( { memberOrZipName => \f(CW$memberOrMemberName\fR [, contents => \f(CW$newContents\fR ] } )" 4
.IX Item "contents( { memberOrZipName => $memberOrMemberName [, contents => $newContents ] } )"
.PD
Returns the uncompressed data for a particular member, or
undef.
.Sp
.Vb 1
\&    print "xyz.txt contains " . $zip\->contents( \*(Aqxyz.txt\*(Aq );
.Ve
.Sp
Also can change the contents of a member:
.Sp
.Vb 1
\&    $zip\->contents( \*(Aqxyz.txt\*(Aq, \*(AqThis is the new contents\*(Aq );
.Ve
.Sp
If called expecting an array as the return value, it will include
the status as the second value in the array.
.Sp
.Vb 1
\&    ($content, $status) = $zip\->contents( \*(Aqxyz.txt\*(Aq);
.Ve
.SS "Zip Archive I/O operations"
.IX Subsection "Zip Archive I/O operations"
A Zip archive can be written to a file or file handle, or read from
one.
.ie n .IP "writeToFileNamed( $fileName )" 4
.el .IP "writeToFileNamed( \f(CW$fileName\fR )" 4
.IX Item "writeToFileNamed( $fileName )"
.PD 0
.ie n .IP "writeToFileNamed( { fileName => $fileName } )" 4
.el .IP "writeToFileNamed( { fileName => \f(CW$fileName\fR } )" 4
.IX Item "writeToFileNamed( { fileName => $fileName } )"
.PD
Write a zip archive to named file. Returns \f(CW\*(C`AZ_OK\*(C'\fR on
success.
.Sp
.Vb 2
\&    my $status = $zip\->writeToFileNamed( \*(Aqxx.zip\*(Aq );
\&    die "error somewhere" if $status != AZ_OK;
.Ve
.Sp
Note that if you use the same name as an existing zip file
that you read in, you will clobber ZipFileMembers. So
instead, write to a different file name, then delete the
original.
If you use the \f(CW\*(C`overwrite()\*(C'\fR or \f(CW\*(C`overwriteAs()\*(C'\fR methods, you can
re-write the original zip in this way.
\&\f(CW$fileName\fR should be a valid file name on your system.
.ie n .IP "writeToFileHandle( $fileHandle [, $seekable] )" 4
.el .IP "writeToFileHandle( \f(CW$fileHandle\fR [, \f(CW$seekable\fR] )" 4
.IX Item "writeToFileHandle( $fileHandle [, $seekable] )"
Write a zip archive to a file handle. Return \s-1AZ_OK\s0 on
success. The optional second arg tells whether or not to try
to seek backwards to re-write headers. If not provided, it is
set if the Perl \f(CW\*(C`\-f\*(C'\fR test returns true. This could fail on
some operating systems, though.
.Sp
.Vb 4
\&    my $fh = IO::File\->new( \*(AqsomeFile.zip\*(Aq, \*(Aqw\*(Aq );
\&    unless ( $zip\->writeToFileHandle( $fh ) == AZ_OK ) {
\&        # error handling
\&    }
.Ve
.Sp
If you pass a file handle that is not seekable (like if
you're writing to a pipe or a socket), pass a false second
argument:
.Sp
.Vb 2
\&    my $fh = IO::File\->new( \*(Aq| cat > somefile.zip\*(Aq, \*(Aqw\*(Aq );
\&    $zip\->writeToFileHandle( $fh, 0 );   # fh is not seekable
.Ve
.Sp
If this method fails during the write of a member, that
member and all following it will return false from
\&\f(CW\*(C`wasWritten()\*(C'\fR. See \fIwriteCentralDirectory()\fR for a way to
deal with this.
If you want, you can write data to the file handle before
passing it to \fIwriteToFileHandle()\fR; this could be used (for
instance) for making self-extracting archives. However, this
only works reliably when writing to a real file (as opposed
to \s-1STDOUT\s0 or some other possible non-file).
.Sp
See examples/selfex.pl for how to write a self-extracting
archive.
.ie n .IP "writeCentralDirectory( $fileHandle [, $offset ] )" 4
.el .IP "writeCentralDirectory( \f(CW$fileHandle\fR [, \f(CW$offset\fR ] )" 4
.IX Item "writeCentralDirectory( $fileHandle [, $offset ] )"
.PD 0
.ie n .IP "writeCentralDirectory( { fileHandle => $fileHandle [, offset => $offset ] } )" 4
.el .IP "writeCentralDirectory( { fileHandle => \f(CW$fileHandle\fR [, offset => \f(CW$offset\fR ] } )" 4
.IX Item "writeCentralDirectory( { fileHandle => $fileHandle [, offset => $offset ] } )"
.PD
Writes the central directory structure to the given file
handle.
.Sp
Returns \s-1AZ_OK\s0 on success. If given an \f(CW$offset\fR, will
seek to that point before writing. This can be used for
recovery in cases where writeToFileHandle or writeToFileNamed
returns an \s-1IO\s0 error because of running out of space on the
destination file.
.Sp
You can truncate the zip by seeking backwards and then writing the
directory:
.Sp
.Vb 10
\&    my $fh = IO::File\->new( \*(AqsomeFile.zip\*(Aq, \*(Aqw\*(Aq );
\&        my $retval = $zip\->writeToFileHandle( $fh );
\&    if ( $retval == AZ_IO_ERROR ) {
\&        my @unwritten = grep { not $_\->wasWritten() } $zip\->members();
\&        if (@unwritten) {
\&            $zip\->removeMember( $member ) foreach my $member ( @unwritten );
\&            $zip\->writeCentralDirectory( $fh,
\&            $unwritten[0]\->writeLocalHeaderRelativeOffset());
\&        }
\&    }
.Ve
.ie n .IP "overwriteAs( $newName )" 4
.el .IP "overwriteAs( \f(CW$newName\fR )" 4
.IX Item "overwriteAs( $newName )"
.PD 0
.ie n .IP "overwriteAs( { filename => $newName } )" 4
.el .IP "overwriteAs( { filename => \f(CW$newName\fR } )" 4
.IX Item "overwriteAs( { filename => $newName } )"
.PD
Write the zip to the specified file, as safely as possible.
This is done by first writing to a temp file, then renaming
the original if it exists, then renaming the temp file, then
deleting the renamed original if it exists. Returns \s-1AZ_OK\s0 if
successful.
.IP "\fIoverwrite()\fR" 4
.IX Item "overwrite()"
Write back to the original zip file. See \fIoverwriteAs()\fR above.
If the zip was not ever read from a file, this generates an
error.
.ie n .IP "read( $fileName )" 4
.el .IP "read( \f(CW$fileName\fR )" 4
.IX Item "read( $fileName )"
.PD 0
.ie n .IP "read( { filename => $fileName } )" 4
.el .IP "read( { filename => \f(CW$fileName\fR } )" 4
.IX Item "read( { filename => $fileName } )"
.PD
Read zipfile headers from a zip file, appending new members.
Returns \f(CW\*(C`AZ_OK\*(C'\fR or error code.
.Sp
.Vb 2
\&    my $zipFile = Archive::Zip\->new();
\&    my $status = $zipFile\->read( \*(Aq/some/FileName.zip\*(Aq );
.Ve
.ie n .IP "readFromFileHandle( $fileHandle, $filename )" 4
.el .IP "readFromFileHandle( \f(CW$fileHandle\fR, \f(CW$filename\fR )" 4
.IX Item "readFromFileHandle( $fileHandle, $filename )"
.PD 0
.ie n .IP "readFromFileHandle( { fileHandle => $fileHandle, filename => $filename } )" 4
.el .IP "readFromFileHandle( { fileHandle => \f(CW$fileHandle\fR, filename => \f(CW$filename\fR } )" 4
.IX Item "readFromFileHandle( { fileHandle => $fileHandle, filename => $filename } )"
.PD
Read zipfile headers from an already-opened file handle,
appending new members. Does not close the file handle.
Returns \f(CW\*(C`AZ_OK\*(C'\fR or error code. Note that this requires a
seekable file handle; reading from a stream is not yet
supported, but using in-memory data is.
.Sp
.Vb 5
\&    my $fh = IO::File\->new( \*(Aq/some/FileName.zip\*(Aq, \*(Aqr\*(Aq );
\&    my $zip1 = Archive::Zip\->new();
\&    my $status = $zip1\->readFromFileHandle( $fh );
\&    my $zip2 = Archive::Zip\->new();
\&    $status = $zip2\->readFromFileHandle( $fh );
.Ve
.Sp
Read zip using in-memory data (recursable):
.Sp
.Vb 5
\&    open my $fh, "<", "archive.zip" or die $!;
\&    my $zip_data = do { local $.; <$fh> };
\&    my $zip = Archive::Zip\->new;
\&    open my $dh, "+<", \e$zip_data;
\&    $zip\->readFromFileHandle ($dh);
.Ve
.SS "Zip Archive Tree operations"
.IX Subsection "Zip Archive Tree operations"
These used to be in Archive::Zip::Tree but got moved into
Archive::Zip. They enable operation on an entire tree of members or
files.
A usage example:
.PP
.Vb 2
\&  use Archive::Zip;
\&  my $zip = Archive::Zip\->new();
\&
\&  # add all readable files and directories below . as xyz/*
\&  $zip\->addTree( \*(Aq.\*(Aq, \*(Aqxyz\*(Aq );
\&
\&  # add all readable plain files below /abc as def/*
\&  $zip\->addTree( \*(Aq/abc\*(Aq, \*(Aqdef\*(Aq, sub { \-f && \-r } );
\&
\&  # add all .c files below /tmp as stuff/*
\&  $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.c$\*(Aq );
\&
\&  # add all .o files below /tmp as stuff/* if they aren\*(Aqt writable
\&  $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { ! \-w } );
\&
\&  # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
\&  $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { \-s < 200 } );
\&
\&  # and write them into a file
\&  $zip\->writeToFileNamed(\*(Aqxxx.zip\*(Aq);
\&
\&  # now extract the same files into /tmpx
\&  $zip\->extractTree( \*(Aqstuff\*(Aq, \*(Aq/tmpx\*(Aq );
.Ve
.ie n .IP "$zip\->addTree( $root, $dest [, $pred, $compressionLevel ] ) \*(-- Add tree of files to a zip" 4
.el .IP "\f(CW$zip\fR\->addTree( \f(CW$root\fR, \f(CW$dest\fR [, \f(CW$pred\fR, \f(CW$compressionLevel\fR ] ) \*(-- Add tree of files to a zip" 4
.IX Item "$zip->addTree( $root, $dest [, $pred, $compressionLevel ] ) Add tree of files to a zip"
.PD 0
.ie n .IP "$zip\->addTree( { root => $root, zipName => $dest [, select => $pred, compressionLevel => $compressionLevel ] )" 4
.el .IP "\f(CW$zip\fR\->addTree( { root => \f(CW$root\fR, zipName => \f(CW$dest\fR [, select => \f(CW$pred\fR, compressionLevel => \f(CW$compressionLevel\fR ] )" 4
.IX Item "$zip->addTree( { root => $root, zipName => $dest [, select => $pred, compressionLevel => $compressionLevel ] )"
.PD
\&\f(CW$root\fR is the root of the tree of files and directories to be
added. It is a valid directory name on your system. \f(CW$dest\fR is
the name for the root in the zip file (undef or blank means
to use relative pathnames). It is a valid \s-1ZIP\s0 directory name
(that is, it uses forward slashes (/) for separating
directory components). \f(CW$pred\fR is an optional subroutine
reference to select files: it is passed the name of the
prospective file or directory using \f(CW$_\fR, and if it returns
true, the file or directory will be included. The default is
to add all readable files and directories. For instance,
using
.Sp
.Vb 2
\&  my $pred = sub { /\e.txt/ };
\&  $zip\->addTree( \*(Aq.\*(Aq, \*(Aq\*(Aq, $pred );
.Ve
.Sp
will add all the .txt files in and below the current
directory, using relative names, and making the names
identical in the zipfile:
.Sp
.Vb 4
\&  original name           zip member name
\&  ./xyz                   xyz
\&  ./a/                    a/
\&  ./a/b                   a/b
.Ve
.Sp
To translate absolute to relative pathnames, just pass them
in: \f(CW$zip\fR\->addTree( '/c/d', 'a' );
.Sp
.Vb 4
\&  original name           zip member name
\&  /c/d/xyz                a/xyz
\&  /c/d/a/                 a/a/
\&  /c/d/a/b                a/a/b
.Ve
.Sp
Returns \s-1AZ_OK\s0 on success. Note that this will not follow
symbolic links to directories. Note also that this does not
check for the validity of filenames.
.Sp
Note that you generally \fIdon't\fR want to make zip archive member names
absolute.
.ie n .IP "$zip\->addTreeMatching( $root, $dest, $pattern [, $pred, $compressionLevel ] )" 4
.el .IP "\f(CW$zip\fR\->addTreeMatching( \f(CW$root\fR, \f(CW$dest\fR, \f(CW$pattern\fR [, \f(CW$pred\fR, \f(CW$compressionLevel\fR ] )" 4
.IX Item "$zip->addTreeMatching( $root, $dest, $pattern [, $pred, $compressionLevel ] )"
.PD 0
.ie n .IP "$zip\->addTreeMatching( { root => $root, zipName => $dest, pattern => $pattern [, select => $pred, compressionLevel => $compressionLevel ] } )" 4
.el .IP "\f(CW$zip\fR\->addTreeMatching( { root => \f(CW$root\fR, zipName => \f(CW$dest\fR, pattern => \f(CW$pattern\fR [, select => \f(CW$pred\fR, compressionLevel => \f(CW$compressionLevel\fR ] } )" 4
.IX Item "$zip->addTreeMatching( { root => $root, zipName => $dest, pattern => $pattern [, select => $pred, compressionLevel => $compressionLevel ] } )"
.PD
\&\f(CW$root\fR is the root of the tree of files and directories to be
added \f(CW$dest\fR is the name for the root in the zip file (undef
means to use relative pathnames) \f(CW$pattern\fR is a (non-anchored)
regular expression for filenames to match \f(CW$pred\fR is an
optional subroutine reference to select files: it is passed
the name of the prospective file or directory in \f(CW$_\fR, and
if it returns true, the file or directory will be included.
The default is to add all readable files and directories. To
add all files in and below the current directory whose names
end in \f(CW\*(C`.pl\*(C'\fR, and make them extract into a subdirectory
named \f(CW\*(C`xyz\*(C'\fR, do this:
.Sp
.Vb 1
\&  $zip\->addTreeMatching( \*(Aq.\*(Aq, \*(Aqxyz\*(Aq, \*(Aq\e.pl$\*(Aq )
.Ve
.Sp
To add all \fIwritable\fR files in and below the directory named
\&\f(CW\*(C`/abc\*(C'\fR whose names end in \f(CW\*(C`.pl\*(C'\fR, and make them extract into
a subdirectory named \f(CW\*(C`xyz\*(C'\fR, do this:
.Sp
.Vb 1
\&  $zip\->addTreeMatching( \*(Aq/abc\*(Aq, \*(Aqxyz\*(Aq, \*(Aq\e.pl$\*(Aq, sub { \-w } )
.Ve
.Sp
Returns \s-1AZ_OK\s0 on success. Note that this will not follow
symbolic links to directories.
.ie n .IP "$zip\->updateTree( $root [, $dest , $pred , $mirror, $compressionLevel ] );" 4
.el .IP "\f(CW$zip\fR\->updateTree( \f(CW$root\fR [, \f(CW$dest\fR , \f(CW$pred\fR , \f(CW$mirror\fR, \f(CW$compressionLevel\fR ] );" 4
.IX Item "$zip->updateTree( $root [, $dest , $pred , $mirror, $compressionLevel ] );"
.PD 0
.ie n .IP "$zip\->updateTree( { root => $root [, zipName => $dest, select => $pred, mirror => $mirror, compressionLevel => $compressionLevel ] } );" 4
.el .IP "\f(CW$zip\fR\->updateTree( { root => \f(CW$root\fR [, zipName => \f(CW$dest\fR, select => \f(CW$pred\fR, mirror => \f(CW$mirror\fR, compressionLevel => \f(CW$compressionLevel\fR ] } );" 4
.IX Item "$zip->updateTree( { root => $root [, zipName => $dest, select => $pred, mirror => $mirror, compressionLevel => $compressionLevel ] } );"
.PD
Update a zip file from a directory tree.
.Sp
\&\f(CW\*(C`updateTree()\*(C'\fR takes the same arguments as \f(CW\*(C`addTree()\*(C'\fR, but first
checks to see whether the file or directory already exists in the zip
file, and whether it has been changed.
.Sp
If the fourth argument \f(CW$mirror\fR is true, then delete all my members
if corresponding files were not found.
.Sp
Returns an error code or \s-1AZ_OK\s0 if all is well.
.ie n .IP "$zip\->extractTree( [ $root, $dest, $volume } ] )" 4
.el .IP "\f(CW$zip\fR\->extractTree( [ \f(CW$root\fR, \f(CW$dest\fR, \f(CW$volume\fR } ] )" 4
.IX Item "$zip->extractTree( [ $root, $dest, $volume } ] )"
.PD 0
.ie n .IP "$zip\->extractTree( [ { root => $root, zipName => $dest, volume => $volume } ] )" 4
.el .IP "\f(CW$zip\fR\->extractTree( [ { root => \f(CW$root\fR, zipName => \f(CW$dest\fR, volume => \f(CW$volume\fR } ] )" 4
.IX Item "$zip->extractTree( [ { root => $root, zipName => $dest, volume => $volume } ] )"
.PD
If you don't give any arguments at all, will extract all the
files in the zip with their original names.
.Sp
If you supply one argument for \f(CW$root\fR, \f(CW\*(C`extractTree\*(C'\fR will extract
all the members whose names start with \f(CW$root\fR into the current
directory, stripping off \f(CW$root\fR first.
\&\f(CW$root\fR is in Zip (Unix) format.
For instance,
.Sp
.Vb 1
\&  $zip\->extractTree( \*(Aqa\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x as ./x
.Sp
a/b/c as ./b/c
.Sp
If you give two arguments, \f(CW\*(C`extractTree\*(C'\fR extracts all the members
whose names start with \f(CW$root\fR. It will translate \f(CW$root\fR into
\&\f(CW$dest\fR to construct the destination file name.
\&\f(CW$root\fR and \f(CW$dest\fR are in Zip (Unix) format.
For instance,
.Sp
.Vb 1
\&   $zip\->extractTree( \*(Aqa\*(Aq, \*(Aqd/e\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x to d/e/x
.Sp
a/b/c to d/e/b/c and ignore ax/d/e and d/e
.Sp
If you give three arguments, \f(CW\*(C`extractTree\*(C'\fR extracts all the members
whose names start with \f(CW$root\fR. It will translate \f(CW$root\fR into
\&\f(CW$dest\fR to construct the destination file name, and then it will
convert to local file system format, using \f(CW$volume\fR as the name of
the destination volume.
.Sp
\&\f(CW$root\fR and \f(CW$dest\fR are in Zip (Unix) format.
.Sp
\&\f(CW$volume\fR is in local file system format.
.Sp
For instance, under Windows,
.Sp
.Vb 1
\&   $zip\->extractTree( \*(Aqa\*(Aq, \*(Aqd/e\*(Aq, \*(Aqf:\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x to f:d/e/x
.Sp
a/b/c to f:d/e/b/c and ignore ax/d/e and d/e
.Sp
If you want absolute paths (the prior example used paths relative to
the current directory on the destination volume, you can specify these
in \f(CW$dest\fR:
.Sp
.Vb 1
\&   $zip\->extractTree( \*(Aqa\*(Aq, \*(Aq/d/e\*(Aq, \*(Aqf:\*(Aq );
.Ve
.Sp
when applied to a zip containing the files:
a/x a/b/c ax/d/e d/e will extract:
.Sp
a/x to f:\ed\ee\ex
.Sp
a/b/c to f:\ed\ee\eb\ec and ignore ax/d/e and d/e
.Sp
Returns an error code or \s-1AZ_OK\s0 if everything worked \s-1OK.\s0
.SH "Archive::Zip Global Variables"
.IX Header "Archive::Zip Global Variables"
.ie n .IP "$Archive::Zip::UNICODE" 4
.el .IP "\f(CW$Archive::Zip::UNICODE\fR" 4
.IX Item "$Archive::Zip::UNICODE"
This variable governs how Unicode file and directory names are added
to or extracted from an archive. If set, file and directory names are considered
to be \s-1UTF\-8\s0 encoded. This is \fI\s-1EXPERIMENTAL AND BUGGY \s0(there are some edge cases
on Win32)\fR. Please report problems.
.Sp
.Vb 4
\&    {
\&        local $Archive::Zip::UNICODE = 1;
\&        $zip\->addFile(\*(AqDe\*'ja\*` vu.txt\*(Aq);
\&    }
.Ve
.SH "MEMBER OPERATIONS"
.IX Header "MEMBER OPERATIONS"
.SS "Member Class Methods"
.IX Subsection "Member Class Methods"
Several constructors allow you to construct members without adding
them to a zip archive. These work the same as the \fIaddFile()\fR,
\&\fIaddDirectory()\fR, and \fIaddString()\fR zip instance methods described above,
but they don't add the new members to a zip.
.ie n .IP "Archive::Zip::Member\->newFromString( $stringOrStringRef [, $fileName ] )" 4
.el .IP "Archive::Zip::Member\->newFromString( \f(CW$stringOrStringRef\fR [, \f(CW$fileName\fR ] )" 4
.IX Item "Archive::Zip::Member->newFromString( $stringOrStringRef [, $fileName ] )"
.PD 0
.ie n .IP "Archive::Zip::Member\->newFromString( { string => $stringOrStringRef [, zipName => $fileName ] )" 4
.el .IP "Archive::Zip::Member\->newFromString( { string => \f(CW$stringOrStringRef\fR [, zipName => \f(CW$fileName\fR ] )" 4
.IX Item "Archive::Zip::Member->newFromString( { string => $stringOrStringRef [, zipName => $fileName ] )"
.PD
Construct a new member from the given string. Returns undef
on error.
.Sp
.Vb 1
\&    my $member = Archive::Zip::Member\->newFromString( \*(AqThis is a test\*(Aq,
.Ve
.ie n .IP "newFromFile( $fileName [, $zipName ] )" 4
.el .IP "newFromFile( \f(CW$fileName\fR [, \f(CW$zipName\fR ] )" 4
.IX Item "newFromFile( $fileName [, $zipName ] )"
.PD 0
.ie n .IP "newFromFile( { filename => $fileName [, zipName => $zipName ] } )" 4
.el .IP "newFromFile( { filename => \f(CW$fileName\fR [, zipName => \f(CW$zipName\fR ] } )" 4
.IX Item "newFromFile( { filename => $fileName [, zipName => $zipName ] } )"
.PD
Construct a new member from the given file. Returns undef on
error.
.Sp
.Vb 1
\&    my $member = Archive::Zip::Member\->newFromFile( \*(Aqxyz.txt\*(Aq );
.Ve
.ie n .IP "newDirectoryNamed( $directoryName [, $zipname ] )" 4
.el .IP "newDirectoryNamed( \f(CW$directoryName\fR [, \f(CW$zipname\fR ] )" 4
.IX Item "newDirectoryNamed( $directoryName [, $zipname ] )"
.PD 0
.ie n .IP "newDirectoryNamed( { directoryName => $directoryName [, zipName => $zipname ] } )" 4
.el .IP "newDirectoryNamed( { directoryName => \f(CW$directoryName\fR [, zipName => \f(CW$zipname\fR ] } )" 4
.IX Item "newDirectoryNamed( { directoryName => $directoryName [, zipName => $zipname ] } )"
.PD
Construct a new member from the given directory.
\&\f(CW$directoryName\fR must be a valid name on your file system; it does not
have to exist.
.Sp
If given, \f(CW$zipname\fR will be the name of the zip member; it must be a
valid Zip (Unix) name. If not given, it will be converted from
\&\f(CW$directoryName\fR.
.Sp
Returns undef on error.
.Sp
.Vb 1
\&    my $member = Archive::Zip::Member\->newDirectoryNamed( \*(AqCVS/\*(Aq );
.Ve
.SS "Member Simple accessors"
.IX Subsection "Member Simple accessors"
These methods get (and/or set) member attribute values.
.IP "\fIversionMadeBy()\fR" 4
.IX Item "versionMadeBy()"
Gets the field from the member header.
.ie n .IP "fileAttributeFormat( [ $format ] )" 4
.el .IP "fileAttributeFormat( [ \f(CW$format\fR ] )" 4
.IX Item "fileAttributeFormat( [ $format ] )"
.PD 0
.ie n .IP "fileAttributeFormat( [ { format => $format ] } )" 4
.el .IP "fileAttributeFormat( [ { format => \f(CW$format\fR ] } )" 4
.IX Item "fileAttributeFormat( [ { format => $format ] } )"
.PD
Gets or sets the field from the member header. These are
\&\f(CW\*(C`FA_*\*(C'\fR values.
.IP "\fIversionNeededToExtract()\fR" 4
.IX Item "versionNeededToExtract()"
Gets the field from the member header.
.IP "\fIbitFlag()\fR" 4
.IX Item "bitFlag()"
Gets the general purpose bit field from the member header.
This is where the \f(CW\*(C`GPBF_*\*(C'\fR bits live.
.IP "\fIcompressionMethod()\fR" 4
.IX Item "compressionMethod()"
Returns the member compression method. This is the method
that is currently being used to compress the member data.
This will be \s-1COMPRESSION_STORED\s0 for added string or file
members, or any of the \f(CW\*(C`COMPRESSION_*\*(C'\fR values for members
from a zip file. However, this module can only handle members
whose data is in \s-1COMPRESSION_STORED\s0 or \s-1COMPRESSION_DEFLATED\s0
format.
.ie n .IP "desiredCompressionMethod( [ $method ] )" 4
.el .IP "desiredCompressionMethod( [ \f(CW$method\fR ] )" 4
.IX Item "desiredCompressionMethod( [ $method ] )"
.PD 0
.ie n .IP "desiredCompressionMethod( [ { compressionMethod => $method } ] )" 4
.el .IP "desiredCompressionMethod( [ { compressionMethod => \f(CW$method\fR } ] )" 4
.IX Item "desiredCompressionMethod( [ { compressionMethod => $method } ] )"
.PD
Get or set the member's \f(CW\*(C`desiredCompressionMethod\*(C'\fR. This is
the compression method that will be used when the member is
written. Returns prior desiredCompressionMethod. Only
\&\s-1COMPRESSION_DEFLATED\s0 or \s-1COMPRESSION_STORED\s0 are valid
arguments. Changing to \s-1COMPRESSION_STORED\s0 will change the
member desiredCompressionLevel to 0; changing to
\&\s-1COMPRESSION_DEFLATED\s0 will change the member
desiredCompressionLevel to \s-1COMPRESSION_LEVEL_DEFAULT.\s0
.ie n .IP "desiredCompressionLevel( [ $level ] )" 4
.el .IP "desiredCompressionLevel( [ \f(CW$level\fR ] )" 4
.IX Item "desiredCompressionLevel( [ $level ] )"
.PD 0
.ie n .IP "desiredCompressionLevel( [ { compressionLevel => $level } ] )" 4
.el .IP "desiredCompressionLevel( [ { compressionLevel => \f(CW$level\fR } ] )" 4
.IX Item "desiredCompressionLevel( [ { compressionLevel => $level } ] )"
.PD
Get or set the member's desiredCompressionLevel This is the
method that will be used to write. Returns prior
desiredCompressionLevel. Valid arguments are 0 through 9,
\&\s-1COMPRESSION_LEVEL_NONE, COMPRESSION_LEVEL_DEFAULT,
COMPRESSION_LEVEL_BEST_COMPRESSION,\s0 and
\&\s-1COMPRESSION_LEVEL_FASTEST. 0\s0 or \s-1COMPRESSION_LEVEL_NONE\s0 will
change the desiredCompressionMethod to \s-1COMPRESSION_STORED.\s0
All other arguments will change the desiredCompressionMethod
to \s-1COMPRESSION_DEFLATED.\s0
.IP "\fIexternalFileName()\fR" 4
.IX Item "externalFileName()"
Return the member's external file name, if any, or undef.
.IP "\fIfileName()\fR" 4
.IX Item "fileName()"
Get or set the member's internal filename. Returns the
(possibly new) filename. Names will have backslashes
converted to forward slashes, and will have multiple
consecutive slashes converted to single ones.
.IP "\fIlastModFileDateTime()\fR" 4
.IX Item "lastModFileDateTime()"
Return the member's last modification date/time stamp in
MS-DOS format.
.IP "\fIlastModTime()\fR" 4
.IX Item "lastModTime()"
Return the member's last modification date/time stamp,
converted to unix localtime format.
.Sp
.Vb 1
\&    print "Mod Time: " . scalar( localtime( $member\->lastModTime() ) );
.Ve
.IP "\fIsetLastModFileDateTimeFromUnix()\fR" 4
.IX Item "setLastModFileDateTimeFromUnix()"
Set the member's lastModFileDateTime from the given unix
time.
.Sp
.Vb 1
\&    $member\->setLastModFileDateTimeFromUnix( time() );
.Ve
.IP "\fIinternalFileAttributes()\fR" 4
.IX Item "internalFileAttributes()"
Return the internal file attributes field from the zip
header. This is only set for members read from a zip file.
.IP "\fIexternalFileAttributes()\fR" 4
.IX Item "externalFileAttributes()"
Return member attributes as read from the \s-1ZIP\s0 file. Note that
these are \s-1NOT UNIX\s0!
.ie n .IP "unixFileAttributes( [ $newAttributes ] )" 4
.el .IP "unixFileAttributes( [ \f(CW$newAttributes\fR ] )" 4
.IX Item "unixFileAttributes( [ $newAttributes ] )"
.PD 0
.ie n .IP "unixFileAttributes( [ { attributes => $newAttributes } ] )" 4
.el .IP "unixFileAttributes( [ { attributes => \f(CW$newAttributes\fR } ] )" 4
.IX Item "unixFileAttributes( [ { attributes => $newAttributes } ] )"
.PD
Get or set the member's file attributes using \s-1UNIX\s0 file
attributes. Returns old attributes.
.Sp
.Vb 1
\&    my $oldAttribs = $member\->unixFileAttributes( 0666 );
.Ve
.Sp
Note that the return value has more than just the file
permissions, so you will have to mask off the lowest bits for
comparisons.
.ie n .IP "localExtraField( [ $newField ] )" 4
.el .IP "localExtraField( [ \f(CW$newField\fR ] )" 4
.IX Item "localExtraField( [ $newField ] )"
.PD 0
.ie n .IP "localExtraField( [ { field => $newField } ] )" 4
.el .IP "localExtraField( [ { field => \f(CW$newField\fR } ] )" 4
.IX Item "localExtraField( [ { field => $newField } ] )"
.PD
Gets or sets the extra field that was read from the local
header. This is not set for a member from a zip file until
after the member has been written out. The extra field must
be in the proper format.
.ie n .IP "cdExtraField( [ $newField ] )" 4
.el .IP "cdExtraField( [ \f(CW$newField\fR ] )" 4
.IX Item "cdExtraField( [ $newField ] )"
.PD 0
.ie n .IP "cdExtraField( [ { field => $newField } ] )" 4
.el .IP "cdExtraField( [ { field => \f(CW$newField\fR } ] )" 4
.IX Item "cdExtraField( [ { field => $newField } ] )"
.PD
Gets or sets the extra field that was read from the central
directory header. The extra field must be in the proper
format.
.IP "\fIextraFields()\fR" 4
.IX Item "extraFields()"
Return both local and \s-1CD\s0 extra fields, concatenated.
.ie n .IP "fileComment( [ $newComment ] )" 4
.el .IP "fileComment( [ \f(CW$newComment\fR ] )" 4
.IX Item "fileComment( [ $newComment ] )"
.PD 0
.ie n .IP "fileComment( [ { comment => $newComment } ] )" 4
.el .IP "fileComment( [ { comment => \f(CW$newComment\fR } ] )" 4
.IX Item "fileComment( [ { comment => $newComment } ] )"
.PD
Get or set the member's file comment.
.IP "\fIhasDataDescriptor()\fR" 4
.IX Item "hasDataDescriptor()"
Get or set the data descriptor flag. If this is set, the
local header will not necessarily have the correct data
sizes. Instead, a small structure will be stored at the end
of the member data with these values. This should be
transparent in normal operation.
.IP "\fIcrc32()\fR" 4
.IX Item "crc32()"
Return the \s-1CRC\-32\s0 value for this member. This will not be set
for members that were constructed from strings or external
files until after the member has been written.
.IP "\fIcrc32String()\fR" 4
.IX Item "crc32String()"
Return the \s-1CRC\-32\s0 value for this member as an 8 character
printable hex string. This will not be set for members that
were constructed from strings or external files until after
the member has been written.
.IP "\fIcompressedSize()\fR" 4
.IX Item "compressedSize()"
Return the compressed size for this member. This will not be
set for members that were constructed from strings or
external files until after the member has been written.
.IP "\fIuncompressedSize()\fR" 4
.IX Item "uncompressedSize()"
Return the uncompressed size for this member.
.ie n .IP "password( [ $password ] )" 4
.el .IP "password( [ \f(CW$password\fR ] )" 4
.IX Item "password( [ $password ] )"
Returns the password for this member to be used on decryption.
If \f(CW$password\fR is given, it will set the password for the decryption.
.IP "\fIisEncrypted()\fR" 4
.IX Item "isEncrypted()"
Return true if this member is encrypted. The Archive::Zip
module does not currently support creation of encrypted
members. Decryption works more or less like this:
.Sp
.Vb 5
\&  my $zip = Archive::Zip\->new;
\&  $zip\->read ("encrypted.zip");
\&  for my $m (map { $zip\->memberNamed ($_) } $zip\->memberNames) {
\&      $m\->password ("secret");
\&      $m\->contents;  # is "" when password was wrong
.Ve
.Sp
That shows that the password has to be set per member, and not per
archive. This might change in the future.
.ie n .IP "isTextFile( [ $flag ] )" 4
.el .IP "isTextFile( [ \f(CW$flag\fR ] )" 4
.IX Item "isTextFile( [ $flag ] )"
.PD 0
.ie n .IP "isTextFile( [ { flag => $flag } ] )" 4
.el .IP "isTextFile( [ { flag => \f(CW$flag\fR } ] )" 4
.IX Item "isTextFile( [ { flag => $flag } ] )"
.PD
Returns true if I am a text file. Also can set the status if
given an argument (then returns old state). Note that this
module does not currently do anything with this flag upon
extraction or storage. That is, bytes are stored in native
format whether or not they came from a text file.
.IP "\fIisBinaryFile()\fR" 4
.IX Item "isBinaryFile()"
Returns true if I am a binary file. Also can set the status
if given an argument (then returns old state). Note that this
module does not currently do anything with this flag upon
extraction or storage. That is, bytes are stored in native
format whether or not they came from a text file.
.ie n .IP "extractToFileNamed( $fileName )" 4
.el .IP "extractToFileNamed( \f(CW$fileName\fR )" 4
.IX Item "extractToFileNamed( $fileName )"
.PD 0
.ie n .IP "extractToFileNamed( { name => $fileName } )" 4
.el .IP "extractToFileNamed( { name => \f(CW$fileName\fR } )" 4
.IX Item "extractToFileNamed( { name => $fileName } )"
.PD
Extract me to a file with the given name. The file will be
created with default modes. Directories will be created as
needed.
The \f(CW$fileName\fR argument should be a valid file name on your
file system.
Returns \s-1AZ_OK\s0 on success.
.IP "\fIisDirectory()\fR" 4
.IX Item "isDirectory()"
Returns true if I am a directory.
.IP "\fIwriteLocalHeaderRelativeOffset()\fR" 4
.IX Item "writeLocalHeaderRelativeOffset()"
Returns the file offset in bytes the last time I was written.
.IP "\fIwasWritten()\fR" 4
.IX Item "wasWritten()"
Returns true if I was successfully written. Reset at the
beginning of a write attempt.
.SS "Low-level member data reading"
.IX Subsection "Low-level member data reading"
It is possible to use lower-level routines to access member data
streams, rather than the extract* methods and \fIcontents()\fR. For
instance, here is how to print the uncompressed contents of a member
in chunks using these methods:
.PP
.Vb 10
\&    my ( $member, $status, $bufferRef );
\&    $member = $zip\->memberNamed( \*(Aqxyz.txt\*(Aq );
\&    $member\->desiredCompressionMethod( COMPRESSION_STORED );
\&    $status = $member\->rewindData();
\&    die "error $status" unless $status == AZ_OK;
\&    while ( ! $member\->readIsDone() )
\&    {
\&    ( $bufferRef, $status ) = $member\->readChunk();
\&    die "error $status"
\&                if $status != AZ_OK && $status != AZ_STREAM_END;
\&    # do something with $bufferRef:
\&    print $$bufferRef;
\&    }
\&    $member\->endRead();
.Ve
.ie n .IP "readChunk( [ $chunkSize ] )" 4
.el .IP "readChunk( [ \f(CW$chunkSize\fR ] )" 4
.IX Item "readChunk( [ $chunkSize ] )"
.PD 0
.ie n .IP "readChunk( [ { chunkSize => $chunkSize } ] )" 4
.el .IP "readChunk( [ { chunkSize => \f(CW$chunkSize\fR } ] )" 4
.IX Item "readChunk( [ { chunkSize => $chunkSize } ] )"
.PD
This reads the next chunk of given size from the member's
data stream and compresses or uncompresses it as necessary,
returning a reference to the bytes read and a status. If size
argument is not given, defaults to global set by
Archive::Zip::setChunkSize. Status is \s-1AZ_OK\s0 on success until
the last chunk, where it returns \s-1AZ_STREAM_END.\s0 Returns \f(CW\*(C`(
\&\e$bytes, $status)\*(C'\fR.
.Sp
.Vb 2
\&    my ( $outRef, $status ) = $self\->readChunk();
\&    print $$outRef if $status != AZ_OK && $status != AZ_STREAM_END;
.Ve
.IP "\fIrewindData()\fR" 4
.IX Item "rewindData()"
Rewind data and set up for reading data streams or writing
zip files. Can take options for \f(CW\*(C`inflateInit()\*(C'\fR or
\&\f(CW\*(C`deflateInit()\*(C'\fR, but this is not likely to be necessary.
Subclass overrides should call this method. Returns \f(CW\*(C`AZ_OK\*(C'\fR
on success.
.IP "\fIendRead()\fR" 4
.IX Item "endRead()"
Reset the read variables and free the inflater or deflater.
Must be called to close files, etc. Returns \s-1AZ_OK\s0 on success.
.IP "\fIreadIsDone()\fR" 4
.IX Item "readIsDone()"
Return true if the read has run out of data or encountered an error.
.IP "\fIcontents()\fR" 4
.IX Item "contents()"
Return the entire uncompressed member data or undef in scalar
context. When called in array context, returns \f(CW\*(C`( $string,
$status )\*(C'\fR; status will be \s-1AZ_OK\s0 on success:
.Sp
.Vb 4
\&    my $string = $member\->contents();
\&    # or
\&    my ( $string, $status ) = $member\->contents();
\&    die "error $status" unless $status == AZ_OK;
.Ve
.Sp
Can also be used to set the contents of a member (this may
change the class of the member):
.Sp
.Vb 1
\&    $member\->contents( "this is my new contents" );
.Ve
.ie n .IP "extractToFileHandle( $fh )" 4
.el .IP "extractToFileHandle( \f(CW$fh\fR )" 4
.IX Item "extractToFileHandle( $fh )"
.PD 0
.ie n .IP "extractToFileHandle( { fileHandle => $fh } )" 4
.el .IP "extractToFileHandle( { fileHandle => \f(CW$fh\fR } )" 4
.IX Item "extractToFileHandle( { fileHandle => $fh } )"
.PD
Extract (and uncompress, if necessary) the member's contents
to the given file handle. Return \s-1AZ_OK\s0 on success.
.SH "Archive::Zip::FileMember methods"
.IX Header "Archive::Zip::FileMember methods"
The Archive::Zip::FileMember class extends Archive::Zip::Member. It is the
base class for both ZipFileMember and NewFileMember classes. This class adds
an \f(CW\*(C`externalFileName\*(C'\fR and an \f(CW\*(C`fh\*(C'\fR member to keep track of the external
file.
.IP "\fIexternalFileName()\fR" 4
.IX Item "externalFileName()"
Return the member's external filename.
.IP "\fIfh()\fR" 4
.IX Item "fh()"
Return the member's read file handle. Automatically opens file if
necessary.
.SH "Archive::Zip::ZipFileMember methods"
.IX Header "Archive::Zip::ZipFileMember methods"
The Archive::Zip::ZipFileMember class represents members that have been read
from external zip files.
.IP "\fIdiskNumberStart()\fR" 4
.IX Item "diskNumberStart()"
Returns the disk number that the member's local header resides in.
Should be 0.
.IP "\fIlocalHeaderRelativeOffset()\fR" 4
.IX Item "localHeaderRelativeOffset()"
Returns the offset into the zip file where the member's local header
is.
.IP "\fIdataOffset()\fR" 4
.IX Item "dataOffset()"
Returns the offset from the beginning of the zip file to the member's
data.
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
Archive::Zip requires several other modules:
.PP
Carp
.PP
Compress::Raw::Zlib
.PP
Cwd
.PP
File::Basename
.PP
File::Copy
.PP
File::Find
.PP
File::Path
.PP
File::Spec
.PP
IO::File
.PP
IO::Seekable
.PP
Time::Local
.SH "BUGS AND CAVEATS"
.IX Header "BUGS AND CAVEATS"
.SS "When not to use Archive::Zip"
.IX Subsection "When not to use Archive::Zip"
If you are just going to be extracting zips (and/or other archives) you
are recommended to look at using Archive::Extract instead, as it is much
easier to use and factors out archive-specific functionality.
.SS "Try to avoid IO::Scalar"
.IX Subsection "Try to avoid IO::Scalar"
One of the most common ways to use Archive::Zip is to generate Zip files
in-memory. Most people use IO::Scalar for this purpose.
.PP
Unfortunately, as of 1.11 this module no longer works with IO::Scalar
as it incorrectly implements seeking.
.PP
Anybody using IO::Scalar should consider porting to IO::String,
which is smaller, lighter, and is implemented to be perfectly compatible
with regular seekable filehandles.
.PP
Support for IO::Scalar most likely will \fBnot\fR be restored in the
future, as IO::Scalar itself cannot change the way it is implemented
due to back-compatibility issues.
.SS "Wrong password for encrypted members"
.IX Subsection "Wrong password for encrypted members"
When an encrypted member is read using the wrong password, you currently
have to re-read the entire archive to try again with the correct password.
.SH "TO DO"
.IX Header "TO DO"
* auto-choosing storing vs compression
.PP
* extra field hooks (see notes.txt)
.PP
* check for duplicates on addition/renaming?
.PP
* Text file extraction (line end translation)
.PP
* Reading zip files from non-seekable inputs
  (Perhaps by proxying through IO::String?)
.PP
* separate unused constants into separate module
.PP
* cookbook style docs
.PP
* Handle tainted paths correctly
.PP
* Work on better compatibility with other \s-1IO::\s0 modules
.PP
* Support encryption
.PP
* More user-friendly decryption
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be reported via the \s-1CPAN\s0 bug tracker
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive\-Zip>
.PP
For other issues contact the maintainer
.SH "AUTHOR"
.IX Header "AUTHOR"
Currently maintained by Fred Moyer <fred@redhotpenguin.com>
.PP
Previously maintained by Adam Kennedy <adamk@cpan.org>
.PP
Previously maintained by Steve Peters <steve@fisharerojo.org>.
.PP
File attributes code by Maurice Aubrey <maurice@lovelyfilth.com>.
.PP
Originally by Ned Konz <nedkonz@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Some parts copyright 2006 \- 2012 Adam Kennedy.
.PP
Some parts copyright 2005 Steve Peters.
.PP
Original work copyright 2000 \- 2004 Ned Konz.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Look at Archive::Zip::MemberRead which is a wrapper that allows one to
read Zip archive members as if they were files.
.PP
Compress::Raw::Zlib, Archive::Tar, Archive::Extract
                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::FAQ.3pm                        0100644 0001750 0001750 00000047421 12566241430 024250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::FAQ 3"
.TH Archive::Zip::FAQ 3 "2013-12-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::FAQ \- Answers to a few frequently asked questions about Archive::Zip
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It seems that I keep answering the same questions over and over again. I
assume that this is because my documentation is deficient, rather than that
people don't read the documentation.
.PP
So this \s-1FAQ\s0 is an attempt to cut down on the number of personal answers I have
to give. At least I can now say "You \fIdid\fR read the \s-1FAQ,\s0 right?".
.PP
The questions are not in any particular order. The answers assume the current
version of Archive::Zip; some of the answers depend on newly added/fixed
functionality.
.SH "Install problems on RedHat 8 or 9 with Perl 5.8.0"
.IX Header "Install problems on RedHat 8 or 9 with Perl 5.8.0"
\&\fBQ:\fR Archive::Zip won't install on my RedHat 9 system! It's broke!
.PP
\&\fBA:\fR This has become something of a \s-1FAQ.\s0
Basically, RedHat broke some versions of Perl by setting \s-1LANG\s0 to \s-1UTF8.\s0
They apparently have a fixed version out as an update.
.PP
You might try running \s-1CPAN\s0 or creating your Makefile after exporting the \s-1LANG\s0
environment variable as
.PP
\&\f(CW\*(C`LANG=C\*(C'\fR
.PP
<https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=87682>
.SH "Why is my zip file so big?"
.IX Header "Why is my zip file so big?"
\&\fBQ:\fR My zip file is actually bigger than what I stored in it! Why?
.PP
\&\fBA:\fR Some things to make sure of:
.IP "Make sure that you are requesting \s-1COMPRESSION_DEFLATED\s0 if you are storing strings." 4
.IX Item "Make sure that you are requesting COMPRESSION_DEFLATED if you are storing strings."
\&\f(CW$member\fR\->desiredCompressionMethod( \s-1COMPRESSION_DEFLATED \s0);
.IP "Don't make lots of little files if you can help it." 4
.IX Item "Don't make lots of little files if you can help it."
Since zip computes the compression tables for each member, small
members without much entropy won't compress well.  Instead, if you've
got lots of repeated strings in your data, try to combine them into
one big member.
.IP "Make sure that you are requesting \s-1COMPRESSION_STORED\s0 if you are storing things that are already compressed." 4
.IX Item "Make sure that you are requesting COMPRESSION_STORED if you are storing things that are already compressed."
If you're storing a .zip, .jpg, .mp3, or other compressed file in a zip,
then don't compress them again. They'll get bigger.
.SH "Sample code?"
.IX Header "Sample code?"
\&\fBQ:\fR Can you send me code to do (whatever)?
.PP
\&\fBA:\fR Have you looked in the \f(CW\*(C`examples/\*(C'\fR directory yet? It contains:
.IP "examples/calcSizes.pl    \*(-- How to find out how big a Zip file will be before writing it" 4
.IX Item "examples/calcSizes.pl How to find out how big a Zip file will be before writing it"
.PD 0
.IP "examples/copy.pl         \*(-- Copies one Zip file to another" 4
.IX Item "examples/copy.pl Copies one Zip file to another"
.IP "examples/extract.pl      \*(-- extract file(s) from a Zip" 4
.IX Item "examples/extract.pl extract file(s) from a Zip"
.IP "examples/mailZip.pl      \*(-- make and mail a zip file" 4
.IX Item "examples/mailZip.pl make and mail a zip file"
.IP "examples/mfh.pl          \*(-- demo for use of MockFileHandle" 4
.IX Item "examples/mfh.pl demo for use of MockFileHandle"
.IP "examples/readScalar.pl   \*(-- shows how to use IO::Scalar as the source of a Zip read" 4
.IX Item "examples/readScalar.pl shows how to use IO::Scalar as the source of a Zip read"
.IP "examples/selfex.pl       \*(-- a brief example of a self-extracting Zip" 4
.IX Item "examples/selfex.pl a brief example of a self-extracting Zip"
.IP "examples/unzipAll.pl     \*(-- uses Archive::Zip::Tree to unzip an entire Zip" 4
.IX Item "examples/unzipAll.pl uses Archive::Zip::Tree to unzip an entire Zip"
.IP "examples/updateZip.pl    \*(-- shows how to read/modify/write a Zip" 4
.IX Item "examples/updateZip.pl shows how to read/modify/write a Zip"
.IP "examples/updateTree.pl   \*(-- shows how to update a Zip in place" 4
.IX Item "examples/updateTree.pl shows how to update a Zip in place"
.IP "examples/writeScalar.pl  \*(-- shows how to use IO::Scalar as the destination of a Zip write" 4
.IX Item "examples/writeScalar.pl shows how to use IO::Scalar as the destination of a Zip write"
.IP "examples/writeScalar2.pl \*(-- shows how to use IO::String as the destination of a Zip write" 4
.IX Item "examples/writeScalar2.pl shows how to use IO::String as the destination of a Zip write"
.IP "examples/zip.pl          \*(-- Constructs a Zip file" 4
.IX Item "examples/zip.pl Constructs a Zip file"
.IP "examples/zipcheck.pl     \*(-- One way to check a Zip file for validity" 4
.IX Item "examples/zipcheck.pl One way to check a Zip file for validity"
.IP "examples/zipinfo.pl      \*(-- Prints out information about a Zip archive file" 4
.IX Item "examples/zipinfo.pl Prints out information about a Zip archive file"
.IP "examples/zipGrep.pl      \*(-- Searches for text in Zip files" 4
.IX Item "examples/zipGrep.pl Searches for text in Zip files"
.IP "examples/ziptest.pl      \*(-- Lists a Zip file and checks member CRCs" 4
.IX Item "examples/ziptest.pl Lists a Zip file and checks member CRCs"
.IP "examples/ziprecent.pl    \*(-- Puts recent files into a zipfile" 4
.IX Item "examples/ziprecent.pl Puts recent files into a zipfile"
.IP "examples/ziptest.pl      \*(-- Another way to check a Zip file for validity" 4
.IX Item "examples/ziptest.pl Another way to check a Zip file for validity"
.PD
.SH "Can't Read/modify/write same Zip file"
.IX Header "Can't Read/modify/write same Zip file"
\&\fBQ:\fR Why can't I open a Zip file, add a member, and write it back? I get an
error message when I try.
.PP
\&\fBA:\fR Because Archive::Zip doesn't (and can't, generally) read file contents into memory,
the original Zip file is required to stay around until the writing of the new
file is completed.
.PP
The best way to do this is to write the Zip to a temporary file and then
rename the temporary file to have the old name (possibly after deleting the
old one).
.PP
Archive::Zip v1.02 added the archive methods \f(CW\*(C`overwrite()\*(C'\fR and
\&\f(CW\*(C`overwriteAs()\*(C'\fR to do this simply and carefully.
.PP
See \f(CW\*(C`examples/updateZip.pl\*(C'\fR for an example of this technique.
.SH "File creation time not set"
.IX Header "File creation time not set"
\&\fBQ:\fR Upon extracting files, I see that their modification (and access) times are
set to the time in the Zip archive. However, their creation time is not set to
the same time. Why?
.PP
\&\fBA:\fR Mostly because Perl doesn't give cross-platform access to \fIcreation time\fR.
Indeed, many systems (like Unix) don't support such a concept.
However, if yours does, you can easily set it. Get the modification time from
the member using \f(CW\*(C`lastModTime()\*(C'\fR.
.SH "Can't use Archive::Zip on gzip files"
.IX Header "Can't use Archive::Zip on gzip files"
\&\fBQ:\fR Can I use Archive::Zip to extract Unix gzip files?
.PP
\&\fBA:\fR No.
.PP
There is a distinction between Unix gzip files, and Zip archives that 
also can use the gzip compression.
.PP
Depending on the format of the gzip file, you can use Compress::Raw::Zlib, or
Archive::Tar to decompress it (and de-archive it in the case of Tar files).
.PP
You can unzip PKZIP/WinZip/etc/ archives using Archive::Zip (that's what 
it's for) as long as any compressed members are compressed using 
Deflate compression.
.SH "Add a directory/tree to a Zip"
.IX Header "Add a directory/tree to a Zip"
\&\fBQ:\fR How can I add a directory (or tree) full of files to a Zip?
.PP
\&\fBA:\fR You can use the Archive::Zip::addTree*() methods:
.PP
.Vb 10
\&   use Archive::Zip;
\&   my $zip = Archive::Zip\->new();
\&   # add all readable files and directories below . as xyz/*
\&   $zip\->addTree( \*(Aq.\*(Aq, \*(Aqxyz\*(Aq ); 
\&   # add all readable plain files below /abc as def/*
\&   $zip\->addTree( \*(Aq/abc\*(Aq, \*(Aqdef\*(Aq, sub { \-f && \-r } );    
\&   # add all .c files below /tmp as stuff/*
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.c$\*(Aq );
\&   # add all .o files below /tmp as stuff/* if they aren\*(Aqt writable
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { ! \-w } );
\&   # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { \-s < 200 } );
\&   # and write them into a file
\&   $zip\->writeToFileNamed(\*(Aqxxx.zip\*(Aq);
.Ve
.SH "Extract a directory/tree"
.IX Header "Extract a directory/tree"
\&\fBQ:\fR How can I extract some (or all) files from a Zip into a different
directory?
.PP
\&\fBA:\fR You can use the \fIArchive::Zip::extractTree()\fR method:
??? ||
.PP
.Vb 2
\&   # now extract the same files into /tmpx
\&   $zip\->extractTree( \*(Aqstuff\*(Aq, \*(Aq/tmpx\*(Aq );
.Ve
.SH "Update a directory/tree"
.IX Header "Update a directory/tree"
\&\fBQ:\fR How can I update a Zip from a directory tree, adding or replacing only
the newer files?
.PP
\&\fBA:\fR You can use the \fIArchive::Zip::updateTree()\fR method that was added in version 1.09.
.SH "Zip times might be off by 1 second"
.IX Header "Zip times might be off by 1 second"
\&\fBQ:\fR It bothers me greatly that my file times are wrong by one second about half
the time. Why don't you do something about it?
.PP
\&\fBA:\fR Get over it. This is a result of the Zip format storing times in \s-1DOS\s0
format, which has a resolution of only two seconds.
.SH "Zip times don't include time zone information"
.IX Header "Zip times don't include time zone information"
\&\fBQ:\fR My file times don't respect time zones. What gives?
.PP
\&\fBA:\fR If this is important to you, please submit patches to read the various
Extra Fields that encode times with time zones. I'm just using the \s-1DOS\s0
Date/Time, which doesn't have a time zone.
.SH "How do I make a self-extracting Zip"
.IX Header "How do I make a self-extracting Zip"
\&\fBQ:\fR I want to make a self-extracting Zip file. Can I do this?
.PP
\&\fBA:\fR Yes. You can write a self-extracting archive stub (that is, a version of
unzip) to the output filehandle that you pass to \fIwriteToFileHandle()\fR. See
examples/selfex.pl for how to write a self-extracting archive.
.PP
However, you should understand that this will only work on one kind of
platform (the one for which the stub was compiled).
.SH "How can I deal with Zips with prepended garbage (i.e. from Sircam)"
.IX Header "How can I deal with Zips with prepended garbage (i.e. from Sircam)"
\&\fBQ:\fR How can I tell if a Zip has been damaged by adding garbage to the
beginning or inside the file?
.PP
\&\fBA:\fR I added code for this for the Amavis virus scanner. You can query archives
for their 'eocdOffset' property, which should be 0:
.PP
.Vb 2
\&  if ($zip\->eocdOffset > 0)
\&    { warn($zip\->eocdOffset . " bytes of garbage at beginning or within Zip") }
.Ve
.PP
When members are extracted, this offset will be used to adjust the start of
the member if necessary.
.SH "Can't extract Shrunk files"
.IX Header "Can't extract Shrunk files"
\&\fBQ:\fR I'm trying to extract a file out of a Zip produced by \s-1PKZIP,\s0 and keep
getting this error message:
.PP
.Vb 1
\&  error: Unsupported compression combination: read 6, write 0
.Ve
.PP
\&\fBA:\fR You can't uncompress this archive member. Archive::Zip only supports uncompressed
members, and compressed members that are compressed using the compression
supported by Compress::Raw::Zlib. That means only Deflated and Stored members.
.PP
Your file is compressed using the Shrink format, which is not supported by
Compress::Raw::Zlib.
.PP
You could, perhaps, use a command-line UnZip program (like the Info-Zip
one) to extract this.
.SH "Can't do decryption"
.IX Header "Can't do decryption"
\&\fBQ:\fR How do I decrypt encrypted Zip members?
.PP
\&\fBA:\fR With some other program or library. Archive::Zip doesn't support decryption,
and probably never will (unless \fIyou\fR write it).
.SH "How to test file integrity?"
.IX Header "How to test file integrity?"
\&\fBQ:\fR How can Archive::Zip can test the validity of a Zip file?
.PP
\&\fBA:\fR If you try to decompress the file, the gzip streams will report errors 
if you have garbage. Most of the time.
.PP
If you try to open the file and a central directory structure can't be 
found, an error will be reported.
.PP
When a file is being read, if we can't find a proper \s-1PK..\s0 signature in 
the right places we report a format error.
.PP
If there is added garbage at the beginning of a Zip file (as inserted 
by some viruses), you can find out about it, but Archive::Zip will ignore it, 
and you can still use the archive. When it gets written back out the 
added stuff will be gone.
.PP
There are two ready-to-use utilities in the examples directory that can
be used to test file integrity, or that you can use as examples
for your own code:
.IP "examples/zipcheck.pl shows how to use an attempted extraction to test a file." 4
.IX Item "examples/zipcheck.pl shows how to use an attempted extraction to test a file."
.PD 0
.IP "examples/ziptest.pl shows how to test CRCs in a file." 4
.IX Item "examples/ziptest.pl shows how to test CRCs in a file."
.PD
.SH "Duplicate files in Zip?"
.IX Header "Duplicate files in Zip?"
\&\fBQ:\fR Archive::Zip let me put the same file in my Zip twice! Why don't you prevent this?
.PP
\&\fBA:\fR As far as I can tell, this is not disallowed by the Zip spec. If you
think it's a bad idea, check for it yourself:
.PP
.Vb 1
\&  $zip\->addFile($someFile, $someName) unless $zip\->memberNamed($someName);
.Ve
.PP
I can even imagine cases where this might be useful (for instance, multiple
versions of files).
.SH "File ownership/permissions/ACLS/etc"
.IX Header "File ownership/permissions/ACLS/etc"
\&\fBQ:\fR Why doesn't Archive::Zip deal with file ownership, ACLs, etc.?
.PP
\&\fBA:\fR There is no standard way to represent these in the Zip file format. If
you want to send me code to properly handle the various extra fields that
have been used to represent these through the years, I'll look at it.
.SH "I can't compile but ActiveState only has an old version of Archive::Zip"
.IX Header "I can't compile but ActiveState only has an old version of Archive::Zip"
\&\fBQ:\fR I've only installed modules using ActiveState's \s-1PPM\s0 program and
repository. But they have a much older version of Archive::Zip than is in \s-1CPAN.\s0 Will
you send me a newer \s-1PPM\s0?
.PP
\&\fBA:\fR Probably not, unless I get lots of extra time. But there's no reason you
can't install the version from \s-1CPAN.\s0 Archive::Zip is pure Perl, so all you need is
\&\s-1NMAKE,\s0 which you can get for free from Microsoft (see the \s-1FAQ\s0 in the
ActiveState documentation for details on how to install \s-1CPAN\s0 modules).
.SH "My JPEGs (or MP3's) don't compress when I put them into Zips!"
.IX Header "My JPEGs (or MP3's) don't compress when I put them into Zips!"
\&\fBQ:\fR How come my JPEGs and \s-1MP3\s0's don't compress much when I put them into Zips?
.PP
\&\fBA:\fR Because they're already compressed.
.SH "Under Windows, things lock up/get damaged"
.IX Header "Under Windows, things lock up/get damaged"
\&\fBQ:\fR I'm using Windows. When I try to use Archive::Zip, my machine locks up/makes
funny sounds/displays a BSOD/corrupts data. How can I fix this?
.PP
\&\fBA:\fR First, try the newest version of Compress::Raw::Zlib. I know of
Windows-related problems prior to v1.14 of that library.
.SH "Zip contents in a scalar"
.IX Header "Zip contents in a scalar"
\&\fBQ:\fR I want to read a Zip file from (or write one to) a scalar variable instead
of a file. How can I do this?
.PP
\&\fBA:\fR Use \f(CW\*(C`IO::String\*(C'\fR and the \f(CW\*(C`readFromFileHandle()\*(C'\fR and
\&\f(CW\*(C`writeToFileHandle()\*(C'\fR methods.
See \f(CW\*(C`examples/readScalar.pl\*(C'\fR and \f(CW\*(C`examples/writeScalar.pl\*(C'\fR.
.SH "Reading from streams"
.IX Header "Reading from streams"
\&\fBQ:\fR How do I read from a stream (like for the Info-Zip \f(CW\*(C`funzip\*(C'\fR program)?
.PP
\&\fBA:\fR This is not currently supported, though writing to a stream is.
                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::FAQ5.16.3pm                    0100644 0001750 0001750 00000047372 12566241430 024567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::FAQ 3"
.TH Archive::Zip::FAQ 3 "2009-06-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::FAQ \- Answers to a few frequently asked questions about Archive::Zip
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It seems that I keep answering the same questions over and over again. I
assume that this is because my documentation is deficient, rather than that
people don't read the documentation.
.PP
So this \s-1FAQ\s0 is an attempt to cut down on the number of personal answers I have
to give. At least I can now say "You \fIdid\fR read the \s-1FAQ\s0, right?".
.PP
The questions are not in any particular order. The answers assume the current
version of Archive::Zip; some of the answers depend on newly added/fixed
functionality.
.SH "Install problems on RedHat 8 or 9 with Perl 5.8.0"
.IX Header "Install problems on RedHat 8 or 9 with Perl 5.8.0"
\&\fBQ:\fR Archive::Zip won't install on my RedHat 9 system! It's broke!
.PP
\&\fBA:\fR This has become something of a \s-1FAQ\s0.
Basically, RedHat broke some versions of Perl by setting \s-1LANG\s0 to \s-1UTF8\s0.
They apparently have a fixed version out as an update.
.PP
You might try running \s-1CPAN\s0 or creating your Makefile after exporting the \s-1LANG\s0
environment variable as
.PP
\&\f(CW\*(C`LANG=C\*(C'\fR
.PP
<https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=87682>
.SH "Why is my zip file so big?"
.IX Header "Why is my zip file so big?"
\&\fBQ:\fR My zip file is actually bigger than what I stored in it! Why?
.PP
\&\fBA:\fR Some things to make sure of:
.IP "Make sure that you are requesting \s-1COMPRESSION_DEFLATED\s0 if you are storing strings." 4
.IX Item "Make sure that you are requesting COMPRESSION_DEFLATED if you are storing strings."
\&\f(CW$member\fR\->desiredCompressionMethod( \s-1COMPRESSION_DEFLATED\s0 );
.IP "Don't make lots of little files if you can help it." 4
.IX Item "Don't make lots of little files if you can help it."
Since zip computes the compression tables for each member, small
members without much entropy won't compress well.  Instead, if you've
got lots of repeated strings in your data, try to combine them into
one big member.
.IP "Make sure that you are requesting \s-1COMPRESSION_STORED\s0 if you are storing things that are already compressed." 4
.IX Item "Make sure that you are requesting COMPRESSION_STORED if you are storing things that are already compressed."
If you're storing a .zip, .jpg, .mp3, or other compressed file in a zip,
then don't compress them again. They'll get bigger.
.SH "Sample code?"
.IX Header "Sample code?"
\&\fBQ:\fR Can you send me code to do (whatever)?
.PP
\&\fBA:\fR Have you looked in the \f(CW\*(C`examples/\*(C'\fR directory yet? It contains:
.IP "examples/calcSizes.pl    \*(-- How to find out how big a Zip file will be before writing it" 4
.IX Item "examples/calcSizes.pl     How to find out how big a Zip file will be before writing it"
.PD 0
.IP "examples/copy.pl         \*(-- Copies one Zip file to another" 4
.IX Item "examples/copy.pl          Copies one Zip file to another"
.IP "examples/extract.pl      \*(-- extract file(s) from a Zip" 4
.IX Item "examples/extract.pl       extract file(s) from a Zip"
.IP "examples/mailZip.pl      \*(-- make and mail a zip file" 4
.IX Item "examples/mailZip.pl       make and mail a zip file"
.IP "examples/mfh.pl          \*(-- demo for use of MockFileHandle" 4
.IX Item "examples/mfh.pl           demo for use of MockFileHandle"
.IP "examples/readScalar.pl   \*(-- shows how to use IO::Scalar as the source of a Zip read" 4
.IX Item "examples/readScalar.pl    shows how to use IO::Scalar as the source of a Zip read"
.IP "examples/selfex.pl       \*(-- a brief example of a self-extracting Zip" 4
.IX Item "examples/selfex.pl        a brief example of a self-extracting Zip"
.IP "examples/unzipAll.pl     \*(-- uses Archive::Zip::Tree to unzip an entire Zip" 4
.IX Item "examples/unzipAll.pl      uses Archive::Zip::Tree to unzip an entire Zip"
.IP "examples/updateZip.pl    \*(-- shows how to read/modify/write a Zip" 4
.IX Item "examples/updateZip.pl     shows how to read/modify/write a Zip"
.IP "examples/updateTree.pl   \*(-- shows how to update a Zip in place" 4
.IX Item "examples/updateTree.pl    shows how to update a Zip in place"
.IP "examples/writeScalar.pl  \*(-- shows how to use IO::Scalar as the destination of a Zip write" 4
.IX Item "examples/writeScalar.pl   shows how to use IO::Scalar as the destination of a Zip write"
.IP "examples/writeScalar2.pl \*(-- shows how to use IO::String as the destination of a Zip write" 4
.IX Item "examples/writeScalar2.pl  shows how to use IO::String as the destination of a Zip write"
.IP "examples/zip.pl          \*(-- Constructs a Zip file" 4
.IX Item "examples/zip.pl           Constructs a Zip file"
.IP "examples/zipcheck.pl     \*(-- One way to check a Zip file for validity" 4
.IX Item "examples/zipcheck.pl      One way to check a Zip file for validity"
.IP "examples/zipinfo.pl      \*(-- Prints out information about a Zip archive file" 4
.IX Item "examples/zipinfo.pl       Prints out information about a Zip archive file"
.IP "examples/zipGrep.pl      \*(-- Searches for text in Zip files" 4
.IX Item "examples/zipGrep.pl       Searches for text in Zip files"
.IP "examples/ziptest.pl      \*(-- Lists a Zip file and checks member CRCs" 4
.IX Item "examples/ziptest.pl       Lists a Zip file and checks member CRCs"
.IP "examples/ziprecent.pl    \*(-- Puts recent files into a zipfile" 4
.IX Item "examples/ziprecent.pl     Puts recent files into a zipfile"
.IP "examples/ziptest.pl      \*(-- Another way to check a Zip file for validity" 4
.IX Item "examples/ziptest.pl       Another way to check a Zip file for validity"
.PD
.SH "Can't Read/modify/write same Zip file"
.IX Header "Can't Read/modify/write same Zip file"
\&\fBQ:\fR Why can't I open a Zip file, add a member, and write it back? I get an
error message when I try.
.PP
\&\fBA:\fR Because Archive::Zip doesn't (and can't, generally) read file contents into memory,
the original Zip file is required to stay around until the writing of the new
file is completed.
.PP
The best way to do this is to write the Zip to a temporary file and then
rename the temporary file to have the old name (possibly after deleting the
old one).
.PP
Archive::Zip v1.02 added the archive methods \f(CW\*(C`overwrite()\*(C'\fR and
\&\f(CW\*(C`overwriteAs()\*(C'\fR to do this simply and carefully.
.PP
See \f(CW\*(C`examples/updateZip.pl\*(C'\fR for an example of this technique.
.SH "File creation time not set"
.IX Header "File creation time not set"
\&\fBQ:\fR Upon extracting files, I see that their modification (and access) times are
set to the time in the Zip archive. However, their creation time is not set to
the same time. Why?
.PP
\&\fBA:\fR Mostly because Perl doesn't give cross-platform access to \fIcreation time\fR.
Indeed, many systems (like Unix) don't support such a concept.
However, if yours does, you can easily set it. Get the modification time from
the member using \f(CW\*(C`lastModTime()\*(C'\fR.
.SH "Can't use Archive::Zip on gzip files"
.IX Header "Can't use Archive::Zip on gzip files"
\&\fBQ:\fR Can I use Archive::Zip to extract Unix gzip files?
.PP
\&\fBA:\fR No.
.PP
There is a distinction between Unix gzip files, and Zip archives that 
also can use the gzip compression.
.PP
Depending on the format of the gzip file, you can use Compress::Raw::Zlib, or
Archive::Tar to decompress it (and de-archive it in the case of Tar files).
.PP
You can unzip PKZIP/WinZip/etc/ archives using Archive::Zip (that's what 
it's for) as long as any compressed members are compressed using 
Deflate compression.
.SH "Add a directory/tree to a Zip"
.IX Header "Add a directory/tree to a Zip"
\&\fBQ:\fR How can I add a directory (or tree) full of files to a Zip?
.PP
\&\fBA:\fR You can use the Archive::Zip::addTree*() methods:
.PP
.Vb 10
\&   use Archive::Zip;
\&   my $zip = Archive::Zip\->new();
\&   # add all readable files and directories below . as xyz/*
\&   $zip\->addTree( \*(Aq.\*(Aq, \*(Aqxyz\*(Aq ); 
\&   # add all readable plain files below /abc as def/*
\&   $zip\->addTree( \*(Aq/abc\*(Aq, \*(Aqdef\*(Aq, sub { \-f && \-r } );    
\&   # add all .c files below /tmp as stuff/*
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.c$\*(Aq );
\&   # add all .o files below /tmp as stuff/* if they aren\*(Aqt writable
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { ! \-w } );
\&   # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { \-s < 200 } );
\&   # and write them into a file
\&   $zip\->writeToFileNamed(\*(Aqxxx.zip\*(Aq);
.Ve
.SH "Extract a directory/tree"
.IX Header "Extract a directory/tree"
\&\fBQ:\fR How can I extract some (or all) files from a Zip into a different
directory?
.PP
\&\fBA:\fR You can use the \fIArchive::Zip::extractTree()\fR method:
??? ||
.PP
.Vb 2
\&   # now extract the same files into /tmpx
\&   $zip\->extractTree( \*(Aqstuff\*(Aq, \*(Aq/tmpx\*(Aq );
.Ve
.SH "Update a directory/tree"
.IX Header "Update a directory/tree"
\&\fBQ:\fR How can I update a Zip from a directory tree, adding or replacing only
the newer files?
.PP
\&\fBA:\fR You can use the \fIArchive::Zip::updateTree()\fR method that was added in version 1.09.
.SH "Zip times might be off by 1 second"
.IX Header "Zip times might be off by 1 second"
\&\fBQ:\fR It bothers me greatly that my file times are wrong by one second about half
the time. Why don't you do something about it?
.PP
\&\fBA:\fR Get over it. This is a result of the Zip format storing times in \s-1DOS\s0
format, which has a resolution of only two seconds.
.SH "Zip times don't include time zone information"
.IX Header "Zip times don't include time zone information"
\&\fBQ:\fR My file times don't respect time zones. What gives?
.PP
\&\fBA:\fR If this is important to you, please submit patches to read the various
Extra Fields that encode times with time zones. I'm just using the \s-1DOS\s0
Date/Time, which doesn't have a time zone.
.SH "How do I make a self-extracting Zip"
.IX Header "How do I make a self-extracting Zip"
\&\fBQ:\fR I want to make a self-extracting Zip file. Can I do this?
.PP
\&\fBA:\fR Yes. You can write a self-extracting archive stub (that is, a version of
unzip) to the output filehandle that you pass to \fIwriteToFileHandle()\fR. See
examples/selfex.pl for how to write a self-extracting archive.
.PP
However, you should understand that this will only work on one kind of
platform (the one for which the stub was compiled).
.SH "How can I deal with Zips with prepended garbage (i.e. from Sircam)"
.IX Header "How can I deal with Zips with prepended garbage (i.e. from Sircam)"
\&\fBQ:\fR How can I tell if a Zip has been damaged by adding garbage to the
beginning or inside the file?
.PP
\&\fBA:\fR I added code for this for the Amavis virus scanner. You can query archives
for their 'eocdOffset' property, which should be 0:
.PP
.Vb 2
\&  if ($zip\->eocdOffset > 0)
\&    { warn($zip\->eocdOffset . " bytes of garbage at beginning or within Zip") }
.Ve
.PP
When members are extracted, this offset will be used to adjust the start of
the member if necessary.
.SH "Can't extract Shrunk files"
.IX Header "Can't extract Shrunk files"
\&\fBQ:\fR I'm trying to extract a file out of a Zip produced by \s-1PKZIP\s0, and keep
getting this error message:
.PP
.Vb 1
\&  error: Unsupported compression combination: read 6, write 0
.Ve
.PP
\&\fBA:\fR You can't uncompress this archive member. Archive::Zip only supports uncompressed
members, and compressed members that are compressed using the compression
supported by Compress::Raw::Zlib. That means only Deflated and Stored members.
.PP
Your file is compressed using the Shrink format, which isn't supported by
Compress::Raw::Zlib.
.PP
You could, perhaps, use a command-line UnZip program (like the Info-Zip
one) to extract this.
.SH "Can't do decryption"
.IX Header "Can't do decryption"
\&\fBQ:\fR How do I decrypt encrypted Zip members?
.PP
\&\fBA:\fR With some other program or library. Archive::Zip doesn't support decryption,
and probably never will (unless \fIyou\fR write it).
.SH "How to test file integrity?"
.IX Header "How to test file integrity?"
\&\fBQ:\fR How can Archive::Zip can test the validity of a Zip file?
.PP
\&\fBA:\fR If you try to decompress the file, the gzip streams will report errors 
if you have garbage. Most of the time.
.PP
If you try to open the file and a central directory structure can't be 
found, an error will be reported.
.PP
When a file is being read, if we can't find a proper \s-1PK\s0.. signature in 
the right places we report a format error.
.PP
If there is added garbage at the beginning of a Zip file (as inserted 
by some viruses), you can find out about it, but Archive::Zip will ignore it, 
and you can still use the archive. When it gets written back out the 
added stuff will be gone.
.PP
There are two ready-to-use utilities in the examples directory that can
be used to test file integrity, or that you can use as examples
for your own code:
.IP "examples/zipcheck.pl shows how to use an attempted extraction to test a file." 4
.IX Item "examples/zipcheck.pl shows how to use an attempted extraction to test a file."
.PD 0
.IP "examples/ziptest.pl shows how to test CRCs in a file." 4
.IX Item "examples/ziptest.pl shows how to test CRCs in a file."
.PD
.SH "Duplicate files in Zip?"
.IX Header "Duplicate files in Zip?"
\&\fBQ:\fR Archive::Zip let me put the same file in my Zip twice! Why don't you prevent this?
.PP
\&\fBA:\fR As far as I can tell, this is not disallowed by the Zip spec. If you
think it's a bad idea, check for it yourself:
.PP
.Vb 1
\&  $zip\->addFile($someFile, $someName) unless $zip\->memberNamed($someName);
.Ve
.PP
I can even imagine cases where this might be useful (for instance, multiple
versions of files).
.SH "File ownership/permissions/ACLS/etc"
.IX Header "File ownership/permissions/ACLS/etc"
\&\fBQ:\fR Why doesn't Archive::Zip deal with file ownership, ACLs, etc.?
.PP
\&\fBA:\fR There is no standard way to represent these in the Zip file format. If
you want to send me code to properly handle the various extra fields that
have been used to represent these through the years, I'll look at it.
.SH "I can't compile but ActiveState only has an old version of Archive::Zip"
.IX Header "I can't compile but ActiveState only has an old version of Archive::Zip"
\&\fBQ:\fR I've only installed modules using ActiveState's \s-1PPM\s0 program and
repository. But they have a much older version of Archive::Zip than is in \s-1CPAN\s0. Will
you send me a newer \s-1PPM\s0?
.PP
\&\fBA:\fR Probably not, unless I get lots of extra time. But there's no reason you
can't install the version from \s-1CPAN\s0. Archive::Zip is pure Perl, so all you need is
\&\s-1NMAKE\s0, which you can get for free from Microsoft (see the \s-1FAQ\s0 in the
ActiveState documentation for details on how to install \s-1CPAN\s0 modules).
.SH "My JPEGs (or MP3's) don't compress when I put them into Zips!"
.IX Header "My JPEGs (or MP3's) don't compress when I put them into Zips!"
\&\fBQ:\fR How come my JPEGs and \s-1MP3\s0's don't compress much when I put them into Zips?
.PP
\&\fBA:\fR Because they're already compressed.
.SH "Under Windows, things lock up/get damaged"
.IX Header "Under Windows, things lock up/get damaged"
\&\fBQ:\fR I'm using Windows. When I try to use Archive::Zip, my machine locks up/makes
funny sounds/displays a BSOD/corrupts data. How can I fix this?
.PP
\&\fBA:\fR First, try the newest version of Compress::Raw::Zlib. I know of
Windows-related problems prior to v1.14 of that library.
.PP
If that doesn't get rid of the problem, fix your computer or get rid of
Windows.
.SH "Zip contents in a scalar"
.IX Header "Zip contents in a scalar"
\&\fBQ:\fR I want to read a Zip file from (or write one to) a scalar variable instead
of a file. How can I do this?
.PP
\&\fBA:\fR Use \f(CW\*(C`IO::String\*(C'\fR and the \f(CW\*(C`readFromFileHandle()\*(C'\fR and
\&\f(CW\*(C`writeToFileHandle()\*(C'\fR methods.
See \f(CW\*(C`examples/readScalar.pl\*(C'\fR and \f(CW\*(C`examples/writeScalar.pl\*(C'\fR.
.SH "Reading from streams"
.IX Header "Reading from streams"
\&\fBQ:\fR How do I read from a stream (like for the Info-Zip \f(CW\*(C`funzip\*(C'\fR program)?
.PP
\&\fBA:\fR	This isn't currently supported, though writing to a stream is.
                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::FAQ5.18.3pm                    0100644 0001750 0001750 00000047421 12566241430 024564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::FAQ 3"
.TH Archive::Zip::FAQ 3 "2013-12-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::FAQ \- Answers to a few frequently asked questions about Archive::Zip
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It seems that I keep answering the same questions over and over again. I
assume that this is because my documentation is deficient, rather than that
people don't read the documentation.
.PP
So this \s-1FAQ\s0 is an attempt to cut down on the number of personal answers I have
to give. At least I can now say "You \fIdid\fR read the \s-1FAQ,\s0 right?".
.PP
The questions are not in any particular order. The answers assume the current
version of Archive::Zip; some of the answers depend on newly added/fixed
functionality.
.SH "Install problems on RedHat 8 or 9 with Perl 5.8.0"
.IX Header "Install problems on RedHat 8 or 9 with Perl 5.8.0"
\&\fBQ:\fR Archive::Zip won't install on my RedHat 9 system! It's broke!
.PP
\&\fBA:\fR This has become something of a \s-1FAQ.\s0
Basically, RedHat broke some versions of Perl by setting \s-1LANG\s0 to \s-1UTF8.\s0
They apparently have a fixed version out as an update.
.PP
You might try running \s-1CPAN\s0 or creating your Makefile after exporting the \s-1LANG\s0
environment variable as
.PP
\&\f(CW\*(C`LANG=C\*(C'\fR
.PP
<https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=87682>
.SH "Why is my zip file so big?"
.IX Header "Why is my zip file so big?"
\&\fBQ:\fR My zip file is actually bigger than what I stored in it! Why?
.PP
\&\fBA:\fR Some things to make sure of:
.IP "Make sure that you are requesting \s-1COMPRESSION_DEFLATED\s0 if you are storing strings." 4
.IX Item "Make sure that you are requesting COMPRESSION_DEFLATED if you are storing strings."
\&\f(CW$member\fR\->desiredCompressionMethod( \s-1COMPRESSION_DEFLATED \s0);
.IP "Don't make lots of little files if you can help it." 4
.IX Item "Don't make lots of little files if you can help it."
Since zip computes the compression tables for each member, small
members without much entropy won't compress well.  Instead, if you've
got lots of repeated strings in your data, try to combine them into
one big member.
.IP "Make sure that you are requesting \s-1COMPRESSION_STORED\s0 if you are storing things that are already compressed." 4
.IX Item "Make sure that you are requesting COMPRESSION_STORED if you are storing things that are already compressed."
If you're storing a .zip, .jpg, .mp3, or other compressed file in a zip,
then don't compress them again. They'll get bigger.
.SH "Sample code?"
.IX Header "Sample code?"
\&\fBQ:\fR Can you send me code to do (whatever)?
.PP
\&\fBA:\fR Have you looked in the \f(CW\*(C`examples/\*(C'\fR directory yet? It contains:
.IP "examples/calcSizes.pl    \*(-- How to find out how big a Zip file will be before writing it" 4
.IX Item "examples/calcSizes.pl How to find out how big a Zip file will be before writing it"
.PD 0
.IP "examples/copy.pl         \*(-- Copies one Zip file to another" 4
.IX Item "examples/copy.pl Copies one Zip file to another"
.IP "examples/extract.pl      \*(-- extract file(s) from a Zip" 4
.IX Item "examples/extract.pl extract file(s) from a Zip"
.IP "examples/mailZip.pl      \*(-- make and mail a zip file" 4
.IX Item "examples/mailZip.pl make and mail a zip file"
.IP "examples/mfh.pl          \*(-- demo for use of MockFileHandle" 4
.IX Item "examples/mfh.pl demo for use of MockFileHandle"
.IP "examples/readScalar.pl   \*(-- shows how to use IO::Scalar as the source of a Zip read" 4
.IX Item "examples/readScalar.pl shows how to use IO::Scalar as the source of a Zip read"
.IP "examples/selfex.pl       \*(-- a brief example of a self-extracting Zip" 4
.IX Item "examples/selfex.pl a brief example of a self-extracting Zip"
.IP "examples/unzipAll.pl     \*(-- uses Archive::Zip::Tree to unzip an entire Zip" 4
.IX Item "examples/unzipAll.pl uses Archive::Zip::Tree to unzip an entire Zip"
.IP "examples/updateZip.pl    \*(-- shows how to read/modify/write a Zip" 4
.IX Item "examples/updateZip.pl shows how to read/modify/write a Zip"
.IP "examples/updateTree.pl   \*(-- shows how to update a Zip in place" 4
.IX Item "examples/updateTree.pl shows how to update a Zip in place"
.IP "examples/writeScalar.pl  \*(-- shows how to use IO::Scalar as the destination of a Zip write" 4
.IX Item "examples/writeScalar.pl shows how to use IO::Scalar as the destination of a Zip write"
.IP "examples/writeScalar2.pl \*(-- shows how to use IO::String as the destination of a Zip write" 4
.IX Item "examples/writeScalar2.pl shows how to use IO::String as the destination of a Zip write"
.IP "examples/zip.pl          \*(-- Constructs a Zip file" 4
.IX Item "examples/zip.pl Constructs a Zip file"
.IP "examples/zipcheck.pl     \*(-- One way to check a Zip file for validity" 4
.IX Item "examples/zipcheck.pl One way to check a Zip file for validity"
.IP "examples/zipinfo.pl      \*(-- Prints out information about a Zip archive file" 4
.IX Item "examples/zipinfo.pl Prints out information about a Zip archive file"
.IP "examples/zipGrep.pl      \*(-- Searches for text in Zip files" 4
.IX Item "examples/zipGrep.pl Searches for text in Zip files"
.IP "examples/ziptest.pl      \*(-- Lists a Zip file and checks member CRCs" 4
.IX Item "examples/ziptest.pl Lists a Zip file and checks member CRCs"
.IP "examples/ziprecent.pl    \*(-- Puts recent files into a zipfile" 4
.IX Item "examples/ziprecent.pl Puts recent files into a zipfile"
.IP "examples/ziptest.pl      \*(-- Another way to check a Zip file for validity" 4
.IX Item "examples/ziptest.pl Another way to check a Zip file for validity"
.PD
.SH "Can't Read/modify/write same Zip file"
.IX Header "Can't Read/modify/write same Zip file"
\&\fBQ:\fR Why can't I open a Zip file, add a member, and write it back? I get an
error message when I try.
.PP
\&\fBA:\fR Because Archive::Zip doesn't (and can't, generally) read file contents into memory,
the original Zip file is required to stay around until the writing of the new
file is completed.
.PP
The best way to do this is to write the Zip to a temporary file and then
rename the temporary file to have the old name (possibly after deleting the
old one).
.PP
Archive::Zip v1.02 added the archive methods \f(CW\*(C`overwrite()\*(C'\fR and
\&\f(CW\*(C`overwriteAs()\*(C'\fR to do this simply and carefully.
.PP
See \f(CW\*(C`examples/updateZip.pl\*(C'\fR for an example of this technique.
.SH "File creation time not set"
.IX Header "File creation time not set"
\&\fBQ:\fR Upon extracting files, I see that their modification (and access) times are
set to the time in the Zip archive. However, their creation time is not set to
the same time. Why?
.PP
\&\fBA:\fR Mostly because Perl doesn't give cross-platform access to \fIcreation time\fR.
Indeed, many systems (like Unix) don't support such a concept.
However, if yours does, you can easily set it. Get the modification time from
the member using \f(CW\*(C`lastModTime()\*(C'\fR.
.SH "Can't use Archive::Zip on gzip files"
.IX Header "Can't use Archive::Zip on gzip files"
\&\fBQ:\fR Can I use Archive::Zip to extract Unix gzip files?
.PP
\&\fBA:\fR No.
.PP
There is a distinction between Unix gzip files, and Zip archives that 
also can use the gzip compression.
.PP
Depending on the format of the gzip file, you can use Compress::Raw::Zlib, or
Archive::Tar to decompress it (and de-archive it in the case of Tar files).
.PP
You can unzip PKZIP/WinZip/etc/ archives using Archive::Zip (that's what 
it's for) as long as any compressed members are compressed using 
Deflate compression.
.SH "Add a directory/tree to a Zip"
.IX Header "Add a directory/tree to a Zip"
\&\fBQ:\fR How can I add a directory (or tree) full of files to a Zip?
.PP
\&\fBA:\fR You can use the Archive::Zip::addTree*() methods:
.PP
.Vb 10
\&   use Archive::Zip;
\&   my $zip = Archive::Zip\->new();
\&   # add all readable files and directories below . as xyz/*
\&   $zip\->addTree( \*(Aq.\*(Aq, \*(Aqxyz\*(Aq ); 
\&   # add all readable plain files below /abc as def/*
\&   $zip\->addTree( \*(Aq/abc\*(Aq, \*(Aqdef\*(Aq, sub { \-f && \-r } );    
\&   # add all .c files below /tmp as stuff/*
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.c$\*(Aq );
\&   # add all .o files below /tmp as stuff/* if they aren\*(Aqt writable
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { ! \-w } );
\&   # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
\&   $zip\->addTreeMatching( \*(Aq/tmp\*(Aq, \*(Aqstuff\*(Aq, \*(Aq\e.o$\*(Aq, sub { \-s < 200 } );
\&   # and write them into a file
\&   $zip\->writeToFileNamed(\*(Aqxxx.zip\*(Aq);
.Ve
.SH "Extract a directory/tree"
.IX Header "Extract a directory/tree"
\&\fBQ:\fR How can I extract some (or all) files from a Zip into a different
directory?
.PP
\&\fBA:\fR You can use the \fIArchive::Zip::extractTree()\fR method:
??? ||
.PP
.Vb 2
\&   # now extract the same files into /tmpx
\&   $zip\->extractTree( \*(Aqstuff\*(Aq, \*(Aq/tmpx\*(Aq );
.Ve
.SH "Update a directory/tree"
.IX Header "Update a directory/tree"
\&\fBQ:\fR How can I update a Zip from a directory tree, adding or replacing only
the newer files?
.PP
\&\fBA:\fR You can use the \fIArchive::Zip::updateTree()\fR method that was added in version 1.09.
.SH "Zip times might be off by 1 second"
.IX Header "Zip times might be off by 1 second"
\&\fBQ:\fR It bothers me greatly that my file times are wrong by one second about half
the time. Why don't you do something about it?
.PP
\&\fBA:\fR Get over it. This is a result of the Zip format storing times in \s-1DOS\s0
format, which has a resolution of only two seconds.
.SH "Zip times don't include time zone information"
.IX Header "Zip times don't include time zone information"
\&\fBQ:\fR My file times don't respect time zones. What gives?
.PP
\&\fBA:\fR If this is important to you, please submit patches to read the various
Extra Fields that encode times with time zones. I'm just using the \s-1DOS\s0
Date/Time, which doesn't have a time zone.
.SH "How do I make a self-extracting Zip"
.IX Header "How do I make a self-extracting Zip"
\&\fBQ:\fR I want to make a self-extracting Zip file. Can I do this?
.PP
\&\fBA:\fR Yes. You can write a self-extracting archive stub (that is, a version of
unzip) to the output filehandle that you pass to \fIwriteToFileHandle()\fR. See
examples/selfex.pl for how to write a self-extracting archive.
.PP
However, you should understand that this will only work on one kind of
platform (the one for which the stub was compiled).
.SH "How can I deal with Zips with prepended garbage (i.e. from Sircam)"
.IX Header "How can I deal with Zips with prepended garbage (i.e. from Sircam)"
\&\fBQ:\fR How can I tell if a Zip has been damaged by adding garbage to the
beginning or inside the file?
.PP
\&\fBA:\fR I added code for this for the Amavis virus scanner. You can query archives
for their 'eocdOffset' property, which should be 0:
.PP
.Vb 2
\&  if ($zip\->eocdOffset > 0)
\&    { warn($zip\->eocdOffset . " bytes of garbage at beginning or within Zip") }
.Ve
.PP
When members are extracted, this offset will be used to adjust the start of
the member if necessary.
.SH "Can't extract Shrunk files"
.IX Header "Can't extract Shrunk files"
\&\fBQ:\fR I'm trying to extract a file out of a Zip produced by \s-1PKZIP,\s0 and keep
getting this error message:
.PP
.Vb 1
\&  error: Unsupported compression combination: read 6, write 0
.Ve
.PP
\&\fBA:\fR You can't uncompress this archive member. Archive::Zip only supports uncompressed
members, and compressed members that are compressed using the compression
supported by Compress::Raw::Zlib. That means only Deflated and Stored members.
.PP
Your file is compressed using the Shrink format, which is not supported by
Compress::Raw::Zlib.
.PP
You could, perhaps, use a command-line UnZip program (like the Info-Zip
one) to extract this.
.SH "Can't do decryption"
.IX Header "Can't do decryption"
\&\fBQ:\fR How do I decrypt encrypted Zip members?
.PP
\&\fBA:\fR With some other program or library. Archive::Zip doesn't support decryption,
and probably never will (unless \fIyou\fR write it).
.SH "How to test file integrity?"
.IX Header "How to test file integrity?"
\&\fBQ:\fR How can Archive::Zip can test the validity of a Zip file?
.PP
\&\fBA:\fR If you try to decompress the file, the gzip streams will report errors 
if you have garbage. Most of the time.
.PP
If you try to open the file and a central directory structure can't be 
found, an error will be reported.
.PP
When a file is being read, if we can't find a proper \s-1PK..\s0 signature in 
the right places we report a format error.
.PP
If there is added garbage at the beginning of a Zip file (as inserted 
by some viruses), you can find out about it, but Archive::Zip will ignore it, 
and you can still use the archive. When it gets written back out the 
added stuff will be gone.
.PP
There are two ready-to-use utilities in the examples directory that can
be used to test file integrity, or that you can use as examples
for your own code:
.IP "examples/zipcheck.pl shows how to use an attempted extraction to test a file." 4
.IX Item "examples/zipcheck.pl shows how to use an attempted extraction to test a file."
.PD 0
.IP "examples/ziptest.pl shows how to test CRCs in a file." 4
.IX Item "examples/ziptest.pl shows how to test CRCs in a file."
.PD
.SH "Duplicate files in Zip?"
.IX Header "Duplicate files in Zip?"
\&\fBQ:\fR Archive::Zip let me put the same file in my Zip twice! Why don't you prevent this?
.PP
\&\fBA:\fR As far as I can tell, this is not disallowed by the Zip spec. If you
think it's a bad idea, check for it yourself:
.PP
.Vb 1
\&  $zip\->addFile($someFile, $someName) unless $zip\->memberNamed($someName);
.Ve
.PP
I can even imagine cases where this might be useful (for instance, multiple
versions of files).
.SH "File ownership/permissions/ACLS/etc"
.IX Header "File ownership/permissions/ACLS/etc"
\&\fBQ:\fR Why doesn't Archive::Zip deal with file ownership, ACLs, etc.?
.PP
\&\fBA:\fR There is no standard way to represent these in the Zip file format. If
you want to send me code to properly handle the various extra fields that
have been used to represent these through the years, I'll look at it.
.SH "I can't compile but ActiveState only has an old version of Archive::Zip"
.IX Header "I can't compile but ActiveState only has an old version of Archive::Zip"
\&\fBQ:\fR I've only installed modules using ActiveState's \s-1PPM\s0 program and
repository. But they have a much older version of Archive::Zip than is in \s-1CPAN.\s0 Will
you send me a newer \s-1PPM\s0?
.PP
\&\fBA:\fR Probably not, unless I get lots of extra time. But there's no reason you
can't install the version from \s-1CPAN.\s0 Archive::Zip is pure Perl, so all you need is
\&\s-1NMAKE,\s0 which you can get for free from Microsoft (see the \s-1FAQ\s0 in the
ActiveState documentation for details on how to install \s-1CPAN\s0 modules).
.SH "My JPEGs (or MP3's) don't compress when I put them into Zips!"
.IX Header "My JPEGs (or MP3's) don't compress when I put them into Zips!"
\&\fBQ:\fR How come my JPEGs and \s-1MP3\s0's don't compress much when I put them into Zips?
.PP
\&\fBA:\fR Because they're already compressed.
.SH "Under Windows, things lock up/get damaged"
.IX Header "Under Windows, things lock up/get damaged"
\&\fBQ:\fR I'm using Windows. When I try to use Archive::Zip, my machine locks up/makes
funny sounds/displays a BSOD/corrupts data. How can I fix this?
.PP
\&\fBA:\fR First, try the newest version of Compress::Raw::Zlib. I know of
Windows-related problems prior to v1.14 of that library.
.SH "Zip contents in a scalar"
.IX Header "Zip contents in a scalar"
\&\fBQ:\fR I want to read a Zip file from (or write one to) a scalar variable instead
of a file. How can I do this?
.PP
\&\fBA:\fR Use \f(CW\*(C`IO::String\*(C'\fR and the \f(CW\*(C`readFromFileHandle()\*(C'\fR and
\&\f(CW\*(C`writeToFileHandle()\*(C'\fR methods.
See \f(CW\*(C`examples/readScalar.pl\*(C'\fR and \f(CW\*(C`examples/writeScalar.pl\*(C'\fR.
.SH "Reading from streams"
.IX Header "Reading from streams"
\&\fBQ:\fR How do I read from a stream (like for the Info-Zip \f(CW\*(C`funzip\*(C'\fR program)?
.PP
\&\fBA:\fR This is not currently supported, though writing to a stream is.
                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::MemberRead.3pm                 0100644 0001750 0001750 00000020532 12566241430 025636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::MemberRead 3"
.TH Archive::Zip::MemberRead 3 "2014-01-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::MemberRead \- A wrapper that lets you read Zip archive members as if they were files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use Archive::Zip;
\&  use Archive::Zip::MemberRead;
\&  $zip = Archive::Zip\->new("file.zip");
\&  $fh  = Archive::Zip::MemberRead\->new($zip, "subdir/abc.txt");
\&  while (defined($line = $fh\->getline()))
\&  {
\&      print $fh\->input_line_number . "#: $line\en";
\&  }
\&
\&  $read = $fh\->read($buffer, 32*1024);
\&  print "Read $read bytes as :$buffer:\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Archive::Zip::MemberRead module lets you read Zip archive member data
just like you read data from files.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fIArchive::Zip::Member::readFileHandle()\fR" 4
.IX Item "Archive::Zip::Member::readFileHandle()"
You can get a \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR from an archive member by
calling \f(CW\*(C`readFileHandle()\*(C'\fR:
.Sp
.Vb 7
\&  my $member = $zip\->memberNamed(\*(Aqabc/def.c\*(Aq);
\&  my $fh = $member\->readFileHandle();
\&  while (defined($line = $fh\->getline()))
\&  {
\&      # ...
\&  }
\&  $fh\->close();
.Ve
.ie n .IP "Archive::Zip::MemberRead\->new($zip, $fileName)" 4
.el .IP "Archive::Zip::MemberRead\->new($zip, \f(CW$fileName\fR)" 4
.IX Item "Archive::Zip::MemberRead->new($zip, $fileName)"
.PD 0
.ie n .IP "Archive::Zip::MemberRead\->new($zip, $member)" 4
.el .IP "Archive::Zip::MemberRead\->new($zip, \f(CW$member\fR)" 4
.IX Item "Archive::Zip::MemberRead->new($zip, $member)"
.IP "Archive::Zip::MemberRead\->new($member)" 4
.IX Item "Archive::Zip::MemberRead->new($member)"
.PD
Construct a new Archive::Zip::MemberRead on the specified member.
.Sp
.Vb 1
\&  my $fh = Archive::Zip::MemberRead\->new($zip, \*(Aqfred.c\*(Aq)
.Ve
.IP "setLineEnd(expr)" 4
.IX Item "setLineEnd(expr)"
Set the line end character to use. This is set to \en by default
except on Windows systems where it is set to \er\en. You will
only need to set this on systems which are not Windows or Unix
based and require a line end different from \en.
This is a class method so call as \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR\->\f(CW\*(C`setLineEnd($nl)\*(C'\fR
.IP "\fIrewind()\fR" 4
.IX Item "rewind()"
Rewinds an \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR so that you can read from it again
starting at the beginning.
.IP "input_record_separator(expr)" 4
.IX Item "input_record_separator(expr)"
If the argument is given, input_record_separator for this
instance is set to it. The current setting (which may be
the global $/) is always returned.
.IP "\fIinput_line_number()\fR" 4
.IX Item "input_line_number()"
Returns the current line number, but only if you're using \f(CW\*(C`getline()\*(C'\fR.
Using \f(CW\*(C`read()\*(C'\fR will not update the line number.
.IP "\fIclose()\fR" 4
.IX Item "close()"
Closes the given file handle.
.ie n .IP "buffer_size([ $size ])" 4
.el .IP "buffer_size([ \f(CW$size\fR ])" 4
.IX Item "buffer_size([ $size ])"
Gets or sets the buffer size used for reads.
Default is the chunk size used by Archive::Zip.
.IP "\fIgetline()\fR" 4
.IX Item "getline()"
Returns the next line from the currently open member.
Makes sense only for text files.
A read error is considered fatal enough to die.
Returns undef on eof. All subsequent calls would return undef,
unless a \fIrewind()\fR is called.
Note: The line returned has the input_record_separator (default: newline) removed.
.IP "getline( { preserve_line_ending => 1 } )" 4
.IX Item "getline( { preserve_line_ending => 1 } )"
Returns the next line including the line ending.
.ie n .IP "read($buffer, $num_bytes_to_read)" 4
.el .IP "read($buffer, \f(CW$num_bytes_to_read\fR)" 4
.IX Item "read($buffer, $num_bytes_to_read)"
Simulates a normal \f(CW\*(C`read()\*(C'\fR system call.
Returns the no. of bytes read. \f(CW\*(C`undef\*(C'\fR on error, 0 on eof, \fIe.g.\fR:
.Sp
.Vb 9
\&  $fh = Archive::Zip::MemberRead\->new($zip, "sreeji/secrets.bin");
\&  while (1)
\&  {
\&    $read = $fh\->read($buffer, 1024);
\&    die "FATAL ERROR reading my secrets !\en" if (!defined($read));
\&    last if (!$read);
\&    # Do processing.
\&    ....
\&   }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Sreeji K. Das <sreeji_k@yahoo.com>
.PP
See Archive::Zip by Ned Konz without which this module does not make
any sense!
.PP
Minor mods by Ned Konz.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 Sreeji K. Das.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::MemberRead5.16.3pm             0100644 0001750 0001750 00000017757 12566241430 026167  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::MemberRead 3"
.TH Archive::Zip::MemberRead 3 "2009-06-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::MemberRead \- A wrapper that lets you read Zip archive members as if they were files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use Archive::Zip;
\&  use Archive::Zip::MemberRead;
\&  $zip = Archive::Zip\->new("file.zip");
\&  $fh  = Archive::Zip::MemberRead\->new($zip, "subdir/abc.txt");
\&  while (defined($line = $fh\->getline()))
\&  {
\&      print $fh\->input_line_number . "#: $line\en";
\&  }
\&
\&  $read = $fh\->read($buffer, 32*1024);
\&  print "Read $read bytes as :$buffer:\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Archive::Zip::MemberRead module lets you read Zip archive member data
just like you read data from files.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fIArchive::Zip::Member::readFileHandle()\fR" 4
.IX Item "Archive::Zip::Member::readFileHandle()"
You can get a \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR from an archive member by
calling \f(CW\*(C`readFileHandle()\*(C'\fR:
.Sp
.Vb 7
\&  my $member = $zip\->memberNamed(\*(Aqabc/def.c\*(Aq);
\&  my $fh = $member\->readFileHandle();
\&  while (defined($line = $fh\->getline()))
\&  {
\&      # ...
\&  }
\&  $fh\->close();
.Ve
.ie n .IP "Archive::Zip::MemberRead\->new($zip, $fileName)" 4
.el .IP "Archive::Zip::MemberRead\->new($zip, \f(CW$fileName\fR)" 4
.IX Item "Archive::Zip::MemberRead->new($zip, $fileName)"
.PD 0
.ie n .IP "Archive::Zip::MemberRead\->new($zip, $member)" 4
.el .IP "Archive::Zip::MemberRead\->new($zip, \f(CW$member\fR)" 4
.IX Item "Archive::Zip::MemberRead->new($zip, $member)"
.IP "Archive::Zip::MemberRead\->new($member)" 4
.IX Item "Archive::Zip::MemberRead->new($member)"
.PD
Construct a new Archive::Zip::MemberRead on the specified member.
.Sp
.Vb 1
\&  my $fh = Archive::Zip::MemberRead\->new($zip, \*(Aqfred.c\*(Aq)
.Ve
.IP "setLineEnd(expr)" 4
.IX Item "setLineEnd(expr)"
Set the line end character to use. This is set to \en by default
except on Windows systems where it is set to \er\en. You will
only need to set this on systems which are not Windows or Unix
based and require a line end diffrent from \en.
This is a class method so call as \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR\->\f(CW\*(C`setLineEnd($nl)\*(C'\fR
.IP "\fIrewind()\fR" 4
.IX Item "rewind()"
Rewinds an \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR so that you can read from it again
starting at the beginning.
.IP "input_record_separator(expr)" 4
.IX Item "input_record_separator(expr)"
If the argumnet is given, input_record_separator for this
instance is set to it. The current setting (which may be
the global $/) is always returned.
.IP "\fIinput_line_number()\fR" 4
.IX Item "input_line_number()"
Returns the current line number, but only if you're using \f(CW\*(C`getline()\*(C'\fR.
Using \f(CW\*(C`read()\*(C'\fR will not update the line number.
.IP "\fIclose()\fR" 4
.IX Item "close()"
Closes the given file handle.
.ie n .IP "buffer_size([ $size ])" 4
.el .IP "buffer_size([ \f(CW$size\fR ])" 4
.IX Item "buffer_size([ $size ])"
Gets or sets the buffer size used for reads.
Default is the chunk size used by Archive::Zip.
.IP "\fIgetline()\fR" 4
.IX Item "getline()"
Returns the next line from the currently open member.
Makes sense only for text files.
A read error is considered fatal enough to die.
Returns undef on eof. All subsequent calls would return undef,
unless a \fIrewind()\fR is called.
Note: The line returned has the input_record_separator (default: newline) removed.
.ie n .IP "read($buffer, $num_bytes_to_read)" 4
.el .IP "read($buffer, \f(CW$num_bytes_to_read\fR)" 4
.IX Item "read($buffer, $num_bytes_to_read)"
Simulates a normal \f(CW\*(C`read()\*(C'\fR system call.
Returns the no. of bytes read. \f(CW\*(C`undef\*(C'\fR on error, 0 on eof, \fIe.g.\fR:
.Sp
.Vb 9
\&  $fh = Archive::Zip::MemberRead\->new($zip, "sreeji/secrets.bin");
\&  while (1)
\&  {
\&    $read = $fh\->read($buffer, 1024);
\&    die "FATAL ERROR reading my secrets !\en" if (!defined($read));
\&    last if (!$read);
\&    # Do processing.
\&    ....
\&   }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Sreeji K. Das, <sreeji_k@yahoo.com>
See Archive::Zip by Ned Konz without which this module does not make
any sense!
.PP
Minor mods by Ned Konz.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 Sreeji K. Das.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::MemberRead5.18.3pm             0100644 0001750 0001750 00000020532 12566241430 026152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::MemberRead 3"
.TH Archive::Zip::MemberRead 3 "2014-01-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::MemberRead \- A wrapper that lets you read Zip archive members as if they were files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use Archive::Zip;
\&  use Archive::Zip::MemberRead;
\&  $zip = Archive::Zip\->new("file.zip");
\&  $fh  = Archive::Zip::MemberRead\->new($zip, "subdir/abc.txt");
\&  while (defined($line = $fh\->getline()))
\&  {
\&      print $fh\->input_line_number . "#: $line\en";
\&  }
\&
\&  $read = $fh\->read($buffer, 32*1024);
\&  print "Read $read bytes as :$buffer:\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Archive::Zip::MemberRead module lets you read Zip archive member data
just like you read data from files.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fIArchive::Zip::Member::readFileHandle()\fR" 4
.IX Item "Archive::Zip::Member::readFileHandle()"
You can get a \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR from an archive member by
calling \f(CW\*(C`readFileHandle()\*(C'\fR:
.Sp
.Vb 7
\&  my $member = $zip\->memberNamed(\*(Aqabc/def.c\*(Aq);
\&  my $fh = $member\->readFileHandle();
\&  while (defined($line = $fh\->getline()))
\&  {
\&      # ...
\&  }
\&  $fh\->close();
.Ve
.ie n .IP "Archive::Zip::MemberRead\->new($zip, $fileName)" 4
.el .IP "Archive::Zip::MemberRead\->new($zip, \f(CW$fileName\fR)" 4
.IX Item "Archive::Zip::MemberRead->new($zip, $fileName)"
.PD 0
.ie n .IP "Archive::Zip::MemberRead\->new($zip, $member)" 4
.el .IP "Archive::Zip::MemberRead\->new($zip, \f(CW$member\fR)" 4
.IX Item "Archive::Zip::MemberRead->new($zip, $member)"
.IP "Archive::Zip::MemberRead\->new($member)" 4
.IX Item "Archive::Zip::MemberRead->new($member)"
.PD
Construct a new Archive::Zip::MemberRead on the specified member.
.Sp
.Vb 1
\&  my $fh = Archive::Zip::MemberRead\->new($zip, \*(Aqfred.c\*(Aq)
.Ve
.IP "setLineEnd(expr)" 4
.IX Item "setLineEnd(expr)"
Set the line end character to use. This is set to \en by default
except on Windows systems where it is set to \er\en. You will
only need to set this on systems which are not Windows or Unix
based and require a line end different from \en.
This is a class method so call as \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR\->\f(CW\*(C`setLineEnd($nl)\*(C'\fR
.IP "\fIrewind()\fR" 4
.IX Item "rewind()"
Rewinds an \f(CW\*(C`Archive::Zip::MemberRead\*(C'\fR so that you can read from it again
starting at the beginning.
.IP "input_record_separator(expr)" 4
.IX Item "input_record_separator(expr)"
If the argument is given, input_record_separator for this
instance is set to it. The current setting (which may be
the global $/) is always returned.
.IP "\fIinput_line_number()\fR" 4
.IX Item "input_line_number()"
Returns the current line number, but only if you're using \f(CW\*(C`getline()\*(C'\fR.
Using \f(CW\*(C`read()\*(C'\fR will not update the line number.
.IP "\fIclose()\fR" 4
.IX Item "close()"
Closes the given file handle.
.ie n .IP "buffer_size([ $size ])" 4
.el .IP "buffer_size([ \f(CW$size\fR ])" 4
.IX Item "buffer_size([ $size ])"
Gets or sets the buffer size used for reads.
Default is the chunk size used by Archive::Zip.
.IP "\fIgetline()\fR" 4
.IX Item "getline()"
Returns the next line from the currently open member.
Makes sense only for text files.
A read error is considered fatal enough to die.
Returns undef on eof. All subsequent calls would return undef,
unless a \fIrewind()\fR is called.
Note: The line returned has the input_record_separator (default: newline) removed.
.IP "getline( { preserve_line_ending => 1 } )" 4
.IX Item "getline( { preserve_line_ending => 1 } )"
Returns the next line including the line ending.
.ie n .IP "read($buffer, $num_bytes_to_read)" 4
.el .IP "read($buffer, \f(CW$num_bytes_to_read\fR)" 4
.IX Item "read($buffer, $num_bytes_to_read)"
Simulates a normal \f(CW\*(C`read()\*(C'\fR system call.
Returns the no. of bytes read. \f(CW\*(C`undef\*(C'\fR on error, 0 on eof, \fIe.g.\fR:
.Sp
.Vb 9
\&  $fh = Archive::Zip::MemberRead\->new($zip, "sreeji/secrets.bin");
\&  while (1)
\&  {
\&    $read = $fh\->read($buffer, 1024);
\&    die "FATAL ERROR reading my secrets !\en" if (!defined($read));
\&    last if (!$read);
\&    # Do processing.
\&    ....
\&   }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Sreeji K. Das <sreeji_k@yahoo.com>
.PP
See Archive::Zip by Ned Konz without which this module does not make
any sense!
.PP
Minor mods by Ned Konz.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 Sreeji K. Das.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::Tree.3pm                       0100644 0001750 0001750 00000011107 12566241430 024530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::Tree 3"
.TH Archive::Zip::Tree 3 "2014-01-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::Tree \- (DEPRECATED) methods for adding/extracting trees using Archive::Zip
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is deprecated, because all its methods were moved into the main
Archive::Zip module.
.PP
It is included in the distribution merely to avoid breaking old code.
.PP
See Archive::Zip.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ned Konz, perl@bike\-nomad.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2002 Ned Konz. All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms
as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Archive::Zip
                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::Tree5.16.3pm                   0100644 0001750 0001750 00000010633 12566241430 025045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::Tree 3"
.TH Archive::Zip::Tree 3 "2009-06-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::Tree \- (DEPRECATED) methods for adding/extracting trees using Archive::Zip
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is deprecated, because all its methods were moved into the main
Archive::Zip module.
.PP
It is included in the distribution merely to avoid breaking old code.
.PP
See Archive::Zip.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ned Konz, perl@bike\-nomad.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2002 Ned Konz. All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms
as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Archive::Zip
                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Archive::Zip::Tree5.18.3pm                   0100644 0001750 0001750 00000011107 12566241430 025044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Archive::Zip::Tree 3"
.TH Archive::Zip::Tree 3 "2014-01-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Archive::Zip::Tree \- (DEPRECATED) methods for adding/extracting trees using Archive::Zip
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is deprecated, because all its methods were moved into the main
Archive::Zip module.
.PP
It is included in the distribution merely to avoid breaking old code.
.PP
See Archive::Zip.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ned Konz, perl@bike\-nomad.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2002 Ned Konz. All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms
as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Archive::Zip
                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Attribute::Handlers.3pm                      0100644 0001750 0001750 00000074356 12566207451 025130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Attribute::Handlers 3pm"
.TH Attribute::Handlers 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Attribute::Handlers \- Simpler definition of attribute handlers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.93 of Attribute::Handlers,
released July 20, 2011.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    package MyClass;
\&    require 5.006;
\&    use Attribute::Handlers;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&
\&    sub Good : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data) = @_;
\&
\&        # Invoked for any scalar variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&
\&        # Do whatever to $referent here (executed in CHECK phase).
\&        ...
\&    }
\&
\&    sub Bad : ATTR(SCALAR) {
\&        # Invoked for any scalar variable with a :Bad attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Good : ATTR(ARRAY) {
\&        # Invoked for any array variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Good : ATTR(HASH) {
\&        # Invoked for any hash variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Ugly : ATTR(CODE) {
\&        # Invoked for any subroutine declared in MyClass (or a 
\&        # derived class) with an :Ugly attribute.
\&        ...
\&    }
\&
\&    sub Omni : ATTR {
\&        # Invoked for any scalar, array, hash, or subroutine
\&        # with an :Omni attribute, provided the variable or
\&        # subroutine was declared in MyClass (or a derived class)
\&        # or the variable was typed to MyClass.
\&        # Use ref($_[2]) to determine what kind of referent it was.
\&        ...
\&    }
\&
\&
\&    use Attribute::Handlers autotie => { Cycle => Tie::Cycle };
\&
\&    my $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module, when inherited by a package, allows that package's class to
define attribute handler subroutines for specific attributes. Variables
and subroutines subsequently defined in that package, or in packages
derived from that package may be given attributes with the same names as
the attribute handler subroutines, which will then be called in one of
the compilation phases (i.e. in a \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR
block). (\f(CW\*(C`UNITCHECK\*(C'\fR blocks don't correspond to a global compilation
phase, so they can't be specified here.)
.PP
To create a handler, define it as a subroutine with the same name as
the desired attribute, and declare the subroutine itself with the  
attribute \f(CW\*(C`:ATTR\*(C'\fR. For example:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&
\&    sub Loud :ATTR {
\&        my ($package, $symbol, $referent, $attr, $data, $phase,
\&            $filename, $linenum) = @_;
\&        print STDERR
\&            ref($referent), " ",
\&            *{$symbol}{NAME}, " ",
\&            "($referent) ", "was just declared ",
\&            "and ascribed the ${attr} attribute ",
\&            "with data ($data)\en",
\&            "in phase $phase\en",
\&            "in file $filename at line $linenum\en";
\&    }
.Ve
.PP
This creates a handler for the attribute \f(CW\*(C`:Loud\*(C'\fR in the class LoudDecl.
Thereafter, any subroutine declared with a \f(CW\*(C`:Loud\*(C'\fR attribute in the class
LoudDecl:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    sub foo: Loud {...}
.Ve
.PP
causes the above handler to be invoked, and passed:
.IP "[0]" 4
.IX Item "[0]"
the name of the package into which it was declared;
.IP "[1]" 4
.IX Item "[1]"
a reference to the symbol table entry (typeglob) containing the subroutine;
.IP "[2]" 4
.IX Item "[2]"
a reference to the subroutine;
.IP "[3]" 4
.IX Item "[3]"
the name of the attribute;
.IP "[4]" 4
.IX Item "[4]"
any data associated with that attribute;
.IP "[5]" 4
.IX Item "[5]"
the name of the phase in which the handler is being invoked;
.IP "[6]" 4
.IX Item "[6]"
the filename in which the handler is being invoked;
.IP "[7]" 4
.IX Item "[7]"
the line number in this file.
.PP
Likewise, declaring any variables with the \f(CW\*(C`:Loud\*(C'\fR attribute within the
package:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    my $foo :Loud;
\&    my @foo :Loud;
\&    my %foo :Loud;
.Ve
.PP
will cause the handler to be called with a similar argument list (except,
of course, that \f(CW$_[2]\fR will be a reference to the variable).
.PP
The package name argument will typically be the name of the class into
which the subroutine was declared, but it may also be the name of a derived
class (since handlers are inherited).
.PP
If a lexical variable is given an attribute, there is no symbol table to 
which it belongs, so the symbol table argument (\f(CW$_[1]\fR) is set to the
string \f(CW\*(AqLEXICAL\*(Aq\fR in that case. Likewise, ascribing an attribute to
an anonymous subroutine results in a symbol table argument of \f(CW\*(AqANON\*(Aq\fR.
.PP
The data argument passes in the value (if any) associated with the
attribute. For example, if \f(CW&foo\fR had been declared:
.PP
.Vb 1
\&        sub foo :Loud("turn it up to 11, man!") {...}
.Ve
.PP
then a reference to an array containing the string
\&\f(CW"turn it up to 11, man!"\fR would be passed as the last argument.
.PP
Attribute::Handlers makes strenuous efforts to convert
the data argument (\f(CW$_[4]\fR) to a usable form before passing it to
the handler (but see \*(L"Non-interpretive attribute handlers\*(R").
If those efforts succeed, the interpreted data is passed in an array
reference; if they fail, the raw data is passed as a string.
For example, all of these:
.PP
.Vb 4
\&    sub foo :Loud(till=>ears=>are=>bleeding) {...}
\&    sub foo :Loud(qw/till ears are bleeding/) {...}
\&    sub foo :Loud(qw/till, ears, are, bleeding/) {...}
\&    sub foo :Loud(till,ears,are,bleeding) {...}
.Ve
.PP
causes it to pass \f(CW\*(C`[\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]\*(C'\fR as the handler's
data argument. While:
.PP
.Vb 1
\&    sub foo :Loud([\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]) {...}
.Ve
.PP
causes it to pass \f(CW\*(C`[ [\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq] ]\*(C'\fR; the array
reference specified in the data being passed inside the standard
array reference indicating successful interpretation.
.PP
However, if the data can't be parsed as valid Perl, then
it is passed as an uninterpreted string. For example:
.PP
.Vb 2
\&    sub foo :Loud(my,ears,are,bleeding) {...}
\&    sub foo :Loud(qw/my ears are bleeding) {...}
.Ve
.PP
cause the strings \f(CW\*(Aqmy,ears,are,bleeding\*(Aq\fR and
\&\f(CW\*(Aqqw/my ears are bleeding\*(Aq\fR respectively to be passed as the
data argument.
.PP
If no value is associated with the attribute, \f(CW\*(C`undef\*(C'\fR is passed.
.SS "Typed lexicals"
.IX Subsection "Typed lexicals"
Regardless of the package in which it is declared, if a lexical variable is
ascribed an attribute, the handler that is invoked is the one belonging to
the package to which it is typed. For example, the following declarations:
.PP
.Vb 1
\&    package OtherClass;
\&
\&    my LoudDecl $loudobj : Loud;
\&    my LoudDecl @loudobjs : Loud;
\&    my LoudDecl %loudobjex : Loud;
.Ve
.PP
causes the LoudDecl::Loud handler to be invoked (even if OtherClass also
defines a handler for \f(CW\*(C`:Loud\*(C'\fR attributes).
.SS "Type-specific attribute handlers"
.IX Subsection "Type-specific attribute handlers"
If an attribute handler is declared and the \f(CW\*(C`:ATTR\*(C'\fR specifier is
given the name of a built-in type (\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, or \f(CW\*(C`CODE\*(C'\fR),
the handler is only applied to declarations of that type. For example,
the following definition:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
.Ve
.PP
creates an attribute handler that applies only to scalars:
.PP
.Vb 2
\&    package Painful;
\&    use base LoudDecl;
\&
\&    my $metal : RealLoud;           # invokes &LoudDecl::RealLoud
\&    my @metal : RealLoud;           # error: unknown attribute
\&    my %metal : RealLoud;           # error: unknown attribute
\&    sub metal : RealLoud {...}      # error: unknown attribute
.Ve
.PP
You can, of course, declare separate handlers for these types as well
(but you'll need to specify \f(CW\*(C`no warnings \*(Aqredefine\*(Aq\*(C'\fR to do it quietly):
.PP
.Vb 3
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
\&    sub RealLoud :ATTR(ARRAY) { print "Urrrrrrrrrr!" }
\&    sub RealLoud :ATTR(HASH) { print "Arrrrrgggghhhhhh!" }
\&    sub RealLoud :ATTR(CODE) { croak "Real loud sub torpedoed" }
.Ve
.PP
You can also explicitly indicate that a single handler is meant to be
used for all types of referents like so:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&
\&    sub SeriousLoud :ATTR(ANY) { warn "Hearing loss imminent" }
.Ve
.PP
(I.e. \f(CW\*(C`ATTR(ANY)\*(C'\fR is a synonym for \f(CW\*(C`:ATTR\*(C'\fR).
.SS "Non-interpretive attribute handlers"
.IX Subsection "Non-interpretive attribute handlers"
Occasionally the strenuous efforts Attribute::Handlers makes to convert
the data argument (\f(CW$_[4]\fR) to a usable form before passing it to
the handler get in the way.
.PP
You can turn off that eagerness-to-help by declaring
an attribute handler with the keyword \f(CW\*(C`RAWDATA\*(C'\fR. For example:
.PP
.Vb 3
\&    sub Raw          : ATTR(RAWDATA) {...}
\&    sub Nekkid       : ATTR(SCALAR,RAWDATA) {...}
\&    sub Au::Naturale : ATTR(RAWDATA,ANY) {...}
.Ve
.PP
Then the handler makes absolutely no attempt to interpret the data it
receives and simply passes it as a string:
.PP
.Vb 1
\&    my $power : Raw(1..100);        # handlers receives "1..100"
.Ve
.SS "Phase-specific attribute handlers"
.IX Subsection "Phase-specific attribute handlers"
By default, attribute handlers are called at the end of the compilation
phase (in a \f(CW\*(C`CHECK\*(C'\fR block). This seems to be optimal in most cases because
most things that can be defined are defined by that point but nothing has
been executed.
.PP
However, it is possible to set up attribute handlers that are called at
other points in the program's compilation or execution, by explicitly
stating the phase (or phases) in which you wish the attribute handler to
be called. For example:
.PP
.Vb 5
\&    sub Early    :ATTR(SCALAR,BEGIN) {...}
\&    sub Normal   :ATTR(SCALAR,CHECK) {...}
\&    sub Late     :ATTR(SCALAR,INIT) {...}
\&    sub Final    :ATTR(SCALAR,END) {...}
\&    sub Bookends :ATTR(SCALAR,BEGIN,END) {...}
.Ve
.PP
As the last example indicates, a handler may be set up to be (re)called in
two or more phases. The phase name is passed as the handler's final argument.
.PP
Note that attribute handlers that are scheduled for the \f(CW\*(C`BEGIN\*(C'\fR phase
are handled as soon as the attribute is detected (i.e. before any
subsequently defined \f(CW\*(C`BEGIN\*(C'\fR blocks are executed).
.ie n .SS "Attributes as ""tie"" interfaces"
.el .SS "Attributes as \f(CWtie\fP interfaces"
.IX Subsection "Attributes as tie interfaces"
Attributes make an excellent and intuitive interface through which to tie
variables. For example:
.PP
.Vb 2
\&    use Attribute::Handlers;
\&    use Tie::Cycle;
\&
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
\&        tie $$referent, \*(AqTie::Cycle\*(Aq, $data;
\&    }
\&
\&    # and thereafter...
\&
\&    package main;
\&
\&    my $next : Cycle(\*(AqA\*(Aq..\*(AqZ\*(Aq);     # $next is now a tied variable
\&
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note that, because the \f(CW\*(C`Cycle\*(C'\fR attribute receives its arguments in the
\&\f(CW$data\fR variable, if the attribute is given a list of arguments, \f(CW$data\fR
will consist of a single array reference; otherwise, it will consist of the
single argument directly. Since Tie::Cycle requires its cycling values to
be passed as an array reference, this means that we need to wrap
non-array-reference arguments in an array constructor:
.PP
.Vb 1
\&    $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
.Ve
.PP
Typically, however, things are the other way around: the tieable class expects
its arguments as a flattened list, so the attribute looks like:
.PP
.Vb 5
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        my @data = ref $data eq \*(AqARRAY\*(Aq ? @$data : $data;
\&        tie $$referent, \*(AqTie::Whatever\*(Aq, @data;
\&    }
.Ve
.PP
This software pattern is so widely applicable that Attribute::Handlers
provides a way to automate it: specifying \f(CW\*(Aqautotie\*(Aq\fR in the
\&\f(CW\*(C`use Attribute::Handlers\*(C'\fR statement. So, the cycling example,
could also be written:
.PP
.Vb 1
\&    use Attribute::Handlers autotie => { Cycle => \*(AqTie::Cycle\*(Aq };
\&
\&    # and thereafter...
\&
\&    package main;
\&
\&    my $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);     # $next is now a tied variable
\&
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note that we now have to pass the cycling values as an array reference,
since the \f(CW\*(C`autotie\*(C'\fR mechanism passes \f(CW\*(C`tie\*(C'\fR a list of arguments as a list
(as in the Tie::Whatever example), \fInot\fR as an array reference (as in
the original Tie::Cycle example at the start of this section).
.PP
The argument after \f(CW\*(Aqautotie\*(Aq\fR is a reference to a hash in which each key is
the name of an attribute to be created, and each value is the class to which
variables ascribed that attribute should be tied.
.PP
Note that there is no longer any need to import the Tie::Cycle module \*(--
Attribute::Handlers takes care of that automagically. You can even pass
arguments to the module's \f(CW\*(C`import\*(C'\fR subroutine, by appending them to the
class name. For example:
.PP
.Vb 2
\&    use Attribute::Handlers
\&         autotie => { Dir => \*(AqTie::Dir qw(DIR_UNLINK)\*(Aq };
.Ve
.PP
If the attribute name is unqualified, the attribute is installed in the
current package. Otherwise it is installed in the qualifier's package:
.PP
.Vb 1
\&    package Here;
\&
\&    use Attribute::Handlers autotie => {
\&         Other::Good => Tie::SecureHash, # tie attr installed in Other::
\&                 Bad => Tie::Taxes,      # tie attr installed in Here::
\&     UNIVERSAL::Ugly => Software::Patent # tie attr installed everywhere
\&    };
.Ve
.PP
Autoties are most commonly used in the module to which they actually tie, 
and need to export their attributes to any module that calls them. To
facilitate this, Attribute::Handlers recognizes a special \*(L"pseudo-class\*(R" \*(--
\&\f(CW\*(C`_\|_CALLER_\|_\*(C'\fR, which may be specified as the qualifier of an attribute:
.PP
.Vb 1
\&    package Tie::Me::Kangaroo:Down::Sport;
\&
\&    use Attribute::Handlers autotie =>
\&         { \*(Aq_\|_CALLER_\|_::Roo\*(Aq => _\|_PACKAGE_\|_ };
.Ve
.PP
This causes Attribute::Handlers to define the \f(CW\*(C`Roo\*(C'\fR attribute in the package
that imports the Tie::Me::Kangaroo:Down::Sport module.
.PP
Note that it is important to quote the _\|_CALLER_\|_::Roo identifier because
a bug in perl 5.8 will refuse to parse it and cause an unknown error.
.PP
\fIPassing the tied object to \f(CI\*(C`tie\*(C'\fI\fR
.IX Subsection "Passing the tied object to tie"
.PP
Occasionally it is important to pass a reference to the object being tied
to the \s-1TIESCALAR, TIEHASH,\s0 etc. that ties it.
.PP
The \f(CW\*(C`autotie\*(C'\fR mechanism supports this too. The following code:
.PP
.Vb 2
\&    use Attribute::Handlers autotieref => { Selfish => Tie::Selfish };
\&    my $var : Selfish(@args);
.Ve
.PP
has the same effect as:
.PP
.Vb 1
\&    tie my $var, \*(AqTie::Selfish\*(Aq, @args;
.Ve
.PP
But when \f(CW"autotieref"\fR is used instead of \f(CW"autotie"\fR:
.PP
.Vb 2
\&    use Attribute::Handlers autotieref => { Selfish => Tie::Selfish };
\&    my $var : Selfish(@args);
.Ve
.PP
the effect is to pass the \f(CW\*(C`tie\*(C'\fR call an extra reference to the variable
being tied:
.PP
.Vb 1
\&    tie my $var, \*(AqTie::Selfish\*(Aq, \e$var, @args;
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
If the class shown in \*(L"\s-1SYNOPSIS\*(R"\s0 were placed in the MyClass.pm
module, then the following code:
.PP
.Vb 2
\&    package main;
\&    use MyClass;
\&
\&    my MyClass $slr :Good :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    package SomeOtherClass;
\&    use base MyClass;
\&
\&    sub tent { \*(Aqacle\*(Aq }
\&
\&    sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&    my @arr :Good :Omni(s/cie/nt/);
\&    my %hsh :Good(q/bye/) :Omni(q/bus/);
.Ve
.PP
would cause the following handlers to be invoked:
.PP
.Vb 1
\&    # my MyClass $slr :Good :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    MyClass::Good:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqGood\*(Aq,             # attr name
\&                                undef               # no attr data
\&                                \*(AqCHECK\*(Aq,            # compiler phase
\&                              );
\&
\&    MyClass::Bad:ATTR(SCALAR)( \*(AqMyClass\*(Aq,           # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e$slr,               # referent
\&                               \*(AqBad\*(Aq,               # attr name
\&                               0                    # eval\*(Aqd attr data
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&    MyClass::Omni:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqOmni\*(Aq,             # attr name
\&                                \*(Aq\-vorous\*(Aq           # eval\*(Aqd attr data
\&                                \*(AqCHECK\*(Aq,            # compiler phase
\&                              );
\&
\&
\&    # sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&
\&    MyClass::UGLY:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqUgly\*(Aq,               # attr name
\&                              \*(Aqsister\*(Aq              # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&    MyClass::Omni:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              [\*(Aqpo\*(Aq,\*(Aqacle\*(Aq]         # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&
\&    # my @arr :Good :Omni(s/cie/nt/);
\&
\&    MyClass::Good:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqGood\*(Aq,              # attr name
\&                               undef                # no attr data
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&    MyClass::Omni:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqOmni\*(Aq,              # attr name
\&                               ""                   # eval\*(Aqd attr data 
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&
\&    # my %hsh :Good(q/bye) :Omni(q/bus/);
\&
\&    MyClass::Good:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqGood\*(Aq,               # attr name
\&                              \*(Aqq/bye\*(Aq               # raw attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&    MyClass::Omni:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              \*(Aqbus\*(Aq                 # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
.Ve
.PP
Installing handlers into \s-1UNIVERSAL,\s0 makes them...err..universal.
For example:
.PP
.Vb 2
\&    package Descriptions;
\&    use Attribute::Handlers;
\&
\&    my %name;
\&    sub name { return $name{$_[2]}||*{$_[1]}{NAME} }
\&
\&    sub UNIVERSAL::Name :ATTR {
\&        $name{$_[2]} = $_[4];
\&    }
\&
\&    sub UNIVERSAL::Purpose :ATTR {
\&        print STDERR "Purpose of ", &name, " is $_[4]\en";
\&    }
\&
\&    sub UNIVERSAL::Unit :ATTR {
\&        print STDERR &name, " measured in $_[4]\en";
\&    }
.Ve
.PP
Let's you write:
.PP
.Vb 1
\&    use Descriptions;
\&
\&    my $capacity : Name(capacity)
\&                 : Purpose(to store max storage capacity for files)
\&                 : Unit(Gb);
\&
\&
\&    package Other;
\&
\&    sub foo : Purpose(to foo all data before barring it) { }
\&
\&    # etc.
.Ve
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
This module offers a single utility function, \f(CW\*(C`findsym()\*(C'\fR.
.IP "findsym" 4
.IX Item "findsym"
.Vb 1
\&    my $symbol = Attribute::Handlers::findsym($package, $referent);
.Ve
.Sp
The function looks in the symbol table of \f(CW$package\fR for the typeglob for
\&\f(CW$referent\fR, which is a reference to a variable or subroutine (\s-1SCALAR, ARRAY,
HASH,\s0 or \s-1CODE\s0). If it finds the typeglob, it returns it. Otherwise, it returns
undef. Note that \f(CW\*(C`findsym\*(C'\fR memoizes the typeglobs it has previously
successfully found, so subsequent calls with the same arguments should be
much faster.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Bad attribute type: ATTR(%s)""" 4
.el .IP "\f(CWBad attribute type: ATTR(%s)\fR" 4
.IX Item "Bad attribute type: ATTR(%s)"
An attribute handler was specified with an \f(CW\*(C`:ATTR(\f(CIref_type\f(CW)\*(C'\fR, but the
type of referent it was defined to handle wasn't one of the five permitted:
\&\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, or \f(CW\*(C`ANY\*(C'\fR.
.ie n .IP """Attribute handler %s doesn\*(Aqt handle %s attributes""" 4
.el .IP "\f(CWAttribute handler %s doesn\*(Aqt handle %s attributes\fR" 4
.IX Item "Attribute handler %s doesnt handle %s attributes"
A handler for attributes of the specified name \fIwas\fR defined, but not
for the specified type of declaration. Typically encountered whe trying
to apply a \f(CW\*(C`VAR\*(C'\fR attribute handler to a subroutine, or a \f(CW\*(C`SCALAR\*(C'\fR
attribute handler to some other type of variable.
.ie n .IP """Declaration of %s attribute in package %s may clash with future reserved word""" 4
.el .IP "\f(CWDeclaration of %s attribute in package %s may clash with future reserved word\fR" 4
.IX Item "Declaration of %s attribute in package %s may clash with future reserved word"
A handler for an attributes with an all-lowercase name was declared. An
attribute with an all-lowercase name might have a meaning to Perl
itself some day, even though most don't yet. Use a mixed-case attribute
name, instead.
.ie n .IP """Can\*(Aqt have two ATTR specifiers on one subroutine""" 4
.el .IP "\f(CWCan\*(Aqt have two ATTR specifiers on one subroutine\fR" 4
.IX Item "Cant have two ATTR specifiers on one subroutine"
You just can't, okay?
Instead, put all the specifications together with commas between them
in a single \f(CW\*(C`ATTR(\f(CIspecification\f(CW)\*(C'\fR.
.ie n .IP """Can\*(Aqt autotie a %s""" 4
.el .IP "\f(CWCan\*(Aqt autotie a %s\fR" 4
.IX Item "Cant autotie a %s"
You can only declare autoties for types \f(CW"SCALAR"\fR, \f(CW"ARRAY"\fR, and
\&\f(CW"HASH"\fR. They're the only things (apart from typeglobs \*(-- which are
not declarable) that Perl can tie.
.ie n .IP """Internal error: %s symbol went missing""" 4
.el .IP "\f(CWInternal error: %s symbol went missing\fR" 4
.IX Item "Internal error: %s symbol went missing"
Something is rotten in the state of the program. An attributed
subroutine ceased to exist between the point it was declared and the point
at which its attribute handler(s) would have been called.
.ie n .IP """Won\*(Aqt be able to apply END handler""" 4
.el .IP "\f(CWWon\*(Aqt be able to apply END handler\fR" 4
.IX Item "Wont be able to apply END handler"
You have defined an \s-1END\s0 handler for an attribute that is being applied
to a lexical variable.  Since the variable may not be available during \s-1END\s0
this won't happen.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org). The maintainer of this module is now Rafael
Garcia-Suarez (rgarciasuarez@gmail.com).
.PP
Maintainer of the \s-1CPAN\s0 release is Steffen Mueller (smueller@cpan.org).
Contact him with technical difficulties with respect to the packaging of the
\&\s-1CPAN\s0 module.
.SH "BUGS"
.IX Header "BUGS"
There are undoubtedly serious bugs lurking somewhere in code this funky :\-)
Bug reports and other feedback are most welcome.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\&         Copyright (c) 2001\-2009, Damian Conway. All Rights Reserved.
\&       This module is free software. It may be used, redistributed
\&           and/or modified under the same terms as Perl itself.
.Ve
                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Attribute::Handlers5.16.3pm                  0100644 0001750 0001750 00000074176 12566207430 025437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Attribute::Handlers 3pm"
.TH Attribute::Handlers 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Attribute::Handlers \- Simpler definition of attribute handlers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.93 of Attribute::Handlers,
released July 20, 2011.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    package MyClass;
\&    require 5.006;
\&    use Attribute::Handlers;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&
\&    sub Good : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data) = @_;
\&
\&        # Invoked for any scalar variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&
\&        # Do whatever to $referent here (executed in CHECK phase).
\&        ...
\&    }
\&
\&    sub Bad : ATTR(SCALAR) {
\&        # Invoked for any scalar variable with a :Bad attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Good : ATTR(ARRAY) {
\&        # Invoked for any array variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Good : ATTR(HASH) {
\&        # Invoked for any hash variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Ugly : ATTR(CODE) {
\&        # Invoked for any subroutine declared in MyClass (or a 
\&        # derived class) with an :Ugly attribute.
\&        ...
\&    }
\&
\&    sub Omni : ATTR {
\&        # Invoked for any scalar, array, hash, or subroutine
\&        # with an :Omni attribute, provided the variable or
\&        # subroutine was declared in MyClass (or a derived class)
\&        # or the variable was typed to MyClass.
\&        # Use ref($_[2]) to determine what kind of referent it was.
\&        ...
\&    }
\&
\&
\&    use Attribute::Handlers autotie => { Cycle => Tie::Cycle };
\&
\&    my $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module, when inherited by a package, allows that package's class to
define attribute handler subroutines for specific attributes. Variables
and subroutines subsequently defined in that package, or in packages
derived from that package may be given attributes with the same names as
the attribute handler subroutines, which will then be called in one of
the compilation phases (i.e. in a \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR
block). (\f(CW\*(C`UNITCHECK\*(C'\fR blocks don't correspond to a global compilation
phase, so they can't be specified here.)
.PP
To create a handler, define it as a subroutine with the same name as
the desired attribute, and declare the subroutine itself with the  
attribute \f(CW\*(C`:ATTR\*(C'\fR. For example:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&
\&    sub Loud :ATTR {
\&        my ($package, $symbol, $referent, $attr, $data, $phase,
\&            $filename, $linenum) = @_;
\&        print STDERR
\&            ref($referent), " ",
\&            *{$symbol}{NAME}, " ",
\&            "($referent) ", "was just declared ",
\&            "and ascribed the ${attr} attribute ",
\&            "with data ($data)\en",
\&            "in phase $phase\en",
\&            "in file $filename at line $linenum\en";
\&    }
.Ve
.PP
This creates a handler for the attribute \f(CW\*(C`:Loud\*(C'\fR in the class LoudDecl.
Thereafter, any subroutine declared with a \f(CW\*(C`:Loud\*(C'\fR attribute in the class
LoudDecl:
.PP
.Vb 1
\&    package LoudDecl;
\&    
\&    sub foo: Loud {...}
.Ve
.PP
causes the above handler to be invoked, and passed:
.IP "[0]" 4
.IX Item "[0]"
the name of the package into which it was declared;
.IP "[1]" 4
.IX Item "[1]"
a reference to the symbol table entry (typeglob) containing the subroutine;
.IP "[2]" 4
.IX Item "[2]"
a reference to the subroutine;
.IP "[3]" 4
.IX Item "[3]"
the name of the attribute;
.IP "[4]" 4
.IX Item "[4]"
any data associated with that attribute;
.IP "[5]" 4
.IX Item "[5]"
the name of the phase in which the handler is being invoked;
.IP "[6]" 4
.IX Item "[6]"
the filename in which the handler is being invoked;
.IP "[7]" 4
.IX Item "[7]"
the line number in this file.
.PP
Likewise, declaring any variables with the \f(CW\*(C`:Loud\*(C'\fR attribute within the
package:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    my $foo :Loud;
\&    my @foo :Loud;
\&    my %foo :Loud;
.Ve
.PP
will cause the handler to be called with a similar argument list (except,
of course, that \f(CW$_[2]\fR will be a reference to the variable).
.PP
The package name argument will typically be the name of the class into
which the subroutine was declared, but it may also be the name of a derived
class (since handlers are inherited).
.PP
If a lexical variable is given an attribute, there is no symbol table to 
which it belongs, so the symbol table argument (\f(CW$_[1]\fR) is set to the
string \f(CW\*(AqLEXICAL\*(Aq\fR in that case. Likewise, ascribing an attribute to
an anonymous subroutine results in a symbol table argument of \f(CW\*(AqANON\*(Aq\fR.
.PP
The data argument passes in the value (if any) associated with the
attribute. For example, if \f(CW&foo\fR had been declared:
.PP
.Vb 1
\&        sub foo :Loud("turn it up to 11, man!") {...}
.Ve
.PP
then a reference to an array containing the string
\&\f(CW"turn it up to 11, man!"\fR would be passed as the last argument.
.PP
Attribute::Handlers makes strenuous efforts to convert
the data argument (\f(CW$_[4]\fR) to a usable form before passing it to
the handler (but see \*(L"Non-interpretive attribute handlers\*(R").
If those efforts succeed, the interpreted data is passed in an array
reference; if they fail, the raw data is passed as a string.
For example, all of these:
.PP
.Vb 4
\&    sub foo :Loud(till=>ears=>are=>bleeding) {...}
\&    sub foo :Loud(qw/till ears are bleeding/) {...}
\&    sub foo :Loud(qw/till, ears, are, bleeding/) {...}
\&    sub foo :Loud(till,ears,are,bleeding) {...}
.Ve
.PP
causes it to pass \f(CW\*(C`[\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]\*(C'\fR as the handler's
data argument. While:
.PP
.Vb 1
\&    sub foo :Loud([\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]) {...}
.Ve
.PP
causes it to pass \f(CW\*(C`[ [\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq] ]\*(C'\fR; the array
reference specified in the data being passed inside the standard
array reference indicating successful interpretation.
.PP
However, if the data can't be parsed as valid Perl, then
it is passed as an uninterpreted string. For example:
.PP
.Vb 2
\&    sub foo :Loud(my,ears,are,bleeding) {...}
\&    sub foo :Loud(qw/my ears are bleeding) {...}
.Ve
.PP
cause the strings \f(CW\*(Aqmy,ears,are,bleeding\*(Aq\fR and
\&\f(CW\*(Aqqw/my ears are bleeding\*(Aq\fR respectively to be passed as the
data argument.
.PP
If no value is associated with the attribute, \f(CW\*(C`undef\*(C'\fR is passed.
.SS "Typed lexicals"
.IX Subsection "Typed lexicals"
Regardless of the package in which it is declared, if a lexical variable is
ascribed an attribute, the handler that is invoked is the one belonging to
the package to which it is typed. For example, the following declarations:
.PP
.Vb 1
\&    package OtherClass;
\&
\&    my LoudDecl $loudobj : Loud;
\&    my LoudDecl @loudobjs : Loud;
\&    my LoudDecl %loudobjex : Loud;
.Ve
.PP
causes the LoudDecl::Loud handler to be invoked (even if OtherClass also
defines a handler for \f(CW\*(C`:Loud\*(C'\fR attributes).
.SS "Type-specific attribute handlers"
.IX Subsection "Type-specific attribute handlers"
If an attribute handler is declared and the \f(CW\*(C`:ATTR\*(C'\fR specifier is
given the name of a built-in type (\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, or \f(CW\*(C`CODE\*(C'\fR),
the handler is only applied to declarations of that type. For example,
the following definition:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
.Ve
.PP
creates an attribute handler that applies only to scalars:
.PP
.Vb 2
\&    package Painful;
\&    use base LoudDecl;
\&
\&    my $metal : RealLoud;           # invokes &LoudDecl::RealLoud
\&    my @metal : RealLoud;           # error: unknown attribute
\&    my %metal : RealLoud;           # error: unknown attribute
\&    sub metal : RealLoud {...}      # error: unknown attribute
.Ve
.PP
You can, of course, declare separate handlers for these types as well
(but you'll need to specify \f(CW\*(C`no warnings \*(Aqredefine\*(Aq\*(C'\fR to do it quietly):
.PP
.Vb 3
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
\&    sub RealLoud :ATTR(ARRAY) { print "Urrrrrrrrrr!" }
\&    sub RealLoud :ATTR(HASH) { print "Arrrrrgggghhhhhh!" }
\&    sub RealLoud :ATTR(CODE) { croak "Real loud sub torpedoed" }
.Ve
.PP
You can also explicitly indicate that a single handler is meant to be
used for all types of referents like so:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&
\&    sub SeriousLoud :ATTR(ANY) { warn "Hearing loss imminent" }
.Ve
.PP
(I.e. \f(CW\*(C`ATTR(ANY)\*(C'\fR is a synonym for \f(CW\*(C`:ATTR\*(C'\fR).
.SS "Non-interpretive attribute handlers"
.IX Subsection "Non-interpretive attribute handlers"
Occasionally the strenuous efforts Attribute::Handlers makes to convert
the data argument (\f(CW$_[4]\fR) to a usable form before passing it to
the handler get in the way.
.PP
You can turn off that eagerness-to-help by declaring
an attribute handler with the keyword \f(CW\*(C`RAWDATA\*(C'\fR. For example:
.PP
.Vb 3
\&    sub Raw          : ATTR(RAWDATA) {...}
\&    sub Nekkid       : ATTR(SCALAR,RAWDATA) {...}
\&    sub Au::Naturale : ATTR(RAWDATA,ANY) {...}
.Ve
.PP
Then the handler makes absolutely no attempt to interpret the data it
receives and simply passes it as a string:
.PP
.Vb 1
\&    my $power : Raw(1..100);        # handlers receives "1..100"
.Ve
.SS "Phase-specific attribute handlers"
.IX Subsection "Phase-specific attribute handlers"
By default, attribute handlers are called at the end of the compilation
phase (in a \f(CW\*(C`CHECK\*(C'\fR block). This seems to be optimal in most cases because
most things that can be defined are defined by that point but nothing has
been executed.
.PP
However, it is possible to set up attribute handlers that are called at
other points in the program's compilation or execution, by explicitly
stating the phase (or phases) in which you wish the attribute handler to
be called. For example:
.PP
.Vb 5
\&    sub Early    :ATTR(SCALAR,BEGIN) {...}
\&    sub Normal   :ATTR(SCALAR,CHECK) {...}
\&    sub Late     :ATTR(SCALAR,INIT) {...}
\&    sub Final    :ATTR(SCALAR,END) {...}
\&    sub Bookends :ATTR(SCALAR,BEGIN,END) {...}
.Ve
.PP
As the last example indicates, a handler may be set up to be (re)called in
two or more phases. The phase name is passed as the handler's final argument.
.PP
Note that attribute handlers that are scheduled for the \f(CW\*(C`BEGIN\*(C'\fR phase
are handled as soon as the attribute is detected (i.e. before any
subsequently defined \f(CW\*(C`BEGIN\*(C'\fR blocks are executed).
.ie n .SS "Attributes as ""tie"" interfaces"
.el .SS "Attributes as \f(CWtie\fP interfaces"
.IX Subsection "Attributes as tie interfaces"
Attributes make an excellent and intuitive interface through which to tie
variables. For example:
.PP
.Vb 2
\&    use Attribute::Handlers;
\&    use Tie::Cycle;
\&    
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
\&        tie $$referent, \*(AqTie::Cycle\*(Aq, $data;
\&    }
\&
\&    # and thereafter...
\&
\&    package main;
\&    
\&    my $next : Cycle(\*(AqA\*(Aq..\*(AqZ\*(Aq);     # $next is now a tied variable
\&    
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note that, because the \f(CW\*(C`Cycle\*(C'\fR attribute receives its arguments in the
\&\f(CW$data\fR variable, if the attribute is given a list of arguments, \f(CW$data\fR
will consist of a single array reference; otherwise, it will consist of the
single argument directly. Since Tie::Cycle requires its cycling values to
be passed as an array reference, this means that we need to wrap
non-array-reference arguments in an array constructor:
.PP
.Vb 1
\&    $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
.Ve
.PP
Typically, however, things are the other way around: the tieable class expects
its arguments as a flattened list, so the attribute looks like:
.PP
.Vb 5
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        my @data = ref $data eq \*(AqARRAY\*(Aq ? @$data : $data;
\&        tie $$referent, \*(AqTie::Whatever\*(Aq, @data;
\&    }
.Ve
.PP
This software pattern is so widely applicable that Attribute::Handlers
provides a way to automate it: specifying \f(CW\*(Aqautotie\*(Aq\fR in the
\&\f(CW\*(C`use Attribute::Handlers\*(C'\fR statement. So, the cycling example,
could also be written:
.PP
.Vb 1
\&    use Attribute::Handlers autotie => { Cycle => \*(AqTie::Cycle\*(Aq };
\&
\&    # and thereafter...
\&
\&    package main;
\&
\&    my $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);     # $next is now a tied variable
\&
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note that we now have to pass the cycling values as an array reference,
since the \f(CW\*(C`autotie\*(C'\fR mechanism passes \f(CW\*(C`tie\*(C'\fR a list of arguments as a list
(as in the Tie::Whatever example), \fInot\fR as an array reference (as in
the original Tie::Cycle example at the start of this section).
.PP
The argument after \f(CW\*(Aqautotie\*(Aq\fR is a reference to a hash in which each key is
the name of an attribute to be created, and each value is the class to which
variables ascribed that attribute should be tied.
.PP
Note that there is no longer any need to import the Tie::Cycle module \*(--
Attribute::Handlers takes care of that automagically. You can even pass
arguments to the module's \f(CW\*(C`import\*(C'\fR subroutine, by appending them to the
class name. For example:
.PP
.Vb 2
\&    use Attribute::Handlers
\&         autotie => { Dir => \*(AqTie::Dir qw(DIR_UNLINK)\*(Aq };
.Ve
.PP
If the attribute name is unqualified, the attribute is installed in the
current package. Otherwise it is installed in the qualifier's package:
.PP
.Vb 1
\&    package Here;
\&    
\&    use Attribute::Handlers autotie => {
\&         Other::Good => Tie::SecureHash, # tie attr installed in Other::
\&                 Bad => Tie::Taxes,      # tie attr installed in Here::
\&     UNIVERSAL::Ugly => Software::Patent # tie attr installed everywhere
\&    };
.Ve
.PP
Autoties are most commonly used in the module to which they actually tie, 
and need to export their attributes to any module that calls them. To
facilitate this, Attribute::Handlers recognizes a special \*(L"pseudo-class\*(R" \*(--
\&\f(CW\*(C`_\|_CALLER_\|_\*(C'\fR, which may be specified as the qualifier of an attribute:
.PP
.Vb 1
\&    package Tie::Me::Kangaroo:Down::Sport;
\&    
\&    use Attribute::Handlers autotie =>
\&         { \*(Aq_\|_CALLER_\|_::Roo\*(Aq => _\|_PACKAGE_\|_ };
.Ve
.PP
This causes Attribute::Handlers to define the \f(CW\*(C`Roo\*(C'\fR attribute in the package
that imports the Tie::Me::Kangaroo:Down::Sport module.
.PP
Note that it is important to quote the _\|_CALLER_\|_::Roo identifier because
a bug in perl 5.8 will refuse to parse it and cause an unknown error.
.PP
\fIPassing the tied object to \f(CI\*(C`tie\*(C'\fI\fR
.IX Subsection "Passing the tied object to tie"
.PP
Occasionally it is important to pass a reference to the object being tied
to the \s-1TIESCALAR\s0, \s-1TIEHASH\s0, etc. that ties it.
.PP
The \f(CW\*(C`autotie\*(C'\fR mechanism supports this too. The following code:
.PP
.Vb 2
\&    use Attribute::Handlers autotieref => { Selfish => Tie::Selfish };
\&    my $var : Selfish(@args);
.Ve
.PP
has the same effect as:
.PP
.Vb 1
\&    tie my $var, \*(AqTie::Selfish\*(Aq, @args;
.Ve
.PP
But when \f(CW"autotieref"\fR is used instead of \f(CW"autotie"\fR:
.PP
.Vb 2
\&    use Attribute::Handlers autotieref => { Selfish => Tie::Selfish };
\&    my $var : Selfish(@args);
.Ve
.PP
the effect is to pass the \f(CW\*(C`tie\*(C'\fR call an extra reference to the variable
being tied:
.PP
.Vb 1
\&    tie my $var, \*(AqTie::Selfish\*(Aq, \e$var, @args;
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
If the class shown in \*(L"\s-1SYNOPSIS\s0\*(R" were placed in the MyClass.pm
module, then the following code:
.PP
.Vb 2
\&    package main;
\&    use MyClass;
\&
\&    my MyClass $slr :Good :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    package SomeOtherClass;
\&    use base MyClass;
\&
\&    sub tent { \*(Aqacle\*(Aq }
\&
\&    sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&    my @arr :Good :Omni(s/cie/nt/);
\&    my %hsh :Good(q/bye/) :Omni(q/bus/);
.Ve
.PP
would cause the following handlers to be invoked:
.PP
.Vb 1
\&    # my MyClass $slr :Good :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    MyClass::Good:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqGood\*(Aq,             # attr name
\&                                undef               # no attr data
\&                                \*(AqCHECK\*(Aq,            # compiler phase
\&                              );
\&
\&    MyClass::Bad:ATTR(SCALAR)( \*(AqMyClass\*(Aq,           # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e$slr,               # referent
\&                               \*(AqBad\*(Aq,               # attr name
\&                               0                    # eval\*(Aqd attr data
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&    MyClass::Omni:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqOmni\*(Aq,             # attr name
\&                                \*(Aq\-vorous\*(Aq           # eval\*(Aqd attr data
\&                                \*(AqCHECK\*(Aq,            # compiler phase
\&                              );
\&
\&
\&    # sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&
\&    MyClass::UGLY:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqUgly\*(Aq,               # attr name
\&                              \*(Aqsister\*(Aq              # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&    MyClass::Omni:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              [\*(Aqpo\*(Aq,\*(Aqacle\*(Aq]         # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&
\&    # my @arr :Good :Omni(s/cie/nt/);
\&
\&    MyClass::Good:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqGood\*(Aq,              # attr name
\&                               undef                # no attr data
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&    MyClass::Omni:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqOmni\*(Aq,              # attr name
\&                               ""                   # eval\*(Aqd attr data 
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&
\&    # my %hsh :Good(q/bye) :Omni(q/bus/);
\&                              
\&    MyClass::Good:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqGood\*(Aq,               # attr name
\&                              \*(Aqq/bye\*(Aq               # raw attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&                    
\&    MyClass::Omni:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              \*(Aqbus\*(Aq                 # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
.Ve
.PP
Installing handlers into \s-1UNIVERSAL\s0, makes them...err..universal.
For example:
.PP
.Vb 2
\&    package Descriptions;
\&    use Attribute::Handlers;
\&
\&    my %name;
\&    sub name { return $name{$_[2]}||*{$_[1]}{NAME} }
\&
\&    sub UNIVERSAL::Name :ATTR {
\&        $name{$_[2]} = $_[4];
\&    }
\&
\&    sub UNIVERSAL::Purpose :ATTR {
\&        print STDERR "Purpose of ", &name, " is $_[4]\en";
\&    }
\&
\&    sub UNIVERSAL::Unit :ATTR {
\&        print STDERR &name, " measured in $_[4]\en";
\&    }
.Ve
.PP
Let's you write:
.PP
.Vb 1
\&    use Descriptions;
\&
\&    my $capacity : Name(capacity)
\&                 : Purpose(to store max storage capacity for files)
\&                 : Unit(Gb);
\&
\&
\&    package Other;
\&
\&    sub foo : Purpose(to foo all data before barring it) { }
\&
\&    # etc.
.Ve
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
This module offers a single utility function, \f(CW\*(C`findsym()\*(C'\fR.
.IP "findsym" 4
.IX Item "findsym"
.Vb 1
\&    my $symbol = Attribute::Handlers::findsym($package, $referent);
.Ve
.Sp
The function looks in the symbol table of \f(CW$package\fR for the typeglob for
\&\f(CW$referent\fR, which is a reference to a variable or subroutine (\s-1SCALAR\s0, \s-1ARRAY\s0,
\&\s-1HASH\s0, or \s-1CODE\s0). If it finds the typeglob, it returns it. Otherwise, it returns
undef. Note that \f(CW\*(C`findsym\*(C'\fR memoizes the typeglobs it has previously
successfully found, so subsequent calls with the same arguments should be
much faster.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Bad attribute type: ATTR(%s)""" 4
.el .IP "\f(CWBad attribute type: ATTR(%s)\fR" 4
.IX Item "Bad attribute type: ATTR(%s)"
An attribute handler was specified with an \f(CW\*(C`:ATTR(\f(CIref_type\f(CW)\*(C'\fR, but the
type of referent it was defined to handle wasn't one of the five permitted:
\&\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, or \f(CW\*(C`ANY\*(C'\fR.
.ie n .IP """Attribute handler %s doesn\*(Aqt handle %s attributes""" 4
.el .IP "\f(CWAttribute handler %s doesn\*(Aqt handle %s attributes\fR" 4
.IX Item "Attribute handler %s doesnt handle %s attributes"
A handler for attributes of the specified name \fIwas\fR defined, but not
for the specified type of declaration. Typically encountered whe trying
to apply a \f(CW\*(C`VAR\*(C'\fR attribute handler to a subroutine, or a \f(CW\*(C`SCALAR\*(C'\fR
attribute handler to some other type of variable.
.ie n .IP """Declaration of %s attribute in package %s may clash with future reserved word""" 4
.el .IP "\f(CWDeclaration of %s attribute in package %s may clash with future reserved word\fR" 4
.IX Item "Declaration of %s attribute in package %s may clash with future reserved word"
A handler for an attributes with an all-lowercase name was declared. An
attribute with an all-lowercase name might have a meaning to Perl
itself some day, even though most don't yet. Use a mixed-case attribute
name, instead.
.ie n .IP """Can\*(Aqt have two ATTR specifiers on one subroutine""" 4
.el .IP "\f(CWCan\*(Aqt have two ATTR specifiers on one subroutine\fR" 4
.IX Item "Cant have two ATTR specifiers on one subroutine"
You just can't, okay?
Instead, put all the specifications together with commas between them
in a single \f(CW\*(C`ATTR(\f(CIspecification\f(CW)\*(C'\fR.
.ie n .IP """Can\*(Aqt autotie a %s""" 4
.el .IP "\f(CWCan\*(Aqt autotie a %s\fR" 4
.IX Item "Cant autotie a %s"
You can only declare autoties for types \f(CW"SCALAR"\fR, \f(CW"ARRAY"\fR, and
\&\f(CW"HASH"\fR. They're the only things (apart from typeglobs \*(-- which are
not declarable) that Perl can tie.
.ie n .IP """Internal error: %s symbol went missing""" 4
.el .IP "\f(CWInternal error: %s symbol went missing\fR" 4
.IX Item "Internal error: %s symbol went missing"
Something is rotten in the state of the program. An attributed
subroutine ceased to exist between the point it was declared and the point
at which its attribute handler(s) would have been called.
.ie n .IP """Won\*(Aqt be able to apply END handler""" 4
.el .IP "\f(CWWon\*(Aqt be able to apply END handler\fR" 4
.IX Item "Wont be able to apply END handler"
You have defined an \s-1END\s0 handler for an attribute that is being applied
to a lexical variable.  Since the variable may not be available during \s-1END\s0
this won't happen.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org). The maintainer of this module is now Rafael
Garcia-Suarez (rgarciasuarez@gmail.com).
.PP
Maintainer of the \s-1CPAN\s0 release is Steffen Mueller (smueller@cpan.org).
Contact him with technical difficulties with respect to the packaging of the
\&\s-1CPAN\s0 module.
.SH "BUGS"
.IX Header "BUGS"
There are undoubtedly serious bugs lurking somewhere in code this funky :\-)
Bug reports and other feedback are most welcome.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\&         Copyright (c) 2001\-2009, Damian Conway. All Rights Reserved.
\&       This module is free software. It may be used, redistributed
\&           and/or modified under the same terms as Perl itself.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Attribute::Handlers5.18.3pm                  0100644 0001750 0001750 00000074356 12566207451 025444  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Attribute::Handlers 3pm"
.TH Attribute::Handlers 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Attribute::Handlers \- Simpler definition of attribute handlers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.93 of Attribute::Handlers,
released July 20, 2011.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    package MyClass;
\&    require 5.006;
\&    use Attribute::Handlers;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&
\&    sub Good : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data) = @_;
\&
\&        # Invoked for any scalar variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&
\&        # Do whatever to $referent here (executed in CHECK phase).
\&        ...
\&    }
\&
\&    sub Bad : ATTR(SCALAR) {
\&        # Invoked for any scalar variable with a :Bad attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Good : ATTR(ARRAY) {
\&        # Invoked for any array variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Good : ATTR(HASH) {
\&        # Invoked for any hash variable with a :Good attribute,
\&        # provided the variable was declared in MyClass (or
\&        # a derived class) or typed to MyClass.
\&        ...
\&    }
\&
\&    sub Ugly : ATTR(CODE) {
\&        # Invoked for any subroutine declared in MyClass (or a 
\&        # derived class) with an :Ugly attribute.
\&        ...
\&    }
\&
\&    sub Omni : ATTR {
\&        # Invoked for any scalar, array, hash, or subroutine
\&        # with an :Omni attribute, provided the variable or
\&        # subroutine was declared in MyClass (or a derived class)
\&        # or the variable was typed to MyClass.
\&        # Use ref($_[2]) to determine what kind of referent it was.
\&        ...
\&    }
\&
\&
\&    use Attribute::Handlers autotie => { Cycle => Tie::Cycle };
\&
\&    my $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module, when inherited by a package, allows that package's class to
define attribute handler subroutines for specific attributes. Variables
and subroutines subsequently defined in that package, or in packages
derived from that package may be given attributes with the same names as
the attribute handler subroutines, which will then be called in one of
the compilation phases (i.e. in a \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR
block). (\f(CW\*(C`UNITCHECK\*(C'\fR blocks don't correspond to a global compilation
phase, so they can't be specified here.)
.PP
To create a handler, define it as a subroutine with the same name as
the desired attribute, and declare the subroutine itself with the  
attribute \f(CW\*(C`:ATTR\*(C'\fR. For example:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&
\&    sub Loud :ATTR {
\&        my ($package, $symbol, $referent, $attr, $data, $phase,
\&            $filename, $linenum) = @_;
\&        print STDERR
\&            ref($referent), " ",
\&            *{$symbol}{NAME}, " ",
\&            "($referent) ", "was just declared ",
\&            "and ascribed the ${attr} attribute ",
\&            "with data ($data)\en",
\&            "in phase $phase\en",
\&            "in file $filename at line $linenum\en";
\&    }
.Ve
.PP
This creates a handler for the attribute \f(CW\*(C`:Loud\*(C'\fR in the class LoudDecl.
Thereafter, any subroutine declared with a \f(CW\*(C`:Loud\*(C'\fR attribute in the class
LoudDecl:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    sub foo: Loud {...}
.Ve
.PP
causes the above handler to be invoked, and passed:
.IP "[0]" 4
.IX Item "[0]"
the name of the package into which it was declared;
.IP "[1]" 4
.IX Item "[1]"
a reference to the symbol table entry (typeglob) containing the subroutine;
.IP "[2]" 4
.IX Item "[2]"
a reference to the subroutine;
.IP "[3]" 4
.IX Item "[3]"
the name of the attribute;
.IP "[4]" 4
.IX Item "[4]"
any data associated with that attribute;
.IP "[5]" 4
.IX Item "[5]"
the name of the phase in which the handler is being invoked;
.IP "[6]" 4
.IX Item "[6]"
the filename in which the handler is being invoked;
.IP "[7]" 4
.IX Item "[7]"
the line number in this file.
.PP
Likewise, declaring any variables with the \f(CW\*(C`:Loud\*(C'\fR attribute within the
package:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    my $foo :Loud;
\&    my @foo :Loud;
\&    my %foo :Loud;
.Ve
.PP
will cause the handler to be called with a similar argument list (except,
of course, that \f(CW$_[2]\fR will be a reference to the variable).
.PP
The package name argument will typically be the name of the class into
which the subroutine was declared, but it may also be the name of a derived
class (since handlers are inherited).
.PP
If a lexical variable is given an attribute, there is no symbol table to 
which it belongs, so the symbol table argument (\f(CW$_[1]\fR) is set to the
string \f(CW\*(AqLEXICAL\*(Aq\fR in that case. Likewise, ascribing an attribute to
an anonymous subroutine results in a symbol table argument of \f(CW\*(AqANON\*(Aq\fR.
.PP
The data argument passes in the value (if any) associated with the
attribute. For example, if \f(CW&foo\fR had been declared:
.PP
.Vb 1
\&        sub foo :Loud("turn it up to 11, man!") {...}
.Ve
.PP
then a reference to an array containing the string
\&\f(CW"turn it up to 11, man!"\fR would be passed as the last argument.
.PP
Attribute::Handlers makes strenuous efforts to convert
the data argument (\f(CW$_[4]\fR) to a usable form before passing it to
the handler (but see \*(L"Non-interpretive attribute handlers\*(R").
If those efforts succeed, the interpreted data is passed in an array
reference; if they fail, the raw data is passed as a string.
For example, all of these:
.PP
.Vb 4
\&    sub foo :Loud(till=>ears=>are=>bleeding) {...}
\&    sub foo :Loud(qw/till ears are bleeding/) {...}
\&    sub foo :Loud(qw/till, ears, are, bleeding/) {...}
\&    sub foo :Loud(till,ears,are,bleeding) {...}
.Ve
.PP
causes it to pass \f(CW\*(C`[\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]\*(C'\fR as the handler's
data argument. While:
.PP
.Vb 1
\&    sub foo :Loud([\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq]) {...}
.Ve
.PP
causes it to pass \f(CW\*(C`[ [\*(Aqtill\*(Aq,\*(Aqears\*(Aq,\*(Aqare\*(Aq,\*(Aqbleeding\*(Aq] ]\*(C'\fR; the array
reference specified in the data being passed inside the standard
array reference indicating successful interpretation.
.PP
However, if the data can't be parsed as valid Perl, then
it is passed as an uninterpreted string. For example:
.PP
.Vb 2
\&    sub foo :Loud(my,ears,are,bleeding) {...}
\&    sub foo :Loud(qw/my ears are bleeding) {...}
.Ve
.PP
cause the strings \f(CW\*(Aqmy,ears,are,bleeding\*(Aq\fR and
\&\f(CW\*(Aqqw/my ears are bleeding\*(Aq\fR respectively to be passed as the
data argument.
.PP
If no value is associated with the attribute, \f(CW\*(C`undef\*(C'\fR is passed.
.SS "Typed lexicals"
.IX Subsection "Typed lexicals"
Regardless of the package in which it is declared, if a lexical variable is
ascribed an attribute, the handler that is invoked is the one belonging to
the package to which it is typed. For example, the following declarations:
.PP
.Vb 1
\&    package OtherClass;
\&
\&    my LoudDecl $loudobj : Loud;
\&    my LoudDecl @loudobjs : Loud;
\&    my LoudDecl %loudobjex : Loud;
.Ve
.PP
causes the LoudDecl::Loud handler to be invoked (even if OtherClass also
defines a handler for \f(CW\*(C`:Loud\*(C'\fR attributes).
.SS "Type-specific attribute handlers"
.IX Subsection "Type-specific attribute handlers"
If an attribute handler is declared and the \f(CW\*(C`:ATTR\*(C'\fR specifier is
given the name of a built-in type (\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, or \f(CW\*(C`CODE\*(C'\fR),
the handler is only applied to declarations of that type. For example,
the following definition:
.PP
.Vb 1
\&    package LoudDecl;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
.Ve
.PP
creates an attribute handler that applies only to scalars:
.PP
.Vb 2
\&    package Painful;
\&    use base LoudDecl;
\&
\&    my $metal : RealLoud;           # invokes &LoudDecl::RealLoud
\&    my @metal : RealLoud;           # error: unknown attribute
\&    my %metal : RealLoud;           # error: unknown attribute
\&    sub metal : RealLoud {...}      # error: unknown attribute
.Ve
.PP
You can, of course, declare separate handlers for these types as well
(but you'll need to specify \f(CW\*(C`no warnings \*(Aqredefine\*(Aq\*(C'\fR to do it quietly):
.PP
.Vb 3
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&    no warnings \*(Aqredefine\*(Aq;
\&
\&    sub RealLoud :ATTR(SCALAR) { print "Yeeeeow!" }
\&    sub RealLoud :ATTR(ARRAY) { print "Urrrrrrrrrr!" }
\&    sub RealLoud :ATTR(HASH) { print "Arrrrrgggghhhhhh!" }
\&    sub RealLoud :ATTR(CODE) { croak "Real loud sub torpedoed" }
.Ve
.PP
You can also explicitly indicate that a single handler is meant to be
used for all types of referents like so:
.PP
.Vb 2
\&    package LoudDecl;
\&    use Attribute::Handlers;
\&
\&    sub SeriousLoud :ATTR(ANY) { warn "Hearing loss imminent" }
.Ve
.PP
(I.e. \f(CW\*(C`ATTR(ANY)\*(C'\fR is a synonym for \f(CW\*(C`:ATTR\*(C'\fR).
.SS "Non-interpretive attribute handlers"
.IX Subsection "Non-interpretive attribute handlers"
Occasionally the strenuous efforts Attribute::Handlers makes to convert
the data argument (\f(CW$_[4]\fR) to a usable form before passing it to
the handler get in the way.
.PP
You can turn off that eagerness-to-help by declaring
an attribute handler with the keyword \f(CW\*(C`RAWDATA\*(C'\fR. For example:
.PP
.Vb 3
\&    sub Raw          : ATTR(RAWDATA) {...}
\&    sub Nekkid       : ATTR(SCALAR,RAWDATA) {...}
\&    sub Au::Naturale : ATTR(RAWDATA,ANY) {...}
.Ve
.PP
Then the handler makes absolutely no attempt to interpret the data it
receives and simply passes it as a string:
.PP
.Vb 1
\&    my $power : Raw(1..100);        # handlers receives "1..100"
.Ve
.SS "Phase-specific attribute handlers"
.IX Subsection "Phase-specific attribute handlers"
By default, attribute handlers are called at the end of the compilation
phase (in a \f(CW\*(C`CHECK\*(C'\fR block). This seems to be optimal in most cases because
most things that can be defined are defined by that point but nothing has
been executed.
.PP
However, it is possible to set up attribute handlers that are called at
other points in the program's compilation or execution, by explicitly
stating the phase (or phases) in which you wish the attribute handler to
be called. For example:
.PP
.Vb 5
\&    sub Early    :ATTR(SCALAR,BEGIN) {...}
\&    sub Normal   :ATTR(SCALAR,CHECK) {...}
\&    sub Late     :ATTR(SCALAR,INIT) {...}
\&    sub Final    :ATTR(SCALAR,END) {...}
\&    sub Bookends :ATTR(SCALAR,BEGIN,END) {...}
.Ve
.PP
As the last example indicates, a handler may be set up to be (re)called in
two or more phases. The phase name is passed as the handler's final argument.
.PP
Note that attribute handlers that are scheduled for the \f(CW\*(C`BEGIN\*(C'\fR phase
are handled as soon as the attribute is detected (i.e. before any
subsequently defined \f(CW\*(C`BEGIN\*(C'\fR blocks are executed).
.ie n .SS "Attributes as ""tie"" interfaces"
.el .SS "Attributes as \f(CWtie\fP interfaces"
.IX Subsection "Attributes as tie interfaces"
Attributes make an excellent and intuitive interface through which to tie
variables. For example:
.PP
.Vb 2
\&    use Attribute::Handlers;
\&    use Tie::Cycle;
\&
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
\&        tie $$referent, \*(AqTie::Cycle\*(Aq, $data;
\&    }
\&
\&    # and thereafter...
\&
\&    package main;
\&
\&    my $next : Cycle(\*(AqA\*(Aq..\*(AqZ\*(Aq);     # $next is now a tied variable
\&
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note that, because the \f(CW\*(C`Cycle\*(C'\fR attribute receives its arguments in the
\&\f(CW$data\fR variable, if the attribute is given a list of arguments, \f(CW$data\fR
will consist of a single array reference; otherwise, it will consist of the
single argument directly. Since Tie::Cycle requires its cycling values to
be passed as an array reference, this means that we need to wrap
non-array-reference arguments in an array constructor:
.PP
.Vb 1
\&    $data = [ $data ] unless ref $data eq \*(AqARRAY\*(Aq;
.Ve
.PP
Typically, however, things are the other way around: the tieable class expects
its arguments as a flattened list, so the attribute looks like:
.PP
.Vb 5
\&    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
\&        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
\&        my @data = ref $data eq \*(AqARRAY\*(Aq ? @$data : $data;
\&        tie $$referent, \*(AqTie::Whatever\*(Aq, @data;
\&    }
.Ve
.PP
This software pattern is so widely applicable that Attribute::Handlers
provides a way to automate it: specifying \f(CW\*(Aqautotie\*(Aq\fR in the
\&\f(CW\*(C`use Attribute::Handlers\*(C'\fR statement. So, the cycling example,
could also be written:
.PP
.Vb 1
\&    use Attribute::Handlers autotie => { Cycle => \*(AqTie::Cycle\*(Aq };
\&
\&    # and thereafter...
\&
\&    package main;
\&
\&    my $next : Cycle([\*(AqA\*(Aq..\*(AqZ\*(Aq]);     # $next is now a tied variable
\&
\&    while (<>) {
\&        print $next;
\&    }
.Ve
.PP
Note that we now have to pass the cycling values as an array reference,
since the \f(CW\*(C`autotie\*(C'\fR mechanism passes \f(CW\*(C`tie\*(C'\fR a list of arguments as a list
(as in the Tie::Whatever example), \fInot\fR as an array reference (as in
the original Tie::Cycle example at the start of this section).
.PP
The argument after \f(CW\*(Aqautotie\*(Aq\fR is a reference to a hash in which each key is
the name of an attribute to be created, and each value is the class to which
variables ascribed that attribute should be tied.
.PP
Note that there is no longer any need to import the Tie::Cycle module \*(--
Attribute::Handlers takes care of that automagically. You can even pass
arguments to the module's \f(CW\*(C`import\*(C'\fR subroutine, by appending them to the
class name. For example:
.PP
.Vb 2
\&    use Attribute::Handlers
\&         autotie => { Dir => \*(AqTie::Dir qw(DIR_UNLINK)\*(Aq };
.Ve
.PP
If the attribute name is unqualified, the attribute is installed in the
current package. Otherwise it is installed in the qualifier's package:
.PP
.Vb 1
\&    package Here;
\&
\&    use Attribute::Handlers autotie => {
\&         Other::Good => Tie::SecureHash, # tie attr installed in Other::
\&                 Bad => Tie::Taxes,      # tie attr installed in Here::
\&     UNIVERSAL::Ugly => Software::Patent # tie attr installed everywhere
\&    };
.Ve
.PP
Autoties are most commonly used in the module to which they actually tie, 
and need to export their attributes to any module that calls them. To
facilitate this, Attribute::Handlers recognizes a special \*(L"pseudo-class\*(R" \*(--
\&\f(CW\*(C`_\|_CALLER_\|_\*(C'\fR, which may be specified as the qualifier of an attribute:
.PP
.Vb 1
\&    package Tie::Me::Kangaroo:Down::Sport;
\&
\&    use Attribute::Handlers autotie =>
\&         { \*(Aq_\|_CALLER_\|_::Roo\*(Aq => _\|_PACKAGE_\|_ };
.Ve
.PP
This causes Attribute::Handlers to define the \f(CW\*(C`Roo\*(C'\fR attribute in the package
that imports the Tie::Me::Kangaroo:Down::Sport module.
.PP
Note that it is important to quote the _\|_CALLER_\|_::Roo identifier because
a bug in perl 5.8 will refuse to parse it and cause an unknown error.
.PP
\fIPassing the tied object to \f(CI\*(C`tie\*(C'\fI\fR
.IX Subsection "Passing the tied object to tie"
.PP
Occasionally it is important to pass a reference to the object being tied
to the \s-1TIESCALAR, TIEHASH,\s0 etc. that ties it.
.PP
The \f(CW\*(C`autotie\*(C'\fR mechanism supports this too. The following code:
.PP
.Vb 2
\&    use Attribute::Handlers autotieref => { Selfish => Tie::Selfish };
\&    my $var : Selfish(@args);
.Ve
.PP
has the same effect as:
.PP
.Vb 1
\&    tie my $var, \*(AqTie::Selfish\*(Aq, @args;
.Ve
.PP
But when \f(CW"autotieref"\fR is used instead of \f(CW"autotie"\fR:
.PP
.Vb 2
\&    use Attribute::Handlers autotieref => { Selfish => Tie::Selfish };
\&    my $var : Selfish(@args);
.Ve
.PP
the effect is to pass the \f(CW\*(C`tie\*(C'\fR call an extra reference to the variable
being tied:
.PP
.Vb 1
\&    tie my $var, \*(AqTie::Selfish\*(Aq, \e$var, @args;
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
If the class shown in \*(L"\s-1SYNOPSIS\*(R"\s0 were placed in the MyClass.pm
module, then the following code:
.PP
.Vb 2
\&    package main;
\&    use MyClass;
\&
\&    my MyClass $slr :Good :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    package SomeOtherClass;
\&    use base MyClass;
\&
\&    sub tent { \*(Aqacle\*(Aq }
\&
\&    sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&    my @arr :Good :Omni(s/cie/nt/);
\&    my %hsh :Good(q/bye/) :Omni(q/bus/);
.Ve
.PP
would cause the following handlers to be invoked:
.PP
.Vb 1
\&    # my MyClass $slr :Good :Bad(1**1\-1) :Omni(\-vorous);
\&
\&    MyClass::Good:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqGood\*(Aq,             # attr name
\&                                undef               # no attr data
\&                                \*(AqCHECK\*(Aq,            # compiler phase
\&                              );
\&
\&    MyClass::Bad:ATTR(SCALAR)( \*(AqMyClass\*(Aq,           # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e$slr,               # referent
\&                               \*(AqBad\*(Aq,               # attr name
\&                               0                    # eval\*(Aqd attr data
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&    MyClass::Omni:ATTR(SCALAR)( \*(AqMyClass\*(Aq,          # class
\&                                \*(AqLEXICAL\*(Aq,          # no typeglob
\&                                \e$slr,              # referent
\&                                \*(AqOmni\*(Aq,             # attr name
\&                                \*(Aq\-vorous\*(Aq           # eval\*(Aqd attr data
\&                                \*(AqCHECK\*(Aq,            # compiler phase
\&                              );
\&
\&
\&    # sub fn :Ugly(sister) :Omni(\*(Aqpo\*(Aq,tent()) {...}
\&
\&    MyClass::UGLY:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqUgly\*(Aq,               # attr name
\&                              \*(Aqsister\*(Aq              # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&    MyClass::Omni:ATTR(CODE)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \e*SomeOtherClass::fn, # typeglob
\&                              \e&SomeOtherClass::fn, # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              [\*(Aqpo\*(Aq,\*(Aqacle\*(Aq]         # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&
\&    # my @arr :Good :Omni(s/cie/nt/);
\&
\&    MyClass::Good:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqGood\*(Aq,              # attr name
\&                               undef                # no attr data
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&    MyClass::Omni:ATTR(ARRAY)( \*(AqSomeOtherClass\*(Aq,    # class
\&                               \*(AqLEXICAL\*(Aq,           # no typeglob
\&                               \e@arr,               # referent
\&                               \*(AqOmni\*(Aq,              # attr name
\&                               ""                   # eval\*(Aqd attr data 
\&                               \*(AqCHECK\*(Aq,             # compiler phase
\&                             );
\&
\&
\&    # my %hsh :Good(q/bye) :Omni(q/bus/);
\&
\&    MyClass::Good:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqGood\*(Aq,               # attr name
\&                              \*(Aqq/bye\*(Aq               # raw attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
\&
\&    MyClass::Omni:ATTR(HASH)( \*(AqSomeOtherClass\*(Aq,     # class
\&                              \*(AqLEXICAL\*(Aq,            # no typeglob
\&                              \e%hsh,                # referent
\&                              \*(AqOmni\*(Aq,               # attr name
\&                              \*(Aqbus\*(Aq                 # eval\*(Aqd attr data
\&                              \*(AqCHECK\*(Aq,              # compiler phase
\&                            );
.Ve
.PP
Installing handlers into \s-1UNIVERSAL,\s0 makes them...err..universal.
For example:
.PP
.Vb 2
\&    package Descriptions;
\&    use Attribute::Handlers;
\&
\&    my %name;
\&    sub name { return $name{$_[2]}||*{$_[1]}{NAME} }
\&
\&    sub UNIVERSAL::Name :ATTR {
\&        $name{$_[2]} = $_[4];
\&    }
\&
\&    sub UNIVERSAL::Purpose :ATTR {
\&        print STDERR "Purpose of ", &name, " is $_[4]\en";
\&    }
\&
\&    sub UNIVERSAL::Unit :ATTR {
\&        print STDERR &name, " measured in $_[4]\en";
\&    }
.Ve
.PP
Let's you write:
.PP
.Vb 1
\&    use Descriptions;
\&
\&    my $capacity : Name(capacity)
\&                 : Purpose(to store max storage capacity for files)
\&                 : Unit(Gb);
\&
\&
\&    package Other;
\&
\&    sub foo : Purpose(to foo all data before barring it) { }
\&
\&    # etc.
.Ve
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
This module offers a single utility function, \f(CW\*(C`findsym()\*(C'\fR.
.IP "findsym" 4
.IX Item "findsym"
.Vb 1
\&    my $symbol = Attribute::Handlers::findsym($package, $referent);
.Ve
.Sp
The function looks in the symbol table of \f(CW$package\fR for the typeglob for
\&\f(CW$referent\fR, which is a reference to a variable or subroutine (\s-1SCALAR, ARRAY,
HASH,\s0 or \s-1CODE\s0). If it finds the typeglob, it returns it. Otherwise, it returns
undef. Note that \f(CW\*(C`findsym\*(C'\fR memoizes the typeglobs it has previously
successfully found, so subsequent calls with the same arguments should be
much faster.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Bad attribute type: ATTR(%s)""" 4
.el .IP "\f(CWBad attribute type: ATTR(%s)\fR" 4
.IX Item "Bad attribute type: ATTR(%s)"
An attribute handler was specified with an \f(CW\*(C`:ATTR(\f(CIref_type\f(CW)\*(C'\fR, but the
type of referent it was defined to handle wasn't one of the five permitted:
\&\f(CW\*(C`SCALAR\*(C'\fR, \f(CW\*(C`ARRAY\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`CODE\*(C'\fR, or \f(CW\*(C`ANY\*(C'\fR.
.ie n .IP """Attribute handler %s doesn\*(Aqt handle %s attributes""" 4
.el .IP "\f(CWAttribute handler %s doesn\*(Aqt handle %s attributes\fR" 4
.IX Item "Attribute handler %s doesnt handle %s attributes"
A handler for attributes of the specified name \fIwas\fR defined, but not
for the specified type of declaration. Typically encountered whe trying
to apply a \f(CW\*(C`VAR\*(C'\fR attribute handler to a subroutine, or a \f(CW\*(C`SCALAR\*(C'\fR
attribute handler to some other type of variable.
.ie n .IP """Declaration of %s attribute in package %s may clash with future reserved word""" 4
.el .IP "\f(CWDeclaration of %s attribute in package %s may clash with future reserved word\fR" 4
.IX Item "Declaration of %s attribute in package %s may clash with future reserved word"
A handler for an attributes with an all-lowercase name was declared. An
attribute with an all-lowercase name might have a meaning to Perl
itself some day, even though most don't yet. Use a mixed-case attribute
name, instead.
.ie n .IP """Can\*(Aqt have two ATTR specifiers on one subroutine""" 4
.el .IP "\f(CWCan\*(Aqt have two ATTR specifiers on one subroutine\fR" 4
.IX Item "Cant have two ATTR specifiers on one subroutine"
You just can't, okay?
Instead, put all the specifications together with commas between them
in a single \f(CW\*(C`ATTR(\f(CIspecification\f(CW)\*(C'\fR.
.ie n .IP """Can\*(Aqt autotie a %s""" 4
.el .IP "\f(CWCan\*(Aqt autotie a %s\fR" 4
.IX Item "Cant autotie a %s"
You can only declare autoties for types \f(CW"SCALAR"\fR, \f(CW"ARRAY"\fR, and
\&\f(CW"HASH"\fR. They're the only things (apart from typeglobs \*(-- which are
not declarable) that Perl can tie.
.ie n .IP """Internal error: %s symbol went missing""" 4
.el .IP "\f(CWInternal error: %s symbol went missing\fR" 4
.IX Item "Internal error: %s symbol went missing"
Something is rotten in the state of the program. An attributed
subroutine ceased to exist between the point it was declared and the point
at which its attribute handler(s) would have been called.
.ie n .IP """Won\*(Aqt be able to apply END handler""" 4
.el .IP "\f(CWWon\*(Aqt be able to apply END handler\fR" 4
.IX Item "Wont be able to apply END handler"
You have defined an \s-1END\s0 handler for an attribute that is being applied
to a lexical variable.  Since the variable may not be available during \s-1END\s0
this won't happen.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org). The maintainer of this module is now Rafael
Garcia-Suarez (rgarciasuarez@gmail.com).
.PP
Maintainer of the \s-1CPAN\s0 release is Steffen Mueller (smueller@cpan.org).
Contact him with technical difficulties with respect to the packaging of the
\&\s-1CPAN\s0 module.
.SH "BUGS"
.IX Header "BUGS"
There are undoubtedly serious bugs lurking somewhere in code this funky :\-)
Bug reports and other feedback are most welcome.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\&         Copyright (c) 2001\-2009, Damian Conway. All Rights Reserved.
\&       This module is free software. It may be used, redistributed
\&           and/or modified under the same terms as Perl itself.
.Ve
                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Attribute::Params::Validate.3pm              0100644 0001750 0001750 00000015716 12566242316 026443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Attribute::Params::Validate 3"
.TH Attribute::Params::Validate 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Attribute::Params::Validate \- Define validation through subroutine attributes
.SH "VERSION"
.IX Header "VERSION"
version 1.08
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Attribute::Params::Validate qw(:all);
\&
\&  # takes named params (hash or hashref)
\&  # foo is mandatory, bar is optional
\&  sub foo : Validate( foo => 1, bar => 0 )
\&  {
\&      ...
\&  }
\&
\&  # takes positional params
\&  # first two are mandatory, third is optional
\&  sub bar : ValidatePos( 1, 1, 0 )
\&  {
\&      ...
\&  }
\&
\&  # for some reason Perl insists that the entire attribute be on one line
\&  sub foo2 : Validate( foo => { type => ARRAYREF }, bar => { can => [ \*(Aqprint\*(Aq, \*(Aqflush\*(Aq, \*(Aqfrobnicate\*(Aq ] }, baz => { type => SCALAR, callbacks => { \*(Aqnumbers only\*(Aq => sub { shift() =~ /^\ed+$/ }, \*(Aqless than 90\*(Aq => sub { shift() < 90 } } } )
\&  {
\&      ...
\&  }
\&
\&  # note that this is marked as a method.  This is very important!
\&  sub baz : Validate( foo => { type => ARRAYREF }, bar => { isa => \*(AqFrobnicator\*(Aq } ) method
\&  {
\&      ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Attribute::Params::Validate module allows you to validate method
or function call parameters just like Params::Validate does.  However,
this module allows you to specify your validation spec as an
attribute, rather than by calling the \f(CW\*(C`validate\*(C'\fR routine.
.PP
Please see Params::Validate for more information on how you can
specify what validation is performed.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
This module exports everything that Params::Validate does except for
the \f(CW\*(C`validate\*(C'\fR and \f(CW\*(C`validate_pos\*(C'\fR subroutines.
.SS "\s-1ATTRIBUTES\s0"
.IX Subsection "ATTRIBUTES"
.IP "\(bu" 4
Validate
.Sp
This attribute corresponds to the \f(CW\*(C`validate\*(C'\fR subroutine in
Params::Validate.
.IP "\(bu" 4
ValidatePos
.Sp
This attribute corresponds to the \f(CW\*(C`validate_pos\*(C'\fR subroutine in
Params::Validate.
.SS "\s-1OO\s0"
.IX Subsection "OO"
If you are using this module to mark \fBmethods\fR for validation, as
opposed to subroutines, it is crucial that you mark these methods with
the \f(CW\*(C`:method\*(C'\fR attribute, as well as the \f(CW\*(C`Validate\*(C'\fR or \f(CW\*(C`ValidatePos\*(C'\fR
attribute.
.PP
If you do not do this, then the object or class used in the method
call will be passed to the validation routines, which is probably not
what you want.
.SS "\s-1CAVEATS\s0"
.IX Subsection "CAVEATS"
You \fBmust\fR put all the arguments to the \f(CW\*(C`Validate\*(C'\fR or \f(CW\*(C`ValidatePos\*(C'\fR
attribute on a single line, or Perl will complain.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Params::Validate
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky, <autarch@urth.org> and Ilya Martynov <ilya@martynov.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by Dave Rolsky and Ilya Martynov.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Attribute::Params::Validate5.16.3pm          0100644 0001750 0001750 00000014440 12566242320 026741  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Attribute::Params::Validate 3"
.TH Attribute::Params::Validate 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Attribute::Params::Validate qw(:all);
\&
\&  # takes named params (hash or hashref)
\&  # foo is mandatory, bar is optional
\&  sub foo : Validate( foo => 1, bar => 0 )
\&  {
\&      ...
\&  }
\&
\&  # takes positional params
\&  # first two are mandatory, third is optional
\&  sub bar : ValidatePos( 1, 1, 0 )
\&  {
\&      ...
\&  }
\&
\&  # for some reason Perl insists that the entire attribute be on one line
\&  sub foo2 : Validate( foo => { type => ARRAYREF }, bar => { can => [ \*(Aqprint\*(Aq, \*(Aqflush\*(Aq, \*(Aqfrobnicate\*(Aq ] }, baz => { type => SCALAR, callbacks => { \*(Aqnumbers only\*(Aq => sub { shift() =~ /^\ed+$/ }, \*(Aqless than 90\*(Aq => sub { shift() < 90 } } } )
\&  {
\&      ...
\&  }
\&
\&  # note that this is marked as a method.  This is very important!
\&  sub baz : Validate( foo => { type => ARRAYREF }, bar => { isa => \*(AqFrobnicator\*(Aq } ) method
\&  {
\&      ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Attribute::Params::Validate module allows you to validate method
or function call parameters just like Params::Validate does.  However,
this module allows you to specify your validation spec as an
attribute, rather than by calling the \f(CW\*(C`validate\*(C'\fR routine.
.PP
Please see Params::Validate for more information on how you can
specify what validation is performed.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
This module exports everything that Params::Validate does except for
the \f(CW\*(C`validate\*(C'\fR and \f(CW\*(C`validate_pos\*(C'\fR subroutines.
.SS "\s-1ATTRIBUTES\s0"
.IX Subsection "ATTRIBUTES"
.IP "\(bu" 4
Validate
.Sp
This attribute corresponds to the \f(CW\*(C`validate\*(C'\fR subroutine in
Params::Validate.
.IP "\(bu" 4
ValidatePos
.Sp
This attribute corresponds to the \f(CW\*(C`validate_pos\*(C'\fR subroutine in
Params::Validate.
.SS "\s-1OO\s0"
.IX Subsection "OO"
If you are using this module to mark \fBmethods\fR for validation, as
opposed to subroutines, it is crucial that you mark these methods with
the \f(CW\*(C`:method\*(C'\fR attribute, as well as the \f(CW\*(C`Validate\*(C'\fR or \f(CW\*(C`ValidatePos\*(C'\fR
attribute.
.PP
If you do not do this, then the object or class used in the method
call will be passed to the validation routines, which is probably not
what you want.
.SS "\s-1CAVEATS\s0"
.IX Subsection "CAVEATS"
You \fBmust\fR put all the arguments to the \f(CW\*(C`Validate\*(C'\fR or \f(CW\*(C`ValidatePos\*(C'\fR
attribute on a single line, or Perl will complain.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Params::Validate
                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Attribute::Params::Validate5.18.3pm          0100644 0001750 0001750 00000015716 12566242316 026757  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Attribute::Params::Validate 3"
.TH Attribute::Params::Validate 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Attribute::Params::Validate \- Define validation through subroutine attributes
.SH "VERSION"
.IX Header "VERSION"
version 1.08
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Attribute::Params::Validate qw(:all);
\&
\&  # takes named params (hash or hashref)
\&  # foo is mandatory, bar is optional
\&  sub foo : Validate( foo => 1, bar => 0 )
\&  {
\&      ...
\&  }
\&
\&  # takes positional params
\&  # first two are mandatory, third is optional
\&  sub bar : ValidatePos( 1, 1, 0 )
\&  {
\&      ...
\&  }
\&
\&  # for some reason Perl insists that the entire attribute be on one line
\&  sub foo2 : Validate( foo => { type => ARRAYREF }, bar => { can => [ \*(Aqprint\*(Aq, \*(Aqflush\*(Aq, \*(Aqfrobnicate\*(Aq ] }, baz => { type => SCALAR, callbacks => { \*(Aqnumbers only\*(Aq => sub { shift() =~ /^\ed+$/ }, \*(Aqless than 90\*(Aq => sub { shift() < 90 } } } )
\&  {
\&      ...
\&  }
\&
\&  # note that this is marked as a method.  This is very important!
\&  sub baz : Validate( foo => { type => ARRAYREF }, bar => { isa => \*(AqFrobnicator\*(Aq } ) method
\&  {
\&      ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Attribute::Params::Validate module allows you to validate method
or function call parameters just like Params::Validate does.  However,
this module allows you to specify your validation spec as an
attribute, rather than by calling the \f(CW\*(C`validate\*(C'\fR routine.
.PP
Please see Params::Validate for more information on how you can
specify what validation is performed.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
This module exports everything that Params::Validate does except for
the \f(CW\*(C`validate\*(C'\fR and \f(CW\*(C`validate_pos\*(C'\fR subroutines.
.SS "\s-1ATTRIBUTES\s0"
.IX Subsection "ATTRIBUTES"
.IP "\(bu" 4
Validate
.Sp
This attribute corresponds to the \f(CW\*(C`validate\*(C'\fR subroutine in
Params::Validate.
.IP "\(bu" 4
ValidatePos
.Sp
This attribute corresponds to the \f(CW\*(C`validate_pos\*(C'\fR subroutine in
Params::Validate.
.SS "\s-1OO\s0"
.IX Subsection "OO"
If you are using this module to mark \fBmethods\fR for validation, as
opposed to subroutines, it is crucial that you mark these methods with
the \f(CW\*(C`:method\*(C'\fR attribute, as well as the \f(CW\*(C`Validate\*(C'\fR or \f(CW\*(C`ValidatePos\*(C'\fR
attribute.
.PP
If you do not do this, then the object or class used in the method
call will be passed to the validation routines, which is probably not
what you want.
.SS "\s-1CAVEATS\s0"
.IX Subsection "CAVEATS"
You \fBmust\fR put all the arguments to the \f(CW\*(C`Validate\*(C'\fR or \f(CW\*(C`ValidatePos\*(C'\fR
attribute on a single line, or Perl will complain.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Params::Validate
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky, <autarch@urth.org> and Ilya Martynov <ilya@martynov.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by Dave Rolsky and Ilya Martynov.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL.3pm                             0100644 0001750 0001750 00000025740 12566241556 023410  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL 3"
.TH Authen::SASL 3 "2012-09-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL \- SASL Authentication framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Authen::SASL;
\&
\& $sasl = Authen::SASL\->new(
\&   mechanism => \*(AqCRAM\-MD5 PLAIN ANONYMOUS\*(Aq,
\&   callback => {
\&     pass => \e&fetch_password,
\&     user => $user,
\&   }
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1SASL\s0 is a generic mechanism for authentication used by several
network protocols. \fBAuthen::SASL\fR provides an implementation
framework that all protocols should be able to share.
.PP
The framework allows different implementations of the connection
class to be plugged in. At the time of writing there were two such
plugins.
.IP "Authen::SASL::Perl" 4
.IX Item "Authen::SASL::Perl"
This module implements several mechanisms and is implemented
entirely in Perl.
.IP "Authen::SASL::XS" 4
.IX Item "Authen::SASL::XS"
This module uses the Cyrus \s-1SASL\s0 C\-library (both version 1 and 2 
are supported).
.IP "Authen::SASL::Cyrus" 4
.IX Item "Authen::SASL::Cyrus"
This module is the predecessor to Authen::SASL::XS. It is reccomended
to use Authen::SASL::XS
.PP
By default the order in which these plugins are selected is 
Authen::SASL::XS, Authen::SASL::Cyrus and then Authen::SASL::Perl.
.PP
If you want to change it or want to specifically use one
implementation only simply do
.PP
.Vb 1
\& use Authen::SASL qw(Perl);
.Ve
.PP
or if you have another plugin module that supports the Authen::SASL \s-1API\s0
.PP
.Vb 1
\& use Authen::SASL qw(My::SASL::Plugin);
.Ve
.SS "\s-1CONTRUCTOR\s0"
.IX Subsection "CONTRUCTOR"
.IP "new ( \s-1OPTIONS \s0)" 4
.IX Item "new ( OPTIONS )"
The constructor may be called with or without arguments. Passing arguments is
just a short cut to calling the \f(CW\*(C`mechanism\*(C'\fR and \f(CW\*(C`callback\*(C'\fR methods.
.RS 4
.IP "callback => { \s-1NAME\s0 => \s-1VALUE, NAME\s0 => \s-1VALUE, ... \s0}" 4
.IX Item "callback => { NAME => VALUE, NAME => VALUE, ... }"
Set the callbacks.
See the callback method for details.
.IP "mechanism => \s-1NAMES\s0" 4
.IX Item "mechanism => NAMES"
.PD 0
.IP "mech => \s-1NAMES\s0" 4
.IX Item "mech => NAMES"
.PD
Set the list of mechanisms to choose from.
See the mechanism method for details.
.IP "debug => \s-1VALUE\s0" 4
.IX Item "debug => VALUE"
Set the debug level bit-value to \f(CW\*(C`VALUE\*(C'\fR
.Sp
Debug output will be sent to \f(CW\*(C`STDERR\*(C'\fR. The
bits of this value are:
.Sp
.Vb 4
\& 1   Show debug messages in the Perl modules for the mechanisms.
\&     (Currently only used in GSSAPI)
\& 4   With security layers in place show information on packages read.
\& 8   With security layers in place show information on packages written.
.Ve
.Sp
The default value is 0.
.RE
.RS 4
.RE
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "mechanism ( )" 4
.IX Item "mechanism ( )"
Returns the current list of mechanisms
.IP "mechanism ( \s-1NAMES \s0)" 4
.IX Item "mechanism ( NAMES )"
Set the list of mechanisms to choose from. \f(CW\*(C`NAMES\*(C'\fR should be a space separated string
of the names.
.IP "callback ( \s-1NAME \s0)" 4
.IX Item "callback ( NAME )"
Returns the current callback associated with \f(CW\*(C`NAME\*(C'\fR.
.IP "callback ( \s-1NAME\s0 => \s-1VALUE, NAME\s0 => \s-1VALUE, ... \s0)" 4
.IX Item "callback ( NAME => VALUE, NAME => VALUE, ... )"
Sets the given callbacks to the given values
.IP "client_new ( \s-1SERVICE, HOST, SECURITY \s0)" 4
.IX Item "client_new ( SERVICE, HOST, SECURITY )"
Creates and returns a new connection object for a client-side connection.
.IP "server_new ( \s-1SERVICE, HOST, OPTIONS \s0)" 4
.IX Item "server_new ( SERVICE, HOST, OPTIONS )"
Creates and returns a new connection object for a server-side connection.
.IP "error ( )" 4
.IX Item "error ( )"
Returns any error from the last connection
.SH "The Connection Class"
.IX Header "The Connection Class"
.IP "server_start ( \s-1CHALLENGE \s0)" 4
.IX Item "server_start ( CHALLENGE )"
server_start begins the authentication using the chosen mechanism.
If the mechanism is not supported by the installed \s-1SASL\s0 it fails.
Because for some mechanisms the client has to start the negotiation,
you can give the client challenge as a parameter.
.IP "server_step ( \s-1CHALLENGE \s0)" 4
.IX Item "server_step ( CHALLENGE )"
server_step performs the next step in the negotiation process. The
first parameter you give is the clients challenge/response.
.IP "client_start ( )" 4
.IX Item "client_start ( )"
The initial step to be performed. Returns the initial value to pass to the server
or an empty list on error.
.IP "client_step ( \s-1CHALLENGE \s0)" 4
.IX Item "client_step ( CHALLENGE )"
This method is called when a response from the server requires it. \s-1CHALLENGE\s0
is the value from the server. Returns the next value to pass to the server or an
empty list on error.
.IP "need_step ( )" 4
.IX Item "need_step ( )"
Returns true if the selected mechanism requires another step before completion
(error or success).
.IP "answer ( \s-1NAME \s0)" 4
.IX Item "answer ( NAME )"
The method will return the value returned from the last call to the callback \s-1NAME\s0
.IP "property ( \s-1NAME \s0)" 4
.IX Item "property ( NAME )"
Returns the property value associated with \f(CW\*(C`NAME\*(C'\fR.
.IP "property ( \s-1NAME\s0 => \s-1VALUE, NAME\s0 => \s-1VALUE, ... \s0)" 4
.IX Item "property ( NAME => VALUE, NAME => VALUE, ... )"
Sets the named properties to their associated values.
.IP "service ( )" 4
.IX Item "service ( )"
Returns the service argument that was passed to *_new\-methods.
.IP "host ( )" 4
.IX Item "host ( )"
Returns the host argument that was passed to *_new\-methods.
.IP "mechanism ( )" 4
.IX Item "mechanism ( )"
Returns the name of the chosen mechanism.
.IP "is_success ( )" 4
.IX Item "is_success ( )"
Once \fIneed_step()\fR returns false, then you can check if the authentication
succeeded by calling this method which returns a boolean value.
.SS "Callbacks"
.IX Subsection "Callbacks"
There are three different ways in which a callback may be passed
.IP "\s-1CODEREF\s0" 4
.IX Item "CODEREF"
If the value passed is a code reference then, when needed, it will be called
and the connection object will be passed as the first argument. In addition
some callbacks may be passed additional arguments.
.IP "\s-1ARRAYREF\s0" 4
.IX Item "ARRAYREF"
If the value passed is an array reference, the first element in the array
must be a code reference. When the callback is called the code reference
will be called with the connection object passed as the first argument
and all other values from the array passed after.
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
All other values passed will be used directly. ie it is the same as
passing an code reference that, when called, returns the value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL::Perl, Authen::SASL::XS, Authen::SASL::Cyrus
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2005 Graham Barr. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL5.16.3pm                         0100644 0001750 0001750 00000025500 12566241555 023713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL 3"
.TH Authen::SASL 3 "2012-09-04" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL \- SASL Authentication framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Authen::SASL;
\&
\& $sasl = Authen::SASL\->new(
\&   mechanism => \*(AqCRAM\-MD5 PLAIN ANONYMOUS\*(Aq,
\&   callback => {
\&     pass => \e&fetch_password,
\&     user => $user,
\&   }
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1SASL\s0 is a generic mechanism for authentication used by several
network protocols. \fBAuthen::SASL\fR provides an implementation
framework that all protocols should be able to share.
.PP
The framework allows different implementations of the connection
class to be plugged in. At the time of writing there were two such
plugins.
.IP "Authen::SASL::Perl" 4
.IX Item "Authen::SASL::Perl"
This module implements several mechanisms and is implemented
entirely in Perl.
.IP "Authen::SASL::XS" 4
.IX Item "Authen::SASL::XS"
This module uses the Cyrus \s-1SASL\s0 C\-library (both version 1 and 2 
are supported).
.IP "Authen::SASL::Cyrus" 4
.IX Item "Authen::SASL::Cyrus"
This module is the predecessor to Authen::SASL::XS. It is reccomended
to use Authen::SASL::XS
.PP
By default the order in which these plugins are selected is 
Authen::SASL::XS, Authen::SASL::Cyrus and then Authen::SASL::Perl.
.PP
If you want to change it or want to specifically use one
implementation only simply do
.PP
.Vb 1
\& use Authen::SASL qw(Perl);
.Ve
.PP
or if you have another plugin module that supports the Authen::SASL \s-1API\s0
.PP
.Vb 1
\& use Authen::SASL qw(My::SASL::Plugin);
.Ve
.SS "\s-1CONTRUCTOR\s0"
.IX Subsection "CONTRUCTOR"
.IP "new ( \s-1OPTIONS\s0 )" 4
.IX Item "new ( OPTIONS )"
The constructor may be called with or without arguments. Passing arguments is
just a short cut to calling the \f(CW\*(C`mechanism\*(C'\fR and \f(CW\*(C`callback\*(C'\fR methods.
.RS 4
.IP "callback => { \s-1NAME\s0 => \s-1VALUE\s0, \s-1NAME\s0 => \s-1VALUE\s0, ... }" 4
.IX Item "callback => { NAME => VALUE, NAME => VALUE, ... }"
Set the callbacks.
See the callback method for details.
.IP "mechanism => \s-1NAMES\s0" 4
.IX Item "mechanism => NAMES"
.PD 0
.IP "mech => \s-1NAMES\s0" 4
.IX Item "mech => NAMES"
.PD
Set the list of mechanisms to choose from.
See the mechanism method for details.
.IP "debug => \s-1VALUE\s0" 4
.IX Item "debug => VALUE"
Set the debug level bit-value to \f(CW\*(C`VALUE\*(C'\fR
.Sp
Debug output will be sent to \f(CW\*(C`STDERR\*(C'\fR. The
bits of this value are:
.Sp
.Vb 4
\& 1   Show debug messages in the Perl modules for the mechanisms.
\&     (Currently only used in GSSAPI)
\& 4   With security layers in place show information on packages read.
\& 8   With security layers in place show information on packages written.
.Ve
.Sp
The default value is 0.
.RE
.RS 4
.RE
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "mechanism ( )" 4
.IX Item "mechanism ( )"
Returns the current list of mechanisms
.IP "mechanism ( \s-1NAMES\s0 )" 4
.IX Item "mechanism ( NAMES )"
Set the list of mechanisms to choose from. \f(CW\*(C`NAMES\*(C'\fR should be a space separated string
of the names.
.IP "callback ( \s-1NAME\s0 )" 4
.IX Item "callback ( NAME )"
Returns the current callback associated with \f(CW\*(C`NAME\*(C'\fR.
.IP "callback ( \s-1NAME\s0 => \s-1VALUE\s0, \s-1NAME\s0 => \s-1VALUE\s0, ... )" 4
.IX Item "callback ( NAME => VALUE, NAME => VALUE, ... )"
Sets the given callbacks to the given values
.IP "client_new ( \s-1SERVICE\s0, \s-1HOST\s0, \s-1SECURITY\s0 )" 4
.IX Item "client_new ( SERVICE, HOST, SECURITY )"
Creates and returns a new connection object for a client-side connection.
.IP "server_new ( \s-1SERVICE\s0, \s-1HOST\s0, \s-1OPTIONS\s0 )" 4
.IX Item "server_new ( SERVICE, HOST, OPTIONS )"
Creates and returns a new connection object for a server-side connection.
.IP "error ( )" 4
.IX Item "error ( )"
Returns any error from the last connection
.SH "The Connection Class"
.IX Header "The Connection Class"
.IP "server_start ( \s-1CHALLENGE\s0 )" 4
.IX Item "server_start ( CHALLENGE )"
server_start begins the authentication using the chosen mechanism.
If the mechanism is not supported by the installed \s-1SASL\s0 it fails.
Because for some mechanisms the client has to start the negotiation,
you can give the client challenge as a parameter.
.IP "server_step ( \s-1CHALLENGE\s0 )" 4
.IX Item "server_step ( CHALLENGE )"
server_step performs the next step in the negotiation process. The
first parameter you give is the clients challenge/response.
.IP "client_start ( )" 4
.IX Item "client_start ( )"
The initial step to be performed. Returns the initial value to pass to the server
or an empty list on error.
.IP "client_step ( \s-1CHALLENGE\s0 )" 4
.IX Item "client_step ( CHALLENGE )"
This method is called when a response from the server requires it. \s-1CHALLENGE\s0
is the value from the server. Returns the next value to pass to the server or an
empty list on error.
.IP "need_step ( )" 4
.IX Item "need_step ( )"
Returns true if the selected mechanism requires another step before completion
(error or success).
.IP "answer ( \s-1NAME\s0 )" 4
.IX Item "answer ( NAME )"
The method will return the value returned from the last call to the callback \s-1NAME\s0
.IP "property ( \s-1NAME\s0 )" 4
.IX Item "property ( NAME )"
Returns the property value associated with \f(CW\*(C`NAME\*(C'\fR.
.IP "property ( \s-1NAME\s0 => \s-1VALUE\s0, \s-1NAME\s0 => \s-1VALUE\s0, ... )" 4
.IX Item "property ( NAME => VALUE, NAME => VALUE, ... )"
Sets the named properties to their associated values.
.IP "service ( )" 4
.IX Item "service ( )"
Returns the service argument that was passed to *_new\-methods.
.IP "host ( )" 4
.IX Item "host ( )"
Returns the host argument that was passed to *_new\-methods.
.IP "mechanism ( )" 4
.IX Item "mechanism ( )"
Returns the name of the chosen mechanism.
.IP "is_success ( )" 4
.IX Item "is_success ( )"
Once \fIneed_step()\fR returns false, then you can check if the authentication
succeeded by calling this method which returns a boolean value.
.SS "Callbacks"
.IX Subsection "Callbacks"
There are three different ways in which a callback may be passed
.IP "\s-1CODEREF\s0" 4
.IX Item "CODEREF"
If the value passed is a code reference then, when needed, it will be called
and the connection object will be passed as the first argument. In addition
some callbacks may be passed additional arguments.
.IP "\s-1ARRAYREF\s0" 4
.IX Item "ARRAYREF"
If the value passed is an array reference, the first element in the array
must be a code reference. When the callback is called the code reference
will be called with the connection object passed as the first argument
and all other values from the array passed after.
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
All other values passed will be used directly. ie it is the same as
passing an code reference that, when called, returns the value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL::Perl, Authen::SASL::XS, Authen::SASL::Cyrus
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2005 Graham Barr. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL5.18.3pm                         0100644 0001750 0001750 00000025740 12566241556 023724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL 3"
.TH Authen::SASL 3 "2012-09-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL \- SASL Authentication framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Authen::SASL;
\&
\& $sasl = Authen::SASL\->new(
\&   mechanism => \*(AqCRAM\-MD5 PLAIN ANONYMOUS\*(Aq,
\&   callback => {
\&     pass => \e&fetch_password,
\&     user => $user,
\&   }
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1SASL\s0 is a generic mechanism for authentication used by several
network protocols. \fBAuthen::SASL\fR provides an implementation
framework that all protocols should be able to share.
.PP
The framework allows different implementations of the connection
class to be plugged in. At the time of writing there were two such
plugins.
.IP "Authen::SASL::Perl" 4
.IX Item "Authen::SASL::Perl"
This module implements several mechanisms and is implemented
entirely in Perl.
.IP "Authen::SASL::XS" 4
.IX Item "Authen::SASL::XS"
This module uses the Cyrus \s-1SASL\s0 C\-library (both version 1 and 2 
are supported).
.IP "Authen::SASL::Cyrus" 4
.IX Item "Authen::SASL::Cyrus"
This module is the predecessor to Authen::SASL::XS. It is reccomended
to use Authen::SASL::XS
.PP
By default the order in which these plugins are selected is 
Authen::SASL::XS, Authen::SASL::Cyrus and then Authen::SASL::Perl.
.PP
If you want to change it or want to specifically use one
implementation only simply do
.PP
.Vb 1
\& use Authen::SASL qw(Perl);
.Ve
.PP
or if you have another plugin module that supports the Authen::SASL \s-1API\s0
.PP
.Vb 1
\& use Authen::SASL qw(My::SASL::Plugin);
.Ve
.SS "\s-1CONTRUCTOR\s0"
.IX Subsection "CONTRUCTOR"
.IP "new ( \s-1OPTIONS \s0)" 4
.IX Item "new ( OPTIONS )"
The constructor may be called with or without arguments. Passing arguments is
just a short cut to calling the \f(CW\*(C`mechanism\*(C'\fR and \f(CW\*(C`callback\*(C'\fR methods.
.RS 4
.IP "callback => { \s-1NAME\s0 => \s-1VALUE, NAME\s0 => \s-1VALUE, ... \s0}" 4
.IX Item "callback => { NAME => VALUE, NAME => VALUE, ... }"
Set the callbacks.
See the callback method for details.
.IP "mechanism => \s-1NAMES\s0" 4
.IX Item "mechanism => NAMES"
.PD 0
.IP "mech => \s-1NAMES\s0" 4
.IX Item "mech => NAMES"
.PD
Set the list of mechanisms to choose from.
See the mechanism method for details.
.IP "debug => \s-1VALUE\s0" 4
.IX Item "debug => VALUE"
Set the debug level bit-value to \f(CW\*(C`VALUE\*(C'\fR
.Sp
Debug output will be sent to \f(CW\*(C`STDERR\*(C'\fR. The
bits of this value are:
.Sp
.Vb 4
\& 1   Show debug messages in the Perl modules for the mechanisms.
\&     (Currently only used in GSSAPI)
\& 4   With security layers in place show information on packages read.
\& 8   With security layers in place show information on packages written.
.Ve
.Sp
The default value is 0.
.RE
.RS 4
.RE
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "mechanism ( )" 4
.IX Item "mechanism ( )"
Returns the current list of mechanisms
.IP "mechanism ( \s-1NAMES \s0)" 4
.IX Item "mechanism ( NAMES )"
Set the list of mechanisms to choose from. \f(CW\*(C`NAMES\*(C'\fR should be a space separated string
of the names.
.IP "callback ( \s-1NAME \s0)" 4
.IX Item "callback ( NAME )"
Returns the current callback associated with \f(CW\*(C`NAME\*(C'\fR.
.IP "callback ( \s-1NAME\s0 => \s-1VALUE, NAME\s0 => \s-1VALUE, ... \s0)" 4
.IX Item "callback ( NAME => VALUE, NAME => VALUE, ... )"
Sets the given callbacks to the given values
.IP "client_new ( \s-1SERVICE, HOST, SECURITY \s0)" 4
.IX Item "client_new ( SERVICE, HOST, SECURITY )"
Creates and returns a new connection object for a client-side connection.
.IP "server_new ( \s-1SERVICE, HOST, OPTIONS \s0)" 4
.IX Item "server_new ( SERVICE, HOST, OPTIONS )"
Creates and returns a new connection object for a server-side connection.
.IP "error ( )" 4
.IX Item "error ( )"
Returns any error from the last connection
.SH "The Connection Class"
.IX Header "The Connection Class"
.IP "server_start ( \s-1CHALLENGE \s0)" 4
.IX Item "server_start ( CHALLENGE )"
server_start begins the authentication using the chosen mechanism.
If the mechanism is not supported by the installed \s-1SASL\s0 it fails.
Because for some mechanisms the client has to start the negotiation,
you can give the client challenge as a parameter.
.IP "server_step ( \s-1CHALLENGE \s0)" 4
.IX Item "server_step ( CHALLENGE )"
server_step performs the next step in the negotiation process. The
first parameter you give is the clients challenge/response.
.IP "client_start ( )" 4
.IX Item "client_start ( )"
The initial step to be performed. Returns the initial value to pass to the server
or an empty list on error.
.IP "client_step ( \s-1CHALLENGE \s0)" 4
.IX Item "client_step ( CHALLENGE )"
This method is called when a response from the server requires it. \s-1CHALLENGE\s0
is the value from the server. Returns the next value to pass to the server or an
empty list on error.
.IP "need_step ( )" 4
.IX Item "need_step ( )"
Returns true if the selected mechanism requires another step before completion
(error or success).
.IP "answer ( \s-1NAME \s0)" 4
.IX Item "answer ( NAME )"
The method will return the value returned from the last call to the callback \s-1NAME\s0
.IP "property ( \s-1NAME \s0)" 4
.IX Item "property ( NAME )"
Returns the property value associated with \f(CW\*(C`NAME\*(C'\fR.
.IP "property ( \s-1NAME\s0 => \s-1VALUE, NAME\s0 => \s-1VALUE, ... \s0)" 4
.IX Item "property ( NAME => VALUE, NAME => VALUE, ... )"
Sets the named properties to their associated values.
.IP "service ( )" 4
.IX Item "service ( )"
Returns the service argument that was passed to *_new\-methods.
.IP "host ( )" 4
.IX Item "host ( )"
Returns the host argument that was passed to *_new\-methods.
.IP "mechanism ( )" 4
.IX Item "mechanism ( )"
Returns the name of the chosen mechanism.
.IP "is_success ( )" 4
.IX Item "is_success ( )"
Once \fIneed_step()\fR returns false, then you can check if the authentication
succeeded by calling this method which returns a boolean value.
.SS "Callbacks"
.IX Subsection "Callbacks"
There are three different ways in which a callback may be passed
.IP "\s-1CODEREF\s0" 4
.IX Item "CODEREF"
If the value passed is a code reference then, when needed, it will be called
and the connection object will be passed as the first argument. In addition
some callbacks may be passed additional arguments.
.IP "\s-1ARRAYREF\s0" 4
.IX Item "ARRAYREF"
If the value passed is an array reference, the first element in the array
must be a code reference. When the callback is called the code reference
will be called with the connection object passed as the first argument
and all other values from the array passed after.
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
All other values passed will be used directly. ie it is the same as
passing an code reference that, when called, returns the value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL::Perl, Authen::SASL::XS, Authen::SASL::Cyrus
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2005 Graham Barr. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl.3pm                       0100644 0001750 0001750 00000021072 12566241556 024411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl 3"
.TH Authen::SASL::Perl 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl \-\- Perl implementation of the SASL Authentication framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Authen::SASL qw(Perl);
\&
\& $sasl = Authen::SASL\->new(
\&   mechanism => \*(AqCRAM\-MD5 PLAIN ANONYMOUS\*(Aq,
\&   callback => {
\&     user => $user,
\&     pass => \e&fetch_password
\&   }
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBAuthen::SASL::Perl\fR is the pure Perl implementation of \s-1SASL\s0 mechanisms
in the \fBAuthen::SASL\fR framework.
.PP
At the time of this writing it provides the client part implementation
for the following \s-1SASL\s0 mechanisms:
.IP "\s-1ANONYMOUS\s0" 4
.IX Item "ANONYMOUS"
The Anonymous \s-1SASL\s0 Mechanism as defined in \s-1RFC 2245\s0 resp. 
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-anon\-03.txt from February 2004
provides a method to anonymously access internet services.
.Sp
Since it does no authentication it does not need to send 
any confidential information such as passwords in plain text
over the network.
.IP "\s-1CRAM\-MD5\s0" 4
.IX Item "CRAM-MD5"
The \s-1CRAM\-MD5 SASL\s0 Mechanism as defined in \s-1RFC2195\s0 resp.
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-crammd5\-XX.txt
offers a simple challenge-response authentication mechanism.
.Sp
Since it is a challenge-response authentication mechanism
no passwords are transferred in clear-text over the wire.
.Sp
Due to the simplicity of the protocol \s-1CRAM\-MD5\s0 is susceptible
to replay and dictionary attacks, so \s-1DIGEST\-MD5\s0 should be used
in preferrence.
.IP "\s-1DIGEST\-MD5\s0" 4
.IX Item "DIGEST-MD5"
The \s-1DIGEST\-MD5 SASL\s0 Mechanism as defined in \s-1RFC 2831\s0 resp.
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-rfc2831bis\-XX.txt
offers the \s-1HTTP\s0 Digest Access Authentication as \s-1SASL\s0 mechanism.
.Sp
Like \s-1CRAM\-MD5\s0 it is a challenge-response authentication
method that does not send plain text passwords over the network.
.Sp
Compared to \s-1CRAM\-MD5, DIGEST\-MD5\s0 prevents chosen plaintext
attacks, and permits the use of third party authentication servers,
so that it is recommended to use \s-1DIGEST\-MD5\s0 instead of \s-1CRAM\-MD5\s0
when possible.
.IP "\s-1EXTERNAL\s0" 4
.IX Item "EXTERNAL"
The \s-1EXTERNAL SASL\s0 mechanism as defined in \s-1RFC 2222\s0
allows the use of external authentication systems as \s-1SASL\s0 mechanisms.
.IP "\s-1GSSAPI\s0" 4
.IX Item "GSSAPI"
The \s-1GSSAPI SASL\s0 mechanism as defined in \s-1RFC 2222\s0 resp. \s-1IETF\s0 Draft
draft\-ietf\-sasl\-gssapi\-XX.txt allows using the Generic Security Service
Application Program Interface [\s-1GSSAPI\s0] \s-1KERBEROS V5\s0 as as \s-1SASL\s0 mechanism.
.Sp
Although \s-1GSSAPI\s0 is a general mechanism for authentication it is almost
exlusively used for Kerberos 5.
.IP "\s-1LOGIN\s0" 4
.IX Item "LOGIN"
The \s-1LOGIN SASL\s0 Mechanism as defined in \s-1IETF\s0 Draft
draft\-murchison\-sasl\-login\-XX.txt allows  the
combination of username and clear-text password to be used
in a \s-1SASL\s0 mechanism.
.Sp
It does does not provide a security layer and sends the credentials
in clear over the wire.
Thus this mechanism should not be used without adequate security
protection.
.IP "\s-1PLAIN\s0" 4
.IX Item "PLAIN"
The Plain \s-1SASL\s0 Mechanism as defined in \s-1RFC 2595\s0 resp. \s-1IETF\s0 Draft
draft\-ietf\-sasl\-plain\-XX.txt is another \s-1SASL\s0 mechanism that allows
username and clear-text password combinations in \s-1SASL\s0 environments.
.Sp
Like \s-1LOGIN\s0 it sends the credentials in clear over the network
and should not be used without sufficient security protection.
.PP
As for server support, only \fI\s-1PLAIN\s0\fR, \fI\s-1LOGIN\s0\fR and \fI\s-1DIGEST\-MD5\s0\fR are supported
at the time of this writing.
.PP
\&\f(CW\*(C`server_new\*(C'\fR \s-1OPTIONS\s0 is a hashref that is only relevant for \fI\s-1DIGEST\-MD5\s0\fR for
now and it supports the following options:
.IP "\- no_integrity" 4
.IX Item "- no_integrity"
.PD 0
.IP "\- no_confidentiality" 4
.IX Item "- no_confidentiality"
.PD
.PP
which configures how the security layers are negotiated with the client (or
rather imposed to the client).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl::ANONYMOUS,
Authen::SASL::Perl::CRAM_MD5,
Authen::SASL::Perl::DIGEST_MD5,
Authen::SASL::Perl::EXTERNAL,
Authen::SASL::Perl::GSSAPI,
Authen::SASL::Perl::LOGIN,
Authen::SASL::Perl::PLAIN
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Marschall <peter@adpm.de>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004\-2006 Peter Marschall.
All rights reserved. This document is distributed, and may be redistributed,
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl5.16.3pm                   0100644 0001750 0001750 00000020623 12566241555 024723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl 3"
.TH Authen::SASL::Perl 3 "2010-03-11" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl \-\- Perl implementation of the SASL Authentication framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Authen::SASL qw(Perl);
\&
\& $sasl = Authen::SASL\->new(
\&   mechanism => \*(AqCRAM\-MD5 PLAIN ANONYMOUS\*(Aq,
\&   callback => {
\&     user => $user,
\&     pass => \e&fetch_password
\&   }
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBAuthen::SASL::Perl\fR is the pure Perl implementation of \s-1SASL\s0 mechanisms
in the \fBAuthen::SASL\fR framework.
.PP
At the time of this writing it provides the client part implementation
for the following \s-1SASL\s0 mechanisms:
.IP "\s-1ANONYMOUS\s0" 4
.IX Item "ANONYMOUS"
The Anonymous \s-1SASL\s0 Mechanism as defined in \s-1RFC\s0 2245 resp. 
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-anon\-03.txt from February 2004
provides a method to anonymously access internet services.
.Sp
Since it does no authentication it does not need to send 
any confidential information such as passwords in plain text
over the network.
.IP "\s-1CRAM\-MD5\s0" 4
.IX Item "CRAM-MD5"
The \s-1CRAM\-MD5\s0 \s-1SASL\s0 Mechanism as defined in \s-1RFC2195\s0 resp.
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-crammd5\-XX.txt
offers a simple challenge-response authentication mechanism.
.Sp
Since it is a challenge-response authentication mechanism
no passwords are transferred in clear-text over the wire.
.Sp
Due to the simplicity of the protocol \s-1CRAM\-MD5\s0 is susceptible
to replay and dictionary attacks, so \s-1DIGEST\-MD5\s0 should be used
in preferrence.
.IP "\s-1DIGEST\-MD5\s0" 4
.IX Item "DIGEST-MD5"
The \s-1DIGEST\-MD5\s0 \s-1SASL\s0 Mechanism as defined in \s-1RFC\s0 2831 resp.
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-rfc2831bis\-XX.txt
offers the \s-1HTTP\s0 Digest Access Authentication as \s-1SASL\s0 mechanism.
.Sp
Like \s-1CRAM\-MD5\s0 it is a challenge-response authentication
method that does not send plain text passwords over the network.
.Sp
Compared to \s-1CRAM\-MD5\s0, \s-1DIGEST\-MD5\s0 prevents chosen plaintext
attacks, and permits the use of third party authentication servers,
so that it is recommended to use \s-1DIGEST\-MD5\s0 instead of \s-1CRAM\-MD5\s0
when possible.
.IP "\s-1EXTERNAL\s0" 4
.IX Item "EXTERNAL"
The \s-1EXTERNAL\s0 \s-1SASL\s0 mechanism as defined in \s-1RFC\s0 2222
allows the use of external authentication systems as \s-1SASL\s0 mechanisms.
.IP "\s-1GSSAPI\s0" 4
.IX Item "GSSAPI"
The \s-1GSSAPI\s0 \s-1SASL\s0 mechanism as defined in \s-1RFC\s0 2222 resp. \s-1IETF\s0 Draft
draft\-ietf\-sasl\-gssapi\-XX.txt allows using the Generic Security Service
Application Program Interface [\s-1GSSAPI\s0] \s-1KERBEROS\s0 V5 as as \s-1SASL\s0 mechanism.
.Sp
Although \s-1GSSAPI\s0 is a general mechanism for authentication it is almost
exlusively used for Kerberos 5.
.IP "\s-1LOGIN\s0" 4
.IX Item "LOGIN"
The \s-1LOGIN\s0 \s-1SASL\s0 Mechanism as defined in \s-1IETF\s0 Draft
draft\-murchison\-sasl\-login\-XX.txt allows  the
combination of username and clear-text password to be used
in a \s-1SASL\s0 mechanism.
.Sp
It does does not provide a security layer and sends the credentials
in clear over the wire.
Thus this mechanism should not be used without adequate security
protection.
.IP "\s-1PLAIN\s0" 4
.IX Item "PLAIN"
The Plain \s-1SASL\s0 Mechanism as defined in \s-1RFC\s0 2595 resp. \s-1IETF\s0 Draft
draft\-ietf\-sasl\-plain\-XX.txt is another \s-1SASL\s0 mechanism that allows
username and clear-text password combinations in \s-1SASL\s0 environments.
.Sp
Like \s-1LOGIN\s0 it sends the credentials in clear over the network
and should not be used without sufficient security protection.
.PP
As for server support, only \fI\s-1PLAIN\s0\fR, \fI\s-1LOGIN\s0\fR and \fI\s-1DIGEST\-MD5\s0\fR are supported
at the time of this writing.
.PP
\&\f(CW\*(C`server_new\*(C'\fR \s-1OPTIONS\s0 is a hashref that is only relevant for \fI\s-1DIGEST\-MD5\s0\fR for
now and it supports the following options:
.IP "\- no_integrity" 4
.IX Item "- no_integrity"
.PD 0
.IP "\- no_confidentiality" 4
.IX Item "- no_confidentiality"
.PD
.PP
which configures how the security layers are negotiated with the client (or
rather imposed to the client).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl::ANONYMOUS,
Authen::SASL::Perl::CRAM_MD5,
Authen::SASL::Perl::DIGEST_MD5,
Authen::SASL::Perl::EXTERNAL,
Authen::SASL::Perl::GSSAPI,
Authen::SASL::Perl::LOGIN,
Authen::SASL::Perl::PLAIN
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Marschall <peter@adpm.de>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004\-2006 Peter Marschall.
All rights reserved. This document is distributed, and may be redistributed,
under the same terms as Perl itself.
                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl5.18.3pm                   0100644 0001750 0001750 00000021072 12566241556 024725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl 3"
.TH Authen::SASL::Perl 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl \-\- Perl implementation of the SASL Authentication framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Authen::SASL qw(Perl);
\&
\& $sasl = Authen::SASL\->new(
\&   mechanism => \*(AqCRAM\-MD5 PLAIN ANONYMOUS\*(Aq,
\&   callback => {
\&     user => $user,
\&     pass => \e&fetch_password
\&   }
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBAuthen::SASL::Perl\fR is the pure Perl implementation of \s-1SASL\s0 mechanisms
in the \fBAuthen::SASL\fR framework.
.PP
At the time of this writing it provides the client part implementation
for the following \s-1SASL\s0 mechanisms:
.IP "\s-1ANONYMOUS\s0" 4
.IX Item "ANONYMOUS"
The Anonymous \s-1SASL\s0 Mechanism as defined in \s-1RFC 2245\s0 resp. 
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-anon\-03.txt from February 2004
provides a method to anonymously access internet services.
.Sp
Since it does no authentication it does not need to send 
any confidential information such as passwords in plain text
over the network.
.IP "\s-1CRAM\-MD5\s0" 4
.IX Item "CRAM-MD5"
The \s-1CRAM\-MD5 SASL\s0 Mechanism as defined in \s-1RFC2195\s0 resp.
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-crammd5\-XX.txt
offers a simple challenge-response authentication mechanism.
.Sp
Since it is a challenge-response authentication mechanism
no passwords are transferred in clear-text over the wire.
.Sp
Due to the simplicity of the protocol \s-1CRAM\-MD5\s0 is susceptible
to replay and dictionary attacks, so \s-1DIGEST\-MD5\s0 should be used
in preferrence.
.IP "\s-1DIGEST\-MD5\s0" 4
.IX Item "DIGEST-MD5"
The \s-1DIGEST\-MD5 SASL\s0 Mechanism as defined in \s-1RFC 2831\s0 resp.
in \s-1IETF\s0 Draft draft\-ietf\-sasl\-rfc2831bis\-XX.txt
offers the \s-1HTTP\s0 Digest Access Authentication as \s-1SASL\s0 mechanism.
.Sp
Like \s-1CRAM\-MD5\s0 it is a challenge-response authentication
method that does not send plain text passwords over the network.
.Sp
Compared to \s-1CRAM\-MD5, DIGEST\-MD5\s0 prevents chosen plaintext
attacks, and permits the use of third party authentication servers,
so that it is recommended to use \s-1DIGEST\-MD5\s0 instead of \s-1CRAM\-MD5\s0
when possible.
.IP "\s-1EXTERNAL\s0" 4
.IX Item "EXTERNAL"
The \s-1EXTERNAL SASL\s0 mechanism as defined in \s-1RFC 2222\s0
allows the use of external authentication systems as \s-1SASL\s0 mechanisms.
.IP "\s-1GSSAPI\s0" 4
.IX Item "GSSAPI"
The \s-1GSSAPI SASL\s0 mechanism as defined in \s-1RFC 2222\s0 resp. \s-1IETF\s0 Draft
draft\-ietf\-sasl\-gssapi\-XX.txt allows using the Generic Security Service
Application Program Interface [\s-1GSSAPI\s0] \s-1KERBEROS V5\s0 as as \s-1SASL\s0 mechanism.
.Sp
Although \s-1GSSAPI\s0 is a general mechanism for authentication it is almost
exlusively used for Kerberos 5.
.IP "\s-1LOGIN\s0" 4
.IX Item "LOGIN"
The \s-1LOGIN SASL\s0 Mechanism as defined in \s-1IETF\s0 Draft
draft\-murchison\-sasl\-login\-XX.txt allows  the
combination of username and clear-text password to be used
in a \s-1SASL\s0 mechanism.
.Sp
It does does not provide a security layer and sends the credentials
in clear over the wire.
Thus this mechanism should not be used without adequate security
protection.
.IP "\s-1PLAIN\s0" 4
.IX Item "PLAIN"
The Plain \s-1SASL\s0 Mechanism as defined in \s-1RFC 2595\s0 resp. \s-1IETF\s0 Draft
draft\-ietf\-sasl\-plain\-XX.txt is another \s-1SASL\s0 mechanism that allows
username and clear-text password combinations in \s-1SASL\s0 environments.
.Sp
Like \s-1LOGIN\s0 it sends the credentials in clear over the network
and should not be used without sufficient security protection.
.PP
As for server support, only \fI\s-1PLAIN\s0\fR, \fI\s-1LOGIN\s0\fR and \fI\s-1DIGEST\-MD5\s0\fR are supported
at the time of this writing.
.PP
\&\f(CW\*(C`server_new\*(C'\fR \s-1OPTIONS\s0 is a hashref that is only relevant for \fI\s-1DIGEST\-MD5\s0\fR for
now and it supports the following options:
.IP "\- no_integrity" 4
.IX Item "- no_integrity"
.PD 0
.IP "\- no_confidentiality" 4
.IX Item "- no_confidentiality"
.PD
.PP
which configures how the security layers are negotiated with the client (or
rather imposed to the client).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl::ANONYMOUS,
Authen::SASL::Perl::CRAM_MD5,
Authen::SASL::Perl::DIGEST_MD5,
Authen::SASL::Perl::EXTERNAL,
Authen::SASL::Perl::GSSAPI,
Authen::SASL::Perl::LOGIN,
Authen::SASL::Perl::PLAIN
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Marschall <peter@adpm.de>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004\-2006 Peter Marschall.
All rights reserved. This document is distributed, and may be redistributed,
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::ANONYMOUS.3pm            0100644 0001750 0001750 00000012524 12566241556 026110  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::ANONYMOUS 3"
.TH Authen::SASL::Perl::ANONYMOUS 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::ANONYMOUS \- Anonymous Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqANONYMOUS\*(Aq,
\&    callback  => {
\&      authname => $mailaddress
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1ANONYMOUS SASL\s0 algorithm,
as described in \s-1RFC 2245\s0 resp. in \s-1IETF\s0 Draft draft\-ietf\-sasl\-anon\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "authname" 4
.IX Item "authname"
email address or \s-1UTF\-8\s0 encoded string to be used as
trace information for the server
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::ANONYMOUS5.16.3pm        0100644 0001750 0001750 00000012212 12566241555 026413  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::ANONYMOUS 3"
.TH Authen::SASL::Perl::ANONYMOUS 3 "2010-03-11" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::ANONYMOUS \- Anonymous Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqANONYMOUS\*(Aq,
\&    callback  => {
\&      authname => $mailaddress
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1ANONYMOUS\s0 \s-1SASL\s0 algorithm,
as described in \s-1RFC\s0 2245 resp. in \s-1IETF\s0 Draft draft\-ietf\-sasl\-anon\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "authname" 4
.IX Item "authname"
email address or \s-1UTF\-8\s0 encoded string to be used as
trace information for the server
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::ANONYMOUS5.18.3pm        0100644 0001750 0001750 00000012524 12566241556 026424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::ANONYMOUS 3"
.TH Authen::SASL::Perl::ANONYMOUS 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::ANONYMOUS \- Anonymous Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqANONYMOUS\*(Aq,
\&    callback  => {
\&      authname => $mailaddress
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1ANONYMOUS SASL\s0 algorithm,
as described in \s-1RFC 2245\s0 resp. in \s-1IETF\s0 Draft draft\-ietf\-sasl\-anon\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "authname" 4
.IX Item "authname"
email address or \s-1UTF\-8\s0 encoded string to be used as
trace information for the server
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::CRAM_MD5.3pm             0100644 0001750 0001750 00000012564 12566241556 025713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::CRAM_MD5 3"
.TH Authen::SASL::Perl::CRAM_MD5 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::CRAM_MD5 \- CRAM MD5 Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqCRAM\-MD5\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1CRAM\-MD5 SASL\s0 algorithm,
as described in \s-1RFC 2195\s0 resp. in \s-1IETF\s0 Draft draft\-ietf\-sasl\-crammd5\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::CRAM_MD55.16.3pm         0100644 0001750 0001750 00000012252 12566241555 026216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::CRAM_MD5 3"
.TH Authen::SASL::Perl::CRAM_MD5 3 "2010-03-11" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::CRAM_MD5 \- CRAM MD5 Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqCRAM\-MD5\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1CRAM\-MD5\s0 \s-1SASL\s0 algorithm,
as described in \s-1RFC\s0 2195 resp. in \s-1IETF\s0 Draft draft\-ietf\-sasl\-crammd5\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::CRAM_MD55.18.3pm         0100644 0001750 0001750 00000012564 12566241556 026227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::CRAM_MD5 3"
.TH Authen::SASL::Perl::CRAM_MD5 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::CRAM_MD5 \- CRAM MD5 Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqCRAM\-MD5\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1CRAM\-MD5 SASL\s0 algorithm,
as described in \s-1RFC 2195\s0 resp. in \s-1IETF\s0 Draft draft\-ietf\-sasl\-crammd5\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::DIGEST_MD5.3pm           0100644 0001750 0001750 00000016572 12566241556 026153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::DIGEST_MD5 3"
.TH Authen::SASL::Perl::DIGEST_MD5 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::DIGEST_MD5 \- Digest MD5 Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqDIGEST\-MD5\*(Aq,
\&    callback  => {
\&      user => $user, 
\&      pass => $pass,
\&      serv => $serv
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server parts of the \s-1DIGEST\-MD5 SASL\s0
algorithm, as described in \s-1RFC 2831.\s0
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIclient\fR
.IX Subsection "client"
.IP "authname" 4
.IX Item "authname"
The authorization id to use after successful authentication
.IP "user" 4
.IX Item "user"
The username to be used in the response
.IP "pass" 4
.IX Item "pass"
The password to be used to compute the response.
.IP "serv" 4
.IX Item "serv"
The service name when authenticating to a replicated service
.IP "realm" 4
.IX Item "realm"
The authentication realm when overriding the server-provided default.
If not given the server-provided value is used.
.Sp
The callback will be passed the list of realms that the server provided
in the initial response.
.PP
\fIserver\fR
.IX Subsection "server"
.IP "realm" 4
.IX Item "realm"
The default realm to provide to the client
.IP "getsecret(username, realm, authzid)" 4
.IX Item "getsecret(username, realm, authzid)"
returns the password associated with \f(CW\*(C`username\*(C'\fR and \f(CW\*(C`realm\*(C'\fR
.SS "\s-1PROPERTIES\s0"
.IX Subsection "PROPERTIES"
The properties used are:
.IP "maxbuf" 4
.IX Item "maxbuf"
The maximum buffer size for receiving cipher text
.IP "minssf" 4
.IX Item "minssf"
The minimum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 0
.IP "maxssf" 4
.IX Item "maxssf"
The maximum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 2**31
.IP "externalssf" 4
.IX Item "externalssf"
The \s-1SSF\s0 value provided by an underlying external security layer.
The default is 0
.IP "ssf" 4
.IX Item "ssf"
The actual \s-1SSF\s0 value provided by the \s-1SASL\s0 security layer after the \s-1SASL\s0
authentication phase has been completed. This value is read-only and set
by the implementation after the \s-1SASL\s0 authentication phase has been completed.
.IP "maxout" 4
.IX Item "maxout"
The maximum plaintext buffer size for sending data to the peer.
This value is set by the implementation after the \s-1SASL\s0 authentication
phase has been completed and a \s-1SASL\s0 security layer is in effect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Graham Barr, Djamel Boudjerda (\s-1NEXOR\s0), Paul Connolly, Julian Onions (\s-1NEXOR\s0),
Yann Kerherve.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2009 Graham Barr, Djamel Boudjerda, Paul Connolly,
Julian Onions, Nexor, Peter Marschall and Yann Kerherve.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 805:" 4
.IX Item "Around line 805:"
Unknown directive: =over4
.IP "Around line 807:" 4
.IX Item "Around line 807:"
\&'=item' outside of any '=over'
                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::DIGEST_MD55.16.3pm       0100644 0001750 0001750 00000016260 12566241555 026456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::DIGEST_MD5 3"
.TH Authen::SASL::Perl::DIGEST_MD5 3 "2010-03-11" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::DIGEST_MD5 \- Digest MD5 Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqDIGEST\-MD5\*(Aq,
\&    callback  => {
\&      user => $user, 
\&      pass => $pass,
\&      serv => $serv
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server parts of the \s-1DIGEST\-MD5\s0 \s-1SASL\s0
algorithm, as described in \s-1RFC\s0 2831.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIclient\fR
.IX Subsection "client"
.IP "authname" 4
.IX Item "authname"
The authorization id to use after successful authentication
.IP "user" 4
.IX Item "user"
The username to be used in the response
.IP "pass" 4
.IX Item "pass"
The password to be used to compute the response.
.IP "serv" 4
.IX Item "serv"
The service name when authenticating to a replicated service
.IP "realm" 4
.IX Item "realm"
The authentication realm when overriding the server-provided default.
If not given the server-provided value is used.
.Sp
The callback will be passed the list of realms that the server provided
in the initial response.
.PP
\fIserver\fR
.IX Subsection "server"
.IP "realm" 4
.IX Item "realm"
The default realm to provide to the client
.IP "getsecret(username, realm, authzid)" 4
.IX Item "getsecret(username, realm, authzid)"
returns the password associated with \f(CW\*(C`username\*(C'\fR and \f(CW\*(C`realm\*(C'\fR
.SS "\s-1PROPERTIES\s0"
.IX Subsection "PROPERTIES"
The properties used are:
.IP "maxbuf" 4
.IX Item "maxbuf"
The maximum buffer size for receiving cipher text
.IP "minssf" 4
.IX Item "minssf"
The minimum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 0
.IP "maxssf" 4
.IX Item "maxssf"
The maximum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 2**31
.IP "externalssf" 4
.IX Item "externalssf"
The \s-1SSF\s0 value provided by an underlying external security layer.
The default is 0
.IP "ssf" 4
.IX Item "ssf"
The actual \s-1SSF\s0 value provided by the \s-1SASL\s0 security layer after the \s-1SASL\s0
authentication phase has been completed. This value is read-only and set
by the implementation after the \s-1SASL\s0 authentication phase has been completed.
.IP "maxout" 4
.IX Item "maxout"
The maximum plaintext buffer size for sending data to the peer.
This value is set by the implementation after the \s-1SASL\s0 authentication
phase has been completed and a \s-1SASL\s0 security layer is in effect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Graham Barr, Djamel Boudjerda (\s-1NEXOR\s0), Paul Connolly, Julian Onions (\s-1NEXOR\s0),
Yann Kerherve.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2009 Graham Barr, Djamel Boudjerda, Paul Connolly,
Julian Onions, Nexor, Peter Marschall and Yann Kerherve.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 805:" 4
.IX Item "Around line 805:"
Unknown directive: =over4
.IP "Around line 807:" 4
.IX Item "Around line 807:"
\&'=item' outside of any '=over'
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::DIGEST_MD55.18.3pm       0100644 0001750 0001750 00000016572 12566241556 026467  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::DIGEST_MD5 3"
.TH Authen::SASL::Perl::DIGEST_MD5 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::DIGEST_MD5 \- Digest MD5 Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqDIGEST\-MD5\*(Aq,
\&    callback  => {
\&      user => $user, 
\&      pass => $pass,
\&      serv => $serv
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server parts of the \s-1DIGEST\-MD5 SASL\s0
algorithm, as described in \s-1RFC 2831.\s0
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIclient\fR
.IX Subsection "client"
.IP "authname" 4
.IX Item "authname"
The authorization id to use after successful authentication
.IP "user" 4
.IX Item "user"
The username to be used in the response
.IP "pass" 4
.IX Item "pass"
The password to be used to compute the response.
.IP "serv" 4
.IX Item "serv"
The service name when authenticating to a replicated service
.IP "realm" 4
.IX Item "realm"
The authentication realm when overriding the server-provided default.
If not given the server-provided value is used.
.Sp
The callback will be passed the list of realms that the server provided
in the initial response.
.PP
\fIserver\fR
.IX Subsection "server"
.IP "realm" 4
.IX Item "realm"
The default realm to provide to the client
.IP "getsecret(username, realm, authzid)" 4
.IX Item "getsecret(username, realm, authzid)"
returns the password associated with \f(CW\*(C`username\*(C'\fR and \f(CW\*(C`realm\*(C'\fR
.SS "\s-1PROPERTIES\s0"
.IX Subsection "PROPERTIES"
The properties used are:
.IP "maxbuf" 4
.IX Item "maxbuf"
The maximum buffer size for receiving cipher text
.IP "minssf" 4
.IX Item "minssf"
The minimum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 0
.IP "maxssf" 4
.IX Item "maxssf"
The maximum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 2**31
.IP "externalssf" 4
.IX Item "externalssf"
The \s-1SSF\s0 value provided by an underlying external security layer.
The default is 0
.IP "ssf" 4
.IX Item "ssf"
The actual \s-1SSF\s0 value provided by the \s-1SASL\s0 security layer after the \s-1SASL\s0
authentication phase has been completed. This value is read-only and set
by the implementation after the \s-1SASL\s0 authentication phase has been completed.
.IP "maxout" 4
.IX Item "maxout"
The maximum plaintext buffer size for sending data to the peer.
This value is set by the implementation after the \s-1SASL\s0 authentication
phase has been completed and a \s-1SASL\s0 security layer is in effect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Graham Barr, Djamel Boudjerda (\s-1NEXOR\s0), Paul Connolly, Julian Onions (\s-1NEXOR\s0),
Yann Kerherve.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003\-2009 Graham Barr, Djamel Boudjerda, Paul Connolly,
Julian Onions, Nexor, Peter Marschall and Yann Kerherve.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 805:" 4
.IX Item "Around line 805:"
Unknown directive: =over4
.IP "Around line 807:" 4
.IX Item "Around line 807:"
\&'=item' outside of any '=over'
                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::EXTERNAL.3pm             0100644 0001750 0001750 00000012316 12566241556 025741  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::EXTERNAL 3"
.TH Authen::SASL::Perl::EXTERNAL 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::EXTERNAL \- External Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqEXTERNAL\*(Aq,
\&    callback  => {
\&      user => $user
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1EXTERNAL SASL\s0 algorithm,
as described in \s-1RFC 2222.\s0
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::EXTERNAL5.16.3pm         0100644 0001750 0001750 00000012004 12566241555 026244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::EXTERNAL 3"
.TH Authen::SASL::Perl::EXTERNAL 3 "2010-03-11" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::EXTERNAL \- External Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqEXTERNAL\*(Aq,
\&    callback  => {
\&      user => $user
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1EXTERNAL\s0 \s-1SASL\s0 algorithm,
as described in \s-1RFC\s0 2222.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::EXTERNAL5.18.3pm         0100644 0001750 0001750 00000012316 12566241556 026255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::EXTERNAL 3"
.TH Authen::SASL::Perl::EXTERNAL 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::EXTERNAL \- External Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqEXTERNAL\*(Aq,
\&    callback  => {
\&      user => $user
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1EXTERNAL SASL\s0 algorithm,
as described in \s-1RFC 2222.\s0
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::GSSAPI.3pm               0100644 0001750 0001750 00000020247 12566241556 025507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::GSSAPI 3"
.TH Authen::SASL::Perl::GSSAPI 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::GSSAPI \- GSSAPI (Kerberosv5) Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new( mechanism => \*(AqGSSAPI\*(Aq );
\&
\&  $sasl = Authen::SASL\->new( mechanism => \*(AqGSSAPI\*(Aq,
\&                             callback => { pass => $mycred });
\&
\&  $sasl\->client_start( $service, $host );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1GSSAPI SASL\s0 algorithm,
as described in \s-1RFC 2222\s0 section 7.2.1 resp. draft\-ietf\-sasl\-gssapi\-XX.txt.
.PP
With a valid Kerberos 5 credentials cache (aka \s-1TGT\s0) it allows
to connect to \fIservice\fR@\fIhost\fR given as the first two parameters
to Authen::SASL's \fIclient_start()\fR method.  Alternatively, a GSSAPI::Cred
object can be passed in via the Authen::SASL callback hash using
the `pass' key.
.PP
Please note that this module does not currently implement a \s-1SASL\s0
security layer following authentication. Unless the connection is
protected by other means, such as \s-1TLS,\s0 it will be vulnerable to
man-in-the-middle attacks. If security layers are required, then the
Authen::SASL::XS \s-1GSSAPI\s0 module should be used instead.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "authname" 4
.IX Item "authname"
The authorization identity to be used in \s-1SASL\s0 exchange
.IP "gssmech" 4
.IX Item "gssmech"
The \s-1GSS\s0 mechanism to be used in the connection
.IP "pass" 4
.IX Item "pass"
The \s-1GSS\s0 credentials to be used in the connection (optional)
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\& #! /usr/bin/perl \-w
\&
\& use strict;
\&
\& use Net::LDAP 0.33;
\& use Authen::SASL 2.10;
\&
\& # \-\-\-\-\-\-\-\- Adjust to your environment \-\-\-\-\-\-\-\-
\& my $adhost      = \*(Aqtheserver.bla.net\*(Aq;
\& my $ldap_base   = \*(Aqdc=bla,dc=net\*(Aq;
\& my $ldap_filter = \*(Aq(&(sAMAccountName=BLAAGROL))\*(Aq;
\&
\& my $sasl = Authen::SASL\->new(mechanism => \*(AqGSSAPI\*(Aq);
\& my $ldap;
\&
\& eval {
\&     $ldap = Net::LDAP\->new($adhost,
\&                            onerror => \*(Aqdie\*(Aq)
\&       or  die "Cannot connect to LDAP host \*(Aq$adhost\*(Aq: \*(Aq$@\*(Aq";
\&     $ldap\->bind(sasl => $sasl);
\& };
\&
\& if ($@) {
\&     chomp $@;
\&     die   "\enBind error         : $@",
\&           "\enDetailed SASL error: ", $sasl\->error,
\&           "\enTerminated";
\& }
\&
\& print "\enLDAP bind() succeeded, working in authenticated state";
\&
\& my $mesg = $ldap\->search(base   => $ldap_base,
\&                          filter => $ldap_filter);
\&
\& # \-\-\-\-\-\-\-\- evaluate $mesg
.Ve
.SS "\s-1PROPERTIES\s0"
.IX Subsection "PROPERTIES"
The properties used are:
.IP "maxbuf" 4
.IX Item "maxbuf"
The maximum buffer size for receiving cipher text
.IP "minssf" 4
.IX Item "minssf"
The minimum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 0
.IP "maxssf" 4
.IX Item "maxssf"
The maximum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 2**31
.IP "externalssf" 4
.IX Item "externalssf"
The \s-1SSF\s0 value provided by an underlying external security layer.
The default is 0
.IP "ssf" 4
.IX Item "ssf"
The actual \s-1SSF\s0 value provided by the \s-1SASL\s0 security layer after the \s-1SASL\s0
authentication phase has been completed. This value is read-only and set
by the implementation after the \s-1SASL\s0 authentication phase has been completed.
.IP "maxout" 4
.IX Item "maxout"
The maximum plaintext buffer size for sending data to the peer.
This value is set by the implementation after the \s-1SASL\s0 authentication
phase has been completed and a \s-1SASL\s0 security layer is in effect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Written by Simon Wilkinson, with patches and extensions by Achim Grolms
and Peter Marschall.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006 Simon Wilkinson, Achim Grolms and Peter Marschall.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::GSSAPI5.16.3pm           0100644 0001750 0001750 00000017735 12566241555 026030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::GSSAPI 3"
.TH Authen::SASL::Perl::GSSAPI 3 "2010-03-11" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::GSSAPI \- GSSAPI (Kerberosv5) Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new( mechanism => \*(AqGSSAPI\*(Aq );
\&
\&  $sasl = Authen::SASL\->new( mechanism => \*(AqGSSAPI\*(Aq,
\&                             callback => { pass => $mycred });
\&
\&  $sasl\->client_start( $service, $host );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1GSSAPI\s0 \s-1SASL\s0 algorithm,
as described in \s-1RFC\s0 2222 section 7.2.1 resp. draft\-ietf\-sasl\-gssapi\-XX.txt.
.PP
With a valid Kerberos 5 credentials cache (aka \s-1TGT\s0) it allows
to connect to \fIservice\fR@\fIhost\fR given as the first two parameters
to Authen::SASL's \fIclient_start()\fR method.  Alternatively, a GSSAPI::Cred
object can be passed in via the Authen::SASL callback hash using
the `pass' key.
.PP
Please note that this module does not currently implement a \s-1SASL\s0
security layer following authentication. Unless the connection is
protected by other means, such as \s-1TLS\s0, it will be vulnerable to
man-in-the-middle attacks. If security layers are required, then the
Authen::SASL::XS \s-1GSSAPI\s0 module should be used instead.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "authname" 4
.IX Item "authname"
The authorization identity to be used in \s-1SASL\s0 exchange
.IP "gssmech" 4
.IX Item "gssmech"
The \s-1GSS\s0 mechanism to be used in the connection
.IP "pass" 4
.IX Item "pass"
The \s-1GSS\s0 credentials to be used in the connection (optional)
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\& #! /usr/bin/perl \-w
\&
\& use strict;
\&
\& use Net::LDAP 0.33;
\& use Authen::SASL 2.10;
\&
\& # \-\-\-\-\-\-\-\- Adjust to your environment \-\-\-\-\-\-\-\-
\& my $adhost      = \*(Aqtheserver.bla.net\*(Aq;
\& my $ldap_base   = \*(Aqdc=bla,dc=net\*(Aq;
\& my $ldap_filter = \*(Aq(&(sAMAccountName=BLAAGROL))\*(Aq;
\&
\& my $sasl = Authen::SASL\->new(mechanism => \*(AqGSSAPI\*(Aq);
\& my $ldap;
\&
\& eval {
\&     $ldap = Net::LDAP\->new($adhost,
\&                            onerror => \*(Aqdie\*(Aq)
\&       or  die "Cannot connect to LDAP host \*(Aq$adhost\*(Aq: \*(Aq$@\*(Aq";
\&     $ldap\->bind(sasl => $sasl);
\& };
\&
\& if ($@) {
\&     chomp $@;
\&     die   "\enBind error         : $@",
\&           "\enDetailed SASL error: ", $sasl\->error,
\&           "\enTerminated";
\& }
\&
\& print "\enLDAP bind() succeeded, working in authenticated state";
\&
\& my $mesg = $ldap\->search(base   => $ldap_base,
\&                          filter => $ldap_filter);
\&
\& # \-\-\-\-\-\-\-\- evaluate $mesg
.Ve
.SS "\s-1PROPERTIES\s0"
.IX Subsection "PROPERTIES"
The properties used are:
.IP "maxbuf" 4
.IX Item "maxbuf"
The maximum buffer size for receiving cipher text
.IP "minssf" 4
.IX Item "minssf"
The minimum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 0
.IP "maxssf" 4
.IX Item "maxssf"
The maximum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 2**31
.IP "externalssf" 4
.IX Item "externalssf"
The \s-1SSF\s0 value provided by an underlying external security layer.
The default is 0
.IP "ssf" 4
.IX Item "ssf"
The actual \s-1SSF\s0 value provided by the \s-1SASL\s0 security layer after the \s-1SASL\s0
authentication phase has been completed. This value is read-only and set
by the implementation after the \s-1SASL\s0 authentication phase has been completed.
.IP "maxout" 4
.IX Item "maxout"
The maximum plaintext buffer size for sending data to the peer.
This value is set by the implementation after the \s-1SASL\s0 authentication
phase has been completed and a \s-1SASL\s0 security layer is in effect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Written by Simon Wilkinson, with patches and extensions by Achim Grolms
and Peter Marschall.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006 Simon Wilkinson, Achim Grolms and Peter Marschall.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::GSSAPI5.18.3pm           0100644 0001750 0001750 00000020247 12566241556 026023  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::GSSAPI 3"
.TH Authen::SASL::Perl::GSSAPI 3 "2010-03-11" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::GSSAPI \- GSSAPI (Kerberosv5) Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new( mechanism => \*(AqGSSAPI\*(Aq );
\&
\&  $sasl = Authen::SASL\->new( mechanism => \*(AqGSSAPI\*(Aq,
\&                             callback => { pass => $mycred });
\&
\&  $sasl\->client_start( $service, $host );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client part of the \s-1GSSAPI SASL\s0 algorithm,
as described in \s-1RFC 2222\s0 section 7.2.1 resp. draft\-ietf\-sasl\-gssapi\-XX.txt.
.PP
With a valid Kerberos 5 credentials cache (aka \s-1TGT\s0) it allows
to connect to \fIservice\fR@\fIhost\fR given as the first two parameters
to Authen::SASL's \fIclient_start()\fR method.  Alternatively, a GSSAPI::Cred
object can be passed in via the Authen::SASL callback hash using
the `pass' key.
.PP
Please note that this module does not currently implement a \s-1SASL\s0
security layer following authentication. Unless the connection is
protected by other means, such as \s-1TLS,\s0 it will be vulnerable to
man-in-the-middle attacks. If security layers are required, then the
Authen::SASL::XS \s-1GSSAPI\s0 module should be used instead.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.IP "authname" 4
.IX Item "authname"
The authorization identity to be used in \s-1SASL\s0 exchange
.IP "gssmech" 4
.IX Item "gssmech"
The \s-1GSS\s0 mechanism to be used in the connection
.IP "pass" 4
.IX Item "pass"
The \s-1GSS\s0 credentials to be used in the connection (optional)
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\& #! /usr/bin/perl \-w
\&
\& use strict;
\&
\& use Net::LDAP 0.33;
\& use Authen::SASL 2.10;
\&
\& # \-\-\-\-\-\-\-\- Adjust to your environment \-\-\-\-\-\-\-\-
\& my $adhost      = \*(Aqtheserver.bla.net\*(Aq;
\& my $ldap_base   = \*(Aqdc=bla,dc=net\*(Aq;
\& my $ldap_filter = \*(Aq(&(sAMAccountName=BLAAGROL))\*(Aq;
\&
\& my $sasl = Authen::SASL\->new(mechanism => \*(AqGSSAPI\*(Aq);
\& my $ldap;
\&
\& eval {
\&     $ldap = Net::LDAP\->new($adhost,
\&                            onerror => \*(Aqdie\*(Aq)
\&       or  die "Cannot connect to LDAP host \*(Aq$adhost\*(Aq: \*(Aq$@\*(Aq";
\&     $ldap\->bind(sasl => $sasl);
\& };
\&
\& if ($@) {
\&     chomp $@;
\&     die   "\enBind error         : $@",
\&           "\enDetailed SASL error: ", $sasl\->error,
\&           "\enTerminated";
\& }
\&
\& print "\enLDAP bind() succeeded, working in authenticated state";
\&
\& my $mesg = $ldap\->search(base   => $ldap_base,
\&                          filter => $ldap_filter);
\&
\& # \-\-\-\-\-\-\-\- evaluate $mesg
.Ve
.SS "\s-1PROPERTIES\s0"
.IX Subsection "PROPERTIES"
The properties used are:
.IP "maxbuf" 4
.IX Item "maxbuf"
The maximum buffer size for receiving cipher text
.IP "minssf" 4
.IX Item "minssf"
The minimum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 0
.IP "maxssf" 4
.IX Item "maxssf"
The maximum \s-1SSF\s0 value that should be provided by the \s-1SASL\s0 security layer.
The default is 2**31
.IP "externalssf" 4
.IX Item "externalssf"
The \s-1SSF\s0 value provided by an underlying external security layer.
The default is 0
.IP "ssf" 4
.IX Item "ssf"
The actual \s-1SSF\s0 value provided by the \s-1SASL\s0 security layer after the \s-1SASL\s0
authentication phase has been completed. This value is read-only and set
by the implementation after the \s-1SASL\s0 authentication phase has been completed.
.IP "maxout" 4
.IX Item "maxout"
The maximum plaintext buffer size for sending data to the peer.
This value is set by the implementation after the \s-1SASL\s0 authentication
phase has been completed and a \s-1SASL\s0 security layer is in effect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Written by Simon Wilkinson, with patches and extensions by Achim Grolms
and Peter Marschall.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006 Simon Wilkinson, Achim Grolms and Peter Marschall.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::LOGIN.3pm                0100644 0001750 0001750 00000014322 12566241556 025366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::LOGIN 3"
.TH Authen::SASL::Perl::LOGIN 3 "2010-06-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::LOGIN \- Login Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqLOGIN\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server part of the \s-1LOGIN SASL\s0 algorithm,
as described in \s-1IETF\s0 Draft draft\-murchison\-sasl\-login\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIClient\fR
.IX Subsection "Client"
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication
.PP
\fIServer\fR
.IX Subsection "Server"
.IP "getsecret(username)" 4
.IX Item "getsecret(username)"
returns the password associated with \f(CW\*(C`username\*(C'\fR
.IP "checkpass(username, password)" 4
.IX Item "checkpass(username, password)"
returns true and false depending on the validity of the credentials passed
in arguments.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
Server support by Yann Kerherve <yannk@cpan.org>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
.PP
Server support Copyright (c) 2009 Yann Kerherve.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 175:" 4
.IX Item "Around line 175:"
Unknown directive: =over4
.IP "Around line 177:" 4
.IX Item "Around line 177:"
\&'=item' outside of any '=over'
                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::LOGIN5.16.3pm            0100644 0001750 0001750 00000014010 12566241555 025671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::LOGIN 3"
.TH Authen::SASL::Perl::LOGIN 3 "2010-06-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::LOGIN \- Login Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqLOGIN\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server part of the \s-1LOGIN\s0 \s-1SASL\s0 algorithm,
as described in \s-1IETF\s0 Draft draft\-murchison\-sasl\-login\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIClient\fR
.IX Subsection "Client"
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication
.PP
\fIServer\fR
.IX Subsection "Server"
.IP "getsecret(username)" 4
.IX Item "getsecret(username)"
returns the password associated with \f(CW\*(C`username\*(C'\fR
.IP "checkpass(username, password)" 4
.IX Item "checkpass(username, password)"
returns true and false depending on the validity of the credentials passed
in arguments.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
Server support by Yann Kerherve <yannk@cpan.org>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
.PP
Server support Copyright (c) 2009 Yann Kerherve.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 175:" 4
.IX Item "Around line 175:"
Unknown directive: =over4
.IP "Around line 177:" 4
.IX Item "Around line 177:"
\&'=item' outside of any '=over'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::LOGIN5.18.3pm            0100644 0001750 0001750 00000014322 12566241556 025702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::LOGIN 3"
.TH Authen::SASL::Perl::LOGIN 3 "2010-06-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::LOGIN \- Login Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqLOGIN\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server part of the \s-1LOGIN SASL\s0 algorithm,
as described in \s-1IETF\s0 Draft draft\-murchison\-sasl\-login\-XX.txt.
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIClient\fR
.IX Subsection "Client"
.IP "user" 4
.IX Item "user"
The username to be used for authentication
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication
.PP
\fIServer\fR
.IX Subsection "Server"
.IP "getsecret(username)" 4
.IX Item "getsecret(username)"
returns the password associated with \f(CW\*(C`username\*(C'\fR
.IP "checkpass(username, password)" 4
.IX Item "checkpass(username, password)"
returns true and false depending on the validity of the credentials passed
in arguments.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
Server support by Yann Kerherve <yannk@cpan.org>
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
.PP
Server support Copyright (c) 2009 Yann Kerherve.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 175:" 4
.IX Item "Around line 175:"
Unknown directive: =over4
.IP "Around line 177:" 4
.IX Item "Around line 177:"
\&'=item' outside of any '=over'
                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::PLAIN.3pm                0100644 0001750 0001750 00000014275 12566241556 025370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::PLAIN 3"
.TH Authen::SASL::Perl::PLAIN 3 "2010-06-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::PLAIN \- Plain Login Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqPLAIN\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server part of the \s-1PLAIN SASL\s0 algorithm,
as described in \s-1RFC 2595\s0 resp. \s-1IETF\s0 Draft draft\-ietf\-sasl\-plain\-XX.txt
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIClient\fR
.IX Subsection "Client"
.IP "authname" 4
.IX Item "authname"
The authorization id to use after successful authentication (client)
.IP "user" 4
.IX Item "user"
The username to be used for authentication (client)
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication.
.PP
\fIServer\fR
.IX Subsection "Server"
.IP "checkpass(username, password, realm)" 4
.IX Item "checkpass(username, password, realm)"
returns true and false depending on the validity of the credentials passed
in arguments.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
.PP
Server support Copyright (c) 2009 Yann Kerherve.
All rights reserved. This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 146:" 4
.IX Item "Around line 146:"
Unknown directive: =over4
.IP "Around line 148:" 4
.IX Item "Around line 148:"
\&'=item' outside of any '=over'
                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::PLAIN5.16.3pm            0100644 0001750 0001750 00000013763 12566241555 025702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::PLAIN 3"
.TH Authen::SASL::Perl::PLAIN 3 "2010-06-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::PLAIN \- Plain Login Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqPLAIN\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server part of the \s-1PLAIN\s0 \s-1SASL\s0 algorithm,
as described in \s-1RFC\s0 2595 resp. \s-1IETF\s0 Draft draft\-ietf\-sasl\-plain\-XX.txt
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIClient\fR
.IX Subsection "Client"
.IP "authname" 4
.IX Item "authname"
The authorization id to use after successful authentication (client)
.IP "user" 4
.IX Item "user"
The username to be used for authentication (client)
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication.
.PP
\fIServer\fR
.IX Subsection "Server"
.IP "checkpass(username, password, realm)" 4
.IX Item "checkpass(username, password, realm)"
returns true and false depending on the validity of the credentials passed
in arguments.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
.PP
Server support Copyright (c) 2009 Yann Kerherve.
All rights reserved. This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 146:" 4
.IX Item "Around line 146:"
Unknown directive: =over4
.IP "Around line 148:" 4
.IX Item "Around line 148:"
\&'=item' outside of any '=over'
             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Authen::SASL::Perl::PLAIN5.18.3pm            0100644 0001750 0001750 00000014275 12566241556 025704  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::SASL::Perl::PLAIN 3"
.TH Authen::SASL::Perl::PLAIN 3 "2010-06-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::SASL::Perl::PLAIN \- Plain Login Authentication class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Authen::SASL qw(Perl);
\&
\&  $sasl = Authen::SASL\->new(
\&    mechanism => \*(AqPLAIN\*(Aq,
\&    callback  => {
\&      user => $user,
\&      pass => $pass
\&    },
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This method implements the client and server part of the \s-1PLAIN SASL\s0 algorithm,
as described in \s-1RFC 2595\s0 resp. \s-1IETF\s0 Draft draft\-ietf\-sasl\-plain\-XX.txt
.SS "\s-1CALLBACK\s0"
.IX Subsection "CALLBACK"
The callbacks used are:
.PP
\fIClient\fR
.IX Subsection "Client"
.IP "authname" 4
.IX Item "authname"
The authorization id to use after successful authentication (client)
.IP "user" 4
.IX Item "user"
The username to be used for authentication (client)
.IP "pass" 4
.IX Item "pass"
The user's password to be used for authentication.
.PP
\fIServer\fR
.IX Subsection "Server"
.IP "checkpass(username, password, realm)" 4
.IX Item "checkpass(username, password, realm)"
returns true and false depending on the validity of the credentials passed
in arguments.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::SASL,
Authen::SASL::Perl
.SH "AUTHORS"
.IX Header "AUTHORS"
Software written by Graham Barr <gbarr@pobox.com>,
documentation written by Peter Marschall <peter@adpm.de>.
.PP
Please report any bugs, or post any suggestions, to the perl-ldap mailing list
<perl\-ldap@perl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Graham Barr.
All rights reserved. This program is free software; you can redistribute 
it and/or modify it under the same terms as Perl itself.
.PP
Documentation Copyright (c) 2004 Peter Marschall.
All rights reserved.  This documentation is distributed,
and may be redistributed, under the same terms as Perl itself.
.PP
Server support Copyright (c) 2009 Yann Kerherve.
All rights reserved. This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 146:" 4
.IX Item "Around line 146:"
Unknown directive: =over4
.IP "Around line 148:" 4
.IX Item "Around line 148:"
\&'=item' outside of any '=over'
                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/AutoLoader.3pm                               0100644 0001750 0001750 00000036546 12566207451 023356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AutoLoader 3pm"
.TH AutoLoader 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AutoLoader \- load subroutines only on demand
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Foo;
\&    use AutoLoader \*(AqAUTOLOAD\*(Aq;   # import the default AUTOLOAD subroutine
\&
\&    package Bar;
\&    use AutoLoader;              # don\*(Aqt import AUTOLOAD, define our own
\&    sub AUTOLOAD {
\&        ...
\&        $AutoLoader::AUTOLOAD = "...";
\&        goto &AutoLoader::AUTOLOAD;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBAutoLoader\fR module works with the \fBAutoSplit\fR module and the
\&\f(CW\*(C`_\|_END_\|_\*(C'\fR token to defer the loading of some subroutines until they are
used rather than loading them all at once.
.PP
To use \fBAutoLoader\fR, the author of a module has to place the
definitions of subroutines to be autoloaded after an \f(CW\*(C`_\|_END_\|_\*(C'\fR token.
(See perldata.)  The \fBAutoSplit\fR module can then be run manually to
extract the definitions into individual files \fIauto/funcname.al\fR.
.PP
\&\fBAutoLoader\fR implements an \s-1AUTOLOAD\s0 subroutine.  When an undefined
subroutine in is called in a client module of \fBAutoLoader\fR,
\&\fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine attempts to locate the subroutine in a
file with a name related to the location of the file from which the
client module was read.  As an example, if \fI\s-1POSIX\s0.pm\fR is located in
\&\fI/usr/local/lib/perl5/POSIX.pm\fR, \fBAutoLoader\fR will look for perl
subroutines \fB\s-1POSIX\s0\fR in \fI/usr/local/lib/perl5/auto/POSIX/*.al\fR, where
the \f(CW\*(C`.al\*(C'\fR file has the same name as the subroutine, sans package.  If
such a file exists, \s-1AUTOLOAD\s0 will read and evaluate it,
thus (presumably) defining the needed subroutine.  \s-1AUTOLOAD\s0 will then
\&\f(CW\*(C`goto\*(C'\fR the newly defined subroutine.
.PP
Once this process completes for a given function, it is defined, so
future calls to the subroutine will bypass the \s-1AUTOLOAD\s0 mechanism.
.SS "Subroutine Stubs"
.IX Subsection "Subroutine Stubs"
In order for object method lookup and/or prototype checking to operate
correctly even when methods have not yet been defined it is necessary to
\&\*(L"forward declare\*(R" each subroutine (as in \f(CW\*(C`sub NAME;\*(C'\fR).  See
\&\*(L"\s-1SYNOPSIS\*(R"\s0 in perlsub.  Such forward declaration creates \*(L"subroutine
stubs\*(R", which are place holders with no code.
.PP
The AutoSplit and \fBAutoLoader\fR modules automate the creation of forward
declarations.  The AutoSplit module creates an 'index' file containing
forward declarations of all the AutoSplit subroutines.  When the
AutoLoader module is 'use'd it loads these declarations into its callers
package.
.PP
Because of this mechanism it is important that \fBAutoLoader\fR is always
\&\f(CW\*(C`use\*(C'\fRd and not \f(CW\*(C`require\*(C'\fRd.
.SS "Using \fBAutoLoader\fP's \s-1AUTOLOAD\s0 Subroutine"
.IX Subsection "Using AutoLoader's AUTOLOAD Subroutine"
In order to use \fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine you \fImust\fR
explicitly import it:
.PP
.Vb 1
\&    use AutoLoader \*(AqAUTOLOAD\*(Aq;
.Ve
.SS "Overriding \fBAutoLoader\fP's \s-1AUTOLOAD\s0 Subroutine"
.IX Subsection "Overriding AutoLoader's AUTOLOAD Subroutine"
Some modules, mainly extensions, provide their own \s-1AUTOLOAD\s0 subroutines.
They typically need to check for some special cases (such as constants)
and then fallback to \fBAutoLoader\fR's \s-1AUTOLOAD\s0 for the rest.
.PP
Such modules should \fInot\fR import \fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine.
Instead, they should define their own \s-1AUTOLOAD\s0 subroutines along these
lines:
.PP
.Vb 2
\&    use AutoLoader;
\&    use Carp;
\&
\&    sub AUTOLOAD {
\&        my $sub = $AUTOLOAD;
\&        (my $constname = $sub) =~ s/.*:://;
\&        my $val = constant($constname, @_ ? $_[0] : 0);
\&        if ($! != 0) {
\&            if ($! =~ /Invalid/ || $!{EINVAL}) {
\&                $AutoLoader::AUTOLOAD = $sub;
\&                goto &AutoLoader::AUTOLOAD;
\&            }
\&            else {
\&                croak "Your vendor has not defined constant $constname";
\&            }
\&        }
\&        *$sub = sub { $val }; # same as: eval "sub $sub { $val }";
\&        goto &$sub;
\&    }
.Ve
.PP
If any module's own \s-1AUTOLOAD\s0 subroutine has no need to fallback to the
AutoLoader's \s-1AUTOLOAD\s0 subroutine (because it doesn't have any AutoSplit
subroutines), then that module should not use \fBAutoLoader\fR at all.
.SS "Package Lexicals"
.IX Subsection "Package Lexicals"
Package lexicals declared with \f(CW\*(C`my\*(C'\fR in the main block of a package
using \fBAutoLoader\fR will not be visible to auto-loaded subroutines, due to
the fact that the given scope ends at the \f(CW\*(C`_\|_END_\|_\*(C'\fR marker.  A module
using such variables as package globals will not work properly under the
\&\fBAutoLoader\fR.
.PP
The \f(CW\*(C`vars\*(C'\fR pragma (see \*(L"vars\*(R" in perlmod) may be used in such
situations as an alternative to explicitly qualifying all globals with
the package namespace.  Variables pre-declared with this pragma will be
visible to any autoloaded routines (but will not be invisible outside
the package, unfortunately).
.SS "Not Using AutoLoader"
.IX Subsection "Not Using AutoLoader"
You can stop using AutoLoader by simply
.PP
.Vb 1
\&        no AutoLoader;
.Ve
.SS "\fBAutoLoader\fP vs. \fBSelfLoader\fP"
.IX Subsection "AutoLoader vs. SelfLoader"
The \fBAutoLoader\fR is similar in purpose to \fBSelfLoader\fR: both delay the
loading of subroutines.
.PP
\&\fBSelfLoader\fR uses the \f(CW\*(C`_\|_DATA_\|_\*(C'\fR marker rather than \f(CW\*(C`_\|_END_\|_\*(C'\fR.
While this avoids the use of a hierarchy of disk files and the
associated open/close for each routine loaded, \fBSelfLoader\fR suffers a
startup speed disadvantage in the one-time parsing of the lines after
\&\f(CW\*(C`_\|_DATA_\|_\*(C'\fR, after which routines are cached.  \fBSelfLoader\fR can also
handle multiple packages in a file.
.PP
\&\fBAutoLoader\fR only reads code as it is requested, and in many cases
should be faster, but requires a mechanism like \fBAutoSplit\fR be used to
create the individual files.  ExtUtils::MakeMaker will invoke
\&\fBAutoSplit\fR automatically if \fBAutoLoader\fR is used in a module source
file.
.SS "Forcing AutoLoader to Load a Function"
.IX Subsection "Forcing AutoLoader to Load a Function"
Sometimes, it can be necessary or useful to make sure that a certain
function is fully loaded by AutoLoader. This is the case, for example,
when you need to wrap a function to inject debugging code. It is also
helpful to force early loading of code before forking to make use of
copy-on-write as much as possible.
.PP
Starting with AutoLoader 5.73, you can call the
\&\f(CW\*(C`AutoLoader::autoload_sub\*(C'\fR function with the fully-qualified name of
the function to load from its \fI.al\fR file. The behaviour is exactly
the same as if you called the function, triggering the regular
\&\f(CW\*(C`AUTOLOAD\*(C'\fR mechanism, but it does not actually execute the
autoloaded function.
.SH "CAVEATS"
.IX Header "CAVEATS"
AutoLoaders prior to Perl 5.002 had a slightly different interface.  Any
old modules which use \fBAutoLoader\fR should be changed to the new calling
style.  Typically this just means changing a require to a use, adding
the explicit \f(CW\*(AqAUTOLOAD\*(Aq\fR import if needed, and removing \fBAutoLoader\fR
from \f(CW@ISA\fR.
.PP
On systems with restrictions on file name length, the file corresponding
to a subroutine may have a shorter name that the routine itself.  This
can lead to conflicting file names.  The \fIAutoSplit\fR package warns of
these potential conflicts when used to split a module.
.PP
AutoLoader may fail to find the autosplit files (or even find the wrong
ones) in cases where \f(CW@INC\fR contains relative paths, \fBand\fR the program
does \f(CW\*(C`chdir\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SelfLoader \- an autoloader that doesn't use external files.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`AutoLoader\*(C'\fR is maintained by the perl5\-porters. Please direct
any questions to the canonical mailing list. Anything that
is applicable to the \s-1CPAN\s0 release can be sent to its maintainer,
though.
.PP
Author and Maintainer: The Perl5\-Porters <perl5\-porters@perl.org>
.PP
Maintainer of the \s-1CPAN\s0 release: Steffen Mueller <smueller@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This package has been part of the perl core since the first release
of perl5. It has been released separately to \s-1CPAN\s0 so older installations
can benefit from bug fixes.
.PP
This package has the same copyright and license as the perl core:
.PP
.Vb 4
\&             Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
\&        2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
\&        2011, 2012
\&        by Larry Wall and others
\&    
\&                            All rights reserved.
\&    
\&    This program is free software; you can redistribute it and/or modify
\&    it under the terms of either:
\&    
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&    
\&        b) the "Artistic License" which comes with this Kit.
\&    
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&    
\&    You should have received a copy of the Artistic License with this
\&    Kit, in the file named "Artistic".  If not, I\*(Aqll be glad to provide one.
\&    
\&    You should also have received a copy of the GNU General Public License
\&    along with this program in the file named "Copying". If not, write to the 
\&    Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
\&    MA 02110\-1301, USA or visit their web page on the internet at
\&    http://www.gnu.org/copyleft/gpl.html.
\&    
\&    For those of you that choose to use the GNU General Public License,
\&    my interpretation of the GNU General Public License is that no Perl
\&    script falls under the terms of the GPL unless you explicitly put
\&    said script under the terms of the GPL yourself.  Furthermore, any
\&    object code linked with perl does not automatically fall under the
\&    terms of the GPL, provided such object code only adds definitions
\&    of subroutines and variables, and does not otherwise impair the
\&    resulting interpreter from executing any standard Perl script.  I
\&    consider linking in C subroutines in this manner to be the moral
\&    equivalent of defining subroutines in the Perl language itself.  You
\&    may sell such an object file as proprietary provided that you provide
\&    or offer to provide the Perl source, as specified by the GNU General
\&    Public License.  (This is merely an alternate way of specifying input
\&    to the program.)  You may also sell a binary produced by the dumping of
\&    a running Perl script that belongs to you, provided that you provide or
\&    offer to provide the Perl source as specified by the GPL.  (The
\&    fact that a Perl interpreter and your code are in the same binary file
\&    is, in this case, a form of mere aggregation.)  This is my interpretation
\&    of the GPL.  If you still have concerns or difficulties understanding
\&    my intent, feel free to contact me.  Of course, the Artistic License
\&    spells all this out for your protection, so you may prefer to use that.
.Ve
                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/AutoLoader5.16.3pm                           0100644 0001750 0001750 00000034565 12566207430 023664  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AutoLoader 3pm"
.TH AutoLoader 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AutoLoader \- load subroutines only on demand
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Foo;
\&    use AutoLoader \*(AqAUTOLOAD\*(Aq;   # import the default AUTOLOAD subroutine
\&
\&    package Bar;
\&    use AutoLoader;              # don\*(Aqt import AUTOLOAD, define our own
\&    sub AUTOLOAD {
\&        ...
\&        $AutoLoader::AUTOLOAD = "...";
\&        goto &AutoLoader::AUTOLOAD;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBAutoLoader\fR module works with the \fBAutoSplit\fR module and the
\&\f(CW\*(C`_\|_END_\|_\*(C'\fR token to defer the loading of some subroutines until they are
used rather than loading them all at once.
.PP
To use \fBAutoLoader\fR, the author of a module has to place the
definitions of subroutines to be autoloaded after an \f(CW\*(C`_\|_END_\|_\*(C'\fR token.
(See perldata.)  The \fBAutoSplit\fR module can then be run manually to
extract the definitions into individual files \fIauto/funcname.al\fR.
.PP
\&\fBAutoLoader\fR implements an \s-1AUTOLOAD\s0 subroutine.  When an undefined
subroutine in is called in a client module of \fBAutoLoader\fR,
\&\fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine attempts to locate the subroutine in a
file with a name related to the location of the file from which the
client module was read.  As an example, if \fI\s-1POSIX\s0.pm\fR is located in
\&\fI/usr/local/lib/perl5/POSIX.pm\fR, \fBAutoLoader\fR will look for perl
subroutines \fB\s-1POSIX\s0\fR in \fI/usr/local/lib/perl5/auto/POSIX/*.al\fR, where
the \f(CW\*(C`.al\*(C'\fR file has the same name as the subroutine, sans package.  If
such a file exists, \s-1AUTOLOAD\s0 will read and evaluate it,
thus (presumably) defining the needed subroutine.  \s-1AUTOLOAD\s0 will then
\&\f(CW\*(C`goto\*(C'\fR the newly defined subroutine.
.PP
Once this process completes for a given function, it is defined, so
future calls to the subroutine will bypass the \s-1AUTOLOAD\s0 mechanism.
.SS "Subroutine Stubs"
.IX Subsection "Subroutine Stubs"
In order for object method lookup and/or prototype checking to operate
correctly even when methods have not yet been defined it is necessary to
\&\*(L"forward declare\*(R" each subroutine (as in \f(CW\*(C`sub NAME;\*(C'\fR).  See
\&\*(L"\s-1SYNOPSIS\s0\*(R" in perlsub.  Such forward declaration creates \*(L"subroutine
stubs\*(R", which are place holders with no code.
.PP
The AutoSplit and \fBAutoLoader\fR modules automate the creation of forward
declarations.  The AutoSplit module creates an 'index' file containing
forward declarations of all the AutoSplit subroutines.  When the
AutoLoader module is 'use'd it loads these declarations into its callers
package.
.PP
Because of this mechanism it is important that \fBAutoLoader\fR is always
\&\f(CW\*(C`use\*(C'\fRd and not \f(CW\*(C`require\*(C'\fRd.
.SS "Using \fBAutoLoader\fP's \s-1AUTOLOAD\s0 Subroutine"
.IX Subsection "Using AutoLoader's AUTOLOAD Subroutine"
In order to use \fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine you \fImust\fR
explicitly import it:
.PP
.Vb 1
\&    use AutoLoader \*(AqAUTOLOAD\*(Aq;
.Ve
.SS "Overriding \fBAutoLoader\fP's \s-1AUTOLOAD\s0 Subroutine"
.IX Subsection "Overriding AutoLoader's AUTOLOAD Subroutine"
Some modules, mainly extensions, provide their own \s-1AUTOLOAD\s0 subroutines.
They typically need to check for some special cases (such as constants)
and then fallback to \fBAutoLoader\fR's \s-1AUTOLOAD\s0 for the rest.
.PP
Such modules should \fInot\fR import \fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine.
Instead, they should define their own \s-1AUTOLOAD\s0 subroutines along these
lines:
.PP
.Vb 2
\&    use AutoLoader;
\&    use Carp;
\&
\&    sub AUTOLOAD {
\&        my $sub = $AUTOLOAD;
\&        (my $constname = $sub) =~ s/.*:://;
\&        my $val = constant($constname, @_ ? $_[0] : 0);
\&        if ($! != 0) {
\&            if ($! =~ /Invalid/ || $!{EINVAL}) {
\&                $AutoLoader::AUTOLOAD = $sub;
\&                goto &AutoLoader::AUTOLOAD;
\&            }
\&            else {
\&                croak "Your vendor has not defined constant $constname";
\&            }
\&        }
\&        *$sub = sub { $val }; # same as: eval "sub $sub { $val }";
\&        goto &$sub;
\&    }
.Ve
.PP
If any module's own \s-1AUTOLOAD\s0 subroutine has no need to fallback to the
AutoLoader's \s-1AUTOLOAD\s0 subroutine (because it doesn't have any AutoSplit
subroutines), then that module should not use \fBAutoLoader\fR at all.
.SS "Package Lexicals"
.IX Subsection "Package Lexicals"
Package lexicals declared with \f(CW\*(C`my\*(C'\fR in the main block of a package
using \fBAutoLoader\fR will not be visible to auto-loaded subroutines, due to
the fact that the given scope ends at the \f(CW\*(C`_\|_END_\|_\*(C'\fR marker.  A module
using such variables as package globals will not work properly under the
\&\fBAutoLoader\fR.
.PP
The \f(CW\*(C`vars\*(C'\fR pragma (see \*(L"vars\*(R" in perlmod) may be used in such
situations as an alternative to explicitly qualifying all globals with
the package namespace.  Variables pre-declared with this pragma will be
visible to any autoloaded routines (but will not be invisible outside
the package, unfortunately).
.SS "Not Using AutoLoader"
.IX Subsection "Not Using AutoLoader"
You can stop using AutoLoader by simply
.PP
.Vb 1
\&        no AutoLoader;
.Ve
.SS "\fBAutoLoader\fP vs. \fBSelfLoader\fP"
.IX Subsection "AutoLoader vs. SelfLoader"
The \fBAutoLoader\fR is similar in purpose to \fBSelfLoader\fR: both delay the
loading of subroutines.
.PP
\&\fBSelfLoader\fR uses the \f(CW\*(C`_\|_DATA_\|_\*(C'\fR marker rather than \f(CW\*(C`_\|_END_\|_\*(C'\fR.
While this avoids the use of a hierarchy of disk files and the
associated open/close for each routine loaded, \fBSelfLoader\fR suffers a
startup speed disadvantage in the one-time parsing of the lines after
\&\f(CW\*(C`_\|_DATA_\|_\*(C'\fR, after which routines are cached.  \fBSelfLoader\fR can also
handle multiple packages in a file.
.PP
\&\fBAutoLoader\fR only reads code as it is requested, and in many cases
should be faster, but requires a mechanism like \fBAutoSplit\fR be used to
create the individual files.  ExtUtils::MakeMaker will invoke
\&\fBAutoSplit\fR automatically if \fBAutoLoader\fR is used in a module source
file.
.SH "CAVEATS"
.IX Header "CAVEATS"
AutoLoaders prior to Perl 5.002 had a slightly different interface.  Any
old modules which use \fBAutoLoader\fR should be changed to the new calling
style.  Typically this just means changing a require to a use, adding
the explicit \f(CW\*(AqAUTOLOAD\*(Aq\fR import if needed, and removing \fBAutoLoader\fR
from \f(CW@ISA\fR.
.PP
On systems with restrictions on file name length, the file corresponding
to a subroutine may have a shorter name that the routine itself.  This
can lead to conflicting file names.  The \fIAutoSplit\fR package warns of
these potential conflicts when used to split a module.
.PP
AutoLoader may fail to find the autosplit files (or even find the wrong
ones) in cases where \f(CW@INC\fR contains relative paths, \fBand\fR the program
does \f(CW\*(C`chdir\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SelfLoader \- an autoloader that doesn't use external files.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`AutoLoader\*(C'\fR is maintained by the perl5\-porters. Please direct
any questions to the canonical mailing list. Anything that
is applicable to the \s-1CPAN\s0 release can be sent to its maintainer,
though.
.PP
Author and Maintainer: The Perl5\-Porters <perl5\-porters@perl.org>
.PP
Maintainer of the \s-1CPAN\s0 release: Steffen Mueller <smueller@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This package has been part of the perl core since the first release
of perl5. It has been released separately to \s-1CPAN\s0 so older installations
can benefit from bug fixes.
.PP
This package has the same copyright and license as the perl core:
.PP
.Vb 3
\&             Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
\&        2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
\&        by Larry Wall and others
\&    
\&                            All rights reserved.
\&    
\&    This program is free software; you can redistribute it and/or modify
\&    it under the terms of either:
\&    
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&    
\&        b) the "Artistic License" which comes with this Kit.
\&    
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&    
\&    You should have received a copy of the Artistic License with this
\&    Kit, in the file named "Artistic".  If not, I\*(Aqll be glad to provide one.
\&    
\&    You should also have received a copy of the GNU General Public License
\&    along with this program in the file named "Copying". If not, write to the 
\&    Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
\&    MA 02110\-1301, USA or visit their web page on the internet at
\&    http://www.gnu.org/copyleft/gpl.html.
\&    
\&    For those of you that choose to use the GNU General Public License,
\&    my interpretation of the GNU General Public License is that no Perl
\&    script falls under the terms of the GPL unless you explicitly put
\&    said script under the terms of the GPL yourself.  Furthermore, any
\&    object code linked with perl does not automatically fall under the
\&    terms of the GPL, provided such object code only adds definitions
\&    of subroutines and variables, and does not otherwise impair the
\&    resulting interpreter from executing any standard Perl script.  I
\&    consider linking in C subroutines in this manner to be the moral
\&    equivalent of defining subroutines in the Perl language itself.  You
\&    may sell such an object file as proprietary provided that you provide
\&    or offer to provide the Perl source, as specified by the GNU General
\&    Public License.  (This is merely an alternate way of specifying input
\&    to the program.)  You may also sell a binary produced by the dumping of
\&    a running Perl script that belongs to you, provided that you provide or
\&    offer to provide the Perl source as specified by the GPL.  (The
\&    fact that a Perl interpreter and your code are in the same binary file
\&    is, in this case, a form of mere aggregation.)  This is my interpretation
\&    of the GPL.  If you still have concerns or difficulties understanding
\&    my intent, feel free to contact me.  Of course, the Artistic License
\&    spells all this out for your protection, so you may prefer to use that.
.Ve
                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/AutoLoader5.18.3pm                           0100644 0001750 0001750 00000036546 12566207451 023672  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AutoLoader 3pm"
.TH AutoLoader 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AutoLoader \- load subroutines only on demand
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Foo;
\&    use AutoLoader \*(AqAUTOLOAD\*(Aq;   # import the default AUTOLOAD subroutine
\&
\&    package Bar;
\&    use AutoLoader;              # don\*(Aqt import AUTOLOAD, define our own
\&    sub AUTOLOAD {
\&        ...
\&        $AutoLoader::AUTOLOAD = "...";
\&        goto &AutoLoader::AUTOLOAD;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBAutoLoader\fR module works with the \fBAutoSplit\fR module and the
\&\f(CW\*(C`_\|_END_\|_\*(C'\fR token to defer the loading of some subroutines until they are
used rather than loading them all at once.
.PP
To use \fBAutoLoader\fR, the author of a module has to place the
definitions of subroutines to be autoloaded after an \f(CW\*(C`_\|_END_\|_\*(C'\fR token.
(See perldata.)  The \fBAutoSplit\fR module can then be run manually to
extract the definitions into individual files \fIauto/funcname.al\fR.
.PP
\&\fBAutoLoader\fR implements an \s-1AUTOLOAD\s0 subroutine.  When an undefined
subroutine in is called in a client module of \fBAutoLoader\fR,
\&\fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine attempts to locate the subroutine in a
file with a name related to the location of the file from which the
client module was read.  As an example, if \fI\s-1POSIX\s0.pm\fR is located in
\&\fI/usr/local/lib/perl5/POSIX.pm\fR, \fBAutoLoader\fR will look for perl
subroutines \fB\s-1POSIX\s0\fR in \fI/usr/local/lib/perl5/auto/POSIX/*.al\fR, where
the \f(CW\*(C`.al\*(C'\fR file has the same name as the subroutine, sans package.  If
such a file exists, \s-1AUTOLOAD\s0 will read and evaluate it,
thus (presumably) defining the needed subroutine.  \s-1AUTOLOAD\s0 will then
\&\f(CW\*(C`goto\*(C'\fR the newly defined subroutine.
.PP
Once this process completes for a given function, it is defined, so
future calls to the subroutine will bypass the \s-1AUTOLOAD\s0 mechanism.
.SS "Subroutine Stubs"
.IX Subsection "Subroutine Stubs"
In order for object method lookup and/or prototype checking to operate
correctly even when methods have not yet been defined it is necessary to
\&\*(L"forward declare\*(R" each subroutine (as in \f(CW\*(C`sub NAME;\*(C'\fR).  See
\&\*(L"\s-1SYNOPSIS\*(R"\s0 in perlsub.  Such forward declaration creates \*(L"subroutine
stubs\*(R", which are place holders with no code.
.PP
The AutoSplit and \fBAutoLoader\fR modules automate the creation of forward
declarations.  The AutoSplit module creates an 'index' file containing
forward declarations of all the AutoSplit subroutines.  When the
AutoLoader module is 'use'd it loads these declarations into its callers
package.
.PP
Because of this mechanism it is important that \fBAutoLoader\fR is always
\&\f(CW\*(C`use\*(C'\fRd and not \f(CW\*(C`require\*(C'\fRd.
.SS "Using \fBAutoLoader\fP's \s-1AUTOLOAD\s0 Subroutine"
.IX Subsection "Using AutoLoader's AUTOLOAD Subroutine"
In order to use \fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine you \fImust\fR
explicitly import it:
.PP
.Vb 1
\&    use AutoLoader \*(AqAUTOLOAD\*(Aq;
.Ve
.SS "Overriding \fBAutoLoader\fP's \s-1AUTOLOAD\s0 Subroutine"
.IX Subsection "Overriding AutoLoader's AUTOLOAD Subroutine"
Some modules, mainly extensions, provide their own \s-1AUTOLOAD\s0 subroutines.
They typically need to check for some special cases (such as constants)
and then fallback to \fBAutoLoader\fR's \s-1AUTOLOAD\s0 for the rest.
.PP
Such modules should \fInot\fR import \fBAutoLoader\fR's \s-1AUTOLOAD\s0 subroutine.
Instead, they should define their own \s-1AUTOLOAD\s0 subroutines along these
lines:
.PP
.Vb 2
\&    use AutoLoader;
\&    use Carp;
\&
\&    sub AUTOLOAD {
\&        my $sub = $AUTOLOAD;
\&        (my $constname = $sub) =~ s/.*:://;
\&        my $val = constant($constname, @_ ? $_[0] : 0);
\&        if ($! != 0) {
\&            if ($! =~ /Invalid/ || $!{EINVAL}) {
\&                $AutoLoader::AUTOLOAD = $sub;
\&                goto &AutoLoader::AUTOLOAD;
\&            }
\&            else {
\&                croak "Your vendor has not defined constant $constname";
\&            }
\&        }
\&        *$sub = sub { $val }; # same as: eval "sub $sub { $val }";
\&        goto &$sub;
\&    }
.Ve
.PP
If any module's own \s-1AUTOLOAD\s0 subroutine has no need to fallback to the
AutoLoader's \s-1AUTOLOAD\s0 subroutine (because it doesn't have any AutoSplit
subroutines), then that module should not use \fBAutoLoader\fR at all.
.SS "Package Lexicals"
.IX Subsection "Package Lexicals"
Package lexicals declared with \f(CW\*(C`my\*(C'\fR in the main block of a package
using \fBAutoLoader\fR will not be visible to auto-loaded subroutines, due to
the fact that the given scope ends at the \f(CW\*(C`_\|_END_\|_\*(C'\fR marker.  A module
using such variables as package globals will not work properly under the
\&\fBAutoLoader\fR.
.PP
The \f(CW\*(C`vars\*(C'\fR pragma (see \*(L"vars\*(R" in perlmod) may be used in such
situations as an alternative to explicitly qualifying all globals with
the package namespace.  Variables pre-declared with this pragma will be
visible to any autoloaded routines (but will not be invisible outside
the package, unfortunately).
.SS "Not Using AutoLoader"
.IX Subsection "Not Using AutoLoader"
You can stop using AutoLoader by simply
.PP
.Vb 1
\&        no AutoLoader;
.Ve
.SS "\fBAutoLoader\fP vs. \fBSelfLoader\fP"
.IX Subsection "AutoLoader vs. SelfLoader"
The \fBAutoLoader\fR is similar in purpose to \fBSelfLoader\fR: both delay the
loading of subroutines.
.PP
\&\fBSelfLoader\fR uses the \f(CW\*(C`_\|_DATA_\|_\*(C'\fR marker rather than \f(CW\*(C`_\|_END_\|_\*(C'\fR.
While this avoids the use of a hierarchy of disk files and the
associated open/close for each routine loaded, \fBSelfLoader\fR suffers a
startup speed disadvantage in the one-time parsing of the lines after
\&\f(CW\*(C`_\|_DATA_\|_\*(C'\fR, after which routines are cached.  \fBSelfLoader\fR can also
handle multiple packages in a file.
.PP
\&\fBAutoLoader\fR only reads code as it is requested, and in many cases
should be faster, but requires a mechanism like \fBAutoSplit\fR be used to
create the individual files.  ExtUtils::MakeMaker will invoke
\&\fBAutoSplit\fR automatically if \fBAutoLoader\fR is used in a module source
file.
.SS "Forcing AutoLoader to Load a Function"
.IX Subsection "Forcing AutoLoader to Load a Function"
Sometimes, it can be necessary or useful to make sure that a certain
function is fully loaded by AutoLoader. This is the case, for example,
when you need to wrap a function to inject debugging code. It is also
helpful to force early loading of code before forking to make use of
copy-on-write as much as possible.
.PP
Starting with AutoLoader 5.73, you can call the
\&\f(CW\*(C`AutoLoader::autoload_sub\*(C'\fR function with the fully-qualified name of
the function to load from its \fI.al\fR file. The behaviour is exactly
the same as if you called the function, triggering the regular
\&\f(CW\*(C`AUTOLOAD\*(C'\fR mechanism, but it does not actually execute the
autoloaded function.
.SH "CAVEATS"
.IX Header "CAVEATS"
AutoLoaders prior to Perl 5.002 had a slightly different interface.  Any
old modules which use \fBAutoLoader\fR should be changed to the new calling
style.  Typically this just means changing a require to a use, adding
the explicit \f(CW\*(AqAUTOLOAD\*(Aq\fR import if needed, and removing \fBAutoLoader\fR
from \f(CW@ISA\fR.
.PP
On systems with restrictions on file name length, the file corresponding
to a subroutine may have a shorter name that the routine itself.  This
can lead to conflicting file names.  The \fIAutoSplit\fR package warns of
these potential conflicts when used to split a module.
.PP
AutoLoader may fail to find the autosplit files (or even find the wrong
ones) in cases where \f(CW@INC\fR contains relative paths, \fBand\fR the program
does \f(CW\*(C`chdir\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SelfLoader \- an autoloader that doesn't use external files.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`AutoLoader\*(C'\fR is maintained by the perl5\-porters. Please direct
any questions to the canonical mailing list. Anything that
is applicable to the \s-1CPAN\s0 release can be sent to its maintainer,
though.
.PP
Author and Maintainer: The Perl5\-Porters <perl5\-porters@perl.org>
.PP
Maintainer of the \s-1CPAN\s0 release: Steffen Mueller <smueller@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This package has been part of the perl core since the first release
of perl5. It has been released separately to \s-1CPAN\s0 so older installations
can benefit from bug fixes.
.PP
This package has the same copyright and license as the perl core:
.PP
.Vb 4
\&             Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
\&        2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
\&        2011, 2012
\&        by Larry Wall and others
\&    
\&                            All rights reserved.
\&    
\&    This program is free software; you can redistribute it and/or modify
\&    it under the terms of either:
\&    
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&    
\&        b) the "Artistic License" which comes with this Kit.
\&    
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&    
\&    You should have received a copy of the Artistic License with this
\&    Kit, in the file named "Artistic".  If not, I\*(Aqll be glad to provide one.
\&    
\&    You should also have received a copy of the GNU General Public License
\&    along with this program in the file named "Copying". If not, write to the 
\&    Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
\&    MA 02110\-1301, USA or visit their web page on the internet at
\&    http://www.gnu.org/copyleft/gpl.html.
\&    
\&    For those of you that choose to use the GNU General Public License,
\&    my interpretation of the GNU General Public License is that no Perl
\&    script falls under the terms of the GPL unless you explicitly put
\&    said script under the terms of the GPL yourself.  Furthermore, any
\&    object code linked with perl does not automatically fall under the
\&    terms of the GPL, provided such object code only adds definitions
\&    of subroutines and variables, and does not otherwise impair the
\&    resulting interpreter from executing any standard Perl script.  I
\&    consider linking in C subroutines in this manner to be the moral
\&    equivalent of defining subroutines in the Perl language itself.  You
\&    may sell such an object file as proprietary provided that you provide
\&    or offer to provide the Perl source, as specified by the GNU General
\&    Public License.  (This is merely an alternate way of specifying input
\&    to the program.)  You may also sell a binary produced by the dumping of
\&    a running Perl script that belongs to you, provided that you provide or
\&    offer to provide the Perl source as specified by the GPL.  (The
\&    fact that a Perl interpreter and your code are in the same binary file
\&    is, in this case, a form of mere aggregation.)  This is my interpretation
\&    of the GPL.  If you still have concerns or difficulties understanding
\&    my intent, feel free to contact me.  Of course, the Artistic License
\&    spells all this out for your protection, so you may prefer to use that.
.Ve
                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/AutoSplit.3pm                                0100644 0001750 0001750 00000027746 12566207451 023245  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AutoSplit 3pm"
.TH AutoSplit 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AutoSplit \- split a package for autoloading
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& autosplit($file, $dir, $keep, $check, $modtime);
\&
\& autosplit_lib_modules(@modules);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This function will split up your program into files that the AutoLoader
module can handle. It is used by both the standard perl libraries and by
the MakeMaker utility, to automatically configure libraries for autoloading.
.PP
The \f(CW\*(C`autosplit\*(C'\fR interface splits the specified file into a hierarchy 
rooted at the directory \f(CW$dir\fR. It creates directories as needed to reflect
class hierarchy, and creates the file \fIautosplit.ix\fR. This file acts as
both forward declaration of all package routines, and as timestamp for the
last update of the hierarchy.
.PP
The remaining three arguments to \f(CW\*(C`autosplit\*(C'\fR govern other options to
the autosplitter.
.ie n .IP "$keep" 2
.el .IP "\f(CW$keep\fR" 2
.IX Item "$keep"
If the third argument, \fI\f(CI$keep\fI\fR, is false, then any
pre-existing \f(CW\*(C`*.al\*(C'\fR files in the autoload directory are removed if
they are no longer part of the module (obsoleted functions).
\&\f(CW$keep\fR defaults to 0.
.ie n .IP "$check" 2
.el .IP "\f(CW$check\fR" 2
.IX Item "$check"
The
fourth argument, \fI\f(CI$check\fI\fR, instructs \f(CW\*(C`autosplit\*(C'\fR to check the module
currently being split to ensure that it includes a \f(CW\*(C`use\*(C'\fR
specification for the AutoLoader module, and skips the module if
AutoLoader is not detected.
\&\f(CW$check\fR defaults to 1.
.ie n .IP "$modtime" 2
.el .IP "\f(CW$modtime\fR" 2
.IX Item "$modtime"
Lastly, the \fI\f(CI$modtime\fI\fR argument specifies
that \f(CW\*(C`autosplit\*(C'\fR is to check the modification time of the module
against that of the \f(CW\*(C`autosplit.ix\*(C'\fR file, and only split the module if
it is newer.
\&\f(CW$modtime\fR defaults to 1.
.PP
Typical use of AutoSplit in the perl MakeMaker utility is via the command-line
with:
.PP
.Vb 1
\& perl \-e \*(Aquse AutoSplit; autosplit($ARGV[0], $ARGV[1], 0, 1, 1)\*(Aq
.Ve
.PP
Defined as a Make macro, it is invoked with file and directory arguments;
\&\f(CW\*(C`autosplit\*(C'\fR will split the specified file into the specified directory and
delete obsolete \f(CW\*(C`.al\*(C'\fR files, after checking first that the module does use
the AutoLoader, and ensuring that the module is not already currently split
in its current form (the modtime test).
.PP
The \f(CW\*(C`autosplit_lib_modules\*(C'\fR form is used in the building of perl. It takes
as input a list of files (modules) that are assumed to reside in a directory
\&\fBlib\fR relative to the current directory. Each file is sent to the 
autosplitter one at a time, to be split into the directory \fBlib/auto\fR.
.PP
In both usages of the autosplitter, only subroutines defined following the
perl \fI_\|_END_\|_\fR token are split out into separate files. Some
routines may be placed prior to this marker to force their immediate loading
and parsing.
.SS "Multiple packages"
.IX Subsection "Multiple packages"
As of version 1.01 of the AutoSplit module it is possible to have
multiple packages within a single file. Both of the following cases
are supported:
.PP
.Vb 7
\&   package NAME;
\&   _\|_END_\|_
\&   sub AAA { ... }
\&   package NAME::option1;
\&   sub BBB { ... }
\&   package NAME::option2;
\&   sub BBB { ... }
\&
\&   package NAME;
\&   _\|_END_\|_
\&   sub AAA { ... }
\&   sub NAME::option1::BBB { ... }
\&   sub NAME::option2::BBB { ... }
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
\&\f(CW\*(C`AutoSplit\*(C'\fR will inform the user if it is necessary to create the
top-level directory specified in the invocation. It is preferred that
the script or installation process that invokes \f(CW\*(C`AutoSplit\*(C'\fR have
created the full directory path ahead of time. This warning may
indicate that the module is being split into an incorrect path.
.PP
\&\f(CW\*(C`AutoSplit\*(C'\fR will warn the user of all subroutines whose name causes
potential file naming conflicts on machines with drastically limited
(8 characters or less) file name length. Since the subroutine name is
used as the file name, these warnings can aid in portability to such
systems.
.PP
Warnings are issued and the file skipped if \f(CW\*(C`AutoSplit\*(C'\fR cannot locate
either the \fI_\|_END_\|_\fR marker or a \*(L"package Name;\*(R"\-style specification.
.PP
\&\f(CW\*(C`AutoSplit\*(C'\fR will also emit general diagnostics for inability to
create directories or files.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`AutoSplit\*(C'\fR is maintained by the perl5\-porters. Please direct
any questions to the canonical mailing list. Anything that
is applicable to the \s-1CPAN\s0 release can be sent to its maintainer,
though.
.PP
Author and Maintainer: The Perl5\-Porters <perl5\-porters@perl.org>
.PP
Maintainer of the \s-1CPAN\s0 release: Steffen Mueller <smueller@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This package has been part of the perl core since the first release
of perl5. It has been released separately to \s-1CPAN\s0 so older installations
can benefit from bug fixes.
.PP
This package has the same copyright and license as the perl core:
.PP
.Vb 3
\&             Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
\&        2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
\&        by Larry Wall and others
\&    
\&                            All rights reserved.
\&    
\&    This program is free software; you can redistribute it and/or modify
\&    it under the terms of either:
\&    
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&    
\&        b) the "Artistic License" which comes with this Kit.
\&    
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&    
\&    You should have received a copy of the Artistic License with this
\&    Kit, in the file named "Artistic".  If not, I\*(Aqll be glad to provide one.
\&    
\&    You should also have received a copy of the GNU General Public License
\&    along with this program in the file named "Copying". If not, write to the 
\&    Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
\&    02111\-1307, USA or visit their web page on the internet at
\&    http://www.gnu.org/copyleft/gpl.html.
\&    
\&    For those of you that choose to use the GNU General Public License,
\&    my interpretation of the GNU General Public License is that no Perl
\&    script falls under the terms of the GPL unless you explicitly put
\&    said script under the terms of the GPL yourself.  Furthermore, any
\&    object code linked with perl does not automatically fall under the
\&    terms of the GPL, provided such object code only adds definitions
\&    of subroutines and variables, and does not otherwise impair the
\&    resulting interpreter from executing any standard Perl script.  I
\&    consider linking in C subroutines in this manner to be the moral
\&    equivalent of defining subroutines in the Perl language itself.  You
\&    may sell such an object file as proprietary provided that you provide
\&    or offer to provide the Perl source, as specified by the GNU General
\&    Public License.  (This is merely an alternate way of specifying input
\&    to the program.)  You may also sell a binary produced by the dumping of
\&    a running Perl script that belongs to you, provided that you provide or
\&    offer to provide the Perl source as specified by the GPL.  (The
\&    fact that a Perl interpreter and your code are in the same binary file
\&    is, in this case, a form of mere aggregation.)  This is my interpretation
\&    of the GPL.  If you still have concerns or difficulties understanding
\&    my intent, feel free to contact me.  Of course, the Artistic License
\&    spells all this out for your protection, so you may prefer to use that.
.Ve
                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/AutoSplit5.16.3pm                            0100644 0001750 0001750 00000027425 12566207430 023546  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AutoSplit 3pm"
.TH AutoSplit 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AutoSplit \- split a package for autoloading
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& autosplit($file, $dir, $keep, $check, $modtime);
\&
\& autosplit_lib_modules(@modules);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This function will split up your program into files that the AutoLoader
module can handle. It is used by both the standard perl libraries and by
the MakeMaker utility, to automatically configure libraries for autoloading.
.PP
The \f(CW\*(C`autosplit\*(C'\fR interface splits the specified file into a hierarchy 
rooted at the directory \f(CW$dir\fR. It creates directories as needed to reflect
class hierarchy, and creates the file \fIautosplit.ix\fR. This file acts as
both forward declaration of all package routines, and as timestamp for the
last update of the hierarchy.
.PP
The remaining three arguments to \f(CW\*(C`autosplit\*(C'\fR govern other options to
the autosplitter.
.ie n .IP "$keep" 2
.el .IP "\f(CW$keep\fR" 2
.IX Item "$keep"
If the third argument, \fI\f(CI$keep\fI\fR, is false, then any
pre-existing \f(CW\*(C`*.al\*(C'\fR files in the autoload directory are removed if
they are no longer part of the module (obsoleted functions).
\&\f(CW$keep\fR defaults to 0.
.ie n .IP "$check" 2
.el .IP "\f(CW$check\fR" 2
.IX Item "$check"
The
fourth argument, \fI\f(CI$check\fI\fR, instructs \f(CW\*(C`autosplit\*(C'\fR to check the module
currently being split to ensure that it includes a \f(CW\*(C`use\*(C'\fR
specification for the AutoLoader module, and skips the module if
AutoLoader is not detected.
\&\f(CW$check\fR defaults to 1.
.ie n .IP "$modtime" 2
.el .IP "\f(CW$modtime\fR" 2
.IX Item "$modtime"
Lastly, the \fI\f(CI$modtime\fI\fR argument specifies
that \f(CW\*(C`autosplit\*(C'\fR is to check the modification time of the module
against that of the \f(CW\*(C`autosplit.ix\*(C'\fR file, and only split the module if
it is newer.
\&\f(CW$modtime\fR defaults to 1.
.PP
Typical use of AutoSplit in the perl MakeMaker utility is via the command-line
with:
.PP
.Vb 1
\& perl \-e \*(Aquse AutoSplit; autosplit($ARGV[0], $ARGV[1], 0, 1, 1)\*(Aq
.Ve
.PP
Defined as a Make macro, it is invoked with file and directory arguments;
\&\f(CW\*(C`autosplit\*(C'\fR will split the specified file into the specified directory and
delete obsolete \f(CW\*(C`.al\*(C'\fR files, after checking first that the module does use
the AutoLoader, and ensuring that the module is not already currently split
in its current form (the modtime test).
.PP
The \f(CW\*(C`autosplit_lib_modules\*(C'\fR form is used in the building of perl. It takes
as input a list of files (modules) that are assumed to reside in a directory
\&\fBlib\fR relative to the current directory. Each file is sent to the 
autosplitter one at a time, to be split into the directory \fBlib/auto\fR.
.PP
In both usages of the autosplitter, only subroutines defined following the
perl \fI_\|_END_\|_\fR token are split out into separate files. Some
routines may be placed prior to this marker to force their immediate loading
and parsing.
.SS "Multiple packages"
.IX Subsection "Multiple packages"
As of version 1.01 of the AutoSplit module it is possible to have
multiple packages within a single file. Both of the following cases
are supported:
.PP
.Vb 7
\&   package NAME;
\&   _\|_END_\|_
\&   sub AAA { ... }
\&   package NAME::option1;
\&   sub BBB { ... }
\&   package NAME::option2;
\&   sub BBB { ... }
\&
\&   package NAME;
\&   _\|_END_\|_
\&   sub AAA { ... }
\&   sub NAME::option1::BBB { ... }
\&   sub NAME::option2::BBB { ... }
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
\&\f(CW\*(C`AutoSplit\*(C'\fR will inform the user if it is necessary to create the
top-level directory specified in the invocation. It is preferred that
the script or installation process that invokes \f(CW\*(C`AutoSplit\*(C'\fR have
created the full directory path ahead of time. This warning may
indicate that the module is being split into an incorrect path.
.PP
\&\f(CW\*(C`AutoSplit\*(C'\fR will warn the user of all subroutines whose name causes
potential file naming conflicts on machines with drastically limited
(8 characters or less) file name length. Since the subroutine name is
used as the file name, these warnings can aid in portability to such
systems.
.PP
Warnings are issued and the file skipped if \f(CW\*(C`AutoSplit\*(C'\fR cannot locate
either the \fI_\|_END_\|_\fR marker or a \*(L"package Name;\*(R"\-style specification.
.PP
\&\f(CW\*(C`AutoSplit\*(C'\fR will also emit general diagnostics for inability to
create directories or files.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`AutoSplit\*(C'\fR is maintained by the perl5\-porters. Please direct
any questions to the canonical mailing list. Anything that
is applicable to the \s-1CPAN\s0 release can be sent to its maintainer,
though.
.PP
Author and Maintainer: The Perl5\-Porters <perl5\-porters@perl.org>
.PP
Maintainer of the \s-1CPAN\s0 release: Steffen Mueller <smueller@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This package has been part of the perl core since the first release
of perl5. It has been released separately to \s-1CPAN\s0 so older installations
can benefit from bug fixes.
.PP
This package has the same copyright and license as the perl core:
.PP
.Vb 3
\&             Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
\&        2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
\&        by Larry Wall and others
\&    
\&                            All rights reserved.
\&    
\&    This program is free software; you can redistribute it and/or modify
\&    it under the terms of either:
\&    
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&    
\&        b) the "Artistic License" which comes with this Kit.
\&    
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&    
\&    You should have received a copy of the Artistic License with this
\&    Kit, in the file named "Artistic".  If not, I\*(Aqll be glad to provide one.
\&    
\&    You should also have received a copy of the GNU General Public License
\&    along with this program in the file named "Copying". If not, write to the 
\&    Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
\&    02111\-1307, USA or visit their web page on the internet at
\&    http://www.gnu.org/copyleft/gpl.html.
\&    
\&    For those of you that choose to use the GNU General Public License,
\&    my interpretation of the GNU General Public License is that no Perl
\&    script falls under the terms of the GPL unless you explicitly put
\&    said script under the terms of the GPL yourself.  Furthermore, any
\&    object code linked with perl does not automatically fall under the
\&    terms of the GPL, provided such object code only adds definitions
\&    of subroutines and variables, and does not otherwise impair the
\&    resulting interpreter from executing any standard Perl script.  I
\&    consider linking in C subroutines in this manner to be the moral
\&    equivalent of defining subroutines in the Perl language itself.  You
\&    may sell such an object file as proprietary provided that you provide
\&    or offer to provide the Perl source, as specified by the GNU General
\&    Public License.  (This is merely an alternate way of specifying input
\&    to the program.)  You may also sell a binary produced by the dumping of
\&    a running Perl script that belongs to you, provided that you provide or
\&    offer to provide the Perl source as specified by the GPL.  (The
\&    fact that a Perl interpreter and your code are in the same binary file
\&    is, in this case, a form of mere aggregation.)  This is my interpretation
\&    of the GPL.  If you still have concerns or difficulties understanding
\&    my intent, feel free to contact me.  Of course, the Artistic License
\&    spells all this out for your protection, so you may prefer to use that.
.Ve
                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/AutoSplit5.18.3pm                            0100644 0001750 0001750 00000027746 12566207451 023561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AutoSplit 3pm"
.TH AutoSplit 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AutoSplit \- split a package for autoloading
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& autosplit($file, $dir, $keep, $check, $modtime);
\&
\& autosplit_lib_modules(@modules);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This function will split up your program into files that the AutoLoader
module can handle. It is used by both the standard perl libraries and by
the MakeMaker utility, to automatically configure libraries for autoloading.
.PP
The \f(CW\*(C`autosplit\*(C'\fR interface splits the specified file into a hierarchy 
rooted at the directory \f(CW$dir\fR. It creates directories as needed to reflect
class hierarchy, and creates the file \fIautosplit.ix\fR. This file acts as
both forward declaration of all package routines, and as timestamp for the
last update of the hierarchy.
.PP
The remaining three arguments to \f(CW\*(C`autosplit\*(C'\fR govern other options to
the autosplitter.
.ie n .IP "$keep" 2
.el .IP "\f(CW$keep\fR" 2
.IX Item "$keep"
If the third argument, \fI\f(CI$keep\fI\fR, is false, then any
pre-existing \f(CW\*(C`*.al\*(C'\fR files in the autoload directory are removed if
they are no longer part of the module (obsoleted functions).
\&\f(CW$keep\fR defaults to 0.
.ie n .IP "$check" 2
.el .IP "\f(CW$check\fR" 2
.IX Item "$check"
The
fourth argument, \fI\f(CI$check\fI\fR, instructs \f(CW\*(C`autosplit\*(C'\fR to check the module
currently being split to ensure that it includes a \f(CW\*(C`use\*(C'\fR
specification for the AutoLoader module, and skips the module if
AutoLoader is not detected.
\&\f(CW$check\fR defaults to 1.
.ie n .IP "$modtime" 2
.el .IP "\f(CW$modtime\fR" 2
.IX Item "$modtime"
Lastly, the \fI\f(CI$modtime\fI\fR argument specifies
that \f(CW\*(C`autosplit\*(C'\fR is to check the modification time of the module
against that of the \f(CW\*(C`autosplit.ix\*(C'\fR file, and only split the module if
it is newer.
\&\f(CW$modtime\fR defaults to 1.
.PP
Typical use of AutoSplit in the perl MakeMaker utility is via the command-line
with:
.PP
.Vb 1
\& perl \-e \*(Aquse AutoSplit; autosplit($ARGV[0], $ARGV[1], 0, 1, 1)\*(Aq
.Ve
.PP
Defined as a Make macro, it is invoked with file and directory arguments;
\&\f(CW\*(C`autosplit\*(C'\fR will split the specified file into the specified directory and
delete obsolete \f(CW\*(C`.al\*(C'\fR files, after checking first that the module does use
the AutoLoader, and ensuring that the module is not already currently split
in its current form (the modtime test).
.PP
The \f(CW\*(C`autosplit_lib_modules\*(C'\fR form is used in the building of perl. It takes
as input a list of files (modules) that are assumed to reside in a directory
\&\fBlib\fR relative to the current directory. Each file is sent to the 
autosplitter one at a time, to be split into the directory \fBlib/auto\fR.
.PP
In both usages of the autosplitter, only subroutines defined following the
perl \fI_\|_END_\|_\fR token are split out into separate files. Some
routines may be placed prior to this marker to force their immediate loading
and parsing.
.SS "Multiple packages"
.IX Subsection "Multiple packages"
As of version 1.01 of the AutoSplit module it is possible to have
multiple packages within a single file. Both of the following cases
are supported:
.PP
.Vb 7
\&   package NAME;
\&   _\|_END_\|_
\&   sub AAA { ... }
\&   package NAME::option1;
\&   sub BBB { ... }
\&   package NAME::option2;
\&   sub BBB { ... }
\&
\&   package NAME;
\&   _\|_END_\|_
\&   sub AAA { ... }
\&   sub NAME::option1::BBB { ... }
\&   sub NAME::option2::BBB { ... }
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
\&\f(CW\*(C`AutoSplit\*(C'\fR will inform the user if it is necessary to create the
top-level directory specified in the invocation. It is preferred that
the script or installation process that invokes \f(CW\*(C`AutoSplit\*(C'\fR have
created the full directory path ahead of time. This warning may
indicate that the module is being split into an incorrect path.
.PP
\&\f(CW\*(C`AutoSplit\*(C'\fR will warn the user of all subroutines whose name causes
potential file naming conflicts on machines with drastically limited
(8 characters or less) file name length. Since the subroutine name is
used as the file name, these warnings can aid in portability to such
systems.
.PP
Warnings are issued and the file skipped if \f(CW\*(C`AutoSplit\*(C'\fR cannot locate
either the \fI_\|_END_\|_\fR marker or a \*(L"package Name;\*(R"\-style specification.
.PP
\&\f(CW\*(C`AutoSplit\*(C'\fR will also emit general diagnostics for inability to
create directories or files.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\f(CW\*(C`AutoSplit\*(C'\fR is maintained by the perl5\-porters. Please direct
any questions to the canonical mailing list. Anything that
is applicable to the \s-1CPAN\s0 release can be sent to its maintainer,
though.
.PP
Author and Maintainer: The Perl5\-Porters <perl5\-porters@perl.org>
.PP
Maintainer of the \s-1CPAN\s0 release: Steffen Mueller <smueller@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This package has been part of the perl core since the first release
of perl5. It has been released separately to \s-1CPAN\s0 so older installations
can benefit from bug fixes.
.PP
This package has the same copyright and license as the perl core:
.PP
.Vb 3
\&             Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
\&        2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
\&        by Larry Wall and others
\&    
\&                            All rights reserved.
\&    
\&    This program is free software; you can redistribute it and/or modify
\&    it under the terms of either:
\&    
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&    
\&        b) the "Artistic License" which comes with this Kit.
\&    
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&    
\&    You should have received a copy of the Artistic License with this
\&    Kit, in the file named "Artistic".  If not, I\*(Aqll be glad to provide one.
\&    
\&    You should also have received a copy of the GNU General Public License
\&    along with this program in the file named "Copying". If not, write to the 
\&    Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
\&    02111\-1307, USA or visit their web page on the internet at
\&    http://www.gnu.org/copyleft/gpl.html.
\&    
\&    For those of you that choose to use the GNU General Public License,
\&    my interpretation of the GNU General Public License is that no Perl
\&    script falls under the terms of the GPL unless you explicitly put
\&    said script under the terms of the GPL yourself.  Furthermore, any
\&    object code linked with perl does not automatically fall under the
\&    terms of the GPL, provided such object code only adds definitions
\&    of subroutines and variables, and does not otherwise impair the
\&    resulting interpreter from executing any standard Perl script.  I
\&    consider linking in C subroutines in this manner to be the moral
\&    equivalent of defining subroutines in the Perl language itself.  You
\&    may sell such an object file as proprietary provided that you provide
\&    or offer to provide the Perl source, as specified by the GNU General
\&    Public License.  (This is merely an alternate way of specifying input
\&    to the program.)  You may also sell a binary produced by the dumping of
\&    a running Perl script that belongs to you, provided that you provide or
\&    offer to provide the Perl source as specified by the GPL.  (The
\&    fact that a Perl interpreter and your code are in the same binary file
\&    is, in this case, a form of mere aggregation.)  This is my interpretation
\&    of the GPL.  If you still have concerns or difficulties understanding
\&    my intent, feel free to contact me.  Of course, the Artistic License
\&    spells all this out for your protection, so you may prefer to use that.
.Ve
                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B.3pm                                        0100644 0001750 0001750 00000073662 12566207451 021500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B 3pm"
.TH B 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B \- The Perl Compiler Backend
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use B;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`B\*(C'\fR module supplies classes which allow a Perl program to delve
into its own innards.  It is the module used to implement the
\&\*(L"backends\*(R" of the Perl compiler.  Usage of the compiler does not
require knowledge of this module: see the \fIO\fR module for the
user-visible part.  The \f(CW\*(C`B\*(C'\fR module is of use to those who want to
write new compiler backends.  This documentation assumes that the
reader knows a fair amount about perl's internals including such
things as SVs, OPs and the internal symbol table and syntax tree
of a program.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
The \f(CW\*(C`B\*(C'\fR module contains a set of utility functions for querying the
current state of the Perl interpreter; typically these functions
return objects from the B::SV and B::OP classes, or their derived
classes.  These classes in turn define methods for querying the
resulting objects about their own internal state.
.SH "Utility Functions"
.IX Header "Utility Functions"
The \f(CW\*(C`B\*(C'\fR module exports a variety of functions: some are simple
utility functions, others provide a Perl program with a way to
get an initial \*(L"handle\*(R" on an internal object.
.ie n .SS "Functions Returning ""B::SV"", ""B::AV"", ""B::HV"", and ""B::CV"" objects"
.el .SS "Functions Returning \f(CWB::SV\fP, \f(CWB::AV\fP, \f(CWB::HV\fP, and \f(CWB::CV\fP objects"
.IX Subsection "Functions Returning B::SV, B::AV, B::HV, and B::CV objects"
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, \*(L"\s-1OVERVIEW OF
CLASSES\*(R"\s0 and \*(L"SV-RELATED \s-1CLASSES\*(R"\s0.
.IP "sv_undef" 4
.IX Item "sv_undef"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_undef\*(C'\fR.
.IP "sv_yes" 4
.IX Item "sv_yes"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_yes\*(C'\fR.
.IP "sv_no" 4
.IX Item "sv_no"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_no\*(C'\fR.
.IP "svref_2object(\s-1SVREF\s0)" 4
.IX Item "svref_2object(SVREF)"
Takes a reference to any Perl value, and turns the referred-to value
into an object in the appropriate B::OP\-derived or B::SV\-derived
class.  Apart from functions such as \f(CW\*(C`main_root\*(C'\fR, this is the primary
way to get an initial \*(L"handle\*(R" on an internal perl data structure
which can then be followed with the other access methods.
.Sp
The returned object will only be valid as long as the underlying OPs
and SVs continue to exist.  Do not attempt to use the object after the
underlying structures are freed.
.IP "amagic_generation" 4
.IX Item "amagic_generation"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`amagic_generation\*(C'\fR.
As of Perl 5.18, this is just an alias to \f(CW\*(C`PL_na\*(C'\fR, so its value is
meaningless.
.IP "init_av" 4
.IX Item "init_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1INIT\s0 blocks.
.IP "check_av" 4
.IX Item "check_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1CHECK\s0 blocks.
.IP "unitcheck_av" 4
.IX Item "unitcheck_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1UNITCHECK\s0 blocks.
.IP "begin_av" 4
.IX Item "begin_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1BEGIN\s0 blocks.
.IP "end_av" 4
.IX Item "end_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1END\s0 blocks.
.IP "comppadlist" 4
.IX Item "comppadlist"
Returns the \s-1AV\s0 object (i.e. in class B::AV) of the global comppadlist.
.IP "regex_padav" 4
.IX Item "regex_padav"
Only when perl was compiled with ithreads.
.IP "main_cv" 4
.IX Item "main_cv"
Return the (faked) \s-1CV\s0 corresponding to the main part of the Perl
program.
.SS "Functions for Examining the Symbol Table"
.IX Subsection "Functions for Examining the Symbol Table"
.IP "walksymtable(\s-1SYMREF, METHOD, RECURSE, PREFIX\s0)" 4
.IX Item "walksymtable(SYMREF, METHOD, RECURSE, PREFIX)"
Walk the symbol table starting at \s-1SYMREF\s0 and call \s-1METHOD\s0 on each
symbol (a B::GV object) visited.  When the walk reaches package
symbols (such as \*(L"Foo::\*(R") it invokes \s-1RECURSE,\s0 passing in the symbol
name, and only recurses into the package if that sub returns true.
.Sp
\&\s-1PREFIX\s0 is the name of the \s-1SYMREF\s0 you're walking.
.Sp
For example:
.Sp
.Vb 4
\&  # Walk CGI\*(Aqs symbol table calling print_subs on each symbol.
\&  # Recurse only into CGI::Util::
\&  walksymtable(\e%CGI::, \*(Aqprint_subs\*(Aq,
\&               sub { $_[0] eq \*(AqCGI::Util::\*(Aq }, \*(AqCGI::\*(Aq);
.Ve
.Sp
\&\fIprint_subs()\fR is a B::GV method you have declared.  Also see \*(L"B::GV
Methods\*(R", below.
.ie n .SS "Functions Returning ""B::OP"" objects or for walking op trees"
.el .SS "Functions Returning \f(CWB::OP\fP objects or for walking op trees"
.IX Subsection "Functions Returning B::OP objects or for walking op trees"
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, \*(L"\s-1OVERVIEW OF
CLASSES\*(R"\s0 and \*(L"OP-RELATED \s-1CLASSES\*(R"\s0.
.IP "main_root" 4
.IX Item "main_root"
Returns the root op (i.e. an object in the appropriate B::OP\-derived
class) of the main part of the Perl program.
.IP "main_start" 4
.IX Item "main_start"
Returns the starting op of the main part of the Perl program.
.IP "walkoptree(\s-1OP, METHOD\s0)" 4
.IX Item "walkoptree(OP, METHOD)"
Does a tree-walk of the syntax tree based at \s-1OP\s0 and calls \s-1METHOD\s0 on
each op it visits.  Each node is visited before its children.  If
\&\f(CW\*(C`walkoptree_debug\*(C'\fR (see below) has been called to turn debugging on then
the method \f(CW\*(C`walkoptree_debug\*(C'\fR is called on each op before \s-1METHOD\s0 is
called.
.IP "walkoptree_debug(\s-1DEBUG\s0)" 4
.IX Item "walkoptree_debug(DEBUG)"
Returns the current debugging flag for \f(CW\*(C`walkoptree\*(C'\fR.  If the optional
\&\s-1DEBUG\s0 argument is non-zero, it sets the debugging flag to that.  See
the description of \f(CW\*(C`walkoptree\*(C'\fR above for what the debugging flag
does.
.SS "Miscellaneous Utility Functions"
.IX Subsection "Miscellaneous Utility Functions"
.IP "ppname(\s-1OPNUM\s0)" 4
.IX Item "ppname(OPNUM)"
Return the \s-1PP\s0 function name (e.g. \*(L"pp_add\*(R") of op number \s-1OPNUM.\s0
.IP "hash(\s-1STR\s0)" 4
.IX Item "hash(STR)"
Returns a string in the form \*(L"0x...\*(R" representing the value of the
internal hash function used by perl on string \s-1STR.\s0
.IP "cast_I32(I)" 4
.IX Item "cast_I32(I)"
Casts I to the internal I32 type used by that perl.
.IP "minus_c" 4
.IX Item "minus_c"
Does the equivalent of the \f(CW\*(C`\-c\*(C'\fR command-line option.  Obviously, this
is only useful in a \s-1BEGIN\s0 block or else the flag is set too late.
.IP "cstring(\s-1STR\s0)" 4
.IX Item "cstring(STR)"
Returns a double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a string in C source code.
.IP "perlstring(\s-1STR\s0)" 4
.IX Item "perlstring(STR)"
Returns a double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a string in Perl source code.
.IP "class(\s-1OBJ\s0)" 4
.IX Item "class(OBJ)"
Returns the class of an object without the part of the classname
preceding the first \f(CW"::"\fR.  This is used to turn \f(CW"B::UNOP"\fR into
\&\f(CW"UNOP"\fR for example.
.IP "threadsv_names" 4
.IX Item "threadsv_names"
In a perl compiled for threads, this returns a list of the special
per-thread threadsv variables.
.SS "Exported utility variables"
.IX Subsection "Exported utility variables"
.ie n .IP "@optype" 4
.el .IP "\f(CW@optype\fR" 4
.IX Item "@optype"
.Vb 1
\&  my $op_type = $optype[$op_type_num];
.Ve
.Sp
A simple mapping of the op type number to its type (like '\s-1COP\s0' or '\s-1BINOP\s0').
.ie n .IP "@specialsv_name" 4
.el .IP "\f(CW@specialsv_name\fR" 4
.IX Item "@specialsv_name"
.Vb 1
\&  my $sv_name = $specialsv_name[$sv_index];
.Ve
.Sp
Certain \s-1SV\s0 types are considered 'special'.  They're represented by
B::SPECIAL and are referred to by a number from the specialsv_list.
This array maps that number back to the name of the \s-1SV \s0(like 'Nullsv'
or '&PL_sv_undef').
.SH "OVERVIEW OF CLASSES"
.IX Header "OVERVIEW OF CLASSES"
The C structures used by Perl's internals to hold \s-1SV\s0 and \s-1OP\s0
information (\s-1PVIV, AV, HV, ..., OP, SVOP, UNOP, ...\s0) are modelled on a
class hierarchy and the \f(CW\*(C`B\*(C'\fR module gives access to them via a true
object hierarchy.  Structure fields which point to other objects
(whether types of \s-1SV\s0 or types of \s-1OP\s0) are represented by the \f(CW\*(C`B\*(C'\fR
module as Perl objects of the appropriate class.
.PP
The bulk of the \f(CW\*(C`B\*(C'\fR module is the methods for accessing fields of
these structures.
.PP
Note that all access is read-only.  You cannot modify the internals by
using this module.  Also, note that the B::OP and B::SV objects created
by this module are only valid for as long as the underlying objects
exist; their creation doesn't increase the reference counts of the
underlying objects.  Trying to access the fields of a freed object will
give incomprehensible results, or worse.
.SS "SV-RELATED \s-1CLASSES\s0"
.IX Subsection "SV-RELATED CLASSES"
B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and
earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO.  These classes
correspond in the obvious way to the underlying C structures of similar names.
The inheritance hierarchy mimics the underlying C \*(L"inheritance\*(R".  For the
5.10.x branch, (\fIie\fR 5.10.0, 5.10.1 \fIetc\fR) this is:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |            |
\&              B::PV        B::IV        B::NV        B::RV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&                   +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |     |     |
\&                 B::AV B::GV B::HV B::CV B::IO
\&                         |           |
\&                         |           |
\&                      B::PVLV      B::FM
.Ve
.PP
For 5.9.0 and earlier, \s-1PVLV\s0 is a direct subclass of \s-1PVMG,\s0 and \s-1BM\s0 is still
present as a distinct type, so the base of this diagram is
.PP
.Vb 10
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&            +\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&            |      |     |     |     |     |     |
\&         B::PVLV B::BM B::AV B::GV B::HV B::CV B::IO
\&                                           |
\&                                           |
\&                                         B::FM
.Ve
.PP
For 5.11.0 and later, B::RV is abolished, and IVs can be used to store
references, and a new type B::REGEXP is introduced, giving this structure:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |
\&              B::PV        B::IV        B::NV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&           +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-+\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&           |       |       |       |       |       |
\&         B::AV   B::GV   B::HV   B::CV   B::IO B::REGEXP
\&                   |               |
\&                   |               |
\&                B::PVLV          B::FM
.Ve
.PP
Access methods correspond to the underlying C macros for field access,
usually with the leading \*(L"class indication\*(R" prefix removed (Sv, Av,
Hv, ...).  The leading prefix is only left in cases where its removal
would cause a clash in method name.  For example, \f(CW\*(C`GvREFCNT\*(C'\fR stays
as-is since its abbreviation would clash with the \*(L"superclass\*(R" method
\&\f(CW\*(C`REFCNT\*(C'\fR (corresponding to the C function \f(CW\*(C`SvREFCNT\*(C'\fR).
.SS "B::SV Methods"
.IX Subsection "B::SV Methods"
.IP "\s-1REFCNT\s0" 4
.IX Item "REFCNT"
.PD 0
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "object_2svref" 4
.IX Item "object_2svref"
.PD
Returns a reference to the regular scalar corresponding to this
B::SV object.  In other words, this method is the inverse operation
to the \fIsvref_2object()\fR subroutine.  This scalar and other data it points
at should be considered read-only: modifying them is neither safe nor
guaranteed to have a sensible effect.
.SS "B::IV Methods"
.IX Subsection "B::IV Methods"
.IP "\s-1IV\s0" 4
.IX Item "IV"
Returns the value of the \s-1IV, \s0\fIinterpreted as
a signed integer\fR.  This will be misleading
if \f(CW\*(C`FLAGS & SVf_IVisUV\*(C'\fR.  Perhaps you want the
\&\f(CW\*(C`int_value\*(C'\fR method instead?
.IP "\s-1IVX\s0" 4
.IX Item "IVX"
.PD 0
.IP "\s-1UVX\s0" 4
.IX Item "UVX"
.IP "int_value" 4
.IX Item "int_value"
.PD
This method returns the value of the \s-1IV\s0 as an integer.
It differs from \f(CW\*(C`IV\*(C'\fR in that it returns the correct
value regardless of whether it's stored signed or
unsigned.
.IP "needs64bits" 4
.IX Item "needs64bits"
.PD 0
.IP "packiv" 4
.IX Item "packiv"
.PD
.SS "B::NV Methods"
.IX Subsection "B::NV Methods"
.IP "\s-1NV\s0" 4
.IX Item "NV"
.PD 0
.IP "\s-1NVX\s0" 4
.IX Item "NVX"
.PD
.SS "B::RV Methods"
.IX Subsection "B::RV Methods"
.IP "\s-1RV\s0" 4
.IX Item "RV"
.SS "B::PV Methods"
.IX Subsection "B::PV Methods"
.PD 0
.IP "\s-1PV\s0" 4
.IX Item "PV"
.PD
This method is the one you usually want.  It constructs a
string using the length and offset information in the struct:
for ordinary scalars it will return the string that you'd see
from Perl, even if it contains null characters.
.IP "\s-1RV\s0" 4
.IX Item "RV"
Same as B::RV::RV, except that it will \fIdie()\fR if the \s-1PV\s0 isn't
a reference.
.IP "\s-1PVX\s0" 4
.IX Item "PVX"
This method is less often useful.  It assumes that the string
stored in the struct is null-terminated, and disregards the
length information.
.Sp
It is the appropriate method to use if you need to get the name
of a lexical variable from a padname array.  Lexical variable names
are always stored with a null terminator, and the length field
(\s-1CUR\s0) is overloaded for other purposes and can't be relied on here.
.IP "\s-1CUR\s0" 4
.IX Item "CUR"
This method returns the internal length field, which consists of the number
of internal bytes, not necessarily the number of logical characters.
.IP "\s-1LEN\s0" 4
.IX Item "LEN"
This method returns the number of bytes allocated (via malloc) for storing
the string.  This is 0 if the scalar does not \*(L"own\*(R" the string.
.SS "B::PVMG Methods"
.IX Subsection "B::PVMG Methods"
.IP "\s-1MAGIC\s0" 4
.IX Item "MAGIC"
.PD 0
.IP "SvSTASH" 4
.IX Item "SvSTASH"
.PD
.SS "B::MAGIC Methods"
.IX Subsection "B::MAGIC Methods"
.IP "\s-1MOREMAGIC\s0" 4
.IX Item "MOREMAGIC"
.PD 0
.IP "precomp" 4
.IX Item "precomp"
.PD
Only valid on r\-magic, returns the string that generated the regexp.
.IP "\s-1PRIVATE\s0" 4
.IX Item "PRIVATE"
.PD 0
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "\s-1OBJ\s0" 4
.IX Item "OBJ"
.PD
Will \fIdie()\fR if called on r\-magic.
.IP "\s-1PTR\s0" 4
.IX Item "PTR"
.PD 0
.IP "\s-1REGEX\s0" 4
.IX Item "REGEX"
.PD
Only valid on r\-magic, returns the integer value of the \s-1REGEX\s0 stored
in the \s-1MAGIC.\s0
.SS "B::PVLV Methods"
.IX Subsection "B::PVLV Methods"
.IP "\s-1TARGOFF\s0" 4
.IX Item "TARGOFF"
.PD 0
.IP "\s-1TARGLEN\s0" 4
.IX Item "TARGLEN"
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1TARG\s0" 4
.IX Item "TARG"
.PD
.SS "B::BM Methods"
.IX Subsection "B::BM Methods"
.IP "\s-1USEFUL\s0" 4
.IX Item "USEFUL"
.PD 0
.IP "\s-1PREVIOUS\s0" 4
.IX Item "PREVIOUS"
.IP "\s-1RARE\s0" 4
.IX Item "RARE"
.IP "\s-1TABLE\s0" 4
.IX Item "TABLE"
.PD
.SS "B::GV Methods"
.IX Subsection "B::GV Methods"
.IP "is_empty" 4
.IX Item "is_empty"
This method returns \s-1TRUE\s0 if the \s-1GP\s0 field of the \s-1GV\s0 is \s-1NULL.\s0
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.PD 0
.IP "\s-1SAFENAME\s0" 4
.IX Item "SAFENAME"
.PD
This method returns the name of the glob, but if the first
character of the name is a control character, then it converts
it to ^X first, so that *^G would return \*(L"^G\*(R" rather than \*(L"\ecG\*(R".
.Sp
It's useful if you want to print out the name of a variable.
If you restrict yourself to globs which exist at compile-time
then the result ought to be unambiguous, because code like
\&\f(CW\*(C`${"^G"} = 1\*(C'\fR is compiled as two ops \- a constant string and
a dereference (rv2gv) \- so that the glob is created at runtime.
.Sp
If you're working with globs at runtime, and need to disambiguate
*^G from *{\*(L"^G\*(R"}, then you should use the raw \s-1NAME\s0 method.
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1SV\s0" 4
.IX Item "SV"
.IP "\s-1IO\s0" 4
.IX Item "IO"
.IP "\s-1FORM\s0" 4
.IX Item "FORM"
.IP "\s-1AV\s0" 4
.IX Item "AV"
.IP "\s-1HV\s0" 4
.IX Item "HV"
.IP "\s-1EGV\s0" 4
.IX Item "EGV"
.IP "\s-1CV\s0" 4
.IX Item "CV"
.IP "\s-1CVGEN\s0" 4
.IX Item "CVGEN"
.IP "\s-1LINE\s0" 4
.IX Item "LINE"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1FILEGV\s0" 4
.IX Item "FILEGV"
.IP "GvREFCNT" 4
.IX Item "GvREFCNT"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.PD
.SS "B::IO Methods"
.IX Subsection "B::IO Methods"
B::IO objects derive from \s-1IO\s0 objects and you will get more information from
the \s-1IO\s0 object itself.
.PP
For example:
.PP
.Vb 3
\&  $gvio = B::svref_2object(\e*main::stdin)\->IO;
\&  $IO = $gvio\->object_2svref();
\&  $fd = $IO\->fileno();
.Ve
.IP "\s-1LINES\s0" 4
.IX Item "LINES"
.PD 0
.IP "\s-1PAGE\s0" 4
.IX Item "PAGE"
.IP "\s-1PAGE_LEN\s0" 4
.IX Item "PAGE_LEN"
.IP "\s-1LINES_LEFT\s0" 4
.IX Item "LINES_LEFT"
.IP "\s-1TOP_NAME\s0" 4
.IX Item "TOP_NAME"
.IP "\s-1TOP_GV\s0" 4
.IX Item "TOP_GV"
.IP "\s-1FMT_NAME\s0" 4
.IX Item "FMT_NAME"
.IP "\s-1FMT_GV\s0" 4
.IX Item "FMT_GV"
.IP "\s-1BOTTOM_NAME\s0" 4
.IX Item "BOTTOM_NAME"
.IP "\s-1BOTTOM_GV\s0" 4
.IX Item "BOTTOM_GV"
.IP "\s-1SUBPROCESS\s0" 4
.IX Item "SUBPROCESS"
.IP "IoTYPE" 4
.IX Item "IoTYPE"
.PD
A character symbolizing the type of \s-1IO\s0 Handle.
.Sp
.Vb 12
\&  \-     STDIN/OUT
\&  I     STDIN/OUT/ERR
\&  <     read\-only
\&  >     write\-only
\&  a     append
\&  +     read and write
\&  s     socket
\&  |     pipe
\&  I     IMPLICIT
\&  #     NUMERIC
\&  space closed handle
\&  \e0    closed internal handle
.Ve
.IP "IoFLAGS" 4
.IX Item "IoFLAGS"
.PD 0
.IP "IsSTD" 4
.IX Item "IsSTD"
.PD
Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true
if the IoIFP of the object is equal to the handle whose name was
passed as argument; i.e., \f(CW$io\fR\->IsSTD('stderr') is true if
IoIFP($io) == \fIPerlIO_stderr()\fR.
.SS "B::AV Methods"
.IX Subsection "B::AV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "ARRAYelt" 4
.IX Item "ARRAYelt"
.PD
Like \f(CW\*(C`ARRAY\*(C'\fR, but takes an index as an argument to get only one element,
rather than a list of all of them.
.IP "\s-1OFF\s0" 4
.IX Item "OFF"
This method is deprecated if running under Perl 5.8, and is no longer present
if running under Perl 5.9
.IP "AvFLAGS" 4
.IX Item "AvFLAGS"
This method returns the \s-1AV\s0 specific
flags.  In Perl 5.9 these are now stored
in with the main \s-1SV\s0 flags, so this method is no longer present.
.SS "B::CV Methods"
.IX Subsection "B::CV Methods"
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1START\s0" 4
.IX Item "START"
.IP "\s-1ROOT\s0" 4
.IX Item "ROOT"
.IP "\s-1GV\s0" 4
.IX Item "GV"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1DEPTH\s0" 4
.IX Item "DEPTH"
.IP "\s-1PADLIST\s0" 4
.IX Item "PADLIST"
.IP "\s-1OUTSIDE\s0" 4
.IX Item "OUTSIDE"
.IP "\s-1OUTSIDE_SEQ\s0" 4
.IX Item "OUTSIDE_SEQ"
.IP "\s-1XSUB\s0" 4
.IX Item "XSUB"
.IP "\s-1XSUBANY\s0" 4
.IX Item "XSUBANY"
.PD
For constant subroutines, returns the constant \s-1SV\s0 returned by the subroutine.
.IP "CvFLAGS" 4
.IX Item "CvFLAGS"
.PD 0
.IP "const_sv" 4
.IX Item "const_sv"
.IP "\s-1NAME_HEK\s0" 4
.IX Item "NAME_HEK"
.PD
Returns the name of a lexical sub, otherwise \f(CW\*(C`undef\*(C'\fR.
.SS "B::HV Methods"
.IX Subsection "B::HV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1KEYS\s0" 4
.IX Item "KEYS"
.IP "\s-1RITER\s0" 4
.IX Item "RITER"
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "\s-1PMROOT\s0" 4
.IX Item "PMROOT"
.PD
This method is not present if running under Perl 5.9, as the \s-1PMROOT\s0
information is no longer stored directly in the hash.
.SS "OP-RELATED \s-1CLASSES\s0"
.IX Subsection "OP-RELATED CLASSES"
\&\f(CW\*(C`B::OP\*(C'\fR, \f(CW\*(C`B::UNOP\*(C'\fR, \f(CW\*(C`B::BINOP\*(C'\fR, \f(CW\*(C`B::LOGOP\*(C'\fR, \f(CW\*(C`B::LISTOP\*(C'\fR, \f(CW\*(C`B::PMOP\*(C'\fR,
\&\f(CW\*(C`B::SVOP\*(C'\fR, \f(CW\*(C`B::PADOP\*(C'\fR, \f(CW\*(C`B::PVOP\*(C'\fR, \f(CW\*(C`B::LOOP\*(C'\fR, \f(CW\*(C`B::COP\*(C'\fR.
.PP
These classes correspond in the obvious way to the underlying C
structures of similar names.  The inheritance hierarchy mimics the
underlying C \*(L"inheritance\*(R":
.PP
.Vb 10
\&                                 B::OP
\&                                   |
\&                   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&                   |               |        |        |       |
\&                B::UNOP          B::SVOP B::PADOP  B::COP  B::PVOP
\&                 ,\*(Aq  \`\-.
\&                /       \`\-\-.
\&           B::BINOP     B::LOGOP
\&               |
\&               |
\&           B::LISTOP
\&             ,\*(Aq \`.
\&            /     \e
\&        B::LOOP B::PMOP
.Ve
.PP
Access methods correspond to the underlying C structre field names,
with the leading \*(L"class indication\*(R" prefix (\f(CW"op_"\fR) removed.
.SS "B::OP Methods"
.IX Subsection "B::OP Methods"
These methods get the values of similarly named fields within the \s-1OP\s0
data structure.  See top of \f(CW\*(C`op.h\*(C'\fR for more info.
.IP "next" 4
.IX Item "next"
.PD 0
.IP "sibling" 4
.IX Item "sibling"
.IP "name" 4
.IX Item "name"
.PD
This returns the op name as a string (e.g. \*(L"add\*(R", \*(L"rv2av\*(R").
.IP "ppaddr" 4
.IX Item "ppaddr"
This returns the function name as a string (e.g. \*(L"PL_ppaddr[\s-1OP_ADD\s0]\*(R",
\&\*(L"PL_ppaddr[\s-1OP_RV2AV\s0]\*(R").
.IP "desc" 4
.IX Item "desc"
This returns the op description from the global C PL_op_desc array
(e.g. \*(L"addition\*(R" \*(L"array deref\*(R").
.IP "targ" 4
.IX Item "targ"
.PD 0
.IP "type" 4
.IX Item "type"
.IP "opt" 4
.IX Item "opt"
.IP "flags" 4
.IX Item "flags"
.IP "private" 4
.IX Item "private"
.IP "spare" 4
.IX Item "spare"
.PD
.SS "B::UNOP \s-1METHOD\s0"
.IX Subsection "B::UNOP METHOD"
.IP "first" 4
.IX Item "first"
.SS "B::BINOP \s-1METHOD\s0"
.IX Subsection "B::BINOP METHOD"
.PD 0
.IP "last" 4
.IX Item "last"
.PD
.SS "B::LOGOP \s-1METHOD\s0"
.IX Subsection "B::LOGOP METHOD"
.IP "other" 4
.IX Item "other"
.SS "B::LISTOP \s-1METHOD\s0"
.IX Subsection "B::LISTOP METHOD"
.PD 0
.IP "children" 4
.IX Item "children"
.PD
.SS "B::PMOP Methods"
.IX Subsection "B::PMOP Methods"
.IP "pmreplroot" 4
.IX Item "pmreplroot"
.PD 0
.IP "pmreplstart" 4
.IX Item "pmreplstart"
.IP "pmnext" 4
.IX Item "pmnext"
.PD
Only up to Perl 5.9.4
.IP "pmflags" 4
.IX Item "pmflags"
.PD 0
.IP "extflags" 4
.IX Item "extflags"
.PD
Since Perl 5.9.5
.IP "precomp" 4
.IX Item "precomp"
.PD 0
.IP "pmoffset" 4
.IX Item "pmoffset"
.PD
Only when perl was compiled with ithreads.
.IP "code_list" 4
.IX Item "code_list"
Since perl 5.17.1
.SS "B::SVOP \s-1METHOD\s0"
.IX Subsection "B::SVOP METHOD"
.IP "sv" 4
.IX Item "sv"
.PD 0
.IP "gv" 4
.IX Item "gv"
.PD
.SS "B::PADOP \s-1METHOD\s0"
.IX Subsection "B::PADOP METHOD"
.IP "padix" 4
.IX Item "padix"
.SS "B::PVOP \s-1METHOD\s0"
.IX Subsection "B::PVOP METHOD"
.PD 0
.IP "pv" 4
.IX Item "pv"
.PD
.SS "B::LOOP Methods"
.IX Subsection "B::LOOP Methods"
.IP "redoop" 4
.IX Item "redoop"
.PD 0
.IP "nextop" 4
.IX Item "nextop"
.IP "lastop" 4
.IX Item "lastop"
.PD
.SS "B::COP Methods"
.IX Subsection "B::COP Methods"
.IP "label" 4
.IX Item "label"
.PD 0
.IP "stash" 4
.IX Item "stash"
.IP "stashpv" 4
.IX Item "stashpv"
.IP "stashoff (threaded only)" 4
.IX Item "stashoff (threaded only)"
.IP "file" 4
.IX Item "file"
.IP "cop_seq" 4
.IX Item "cop_seq"
.IP "arybase" 4
.IX Item "arybase"
.IP "line" 4
.IX Item "line"
.IP "warnings" 4
.IX Item "warnings"
.IP "io" 4
.IX Item "io"
.IP "hints" 4
.IX Item "hints"
.IP "hints_hash" 4
.IX Item "hints_hash"
.PD
.ie n .SS "$B::overlay"
.el .SS "\f(CW$B::overlay\fP"
.IX Subsection "$B::overlay"
Although the optree is read-only, there is an overlay facility that allows
you to override what values the various B::*OP methods return for a
particular op. \f(CW$B::overlay\fR should be set to reference a two-deep hash:
indexed by \s-1OP\s0 address, then method name. Whenever a an op method is
called, the value in the hash is returned if it exists. This facility is
used by B::Deparse to \*(L"undo\*(R" some optimisations. For example:
.PP
.Vb 11
\&    local $B::overlay = {};
\&    ...
\&    if ($op\->name eq "foo") {
\&        $B::overlay\->{$$op} = {
\&                name => \*(Aqbar\*(Aq,
\&                next => $op\->next\->next,
\&        };
\&    }
\&    ...
\&    $op\->name # returns "bar"
\&    $op\->next # returns the next op but one
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B5.16.3pm                                    0100644 0001750 0001750 00000071312 12566207430 021775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B 3pm"
.TH B 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B \- The Perl Compiler Backend
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use B;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`B\*(C'\fR module supplies classes which allow a Perl program to delve
into its own innards.  It is the module used to implement the
\&\*(L"backends\*(R" of the Perl compiler.  Usage of the compiler does not
require knowledge of this module: see the \fIO\fR module for the
user-visible part.  The \f(CW\*(C`B\*(C'\fR module is of use to those who want to
write new compiler backends.  This documentation assumes that the
reader knows a fair amount about perl's internals including such
things as SVs, OPs and the internal symbol table and syntax tree
of a program.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
The \f(CW\*(C`B\*(C'\fR module contains a set of utility functions for querying the
current state of the Perl interpreter; typically these functions
return objects from the B::SV and B::OP classes, or their derived
classes.  These classes in turn define methods for querying the
resulting objects about their own internal state.
.SH "Utility Functions"
.IX Header "Utility Functions"
The \f(CW\*(C`B\*(C'\fR module exports a variety of functions: some are simple
utility functions, others provide a Perl program with a way to
get an initial \*(L"handle\*(R" on an internal object.
.ie n .SS "Functions Returning ""B::SV"", ""B::AV"", ""B::HV"", and ""B::CV"" objects"
.el .SS "Functions Returning \f(CWB::SV\fP, \f(CWB::AV\fP, \f(CWB::HV\fP, and \f(CWB::CV\fP objects"
.IX Subsection "Functions Returning B::SV, B::AV, B::HV, and B::CV objects"
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, \*(L"\s-1OVERVIEW\s0 \s-1OF\s0
\&\s-1CLASSES\s0\*(R" and \*(L"SV-RELATED \s-1CLASSES\s0\*(R".
.IP "sv_undef" 4
.IX Item "sv_undef"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_undef\*(C'\fR.
.IP "sv_yes" 4
.IX Item "sv_yes"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_yes\*(C'\fR.
.IP "sv_no" 4
.IX Item "sv_no"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_no\*(C'\fR.
.IP "svref_2object(\s-1SVREF\s0)" 4
.IX Item "svref_2object(SVREF)"
Takes a reference to any Perl value, and turns the referred-to value
into an object in the appropriate B::OP\-derived or B::SV\-derived
class.  Apart from functions such as \f(CW\*(C`main_root\*(C'\fR, this is the primary
way to get an initial \*(L"handle\*(R" on an internal perl data structure
which can then be followed with the other access methods.
.Sp
The returned object will only be valid as long as the underlying OPs
and SVs continue to exist.  Do not attempt to use the object after the
underlying structures are freed.
.IP "amagic_generation" 4
.IX Item "amagic_generation"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`amagic_generation\*(C'\fR.
.IP "init_av" 4
.IX Item "init_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1INIT\s0 blocks.
.IP "check_av" 4
.IX Item "check_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1CHECK\s0 blocks.
.IP "unitcheck_av" 4
.IX Item "unitcheck_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1UNITCHECK\s0 blocks.
.IP "begin_av" 4
.IX Item "begin_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1BEGIN\s0 blocks.
.IP "end_av" 4
.IX Item "end_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1END\s0 blocks.
.IP "comppadlist" 4
.IX Item "comppadlist"
Returns the \s-1AV\s0 object (i.e. in class B::AV) of the global comppadlist.
.IP "regex_padav" 4
.IX Item "regex_padav"
Only when perl was compiled with ithreads.
.IP "main_cv" 4
.IX Item "main_cv"
Return the (faked) \s-1CV\s0 corresponding to the main part of the Perl
program.
.SS "Functions for Examining the Symbol Table"
.IX Subsection "Functions for Examining the Symbol Table"
.IP "walksymtable(\s-1SYMREF\s0, \s-1METHOD\s0, \s-1RECURSE\s0, \s-1PREFIX\s0)" 4
.IX Item "walksymtable(SYMREF, METHOD, RECURSE, PREFIX)"
Walk the symbol table starting at \s-1SYMREF\s0 and call \s-1METHOD\s0 on each
symbol (a B::GV object) visited.  When the walk reaches package
symbols (such as \*(L"Foo::\*(R") it invokes \s-1RECURSE\s0, passing in the symbol
name, and only recurses into the package if that sub returns true.
.Sp
\&\s-1PREFIX\s0 is the name of the \s-1SYMREF\s0 you're walking.
.Sp
For example:
.Sp
.Vb 4
\&  # Walk CGI\*(Aqs symbol table calling print_subs on each symbol.
\&  # Recurse only into CGI::Util::
\&  walksymtable(\e%CGI::, \*(Aqprint_subs\*(Aq,
\&               sub { $_[0] eq \*(AqCGI::Util::\*(Aq }, \*(AqCGI::\*(Aq);
.Ve
.Sp
\&\fIprint_subs()\fR is a B::GV method you have declared.  Also see \*(L"B::GV
Methods\*(R", below.
.ie n .SS "Functions Returning ""B::OP"" objects or for walking op trees"
.el .SS "Functions Returning \f(CWB::OP\fP objects or for walking op trees"
.IX Subsection "Functions Returning B::OP objects or for walking op trees"
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, \*(L"\s-1OVERVIEW\s0 \s-1OF\s0
\&\s-1CLASSES\s0\*(R" and \*(L"OP-RELATED \s-1CLASSES\s0\*(R".
.IP "main_root" 4
.IX Item "main_root"
Returns the root op (i.e. an object in the appropriate B::OP\-derived
class) of the main part of the Perl program.
.IP "main_start" 4
.IX Item "main_start"
Returns the starting op of the main part of the Perl program.
.IP "walkoptree(\s-1OP\s0, \s-1METHOD\s0)" 4
.IX Item "walkoptree(OP, METHOD)"
Does a tree-walk of the syntax tree based at \s-1OP\s0 and calls \s-1METHOD\s0 on
each op it visits.  Each node is visited before its children.  If
\&\f(CW\*(C`walkoptree_debug\*(C'\fR (see below) has been called to turn debugging on then
the method \f(CW\*(C`walkoptree_debug\*(C'\fR is called on each op before \s-1METHOD\s0 is
called.
.IP "walkoptree_debug(\s-1DEBUG\s0)" 4
.IX Item "walkoptree_debug(DEBUG)"
Returns the current debugging flag for \f(CW\*(C`walkoptree\*(C'\fR.  If the optional
\&\s-1DEBUG\s0 argument is non-zero, it sets the debugging flag to that.  See
the description of \f(CW\*(C`walkoptree\*(C'\fR above for what the debugging flag
does.
.SS "Miscellaneous Utility Functions"
.IX Subsection "Miscellaneous Utility Functions"
.IP "ppname(\s-1OPNUM\s0)" 4
.IX Item "ppname(OPNUM)"
Return the \s-1PP\s0 function name (e.g. \*(L"pp_add\*(R") of op number \s-1OPNUM\s0.
.IP "hash(\s-1STR\s0)" 4
.IX Item "hash(STR)"
Returns a string in the form \*(L"0x...\*(R" representing the value of the
internal hash function used by perl on string \s-1STR\s0.
.IP "cast_I32(I)" 4
.IX Item "cast_I32(I)"
Casts I to the internal I32 type used by that perl.
.IP "minus_c" 4
.IX Item "minus_c"
Does the equivalent of the \f(CW\*(C`\-c\*(C'\fR command-line option.  Obviously, this
is only useful in a \s-1BEGIN\s0 block or else the flag is set too late.
.IP "cstring(\s-1STR\s0)" 4
.IX Item "cstring(STR)"
Returns a double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a string in C source code.
.IP "perlstring(\s-1STR\s0)" 4
.IX Item "perlstring(STR)"
Returns a double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a string in Perl source code.
.IP "class(\s-1OBJ\s0)" 4
.IX Item "class(OBJ)"
Returns the class of an object without the part of the classname
preceding the first \f(CW"::"\fR.  This is used to turn \f(CW"B::UNOP"\fR into
\&\f(CW"UNOP"\fR for example.
.IP "threadsv_names" 4
.IX Item "threadsv_names"
In a perl compiled for threads, this returns a list of the special
per-thread threadsv variables.
.SS "Exported utility variables"
.IX Subsection "Exported utility variables"
.ie n .IP "@optype" 4
.el .IP "\f(CW@optype\fR" 4
.IX Item "@optype"
.Vb 1
\&  my $op_type = $optype[$op_type_num];
.Ve
.Sp
A simple mapping of the op type number to its type (like '\s-1COP\s0' or '\s-1BINOP\s0').
.ie n .IP "@specialsv_name" 4
.el .IP "\f(CW@specialsv_name\fR" 4
.IX Item "@specialsv_name"
.Vb 1
\&  my $sv_name = $specialsv_name[$sv_index];
.Ve
.Sp
Certain \s-1SV\s0 types are considered 'special'.  They're represented by
B::SPECIAL and are referred to by a number from the specialsv_list.
This array maps that number back to the name of the \s-1SV\s0 (like 'Nullsv'
or '&PL_sv_undef').
.SH "OVERVIEW OF CLASSES"
.IX Header "OVERVIEW OF CLASSES"
The C structures used by Perl's internals to hold \s-1SV\s0 and \s-1OP\s0
information (\s-1PVIV\s0, \s-1AV\s0, \s-1HV\s0, ..., \s-1OP\s0, \s-1SVOP\s0, \s-1UNOP\s0, ...) are modelled on a
class hierarchy and the \f(CW\*(C`B\*(C'\fR module gives access to them via a true
object hierarchy.  Structure fields which point to other objects
(whether types of \s-1SV\s0 or types of \s-1OP\s0) are represented by the \f(CW\*(C`B\*(C'\fR
module as Perl objects of the appropriate class.
.PP
The bulk of the \f(CW\*(C`B\*(C'\fR module is the methods for accessing fields of
these structures.
.PP
Note that all access is read-only.  You cannot modify the internals by
using this module.  Also, note that the B::OP and B::SV objects created
by this module are only valid for as long as the underlying objects
exist; their creation doesn't increase the reference counts of the
underlying objects.  Trying to access the fields of a freed object will
give incomprehensible results, or worse.
.SS "SV-RELATED \s-1CLASSES\s0"
.IX Subsection "SV-RELATED CLASSES"
B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and
earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO.  These classes
correspond in the obvious way to the underlying C structures of similar names.
The inheritance hierarchy mimics the underlying C \*(L"inheritance\*(R".  For the
5.10.x branch, (\fIie\fR 5.10.0, 5.10.1 \fIetc\fR) this is:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |            |
\&              B::PV        B::IV        B::NV        B::RV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&                   +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |     |     |
\&                 B::AV B::GV B::HV B::CV B::IO
\&                         |           |
\&                         |           |
\&                      B::PVLV      B::FM
.Ve
.PP
For 5.9.0 and earlier, \s-1PVLV\s0 is a direct subclass of \s-1PVMG\s0, and \s-1BM\s0 is still
present as a distinct type, so the base of this diagram is
.PP
.Vb 10
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&            +\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&            |      |     |     |     |     |     |
\&         B::PVLV B::BM B::AV B::GV B::HV B::CV B::IO
\&                                           |
\&                                           |
\&                                         B::FM
.Ve
.PP
For 5.11.0 and later, B::RV is abolished, and IVs can be used to store
references, and a new type B::REGEXP is introduced, giving this structure:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |
\&              B::PV        B::IV        B::NV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&           +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-+\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&           |       |       |       |       |       |
\&         B::AV   B::GV   B::HV   B::CV   B::IO B::REGEXP
\&                   |               |
\&                   |               |
\&                B::PVLV          B::FM
.Ve
.PP
Access methods correspond to the underlying C macros for field access,
usually with the leading \*(L"class indication\*(R" prefix removed (Sv, Av,
Hv, ...).  The leading prefix is only left in cases where its removal
would cause a clash in method name.  For example, \f(CW\*(C`GvREFCNT\*(C'\fR stays
as-is since its abbreviation would clash with the \*(L"superclass\*(R" method
\&\f(CW\*(C`REFCNT\*(C'\fR (corresponding to the C function \f(CW\*(C`SvREFCNT\*(C'\fR).
.SS "B::SV Methods"
.IX Subsection "B::SV Methods"
.IP "\s-1REFCNT\s0" 4
.IX Item "REFCNT"
.PD 0
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "object_2svref" 4
.IX Item "object_2svref"
.PD
Returns a reference to the regular scalar corresponding to this
B::SV object.  In other words, this method is the inverse operation
to the \fIsvref_2object()\fR subroutine.  This scalar and other data it points
at should be considered read-only: modifying them is neither safe nor
guaranteed to have a sensible effect.
.SS "B::IV Methods"
.IX Subsection "B::IV Methods"
.IP "\s-1IV\s0" 4
.IX Item "IV"
Returns the value of the \s-1IV\s0, \fIinterpreted as
a signed integer\fR.  This will be misleading
if \f(CW\*(C`FLAGS & SVf_IVisUV\*(C'\fR.  Perhaps you want the
\&\f(CW\*(C`int_value\*(C'\fR method instead?
.IP "\s-1IVX\s0" 4
.IX Item "IVX"
.PD 0
.IP "\s-1UVX\s0" 4
.IX Item "UVX"
.IP "int_value" 4
.IX Item "int_value"
.PD
This method returns the value of the \s-1IV\s0 as an integer.
It differs from \f(CW\*(C`IV\*(C'\fR in that it returns the correct
value regardless of whether it's stored signed or
unsigned.
.IP "needs64bits" 4
.IX Item "needs64bits"
.PD 0
.IP "packiv" 4
.IX Item "packiv"
.PD
.SS "B::NV Methods"
.IX Subsection "B::NV Methods"
.IP "\s-1NV\s0" 4
.IX Item "NV"
.PD 0
.IP "\s-1NVX\s0" 4
.IX Item "NVX"
.PD
.SS "B::RV Methods"
.IX Subsection "B::RV Methods"
.IP "\s-1RV\s0" 4
.IX Item "RV"
.SS "B::PV Methods"
.IX Subsection "B::PV Methods"
.PD 0
.IP "\s-1PV\s0" 4
.IX Item "PV"
.PD
This method is the one you usually want.  It constructs a
string using the length and offset information in the struct:
for ordinary scalars it will return the string that you'd see
from Perl, even if it contains null characters.
.IP "\s-1RV\s0" 4
.IX Item "RV"
Same as B::RV::RV, except that it will \fIdie()\fR if the \s-1PV\s0 isn't
a reference.
.IP "\s-1PVX\s0" 4
.IX Item "PVX"
This method is less often useful.  It assumes that the string
stored in the struct is null-terminated, and disregards the
length information.
.Sp
It is the appropriate method to use if you need to get the name
of a lexical variable from a padname array.  Lexical variable names
are always stored with a null terminator, and the length field
(\s-1CUR\s0) is overloaded for other purposes and can't be relied on here.
.IP "\s-1CUR\s0" 4
.IX Item "CUR"
This method returns the internal length field, which consists of the number
of internal bytes, not necessarily the number of logical characters.
.IP "\s-1LEN\s0" 4
.IX Item "LEN"
This method returns the number of bytes allocated (via malloc) for storing
the string.  This is 0 if the scalar does not \*(L"own\*(R" the string.
.SS "B::PVMG Methods"
.IX Subsection "B::PVMG Methods"
.IP "\s-1MAGIC\s0" 4
.IX Item "MAGIC"
.PD 0
.IP "SvSTASH" 4
.IX Item "SvSTASH"
.PD
.SS "B::MAGIC Methods"
.IX Subsection "B::MAGIC Methods"
.IP "\s-1MOREMAGIC\s0" 4
.IX Item "MOREMAGIC"
.PD 0
.IP "precomp" 4
.IX Item "precomp"
.PD
Only valid on r\-magic, returns the string that generated the regexp.
.IP "\s-1PRIVATE\s0" 4
.IX Item "PRIVATE"
.PD 0
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "\s-1OBJ\s0" 4
.IX Item "OBJ"
.PD
Will \fIdie()\fR if called on r\-magic.
.IP "\s-1PTR\s0" 4
.IX Item "PTR"
.PD 0
.IP "\s-1REGEX\s0" 4
.IX Item "REGEX"
.PD
Only valid on r\-magic, returns the integer value of the \s-1REGEX\s0 stored
in the \s-1MAGIC\s0.
.SS "B::PVLV Methods"
.IX Subsection "B::PVLV Methods"
.IP "\s-1TARGOFF\s0" 4
.IX Item "TARGOFF"
.PD 0
.IP "\s-1TARGLEN\s0" 4
.IX Item "TARGLEN"
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1TARG\s0" 4
.IX Item "TARG"
.PD
.SS "B::BM Methods"
.IX Subsection "B::BM Methods"
.IP "\s-1USEFUL\s0" 4
.IX Item "USEFUL"
.PD 0
.IP "\s-1PREVIOUS\s0" 4
.IX Item "PREVIOUS"
.IP "\s-1RARE\s0" 4
.IX Item "RARE"
.IP "\s-1TABLE\s0" 4
.IX Item "TABLE"
.PD
.SS "B::GV Methods"
.IX Subsection "B::GV Methods"
.IP "is_empty" 4
.IX Item "is_empty"
This method returns \s-1TRUE\s0 if the \s-1GP\s0 field of the \s-1GV\s0 is \s-1NULL\s0.
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.PD 0
.IP "\s-1SAFENAME\s0" 4
.IX Item "SAFENAME"
.PD
This method returns the name of the glob, but if the first
character of the name is a control character, then it converts
it to ^X first, so that *^G would return \*(L"^G\*(R" rather than \*(L"\ecG\*(R".
.Sp
It's useful if you want to print out the name of a variable.
If you restrict yourself to globs which exist at compile-time
then the result ought to be unambiguous, because code like
\&\f(CW\*(C`${"^G"} = 1\*(C'\fR is compiled as two ops \- a constant string and
a dereference (rv2gv) \- so that the glob is created at runtime.
.Sp
If you're working with globs at runtime, and need to disambiguate
*^G from *{\*(L"^G\*(R"}, then you should use the raw \s-1NAME\s0 method.
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1SV\s0" 4
.IX Item "SV"
.IP "\s-1IO\s0" 4
.IX Item "IO"
.IP "\s-1FORM\s0" 4
.IX Item "FORM"
.IP "\s-1AV\s0" 4
.IX Item "AV"
.IP "\s-1HV\s0" 4
.IX Item "HV"
.IP "\s-1EGV\s0" 4
.IX Item "EGV"
.IP "\s-1CV\s0" 4
.IX Item "CV"
.IP "\s-1CVGEN\s0" 4
.IX Item "CVGEN"
.IP "\s-1LINE\s0" 4
.IX Item "LINE"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1FILEGV\s0" 4
.IX Item "FILEGV"
.IP "GvREFCNT" 4
.IX Item "GvREFCNT"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.PD
.SS "B::IO Methods"
.IX Subsection "B::IO Methods"
B::IO objects derive from \s-1IO\s0 objects and you will get more information from
the \s-1IO\s0 object itself.
.PP
For example:
.PP
.Vb 3
\&  $gvio = B::svref_2object(\e*main::stdin)\->IO;
\&  $IO = $gvio\->object_2svref();
\&  $fd = $IO\->fileno();
.Ve
.IP "\s-1LINES\s0" 4
.IX Item "LINES"
.PD 0
.IP "\s-1PAGE\s0" 4
.IX Item "PAGE"
.IP "\s-1PAGE_LEN\s0" 4
.IX Item "PAGE_LEN"
.IP "\s-1LINES_LEFT\s0" 4
.IX Item "LINES_LEFT"
.IP "\s-1TOP_NAME\s0" 4
.IX Item "TOP_NAME"
.IP "\s-1TOP_GV\s0" 4
.IX Item "TOP_GV"
.IP "\s-1FMT_NAME\s0" 4
.IX Item "FMT_NAME"
.IP "\s-1FMT_GV\s0" 4
.IX Item "FMT_GV"
.IP "\s-1BOTTOM_NAME\s0" 4
.IX Item "BOTTOM_NAME"
.IP "\s-1BOTTOM_GV\s0" 4
.IX Item "BOTTOM_GV"
.IP "\s-1SUBPROCESS\s0" 4
.IX Item "SUBPROCESS"
.IP "IoTYPE" 4
.IX Item "IoTYPE"
.PD
A character symbolizing the type of \s-1IO\s0 Handle.
.Sp
.Vb 12
\&  \-     STDIN/OUT
\&  I     STDIN/OUT/ERR
\&  <     read\-only
\&  >     write\-only
\&  a     append
\&  +     read and write
\&  s     socket
\&  |     pipe
\&  I     IMPLICIT
\&  #     NUMERIC
\&  space closed handle
\&  \e0    closed internal handle
.Ve
.IP "IoFLAGS" 4
.IX Item "IoFLAGS"
.PD 0
.IP "IsSTD" 4
.IX Item "IsSTD"
.PD
Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true
if the IoIFP of the object is equal to the handle whose name was
passed as argument; i.e., \f(CW$io\fR\->IsSTD('stderr') is true if
IoIFP($io) == \fIPerlIO_stderr()\fR.
.SS "B::AV Methods"
.IX Subsection "B::AV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "ARRAYelt" 4
.IX Item "ARRAYelt"
.PD
Like \f(CW\*(C`ARRAY\*(C'\fR, but takes an index as an argument to get only one element,
rather than a list of all of them.
.IP "\s-1OFF\s0" 4
.IX Item "OFF"
This method is deprecated if running under Perl 5.8, and is no longer present
if running under Perl 5.9
.IP "AvFLAGS" 4
.IX Item "AvFLAGS"
This method returns the \s-1AV\s0 specific
flags.  In Perl 5.9 these are now stored
in with the main \s-1SV\s0 flags, so this method is no longer present.
.SS "B::CV Methods"
.IX Subsection "B::CV Methods"
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1START\s0" 4
.IX Item "START"
.IP "\s-1ROOT\s0" 4
.IX Item "ROOT"
.IP "\s-1GV\s0" 4
.IX Item "GV"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1DEPTH\s0" 4
.IX Item "DEPTH"
.IP "\s-1PADLIST\s0" 4
.IX Item "PADLIST"
.IP "\s-1OUTSIDE\s0" 4
.IX Item "OUTSIDE"
.IP "\s-1OUTSIDE_SEQ\s0" 4
.IX Item "OUTSIDE_SEQ"
.IP "\s-1XSUB\s0" 4
.IX Item "XSUB"
.IP "\s-1XSUBANY\s0" 4
.IX Item "XSUBANY"
.PD
For constant subroutines, returns the constant \s-1SV\s0 returned by the subroutine.
.IP "CvFLAGS" 4
.IX Item "CvFLAGS"
.PD 0
.IP "const_sv" 4
.IX Item "const_sv"
.PD
.SS "B::HV Methods"
.IX Subsection "B::HV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1KEYS\s0" 4
.IX Item "KEYS"
.IP "\s-1RITER\s0" 4
.IX Item "RITER"
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "\s-1PMROOT\s0" 4
.IX Item "PMROOT"
.PD
This method is not present if running under Perl 5.9, as the \s-1PMROOT\s0
information is no longer stored directly in the hash.
.SS "OP-RELATED \s-1CLASSES\s0"
.IX Subsection "OP-RELATED CLASSES"
\&\f(CW\*(C`B::OP\*(C'\fR, \f(CW\*(C`B::UNOP\*(C'\fR, \f(CW\*(C`B::BINOP\*(C'\fR, \f(CW\*(C`B::LOGOP\*(C'\fR, \f(CW\*(C`B::LISTOP\*(C'\fR, \f(CW\*(C`B::PMOP\*(C'\fR,
\&\f(CW\*(C`B::SVOP\*(C'\fR, \f(CW\*(C`B::PADOP\*(C'\fR, \f(CW\*(C`B::PVOP\*(C'\fR, \f(CW\*(C`B::LOOP\*(C'\fR, \f(CW\*(C`B::COP\*(C'\fR.
.PP
These classes correspond in the obvious way to the underlying C
structures of similar names.  The inheritance hierarchy mimics the
underlying C \*(L"inheritance\*(R":
.PP
.Vb 10
\&                                 B::OP
\&                                   |
\&                   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&                   |               |        |        |       |
\&                B::UNOP          B::SVOP B::PADOP  B::COP  B::PVOP
\&                 ,\*(Aq  \`\-.
\&                /       \`\-\-.
\&           B::BINOP     B::LOGOP
\&               |
\&               |
\&           B::LISTOP
\&             ,\*(Aq \`.
\&            /     \e
\&        B::LOOP B::PMOP
.Ve
.PP
Access methods correspond to the underlying C structre field names,
with the leading \*(L"class indication\*(R" prefix (\f(CW"op_"\fR) removed.
.SS "B::OP Methods"
.IX Subsection "B::OP Methods"
These methods get the values of similarly named fields within the \s-1OP\s0
data structure.  See top of \f(CW\*(C`op.h\*(C'\fR for more info.
.IP "next" 4
.IX Item "next"
.PD 0
.IP "sibling" 4
.IX Item "sibling"
.IP "name" 4
.IX Item "name"
.PD
This returns the op name as a string (e.g. \*(L"add\*(R", \*(L"rv2av\*(R").
.IP "ppaddr" 4
.IX Item "ppaddr"
This returns the function name as a string (e.g. \*(L"PL_ppaddr[\s-1OP_ADD\s0]\*(R",
\&\*(L"PL_ppaddr[\s-1OP_RV2AV\s0]\*(R").
.IP "desc" 4
.IX Item "desc"
This returns the op description from the global C PL_op_desc array
(e.g. \*(L"addition\*(R" \*(L"array deref\*(R").
.IP "targ" 4
.IX Item "targ"
.PD 0
.IP "type" 4
.IX Item "type"
.IP "opt" 4
.IX Item "opt"
.IP "flags" 4
.IX Item "flags"
.IP "private" 4
.IX Item "private"
.IP "spare" 4
.IX Item "spare"
.PD
.SS "B::UNOP \s-1METHOD\s0"
.IX Subsection "B::UNOP METHOD"
.IP "first" 4
.IX Item "first"
.SS "B::BINOP \s-1METHOD\s0"
.IX Subsection "B::BINOP METHOD"
.PD 0
.IP "last" 4
.IX Item "last"
.PD
.SS "B::LOGOP \s-1METHOD\s0"
.IX Subsection "B::LOGOP METHOD"
.IP "other" 4
.IX Item "other"
.SS "B::LISTOP \s-1METHOD\s0"
.IX Subsection "B::LISTOP METHOD"
.PD 0
.IP "children" 4
.IX Item "children"
.PD
.SS "B::PMOP Methods"
.IX Subsection "B::PMOP Methods"
.IP "pmreplroot" 4
.IX Item "pmreplroot"
.PD 0
.IP "pmreplstart" 4
.IX Item "pmreplstart"
.IP "pmnext" 4
.IX Item "pmnext"
.PD
Only up to Perl 5.9.4
.IP "pmflags" 4
.IX Item "pmflags"
.PD 0
.IP "extflags" 4
.IX Item "extflags"
.PD
Since Perl 5.9.5
.IP "precomp" 4
.IX Item "precomp"
.PD 0
.IP "pmoffset" 4
.IX Item "pmoffset"
.PD
Only when perl was compiled with ithreads.
.SS "B::SVOP \s-1METHOD\s0"
.IX Subsection "B::SVOP METHOD"
.IP "sv" 4
.IX Item "sv"
.PD 0
.IP "gv" 4
.IX Item "gv"
.PD
.SS "B::PADOP \s-1METHOD\s0"
.IX Subsection "B::PADOP METHOD"
.IP "padix" 4
.IX Item "padix"
.SS "B::PVOP \s-1METHOD\s0"
.IX Subsection "B::PVOP METHOD"
.PD 0
.IP "pv" 4
.IX Item "pv"
.PD
.SS "B::LOOP Methods"
.IX Subsection "B::LOOP Methods"
.IP "redoop" 4
.IX Item "redoop"
.PD 0
.IP "nextop" 4
.IX Item "nextop"
.IP "lastop" 4
.IX Item "lastop"
.PD
.SS "B::COP Methods"
.IX Subsection "B::COP Methods"
.IP "label" 4
.IX Item "label"
.PD 0
.IP "stash" 4
.IX Item "stash"
.IP "stashpv" 4
.IX Item "stashpv"
.IP "stashlen" 4
.IX Item "stashlen"
.IP "file" 4
.IX Item "file"
.IP "cop_seq" 4
.IX Item "cop_seq"
.IP "arybase" 4
.IX Item "arybase"
.IP "line" 4
.IX Item "line"
.IP "warnings" 4
.IX Item "warnings"
.IP "io" 4
.IX Item "io"
.IP "hints" 4
.IX Item "hints"
.IP "hints_hash" 4
.IX Item "hints_hash"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B5.18.3pm                                    0100644 0001750 0001750 00000073662 12566207451 022014  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B 3pm"
.TH B 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B \- The Perl Compiler Backend
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use B;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`B\*(C'\fR module supplies classes which allow a Perl program to delve
into its own innards.  It is the module used to implement the
\&\*(L"backends\*(R" of the Perl compiler.  Usage of the compiler does not
require knowledge of this module: see the \fIO\fR module for the
user-visible part.  The \f(CW\*(C`B\*(C'\fR module is of use to those who want to
write new compiler backends.  This documentation assumes that the
reader knows a fair amount about perl's internals including such
things as SVs, OPs and the internal symbol table and syntax tree
of a program.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
The \f(CW\*(C`B\*(C'\fR module contains a set of utility functions for querying the
current state of the Perl interpreter; typically these functions
return objects from the B::SV and B::OP classes, or their derived
classes.  These classes in turn define methods for querying the
resulting objects about their own internal state.
.SH "Utility Functions"
.IX Header "Utility Functions"
The \f(CW\*(C`B\*(C'\fR module exports a variety of functions: some are simple
utility functions, others provide a Perl program with a way to
get an initial \*(L"handle\*(R" on an internal object.
.ie n .SS "Functions Returning ""B::SV"", ""B::AV"", ""B::HV"", and ""B::CV"" objects"
.el .SS "Functions Returning \f(CWB::SV\fP, \f(CWB::AV\fP, \f(CWB::HV\fP, and \f(CWB::CV\fP objects"
.IX Subsection "Functions Returning B::SV, B::AV, B::HV, and B::CV objects"
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, \*(L"\s-1OVERVIEW OF
CLASSES\*(R"\s0 and \*(L"SV-RELATED \s-1CLASSES\*(R"\s0.
.IP "sv_undef" 4
.IX Item "sv_undef"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_undef\*(C'\fR.
.IP "sv_yes" 4
.IX Item "sv_yes"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_yes\*(C'\fR.
.IP "sv_no" 4
.IX Item "sv_no"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`sv_no\*(C'\fR.
.IP "svref_2object(\s-1SVREF\s0)" 4
.IX Item "svref_2object(SVREF)"
Takes a reference to any Perl value, and turns the referred-to value
into an object in the appropriate B::OP\-derived or B::SV\-derived
class.  Apart from functions such as \f(CW\*(C`main_root\*(C'\fR, this is the primary
way to get an initial \*(L"handle\*(R" on an internal perl data structure
which can then be followed with the other access methods.
.Sp
The returned object will only be valid as long as the underlying OPs
and SVs continue to exist.  Do not attempt to use the object after the
underlying structures are freed.
.IP "amagic_generation" 4
.IX Item "amagic_generation"
Returns the \s-1SV\s0 object corresponding to the C variable \f(CW\*(C`amagic_generation\*(C'\fR.
As of Perl 5.18, this is just an alias to \f(CW\*(C`PL_na\*(C'\fR, so its value is
meaningless.
.IP "init_av" 4
.IX Item "init_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1INIT\s0 blocks.
.IP "check_av" 4
.IX Item "check_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1CHECK\s0 blocks.
.IP "unitcheck_av" 4
.IX Item "unitcheck_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1UNITCHECK\s0 blocks.
.IP "begin_av" 4
.IX Item "begin_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1BEGIN\s0 blocks.
.IP "end_av" 4
.IX Item "end_av"
Returns the \s-1AV\s0 object (i.e. in class B::AV) representing \s-1END\s0 blocks.
.IP "comppadlist" 4
.IX Item "comppadlist"
Returns the \s-1AV\s0 object (i.e. in class B::AV) of the global comppadlist.
.IP "regex_padav" 4
.IX Item "regex_padav"
Only when perl was compiled with ithreads.
.IP "main_cv" 4
.IX Item "main_cv"
Return the (faked) \s-1CV\s0 corresponding to the main part of the Perl
program.
.SS "Functions for Examining the Symbol Table"
.IX Subsection "Functions for Examining the Symbol Table"
.IP "walksymtable(\s-1SYMREF, METHOD, RECURSE, PREFIX\s0)" 4
.IX Item "walksymtable(SYMREF, METHOD, RECURSE, PREFIX)"
Walk the symbol table starting at \s-1SYMREF\s0 and call \s-1METHOD\s0 on each
symbol (a B::GV object) visited.  When the walk reaches package
symbols (such as \*(L"Foo::\*(R") it invokes \s-1RECURSE,\s0 passing in the symbol
name, and only recurses into the package if that sub returns true.
.Sp
\&\s-1PREFIX\s0 is the name of the \s-1SYMREF\s0 you're walking.
.Sp
For example:
.Sp
.Vb 4
\&  # Walk CGI\*(Aqs symbol table calling print_subs on each symbol.
\&  # Recurse only into CGI::Util::
\&  walksymtable(\e%CGI::, \*(Aqprint_subs\*(Aq,
\&               sub { $_[0] eq \*(AqCGI::Util::\*(Aq }, \*(AqCGI::\*(Aq);
.Ve
.Sp
\&\fIprint_subs()\fR is a B::GV method you have declared.  Also see \*(L"B::GV
Methods\*(R", below.
.ie n .SS "Functions Returning ""B::OP"" objects or for walking op trees"
.el .SS "Functions Returning \f(CWB::OP\fP objects or for walking op trees"
.IX Subsection "Functions Returning B::OP objects or for walking op trees"
For descriptions of the class hierarchy of these objects and the
methods that can be called on them, see below, \*(L"\s-1OVERVIEW OF
CLASSES\*(R"\s0 and \*(L"OP-RELATED \s-1CLASSES\*(R"\s0.
.IP "main_root" 4
.IX Item "main_root"
Returns the root op (i.e. an object in the appropriate B::OP\-derived
class) of the main part of the Perl program.
.IP "main_start" 4
.IX Item "main_start"
Returns the starting op of the main part of the Perl program.
.IP "walkoptree(\s-1OP, METHOD\s0)" 4
.IX Item "walkoptree(OP, METHOD)"
Does a tree-walk of the syntax tree based at \s-1OP\s0 and calls \s-1METHOD\s0 on
each op it visits.  Each node is visited before its children.  If
\&\f(CW\*(C`walkoptree_debug\*(C'\fR (see below) has been called to turn debugging on then
the method \f(CW\*(C`walkoptree_debug\*(C'\fR is called on each op before \s-1METHOD\s0 is
called.
.IP "walkoptree_debug(\s-1DEBUG\s0)" 4
.IX Item "walkoptree_debug(DEBUG)"
Returns the current debugging flag for \f(CW\*(C`walkoptree\*(C'\fR.  If the optional
\&\s-1DEBUG\s0 argument is non-zero, it sets the debugging flag to that.  See
the description of \f(CW\*(C`walkoptree\*(C'\fR above for what the debugging flag
does.
.SS "Miscellaneous Utility Functions"
.IX Subsection "Miscellaneous Utility Functions"
.IP "ppname(\s-1OPNUM\s0)" 4
.IX Item "ppname(OPNUM)"
Return the \s-1PP\s0 function name (e.g. \*(L"pp_add\*(R") of op number \s-1OPNUM.\s0
.IP "hash(\s-1STR\s0)" 4
.IX Item "hash(STR)"
Returns a string in the form \*(L"0x...\*(R" representing the value of the
internal hash function used by perl on string \s-1STR.\s0
.IP "cast_I32(I)" 4
.IX Item "cast_I32(I)"
Casts I to the internal I32 type used by that perl.
.IP "minus_c" 4
.IX Item "minus_c"
Does the equivalent of the \f(CW\*(C`\-c\*(C'\fR command-line option.  Obviously, this
is only useful in a \s-1BEGIN\s0 block or else the flag is set too late.
.IP "cstring(\s-1STR\s0)" 4
.IX Item "cstring(STR)"
Returns a double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a string in C source code.
.IP "perlstring(\s-1STR\s0)" 4
.IX Item "perlstring(STR)"
Returns a double-quote-surrounded escaped version of \s-1STR\s0 which can
be used as a string in Perl source code.
.IP "class(\s-1OBJ\s0)" 4
.IX Item "class(OBJ)"
Returns the class of an object without the part of the classname
preceding the first \f(CW"::"\fR.  This is used to turn \f(CW"B::UNOP"\fR into
\&\f(CW"UNOP"\fR for example.
.IP "threadsv_names" 4
.IX Item "threadsv_names"
In a perl compiled for threads, this returns a list of the special
per-thread threadsv variables.
.SS "Exported utility variables"
.IX Subsection "Exported utility variables"
.ie n .IP "@optype" 4
.el .IP "\f(CW@optype\fR" 4
.IX Item "@optype"
.Vb 1
\&  my $op_type = $optype[$op_type_num];
.Ve
.Sp
A simple mapping of the op type number to its type (like '\s-1COP\s0' or '\s-1BINOP\s0').
.ie n .IP "@specialsv_name" 4
.el .IP "\f(CW@specialsv_name\fR" 4
.IX Item "@specialsv_name"
.Vb 1
\&  my $sv_name = $specialsv_name[$sv_index];
.Ve
.Sp
Certain \s-1SV\s0 types are considered 'special'.  They're represented by
B::SPECIAL and are referred to by a number from the specialsv_list.
This array maps that number back to the name of the \s-1SV \s0(like 'Nullsv'
or '&PL_sv_undef').
.SH "OVERVIEW OF CLASSES"
.IX Header "OVERVIEW OF CLASSES"
The C structures used by Perl's internals to hold \s-1SV\s0 and \s-1OP\s0
information (\s-1PVIV, AV, HV, ..., OP, SVOP, UNOP, ...\s0) are modelled on a
class hierarchy and the \f(CW\*(C`B\*(C'\fR module gives access to them via a true
object hierarchy.  Structure fields which point to other objects
(whether types of \s-1SV\s0 or types of \s-1OP\s0) are represented by the \f(CW\*(C`B\*(C'\fR
module as Perl objects of the appropriate class.
.PP
The bulk of the \f(CW\*(C`B\*(C'\fR module is the methods for accessing fields of
these structures.
.PP
Note that all access is read-only.  You cannot modify the internals by
using this module.  Also, note that the B::OP and B::SV objects created
by this module are only valid for as long as the underlying objects
exist; their creation doesn't increase the reference counts of the
underlying objects.  Trying to access the fields of a freed object will
give incomprehensible results, or worse.
.SS "SV-RELATED \s-1CLASSES\s0"
.IX Subsection "SV-RELATED CLASSES"
B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and
earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO.  These classes
correspond in the obvious way to the underlying C structures of similar names.
The inheritance hierarchy mimics the underlying C \*(L"inheritance\*(R".  For the
5.10.x branch, (\fIie\fR 5.10.0, 5.10.1 \fIetc\fR) this is:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |            |
\&              B::PV        B::IV        B::NV        B::RV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&                   +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |     |     |
\&                 B::AV B::GV B::HV B::CV B::IO
\&                         |           |
\&                         |           |
\&                      B::PVLV      B::FM
.Ve
.PP
For 5.9.0 and earlier, \s-1PVLV\s0 is a direct subclass of \s-1PVMG,\s0 and \s-1BM\s0 is still
present as a distinct type, so the base of this diagram is
.PP
.Vb 10
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&            +\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&            |      |     |     |     |     |     |
\&         B::PVLV B::BM B::AV B::GV B::HV B::CV B::IO
\&                                           |
\&                                           |
\&                                         B::FM
.Ve
.PP
For 5.11.0 and later, B::RV is abolished, and IVs can be used to store
references, and a new type B::REGEXP is introduced, giving this structure:
.PP
.Vb 10
\&                           B::SV
\&                             |
\&                +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+
\&                |            |            |
\&              B::PV        B::IV        B::NV
\&                  \e         /           /
\&                   \e       /           /
\&                    B::PVIV           /
\&                         \e           /
\&                          \e         /
\&                           \e       /
\&                            B::PVNV
\&                               |
\&                               |
\&                            B::PVMG
\&                               |
\&           +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-+\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&           |       |       |       |       |       |
\&         B::AV   B::GV   B::HV   B::CV   B::IO B::REGEXP
\&                   |               |
\&                   |               |
\&                B::PVLV          B::FM
.Ve
.PP
Access methods correspond to the underlying C macros for field access,
usually with the leading \*(L"class indication\*(R" prefix removed (Sv, Av,
Hv, ...).  The leading prefix is only left in cases where its removal
would cause a clash in method name.  For example, \f(CW\*(C`GvREFCNT\*(C'\fR stays
as-is since its abbreviation would clash with the \*(L"superclass\*(R" method
\&\f(CW\*(C`REFCNT\*(C'\fR (corresponding to the C function \f(CW\*(C`SvREFCNT\*(C'\fR).
.SS "B::SV Methods"
.IX Subsection "B::SV Methods"
.IP "\s-1REFCNT\s0" 4
.IX Item "REFCNT"
.PD 0
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "object_2svref" 4
.IX Item "object_2svref"
.PD
Returns a reference to the regular scalar corresponding to this
B::SV object.  In other words, this method is the inverse operation
to the \fIsvref_2object()\fR subroutine.  This scalar and other data it points
at should be considered read-only: modifying them is neither safe nor
guaranteed to have a sensible effect.
.SS "B::IV Methods"
.IX Subsection "B::IV Methods"
.IP "\s-1IV\s0" 4
.IX Item "IV"
Returns the value of the \s-1IV, \s0\fIinterpreted as
a signed integer\fR.  This will be misleading
if \f(CW\*(C`FLAGS & SVf_IVisUV\*(C'\fR.  Perhaps you want the
\&\f(CW\*(C`int_value\*(C'\fR method instead?
.IP "\s-1IVX\s0" 4
.IX Item "IVX"
.PD 0
.IP "\s-1UVX\s0" 4
.IX Item "UVX"
.IP "int_value" 4
.IX Item "int_value"
.PD
This method returns the value of the \s-1IV\s0 as an integer.
It differs from \f(CW\*(C`IV\*(C'\fR in that it returns the correct
value regardless of whether it's stored signed or
unsigned.
.IP "needs64bits" 4
.IX Item "needs64bits"
.PD 0
.IP "packiv" 4
.IX Item "packiv"
.PD
.SS "B::NV Methods"
.IX Subsection "B::NV Methods"
.IP "\s-1NV\s0" 4
.IX Item "NV"
.PD 0
.IP "\s-1NVX\s0" 4
.IX Item "NVX"
.PD
.SS "B::RV Methods"
.IX Subsection "B::RV Methods"
.IP "\s-1RV\s0" 4
.IX Item "RV"
.SS "B::PV Methods"
.IX Subsection "B::PV Methods"
.PD 0
.IP "\s-1PV\s0" 4
.IX Item "PV"
.PD
This method is the one you usually want.  It constructs a
string using the length and offset information in the struct:
for ordinary scalars it will return the string that you'd see
from Perl, even if it contains null characters.
.IP "\s-1RV\s0" 4
.IX Item "RV"
Same as B::RV::RV, except that it will \fIdie()\fR if the \s-1PV\s0 isn't
a reference.
.IP "\s-1PVX\s0" 4
.IX Item "PVX"
This method is less often useful.  It assumes that the string
stored in the struct is null-terminated, and disregards the
length information.
.Sp
It is the appropriate method to use if you need to get the name
of a lexical variable from a padname array.  Lexical variable names
are always stored with a null terminator, and the length field
(\s-1CUR\s0) is overloaded for other purposes and can't be relied on here.
.IP "\s-1CUR\s0" 4
.IX Item "CUR"
This method returns the internal length field, which consists of the number
of internal bytes, not necessarily the number of logical characters.
.IP "\s-1LEN\s0" 4
.IX Item "LEN"
This method returns the number of bytes allocated (via malloc) for storing
the string.  This is 0 if the scalar does not \*(L"own\*(R" the string.
.SS "B::PVMG Methods"
.IX Subsection "B::PVMG Methods"
.IP "\s-1MAGIC\s0" 4
.IX Item "MAGIC"
.PD 0
.IP "SvSTASH" 4
.IX Item "SvSTASH"
.PD
.SS "B::MAGIC Methods"
.IX Subsection "B::MAGIC Methods"
.IP "\s-1MOREMAGIC\s0" 4
.IX Item "MOREMAGIC"
.PD 0
.IP "precomp" 4
.IX Item "precomp"
.PD
Only valid on r\-magic, returns the string that generated the regexp.
.IP "\s-1PRIVATE\s0" 4
.IX Item "PRIVATE"
.PD 0
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.IP "\s-1OBJ\s0" 4
.IX Item "OBJ"
.PD
Will \fIdie()\fR if called on r\-magic.
.IP "\s-1PTR\s0" 4
.IX Item "PTR"
.PD 0
.IP "\s-1REGEX\s0" 4
.IX Item "REGEX"
.PD
Only valid on r\-magic, returns the integer value of the \s-1REGEX\s0 stored
in the \s-1MAGIC.\s0
.SS "B::PVLV Methods"
.IX Subsection "B::PVLV Methods"
.IP "\s-1TARGOFF\s0" 4
.IX Item "TARGOFF"
.PD 0
.IP "\s-1TARGLEN\s0" 4
.IX Item "TARGLEN"
.IP "\s-1TYPE\s0" 4
.IX Item "TYPE"
.IP "\s-1TARG\s0" 4
.IX Item "TARG"
.PD
.SS "B::BM Methods"
.IX Subsection "B::BM Methods"
.IP "\s-1USEFUL\s0" 4
.IX Item "USEFUL"
.PD 0
.IP "\s-1PREVIOUS\s0" 4
.IX Item "PREVIOUS"
.IP "\s-1RARE\s0" 4
.IX Item "RARE"
.IP "\s-1TABLE\s0" 4
.IX Item "TABLE"
.PD
.SS "B::GV Methods"
.IX Subsection "B::GV Methods"
.IP "is_empty" 4
.IX Item "is_empty"
This method returns \s-1TRUE\s0 if the \s-1GP\s0 field of the \s-1GV\s0 is \s-1NULL.\s0
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.PD 0
.IP "\s-1SAFENAME\s0" 4
.IX Item "SAFENAME"
.PD
This method returns the name of the glob, but if the first
character of the name is a control character, then it converts
it to ^X first, so that *^G would return \*(L"^G\*(R" rather than \*(L"\ecG\*(R".
.Sp
It's useful if you want to print out the name of a variable.
If you restrict yourself to globs which exist at compile-time
then the result ought to be unambiguous, because code like
\&\f(CW\*(C`${"^G"} = 1\*(C'\fR is compiled as two ops \- a constant string and
a dereference (rv2gv) \- so that the glob is created at runtime.
.Sp
If you're working with globs at runtime, and need to disambiguate
*^G from *{\*(L"^G\*(R"}, then you should use the raw \s-1NAME\s0 method.
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1SV\s0" 4
.IX Item "SV"
.IP "\s-1IO\s0" 4
.IX Item "IO"
.IP "\s-1FORM\s0" 4
.IX Item "FORM"
.IP "\s-1AV\s0" 4
.IX Item "AV"
.IP "\s-1HV\s0" 4
.IX Item "HV"
.IP "\s-1EGV\s0" 4
.IX Item "EGV"
.IP "\s-1CV\s0" 4
.IX Item "CV"
.IP "\s-1CVGEN\s0" 4
.IX Item "CVGEN"
.IP "\s-1LINE\s0" 4
.IX Item "LINE"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1FILEGV\s0" 4
.IX Item "FILEGV"
.IP "GvREFCNT" 4
.IX Item "GvREFCNT"
.IP "\s-1FLAGS\s0" 4
.IX Item "FLAGS"
.PD
.SS "B::IO Methods"
.IX Subsection "B::IO Methods"
B::IO objects derive from \s-1IO\s0 objects and you will get more information from
the \s-1IO\s0 object itself.
.PP
For example:
.PP
.Vb 3
\&  $gvio = B::svref_2object(\e*main::stdin)\->IO;
\&  $IO = $gvio\->object_2svref();
\&  $fd = $IO\->fileno();
.Ve
.IP "\s-1LINES\s0" 4
.IX Item "LINES"
.PD 0
.IP "\s-1PAGE\s0" 4
.IX Item "PAGE"
.IP "\s-1PAGE_LEN\s0" 4
.IX Item "PAGE_LEN"
.IP "\s-1LINES_LEFT\s0" 4
.IX Item "LINES_LEFT"
.IP "\s-1TOP_NAME\s0" 4
.IX Item "TOP_NAME"
.IP "\s-1TOP_GV\s0" 4
.IX Item "TOP_GV"
.IP "\s-1FMT_NAME\s0" 4
.IX Item "FMT_NAME"
.IP "\s-1FMT_GV\s0" 4
.IX Item "FMT_GV"
.IP "\s-1BOTTOM_NAME\s0" 4
.IX Item "BOTTOM_NAME"
.IP "\s-1BOTTOM_GV\s0" 4
.IX Item "BOTTOM_GV"
.IP "\s-1SUBPROCESS\s0" 4
.IX Item "SUBPROCESS"
.IP "IoTYPE" 4
.IX Item "IoTYPE"
.PD
A character symbolizing the type of \s-1IO\s0 Handle.
.Sp
.Vb 12
\&  \-     STDIN/OUT
\&  I     STDIN/OUT/ERR
\&  <     read\-only
\&  >     write\-only
\&  a     append
\&  +     read and write
\&  s     socket
\&  |     pipe
\&  I     IMPLICIT
\&  #     NUMERIC
\&  space closed handle
\&  \e0    closed internal handle
.Ve
.IP "IoFLAGS" 4
.IX Item "IoFLAGS"
.PD 0
.IP "IsSTD" 4
.IX Item "IsSTD"
.PD
Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true
if the IoIFP of the object is equal to the handle whose name was
passed as argument; i.e., \f(CW$io\fR\->IsSTD('stderr') is true if
IoIFP($io) == \fIPerlIO_stderr()\fR.
.SS "B::AV Methods"
.IX Subsection "B::AV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "ARRAYelt" 4
.IX Item "ARRAYelt"
.PD
Like \f(CW\*(C`ARRAY\*(C'\fR, but takes an index as an argument to get only one element,
rather than a list of all of them.
.IP "\s-1OFF\s0" 4
.IX Item "OFF"
This method is deprecated if running under Perl 5.8, and is no longer present
if running under Perl 5.9
.IP "AvFLAGS" 4
.IX Item "AvFLAGS"
This method returns the \s-1AV\s0 specific
flags.  In Perl 5.9 these are now stored
in with the main \s-1SV\s0 flags, so this method is no longer present.
.SS "B::CV Methods"
.IX Subsection "B::CV Methods"
.IP "\s-1STASH\s0" 4
.IX Item "STASH"
.PD 0
.IP "\s-1START\s0" 4
.IX Item "START"
.IP "\s-1ROOT\s0" 4
.IX Item "ROOT"
.IP "\s-1GV\s0" 4
.IX Item "GV"
.IP "\s-1FILE\s0" 4
.IX Item "FILE"
.IP "\s-1DEPTH\s0" 4
.IX Item "DEPTH"
.IP "\s-1PADLIST\s0" 4
.IX Item "PADLIST"
.IP "\s-1OUTSIDE\s0" 4
.IX Item "OUTSIDE"
.IP "\s-1OUTSIDE_SEQ\s0" 4
.IX Item "OUTSIDE_SEQ"
.IP "\s-1XSUB\s0" 4
.IX Item "XSUB"
.IP "\s-1XSUBANY\s0" 4
.IX Item "XSUBANY"
.PD
For constant subroutines, returns the constant \s-1SV\s0 returned by the subroutine.
.IP "CvFLAGS" 4
.IX Item "CvFLAGS"
.PD 0
.IP "const_sv" 4
.IX Item "const_sv"
.IP "\s-1NAME_HEK\s0" 4
.IX Item "NAME_HEK"
.PD
Returns the name of a lexical sub, otherwise \f(CW\*(C`undef\*(C'\fR.
.SS "B::HV Methods"
.IX Subsection "B::HV Methods"
.IP "\s-1FILL\s0" 4
.IX Item "FILL"
.PD 0
.IP "\s-1MAX\s0" 4
.IX Item "MAX"
.IP "\s-1KEYS\s0" 4
.IX Item "KEYS"
.IP "\s-1RITER\s0" 4
.IX Item "RITER"
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
.IP "\s-1PMROOT\s0" 4
.IX Item "PMROOT"
.PD
This method is not present if running under Perl 5.9, as the \s-1PMROOT\s0
information is no longer stored directly in the hash.
.SS "OP-RELATED \s-1CLASSES\s0"
.IX Subsection "OP-RELATED CLASSES"
\&\f(CW\*(C`B::OP\*(C'\fR, \f(CW\*(C`B::UNOP\*(C'\fR, \f(CW\*(C`B::BINOP\*(C'\fR, \f(CW\*(C`B::LOGOP\*(C'\fR, \f(CW\*(C`B::LISTOP\*(C'\fR, \f(CW\*(C`B::PMOP\*(C'\fR,
\&\f(CW\*(C`B::SVOP\*(C'\fR, \f(CW\*(C`B::PADOP\*(C'\fR, \f(CW\*(C`B::PVOP\*(C'\fR, \f(CW\*(C`B::LOOP\*(C'\fR, \f(CW\*(C`B::COP\*(C'\fR.
.PP
These classes correspond in the obvious way to the underlying C
structures of similar names.  The inheritance hierarchy mimics the
underlying C \*(L"inheritance\*(R":
.PP
.Vb 10
\&                                 B::OP
\&                                   |
\&                   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+
\&                   |               |        |        |       |
\&                B::UNOP          B::SVOP B::PADOP  B::COP  B::PVOP
\&                 ,\*(Aq  \`\-.
\&                /       \`\-\-.
\&           B::BINOP     B::LOGOP
\&               |
\&               |
\&           B::LISTOP
\&             ,\*(Aq \`.
\&            /     \e
\&        B::LOOP B::PMOP
.Ve
.PP
Access methods correspond to the underlying C structre field names,
with the leading \*(L"class indication\*(R" prefix (\f(CW"op_"\fR) removed.
.SS "B::OP Methods"
.IX Subsection "B::OP Methods"
These methods get the values of similarly named fields within the \s-1OP\s0
data structure.  See top of \f(CW\*(C`op.h\*(C'\fR for more info.
.IP "next" 4
.IX Item "next"
.PD 0
.IP "sibling" 4
.IX Item "sibling"
.IP "name" 4
.IX Item "name"
.PD
This returns the op name as a string (e.g. \*(L"add\*(R", \*(L"rv2av\*(R").
.IP "ppaddr" 4
.IX Item "ppaddr"
This returns the function name as a string (e.g. \*(L"PL_ppaddr[\s-1OP_ADD\s0]\*(R",
\&\*(L"PL_ppaddr[\s-1OP_RV2AV\s0]\*(R").
.IP "desc" 4
.IX Item "desc"
This returns the op description from the global C PL_op_desc array
(e.g. \*(L"addition\*(R" \*(L"array deref\*(R").
.IP "targ" 4
.IX Item "targ"
.PD 0
.IP "type" 4
.IX Item "type"
.IP "opt" 4
.IX Item "opt"
.IP "flags" 4
.IX Item "flags"
.IP "private" 4
.IX Item "private"
.IP "spare" 4
.IX Item "spare"
.PD
.SS "B::UNOP \s-1METHOD\s0"
.IX Subsection "B::UNOP METHOD"
.IP "first" 4
.IX Item "first"
.SS "B::BINOP \s-1METHOD\s0"
.IX Subsection "B::BINOP METHOD"
.PD 0
.IP "last" 4
.IX Item "last"
.PD
.SS "B::LOGOP \s-1METHOD\s0"
.IX Subsection "B::LOGOP METHOD"
.IP "other" 4
.IX Item "other"
.SS "B::LISTOP \s-1METHOD\s0"
.IX Subsection "B::LISTOP METHOD"
.PD 0
.IP "children" 4
.IX Item "children"
.PD
.SS "B::PMOP Methods"
.IX Subsection "B::PMOP Methods"
.IP "pmreplroot" 4
.IX Item "pmreplroot"
.PD 0
.IP "pmreplstart" 4
.IX Item "pmreplstart"
.IP "pmnext" 4
.IX Item "pmnext"
.PD
Only up to Perl 5.9.4
.IP "pmflags" 4
.IX Item "pmflags"
.PD 0
.IP "extflags" 4
.IX Item "extflags"
.PD
Since Perl 5.9.5
.IP "precomp" 4
.IX Item "precomp"
.PD 0
.IP "pmoffset" 4
.IX Item "pmoffset"
.PD
Only when perl was compiled with ithreads.
.IP "code_list" 4
.IX Item "code_list"
Since perl 5.17.1
.SS "B::SVOP \s-1METHOD\s0"
.IX Subsection "B::SVOP METHOD"
.IP "sv" 4
.IX Item "sv"
.PD 0
.IP "gv" 4
.IX Item "gv"
.PD
.SS "B::PADOP \s-1METHOD\s0"
.IX Subsection "B::PADOP METHOD"
.IP "padix" 4
.IX Item "padix"
.SS "B::PVOP \s-1METHOD\s0"
.IX Subsection "B::PVOP METHOD"
.PD 0
.IP "pv" 4
.IX Item "pv"
.PD
.SS "B::LOOP Methods"
.IX Subsection "B::LOOP Methods"
.IP "redoop" 4
.IX Item "redoop"
.PD 0
.IP "nextop" 4
.IX Item "nextop"
.IP "lastop" 4
.IX Item "lastop"
.PD
.SS "B::COP Methods"
.IX Subsection "B::COP Methods"
.IP "label" 4
.IX Item "label"
.PD 0
.IP "stash" 4
.IX Item "stash"
.IP "stashpv" 4
.IX Item "stashpv"
.IP "stashoff (threaded only)" 4
.IX Item "stashoff (threaded only)"
.IP "file" 4
.IX Item "file"
.IP "cop_seq" 4
.IX Item "cop_seq"
.IP "arybase" 4
.IX Item "arybase"
.IP "line" 4
.IX Item "line"
.IP "warnings" 4
.IX Item "warnings"
.IP "io" 4
.IX Item "io"
.IP "hints" 4
.IX Item "hints"
.IP "hints_hash" 4
.IX Item "hints_hash"
.PD
.ie n .SS "$B::overlay"
.el .SS "\f(CW$B::overlay\fP"
.IX Subsection "$B::overlay"
Although the optree is read-only, there is an overlay facility that allows
you to override what values the various B::*OP methods return for a
particular op. \f(CW$B::overlay\fR should be set to reference a two-deep hash:
indexed by \s-1OP\s0 address, then method name. Whenever a an op method is
called, the value in the hash is returned if it exists. This facility is
used by B::Deparse to \*(L"undo\*(R" some optimisations. For example:
.PP
.Vb 11
\&    local $B::overlay = {};
\&    ...
\&    if ($op\->name eq "foo") {
\&        $B::overlay\->{$$op} = {
\&                name => \*(Aqbar\*(Aq,
\&                next => $op\->next\->next,
\&        };
\&    }
\&    ...
\&    $op\->name # returns "bar"
\&    $op\->next # returns the next op but one
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Concise.3pm                               0100644 0001750 0001750 00000102340 12566207451 023152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Concise 3pm"
.TH B::Concise 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Concise \- Walk Perl syntax tree, printing concise info about ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    perl \-MO=Concise[,OPTIONS] foo.pl
\&
\&    use B::Concise qw(set_style add_callback);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This compiler backend prints the internal OPs of a Perl program's syntax
tree in one of several space-efficient text formats suitable for debugging
the inner workings of perl or other compiler backends. It can print OPs in
the order they appear in the \s-1OP\s0 tree, in the order they will execute, or
in a text approximation to their tree structure, and the format of the
information displayed is customizable. Its function is similar to that of
perl's \fB\-Dx\fR debugging flag or the \fBB::Terse\fR module, but it is more
sophisticated and flexible.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Here's two outputs (or 'renderings'), using the \-exec and \-basic
(i.e. default) formatting conventions on the same code snippet.
.PP
.Vb 9
\&    % perl \-MO=Concise,\-exec \-e \*(Aq$a = $b + 42\*(Aq
\&    1  <0> enter
\&    2  <;> nextstate(main 1 \-e:1) v
\&    3  <#> gvsv[*b] s
\&    4  <$> const[IV 42] s
\& *  5  <2> add[t3] sK/2
\&    6  <#> gvsv[*a] s
\&    7  <2> sassign vKS/2
\&    8  <@> leave[1 ref] vKP/REFC
.Ve
.PP
In this \-exec rendering, each opcode is executed in the order shown.
The add opcode, marked with '*', is discussed in more detail.
.PP
The 1st column is the op's sequence number, starting at 1, and is
displayed in base 36 by default.  Here they're purely linear; the
sequences are very helpful when looking at code with loops and
branches.
.PP
The symbol between angle brackets indicates the op's type, for
example; <2> is a \s-1BINOP,\s0 <@> a \s-1LISTOP,\s0 and <#> is a \s-1PADOP,\s0 which is
used in threaded perls. (see \*(L"\s-1OP\s0 class abbreviations\*(R").
.PP
The opname, as in \fB'add[t1]'\fR, may be followed by op-specific
information in parentheses or brackets (ex \fB'[t1]'\fR).
.PP
The op-flags (ex \fB'sK/2'\fR) are described in (\*(L"\s-1OP\s0 flags
abbreviations\*(R").
.PP
.Vb 11
\&    % perl \-MO=Concise \-e \*(Aq$a = $b + 42\*(Aq
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    1     <0> enter \->2
\&    2     <;> nextstate(main 1 \-e:1) v \->3
\&    7     <2> sassign vKS/2 \->8
\& *  5        <2> add[t1] sK/2 \->6
\&    \-           <1> ex\-rv2sv sK/1 \->4
\&    3              <$> gvsv(*b) s \->4
\&    4           <$> const(IV 42) s \->5
\&    \-        <1> ex\-rv2sv sKRM*/1 \->7
\&    6           <$> gvsv(*a) s \->7
.Ve
.PP
The default rendering is top-down, so they're not in execution order.
This form reflects the way the stack is used to parse and evaluate
expressions; the add operates on the two terms below it in the tree.
.PP
Nullops appear as \f(CW\*(C`ex\-opname\*(C'\fR, where \fIopname\fR is an op that has been
optimized away by perl.  They're displayed with a sequence-number of
\&'\-', because they are not executed (they don't appear in previous
example), they're printed here because they reflect the parse.
.PP
The arrow points to the sequence number of the next op; they're not
displayed in \-exec mode, for obvious reasons.
.PP
Note that because this rendering was done on a non-threaded perl, the
PADOPs in the previous examples are now SVOPs, and some (but not all)
of the square brackets have been replaced by round ones.  This is a
subtle feature to provide some visual distinction between renderings
on threaded and un-threaded perls.
.SH "OPTIONS"
.IX Header "OPTIONS"
Arguments that don't start with a hyphen are taken to be the names of
subroutines or formats to render; if no
such functions are specified, the main
body of the program (outside any subroutines, and not including use'd
or require'd files) is rendered.  Passing \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR,
\&\f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR will cause all of the corresponding
special blocks to be printed.  Arguments must follow options.
.PP
Options affect how things are rendered (ie printed).  They're presented
here by their visual effect, 1st being strongest.  They're grouped
according to how they interrelate; within each group the options are
mutually exclusive (unless otherwise stated).
.SS "Options for Opcode Ordering"
.IX Subsection "Options for Opcode Ordering"
These options control the 'vertical display' of opcodes.  The display
\&'order' is also called 'mode' elsewhere in this document.
.IP "\fB\-basic\fR" 4
.IX Item "-basic"
Print OPs in the order they appear in the \s-1OP\s0 tree (a preorder
traversal, starting at the root). The indentation of each \s-1OP\s0 shows its
level in the tree, and the '\->' at the end of the line indicates the
next opcode in execution order.  This mode is the default, so the flag
is included simply for completeness.
.IP "\fB\-exec\fR" 4
.IX Item "-exec"
Print OPs in the order they would normally execute (for the majority
of constructs this is a postorder traversal of the tree, ending at the
root). In most cases the \s-1OP\s0 that usually follows a given \s-1OP\s0 will
appear directly below it; alternate paths are shown by indentation. In
cases like loops when control jumps out of a linear path, a 'goto'
line is generated.
.IP "\fB\-tree\fR" 4
.IX Item "-tree"
Print OPs in a text approximation of a tree, with the root of the tree
at the left and 'left\-to\-right' order of children transformed into
\&'top\-to\-bottom'. Because this mode grows both to the right and down,
it isn't suitable for large programs (unless you have a very wide
terminal).
.SS "Options for Line-Style"
.IX Subsection "Options for Line-Style"
These options select the line-style (or just style) used to render
each opcode, and dictates what info is actually printed into each line.
.IP "\fB\-concise\fR" 4
.IX Item "-concise"
Use the author's favorite set of formatting conventions. This is the
default, of course.
.IP "\fB\-terse\fR" 4
.IX Item "-terse"
Use formatting conventions that emulate the output of \fBB::Terse\fR. The
basic mode is almost indistinguishable from the real \fBB::Terse\fR, and the
exec mode looks very similar, but is in a more logical order and lacks
curly brackets. \fBB::Terse\fR doesn't have a tree mode, so the tree mode
is only vaguely reminiscent of \fBB::Terse\fR.
.IP "\fB\-linenoise\fR" 4
.IX Item "-linenoise"
Use formatting conventions in which the name of each \s-1OP,\s0 rather than being
written out in full, is represented by a one\- or two-character abbreviation.
This is mainly a joke.
.IP "\fB\-debug\fR" 4
.IX Item "-debug"
Use formatting conventions reminiscent of \fBB::Debug\fR; these aren't
very concise at all.
.IP "\fB\-env\fR" 4
.IX Item "-env"
Use formatting conventions read from the environment variables
\&\f(CW\*(C`B_CONCISE_FORMAT\*(C'\fR, \f(CW\*(C`B_CONCISE_GOTO_FORMAT\*(C'\fR, and \f(CW\*(C`B_CONCISE_TREE_FORMAT\*(C'\fR.
.SS "Options for tree-specific formatting"
.IX Subsection "Options for tree-specific formatting"
.IP "\fB\-compact\fR" 4
.IX Item "-compact"
Use a tree format in which the minimum amount of space is used for the
lines connecting nodes (one character in most cases). This squeezes out
a few precious columns of screen real estate.
.IP "\fB\-loose\fR" 4
.IX Item "-loose"
Use a tree format that uses longer edges to separate \s-1OP\s0 nodes. This format
tends to look better than the compact one, especially in \s-1ASCII,\s0 and is
the default.
.IP "\fB\-vt\fR" 4
.IX Item "-vt"
Use tree connecting characters drawn from the \s-1VT100\s0 line-drawing set.
This looks better if your terminal supports it.
.IP "\fB\-ascii\fR" 4
.IX Item "-ascii"
Draw the tree with standard \s-1ASCII\s0 characters like \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`|\*(C'\fR. These don't
look as clean as the \s-1VT100\s0 characters, but they'll work with almost any
terminal (or the horizontal scrolling mode of \fIless\fR\|(1)) and are suitable
for text documentation or email. This is the default.
.PP
These are pairwise exclusive, i.e. compact or loose, vt or ascii.
.SS "Options controlling sequence numbering"
.IX Subsection "Options controlling sequence numbering"
.IP "\fB\-base\fR\fIn\fR" 4
.IX Item "-basen"
Print \s-1OP\s0 sequence numbers in base \fIn\fR. If \fIn\fR is greater than 10, the
digit for 11 will be 'a', and so on. If \fIn\fR is greater than 36, the digit
for 37 will be 'A', and so on until 62. Values greater than 62 are not
currently supported. The default is 36.
.IP "\fB\-bigendian\fR" 4
.IX Item "-bigendian"
Print sequence numbers with the most significant digit first. This is the
usual convention for Arabic numerals, and the default.
.IP "\fB\-littleendian\fR" 4
.IX Item "-littleendian"
Print sequence numbers with the least significant digit first.  This is
obviously mutually exclusive with bigendian.
.SS "Other options"
.IX Subsection "Other options"
.IP "\fB\-src\fR" 4
.IX Item "-src"
With this option, the rendering of each statement (starting with the
nextstate \s-1OP\s0) will be preceded by the 1st line of source code that
generates it.  For example:
.Sp
.Vb 10
\&    1  <0> enter
\&    # 1: my $i;
\&    2  <;> nextstate(main 1 junk.pl:1) v:{
\&    3  <0> padsv[$i:1,10] vM/LVINTRO
\&    # 3: for $i (0..9) {
\&    4  <;> nextstate(main 3 junk.pl:3) v:{
\&    5  <0> pushmark s
\&    6  <$> const[IV 0] s
\&    7  <$> const[IV 9] s
\&    8  <{> enteriter(next\->j last\->m redo\->9)[$i:1,10] lKS
\&    k  <0> iter s
\&    l  <|> and(other\->9) vK/1
\&    # 4:     print "line ";
\&    9      <;> nextstate(main 2 junk.pl:4) v
\&    a      <0> pushmark s
\&    b      <$> const[PV "line "] s
\&    c      <@> print vK
\&    # 5:     print "$i\en";
\&    ...
.Ve
.ie n .IP "\fB\-stash=""somepackage""\fR" 4
.el .IP "\fB\-stash=``somepackage''\fR" 4
.IX Item "-stash=somepackage"
With this, \*(L"somepackage\*(R" will be required, then the stash is
inspected, and each function is rendered.
.PP
The following options are pairwise exclusive.
.IP "\fB\-main\fR" 4
.IX Item "-main"
Include the main program in the output, even if subroutines were also
specified.  This rendering is normally suppressed when a subroutine
name or reference is given.
.IP "\fB\-nomain\fR" 4
.IX Item "-nomain"
This restores the default behavior after you've changed it with '\-main'
(it's not normally needed).  If no subroutine name/ref is given, main is
rendered, regardless of this flag.
.IP "\fB\-nobanner\fR" 4
.IX Item "-nobanner"
Renderings usually include a banner line identifying the function name
or stringified subref.  This suppresses the printing of the banner.
.Sp
\&\s-1TBC:\s0 Remove the stringified coderef; while it provides a 'cookie' for
each function rendered, the cookies used should be 1,2,3.. not a
random hex-address.  It also complicates string comparison of two
different trees.
.IP "\fB\-banner\fR" 4
.IX Item "-banner"
restores default banner behavior.
.IP "\fB\-banneris\fR => subref" 4
.IX Item "-banneris => subref"
\&\s-1TBC:\s0 a hookpoint (and an option to set it) for a user-supplied
function to produce a banner appropriate for users needs.  It's not
ideal, because the rendering-state variables, which are a natural
candidate for use in concise.t, are unavailable to the user.
.SS "Option Stickiness"
.IX Subsection "Option Stickiness"
If you invoke Concise more than once in a program, you should know that
the options are 'sticky'.  This means that the options you provide in
the first call will be remembered for the 2nd call, unless you
re-specify or change them.
.SH "ABBREVIATIONS"
.IX Header "ABBREVIATIONS"
The concise style uses symbols to convey maximum info with minimal
clutter (like hex addresses).  With just a little practice, you can
start to see the flowers, not just the branches, in the trees.
.SS "\s-1OP\s0 class abbreviations"
.IX Subsection "OP class abbreviations"
These symbols appear before the op-name, and indicate the
B:: namespace that represents the ops in your Perl code.
.PP
.Vb 11
\&    0      OP (aka BASEOP)  An OP with no children
\&    1      UNOP             An OP with one child
\&    2      BINOP            An OP with two children
\&    |      LOGOP            A control branch OP
\&    @      LISTOP           An OP that could have lots of children
\&    /      PMOP             An OP with a regular expression
\&    $      SVOP             An OP with an SV
\&    "      PVOP             An OP with a string
\&    {      LOOP             An OP that holds pointers for a loop
\&    ;      COP              An OP that marks the start of a statement
\&    #      PADOP            An OP with a GV on the pad
.Ve
.SS "\s-1OP\s0 flags abbreviations"
.IX Subsection "OP flags abbreviations"
\&\s-1OP\s0 flags are either public or private.  The public flags alter the
behavior of each opcode in consistent ways, and are represented by 0
or more single characters.
.PP
.Vb 12
\&    v      OPf_WANT_VOID    Want nothing (void context)
\&    s      OPf_WANT_SCALAR  Want single value (scalar context)
\&    l      OPf_WANT_LIST    Want list of any length (list context)
\&                            Want is unknown
\&    K      OPf_KIDS         There is a firstborn child.
\&    P      OPf_PARENS       This operator was parenthesized.
\&                             (Or block needs explicit scope entry.)
\&    R      OPf_REF          Certified reference.
\&                             (Return container, not containee).
\&    M      OPf_MOD          Will modify (lvalue).
\&    S      OPf_STACKED      Some arg is arriving on the stack.
\&    *      OPf_SPECIAL      Do something weird for this op (see op.h)
.Ve
.PP
Private flags, if any are set for an opcode, are displayed after a '/'
.PP
.Vb 2
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    7     <2> sassign vKS/2 \->8
.Ve
.PP
They're opcode specific, and occur less often than the public ones, so
they're represented by short mnemonics instead of single-chars; see
\&\fIop.h\fR for gory details, or try this quick 2\-liner:
.PP
.Vb 2
\&  $> perl \-MB::Concise \-de 1
\&  DB<1> |x \e%B::Concise::priv
.Ve
.SH "FORMATTING SPECIFICATIONS"
.IX Header "FORMATTING SPECIFICATIONS"
For each line-style ('concise', 'terse', 'linenoise', etc.) there are
3 format-specs which control how OPs are rendered.
.PP
The first is the 'default' format, which is used in both basic and exec
modes to print all opcodes.  The 2nd, goto-format, is used in exec
mode when branches are encountered.  They're not real opcodes, and are
inserted to look like a closing curly brace.  The tree-format is tree
specific.
.PP
When a line is rendered, the correct format-spec is copied and scanned
for the following items; data is substituted in, and other
manipulations like basic indenting are done, for each opcode rendered.
.PP
There are 3 kinds of items that may be populated; special patterns,
#vars, and literal text, which is copied verbatim.  (Yes, it's a set
of s///g steps.)
.SS "Special Patterns"
.IX Subsection "Special Patterns"
These items are the primitives used to perform indenting, and to
select text from amongst alternatives.
.IP "\fB(x(\fR\fIexec_text\fR\fB;\fR\fIbasic_text\fR\fB)x)\fR" 4
.IX Item "(x(exec_text;basic_text)x)"
Generates \fIexec_text\fR in exec mode, or \fIbasic_text\fR in basic mode.
.IP "\fB(*(\fR\fItext\fR\fB)*)\fR" 4
.IX Item "(*(text)*)"
Generates one copy of \fItext\fR for each indentation level.
.IP "\fB(*(\fR\fItext1\fR\fB;\fR\fItext2\fR\fB)*)\fR" 4
.IX Item "(*(text1;text2)*)"
Generates one fewer copies of \fItext1\fR than the indentation level, followed
by one copy of \fItext2\fR if the indentation level is more than 0.
.IP "\fB(?(\fR\fItext1\fR\fB#\fR\fIvar\fR\fIText2\fR\fB)?)\fR" 4
.IX Item "(?(text1#varText2)?)"
If the value of \fIvar\fR is true (not empty or zero), generates the
value of \fIvar\fR surrounded by \fItext1\fR and \fIText2\fR, otherwise
nothing.
.IP "\fB~\fR" 4
.IX Item "~"
Any number of tildes and surrounding whitespace will be collapsed to
a single space.
.SS "# Variables"
.IX Subsection "# Variables"
These #vars represent opcode properties that you may want as part of
your rendering.  The '#' is intended as a private sigil; a #var's
value is interpolated into the style-line, much like \*(L"read \f(CW$this\fR\*(R".
.PP
These vars take 3 forms:
.IP "\fB#\fR\fIvar\fR" 4
.IX Item "#var"
A property named 'var' is assumed to exist for the opcodes, and is
interpolated into the rendering.
.IP "\fB#\fR\fIvar\fR\fIN\fR" 4
.IX Item "#varN"
Generates the value of \fIvar\fR, left justified to fill \fIN\fR spaces.
Note that this means while you can have properties 'foo' and 'foo2',
you cannot render 'foo2', but you could with 'foo2a'.  You would be
wise not to rely on this behavior going forward ;\-)
.IP "\fB#\fR\fIVar\fR" 4
.IX Item "#Var"
This ucfirst form of #var generates a tag-value form of itself for
display; it converts '#Var' into a 'Var => #var' style, which is then
handled as described above.  (Imp-note: #Vars cannot be used for
conditional-fills, because the => #var transform is done after the check
for #Var's value).
.PP
The following variables are 'defined' by B::Concise; when they are
used in a style, their respective values are plugged into the
rendering of each opcode.
.PP
Only some of these are used by the standard styles, the others are
provided for you to delve into optree mechanics, should you wish to
add a new style (see \*(L"add_style\*(R" below) that uses them.  You can
also add new ones using \*(L"add_callback\*(R".
.IP "\fB#addr\fR" 4
.IX Item "#addr"
The address of the \s-1OP,\s0 in hexadecimal.
.IP "\fB#arg\fR" 4
.IX Item "#arg"
The OP-specific information of the \s-1OP \s0(such as the \s-1SV\s0 for an \s-1SVOP,\s0 the
non-local exit pointers for a \s-1LOOP,\s0 etc.) enclosed in parentheses.
.IP "\fB#class\fR" 4
.IX Item "#class"
The B\-determined class of the \s-1OP,\s0 in all caps.
.IP "\fB#classsym\fR" 4
.IX Item "#classsym"
A single symbol abbreviating the class of the \s-1OP.\s0
.IP "\fB#coplabel\fR" 4
.IX Item "#coplabel"
The label of the statement or block the \s-1OP\s0 is the start of, if any.
.IP "\fB#exname\fR" 4
.IX Item "#exname"
The name of the \s-1OP,\s0 or 'ex\-foo' if the \s-1OP\s0 is a null that used to be a foo.
.IP "\fB#extarg\fR" 4
.IX Item "#extarg"
The target of the \s-1OP,\s0 or nothing for a nulled \s-1OP.\s0
.IP "\fB#firstaddr\fR" 4
.IX Item "#firstaddr"
The address of the \s-1OP\s0's first child, in hexadecimal.
.IP "\fB#flags\fR" 4
.IX Item "#flags"
The \s-1OP\s0's flags, abbreviated as a series of symbols.
.IP "\fB#flagval\fR" 4
.IX Item "#flagval"
The numeric value of the \s-1OP\s0's flags.
.IP "\fB#hints\fR" 4
.IX Item "#hints"
The \s-1COP\s0's hint flags, rendered with abbreviated names if possible. An empty
string if this is not a \s-1COP.\s0 Here are the symbols used:
.Sp
.Vb 10
\&    $ strict refs
\&    & strict subs
\&    * strict vars
\&   x$ explicit use/no strict refs
\&   x& explicit use/no strict subs
\&   x* explicit use/no strict vars
\&    i integers
\&    l locale
\&    b bytes
\&    { block scope
\&    % localise %^H
\&    < open in
\&    > open out
\&    I overload int
\&    F overload float
\&    B overload binary
\&    S overload string
\&    R overload re
\&    T taint
\&    E eval
\&    X filetest access
\&    U utf\-8
.Ve
.IP "\fB#hintsval\fR" 4
.IX Item "#hintsval"
The numeric value of the \s-1COP\s0's hint flags, or an empty string if this is not
a \s-1COP.\s0
.IP "\fB#hyphseq\fR" 4
.IX Item "#hyphseq"
The sequence number of the \s-1OP,\s0 or a hyphen if it doesn't have one.
.IP "\fB#label\fR" 4
.IX Item "#label"
\&'\s-1NEXT\s0', '\s-1LAST\s0', or '\s-1REDO\s0' if the \s-1OP\s0 is a target of one of those in exec
mode, or empty otherwise.
.IP "\fB#lastaddr\fR" 4
.IX Item "#lastaddr"
The address of the \s-1OP\s0's last child, in hexadecimal.
.IP "\fB#name\fR" 4
.IX Item "#name"
The \s-1OP\s0's name.
.IP "\fB#NAME\fR" 4
.IX Item "#NAME"
The \s-1OP\s0's name, in all caps.
.IP "\fB#next\fR" 4
.IX Item "#next"
The sequence number of the \s-1OP\s0's next \s-1OP.\s0
.IP "\fB#nextaddr\fR" 4
.IX Item "#nextaddr"
The address of the \s-1OP\s0's next \s-1OP,\s0 in hexadecimal.
.IP "\fB#noise\fR" 4
.IX Item "#noise"
A one\- or two-character abbreviation for the \s-1OP\s0's name.
.IP "\fB#private\fR" 4
.IX Item "#private"
The \s-1OP\s0's private flags, rendered with abbreviated names if possible.
.IP "\fB#privval\fR" 4
.IX Item "#privval"
The numeric value of the \s-1OP\s0's private flags.
.IP "\fB#seq\fR" 4
.IX Item "#seq"
The sequence number of the \s-1OP.\s0 Note that this is a sequence number
generated by B::Concise.
.IP "\fB#seqnum\fR" 4
.IX Item "#seqnum"
5.8.x and earlier only. 5.9 and later do not provide this.
.Sp
The real sequence number of the \s-1OP,\s0 as a regular number and not adjusted
to be relative to the start of the real program. (This will generally be
a fairly large number because all of \fBB::Concise\fR is compiled before
your program is).
.IP "\fB#opt\fR" 4
.IX Item "#opt"
Whether or not the op has been optimised by the peephole optimiser.
.Sp
Only available in 5.9 and later.
.IP "\fB#sibaddr\fR" 4
.IX Item "#sibaddr"
The address of the \s-1OP\s0's next youngest sibling, in hexadecimal.
.IP "\fB#svaddr\fR" 4
.IX Item "#svaddr"
The address of the \s-1OP\s0's \s-1SV,\s0 if it has an \s-1SV,\s0 in hexadecimal.
.IP "\fB#svclass\fR" 4
.IX Item "#svclass"
The class of the \s-1OP\s0's \s-1SV,\s0 if it has one, in all caps (e.g., '\s-1IV\s0').
.IP "\fB#svval\fR" 4
.IX Item "#svval"
The value of the \s-1OP\s0's \s-1SV,\s0 if it has one, in a short human-readable format.
.IP "\fB#targ\fR" 4
.IX Item "#targ"
The numeric value of the \s-1OP\s0's targ.
.IP "\fB#targarg\fR" 4
.IX Item "#targarg"
The name of the variable the \s-1OP\s0's targ refers to, if any, otherwise the
letter t followed by the \s-1OP\s0's targ in decimal.
.IP "\fB#targarglife\fR" 4
.IX Item "#targarglife"
Same as \fB#targarg\fR, but followed by the \s-1COP\s0 sequence numbers that delimit
the variable's lifetime (or 'end' for a variable in an open scope) for a
variable.
.IP "\fB#typenum\fR" 4
.IX Item "#typenum"
The numeric value of the \s-1OP\s0's type, in decimal.
.SH "One-Liner Command tips"
.IX Header "One-Liner Command tips"
.IP "perl \-MO=Concise,bar foo.pl" 4
.IX Item "perl -MO=Concise,bar foo.pl"
Renders only \fIbar()\fR from foo.pl.  To see main, drop the ',bar'.  To see
both, add ',\-main'
.IP "perl \-MDigest::MD5=md5 \-MO=Concise,md5 \-e1" 4
.IX Item "perl -MDigest::MD5=md5 -MO=Concise,md5 -e1"
Identifies md5 as an \s-1XS\s0 function.  The export is needed so that \s-1BC\s0 can
find it in main.
.IP "perl \-MPOSIX \-MO=Concise,_POSIX_ARG_MAX \-e1" 4
.IX Item "perl -MPOSIX -MO=Concise,_POSIX_ARG_MAX -e1"
Identifies _POSIX_ARG_MAX as a constant sub, optimized to an \s-1IV.\s0
Although \s-1POSIX\s0 isn't entirely consistent across platforms, this is
likely to be present in virtually all of them.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'print _POSIX_SAVED_IDS'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'print _POSIX_SAVED_IDS'"
This renders a print statement, which includes a call to the function.
It's identical to rendering a file with a use call and that single
statement, except for the filename which appears in the nextstate ops.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'sub a{_POSIX_SAVED_IDS}'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'sub a{_POSIX_SAVED_IDS}'"
This is \fBvery\fR similar to previous, only the first two ops differ.  This
subroutine rendering is more representative, insofar as a single main
program will have many subs.
.ie n .IP "perl \-MB::Concise \-e 'B::Concise::compile(""\-exec"",""\-src"", \e%B::Concise::)\->()'" 4
.el .IP "perl \-MB::Concise \-e 'B::Concise::compile(``\-exec'',``\-src'', \e%B::Concise::)\->()'" 4
.IX Item "perl -MB::Concise -e 'B::Concise::compile(-exec,-src, %B::Concise::)->()'"
This renders all functions in the B::Concise package with the source
lines.  It eschews the O framework so that the stashref can be passed
directly to \fIB::Concise::compile()\fR.  See \-stash option for a more
convenient way to render a package.
.SH "Using B::Concise outside of the O framework"
.IX Header "Using B::Concise outside of the O framework"
The common (and original) usage of B::Concise was for command-line
renderings of simple code, as given in \s-1EXAMPLE. \s0 But you can also use
\&\fBB::Concise\fR from your code, and call \fIcompile()\fR directly, and
repeatedly.  By doing so, you can avoid the compile-time only
operation of O.pm, and even use the debugger to step through
\&\fIB::Concise::compile()\fR itself.
.PP
Once you're doing this, you may alter Concise output by adding new
rendering styles, and by optionally adding callback routines which
populate new variables, if such were referenced from those (just
added) styles.
.SS "Example: Altering Concise Renderings"
.IX Subsection "Example: Altering Concise Renderings"
.Vb 9
\&    use B::Concise qw(set_style add_callback);
\&    add_style($yourStyleName => $defaultfmt, $gotofmt, $treefmt);
\&    add_callback
\&      ( sub {
\&            my ($h, $op, $format, $level, $stylename) = @_;
\&            $h\->{variable} = some_func($op);
\&        });
\&    $walker = B::Concise::compile(@options,@subnames,@subrefs);
\&    $walker\->();
.Ve
.SS "\fIset_style()\fP"
.IX Subsection "set_style()"
\&\fBset_style\fR accepts 3 arguments, and updates the three format-specs
comprising a line-style (basic-exec, goto, tree).  It has one minor
drawback though; it doesn't register the style under a new name.  This
can become an issue if you render more than once and switch styles.
Thus you may prefer to use \fIadd_style()\fR and/or \fIset_style_standard()\fR
instead.
.SS "set_style_standard($name)"
.IX Subsection "set_style_standard($name)"
This restores one of the standard line-styles: \f(CW\*(C`terse\*(C'\fR, \f(CW\*(C`concise\*(C'\fR,
\&\f(CW\*(C`linenoise\*(C'\fR, \f(CW\*(C`debug\*(C'\fR, \f(CW\*(C`env\*(C'\fR, into effect.  It also accepts style
names previously defined with \fIadd_style()\fR.
.SS "add_style ()"
.IX Subsection "add_style ()"
This subroutine accepts a new style name and three style arguments as
above, and creates, registers, and selects the newly named style.  It is
an error to re-add a style; call \fIset_style_standard()\fR to switch between
several styles.
.SS "add_callback ()"
.IX Subsection "add_callback ()"
If your newly minted styles refer to any new #variables, you'll need
to define a callback subroutine that will populate (or modify) those
variables.  They are then available for use in the style you've
chosen.
.PP
The callbacks are called for each opcode visited by Concise, in the
same order as they are added.  Each subroutine is passed five
parameters.
.PP
.Vb 6
\&  1. A hashref, containing the variable names and values which are
\&     populated into the report\-line for the op
\&  2. the op, as a B<B::OP> object
\&  3. a reference to the format string
\&  4. the formatting (indent) level
\&  5. the selected stylename
.Ve
.PP
To define your own variables, simply add them to the hash, or change
existing values if you need to.  The level and format are passed in as
references to scalars, but it is unlikely that they will need to be
changed or even used.
.SS "Running \fIB::Concise::compile()\fP"
.IX Subsection "Running B::Concise::compile()"
\&\fBcompile\fR accepts options as described above in \*(L"\s-1OPTIONS\*(R"\s0, and
arguments, which are either coderefs, or subroutine names.
.PP
It constructs and returns a \f(CW$treewalker\fR coderef, which when invoked,
traverses, or walks, and renders the optrees of the given arguments to
\&\s-1STDOUT. \s0 You can reuse this, and can change the rendering style used
each time; thereafter the coderef renders in the new style.
.PP
\&\fBwalk_output\fR lets you change the print destination from \s-1STDOUT\s0 to
another open filehandle, or into a string passed as a ref (unless
you've built perl with \-Uuseperlio).
.PP
.Vb 7
\&    my $walker = B::Concise::compile(\*(Aq\-terse\*(Aq,\*(AqaFuncName\*(Aq, \e&aSubRef);  # 1
\&    walk_output(\emy $buf);
\&    $walker\->();                        # 1 renders \-terse
\&    set_style_standard(\*(Aqconcise\*(Aq);      # 2
\&    $walker\->();                        # 2 renders \-concise
\&    $walker\->(@new);                    # 3 renders whatever
\&    print "3 different renderings: terse, concise, and @new: $buf\en";
.Ve
.PP
When \f(CW$walker\fR is called, it traverses the subroutines supplied when it
was created, and renders them using the current style.  You can change
the style afterwards in several different ways:
.PP
.Vb 3
\&  1. call C<compile>, altering style or mode/order
\&  2. call C<set_style_standard>
\&  3. call $walker, passing @new options
.Ve
.PP
Passing new options to the \f(CW$walker\fR is the easiest way to change
amongst any pre-defined styles (the ones you add are automatically
recognized as options), and is the only way to alter rendering order
without calling compile again.  Note however that rendering state is
still shared amongst multiple \f(CW$walker\fR objects, so they must still be
used in a coordinated manner.
.SS "\fIB::Concise::reset_sequence()\fP"
.IX Subsection "B::Concise::reset_sequence()"
This function (not exported) lets you reset the sequence numbers (note
that they're numbered arbitrarily, their goal being to be human
readable).  Its purpose is mostly to support testing, i.e. to compare
the concise output from two identical anonymous subroutines (but
different instances).  Without the reset, B::Concise, seeing that
they're separate optrees, generates different sequence numbers in
the output.
.SS "Errors"
.IX Subsection "Errors"
Errors in rendering (non-existent function-name, non-existent coderef)
are written to the \s-1STDOUT,\s0 or wherever you've set it via
\&\fIwalk_output()\fR.
.PP
Errors using the various *style* calls, and bad args to \fIwalk_output()\fR,
result in \fIdie()\fR.  Use an eval if you wish to catch these errors and
continue processing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant, <smcc@CSUA.Berkeley.EDU>.
                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Concise5.16.3pm                           0100644 0001750 0001750 00000102004 12566207430 023456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Concise 3pm"
.TH B::Concise 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Concise \- Walk Perl syntax tree, printing concise info about ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    perl \-MO=Concise[,OPTIONS] foo.pl
\&
\&    use B::Concise qw(set_style add_callback);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This compiler backend prints the internal OPs of a Perl program's syntax
tree in one of several space-efficient text formats suitable for debugging
the inner workings of perl or other compiler backends. It can print OPs in
the order they appear in the \s-1OP\s0 tree, in the order they will execute, or
in a text approximation to their tree structure, and the format of the
information displayed is customizable. Its function is similar to that of
perl's \fB\-Dx\fR debugging flag or the \fBB::Terse\fR module, but it is more
sophisticated and flexible.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Here's two outputs (or 'renderings'), using the \-exec and \-basic
(i.e. default) formatting conventions on the same code snippet.
.PP
.Vb 9
\&    % perl \-MO=Concise,\-exec \-e \*(Aq$a = $b + 42\*(Aq
\&    1  <0> enter
\&    2  <;> nextstate(main 1 \-e:1) v
\&    3  <#> gvsv[*b] s
\&    4  <$> const[IV 42] s
\& *  5  <2> add[t3] sK/2
\&    6  <#> gvsv[*a] s
\&    7  <2> sassign vKS/2
\&    8  <@> leave[1 ref] vKP/REFC
.Ve
.PP
In this \-exec rendering, each opcode is executed in the order shown.
The add opcode, marked with '*', is discussed in more detail.
.PP
The 1st column is the op's sequence number, starting at 1, and is
displayed in base 36 by default.  Here they're purely linear; the
sequences are very helpful when looking at code with loops and
branches.
.PP
The symbol between angle brackets indicates the op's type, for
example; <2> is a \s-1BINOP\s0, <@> a \s-1LISTOP\s0, and <#> is a \s-1PADOP\s0, which is
used in threaded perls. (see \*(L"\s-1OP\s0 class abbreviations\*(R").
.PP
The opname, as in \fB'add[t1]'\fR, may be followed by op-specific
information in parentheses or brackets (ex \fB'[t1]'\fR).
.PP
The op-flags (ex \fB'sK/2'\fR) are described in (\*(L"\s-1OP\s0 flags
abbreviations\*(R").
.PP
.Vb 11
\&    % perl \-MO=Concise \-e \*(Aq$a = $b + 42\*(Aq
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    1     <0> enter \->2
\&    2     <;> nextstate(main 1 \-e:1) v \->3
\&    7     <2> sassign vKS/2 \->8
\& *  5        <2> add[t1] sK/2 \->6
\&    \-           <1> ex\-rv2sv sK/1 \->4
\&    3              <$> gvsv(*b) s \->4
\&    4           <$> const(IV 42) s \->5
\&    \-        <1> ex\-rv2sv sKRM*/1 \->7
\&    6           <$> gvsv(*a) s \->7
.Ve
.PP
The default rendering is top-down, so they're not in execution order.
This form reflects the way the stack is used to parse and evaluate
expressions; the add operates on the two terms below it in the tree.
.PP
Nullops appear as \f(CW\*(C`ex\-opname\*(C'\fR, where \fIopname\fR is an op that has been
optimized away by perl.  They're displayed with a sequence-number of
\&'\-', because they are not executed (they don't appear in previous
example), they're printed here because they reflect the parse.
.PP
The arrow points to the sequence number of the next op; they're not
displayed in \-exec mode, for obvious reasons.
.PP
Note that because this rendering was done on a non-threaded perl, the
PADOPs in the previous examples are now SVOPs, and some (but not all)
of the square brackets have been replaced by round ones.  This is a
subtle feature to provide some visual distinction between renderings
on threaded and un-threaded perls.
.SH "OPTIONS"
.IX Header "OPTIONS"
Arguments that don't start with a hyphen are taken to be the names of
subroutines to render; if no such functions are specified, the main
body of the program (outside any subroutines, and not including use'd
or require'd files) is rendered.  Passing \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR,
\&\f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR will cause all of the corresponding
special blocks to be printed.  Arguments must follow options.
.PP
Options affect how things are rendered (ie printed).  They're presented
here by their visual effect, 1st being strongest.  They're grouped
according to how they interrelate; within each group the options are
mutually exclusive (unless otherwise stated).
.SS "Options for Opcode Ordering"
.IX Subsection "Options for Opcode Ordering"
These options control the 'vertical display' of opcodes.  The display
\&'order' is also called 'mode' elsewhere in this document.
.IP "\fB\-basic\fR" 4
.IX Item "-basic"
Print OPs in the order they appear in the \s-1OP\s0 tree (a preorder
traversal, starting at the root). The indentation of each \s-1OP\s0 shows its
level in the tree, and the '\->' at the end of the line indicates the
next opcode in execution order.  This mode is the default, so the flag
is included simply for completeness.
.IP "\fB\-exec\fR" 4
.IX Item "-exec"
Print OPs in the order they would normally execute (for the majority
of constructs this is a postorder traversal of the tree, ending at the
root). In most cases the \s-1OP\s0 that usually follows a given \s-1OP\s0 will
appear directly below it; alternate paths are shown by indentation. In
cases like loops when control jumps out of a linear path, a 'goto'
line is generated.
.IP "\fB\-tree\fR" 4
.IX Item "-tree"
Print OPs in a text approximation of a tree, with the root of the tree
at the left and 'left\-to\-right' order of children transformed into
\&'top\-to\-bottom'. Because this mode grows both to the right and down,
it isn't suitable for large programs (unless you have a very wide
terminal).
.SS "Options for Line-Style"
.IX Subsection "Options for Line-Style"
These options select the line-style (or just style) used to render
each opcode, and dictates what info is actually printed into each line.
.IP "\fB\-concise\fR" 4
.IX Item "-concise"
Use the author's favorite set of formatting conventions. This is the
default, of course.
.IP "\fB\-terse\fR" 4
.IX Item "-terse"
Use formatting conventions that emulate the output of \fBB::Terse\fR. The
basic mode is almost indistinguishable from the real \fBB::Terse\fR, and the
exec mode looks very similar, but is in a more logical order and lacks
curly brackets. \fBB::Terse\fR doesn't have a tree mode, so the tree mode
is only vaguely reminiscent of \fBB::Terse\fR.
.IP "\fB\-linenoise\fR" 4
.IX Item "-linenoise"
Use formatting conventions in which the name of each \s-1OP\s0, rather than being
written out in full, is represented by a one\- or two-character abbreviation.
This is mainly a joke.
.IP "\fB\-debug\fR" 4
.IX Item "-debug"
Use formatting conventions reminiscent of \fBB::Debug\fR; these aren't
very concise at all.
.IP "\fB\-env\fR" 4
.IX Item "-env"
Use formatting conventions read from the environment variables
\&\f(CW\*(C`B_CONCISE_FORMAT\*(C'\fR, \f(CW\*(C`B_CONCISE_GOTO_FORMAT\*(C'\fR, and \f(CW\*(C`B_CONCISE_TREE_FORMAT\*(C'\fR.
.SS "Options for tree-specific formatting"
.IX Subsection "Options for tree-specific formatting"
.IP "\fB\-compact\fR" 4
.IX Item "-compact"
Use a tree format in which the minimum amount of space is used for the
lines connecting nodes (one character in most cases). This squeezes out
a few precious columns of screen real estate.
.IP "\fB\-loose\fR" 4
.IX Item "-loose"
Use a tree format that uses longer edges to separate \s-1OP\s0 nodes. This format
tends to look better than the compact one, especially in \s-1ASCII\s0, and is
the default.
.IP "\fB\-vt\fR" 4
.IX Item "-vt"
Use tree connecting characters drawn from the \s-1VT100\s0 line-drawing set.
This looks better if your terminal supports it.
.IP "\fB\-ascii\fR" 4
.IX Item "-ascii"
Draw the tree with standard \s-1ASCII\s0 characters like \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`|\*(C'\fR. These don't
look as clean as the \s-1VT100\s0 characters, but they'll work with almost any
terminal (or the horizontal scrolling mode of \fIless\fR\|(1)) and are suitable
for text documentation or email. This is the default.
.PP
These are pairwise exclusive, i.e. compact or loose, vt or ascii.
.SS "Options controlling sequence numbering"
.IX Subsection "Options controlling sequence numbering"
.IP "\fB\-base\fR\fIn\fR" 4
.IX Item "-basen"
Print \s-1OP\s0 sequence numbers in base \fIn\fR. If \fIn\fR is greater than 10, the
digit for 11 will be 'a', and so on. If \fIn\fR is greater than 36, the digit
for 37 will be 'A', and so on until 62. Values greater than 62 are not
currently supported. The default is 36.
.IP "\fB\-bigendian\fR" 4
.IX Item "-bigendian"
Print sequence numbers with the most significant digit first. This is the
usual convention for Arabic numerals, and the default.
.IP "\fB\-littleendian\fR" 4
.IX Item "-littleendian"
Print sequence numbers with the least significant digit first.  This is
obviously mutually exclusive with bigendian.
.SS "Other options"
.IX Subsection "Other options"
.IP "\fB\-src\fR" 4
.IX Item "-src"
With this option, the rendering of each statement (starting with the
nextstate \s-1OP\s0) will be preceded by the 1st line of source code that
generates it.  For example:
.Sp
.Vb 10
\&    1  <0> enter
\&    # 1: my $i;
\&    2  <;> nextstate(main 1 junk.pl:1) v:{
\&    3  <0> padsv[$i:1,10] vM/LVINTRO
\&    # 3: for $i (0..9) {
\&    4  <;> nextstate(main 3 junk.pl:3) v:{
\&    5  <0> pushmark s
\&    6  <$> const[IV 0] s
\&    7  <$> const[IV 9] s
\&    8  <{> enteriter(next\->j last\->m redo\->9)[$i:1,10] lKS
\&    k  <0> iter s
\&    l  <|> and(other\->9) vK/1
\&    # 4:     print "line ";
\&    9      <;> nextstate(main 2 junk.pl:4) v
\&    a      <0> pushmark s
\&    b      <$> const[PV "line "] s
\&    c      <@> print vK
\&    # 5:     print "$i\en";
\&    ...
.Ve
.ie n .IP "\fB\-stash=""somepackage""\fR" 4
.el .IP "\fB\-stash=``somepackage''\fR" 4
.IX Item "-stash=somepackage"
With this, \*(L"somepackage\*(R" will be required, then the stash is
inspected, and each function is rendered.
.PP
The following options are pairwise exclusive.
.IP "\fB\-main\fR" 4
.IX Item "-main"
Include the main program in the output, even if subroutines were also
specified.  This rendering is normally suppressed when a subroutine
name or reference is given.
.IP "\fB\-nomain\fR" 4
.IX Item "-nomain"
This restores the default behavior after you've changed it with '\-main'
(it's not normally needed).  If no subroutine name/ref is given, main is
rendered, regardless of this flag.
.IP "\fB\-nobanner\fR" 4
.IX Item "-nobanner"
Renderings usually include a banner line identifying the function name
or stringified subref.  This suppresses the printing of the banner.
.Sp
\&\s-1TBC:\s0 Remove the stringified coderef; while it provides a 'cookie' for
each function rendered, the cookies used should be 1,2,3.. not a
random hex-address.  It also complicates string comparison of two
different trees.
.IP "\fB\-banner\fR" 4
.IX Item "-banner"
restores default banner behavior.
.IP "\fB\-banneris\fR => subref" 4
.IX Item "-banneris => subref"
\&\s-1TBC:\s0 a hookpoint (and an option to set it) for a user-supplied
function to produce a banner appropriate for users needs.  It's not
ideal, because the rendering-state variables, which are a natural
candidate for use in concise.t, are unavailable to the user.
.SS "Option Stickiness"
.IX Subsection "Option Stickiness"
If you invoke Concise more than once in a program, you should know that
the options are 'sticky'.  This means that the options you provide in
the first call will be remembered for the 2nd call, unless you
re-specify or change them.
.SH "ABBREVIATIONS"
.IX Header "ABBREVIATIONS"
The concise style uses symbols to convey maximum info with minimal
clutter (like hex addresses).  With just a little practice, you can
start to see the flowers, not just the branches, in the trees.
.SS "\s-1OP\s0 class abbreviations"
.IX Subsection "OP class abbreviations"
These symbols appear before the op-name, and indicate the
B:: namespace that represents the ops in your Perl code.
.PP
.Vb 11
\&    0      OP (aka BASEOP)  An OP with no children
\&    1      UNOP             An OP with one child
\&    2      BINOP            An OP with two children
\&    |      LOGOP            A control branch OP
\&    @      LISTOP           An OP that could have lots of children
\&    /      PMOP             An OP with a regular expression
\&    $      SVOP             An OP with an SV
\&    "      PVOP             An OP with a string
\&    {      LOOP             An OP that holds pointers for a loop
\&    ;      COP              An OP that marks the start of a statement
\&    #      PADOP            An OP with a GV on the pad
.Ve
.SS "\s-1OP\s0 flags abbreviations"
.IX Subsection "OP flags abbreviations"
\&\s-1OP\s0 flags are either public or private.  The public flags alter the
behavior of each opcode in consistent ways, and are represented by 0
or more single characters.
.PP
.Vb 12
\&    v      OPf_WANT_VOID    Want nothing (void context)
\&    s      OPf_WANT_SCALAR  Want single value (scalar context)
\&    l      OPf_WANT_LIST    Want list of any length (list context)
\&                            Want is unknown
\&    K      OPf_KIDS         There is a firstborn child.
\&    P      OPf_PARENS       This operator was parenthesized.
\&                             (Or block needs explicit scope entry.)
\&    R      OPf_REF          Certified reference.
\&                             (Return container, not containee).
\&    M      OPf_MOD          Will modify (lvalue).
\&    S      OPf_STACKED      Some arg is arriving on the stack.
\&    *      OPf_SPECIAL      Do something weird for this op (see op.h)
.Ve
.PP
Private flags, if any are set for an opcode, are displayed after a '/'
.PP
.Vb 2
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    7     <2> sassign vKS/2 \->8
.Ve
.PP
They're opcode specific, and occur less often than the public ones, so
they're represented by short mnemonics instead of single-chars; see
\&\fIop.h\fR for gory details, or try this quick 2\-liner:
.PP
.Vb 2
\&  $> perl \-MB::Concise \-de 1
\&  DB<1> |x \e%B::Concise::priv
.Ve
.SH "FORMATTING SPECIFICATIONS"
.IX Header "FORMATTING SPECIFICATIONS"
For each line-style ('concise', 'terse', 'linenoise', etc.) there are
3 format-specs which control how OPs are rendered.
.PP
The first is the 'default' format, which is used in both basic and exec
modes to print all opcodes.  The 2nd, goto-format, is used in exec
mode when branches are encountered.  They're not real opcodes, and are
inserted to look like a closing curly brace.  The tree-format is tree
specific.
.PP
When a line is rendered, the correct format-spec is copied and scanned
for the following items; data is substituted in, and other
manipulations like basic indenting are done, for each opcode rendered.
.PP
There are 3 kinds of items that may be populated; special patterns,
#vars, and literal text, which is copied verbatim.  (Yes, it's a set
of s///g steps.)
.SS "Special Patterns"
.IX Subsection "Special Patterns"
These items are the primitives used to perform indenting, and to
select text from amongst alternatives.
.IP "\fB(x(\fR\fIexec_text\fR\fB;\fR\fIbasic_text\fR\fB)x)\fR" 4
.IX Item "(x(exec_text;basic_text)x)"
Generates \fIexec_text\fR in exec mode, or \fIbasic_text\fR in basic mode.
.IP "\fB(*(\fR\fItext\fR\fB)*)\fR" 4
.IX Item "(*(text)*)"
Generates one copy of \fItext\fR for each indentation level.
.IP "\fB(*(\fR\fItext1\fR\fB;\fR\fItext2\fR\fB)*)\fR" 4
.IX Item "(*(text1;text2)*)"
Generates one fewer copies of \fItext1\fR than the indentation level, followed
by one copy of \fItext2\fR if the indentation level is more than 0.
.IP "\fB(?(\fR\fItext1\fR\fB#\fR\fIvar\fR\fIText2\fR\fB)?)\fR" 4
.IX Item "(?(text1#varText2)?)"
If the value of \fIvar\fR is true (not empty or zero), generates the
value of \fIvar\fR surrounded by \fItext1\fR and \fIText2\fR, otherwise
nothing.
.IP "\fB~\fR" 4
.IX Item "~"
Any number of tildes and surrounding whitespace will be collapsed to
a single space.
.SS "# Variables"
.IX Subsection "# Variables"
These #vars represent opcode properties that you may want as part of
your rendering.  The '#' is intended as a private sigil; a #var's
value is interpolated into the style-line, much like \*(L"read \f(CW$this\fR\*(R".
.PP
These vars take 3 forms:
.IP "\fB#\fR\fIvar\fR" 4
.IX Item "#var"
A property named 'var' is assumed to exist for the opcodes, and is
interpolated into the rendering.
.IP "\fB#\fR\fIvar\fR\fIN\fR" 4
.IX Item "#varN"
Generates the value of \fIvar\fR, left justified to fill \fIN\fR spaces.
Note that this means while you can have properties 'foo' and 'foo2',
you cannot render 'foo2', but you could with 'foo2a'.  You would be
wise not to rely on this behavior going forward ;\-)
.IP "\fB#\fR\fIVar\fR" 4
.IX Item "#Var"
This ucfirst form of #var generates a tag-value form of itself for
display; it converts '#Var' into a 'Var => #var' style, which is then
handled as described above.  (Imp-note: #Vars cannot be used for
conditional-fills, because the => #var transform is done after the check
for #Var's value).
.PP
The following variables are 'defined' by B::Concise; when they are
used in a style, their respective values are plugged into the
rendering of each opcode.
.PP
Only some of these are used by the standard styles, the others are
provided for you to delve into optree mechanics, should you wish to
add a new style (see \*(L"add_style\*(R" below) that uses them.  You can
also add new ones using \*(L"add_callback\*(R".
.IP "\fB#addr\fR" 4
.IX Item "#addr"
The address of the \s-1OP\s0, in hexadecimal.
.IP "\fB#arg\fR" 4
.IX Item "#arg"
The OP-specific information of the \s-1OP\s0 (such as the \s-1SV\s0 for an \s-1SVOP\s0, the
non-local exit pointers for a \s-1LOOP\s0, etc.) enclosed in parentheses.
.IP "\fB#class\fR" 4
.IX Item "#class"
The B\-determined class of the \s-1OP\s0, in all caps.
.IP "\fB#classsym\fR" 4
.IX Item "#classsym"
A single symbol abbreviating the class of the \s-1OP\s0.
.IP "\fB#coplabel\fR" 4
.IX Item "#coplabel"
The label of the statement or block the \s-1OP\s0 is the start of, if any.
.IP "\fB#exname\fR" 4
.IX Item "#exname"
The name of the \s-1OP\s0, or 'ex\-foo' if the \s-1OP\s0 is a null that used to be a foo.
.IP "\fB#extarg\fR" 4
.IX Item "#extarg"
The target of the \s-1OP\s0, or nothing for a nulled \s-1OP\s0.
.IP "\fB#firstaddr\fR" 4
.IX Item "#firstaddr"
The address of the \s-1OP\s0's first child, in hexadecimal.
.IP "\fB#flags\fR" 4
.IX Item "#flags"
The \s-1OP\s0's flags, abbreviated as a series of symbols.
.IP "\fB#flagval\fR" 4
.IX Item "#flagval"
The numeric value of the \s-1OP\s0's flags.
.IP "\fB#hints\fR" 4
.IX Item "#hints"
The \s-1COP\s0's hint flags, rendered with abbreviated names if possible. An empty
string if this is not a \s-1COP\s0. Here are the symbols used:
.Sp
.Vb 10
\&    $ strict refs
\&    & strict subs
\&    * strict vars
\&   x$ explicit use/no strict refs
\&   x& explicit use/no strict subs
\&   x* explicit use/no strict vars
\&    i integers
\&    l locale
\&    b bytes
\&    { block scope
\&    % localise %^H
\&    < open in
\&    > open out
\&    I overload int
\&    F overload float
\&    B overload binary
\&    S overload string
\&    R overload re
\&    T taint
\&    E eval
\&    X filetest access
\&    U utf\-8
.Ve
.IP "\fB#hintsval\fR" 4
.IX Item "#hintsval"
The numeric value of the \s-1COP\s0's hint flags, or an empty string if this is not
a \s-1COP\s0.
.IP "\fB#hyphseq\fR" 4
.IX Item "#hyphseq"
The sequence number of the \s-1OP\s0, or a hyphen if it doesn't have one.
.IP "\fB#label\fR" 4
.IX Item "#label"
\&'\s-1NEXT\s0', '\s-1LAST\s0', or '\s-1REDO\s0' if the \s-1OP\s0 is a target of one of those in exec
mode, or empty otherwise.
.IP "\fB#lastaddr\fR" 4
.IX Item "#lastaddr"
The address of the \s-1OP\s0's last child, in hexadecimal.
.IP "\fB#name\fR" 4
.IX Item "#name"
The \s-1OP\s0's name.
.IP "\fB#NAME\fR" 4
.IX Item "#NAME"
The \s-1OP\s0's name, in all caps.
.IP "\fB#next\fR" 4
.IX Item "#next"
The sequence number of the \s-1OP\s0's next \s-1OP\s0.
.IP "\fB#nextaddr\fR" 4
.IX Item "#nextaddr"
The address of the \s-1OP\s0's next \s-1OP\s0, in hexadecimal.
.IP "\fB#noise\fR" 4
.IX Item "#noise"
A one\- or two-character abbreviation for the \s-1OP\s0's name.
.IP "\fB#private\fR" 4
.IX Item "#private"
The \s-1OP\s0's private flags, rendered with abbreviated names if possible.
.IP "\fB#privval\fR" 4
.IX Item "#privval"
The numeric value of the \s-1OP\s0's private flags.
.IP "\fB#seq\fR" 4
.IX Item "#seq"
The sequence number of the \s-1OP\s0. Note that this is a sequence number
generated by B::Concise.
.IP "\fB#seqnum\fR" 4
.IX Item "#seqnum"
5.8.x and earlier only. 5.9 and later do not provide this.
.Sp
The real sequence number of the \s-1OP\s0, as a regular number and not adjusted
to be relative to the start of the real program. (This will generally be
a fairly large number because all of \fBB::Concise\fR is compiled before
your program is).
.IP "\fB#opt\fR" 4
.IX Item "#opt"
Whether or not the op has been optimised by the peephole optimiser.
.Sp
Only available in 5.9 and later.
.IP "\fB#sibaddr\fR" 4
.IX Item "#sibaddr"
The address of the \s-1OP\s0's next youngest sibling, in hexadecimal.
.IP "\fB#svaddr\fR" 4
.IX Item "#svaddr"
The address of the \s-1OP\s0's \s-1SV\s0, if it has an \s-1SV\s0, in hexadecimal.
.IP "\fB#svclass\fR" 4
.IX Item "#svclass"
The class of the \s-1OP\s0's \s-1SV\s0, if it has one, in all caps (e.g., '\s-1IV\s0').
.IP "\fB#svval\fR" 4
.IX Item "#svval"
The value of the \s-1OP\s0's \s-1SV\s0, if it has one, in a short human-readable format.
.IP "\fB#targ\fR" 4
.IX Item "#targ"
The numeric value of the \s-1OP\s0's targ.
.IP "\fB#targarg\fR" 4
.IX Item "#targarg"
The name of the variable the \s-1OP\s0's targ refers to, if any, otherwise the
letter t followed by the \s-1OP\s0's targ in decimal.
.IP "\fB#targarglife\fR" 4
.IX Item "#targarglife"
Same as \fB#targarg\fR, but followed by the \s-1COP\s0 sequence numbers that delimit
the variable's lifetime (or 'end' for a variable in an open scope) for a
variable.
.IP "\fB#typenum\fR" 4
.IX Item "#typenum"
The numeric value of the \s-1OP\s0's type, in decimal.
.SH "One-Liner Command tips"
.IX Header "One-Liner Command tips"
.IP "perl \-MO=Concise,bar foo.pl" 4
.IX Item "perl -MO=Concise,bar foo.pl"
Renders only \fIbar()\fR from foo.pl.  To see main, drop the ',bar'.  To see
both, add ',\-main'
.IP "perl \-MDigest::MD5=md5 \-MO=Concise,md5 \-e1" 4
.IX Item "perl -MDigest::MD5=md5 -MO=Concise,md5 -e1"
Identifies md5 as an \s-1XS\s0 function.  The export is needed so that \s-1BC\s0 can
find it in main.
.IP "perl \-MPOSIX \-MO=Concise,_POSIX_ARG_MAX \-e1" 4
.IX Item "perl -MPOSIX -MO=Concise,_POSIX_ARG_MAX -e1"
Identifies _POSIX_ARG_MAX as a constant sub, optimized to an \s-1IV\s0.
Although \s-1POSIX\s0 isn't entirely consistent across platforms, this is
likely to be present in virtually all of them.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'print _POSIX_SAVED_IDS'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'print _POSIX_SAVED_IDS'"
This renders a print statement, which includes a call to the function.
It's identical to rendering a file with a use call and that single
statement, except for the filename which appears in the nextstate ops.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'sub a{_POSIX_SAVED_IDS}'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'sub a{_POSIX_SAVED_IDS}'"
This is \fBvery\fR similar to previous, only the first two ops differ.  This
subroutine rendering is more representative, insofar as a single main
program will have many subs.
.ie n .IP "perl \-MB::Concise \-e 'B::Concise::compile(""\-exec"",""\-src"", \e%B::Concise::)\->()'" 4
.el .IP "perl \-MB::Concise \-e 'B::Concise::compile(``\-exec'',``\-src'', \e%B::Concise::)\->()'" 4
.IX Item "perl -MB::Concise -e 'B::Concise::compile(-exec,-src, %B::Concise::)->()'"
This renders all functions in the B::Concise package with the source
lines.  It eschews the O framework so that the stashref can be passed
directly to \fIB::Concise::compile()\fR.  See \-stash option for a more
convenient way to render a package.
.SH "Using B::Concise outside of the O framework"
.IX Header "Using B::Concise outside of the O framework"
The common (and original) usage of B::Concise was for command-line
renderings of simple code, as given in \s-1EXAMPLE\s0.  But you can also use
\&\fBB::Concise\fR from your code, and call \fIcompile()\fR directly, and
repeatedly.  By doing so, you can avoid the compile-time only
operation of O.pm, and even use the debugger to step through
\&\fIB::Concise::compile()\fR itself.
.PP
Once you're doing this, you may alter Concise output by adding new
rendering styles, and by optionally adding callback routines which
populate new variables, if such were referenced from those (just
added) styles.
.SS "Example: Altering Concise Renderings"
.IX Subsection "Example: Altering Concise Renderings"
.Vb 9
\&    use B::Concise qw(set_style add_callback);
\&    add_style($yourStyleName => $defaultfmt, $gotofmt, $treefmt);
\&    add_callback
\&      ( sub {
\&            my ($h, $op, $format, $level, $stylename) = @_;
\&            $h\->{variable} = some_func($op);
\&        });
\&    $walker = B::Concise::compile(@options,@subnames,@subrefs);
\&    $walker\->();
.Ve
.SS "\fIset_style()\fP"
.IX Subsection "set_style()"
\&\fBset_style\fR accepts 3 arguments, and updates the three format-specs
comprising a line-style (basic-exec, goto, tree).  It has one minor
drawback though; it doesn't register the style under a new name.  This
can become an issue if you render more than once and switch styles.
Thus you may prefer to use \fIadd_style()\fR and/or \fIset_style_standard()\fR
instead.
.SS "set_style_standard($name)"
.IX Subsection "set_style_standard($name)"
This restores one of the standard line-styles: \f(CW\*(C`terse\*(C'\fR, \f(CW\*(C`concise\*(C'\fR,
\&\f(CW\*(C`linenoise\*(C'\fR, \f(CW\*(C`debug\*(C'\fR, \f(CW\*(C`env\*(C'\fR, into effect.  It also accepts style
names previously defined with \fIadd_style()\fR.
.SS "add_style ()"
.IX Subsection "add_style ()"
This subroutine accepts a new style name and three style arguments as
above, and creates, registers, and selects the newly named style.  It is
an error to re-add a style; call \fIset_style_standard()\fR to switch between
several styles.
.SS "add_callback ()"
.IX Subsection "add_callback ()"
If your newly minted styles refer to any new #variables, you'll need
to define a callback subroutine that will populate (or modify) those
variables.  They are then available for use in the style you've
chosen.
.PP
The callbacks are called for each opcode visited by Concise, in the
same order as they are added.  Each subroutine is passed five
parameters.
.PP
.Vb 6
\&  1. A hashref, containing the variable names and values which are
\&     populated into the report\-line for the op
\&  2. the op, as a B<B::OP> object
\&  3. a reference to the format string
\&  4. the formatting (indent) level
\&  5. the selected stylename
.Ve
.PP
To define your own variables, simply add them to the hash, or change
existing values if you need to.  The level and format are passed in as
references to scalars, but it is unlikely that they will need to be
changed or even used.
.SS "Running \fIB::Concise::compile()\fP"
.IX Subsection "Running B::Concise::compile()"
\&\fBcompile\fR accepts options as described above in \*(L"\s-1OPTIONS\s0\*(R", and
arguments, which are either coderefs, or subroutine names.
.PP
It constructs and returns a \f(CW$treewalker\fR coderef, which when invoked,
traverses, or walks, and renders the optrees of the given arguments to
\&\s-1STDOUT\s0.  You can reuse this, and can change the rendering style used
each time; thereafter the coderef renders in the new style.
.PP
\&\fBwalk_output\fR lets you change the print destination from \s-1STDOUT\s0 to
another open filehandle, or into a string passed as a ref (unless
you've built perl with \-Uuseperlio).
.PP
.Vb 7
\&    my $walker = B::Concise::compile(\*(Aq\-terse\*(Aq,\*(AqaFuncName\*(Aq, \e&aSubRef);  # 1
\&    walk_output(\emy $buf);
\&    $walker\->();                        # 1 renders \-terse
\&    set_style_standard(\*(Aqconcise\*(Aq);      # 2
\&    $walker\->();                        # 2 renders \-concise
\&    $walker\->(@new);                    # 3 renders whatever
\&    print "3 different renderings: terse, concise, and @new: $buf\en";
.Ve
.PP
When \f(CW$walker\fR is called, it traverses the subroutines supplied when it
was created, and renders them using the current style.  You can change
the style afterwards in several different ways:
.PP
.Vb 3
\&  1. call C<compile>, altering style or mode/order
\&  2. call C<set_style_standard>
\&  3. call $walker, passing @new options
.Ve
.PP
Passing new options to the \f(CW$walker\fR is the easiest way to change
amongst any pre-defined styles (the ones you add are automatically
recognized as options), and is the only way to alter rendering order
without calling compile again.  Note however that rendering state is
still shared amongst multiple \f(CW$walker\fR objects, so they must still be
used in a coordinated manner.
.SS "\fIB::Concise::reset_sequence()\fP"
.IX Subsection "B::Concise::reset_sequence()"
This function (not exported) lets you reset the sequence numbers (note
that they're numbered arbitrarily, their goal being to be human
readable).  Its purpose is mostly to support testing, i.e. to compare
the concise output from two identical anonymous subroutines (but
different instances).  Without the reset, B::Concise, seeing that
they're separate optrees, generates different sequence numbers in
the output.
.SS "Errors"
.IX Subsection "Errors"
Errors in rendering (non-existent function-name, non-existent coderef)
are written to the \s-1STDOUT\s0, or wherever you've set it via
\&\fIwalk_output()\fR.
.PP
Errors using the various *style* calls, and bad args to \fIwalk_output()\fR,
result in \fIdie()\fR.  Use an eval if you wish to catch these errors and
continue processing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant, <smcc@CSUA.Berkeley.EDU>.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Concise5.18.3pm                           0100644 0001750 0001750 00000102340 12566207451 023466  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Concise 3pm"
.TH B::Concise 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Concise \- Walk Perl syntax tree, printing concise info about ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    perl \-MO=Concise[,OPTIONS] foo.pl
\&
\&    use B::Concise qw(set_style add_callback);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This compiler backend prints the internal OPs of a Perl program's syntax
tree in one of several space-efficient text formats suitable for debugging
the inner workings of perl or other compiler backends. It can print OPs in
the order they appear in the \s-1OP\s0 tree, in the order they will execute, or
in a text approximation to their tree structure, and the format of the
information displayed is customizable. Its function is similar to that of
perl's \fB\-Dx\fR debugging flag or the \fBB::Terse\fR module, but it is more
sophisticated and flexible.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Here's two outputs (or 'renderings'), using the \-exec and \-basic
(i.e. default) formatting conventions on the same code snippet.
.PP
.Vb 9
\&    % perl \-MO=Concise,\-exec \-e \*(Aq$a = $b + 42\*(Aq
\&    1  <0> enter
\&    2  <;> nextstate(main 1 \-e:1) v
\&    3  <#> gvsv[*b] s
\&    4  <$> const[IV 42] s
\& *  5  <2> add[t3] sK/2
\&    6  <#> gvsv[*a] s
\&    7  <2> sassign vKS/2
\&    8  <@> leave[1 ref] vKP/REFC
.Ve
.PP
In this \-exec rendering, each opcode is executed in the order shown.
The add opcode, marked with '*', is discussed in more detail.
.PP
The 1st column is the op's sequence number, starting at 1, and is
displayed in base 36 by default.  Here they're purely linear; the
sequences are very helpful when looking at code with loops and
branches.
.PP
The symbol between angle brackets indicates the op's type, for
example; <2> is a \s-1BINOP,\s0 <@> a \s-1LISTOP,\s0 and <#> is a \s-1PADOP,\s0 which is
used in threaded perls. (see \*(L"\s-1OP\s0 class abbreviations\*(R").
.PP
The opname, as in \fB'add[t1]'\fR, may be followed by op-specific
information in parentheses or brackets (ex \fB'[t1]'\fR).
.PP
The op-flags (ex \fB'sK/2'\fR) are described in (\*(L"\s-1OP\s0 flags
abbreviations\*(R").
.PP
.Vb 11
\&    % perl \-MO=Concise \-e \*(Aq$a = $b + 42\*(Aq
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    1     <0> enter \->2
\&    2     <;> nextstate(main 1 \-e:1) v \->3
\&    7     <2> sassign vKS/2 \->8
\& *  5        <2> add[t1] sK/2 \->6
\&    \-           <1> ex\-rv2sv sK/1 \->4
\&    3              <$> gvsv(*b) s \->4
\&    4           <$> const(IV 42) s \->5
\&    \-        <1> ex\-rv2sv sKRM*/1 \->7
\&    6           <$> gvsv(*a) s \->7
.Ve
.PP
The default rendering is top-down, so they're not in execution order.
This form reflects the way the stack is used to parse and evaluate
expressions; the add operates on the two terms below it in the tree.
.PP
Nullops appear as \f(CW\*(C`ex\-opname\*(C'\fR, where \fIopname\fR is an op that has been
optimized away by perl.  They're displayed with a sequence-number of
\&'\-', because they are not executed (they don't appear in previous
example), they're printed here because they reflect the parse.
.PP
The arrow points to the sequence number of the next op; they're not
displayed in \-exec mode, for obvious reasons.
.PP
Note that because this rendering was done on a non-threaded perl, the
PADOPs in the previous examples are now SVOPs, and some (but not all)
of the square brackets have been replaced by round ones.  This is a
subtle feature to provide some visual distinction between renderings
on threaded and un-threaded perls.
.SH "OPTIONS"
.IX Header "OPTIONS"
Arguments that don't start with a hyphen are taken to be the names of
subroutines or formats to render; if no
such functions are specified, the main
body of the program (outside any subroutines, and not including use'd
or require'd files) is rendered.  Passing \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR,
\&\f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, or \f(CW\*(C`END\*(C'\fR will cause all of the corresponding
special blocks to be printed.  Arguments must follow options.
.PP
Options affect how things are rendered (ie printed).  They're presented
here by their visual effect, 1st being strongest.  They're grouped
according to how they interrelate; within each group the options are
mutually exclusive (unless otherwise stated).
.SS "Options for Opcode Ordering"
.IX Subsection "Options for Opcode Ordering"
These options control the 'vertical display' of opcodes.  The display
\&'order' is also called 'mode' elsewhere in this document.
.IP "\fB\-basic\fR" 4
.IX Item "-basic"
Print OPs in the order they appear in the \s-1OP\s0 tree (a preorder
traversal, starting at the root). The indentation of each \s-1OP\s0 shows its
level in the tree, and the '\->' at the end of the line indicates the
next opcode in execution order.  This mode is the default, so the flag
is included simply for completeness.
.IP "\fB\-exec\fR" 4
.IX Item "-exec"
Print OPs in the order they would normally execute (for the majority
of constructs this is a postorder traversal of the tree, ending at the
root). In most cases the \s-1OP\s0 that usually follows a given \s-1OP\s0 will
appear directly below it; alternate paths are shown by indentation. In
cases like loops when control jumps out of a linear path, a 'goto'
line is generated.
.IP "\fB\-tree\fR" 4
.IX Item "-tree"
Print OPs in a text approximation of a tree, with the root of the tree
at the left and 'left\-to\-right' order of children transformed into
\&'top\-to\-bottom'. Because this mode grows both to the right and down,
it isn't suitable for large programs (unless you have a very wide
terminal).
.SS "Options for Line-Style"
.IX Subsection "Options for Line-Style"
These options select the line-style (or just style) used to render
each opcode, and dictates what info is actually printed into each line.
.IP "\fB\-concise\fR" 4
.IX Item "-concise"
Use the author's favorite set of formatting conventions. This is the
default, of course.
.IP "\fB\-terse\fR" 4
.IX Item "-terse"
Use formatting conventions that emulate the output of \fBB::Terse\fR. The
basic mode is almost indistinguishable from the real \fBB::Terse\fR, and the
exec mode looks very similar, but is in a more logical order and lacks
curly brackets. \fBB::Terse\fR doesn't have a tree mode, so the tree mode
is only vaguely reminiscent of \fBB::Terse\fR.
.IP "\fB\-linenoise\fR" 4
.IX Item "-linenoise"
Use formatting conventions in which the name of each \s-1OP,\s0 rather than being
written out in full, is represented by a one\- or two-character abbreviation.
This is mainly a joke.
.IP "\fB\-debug\fR" 4
.IX Item "-debug"
Use formatting conventions reminiscent of \fBB::Debug\fR; these aren't
very concise at all.
.IP "\fB\-env\fR" 4
.IX Item "-env"
Use formatting conventions read from the environment variables
\&\f(CW\*(C`B_CONCISE_FORMAT\*(C'\fR, \f(CW\*(C`B_CONCISE_GOTO_FORMAT\*(C'\fR, and \f(CW\*(C`B_CONCISE_TREE_FORMAT\*(C'\fR.
.SS "Options for tree-specific formatting"
.IX Subsection "Options for tree-specific formatting"
.IP "\fB\-compact\fR" 4
.IX Item "-compact"
Use a tree format in which the minimum amount of space is used for the
lines connecting nodes (one character in most cases). This squeezes out
a few precious columns of screen real estate.
.IP "\fB\-loose\fR" 4
.IX Item "-loose"
Use a tree format that uses longer edges to separate \s-1OP\s0 nodes. This format
tends to look better than the compact one, especially in \s-1ASCII,\s0 and is
the default.
.IP "\fB\-vt\fR" 4
.IX Item "-vt"
Use tree connecting characters drawn from the \s-1VT100\s0 line-drawing set.
This looks better if your terminal supports it.
.IP "\fB\-ascii\fR" 4
.IX Item "-ascii"
Draw the tree with standard \s-1ASCII\s0 characters like \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`|\*(C'\fR. These don't
look as clean as the \s-1VT100\s0 characters, but they'll work with almost any
terminal (or the horizontal scrolling mode of \fIless\fR\|(1)) and are suitable
for text documentation or email. This is the default.
.PP
These are pairwise exclusive, i.e. compact or loose, vt or ascii.
.SS "Options controlling sequence numbering"
.IX Subsection "Options controlling sequence numbering"
.IP "\fB\-base\fR\fIn\fR" 4
.IX Item "-basen"
Print \s-1OP\s0 sequence numbers in base \fIn\fR. If \fIn\fR is greater than 10, the
digit for 11 will be 'a', and so on. If \fIn\fR is greater than 36, the digit
for 37 will be 'A', and so on until 62. Values greater than 62 are not
currently supported. The default is 36.
.IP "\fB\-bigendian\fR" 4
.IX Item "-bigendian"
Print sequence numbers with the most significant digit first. This is the
usual convention for Arabic numerals, and the default.
.IP "\fB\-littleendian\fR" 4
.IX Item "-littleendian"
Print sequence numbers with the least significant digit first.  This is
obviously mutually exclusive with bigendian.
.SS "Other options"
.IX Subsection "Other options"
.IP "\fB\-src\fR" 4
.IX Item "-src"
With this option, the rendering of each statement (starting with the
nextstate \s-1OP\s0) will be preceded by the 1st line of source code that
generates it.  For example:
.Sp
.Vb 10
\&    1  <0> enter
\&    # 1: my $i;
\&    2  <;> nextstate(main 1 junk.pl:1) v:{
\&    3  <0> padsv[$i:1,10] vM/LVINTRO
\&    # 3: for $i (0..9) {
\&    4  <;> nextstate(main 3 junk.pl:3) v:{
\&    5  <0> pushmark s
\&    6  <$> const[IV 0] s
\&    7  <$> const[IV 9] s
\&    8  <{> enteriter(next\->j last\->m redo\->9)[$i:1,10] lKS
\&    k  <0> iter s
\&    l  <|> and(other\->9) vK/1
\&    # 4:     print "line ";
\&    9      <;> nextstate(main 2 junk.pl:4) v
\&    a      <0> pushmark s
\&    b      <$> const[PV "line "] s
\&    c      <@> print vK
\&    # 5:     print "$i\en";
\&    ...
.Ve
.ie n .IP "\fB\-stash=""somepackage""\fR" 4
.el .IP "\fB\-stash=``somepackage''\fR" 4
.IX Item "-stash=somepackage"
With this, \*(L"somepackage\*(R" will be required, then the stash is
inspected, and each function is rendered.
.PP
The following options are pairwise exclusive.
.IP "\fB\-main\fR" 4
.IX Item "-main"
Include the main program in the output, even if subroutines were also
specified.  This rendering is normally suppressed when a subroutine
name or reference is given.
.IP "\fB\-nomain\fR" 4
.IX Item "-nomain"
This restores the default behavior after you've changed it with '\-main'
(it's not normally needed).  If no subroutine name/ref is given, main is
rendered, regardless of this flag.
.IP "\fB\-nobanner\fR" 4
.IX Item "-nobanner"
Renderings usually include a banner line identifying the function name
or stringified subref.  This suppresses the printing of the banner.
.Sp
\&\s-1TBC:\s0 Remove the stringified coderef; while it provides a 'cookie' for
each function rendered, the cookies used should be 1,2,3.. not a
random hex-address.  It also complicates string comparison of two
different trees.
.IP "\fB\-banner\fR" 4
.IX Item "-banner"
restores default banner behavior.
.IP "\fB\-banneris\fR => subref" 4
.IX Item "-banneris => subref"
\&\s-1TBC:\s0 a hookpoint (and an option to set it) for a user-supplied
function to produce a banner appropriate for users needs.  It's not
ideal, because the rendering-state variables, which are a natural
candidate for use in concise.t, are unavailable to the user.
.SS "Option Stickiness"
.IX Subsection "Option Stickiness"
If you invoke Concise more than once in a program, you should know that
the options are 'sticky'.  This means that the options you provide in
the first call will be remembered for the 2nd call, unless you
re-specify or change them.
.SH "ABBREVIATIONS"
.IX Header "ABBREVIATIONS"
The concise style uses symbols to convey maximum info with minimal
clutter (like hex addresses).  With just a little practice, you can
start to see the flowers, not just the branches, in the trees.
.SS "\s-1OP\s0 class abbreviations"
.IX Subsection "OP class abbreviations"
These symbols appear before the op-name, and indicate the
B:: namespace that represents the ops in your Perl code.
.PP
.Vb 11
\&    0      OP (aka BASEOP)  An OP with no children
\&    1      UNOP             An OP with one child
\&    2      BINOP            An OP with two children
\&    |      LOGOP            A control branch OP
\&    @      LISTOP           An OP that could have lots of children
\&    /      PMOP             An OP with a regular expression
\&    $      SVOP             An OP with an SV
\&    "      PVOP             An OP with a string
\&    {      LOOP             An OP that holds pointers for a loop
\&    ;      COP              An OP that marks the start of a statement
\&    #      PADOP            An OP with a GV on the pad
.Ve
.SS "\s-1OP\s0 flags abbreviations"
.IX Subsection "OP flags abbreviations"
\&\s-1OP\s0 flags are either public or private.  The public flags alter the
behavior of each opcode in consistent ways, and are represented by 0
or more single characters.
.PP
.Vb 12
\&    v      OPf_WANT_VOID    Want nothing (void context)
\&    s      OPf_WANT_SCALAR  Want single value (scalar context)
\&    l      OPf_WANT_LIST    Want list of any length (list context)
\&                            Want is unknown
\&    K      OPf_KIDS         There is a firstborn child.
\&    P      OPf_PARENS       This operator was parenthesized.
\&                             (Or block needs explicit scope entry.)
\&    R      OPf_REF          Certified reference.
\&                             (Return container, not containee).
\&    M      OPf_MOD          Will modify (lvalue).
\&    S      OPf_STACKED      Some arg is arriving on the stack.
\&    *      OPf_SPECIAL      Do something weird for this op (see op.h)
.Ve
.PP
Private flags, if any are set for an opcode, are displayed after a '/'
.PP
.Vb 2
\&    8  <@> leave[1 ref] vKP/REFC \->(end)
\&    7     <2> sassign vKS/2 \->8
.Ve
.PP
They're opcode specific, and occur less often than the public ones, so
they're represented by short mnemonics instead of single-chars; see
\&\fIop.h\fR for gory details, or try this quick 2\-liner:
.PP
.Vb 2
\&  $> perl \-MB::Concise \-de 1
\&  DB<1> |x \e%B::Concise::priv
.Ve
.SH "FORMATTING SPECIFICATIONS"
.IX Header "FORMATTING SPECIFICATIONS"
For each line-style ('concise', 'terse', 'linenoise', etc.) there are
3 format-specs which control how OPs are rendered.
.PP
The first is the 'default' format, which is used in both basic and exec
modes to print all opcodes.  The 2nd, goto-format, is used in exec
mode when branches are encountered.  They're not real opcodes, and are
inserted to look like a closing curly brace.  The tree-format is tree
specific.
.PP
When a line is rendered, the correct format-spec is copied and scanned
for the following items; data is substituted in, and other
manipulations like basic indenting are done, for each opcode rendered.
.PP
There are 3 kinds of items that may be populated; special patterns,
#vars, and literal text, which is copied verbatim.  (Yes, it's a set
of s///g steps.)
.SS "Special Patterns"
.IX Subsection "Special Patterns"
These items are the primitives used to perform indenting, and to
select text from amongst alternatives.
.IP "\fB(x(\fR\fIexec_text\fR\fB;\fR\fIbasic_text\fR\fB)x)\fR" 4
.IX Item "(x(exec_text;basic_text)x)"
Generates \fIexec_text\fR in exec mode, or \fIbasic_text\fR in basic mode.
.IP "\fB(*(\fR\fItext\fR\fB)*)\fR" 4
.IX Item "(*(text)*)"
Generates one copy of \fItext\fR for each indentation level.
.IP "\fB(*(\fR\fItext1\fR\fB;\fR\fItext2\fR\fB)*)\fR" 4
.IX Item "(*(text1;text2)*)"
Generates one fewer copies of \fItext1\fR than the indentation level, followed
by one copy of \fItext2\fR if the indentation level is more than 0.
.IP "\fB(?(\fR\fItext1\fR\fB#\fR\fIvar\fR\fIText2\fR\fB)?)\fR" 4
.IX Item "(?(text1#varText2)?)"
If the value of \fIvar\fR is true (not empty or zero), generates the
value of \fIvar\fR surrounded by \fItext1\fR and \fIText2\fR, otherwise
nothing.
.IP "\fB~\fR" 4
.IX Item "~"
Any number of tildes and surrounding whitespace will be collapsed to
a single space.
.SS "# Variables"
.IX Subsection "# Variables"
These #vars represent opcode properties that you may want as part of
your rendering.  The '#' is intended as a private sigil; a #var's
value is interpolated into the style-line, much like \*(L"read \f(CW$this\fR\*(R".
.PP
These vars take 3 forms:
.IP "\fB#\fR\fIvar\fR" 4
.IX Item "#var"
A property named 'var' is assumed to exist for the opcodes, and is
interpolated into the rendering.
.IP "\fB#\fR\fIvar\fR\fIN\fR" 4
.IX Item "#varN"
Generates the value of \fIvar\fR, left justified to fill \fIN\fR spaces.
Note that this means while you can have properties 'foo' and 'foo2',
you cannot render 'foo2', but you could with 'foo2a'.  You would be
wise not to rely on this behavior going forward ;\-)
.IP "\fB#\fR\fIVar\fR" 4
.IX Item "#Var"
This ucfirst form of #var generates a tag-value form of itself for
display; it converts '#Var' into a 'Var => #var' style, which is then
handled as described above.  (Imp-note: #Vars cannot be used for
conditional-fills, because the => #var transform is done after the check
for #Var's value).
.PP
The following variables are 'defined' by B::Concise; when they are
used in a style, their respective values are plugged into the
rendering of each opcode.
.PP
Only some of these are used by the standard styles, the others are
provided for you to delve into optree mechanics, should you wish to
add a new style (see \*(L"add_style\*(R" below) that uses them.  You can
also add new ones using \*(L"add_callback\*(R".
.IP "\fB#addr\fR" 4
.IX Item "#addr"
The address of the \s-1OP,\s0 in hexadecimal.
.IP "\fB#arg\fR" 4
.IX Item "#arg"
The OP-specific information of the \s-1OP \s0(such as the \s-1SV\s0 for an \s-1SVOP,\s0 the
non-local exit pointers for a \s-1LOOP,\s0 etc.) enclosed in parentheses.
.IP "\fB#class\fR" 4
.IX Item "#class"
The B\-determined class of the \s-1OP,\s0 in all caps.
.IP "\fB#classsym\fR" 4
.IX Item "#classsym"
A single symbol abbreviating the class of the \s-1OP.\s0
.IP "\fB#coplabel\fR" 4
.IX Item "#coplabel"
The label of the statement or block the \s-1OP\s0 is the start of, if any.
.IP "\fB#exname\fR" 4
.IX Item "#exname"
The name of the \s-1OP,\s0 or 'ex\-foo' if the \s-1OP\s0 is a null that used to be a foo.
.IP "\fB#extarg\fR" 4
.IX Item "#extarg"
The target of the \s-1OP,\s0 or nothing for a nulled \s-1OP.\s0
.IP "\fB#firstaddr\fR" 4
.IX Item "#firstaddr"
The address of the \s-1OP\s0's first child, in hexadecimal.
.IP "\fB#flags\fR" 4
.IX Item "#flags"
The \s-1OP\s0's flags, abbreviated as a series of symbols.
.IP "\fB#flagval\fR" 4
.IX Item "#flagval"
The numeric value of the \s-1OP\s0's flags.
.IP "\fB#hints\fR" 4
.IX Item "#hints"
The \s-1COP\s0's hint flags, rendered with abbreviated names if possible. An empty
string if this is not a \s-1COP.\s0 Here are the symbols used:
.Sp
.Vb 10
\&    $ strict refs
\&    & strict subs
\&    * strict vars
\&   x$ explicit use/no strict refs
\&   x& explicit use/no strict subs
\&   x* explicit use/no strict vars
\&    i integers
\&    l locale
\&    b bytes
\&    { block scope
\&    % localise %^H
\&    < open in
\&    > open out
\&    I overload int
\&    F overload float
\&    B overload binary
\&    S overload string
\&    R overload re
\&    T taint
\&    E eval
\&    X filetest access
\&    U utf\-8
.Ve
.IP "\fB#hintsval\fR" 4
.IX Item "#hintsval"
The numeric value of the \s-1COP\s0's hint flags, or an empty string if this is not
a \s-1COP.\s0
.IP "\fB#hyphseq\fR" 4
.IX Item "#hyphseq"
The sequence number of the \s-1OP,\s0 or a hyphen if it doesn't have one.
.IP "\fB#label\fR" 4
.IX Item "#label"
\&'\s-1NEXT\s0', '\s-1LAST\s0', or '\s-1REDO\s0' if the \s-1OP\s0 is a target of one of those in exec
mode, or empty otherwise.
.IP "\fB#lastaddr\fR" 4
.IX Item "#lastaddr"
The address of the \s-1OP\s0's last child, in hexadecimal.
.IP "\fB#name\fR" 4
.IX Item "#name"
The \s-1OP\s0's name.
.IP "\fB#NAME\fR" 4
.IX Item "#NAME"
The \s-1OP\s0's name, in all caps.
.IP "\fB#next\fR" 4
.IX Item "#next"
The sequence number of the \s-1OP\s0's next \s-1OP.\s0
.IP "\fB#nextaddr\fR" 4
.IX Item "#nextaddr"
The address of the \s-1OP\s0's next \s-1OP,\s0 in hexadecimal.
.IP "\fB#noise\fR" 4
.IX Item "#noise"
A one\- or two-character abbreviation for the \s-1OP\s0's name.
.IP "\fB#private\fR" 4
.IX Item "#private"
The \s-1OP\s0's private flags, rendered with abbreviated names if possible.
.IP "\fB#privval\fR" 4
.IX Item "#privval"
The numeric value of the \s-1OP\s0's private flags.
.IP "\fB#seq\fR" 4
.IX Item "#seq"
The sequence number of the \s-1OP.\s0 Note that this is a sequence number
generated by B::Concise.
.IP "\fB#seqnum\fR" 4
.IX Item "#seqnum"
5.8.x and earlier only. 5.9 and later do not provide this.
.Sp
The real sequence number of the \s-1OP,\s0 as a regular number and not adjusted
to be relative to the start of the real program. (This will generally be
a fairly large number because all of \fBB::Concise\fR is compiled before
your program is).
.IP "\fB#opt\fR" 4
.IX Item "#opt"
Whether or not the op has been optimised by the peephole optimiser.
.Sp
Only available in 5.9 and later.
.IP "\fB#sibaddr\fR" 4
.IX Item "#sibaddr"
The address of the \s-1OP\s0's next youngest sibling, in hexadecimal.
.IP "\fB#svaddr\fR" 4
.IX Item "#svaddr"
The address of the \s-1OP\s0's \s-1SV,\s0 if it has an \s-1SV,\s0 in hexadecimal.
.IP "\fB#svclass\fR" 4
.IX Item "#svclass"
The class of the \s-1OP\s0's \s-1SV,\s0 if it has one, in all caps (e.g., '\s-1IV\s0').
.IP "\fB#svval\fR" 4
.IX Item "#svval"
The value of the \s-1OP\s0's \s-1SV,\s0 if it has one, in a short human-readable format.
.IP "\fB#targ\fR" 4
.IX Item "#targ"
The numeric value of the \s-1OP\s0's targ.
.IP "\fB#targarg\fR" 4
.IX Item "#targarg"
The name of the variable the \s-1OP\s0's targ refers to, if any, otherwise the
letter t followed by the \s-1OP\s0's targ in decimal.
.IP "\fB#targarglife\fR" 4
.IX Item "#targarglife"
Same as \fB#targarg\fR, but followed by the \s-1COP\s0 sequence numbers that delimit
the variable's lifetime (or 'end' for a variable in an open scope) for a
variable.
.IP "\fB#typenum\fR" 4
.IX Item "#typenum"
The numeric value of the \s-1OP\s0's type, in decimal.
.SH "One-Liner Command tips"
.IX Header "One-Liner Command tips"
.IP "perl \-MO=Concise,bar foo.pl" 4
.IX Item "perl -MO=Concise,bar foo.pl"
Renders only \fIbar()\fR from foo.pl.  To see main, drop the ',bar'.  To see
both, add ',\-main'
.IP "perl \-MDigest::MD5=md5 \-MO=Concise,md5 \-e1" 4
.IX Item "perl -MDigest::MD5=md5 -MO=Concise,md5 -e1"
Identifies md5 as an \s-1XS\s0 function.  The export is needed so that \s-1BC\s0 can
find it in main.
.IP "perl \-MPOSIX \-MO=Concise,_POSIX_ARG_MAX \-e1" 4
.IX Item "perl -MPOSIX -MO=Concise,_POSIX_ARG_MAX -e1"
Identifies _POSIX_ARG_MAX as a constant sub, optimized to an \s-1IV.\s0
Although \s-1POSIX\s0 isn't entirely consistent across platforms, this is
likely to be present in virtually all of them.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'print _POSIX_SAVED_IDS'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'print _POSIX_SAVED_IDS'"
This renders a print statement, which includes a call to the function.
It's identical to rendering a file with a use call and that single
statement, except for the filename which appears in the nextstate ops.
.IP "perl \-MPOSIX \-MO=Concise,a \-e 'sub a{_POSIX_SAVED_IDS}'" 4
.IX Item "perl -MPOSIX -MO=Concise,a -e 'sub a{_POSIX_SAVED_IDS}'"
This is \fBvery\fR similar to previous, only the first two ops differ.  This
subroutine rendering is more representative, insofar as a single main
program will have many subs.
.ie n .IP "perl \-MB::Concise \-e 'B::Concise::compile(""\-exec"",""\-src"", \e%B::Concise::)\->()'" 4
.el .IP "perl \-MB::Concise \-e 'B::Concise::compile(``\-exec'',``\-src'', \e%B::Concise::)\->()'" 4
.IX Item "perl -MB::Concise -e 'B::Concise::compile(-exec,-src, %B::Concise::)->()'"
This renders all functions in the B::Concise package with the source
lines.  It eschews the O framework so that the stashref can be passed
directly to \fIB::Concise::compile()\fR.  See \-stash option for a more
convenient way to render a package.
.SH "Using B::Concise outside of the O framework"
.IX Header "Using B::Concise outside of the O framework"
The common (and original) usage of B::Concise was for command-line
renderings of simple code, as given in \s-1EXAMPLE. \s0 But you can also use
\&\fBB::Concise\fR from your code, and call \fIcompile()\fR directly, and
repeatedly.  By doing so, you can avoid the compile-time only
operation of O.pm, and even use the debugger to step through
\&\fIB::Concise::compile()\fR itself.
.PP
Once you're doing this, you may alter Concise output by adding new
rendering styles, and by optionally adding callback routines which
populate new variables, if such were referenced from those (just
added) styles.
.SS "Example: Altering Concise Renderings"
.IX Subsection "Example: Altering Concise Renderings"
.Vb 9
\&    use B::Concise qw(set_style add_callback);
\&    add_style($yourStyleName => $defaultfmt, $gotofmt, $treefmt);
\&    add_callback
\&      ( sub {
\&            my ($h, $op, $format, $level, $stylename) = @_;
\&            $h\->{variable} = some_func($op);
\&        });
\&    $walker = B::Concise::compile(@options,@subnames,@subrefs);
\&    $walker\->();
.Ve
.SS "\fIset_style()\fP"
.IX Subsection "set_style()"
\&\fBset_style\fR accepts 3 arguments, and updates the three format-specs
comprising a line-style (basic-exec, goto, tree).  It has one minor
drawback though; it doesn't register the style under a new name.  This
can become an issue if you render more than once and switch styles.
Thus you may prefer to use \fIadd_style()\fR and/or \fIset_style_standard()\fR
instead.
.SS "set_style_standard($name)"
.IX Subsection "set_style_standard($name)"
This restores one of the standard line-styles: \f(CW\*(C`terse\*(C'\fR, \f(CW\*(C`concise\*(C'\fR,
\&\f(CW\*(C`linenoise\*(C'\fR, \f(CW\*(C`debug\*(C'\fR, \f(CW\*(C`env\*(C'\fR, into effect.  It also accepts style
names previously defined with \fIadd_style()\fR.
.SS "add_style ()"
.IX Subsection "add_style ()"
This subroutine accepts a new style name and three style arguments as
above, and creates, registers, and selects the newly named style.  It is
an error to re-add a style; call \fIset_style_standard()\fR to switch between
several styles.
.SS "add_callback ()"
.IX Subsection "add_callback ()"
If your newly minted styles refer to any new #variables, you'll need
to define a callback subroutine that will populate (or modify) those
variables.  They are then available for use in the style you've
chosen.
.PP
The callbacks are called for each opcode visited by Concise, in the
same order as they are added.  Each subroutine is passed five
parameters.
.PP
.Vb 6
\&  1. A hashref, containing the variable names and values which are
\&     populated into the report\-line for the op
\&  2. the op, as a B<B::OP> object
\&  3. a reference to the format string
\&  4. the formatting (indent) level
\&  5. the selected stylename
.Ve
.PP
To define your own variables, simply add them to the hash, or change
existing values if you need to.  The level and format are passed in as
references to scalars, but it is unlikely that they will need to be
changed or even used.
.SS "Running \fIB::Concise::compile()\fP"
.IX Subsection "Running B::Concise::compile()"
\&\fBcompile\fR accepts options as described above in \*(L"\s-1OPTIONS\*(R"\s0, and
arguments, which are either coderefs, or subroutine names.
.PP
It constructs and returns a \f(CW$treewalker\fR coderef, which when invoked,
traverses, or walks, and renders the optrees of the given arguments to
\&\s-1STDOUT. \s0 You can reuse this, and can change the rendering style used
each time; thereafter the coderef renders in the new style.
.PP
\&\fBwalk_output\fR lets you change the print destination from \s-1STDOUT\s0 to
another open filehandle, or into a string passed as a ref (unless
you've built perl with \-Uuseperlio).
.PP
.Vb 7
\&    my $walker = B::Concise::compile(\*(Aq\-terse\*(Aq,\*(AqaFuncName\*(Aq, \e&aSubRef);  # 1
\&    walk_output(\emy $buf);
\&    $walker\->();                        # 1 renders \-terse
\&    set_style_standard(\*(Aqconcise\*(Aq);      # 2
\&    $walker\->();                        # 2 renders \-concise
\&    $walker\->(@new);                    # 3 renders whatever
\&    print "3 different renderings: terse, concise, and @new: $buf\en";
.Ve
.PP
When \f(CW$walker\fR is called, it traverses the subroutines supplied when it
was created, and renders them using the current style.  You can change
the style afterwards in several different ways:
.PP
.Vb 3
\&  1. call C<compile>, altering style or mode/order
\&  2. call C<set_style_standard>
\&  3. call $walker, passing @new options
.Ve
.PP
Passing new options to the \f(CW$walker\fR is the easiest way to change
amongst any pre-defined styles (the ones you add are automatically
recognized as options), and is the only way to alter rendering order
without calling compile again.  Note however that rendering state is
still shared amongst multiple \f(CW$walker\fR objects, so they must still be
used in a coordinated manner.
.SS "\fIB::Concise::reset_sequence()\fP"
.IX Subsection "B::Concise::reset_sequence()"
This function (not exported) lets you reset the sequence numbers (note
that they're numbered arbitrarily, their goal being to be human
readable).  Its purpose is mostly to support testing, i.e. to compare
the concise output from two identical anonymous subroutines (but
different instances).  Without the reset, B::Concise, seeing that
they're separate optrees, generates different sequence numbers in
the output.
.SS "Errors"
.IX Subsection "Errors"
Errors in rendering (non-existent function-name, non-existent coderef)
are written to the \s-1STDOUT,\s0 or wherever you've set it via
\&\fIwalk_output()\fR.
.PP
Errors using the various *style* calls, and bad args to \fIwalk_output()\fR,
result in \fIdie()\fR.  Use an eval if you wish to catch these errors and
continue processing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant, <smcc@CSUA.Berkeley.EDU>.
                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Debug.3pm                                 0100644 0001750 0001750 00000013227 12566207451 022622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Debug 3pm"
.TH B::Debug 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Debug \- Walk Perl syntax tree, printing debug info about ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        perl \-MO=Debug foo.pl
\&        perl \-MO=Debug,\-exec foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See \fIext/B/README\fR and the newer B::Concise, B::Terse.
.SH "OPTIONS"
.IX Header "OPTIONS"
With option \-exec, walks tree in execute order,
otherwise in basic order.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
Reini Urban \f(CW\*(C`rurban@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1996, 1997 Malcolm Beattie
Copyright (c) 2008, 2010 Reini Urban
.PP
.Vb 2
\&        This program is free software; you can redistribute it and/or modify
\&        it under the terms of either:
\&
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&
\&        b) the "Artistic License" which comes with this kit.
\&
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&
\&    You should have received a copy of the Artistic License with this kit,
\&    in the file named "Artistic".  If not, you can get one from the Perl
\&    distribution. You should also have received a copy of the GNU General
\&    Public License, in the file named "Copying". If not, you can get one
\&    from the Perl distribution or else write to the Free Software Foundation,
\&    Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110\-1301, USA.
.Ve
                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Debug5.16.3pm                             0100644 0001750 0001750 00000012706 12566207430 023132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Debug 3pm"
.TH B::Debug 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Debug \- Walk Perl syntax tree, printing debug info about ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        perl \-MO=Debug foo.pl
\&        perl \-MO=Debug,\-exec foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See \fIext/B/README\fR and the newer B::Concise, B::Terse.
.SH "OPTIONS"
.IX Header "OPTIONS"
With option \-exec, walks tree in execute order,
otherwise in basic order.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
Reini Urban \f(CW\*(C`rurban@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1996, 1997 Malcolm Beattie
Copyright (c) 2008, 2010 Reini Urban
.PP
.Vb 2
\&        This program is free software; you can redistribute it and/or modify
\&        it under the terms of either:
\&
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&
\&        b) the "Artistic License" which comes with this kit.
\&
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&
\&    You should have received a copy of the Artistic License with this kit,
\&    in the file named "Artistic".  If not, you can get one from the Perl
\&    distribution. You should also have received a copy of the GNU General
\&    Public License, in the file named "Copying". If not, you can get one
\&    from the Perl distribution or else write to the Free Software Foundation,
\&    Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110\-1301, USA.
.Ve
                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Debug5.18.3pm                             0100644 0001750 0001750 00000013227 12566207451 023136  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Debug 3pm"
.TH B::Debug 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Debug \- Walk Perl syntax tree, printing debug info about ops
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        perl \-MO=Debug foo.pl
\&        perl \-MO=Debug,\-exec foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See \fIext/B/README\fR and the newer B::Concise, B::Terse.
.SH "OPTIONS"
.IX Header "OPTIONS"
With option \-exec, walks tree in execute order,
otherwise in basic order.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
Reini Urban \f(CW\*(C`rurban@cpan.org\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1996, 1997 Malcolm Beattie
Copyright (c) 2008, 2010 Reini Urban
.PP
.Vb 2
\&        This program is free software; you can redistribute it and/or modify
\&        it under the terms of either:
\&
\&        a) the GNU General Public License as published by the Free
\&        Software Foundation; either version 1, or (at your option) any
\&        later version, or
\&
\&        b) the "Artistic License" which comes with this kit.
\&
\&    This program is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
\&    the GNU General Public License or the Artistic License for more details.
\&
\&    You should have received a copy of the Artistic License with this kit,
\&    in the file named "Artistic".  If not, you can get one from the Perl
\&    distribution. You should also have received a copy of the GNU General
\&    Public License, in the file named "Copying". If not, you can get one
\&    from the Perl distribution or else write to the Free Software Foundation,
\&    Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110\-1301, USA.
.Ve
                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Deparse.3pm                               0100644 0001750 0001750 00000051756 12566207451 023170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Deparse 3pm"
.TH B::Deparse 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Deparse \- Perl compiler backend to produce perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperl\fR \fB\-MO=Deparse\fR[\fB,\-d\fR][\fB,\-f\fR\fI\s-1FILE\s0\fR][\fB,\-p\fR][\fB,\-q\fR][\fB,\-l\fR]
        [\fB,\-s\fR\fI\s-1LETTERS\s0\fR][\fB,\-x\fR\fI\s-1LEVEL\s0\fR] \fIprog.pl\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
B::Deparse is a backend module for the Perl compiler that generates
perl source code, based on the internal compiled structure that perl
itself creates after parsing a program.  The output of B::Deparse won't
be exactly the same as the original source, since perl doesn't keep
track of comments or whitespace, and there isn't a one-to-one
correspondence between perl's syntactical constructions and their
compiled form, but it will often be close.  When you use the \fB\-p\fR
option, the output also includes parentheses even when they are not
required by precedence, which can make it easy to see if perl is
parsing your expressions the way you intended.
.PP
While B::Deparse goes to some lengths to try to figure out what your
original program was doing, some parts of the language can still trip
it up; it still fails even on some parts of Perl's own test suite.  If
you encounter a failure other than the most common ones described in
the \s-1BUGS\s0 section below, you can help contribute to B::Deparse's
ongoing development by submitting a bug report with a small
example.
.SH "OPTIONS"
.IX Header "OPTIONS"
As with all compiler backend options, these must follow directly after
the '\-MO=Deparse', separated by a comma but not any white space.
.IP "\fB\-d\fR" 4
.IX Item "-d"
Output data values (when they appear as constants) using Data::Dumper.
Without this option, B::Deparse will use some simple routines of its
own for the same purpose.  Currently, Data::Dumper is better for some
kinds of data (such as complex structures with sharing and
self-reference) while the built-in routines are better for others
(such as odd floating-point values).
.IP "\fB\-f\fR\fI\s-1FILE\s0\fR" 4
.IX Item "-fFILE"
Normally, B::Deparse deparses the main code of a program, and all the subs
defined in the same file.  To include subs defined in
other files, pass the \fB\-f\fR option with the filename.
You can pass the \fB\-f\fR option several times, to
include more than one secondary file.  (Most of the time you don't want to
use it at all.)  You can also use this option to include subs which are
defined in the scope of a \fB#line\fR directive with two parameters.
.IP "\fB\-l\fR" 4
.IX Item "-l"
Add '#line' declarations to the output based on the line and file
locations of the original code.
.IP "\fB\-p\fR" 4
.IX Item "-p"
Print extra parentheses.  Without this option, B::Deparse includes
parentheses in its output only when they are needed, based on the
structure of your program.  With \fB\-p\fR, it uses parentheses (almost)
whenever they would be legal.  This can be useful if you are used to
\&\s-1LISP,\s0 or if you want to see how perl parses your input.  If you say
.Sp
.Vb 3
\&    if ($var & 0x7f == 65) {print "Gimme an A!"}
\&    print ($which ? $a : $b), "\en";
\&    $name = $ENV{USER} or "Bob";
.Ve
.Sp
\&\f(CW\*(C`B::Deparse,\-p\*(C'\fR will print
.Sp
.Vb 5
\&    if (($var & 0)) {
\&        print(\*(AqGimme an A!\*(Aq)
\&    };
\&    (print(($which ? $a : $b)), \*(Aq???\*(Aq);
\&    (($name = $ENV{\*(AqUSER\*(Aq}) or \*(Aq???\*(Aq)
.Ve
.Sp
which probably isn't what you intended (the \f(CW\*(Aq???\*(Aq\fR is a sign that
perl optimized away a constant value).
.IP "\fB\-P\fR" 4
.IX Item "-P"
Disable prototype checking.  With this option, all function calls are
deparsed as if no prototype was defined for them.  In other words,
.Sp
.Vb 1
\&    perl \-MO=Deparse,\-P \-e \*(Aqsub foo (\e@) { 1 } foo @x\*(Aq
.Ve
.Sp
will print
.Sp
.Vb 4
\&    sub foo (\e@) {
\&        1;
\&    }
\&    &foo(\e@x);
.Ve
.Sp
making clear how the parameters are actually passed to \f(CW\*(C`foo\*(C'\fR.
.IP "\fB\-q\fR" 4
.IX Item "-q"
Expand double-quoted strings into the corresponding combinations of
concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join.  For
instance, print
.Sp
.Vb 1
\&    print "Hello, $world, @ladies, \eu$gentlemen\eE, \eu\eL$me!";
.Ve
.Sp
as
.Sp
.Vb 2
\&    print \*(AqHello, \*(Aq . $world . \*(Aq, \*(Aq . join($", @ladies) . \*(Aq, \*(Aq
\&          . ucfirst($gentlemen) . \*(Aq, \*(Aq . ucfirst(lc $me . \*(Aq!\*(Aq);
.Ve
.Sp
Note that the expanded form represents the way perl handles such
constructions internally \*(-- this option actually turns off the reverse
translation that B::Deparse usually does.  On the other hand, note that
\&\f(CW\*(C`$x = "$y"\*(C'\fR is not the same as \f(CW\*(C`$x = $y\*(C'\fR: the former makes the value
of \f(CW$y\fR into a string before doing the assignment.
.IP "\fB\-s\fR\fI\s-1LETTERS\s0\fR" 4
.IX Item "-sLETTERS"
Tweak the style of B::Deparse's output.  The letters should follow
directly after the 's', with no space or punctuation.  The following
options are available:
.RS 4
.IP "\fBC\fR" 4
.IX Item "C"
Cuddle \f(CW\*(C`elsif\*(C'\fR, \f(CW\*(C`else\*(C'\fR, and \f(CW\*(C`continue\*(C'\fR blocks.  For example, print
.Sp
.Vb 5
\&    if (...) {
\&         ...
\&    } else {
\&         ...
\&    }
.Ve
.Sp
instead of
.Sp
.Vb 6
\&    if (...) {
\&         ...
\&    }
\&    else {
\&         ...
\&    }
.Ve
.Sp
The default is not to cuddle.
.IP "\fBi\fR\fI\s-1NUMBER\s0\fR" 4
.IX Item "iNUMBER"
Indent lines by multiples of \fI\s-1NUMBER\s0\fR columns.  The default is 4 columns.
.IP "\fBT\fR" 4
.IX Item "T"
Use tabs for each 8 columns of indent.  The default is to use only spaces.
For instance, if the style options are \fB\-si4T\fR, a line that's indented
3 times will be preceded by one tab and four spaces; if the options were
\&\fB\-si8T\fR, the same line would be preceded by three tabs.
.IP "\fBv\fR\fI\s-1STRING\s0\fR\fB.\fR" 4
.IX Item "vSTRING."
Print \fI\s-1STRING\s0\fR for the value of a constant that can't be determined
because it was optimized away (mnemonic: this happens when a constant
is used in \fBv\fRoid context).  The end of the string is marked by a period.
The string should be a valid perl expression, generally a constant.
Note that unless it's a number, it probably needs to be quoted, and on
a command line quotes need to be protected from the shell.  Some
conventional values include 0, 1, 42, '', 'foo', and
\&'Useless use of constant omitted' (which may need to be
\&\fB\-sv\*(L"'Useless use of constant omitted'.\*(R"\fR
or something similar depending on your shell).  The default is '???'.
If you're using B::Deparse on a module or other file that's require'd,
you shouldn't use a value that evaluates to false, since the customary
true constant at the end of a module will be in void context when the
file is compiled as a main program.
.RE
.RS 4
.RE
.IP "\fB\-x\fR\fI\s-1LEVEL\s0\fR" 4
.IX Item "-xLEVEL"
Expand conventional syntax constructions into equivalent ones that expose
their internal operation.  \fI\s-1LEVEL\s0\fR should be a digit, with higher values
meaning more expansion.  As with \fB\-q\fR, this actually involves turning off
special cases in B::Deparse's normal operations.
.Sp
If \fI\s-1LEVEL\s0\fR is at least 3, \f(CW\*(C`for\*(C'\fR loops will be translated into equivalent
while loops with continue blocks; for instance
.Sp
.Vb 3
\&    for ($i = 0; $i < 10; ++$i) {
\&        print $i;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    $i = 0;
\&    while ($i < 10) {
\&        print $i;
\&    } continue {
\&        ++$i
\&    }
.Ve
.Sp
Note that in a few cases this translation can't be perfectly carried back
into the source code \*(-- if the loop's initializer declares a my variable,
for instance, it won't have the correct scope outside of the loop.
.Sp
If \fI\s-1LEVEL\s0\fR is at least 5, \f(CW\*(C`use\*(C'\fR declarations will be translated into
\&\f(CW\*(C`BEGIN\*(C'\fR blocks containing calls to \f(CW\*(C`require\*(C'\fR and \f(CW\*(C`import\*(C'\fR; for
instance,
.Sp
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    sub BEGIN {
\&        require strict;
\&        do {
\&            \*(Aqstrict\*(Aq\->import(\*(Aqrefs\*(Aq)
\&        };
\&    }
.Ve
.Sp
If \fI\s-1LEVEL\s0\fR is at least 7, \f(CW\*(C`if\*(C'\fR statements will be translated into
equivalent expressions using \f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`?:\*(C'\fR and \f(CW\*(C`do {}\*(C'\fR; for instance
.Sp
.Vb 9
\&    print \*(Aqhi\*(Aq if $nice;
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    }
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    } else {
\&        print \*(Aqbye\*(Aq;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 3
\&    $nice and print \*(Aqhi\*(Aq;
\&    $nice and do { print \*(Aqhi\*(Aq };
\&    $nice ? do { print \*(Aqhi\*(Aq } : do { print \*(Aqbye\*(Aq };
.Ve
.Sp
Long sequences of elsifs will turn into nested ternary operators, which
B::Deparse doesn't know how to indent nicely.
.SH "USING B::Deparse AS A MODULE"
.IX Header "USING B::Deparse AS A MODULE"
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 4
\&    use B::Deparse;
\&    $deparse = B::Deparse\->new("\-p", "\-sC");
\&    $body = $deparse\->coderef2text(\e&func);
\&    eval "sub func $body"; # the inverse operation
.Ve
.SS "Description"
.IX Subsection "Description"
B::Deparse can also be used on a sub-by-sub basis from other perl
programs.
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $deparse = B::Deparse\->new(OPTIONS)
.Ve
.PP
Create an object to store the state of a deparsing operation and any
options.  The options are the same as those that can be given on the
command line (see \*(L"\s-1OPTIONS\*(R"\s0); options that are separated by commas
after \fB\-MO=Deparse\fR should be given as separate strings.
.SS "ambient_pragmas"
.IX Subsection "ambient_pragmas"
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqall\*(Aq, \*(Aq$[\*(Aq => $[);
.Ve
.PP
The compilation of a subroutine can be affected by a few compiler
directives, \fBpragmas\fR.  These are:
.IP "\(bu" 4
use strict;
.IP "\(bu" 4
use warnings;
.IP "\(bu" 4
Assigning to the special variable $[
.IP "\(bu" 4
use integer;
.IP "\(bu" 4
use bytes;
.IP "\(bu" 4
use utf8;
.IP "\(bu" 4
use re;
.PP
Ordinarily, if you use B::Deparse on a subroutine which has
been compiled in the presence of one or more of these pragmas,
the output will include statements to turn on the appropriate
directives.  So if you then compile the code returned by coderef2text,
it will behave the same way as the subroutine which you deparsed.
.PP
However, you may know that you intend to use the results in a
particular context, where some pragmas are already in scope.  In
this case, you use the \fBambient_pragmas\fR method to describe the
assumptions you wish to make.
.PP
Not all of the options currently have any useful effect.  See
\&\*(L"\s-1BUGS\*(R"\s0 for more details.
.PP
The parameters it accepts are:
.IP "strict" 4
.IX Item "strict"
Takes a string, possibly containing several values separated
by whitespace.  The special values \*(L"all\*(R" and \*(L"none\*(R" mean what you'd
expect.
.Sp
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqsubs refs\*(Aq);
.Ve
.IP "$[" 4
Takes a number, the value of the array base $[.
Cannot be non-zero on Perl 5.15.3 or later.
.IP "bytes" 4
.IX Item "bytes"
.PD 0
.IP "utf8" 4
.IX Item "utf8"
.IP "integer" 4
.IX Item "integer"
.PD
If the value is true, then the appropriate pragma is assumed to
be in the ambient scope, otherwise not.
.IP "re" 4
.IX Item "re"
Takes a string, possibly containing a whitespace-separated list of
values.  The values \*(L"all\*(R" and \*(L"none\*(R" are special.  It's also permissible
to pass an array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(re => \*(Aqeval\*(Aq);
.Ve
.IP "warnings" 4
.IX Item "warnings"
Takes a string, possibly containing a whitespace-separated list of
values.  The values \*(L"all\*(R" and \*(L"none\*(R" are special, again.  It's also
permissible to pass an array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(warnings => [qw[void io]]);
.Ve
.Sp
If one of the values is the string \*(L"\s-1FATAL\*(R",\s0 then all the warnings
in that list will be considered fatal, just as with the \fBwarnings\fR
pragma itself.  Should you need to specify that some warnings are
fatal, and others are merely enabled, you can pass the \fBwarnings\fR
parameter twice:
.Sp
.Vb 4
\&    $deparser\->ambient_pragmas(
\&        warnings => \*(Aqall\*(Aq,
\&        warnings => [FATAL => qw/void io/],
\&    );
.Ve
.Sp
See perllexwarn for more information about lexical warnings.
.IP "hint_bits" 4
.IX Item "hint_bits"
.PD 0
.IP "warning_bits" 4
.IX Item "warning_bits"
.PD
These two parameters are used to specify the ambient pragmas in
the format used by the special variables $^H and ${^WARNING_BITS}.
.Sp
They exist principally so that you can write code like:
.Sp
.Vb 7
\&    { my ($hint_bits, $warning_bits);
\&    BEGIN {($hint_bits, $warning_bits) = ($^H, ${^WARNING_BITS})}
\&    $deparser\->ambient_pragmas (
\&        hint_bits    => $hint_bits,
\&        warning_bits => $warning_bits,
\&        \*(Aq$[\*(Aq         => 0 + $[
\&    ); }
.Ve
.Sp
which specifies that the ambient pragmas are exactly those which
are in scope at the point of calling.
.IP "%^H" 4
.IX Item "%^H"
This parameter is used to specify the ambient pragmas which are
stored in the special hash %^H.
.SS "coderef2text"
.IX Subsection "coderef2text"
.Vb 2
\&    $body = $deparse\->coderef2text(\e&func)
\&    $body = $deparse\->coderef2text(sub ($$) { ... })
.Ve
.PP
Return source code for the body of a subroutine (a block, optionally
preceded by a prototype in parens), given a reference to the
sub.  Because a subroutine can have no names, or more than one name,
this method doesn't return a complete subroutine definition \*(-- if you
want to eval the result, you should prepend \*(L"sub subname \*(R", or \*(L"sub \*(R"
for an anonymous function constructor.  Unless the sub was defined in
the main:: package, the code will include a package declaration.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
The only pragmas to be completely supported are: \f(CW\*(C`use warnings\*(C'\fR,
\&\f(CW\*(C`use strict\*(C'\fR, \f(CW\*(C`use bytes\*(C'\fR, \f(CW\*(C`use integer\*(C'\fR
and \f(CW\*(C`use feature\*(C'\fR.  (\f(CW$[\fR, which
behaves like a pragma, is also supported.)
.Sp
Excepting those listed above, we're currently unable to guarantee that
B::Deparse will produce a pragma at the correct point in the program.
(Specifically, pragmas at the beginning of a block often appear right
before the start of the block instead.)
Since the effects of pragmas are often lexically scoped, this can mean
that the pragma holds sway over a different portion of the program
than in the input file.
.IP "\(bu" 4
In fact, the above is a specific instance of a more general problem:
we can't guarantee to produce \s-1BEGIN\s0 blocks or \f(CW\*(C`use\*(C'\fR declarations in
exactly the right place.  So if you use a module which affects compilation
(such as by over-riding keywords, overloading constants or whatever)
then the output code might not work as intended.
.Sp
This is the most serious outstanding problem, and will require some help
from the Perl core to fix.
.IP "\(bu" 4
Some constants don't print correctly either with or without \fB\-d\fR.
For instance, neither B::Deparse nor Data::Dumper know how to print
dual-valued scalars correctly, as in:
.Sp
.Vb 1
\&    use constant E2BIG => ($!=7); $y = E2BIG; print $y, 0+$y;
\&
\&    use constant H => { "#" => 1 }; H\->{"#"};
.Ve
.IP "\(bu" 4
An input file that uses source filtering probably won't be deparsed into
runnable code, because it will still include the \fBuse\fR declaration
for the source filtering module, even though the code that is
produced is already ordinary Perl which shouldn't be filtered again.
.IP "\(bu" 4
Optimised away statements are rendered as
\&'???'.  This includes statements that
have a compile-time side-effect, such as the obscure
.Sp
.Vb 1
\&    my $x if 0;
.Ve
.Sp
which is not, consequently, deparsed correctly.
.Sp
.Vb 3
\&    foreach my $i (@_) { 0 }
\&  =>
\&    foreach my $i (@_) { \*(Aq???\*(Aq }
.Ve
.IP "\(bu" 4
Lexical (my) variables declared in scopes external to a subroutine
appear in code2ref output text as package variables.  This is a tricky
problem, as perl has no native facility for referring to a lexical variable
defined within a different scope, although PadWalker is a good start.
.IP "\(bu" 4
There are probably many more bugs on non-ASCII platforms (\s-1EBCDIC\s0).
.IP "\(bu" 4
Lexical \f(CW\*(C`my\*(C'\fR subroutines are not deparsed properly at the moment.  They are
emitted as pure declarations, without their body; and the declaration may
appear in the wrong place (before any lexicals the body closes over, or
before the \f(CW\*(C`use feature\*(C'\fR declaration that permits use of this feature).
.Sp
We expect to resolve this before the lexical-subroutine feature is no longer
considered experimental.
.IP "\(bu" 4
Lexical \f(CW\*(C`state\*(C'\fR subroutines are not deparsed at all at the moment.
.Sp
We expect to resolve this before the lexical-subroutine feature is no longer
considered experimental.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant <smcc@CSUA.Berkeley.EDU>, based on an earlier version
by Malcolm Beattie <mbeattie@sable.ox.ac.uk>, with contributions from
Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell,
Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael
Garcia-Suarez.
                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Deparse5.16.3pm                           0100644 0001750 0001750 00000050226 12566207430 023466  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Deparse 3pm"
.TH B::Deparse 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Deparse \- Perl compiler backend to produce perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperl\fR \fB\-MO=Deparse\fR[\fB,\-d\fR][\fB,\-f\fR\fI\s-1FILE\s0\fR][\fB,\-p\fR][\fB,\-q\fR][\fB,\-l\fR]
        [\fB,\-s\fR\fI\s-1LETTERS\s0\fR][\fB,\-x\fR\fI\s-1LEVEL\s0\fR] \fIprog.pl\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
B::Deparse is a backend module for the Perl compiler that generates
perl source code, based on the internal compiled structure that perl
itself creates after parsing a program.  The output of B::Deparse won't
be exactly the same as the original source, since perl doesn't keep
track of comments or whitespace, and there isn't a one-to-one
correspondence between perl's syntactical constructions and their
compiled form, but it will often be close.  When you use the \fB\-p\fR
option, the output also includes parentheses even when they are not
required by precedence, which can make it easy to see if perl is
parsing your expressions the way you intended.
.PP
While B::Deparse goes to some lengths to try to figure out what your
original program was doing, some parts of the language can still trip
it up; it still fails even on some parts of Perl's own test suite.  If
you encounter a failure other than the most common ones described in
the \s-1BUGS\s0 section below, you can help contribute to B::Deparse's
ongoing development by submitting a bug report with a small
example.
.SH "OPTIONS"
.IX Header "OPTIONS"
As with all compiler backend options, these must follow directly after
the '\-MO=Deparse', separated by a comma but not any white space.
.IP "\fB\-d\fR" 4
.IX Item "-d"
Output data values (when they appear as constants) using Data::Dumper.
Without this option, B::Deparse will use some simple routines of its
own for the same purpose.  Currently, Data::Dumper is better for some
kinds of data (such as complex structures with sharing and
self-reference) while the built-in routines are better for others
(such as odd floating-point values).
.IP "\fB\-f\fR\fI\s-1FILE\s0\fR" 4
.IX Item "-fFILE"
Normally, B::Deparse deparses the main code of a program, and all the subs
defined in the same file.  To include subs defined in
other files, pass the \fB\-f\fR option with the filename.
You can pass the \fB\-f\fR option several times, to
include more than one secondary file.  (Most of the time you don't want to
use it at all.)  You can also use this option to include subs which are
defined in the scope of a \fB#line\fR directive with two parameters.
.IP "\fB\-l\fR" 4
.IX Item "-l"
Add '#line' declarations to the output based on the line and file
locations of the original code.
.IP "\fB\-p\fR" 4
.IX Item "-p"
Print extra parentheses.  Without this option, B::Deparse includes
parentheses in its output only when they are needed, based on the
structure of your program.  With \fB\-p\fR, it uses parentheses (almost)
whenever they would be legal.  This can be useful if you are used to
\&\s-1LISP\s0, or if you want to see how perl parses your input.  If you say
.Sp
.Vb 3
\&    if ($var & 0x7f == 65) {print "Gimme an A!"}
\&    print ($which ? $a : $b), "\en";
\&    $name = $ENV{USER} or "Bob";
.Ve
.Sp
\&\f(CW\*(C`B::Deparse,\-p\*(C'\fR will print
.Sp
.Vb 5
\&    if (($var & 0)) {
\&        print(\*(AqGimme an A!\*(Aq)
\&    };
\&    (print(($which ? $a : $b)), \*(Aq???\*(Aq);
\&    (($name = $ENV{\*(AqUSER\*(Aq}) or \*(Aq???\*(Aq)
.Ve
.Sp
which probably isn't what you intended (the \f(CW\*(Aq???\*(Aq\fR is a sign that
perl optimized away a constant value).
.IP "\fB\-P\fR" 4
.IX Item "-P"
Disable prototype checking.  With this option, all function calls are
deparsed as if no prototype was defined for them.  In other words,
.Sp
.Vb 1
\&    perl \-MO=Deparse,\-P \-e \*(Aqsub foo (\e@) { 1 } foo @x\*(Aq
.Ve
.Sp
will print
.Sp
.Vb 4
\&    sub foo (\e@) {
\&        1;
\&    }
\&    &foo(\e@x);
.Ve
.Sp
making clear how the parameters are actually passed to \f(CW\*(C`foo\*(C'\fR.
.IP "\fB\-q\fR" 4
.IX Item "-q"
Expand double-quoted strings into the corresponding combinations of
concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join.  For
instance, print
.Sp
.Vb 1
\&    print "Hello, $world, @ladies, \eu$gentlemen\eE, \eu\eL$me!";
.Ve
.Sp
as
.Sp
.Vb 2
\&    print \*(AqHello, \*(Aq . $world . \*(Aq, \*(Aq . join($", @ladies) . \*(Aq, \*(Aq
\&          . ucfirst($gentlemen) . \*(Aq, \*(Aq . ucfirst(lc $me . \*(Aq!\*(Aq);
.Ve
.Sp
Note that the expanded form represents the way perl handles such
constructions internally \*(-- this option actually turns off the reverse
translation that B::Deparse usually does.  On the other hand, note that
\&\f(CW\*(C`$x = "$y"\*(C'\fR is not the same as \f(CW\*(C`$x = $y\*(C'\fR: the former makes the value
of \f(CW$y\fR into a string before doing the assignment.
.IP "\fB\-s\fR\fI\s-1LETTERS\s0\fR" 4
.IX Item "-sLETTERS"
Tweak the style of B::Deparse's output.  The letters should follow
directly after the 's', with no space or punctuation.  The following
options are available:
.RS 4
.IP "\fBC\fR" 4
.IX Item "C"
Cuddle \f(CW\*(C`elsif\*(C'\fR, \f(CW\*(C`else\*(C'\fR, and \f(CW\*(C`continue\*(C'\fR blocks.  For example, print
.Sp
.Vb 5
\&    if (...) {
\&         ...
\&    } else {
\&         ...
\&    }
.Ve
.Sp
instead of
.Sp
.Vb 6
\&    if (...) {
\&         ...
\&    }
\&    else {
\&         ...
\&    }
.Ve
.Sp
The default is not to cuddle.
.IP "\fBi\fR\fI\s-1NUMBER\s0\fR" 4
.IX Item "iNUMBER"
Indent lines by multiples of \fI\s-1NUMBER\s0\fR columns.  The default is 4 columns.
.IP "\fBT\fR" 4
.IX Item "T"
Use tabs for each 8 columns of indent.  The default is to use only spaces.
For instance, if the style options are \fB\-si4T\fR, a line that's indented
3 times will be preceded by one tab and four spaces; if the options were
\&\fB\-si8T\fR, the same line would be preceded by three tabs.
.IP "\fBv\fR\fI\s-1STRING\s0\fR\fB.\fR" 4
.IX Item "vSTRING."
Print \fI\s-1STRING\s0\fR for the value of a constant that can't be determined
because it was optimized away (mnemonic: this happens when a constant
is used in \fBv\fRoid context).  The end of the string is marked by a period.
The string should be a valid perl expression, generally a constant.
Note that unless it's a number, it probably needs to be quoted, and on
a command line quotes need to be protected from the shell.  Some
conventional values include 0, 1, 42, '', 'foo', and
\&'Useless use of constant omitted' (which may need to be
\&\fB\-sv\*(L"'Useless use of constant omitted'.\*(R"\fR
or something similar depending on your shell).  The default is '???'.
If you're using B::Deparse on a module or other file that's require'd,
you shouldn't use a value that evaluates to false, since the customary
true constant at the end of a module will be in void context when the
file is compiled as a main program.
.RE
.RS 4
.RE
.IP "\fB\-x\fR\fI\s-1LEVEL\s0\fR" 4
.IX Item "-xLEVEL"
Expand conventional syntax constructions into equivalent ones that expose
their internal operation.  \fI\s-1LEVEL\s0\fR should be a digit, with higher values
meaning more expansion.  As with \fB\-q\fR, this actually involves turning off
special cases in B::Deparse's normal operations.
.Sp
If \fI\s-1LEVEL\s0\fR is at least 3, \f(CW\*(C`for\*(C'\fR loops will be translated into equivalent
while loops with continue blocks; for instance
.Sp
.Vb 3
\&    for ($i = 0; $i < 10; ++$i) {
\&        print $i;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    $i = 0;
\&    while ($i < 10) {
\&        print $i;
\&    } continue {
\&        ++$i
\&    }
.Ve
.Sp
Note that in a few cases this translation can't be perfectly carried back
into the source code \*(-- if the loop's initializer declares a my variable,
for instance, it won't have the correct scope outside of the loop.
.Sp
If \fI\s-1LEVEL\s0\fR is at least 5, \f(CW\*(C`use\*(C'\fR declarations will be translated into
\&\f(CW\*(C`BEGIN\*(C'\fR blocks containing calls to \f(CW\*(C`require\*(C'\fR and \f(CW\*(C`import\*(C'\fR; for
instance,
.Sp
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    sub BEGIN {
\&        require strict;
\&        do {
\&            \*(Aqstrict\*(Aq\->import(\*(Aqrefs\*(Aq)
\&        };
\&    }
.Ve
.Sp
If \fI\s-1LEVEL\s0\fR is at least 7, \f(CW\*(C`if\*(C'\fR statements will be translated into
equivalent expressions using \f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`?:\*(C'\fR and \f(CW\*(C`do {}\*(C'\fR; for instance
.Sp
.Vb 9
\&    print \*(Aqhi\*(Aq if $nice;
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    }
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    } else {
\&        print \*(Aqbye\*(Aq;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 3
\&    $nice and print \*(Aqhi\*(Aq;
\&    $nice and do { print \*(Aqhi\*(Aq };
\&    $nice ? do { print \*(Aqhi\*(Aq } : do { print \*(Aqbye\*(Aq };
.Ve
.Sp
Long sequences of elsifs will turn into nested ternary operators, which
B::Deparse doesn't know how to indent nicely.
.SH "USING B::Deparse AS A MODULE"
.IX Header "USING B::Deparse AS A MODULE"
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 4
\&    use B::Deparse;
\&    $deparse = B::Deparse\->new("\-p", "\-sC");
\&    $body = $deparse\->coderef2text(\e&func);
\&    eval "sub func $body"; # the inverse operation
.Ve
.SS "Description"
.IX Subsection "Description"
B::Deparse can also be used on a sub-by-sub basis from other perl
programs.
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $deparse = B::Deparse\->new(OPTIONS)
.Ve
.PP
Create an object to store the state of a deparsing operation and any
options.  The options are the same as those that can be given on the
command line (see \*(L"\s-1OPTIONS\s0\*(R"); options that are separated by commas
after \fB\-MO=Deparse\fR should be given as separate strings.
.SS "ambient_pragmas"
.IX Subsection "ambient_pragmas"
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqall\*(Aq, \*(Aq$[\*(Aq => $[);
.Ve
.PP
The compilation of a subroutine can be affected by a few compiler
directives, \fBpragmas\fR.  These are:
.IP "\(bu" 4
use strict;
.IP "\(bu" 4
use warnings;
.IP "\(bu" 4
Assigning to the special variable $[
.IP "\(bu" 4
use integer;
.IP "\(bu" 4
use bytes;
.IP "\(bu" 4
use utf8;
.IP "\(bu" 4
use re;
.PP
Ordinarily, if you use B::Deparse on a subroutine which has
been compiled in the presence of one or more of these pragmas,
the output will include statements to turn on the appropriate
directives.  So if you then compile the code returned by coderef2text,
it will behave the same way as the subroutine which you deparsed.
.PP
However, you may know that you intend to use the results in a
particular context, where some pragmas are already in scope.  In
this case, you use the \fBambient_pragmas\fR method to describe the
assumptions you wish to make.
.PP
Not all of the options currently have any useful effect.  See
\&\*(L"\s-1BUGS\s0\*(R" for more details.
.PP
The parameters it accepts are:
.IP "strict" 4
.IX Item "strict"
Takes a string, possibly containing several values separated
by whitespace.  The special values \*(L"all\*(R" and \*(L"none\*(R" mean what you'd
expect.
.Sp
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqsubs refs\*(Aq);
.Ve
.IP "$[" 4
Takes a number, the value of the array base $[.
Cannot be non-zero on Perl 5.15.3 or later.
.IP "bytes" 4
.IX Item "bytes"
.PD 0
.IP "utf8" 4
.IX Item "utf8"
.IP "integer" 4
.IX Item "integer"
.PD
If the value is true, then the appropriate pragma is assumed to
be in the ambient scope, otherwise not.
.IP "re" 4
.IX Item "re"
Takes a string, possibly containing a whitespace-separated list of
values.  The values \*(L"all\*(R" and \*(L"none\*(R" are special.  It's also permissible
to pass an array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(re => \*(Aqeval\*(Aq);
.Ve
.IP "warnings" 4
.IX Item "warnings"
Takes a string, possibly containing a whitespace-separated list of
values.  The values \*(L"all\*(R" and \*(L"none\*(R" are special, again.  It's also
permissible to pass an array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(warnings => [qw[void io]]);
.Ve
.Sp
If one of the values is the string \*(L"\s-1FATAL\s0\*(R", then all the warnings
in that list will be considered fatal, just as with the \fBwarnings\fR
pragma itself.  Should you need to specify that some warnings are
fatal, and others are merely enabled, you can pass the \fBwarnings\fR
parameter twice:
.Sp
.Vb 4
\&    $deparser\->ambient_pragmas(
\&        warnings => \*(Aqall\*(Aq,
\&        warnings => [FATAL => qw/void io/],
\&    );
.Ve
.Sp
See perllexwarn for more information about lexical warnings.
.IP "hint_bits" 4
.IX Item "hint_bits"
.PD 0
.IP "warning_bits" 4
.IX Item "warning_bits"
.PD
These two parameters are used to specify the ambient pragmas in
the format used by the special variables $^H and ${^WARNING_BITS}.
.Sp
They exist principally so that you can write code like:
.Sp
.Vb 7
\&    { my ($hint_bits, $warning_bits);
\&    BEGIN {($hint_bits, $warning_bits) = ($^H, ${^WARNING_BITS})}
\&    $deparser\->ambient_pragmas (
\&        hint_bits    => $hint_bits,
\&        warning_bits => $warning_bits,
\&        \*(Aq$[\*(Aq         => 0 + $[
\&    ); }
.Ve
.Sp
which specifies that the ambient pragmas are exactly those which
are in scope at the point of calling.
.IP "%^H" 4
.IX Item "%^H"
This parameter is used to specify the ambient pragmas which are
stored in the special hash %^H.
.SS "coderef2text"
.IX Subsection "coderef2text"
.Vb 2
\&    $body = $deparse\->coderef2text(\e&func)
\&    $body = $deparse\->coderef2text(sub ($$) { ... })
.Ve
.PP
Return source code for the body of a subroutine (a block, optionally
preceded by a prototype in parens), given a reference to the
sub.  Because a subroutine can have no names, or more than one name,
this method doesn't return a complete subroutine definition \*(-- if you
want to eval the result, you should prepend \*(L"sub subname \*(R", or \*(L"sub \*(R"
for an anonymous function constructor.  Unless the sub was defined in
the main:: package, the code will include a package declaration.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
The only pragmas to be completely supported are: \f(CW\*(C`use warnings\*(C'\fR,
\&\f(CW\*(C`use strict\*(C'\fR, \f(CW\*(C`use bytes\*(C'\fR, \f(CW\*(C`use integer\*(C'\fR
and \f(CW\*(C`use feature\*(C'\fR.  (\f(CW$[\fR, which
behaves like a pragma, is also supported.)
.Sp
Excepting those listed above, we're currently unable to guarantee that
B::Deparse will produce a pragma at the correct point in the program.
(Specifically, pragmas at the beginning of a block often appear right
before the start of the block instead.)
Since the effects of pragmas are often lexically scoped, this can mean
that the pragma holds sway over a different portion of the program
than in the input file.
.IP "\(bu" 4
In fact, the above is a specific instance of a more general problem:
we can't guarantee to produce \s-1BEGIN\s0 blocks or \f(CW\*(C`use\*(C'\fR declarations in
exactly the right place.  So if you use a module which affects compilation
(such as by over-riding keywords, overloading constants or whatever)
then the output code might not work as intended.
.Sp
This is the most serious outstanding problem, and will require some help
from the Perl core to fix.
.IP "\(bu" 4
Some constants don't print correctly either with or without \fB\-d\fR.
For instance, neither B::Deparse nor Data::Dumper know how to print
dual-valued scalars correctly, as in:
.Sp
.Vb 1
\&    use constant E2BIG => ($!=7); $y = E2BIG; print $y, 0+$y;
\&
\&    use constant H => { "#" => 1 }; H\->{"#"};
.Ve
.IP "\(bu" 4
An input file that uses source filtering probably won't be deparsed into
runnable code, because it will still include the \fBuse\fR declaration
for the source filtering module, even though the code that is
produced is already ordinary Perl which shouldn't be filtered again.
.IP "\(bu" 4
Optimised away statements are rendered as
\&'???'.  This includes statements that
have a compile-time side-effect, such as the obscure
.Sp
.Vb 1
\&    my $x if 0;
.Ve
.Sp
which is not, consequently, deparsed correctly.
.Sp
.Vb 3
\&    foreach my $i (@_) { 0 }
\&  =>
\&    foreach my $i (@_) { \*(Aq???\*(Aq }
.Ve
.IP "\(bu" 4
Lexical (my) variables declared in scopes external to a subroutine
appear in code2ref output text as package variables.  This is a tricky
problem, as perl has no native facility for referring to a lexical variable
defined within a different scope, although PadWalker is a good start.
.IP "\(bu" 4
There are probably many more bugs on non-ASCII platforms (\s-1EBCDIC\s0).
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant <smcc@CSUA.Berkeley.EDU>, based on an earlier version
by Malcolm Beattie <mbeattie@sable.ox.ac.uk>, with contributions from
Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell,
Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael
Garcia-Suarez.
                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Deparse5.18.3pm                           0100644 0001750 0001750 00000051756 12566207451 023504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Deparse 3pm"
.TH B::Deparse 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Deparse \- Perl compiler backend to produce perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBperl\fR \fB\-MO=Deparse\fR[\fB,\-d\fR][\fB,\-f\fR\fI\s-1FILE\s0\fR][\fB,\-p\fR][\fB,\-q\fR][\fB,\-l\fR]
        [\fB,\-s\fR\fI\s-1LETTERS\s0\fR][\fB,\-x\fR\fI\s-1LEVEL\s0\fR] \fIprog.pl\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
B::Deparse is a backend module for the Perl compiler that generates
perl source code, based on the internal compiled structure that perl
itself creates after parsing a program.  The output of B::Deparse won't
be exactly the same as the original source, since perl doesn't keep
track of comments or whitespace, and there isn't a one-to-one
correspondence between perl's syntactical constructions and their
compiled form, but it will often be close.  When you use the \fB\-p\fR
option, the output also includes parentheses even when they are not
required by precedence, which can make it easy to see if perl is
parsing your expressions the way you intended.
.PP
While B::Deparse goes to some lengths to try to figure out what your
original program was doing, some parts of the language can still trip
it up; it still fails even on some parts of Perl's own test suite.  If
you encounter a failure other than the most common ones described in
the \s-1BUGS\s0 section below, you can help contribute to B::Deparse's
ongoing development by submitting a bug report with a small
example.
.SH "OPTIONS"
.IX Header "OPTIONS"
As with all compiler backend options, these must follow directly after
the '\-MO=Deparse', separated by a comma but not any white space.
.IP "\fB\-d\fR" 4
.IX Item "-d"
Output data values (when they appear as constants) using Data::Dumper.
Without this option, B::Deparse will use some simple routines of its
own for the same purpose.  Currently, Data::Dumper is better for some
kinds of data (such as complex structures with sharing and
self-reference) while the built-in routines are better for others
(such as odd floating-point values).
.IP "\fB\-f\fR\fI\s-1FILE\s0\fR" 4
.IX Item "-fFILE"
Normally, B::Deparse deparses the main code of a program, and all the subs
defined in the same file.  To include subs defined in
other files, pass the \fB\-f\fR option with the filename.
You can pass the \fB\-f\fR option several times, to
include more than one secondary file.  (Most of the time you don't want to
use it at all.)  You can also use this option to include subs which are
defined in the scope of a \fB#line\fR directive with two parameters.
.IP "\fB\-l\fR" 4
.IX Item "-l"
Add '#line' declarations to the output based on the line and file
locations of the original code.
.IP "\fB\-p\fR" 4
.IX Item "-p"
Print extra parentheses.  Without this option, B::Deparse includes
parentheses in its output only when they are needed, based on the
structure of your program.  With \fB\-p\fR, it uses parentheses (almost)
whenever they would be legal.  This can be useful if you are used to
\&\s-1LISP,\s0 or if you want to see how perl parses your input.  If you say
.Sp
.Vb 3
\&    if ($var & 0x7f == 65) {print "Gimme an A!"}
\&    print ($which ? $a : $b), "\en";
\&    $name = $ENV{USER} or "Bob";
.Ve
.Sp
\&\f(CW\*(C`B::Deparse,\-p\*(C'\fR will print
.Sp
.Vb 5
\&    if (($var & 0)) {
\&        print(\*(AqGimme an A!\*(Aq)
\&    };
\&    (print(($which ? $a : $b)), \*(Aq???\*(Aq);
\&    (($name = $ENV{\*(AqUSER\*(Aq}) or \*(Aq???\*(Aq)
.Ve
.Sp
which probably isn't what you intended (the \f(CW\*(Aq???\*(Aq\fR is a sign that
perl optimized away a constant value).
.IP "\fB\-P\fR" 4
.IX Item "-P"
Disable prototype checking.  With this option, all function calls are
deparsed as if no prototype was defined for them.  In other words,
.Sp
.Vb 1
\&    perl \-MO=Deparse,\-P \-e \*(Aqsub foo (\e@) { 1 } foo @x\*(Aq
.Ve
.Sp
will print
.Sp
.Vb 4
\&    sub foo (\e@) {
\&        1;
\&    }
\&    &foo(\e@x);
.Ve
.Sp
making clear how the parameters are actually passed to \f(CW\*(C`foo\*(C'\fR.
.IP "\fB\-q\fR" 4
.IX Item "-q"
Expand double-quoted strings into the corresponding combinations of
concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join.  For
instance, print
.Sp
.Vb 1
\&    print "Hello, $world, @ladies, \eu$gentlemen\eE, \eu\eL$me!";
.Ve
.Sp
as
.Sp
.Vb 2
\&    print \*(AqHello, \*(Aq . $world . \*(Aq, \*(Aq . join($", @ladies) . \*(Aq, \*(Aq
\&          . ucfirst($gentlemen) . \*(Aq, \*(Aq . ucfirst(lc $me . \*(Aq!\*(Aq);
.Ve
.Sp
Note that the expanded form represents the way perl handles such
constructions internally \*(-- this option actually turns off the reverse
translation that B::Deparse usually does.  On the other hand, note that
\&\f(CW\*(C`$x = "$y"\*(C'\fR is not the same as \f(CW\*(C`$x = $y\*(C'\fR: the former makes the value
of \f(CW$y\fR into a string before doing the assignment.
.IP "\fB\-s\fR\fI\s-1LETTERS\s0\fR" 4
.IX Item "-sLETTERS"
Tweak the style of B::Deparse's output.  The letters should follow
directly after the 's', with no space or punctuation.  The following
options are available:
.RS 4
.IP "\fBC\fR" 4
.IX Item "C"
Cuddle \f(CW\*(C`elsif\*(C'\fR, \f(CW\*(C`else\*(C'\fR, and \f(CW\*(C`continue\*(C'\fR blocks.  For example, print
.Sp
.Vb 5
\&    if (...) {
\&         ...
\&    } else {
\&         ...
\&    }
.Ve
.Sp
instead of
.Sp
.Vb 6
\&    if (...) {
\&         ...
\&    }
\&    else {
\&         ...
\&    }
.Ve
.Sp
The default is not to cuddle.
.IP "\fBi\fR\fI\s-1NUMBER\s0\fR" 4
.IX Item "iNUMBER"
Indent lines by multiples of \fI\s-1NUMBER\s0\fR columns.  The default is 4 columns.
.IP "\fBT\fR" 4
.IX Item "T"
Use tabs for each 8 columns of indent.  The default is to use only spaces.
For instance, if the style options are \fB\-si4T\fR, a line that's indented
3 times will be preceded by one tab and four spaces; if the options were
\&\fB\-si8T\fR, the same line would be preceded by three tabs.
.IP "\fBv\fR\fI\s-1STRING\s0\fR\fB.\fR" 4
.IX Item "vSTRING."
Print \fI\s-1STRING\s0\fR for the value of a constant that can't be determined
because it was optimized away (mnemonic: this happens when a constant
is used in \fBv\fRoid context).  The end of the string is marked by a period.
The string should be a valid perl expression, generally a constant.
Note that unless it's a number, it probably needs to be quoted, and on
a command line quotes need to be protected from the shell.  Some
conventional values include 0, 1, 42, '', 'foo', and
\&'Useless use of constant omitted' (which may need to be
\&\fB\-sv\*(L"'Useless use of constant omitted'.\*(R"\fR
or something similar depending on your shell).  The default is '???'.
If you're using B::Deparse on a module or other file that's require'd,
you shouldn't use a value that evaluates to false, since the customary
true constant at the end of a module will be in void context when the
file is compiled as a main program.
.RE
.RS 4
.RE
.IP "\fB\-x\fR\fI\s-1LEVEL\s0\fR" 4
.IX Item "-xLEVEL"
Expand conventional syntax constructions into equivalent ones that expose
their internal operation.  \fI\s-1LEVEL\s0\fR should be a digit, with higher values
meaning more expansion.  As with \fB\-q\fR, this actually involves turning off
special cases in B::Deparse's normal operations.
.Sp
If \fI\s-1LEVEL\s0\fR is at least 3, \f(CW\*(C`for\*(C'\fR loops will be translated into equivalent
while loops with continue blocks; for instance
.Sp
.Vb 3
\&    for ($i = 0; $i < 10; ++$i) {
\&        print $i;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    $i = 0;
\&    while ($i < 10) {
\&        print $i;
\&    } continue {
\&        ++$i
\&    }
.Ve
.Sp
Note that in a few cases this translation can't be perfectly carried back
into the source code \*(-- if the loop's initializer declares a my variable,
for instance, it won't have the correct scope outside of the loop.
.Sp
If \fI\s-1LEVEL\s0\fR is at least 5, \f(CW\*(C`use\*(C'\fR declarations will be translated into
\&\f(CW\*(C`BEGIN\*(C'\fR blocks containing calls to \f(CW\*(C`require\*(C'\fR and \f(CW\*(C`import\*(C'\fR; for
instance,
.Sp
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.Sp
turns into
.Sp
.Vb 6
\&    sub BEGIN {
\&        require strict;
\&        do {
\&            \*(Aqstrict\*(Aq\->import(\*(Aqrefs\*(Aq)
\&        };
\&    }
.Ve
.Sp
If \fI\s-1LEVEL\s0\fR is at least 7, \f(CW\*(C`if\*(C'\fR statements will be translated into
equivalent expressions using \f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`?:\*(C'\fR and \f(CW\*(C`do {}\*(C'\fR; for instance
.Sp
.Vb 9
\&    print \*(Aqhi\*(Aq if $nice;
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    }
\&    if ($nice) {
\&        print \*(Aqhi\*(Aq;
\&    } else {
\&        print \*(Aqbye\*(Aq;
\&    }
.Ve
.Sp
turns into
.Sp
.Vb 3
\&    $nice and print \*(Aqhi\*(Aq;
\&    $nice and do { print \*(Aqhi\*(Aq };
\&    $nice ? do { print \*(Aqhi\*(Aq } : do { print \*(Aqbye\*(Aq };
.Ve
.Sp
Long sequences of elsifs will turn into nested ternary operators, which
B::Deparse doesn't know how to indent nicely.
.SH "USING B::Deparse AS A MODULE"
.IX Header "USING B::Deparse AS A MODULE"
.SS "Synopsis"
.IX Subsection "Synopsis"
.Vb 4
\&    use B::Deparse;
\&    $deparse = B::Deparse\->new("\-p", "\-sC");
\&    $body = $deparse\->coderef2text(\e&func);
\&    eval "sub func $body"; # the inverse operation
.Ve
.SS "Description"
.IX Subsection "Description"
B::Deparse can also be used on a sub-by-sub basis from other perl
programs.
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $deparse = B::Deparse\->new(OPTIONS)
.Ve
.PP
Create an object to store the state of a deparsing operation and any
options.  The options are the same as those that can be given on the
command line (see \*(L"\s-1OPTIONS\*(R"\s0); options that are separated by commas
after \fB\-MO=Deparse\fR should be given as separate strings.
.SS "ambient_pragmas"
.IX Subsection "ambient_pragmas"
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqall\*(Aq, \*(Aq$[\*(Aq => $[);
.Ve
.PP
The compilation of a subroutine can be affected by a few compiler
directives, \fBpragmas\fR.  These are:
.IP "\(bu" 4
use strict;
.IP "\(bu" 4
use warnings;
.IP "\(bu" 4
Assigning to the special variable $[
.IP "\(bu" 4
use integer;
.IP "\(bu" 4
use bytes;
.IP "\(bu" 4
use utf8;
.IP "\(bu" 4
use re;
.PP
Ordinarily, if you use B::Deparse on a subroutine which has
been compiled in the presence of one or more of these pragmas,
the output will include statements to turn on the appropriate
directives.  So if you then compile the code returned by coderef2text,
it will behave the same way as the subroutine which you deparsed.
.PP
However, you may know that you intend to use the results in a
particular context, where some pragmas are already in scope.  In
this case, you use the \fBambient_pragmas\fR method to describe the
assumptions you wish to make.
.PP
Not all of the options currently have any useful effect.  See
\&\*(L"\s-1BUGS\*(R"\s0 for more details.
.PP
The parameters it accepts are:
.IP "strict" 4
.IX Item "strict"
Takes a string, possibly containing several values separated
by whitespace.  The special values \*(L"all\*(R" and \*(L"none\*(R" mean what you'd
expect.
.Sp
.Vb 1
\&    $deparse\->ambient_pragmas(strict => \*(Aqsubs refs\*(Aq);
.Ve
.IP "$[" 4
Takes a number, the value of the array base $[.
Cannot be non-zero on Perl 5.15.3 or later.
.IP "bytes" 4
.IX Item "bytes"
.PD 0
.IP "utf8" 4
.IX Item "utf8"
.IP "integer" 4
.IX Item "integer"
.PD
If the value is true, then the appropriate pragma is assumed to
be in the ambient scope, otherwise not.
.IP "re" 4
.IX Item "re"
Takes a string, possibly containing a whitespace-separated list of
values.  The values \*(L"all\*(R" and \*(L"none\*(R" are special.  It's also permissible
to pass an array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(re => \*(Aqeval\*(Aq);
.Ve
.IP "warnings" 4
.IX Item "warnings"
Takes a string, possibly containing a whitespace-separated list of
values.  The values \*(L"all\*(R" and \*(L"none\*(R" are special, again.  It's also
permissible to pass an array reference here.
.Sp
.Vb 1
\&    $deparser\->ambient_pragmas(warnings => [qw[void io]]);
.Ve
.Sp
If one of the values is the string \*(L"\s-1FATAL\*(R",\s0 then all the warnings
in that list will be considered fatal, just as with the \fBwarnings\fR
pragma itself.  Should you need to specify that some warnings are
fatal, and others are merely enabled, you can pass the \fBwarnings\fR
parameter twice:
.Sp
.Vb 4
\&    $deparser\->ambient_pragmas(
\&        warnings => \*(Aqall\*(Aq,
\&        warnings => [FATAL => qw/void io/],
\&    );
.Ve
.Sp
See perllexwarn for more information about lexical warnings.
.IP "hint_bits" 4
.IX Item "hint_bits"
.PD 0
.IP "warning_bits" 4
.IX Item "warning_bits"
.PD
These two parameters are used to specify the ambient pragmas in
the format used by the special variables $^H and ${^WARNING_BITS}.
.Sp
They exist principally so that you can write code like:
.Sp
.Vb 7
\&    { my ($hint_bits, $warning_bits);
\&    BEGIN {($hint_bits, $warning_bits) = ($^H, ${^WARNING_BITS})}
\&    $deparser\->ambient_pragmas (
\&        hint_bits    => $hint_bits,
\&        warning_bits => $warning_bits,
\&        \*(Aq$[\*(Aq         => 0 + $[
\&    ); }
.Ve
.Sp
which specifies that the ambient pragmas are exactly those which
are in scope at the point of calling.
.IP "%^H" 4
.IX Item "%^H"
This parameter is used to specify the ambient pragmas which are
stored in the special hash %^H.
.SS "coderef2text"
.IX Subsection "coderef2text"
.Vb 2
\&    $body = $deparse\->coderef2text(\e&func)
\&    $body = $deparse\->coderef2text(sub ($$) { ... })
.Ve
.PP
Return source code for the body of a subroutine (a block, optionally
preceded by a prototype in parens), given a reference to the
sub.  Because a subroutine can have no names, or more than one name,
this method doesn't return a complete subroutine definition \*(-- if you
want to eval the result, you should prepend \*(L"sub subname \*(R", or \*(L"sub \*(R"
for an anonymous function constructor.  Unless the sub was defined in
the main:: package, the code will include a package declaration.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
The only pragmas to be completely supported are: \f(CW\*(C`use warnings\*(C'\fR,
\&\f(CW\*(C`use strict\*(C'\fR, \f(CW\*(C`use bytes\*(C'\fR, \f(CW\*(C`use integer\*(C'\fR
and \f(CW\*(C`use feature\*(C'\fR.  (\f(CW$[\fR, which
behaves like a pragma, is also supported.)
.Sp
Excepting those listed above, we're currently unable to guarantee that
B::Deparse will produce a pragma at the correct point in the program.
(Specifically, pragmas at the beginning of a block often appear right
before the start of the block instead.)
Since the effects of pragmas are often lexically scoped, this can mean
that the pragma holds sway over a different portion of the program
than in the input file.
.IP "\(bu" 4
In fact, the above is a specific instance of a more general problem:
we can't guarantee to produce \s-1BEGIN\s0 blocks or \f(CW\*(C`use\*(C'\fR declarations in
exactly the right place.  So if you use a module which affects compilation
(such as by over-riding keywords, overloading constants or whatever)
then the output code might not work as intended.
.Sp
This is the most serious outstanding problem, and will require some help
from the Perl core to fix.
.IP "\(bu" 4
Some constants don't print correctly either with or without \fB\-d\fR.
For instance, neither B::Deparse nor Data::Dumper know how to print
dual-valued scalars correctly, as in:
.Sp
.Vb 1
\&    use constant E2BIG => ($!=7); $y = E2BIG; print $y, 0+$y;
\&
\&    use constant H => { "#" => 1 }; H\->{"#"};
.Ve
.IP "\(bu" 4
An input file that uses source filtering probably won't be deparsed into
runnable code, because it will still include the \fBuse\fR declaration
for the source filtering module, even though the code that is
produced is already ordinary Perl which shouldn't be filtered again.
.IP "\(bu" 4
Optimised away statements are rendered as
\&'???'.  This includes statements that
have a compile-time side-effect, such as the obscure
.Sp
.Vb 1
\&    my $x if 0;
.Ve
.Sp
which is not, consequently, deparsed correctly.
.Sp
.Vb 3
\&    foreach my $i (@_) { 0 }
\&  =>
\&    foreach my $i (@_) { \*(Aq???\*(Aq }
.Ve
.IP "\(bu" 4
Lexical (my) variables declared in scopes external to a subroutine
appear in code2ref output text as package variables.  This is a tricky
problem, as perl has no native facility for referring to a lexical variable
defined within a different scope, although PadWalker is a good start.
.IP "\(bu" 4
There are probably many more bugs on non-ASCII platforms (\s-1EBCDIC\s0).
.IP "\(bu" 4
Lexical \f(CW\*(C`my\*(C'\fR subroutines are not deparsed properly at the moment.  They are
emitted as pure declarations, without their body; and the declaration may
appear in the wrong place (before any lexicals the body closes over, or
before the \f(CW\*(C`use feature\*(C'\fR declaration that permits use of this feature).
.Sp
We expect to resolve this before the lexical-subroutine feature is no longer
considered experimental.
.IP "\(bu" 4
Lexical \f(CW\*(C`state\*(C'\fR subroutines are not deparsed at all at the moment.
.Sp
We expect to resolve this before the lexical-subroutine feature is no longer
considered experimental.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stephen McCamant <smcc@CSUA.Berkeley.EDU>, based on an earlier version
by Malcolm Beattie <mbeattie@sable.ox.ac.uk>, with contributions from
Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell,
Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael
Garcia-Suarez.
                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::EndOfScope.3pm                     0100644 0001750 0001750 00000013660 12566242330 024745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::EndOfScope 3"
.TH B::Hooks::EndOfScope 3 "2014-01-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::EndOfScope \- Execute code after a scope finished compilation
.SH "VERSION"
.IX Header "VERSION"
version 0.13
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    on_scope_end { ... };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to execute code when perl finished compiling the
surrounding scope.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "on_scope_end"
.IX Subsection "on_scope_end"
.Vb 1
\&    on_scope_end { ... };
\&
\&    on_scope_end $code;
.Ve
.PP
Registers \f(CW$code\fR to be executed after the surrounding scope has been
compiled.
.PP
This is exported by default. See Sub::Exporter on how to customize it.
.SH "PURE-PERL MODE CAVEAT"
.IX Header "PURE-PERL MODE CAVEAT"
While Variable::Magic has access to some very dark sorcery to make it
possible to throw an exception from within a callback, the pure-perl
implementation does not have access to these hacks. Therefore, what
would have been a compile-time exception is instead converted to a
warning, and your execution will continue as if the exception never
happened.
.PP
To explicitly request an \s-1XS \s0(or \s-1PP\s0) implementation one has two choices. Either
to import from the desired implementation explicitly:
.PP
.Vb 3
\& use B::Hooks::EndOfScope::XS
\&   or
\& use B::Hooks::EndOfScope::PP
.Ve
.PP
or by setting \f(CW$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}\fR to either \f(CW\*(C`XS\*(C'\fR or
\&\f(CW\*(C`PP\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sub::Exporter
.PP
Variable::Magic
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Tomas Doran <bobtfish@bobtfish.net>
                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::EndOfScope5.16.3pm                 0100644 0001750 0001750 00000011332 12566242331 025252  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::EndOfScope 3"
.TH B::Hooks::EndOfScope 3 "2012-02-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::EndOfScope \- Execute code after a scope finished compilation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    on_scope_end { ... };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to execute code when perl finished compiling the
surrounding scope.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "on_scope_end"
.IX Subsection "on_scope_end"
.Vb 1
\&    on_scope_end { ... };
\&
\&    on_scope_end $code;
.Ve
.PP
Registers \f(CW$code\fR to be executed after the surrounding scope has been
compiled.
.PP
This is exported by default. See Sub::Exporter on how to customize it.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sub::Exporter
.PP
Variable::Magic
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::EndOfScope5.18.3pm                 0100644 0001750 0001750 00000013660 12566242330 025261  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::EndOfScope 3"
.TH B::Hooks::EndOfScope 3 "2014-01-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::EndOfScope \- Execute code after a scope finished compilation
.SH "VERSION"
.IX Header "VERSION"
version 0.13
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    on_scope_end { ... };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to execute code when perl finished compiling the
surrounding scope.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "on_scope_end"
.IX Subsection "on_scope_end"
.Vb 1
\&    on_scope_end { ... };
\&
\&    on_scope_end $code;
.Ve
.PP
Registers \f(CW$code\fR to be executed after the surrounding scope has been
compiled.
.PP
This is exported by default. See Sub::Exporter on how to customize it.
.SH "PURE-PERL MODE CAVEAT"
.IX Header "PURE-PERL MODE CAVEAT"
While Variable::Magic has access to some very dark sorcery to make it
possible to throw an exception from within a callback, the pure-perl
implementation does not have access to these hacks. Therefore, what
would have been a compile-time exception is instead converted to a
warning, and your execution will continue as if the exception never
happened.
.PP
To explicitly request an \s-1XS \s0(or \s-1PP\s0) implementation one has two choices. Either
to import from the desired implementation explicitly:
.PP
.Vb 3
\& use B::Hooks::EndOfScope::XS
\&   or
\& use B::Hooks::EndOfScope::PP
.Ve
.PP
or by setting \f(CW$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}\fR to either \f(CW\*(C`XS\*(C'\fR or
\&\f(CW\*(C`PP\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sub::Exporter
.PP
Variable::Magic
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Tomas Doran <bobtfish@bobtfish.net>
                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::EndOfScope::PP.3pm                 0100644 0001750 0001750 00000012215 12566242330 025364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::EndOfScope::PP 3"
.TH B::Hooks::EndOfScope::PP 3 "2014-01-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::EndOfScope::PP \- Execute code after a scope finished compilation \- PP implementation
.SH "VERSION"
.IX Header "VERSION"
version 0.13
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the pure-perl implementation of B::Hooks::EndOfScope based only on
modules available as part of the perl core. Its leaner sibling
B::Hooks::EndOfScope::XS will be automatically preferred if all
dependencies are available and \f(CW$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}\fR is
not set to \f(CW\*(AqPP\*(Aq\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "on_scope_end"
.IX Subsection "on_scope_end"
.Vb 1
\&    on_scope_end { ... };
\&
\&    on_scope_end $code;
.Ve
.PP
Registers \f(CW$code\fR to be executed after the surrounding scope has been
compiled.
.PP
This is exported by default. See Sub::Exporter on how to customize it.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::EndOfScope::PP5.18.3pm             0100644 0001750 0001750 00000012215 12566242330 025700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::EndOfScope::PP 3"
.TH B::Hooks::EndOfScope::PP 3 "2014-01-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::EndOfScope::PP \- Execute code after a scope finished compilation \- PP implementation
.SH "VERSION"
.IX Header "VERSION"
version 0.13
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the pure-perl implementation of B::Hooks::EndOfScope based only on
modules available as part of the perl core. Its leaner sibling
B::Hooks::EndOfScope::XS will be automatically preferred if all
dependencies are available and \f(CW$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}\fR is
not set to \f(CW\*(AqPP\*(Aq\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "on_scope_end"
.IX Subsection "on_scope_end"
.Vb 1
\&    on_scope_end { ... };
\&
\&    on_scope_end $code;
.Ve
.PP
Registers \f(CW$code\fR to be executed after the surrounding scope has been
compiled.
.PP
This is exported by default. See Sub::Exporter on how to customize it.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::EndOfScope::XS.3pm                 0100644 0001750 0001750 00000012036 12566242330 025400  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::EndOfScope::XS 3"
.TH B::Hooks::EndOfScope::XS 3 "2014-01-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::EndOfScope::XS \- Execute code after a scope finished compilation \- XS implementation
.SH "VERSION"
.IX Header "VERSION"
version 0.13
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the implementation of B::Hooks::EndOfScope based on
Variable::Magic, which is an \s-1XS\s0 module dependent on a compiler. It will
always be automatically preferred if Variable::Magic is available.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "on_scope_end"
.IX Subsection "on_scope_end"
.Vb 1
\&    on_scope_end { ... };
\&
\&    on_scope_end $code;
.Ve
.PP
Registers \f(CW$code\fR to be executed after the surrounding scope has been
compiled.
.PP
This is exported by default. See Sub::Exporter on how to customize it.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::EndOfScope::XS5.18.3pm             0100644 0001750 0001750 00000012036 12566242330 025714  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::EndOfScope::XS 3"
.TH B::Hooks::EndOfScope::XS 3 "2014-01-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::EndOfScope::XS \- Execute code after a scope finished compilation \- XS implementation
.SH "VERSION"
.IX Header "VERSION"
version 0.13
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the implementation of B::Hooks::EndOfScope based on
Variable::Magic, which is an \s-1XS\s0 module dependent on a compiler. It will
always be automatically preferred if Variable::Magic is available.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "on_scope_end"
.IX Subsection "on_scope_end"
.Vb 1
\&    on_scope_end { ... };
\&
\&    on_scope_end $code;
.Ve
.PP
Registers \f(CW$code\fR to be executed after the surrounding scope has been
compiled.
.PP
This is exported by default. See Sub::Exporter on how to customize it.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Florian Ragwitz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::OP::Check.3pm                      0100644 0001750 0001750 00000014562 12566242552 024430  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::OP::Check 3"
.TH B::Hooks::OP::Check 3 "2011-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::OP::Check \- Wrap OP check callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # include "hook_op_check.h"
\&
\&    STATIC OP *my_const_check_op (pTHX_ OP *op, void *user_data) {
\&        /* ... */
\&        return op;
\&    }
\&
\&    STATIC hook_op_check_id my_hook_id = 0;
\&
\&    void
\&    setup ()
\&        CODE:
\&            my_hook_id = hook_op_check (OP_CONST, my_const_check_op, NULL);
\&
\&    void
\&    teardown ()
\&        CODE:
\&            hook_op_check_remove (OP_CONST, my_hook_id);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a c api for \s-1XS\s0 modules to hook into the callbacks of
\&\f(CW\*(C`PL_check\*(C'\fR.
.PP
ExtUtils::Depends is used to export all functions for other \s-1XS\s0 modules to
use. Include the following in your Makefile.PL:
.PP
.Vb 5
\&    my $pkg = ExtUtils::Depends\->new(\*(AqYour::XSModule\*(Aq, \*(AqB::Hooks::OP::Check\*(Aq);
\&    WriteMakefile(
\&        ... # your normal makefile flags
\&        $pkg\->get_makefile_vars,
\&    );
.Ve
.PP
Your \s-1XS\s0 module can now include \f(CW\*(C`hook_op_check.h\*(C'\fR.
.SH "TYPES"
.IX Header "TYPES"
.SS "typedef \s-1OP\s0 *(*hook_op_check_cb) (pTHX_ \s-1OP\s0 *, void *);"
.IX Subsection "typedef OP *(*hook_op_check_cb) (pTHX_ OP *, void *);"
Type that callbacks need to implement.
.SS "typedef \s-1UV\s0 hook_op_check_id"
.IX Subsection "typedef UV hook_op_check_id"
Type to identify a callback.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "hook_op_check_id hook_op_check (opcode type, hook_op_check_cb cb, void *user_data)"
.IX Subsection "hook_op_check_id hook_op_check (opcode type, hook_op_check_cb cb, void *user_data)"
Register the callback \f(CW\*(C`cb\*(C'\fR to be called after the \f(CW\*(C`PL_check\*(C'\fR function for
opcodes of the given \f(CW\*(C`type\*(C'\fR. \f(CW\*(C`user_data\*(C'\fR will be passed to the callback as
the last argument. Returns an id that can be used to remove the callback later
on.
.SS "void *hook_op_check_remove (opcode type, hook_op_check_id id)"
.IX Subsection "void *hook_op_check_remove (opcode type, hook_op_check_id id)"
Remove the callback identified by \f(CW\*(C`id\*(C'\fR. Returns the userdata the callback had.
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2008 Florian Ragwitz
.PP
This module is free software.
.PP
You may distribute this code under the same terms as Perl itself.
                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::OP::Check5.16.3pm                  0100644 0001750 0001750 00000014241 12566242542 024733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::OP::Check 3"
.TH B::Hooks::OP::Check 3 "2011-09-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::OP::Check \- Wrap OP check callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # include "hook_op_check.h"
\&
\&    STATIC OP *my_const_check_op (pTHX_ OP *op, void *user_data) {
\&        /* ... */
\&        return op;
\&    }
\&
\&    STATIC hook_op_check_id my_hook_id = 0;
\&
\&    void
\&    setup ()
\&        CODE:
\&            my_hook_id = hook_op_check (OP_CONST, my_const_check_op, NULL);
\&
\&    void
\&    teardown ()
\&        CODE:
\&            hook_op_check_remove (OP_CONST, my_hook_id);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a c api for \s-1XS\s0 modules to hook into the callbacks of
\&\f(CW\*(C`PL_check\*(C'\fR.
.PP
ExtUtils::Depends is used to export all functions for other \s-1XS\s0 modules to
use. Include the following in your Makefile.PL:
.PP
.Vb 5
\&    my $pkg = ExtUtils::Depends\->new(\*(AqYour::XSModule\*(Aq, \*(AqB::Hooks::OP::Check\*(Aq);
\&    WriteMakefile(
\&        ... # your normal makefile flags
\&        $pkg\->get_makefile_vars,
\&    );
.Ve
.PP
Your \s-1XS\s0 module can now include \f(CW\*(C`hook_op_check.h\*(C'\fR.
.SH "TYPES"
.IX Header "TYPES"
.SS "typedef \s-1OP\s0 *(*hook_op_check_cb) (pTHX_ \s-1OP\s0 *, void *);"
.IX Subsection "typedef OP *(*hook_op_check_cb) (pTHX_ OP *, void *);"
Type that callbacks need to implement.
.SS "typedef \s-1UV\s0 hook_op_check_id"
.IX Subsection "typedef UV hook_op_check_id"
Type to identify a callback.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "hook_op_check_id hook_op_check (opcode type, hook_op_check_cb cb, void *user_data)"
.IX Subsection "hook_op_check_id hook_op_check (opcode type, hook_op_check_cb cb, void *user_data)"
Register the callback \f(CW\*(C`cb\*(C'\fR to be called after the \f(CW\*(C`PL_check\*(C'\fR function for
opcodes of the given \f(CW\*(C`type\*(C'\fR. \f(CW\*(C`user_data\*(C'\fR will be passed to the callback as
the last argument. Returns an id that can be used to remove the callback later
on.
.SS "void *hook_op_check_remove (opcode type, hook_op_check_id id)"
.IX Subsection "void *hook_op_check_remove (opcode type, hook_op_check_id id)"
Remove the callback identified by \f(CW\*(C`id\*(C'\fR. Returns the userdata the callback had.
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2008 Florian Ragwitz
.PP
This module is free software.
.PP
You may distribute this code under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Hooks::OP::Check5.18.3pm                  0100644 0001750 0001750 00000014562 12566242552 024744  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Hooks::OP::Check 3"
.TH B::Hooks::OP::Check 3 "2011-09-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Hooks::OP::Check \- Wrap OP check callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # include "hook_op_check.h"
\&
\&    STATIC OP *my_const_check_op (pTHX_ OP *op, void *user_data) {
\&        /* ... */
\&        return op;
\&    }
\&
\&    STATIC hook_op_check_id my_hook_id = 0;
\&
\&    void
\&    setup ()
\&        CODE:
\&            my_hook_id = hook_op_check (OP_CONST, my_const_check_op, NULL);
\&
\&    void
\&    teardown ()
\&        CODE:
\&            hook_op_check_remove (OP_CONST, my_hook_id);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a c api for \s-1XS\s0 modules to hook into the callbacks of
\&\f(CW\*(C`PL_check\*(C'\fR.
.PP
ExtUtils::Depends is used to export all functions for other \s-1XS\s0 modules to
use. Include the following in your Makefile.PL:
.PP
.Vb 5
\&    my $pkg = ExtUtils::Depends\->new(\*(AqYour::XSModule\*(Aq, \*(AqB::Hooks::OP::Check\*(Aq);
\&    WriteMakefile(
\&        ... # your normal makefile flags
\&        $pkg\->get_makefile_vars,
\&    );
.Ve
.PP
Your \s-1XS\s0 module can now include \f(CW\*(C`hook_op_check.h\*(C'\fR.
.SH "TYPES"
.IX Header "TYPES"
.SS "typedef \s-1OP\s0 *(*hook_op_check_cb) (pTHX_ \s-1OP\s0 *, void *);"
.IX Subsection "typedef OP *(*hook_op_check_cb) (pTHX_ OP *, void *);"
Type that callbacks need to implement.
.SS "typedef \s-1UV\s0 hook_op_check_id"
.IX Subsection "typedef UV hook_op_check_id"
Type to identify a callback.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "hook_op_check_id hook_op_check (opcode type, hook_op_check_cb cb, void *user_data)"
.IX Subsection "hook_op_check_id hook_op_check (opcode type, hook_op_check_cb cb, void *user_data)"
Register the callback \f(CW\*(C`cb\*(C'\fR to be called after the \f(CW\*(C`PL_check\*(C'\fR function for
opcodes of the given \f(CW\*(C`type\*(C'\fR. \f(CW\*(C`user_data\*(C'\fR will be passed to the callback as
the last argument. Returns an id that can be used to remove the callback later
on.
.SS "void *hook_op_check_remove (opcode type, hook_op_check_id id)"
.IX Subsection "void *hook_op_check_remove (opcode type, hook_op_check_id id)"
Remove the callback identified by \f(CW\*(C`id\*(C'\fR. Returns the userdata the callback had.
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Ragwitz <rafl@debian.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2008 Florian Ragwitz
.PP
This module is free software.
.PP
You may distribute this code under the same terms as Perl itself.
                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Lint.3pm                                  0100644 0001750 0001750 00000023646 12566207451 022510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Lint 3pm"
.TH B::Lint 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Lint \- Perl lint
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
perl \-MO=Lint[,OPTIONS] foo.pl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The B::Lint module is equivalent to an extended version of the \fB\-w\fR
option of \fBperl\fR. It is named after the program \fIlint\fR which carries
out a similar process for C programs.
.SH "OPTIONS AND LINT CHECKS"
.IX Header "OPTIONS AND LINT CHECKS"
Option words are separated by commas (not whitespace) and follow the
usual conventions of compiler backend options. Following any options
(indicated by a leading \fB\-\fR) come lint check arguments. Each such
argument (apart from the special \fBall\fR and \fBnone\fR options) is a
word representing one possible lint check (turning on that check) or
is \fBno-foo\fR (turning off that check). Before processing the check
arguments, a standard list of checks is turned on. Later options
override earlier ones. Available options are:
.IP "\fBmagic-diamond\fR" 8
.IX Item "magic-diamond"
Produces a warning whenever the magic \f(CW\*(C`<>\*(C'\fR readline is
used. Internally it uses perl's two-argument open which itself treats
filenames with special characters specially. This could allow
interestingly named files to have unexpected effects when reading.
.Sp
.Vb 2
\&  % touch \*(Aqrm *|\*(Aq
\&  % perl \-pe 1
.Ve
.Sp
The above creates a file named \f(CW\*(C`rm *|\*(C'\fR. When perl opens it with
\&\f(CW\*(C`<>\*(C'\fR it actually executes the shell program \f(CW\*(C`rm *\*(C'\fR. This
makes \f(CW\*(C`<>\*(C'\fR dangerous to use carelessly.
.IP "\fBcontext\fR" 8
.IX Item "context"
Produces a warning whenever an array is used in an implicit scalar
context. For example, both of the lines
.Sp
.Vb 2
\&    $foo = length(@bar);
\&    $foo = @bar;
.Ve
.Sp
will elicit a warning. Using an explicit \fB\f(BIscalar()\fB\fR silences the
warning. For example,
.Sp
.Vb 1
\&    $foo = scalar(@bar);
.Ve
.IP "\fBimplicit-read\fR and \fBimplicit-write\fR" 8
.IX Item "implicit-read and implicit-write"
These options produce a warning whenever an operation implicitly
reads or (respectively) writes to one of Perl's special variables.
For example, \fBimplicit-read\fR will warn about these:
.Sp
.Vb 1
\&    /foo/;
.Ve
.Sp
and \fBimplicit-write\fR will warn about these:
.Sp
.Vb 1
\&    s/foo/bar/;
.Ve
.Sp
Both \fBimplicit-read\fR and \fBimplicit-write\fR warn about this:
.Sp
.Vb 1
\&    for (@a) { ... }
.Ve
.IP "\fBbare-subs\fR" 8
.IX Item "bare-subs"
This option warns whenever a bareword is implicitly quoted, but is also
the name of a subroutine in the current package. Typical mistakes that it will
trap are:
.Sp
.Vb 3
\&    use constant foo => \*(Aqbar\*(Aq;
\&    @a = ( foo => 1 );
\&    $b{foo} = 2;
.Ve
.Sp
Neither of these will do what a naive user would expect.
.IP "\fBdollar-underscore\fR" 8
.IX Item "dollar-underscore"
This option warns whenever \f(CW$_\fR is used either explicitly anywhere or
as the implicit argument of a \fBprint\fR statement.
.IP "\fBprivate-names\fR" 8
.IX Item "private-names"
This option warns on each use of any variable, subroutine or
method name that lives in a non-current package but begins with
an underscore (\*(L"_\*(R"). Warnings aren't issued for the special case
of the single character name \*(L"_\*(R" by itself (e.g. \f(CW$_\fR and \f(CW@_\fR).
.IP "\fBundefined-subs\fR" 8
.IX Item "undefined-subs"
This option warns whenever an undefined subroutine is invoked.
This option will only catch explicitly invoked subroutines such
as \f(CW\*(C`foo()\*(C'\fR and not indirect invocations such as \f(CW\*(C`&$subref()\*(C'\fR
or \f(CW\*(C`$obj\->meth()\*(C'\fR. Note that some programs or modules delay
definition of subs until runtime by means of the \s-1AUTOLOAD\s0
mechanism.
.IP "\fBregexp-variables\fR" 8
.IX Item "regexp-variables"
This option warns whenever one of the regexp variables \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR or \f(CW\*(C`$\*(Aq\*(C'\fR
is used. Any occurrence of any of these variables in your
program can slow your whole program down. See perlre for
details.
.IP "\fBall\fR" 8
.IX Item "all"
Turn all warnings on.
.IP "\fBnone\fR" 8
.IX Item "none"
Turn all warnings off.
.SH "NON LINT-CHECK OPTIONS"
.IX Header "NON LINT-CHECK OPTIONS"
.IP "\fB\-u Package\fR" 8
.IX Item "-u Package"
Normally, Lint only checks the main code of the program together
with all subs defined in package main. The \fB\-u\fR option lets you
include other package names whose subs are then checked by Lint.
.SH "EXTENDING LINT"
.IX Header "EXTENDING LINT"
Lint can be extended by with plugins. Lint uses Module::Pluggable
to find available plugins. Plugins are expected but not required to
inform Lint of which checks they are adding.
.PP
The \f(CW\*(C`B::Lint\->register_plugin( MyPlugin => \e@new_checks )\*(C'\fR method
adds the list of \f(CW@new_checks\fR to the list of valid checks. If your
module wasn't loaded by Module::Pluggable then your class name is
added to the list of plugins.
.PP
You must create a \f(CW\*(C`match( \e%checks )\*(C'\fR method in your plugin class or one
of its parents. It will be called on every op as a regular method call
with a hash ref of checks as its parameter.
.PP
The class methods \f(CW\*(C`B::Lint\->file\*(C'\fR and \f(CW\*(C`B::Lint\->line\*(C'\fR contain
the current filename and line number.
.PP
.Vb 3
\&  package Sample;
\&  use B::Lint;
\&  B::Lint\->register_plugin( Sample => [ \*(Aqgood_taste\*(Aq ] );
\&  
\&  sub match {
\&      my ( $op, $checks_href ) = shift @_;
\&      if ( $checks_href\->{good_taste} ) {
\&          ...
\&      }
\&  }
.Ve
.SH "TODO"
.IX Header "TODO"
.ie n .IP "while(<\s-1FH\s0>) stomps $_" 4
.el .IP "while(<\s-1FH\s0>) stomps \f(CW$_\fR" 4
.IX Item "while(<FH>) stomps $_"
.PD 0
.IP "strict oo" 4
.IX Item "strict oo"
.IP "unchecked system calls" 4
.IX Item "unchecked system calls"
.IP "more tests, validate against older perls" 4
.IX Item "more tests, validate against older perls"
.PD
.SH "BUGS"
.IX Header "BUGS"
This is only a very preliminary version.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, mbeattie@sable.ox.ac.uk.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Sebastien Aperghis-Tramoni \- bug fixes
                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Lint5.16.3pm                              0100644 0001750 0001750 00000023325 12566207430 023011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Lint 3pm"
.TH B::Lint 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Lint \- Perl lint
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
perl \-MO=Lint[,OPTIONS] foo.pl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The B::Lint module is equivalent to an extended version of the \fB\-w\fR
option of \fBperl\fR. It is named after the program \fIlint\fR which carries
out a similar process for C programs.
.SH "OPTIONS AND LINT CHECKS"
.IX Header "OPTIONS AND LINT CHECKS"
Option words are separated by commas (not whitespace) and follow the
usual conventions of compiler backend options. Following any options
(indicated by a leading \fB\-\fR) come lint check arguments. Each such
argument (apart from the special \fBall\fR and \fBnone\fR options) is a
word representing one possible lint check (turning on that check) or
is \fBno-foo\fR (turning off that check). Before processing the check
arguments, a standard list of checks is turned on. Later options
override earlier ones. Available options are:
.IP "\fBmagic-diamond\fR" 8
.IX Item "magic-diamond"
Produces a warning whenever the magic \f(CW\*(C`<>\*(C'\fR readline is
used. Internally it uses perl's two-argument open which itself treats
filenames with special characters specially. This could allow
interestingly named files to have unexpected effects when reading.
.Sp
.Vb 2
\&  % touch \*(Aqrm *|\*(Aq
\&  % perl \-pe 1
.Ve
.Sp
The above creates a file named \f(CW\*(C`rm *|\*(C'\fR. When perl opens it with
\&\f(CW\*(C`<>\*(C'\fR it actually executes the shell program \f(CW\*(C`rm *\*(C'\fR. This
makes \f(CW\*(C`<>\*(C'\fR dangerous to use carelessly.
.IP "\fBcontext\fR" 8
.IX Item "context"
Produces a warning whenever an array is used in an implicit scalar
context. For example, both of the lines
.Sp
.Vb 2
\&    $foo = length(@bar);
\&    $foo = @bar;
.Ve
.Sp
will elicit a warning. Using an explicit \fB\f(BIscalar()\fB\fR silences the
warning. For example,
.Sp
.Vb 1
\&    $foo = scalar(@bar);
.Ve
.IP "\fBimplicit-read\fR and \fBimplicit-write\fR" 8
.IX Item "implicit-read and implicit-write"
These options produce a warning whenever an operation implicitly
reads or (respectively) writes to one of Perl's special variables.
For example, \fBimplicit-read\fR will warn about these:
.Sp
.Vb 1
\&    /foo/;
.Ve
.Sp
and \fBimplicit-write\fR will warn about these:
.Sp
.Vb 1
\&    s/foo/bar/;
.Ve
.Sp
Both \fBimplicit-read\fR and \fBimplicit-write\fR warn about this:
.Sp
.Vb 1
\&    for (@a) { ... }
.Ve
.IP "\fBbare-subs\fR" 8
.IX Item "bare-subs"
This option warns whenever a bareword is implicitly quoted, but is also
the name of a subroutine in the current package. Typical mistakes that it will
trap are:
.Sp
.Vb 3
\&    use constant foo => \*(Aqbar\*(Aq;
\&    @a = ( foo => 1 );
\&    $b{foo} = 2;
.Ve
.Sp
Neither of these will do what a naive user would expect.
.IP "\fBdollar-underscore\fR" 8
.IX Item "dollar-underscore"
This option warns whenever \f(CW$_\fR is used either explicitly anywhere or
as the implicit argument of a \fBprint\fR statement.
.IP "\fBprivate-names\fR" 8
.IX Item "private-names"
This option warns on each use of any variable, subroutine or
method name that lives in a non-current package but begins with
an underscore (\*(L"_\*(R"). Warnings aren't issued for the special case
of the single character name \*(L"_\*(R" by itself (e.g. \f(CW$_\fR and \f(CW@_\fR).
.IP "\fBundefined-subs\fR" 8
.IX Item "undefined-subs"
This option warns whenever an undefined subroutine is invoked.
This option will only catch explicitly invoked subroutines such
as \f(CW\*(C`foo()\*(C'\fR and not indirect invocations such as \f(CW\*(C`&$subref()\*(C'\fR
or \f(CW\*(C`$obj\->meth()\*(C'\fR. Note that some programs or modules delay
definition of subs until runtime by means of the \s-1AUTOLOAD\s0
mechanism.
.IP "\fBregexp-variables\fR" 8
.IX Item "regexp-variables"
This option warns whenever one of the regexp variables \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR or \f(CW\*(C`$\*(Aq\*(C'\fR
is used. Any occurrence of any of these variables in your
program can slow your whole program down. See perlre for
details.
.IP "\fBall\fR" 8
.IX Item "all"
Turn all warnings on.
.IP "\fBnone\fR" 8
.IX Item "none"
Turn all warnings off.
.SH "NON LINT-CHECK OPTIONS"
.IX Header "NON LINT-CHECK OPTIONS"
.IP "\fB\-u Package\fR" 8
.IX Item "-u Package"
Normally, Lint only checks the main code of the program together
with all subs defined in package main. The \fB\-u\fR option lets you
include other package names whose subs are then checked by Lint.
.SH "EXTENDING LINT"
.IX Header "EXTENDING LINT"
Lint can be extended by with plugins. Lint uses Module::Pluggable
to find available plugins. Plugins are expected but not required to
inform Lint of which checks they are adding.
.PP
The \f(CW\*(C`B::Lint\->register_plugin( MyPlugin => \e@new_checks )\*(C'\fR method
adds the list of \f(CW@new_checks\fR to the list of valid checks. If your
module wasn't loaded by Module::Pluggable then your class name is
added to the list of plugins.
.PP
You must create a \f(CW\*(C`match( \e%checks )\*(C'\fR method in your plugin class or one
of its parents. It will be called on every op as a regular method call
with a hash ref of checks as its parameter.
.PP
The class methods \f(CW\*(C`B::Lint\->file\*(C'\fR and \f(CW\*(C`B::Lint\->line\*(C'\fR contain
the current filename and line number.
.PP
.Vb 3
\&  package Sample;
\&  use B::Lint;
\&  B::Lint\->register_plugin( Sample => [ \*(Aqgood_taste\*(Aq ] );
\&  
\&  sub match {
\&      my ( $op, $checks_href ) = shift @_;
\&      if ( $checks_href\->{good_taste} ) {
\&          ...
\&      }
\&  }
.Ve
.SH "TODO"
.IX Header "TODO"
.ie n .IP "while(<\s-1FH\s0>) stomps $_" 4
.el .IP "while(<\s-1FH\s0>) stomps \f(CW$_\fR" 4
.IX Item "while(<FH>) stomps $_"
.PD 0
.IP "strict oo" 4
.IX Item "strict oo"
.IP "unchecked system calls" 4
.IX Item "unchecked system calls"
.IP "more tests, validate against older perls" 4
.IX Item "more tests, validate against older perls"
.PD
.SH "BUGS"
.IX Header "BUGS"
This is only a very preliminary version.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, mbeattie@sable.ox.ac.uk.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Sebastien Aperghis-Tramoni \- bug fixes
                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/B::Lint5.18.3pm                              0100644 0001750 0001750 00000023646 12566207451 023024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Lint 3pm"
.TH B::Lint 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Lint \- Perl lint
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
perl \-MO=Lint[,OPTIONS] foo.pl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The B::Lint module is equivalent to an extended version of the \fB\-w\fR
option of \fBperl\fR. It is named after the program \fIlint\fR which carries
out a similar process for C programs.
.SH "OPTIONS AND LINT CHECKS"
.IX Header "OPTIONS AND LINT CHECKS"
Option words are separated by commas (not whitespace) and follow the
usual conventions of compiler backend options. Following any options
(indicated by a leading \fB\-\fR) come lint check arguments. Each such
argument (apart from the special \fBall\fR and \fBnone\fR options) is a
word representing one possible lint check (turning on that check) or
is \fBno-foo\fR (turning off that check). Before processing the check
arguments, a standard list of checks is turned on. Later options
override earlier ones. Available options are:
.IP "\fBmagic-diamond\fR" 8
.IX Item "magic-diamond"
Produces a warning whenever the magic \f(CW\*(C`<>\*(C'\fR readline is
used. Internally it uses perl's two-argument open which itself treats
filenames with special characters specially. This could allow
interestingly named files to have unexpected effects when reading.
.Sp
.Vb 2
\&  % touch \*(Aqrm *|\*(Aq
\&  % perl \-pe 1
.Ve
.Sp
The above creates a file named \f(CW\*(C`rm *|\*(C'\fR. When perl opens it with
\&\f(CW\*(C`<>\*(C'\fR it actually executes the shell program \f(CW\*(C`rm *\*(C'\fR. This
makes \f(CW\*(C`<>\*(C'\fR dangerous to use carelessly.
.IP "\fBcontext\fR" 8
.IX Item "context"
Produces a warning whenever an array is used 