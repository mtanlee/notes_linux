;
#else
typedef struct CVodafoneAACDecMediaObject CVodafoneAACDecMediaObject;
#endif /* defined __cplusplus */
#endif /* defined __CVodafoneAACDecMediaObject_FWD_DEFINED__ */

#ifndef __CZuneAACCCDecMediaObject_FWD_DEFINED__
#define __CZuneAACCCDecMediaObject_FWD_DEFINED__
#ifdef __cplusplus
typedef class CZuneAACCCDecMediaObject CZuneAACCCDecMediaObject;
#else
typedef struct CZuneAACCCDecMediaObject CZuneAACCCDecMediaObject;
#endif /* defined __cplusplus */
#endif /* defined __CZuneAACCCDecMediaObject_FWD_DEFINED__ */

#ifndef __CNokiaAACCCDecMediaObject_FWD_DEFINED__
#define __CNokiaAACCCDecMediaObject_FWD_DEFINED__
#ifdef __cplusplus
typedef class CNokiaAACCCDecMediaObject CNokiaAACCCDecMediaObject;
#else
typedef struct CNokiaAACCCDecMediaObject CNokiaAACCCDecMediaObject;
#endif /* defined __cplusplus */
#endif /* defined __CNokiaAACCCDecMediaObject_FWD_DEFINED__ */

#ifndef __CVodafoneAACCCDecMediaObject_FWD_DEFINED__
#define __CVodafoneAACCCDecMediaObject_FWD_DEFINED__
#ifdef __cplusplus
typedef class CVodafoneAACCCDecMediaObject CVodafoneAACCCDecMediaObject;
#else
typedef struct CVodafoneAACCCDecMediaObject CVodafoneAACCCDecMediaObject;
#endif /* defined __cplusplus */
#endif /* defined __CVodafoneAACCCDecMediaObject_FWD_DEFINED__ */

#ifndef __CMPEG2EncoderDS_FWD_DEFINED__
#define __CMPEG2EncoderDS_FWD_DEFINED__
#ifdef __cplusplus
typedef class CMPEG2EncoderDS CMPEG2EncoderDS;
#else
typedef struct CMPEG2EncoderDS CMPEG2EncoderDS;
#endif /* defined __cplusplus */
#endif /* defined __CMPEG2EncoderDS_FWD_DEFINED__ */

#ifndef __CMPEG2EncoderVideoDS_FWD_DEFINED__
#define __CMPEG2EncoderVideoDS_FWD_DEFINED__
#ifdef __cplusplus
typedef class CMPEG2EncoderVideoDS CMPEG2EncoderVideoDS;
#else
typedef struct CMPEG2EncoderVideoDS CMPEG2EncoderVideoDS;
#endif /* defined __cplusplus */
#endif /* defined __CMPEG2EncoderVideoDS_FWD_DEFINED__ */

#ifndef __CMPEG2EncoderAudioDS_FWD_DEFINED__
#define __CMPEG2EncoderAudioDS_FWD_DEFINED__
#ifdef __cplusplus
typedef class CMPEG2EncoderAudioDS CMPEG2EncoderAudioDS;
#else
typedef struct CMPEG2EncoderAudioDS CMPEG2EncoderAudioDS;
#endif /* defined __cplusplus */
#endif /* defined __CMPEG2EncoderAudioDS_FWD_DEFINED__ */

#ifndef __CMPEG2AudDecoderDS_FWD_DEFINED__
#define __CMPEG2AudDecoderDS_FWD_DEFINED__
#ifdef __cplusplus
typedef class CMPEG2AudDecoderDS CMPEG2AudDecoderDS;
#else
typedef struct CMPEG2AudDecoderDS CMPEG2AudDecoderDS;
#endif /* defined __cplusplus */
#endif /* defined __CMPEG2AudDecoderDS_FWD_DEFINED__ */

#ifndef __CMPEG2VidDecoderDS_FWD_DEFINED__
#define __CMPEG2VidDecoderDS_FWD_DEFINED__
#ifdef __cplusplus
typedef class CMPEG2VidDecoderDS CMPEG2VidDecoderDS;
#else
typedef struct CMPEG2VidDecoderDS CMPEG2VidDecoderDS;
#endif /* defined __cplusplus */
#endif /* defined __CMPEG2VidDecoderDS_FWD_DEFINED__ */

#ifndef __CDTVAudDecoderDS_FWD_DEFINED__
#define __CDTVAudDecoderDS_FWD_DEFINED__
#ifdef __cplusplus
typedef class CDTVAudDecoderDS CDTVAudDecoderDS;
#else
typedef struct CDTVAudDecoderDS CDTVAudDecoderDS;
#endif /* defined __cplusplus */
#endif /* defined __CDTVAudDecoderDS_FWD_DEFINED__ */

#ifndef __CDTVVidDecoderDS_FWD_DEFINED__
#define __CDTVVidDecoderDS_FWD_DEFINED__
#ifdef __cplusplus
typedef class CDTVVidDecoderDS CDTVVidDecoderDS;
#else
typedef struct CDTVVidDecoderDS CDTVVidDecoderDS;
#endif /* defined __cplusplus */
#endif /* defined __CDTVVidDecoderDS_FWD_DEFINED__ */

#ifndef __CMSAC3Enc_FWD_DEFINED__
#define __CMSAC3Enc_FWD_DEFINED__
#ifdef __cplusplus
typedef class CMSAC3Enc CMSAC3Enc;
#else
typedef struct CMSAC3Enc CMSAC3Enc;
#endif /* defined __cplusplus */
#endif /* defined __CMSAC3Enc_FWD_DEFINED__ */

#ifndef __CMSH264DecoderMFT_FWD_DEFINED__
#define __CMSH264DecoderMFT_FWD_DEFINED__
#ifdef __cplusplus
typedef class CMSH264DecoderMFT CMSH264DecoderMFT;
#else
typedef struct CMSH264DecoderMFT CMSH264DecoderMFT;
#endif /* defined __cplusplus */
#endif /* defined __CMSH264DecoderMFT_FWD_DEFINED__ */

/* Headers for imported files */

#include <mediaobj.h>
#include <strmif.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************
 * IWMValidate interface
 */
#ifndef __IWMValidate_INTERFACE_DEFINED__
#define __IWMValidate_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMValidate, 0xcee3def2, 0x3808, 0x414d, 0xbe,0x66, 0xfa,0xfd,0x47,0x22,0x10,0xbc);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("cee3def2-3808-414d-be66-fafd472210bc")
IWMValidate : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetIdentifier(
        GUID guidValidationID) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMValidate, 0xcee3def2, 0x3808, 0x414d, 0xbe,0x66, 0xfa,0xfd,0x47,0x22,0x10,0xbc)
#endif
#else
typedef struct IWMValidateVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMValidate* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMValidate* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMValidate* This);

    /*** IWMValidate methods ***/
    HRESULT (STDMETHODCALLTYPE *SetIdentifier)(
        IWMValidate* This,
        GUID guidValidationID);

    END_INTERFACE
} IWMValidateVtbl;
interface IWMValidate {
    CONST_VTBL IWMValidateVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMValidate_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMValidate_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMValidate_Release(This) (This)->lpVtbl->Release(This)
/*** IWMValidate methods ***/
#define IWMValidate_SetIdentifier(This,guidValidationID) (This)->lpVtbl->SetIdentifier(This,guidValidationID)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMValidate_QueryInterface(IWMValidate* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMValidate_AddRef(IWMValidate* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMValidate_Release(IWMValidate* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMValidate methods ***/
static FORCEINLINE HRESULT IWMValidate_SetIdentifier(IWMValidate* This,GUID guidValidationID) {
    return This->lpVtbl->SetIdentifier(This,guidValidationID);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMValidate_SetIdentifier_Proxy(
    IWMValidate* This,
    GUID guidValidationID);
void __RPC_STUB IWMValidate_SetIdentifier_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMValidate_INTERFACE_DEFINED__ */

/*****************************************************************************
 * CMpeg4DecMediaObject coclass
 */

DEFINE_GUID(CLSID_CMpeg4DecMediaObject, 0xf371728a, 0x6052, 0x4d47, 0x82,0x7c, 0xd0,0x39,0x33,0x5d,0xfe,0x0a);

#ifdef __cplusplus
class DECLSPEC_UUID("f371728a-6052-4d47-827c-d039335dfe0a") CMpeg4DecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMpeg4DecMediaObject, 0xf371728a, 0x6052, 0x4d47, 0x82,0x7c, 0xd0,0x39,0x33,0x5d,0xfe,0x0a)
#endif
#endif

/*****************************************************************************
 * CMpeg43DecMediaObject coclass
 */

DEFINE_GUID(CLSID_CMpeg43DecMediaObject, 0xcba9e78b, 0x49a3, 0x49ea, 0x93,0xd4, 0x6b,0xcb,0xa8,0xc4,0xde,0x07);

#ifdef __cplusplus
class DECLSPEC_UUID("cba9e78b-49a3-49ea-93d4-6bcba8c4de07") CMpeg43DecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMpeg43DecMediaObject, 0xcba9e78b, 0x49a3, 0x49ea, 0x93,0xd4, 0x6b,0xcb,0xa8,0xc4,0xde,0x07)
#endif
#endif

/*****************************************************************************
 * CMpeg4sDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CMpeg4sDecMediaObject, 0x2a11bae2, 0xfe6e, 0x4249, 0x86,0x4b, 0x9e,0x9e,0xd6,0xe8,0xdb,0xc2);

#ifdef __cplusplus
class DECLSPEC_UUID("2a11bae2-fe6e-4249-864b-9e9ed6e8dbc2") CMpeg4sDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMpeg4sDecMediaObject, 0x2a11bae2, 0xfe6e, 0x4249, 0x86,0x4b, 0x9e,0x9e,0xd6,0xe8,0xdb,0xc2)
#endif
#endif

/*****************************************************************************
 * CMpeg4sDecMFT coclass
 */

DEFINE_GUID(CLSID_CMpeg4sDecMFT, 0x5686a0d9, 0xfe39, 0x409f, 0x9d,0xff, 0x3f,0xdb,0xc8,0x49,0xf9,0xf5);

#ifdef __cplusplus
class DECLSPEC_UUID("5686a0d9-fe39-409f-9dff-3fdbc849f9f5") CMpeg4sDecMFT;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMpeg4sDecMFT, 0x5686a0d9, 0xfe39, 0x409f, 0x9d,0xff, 0x3f,0xdb,0xc8,0x49,0xf9,0xf5)
#endif
#endif

/*****************************************************************************
 * CZuneM4S2DecMediaObject coclass
 */

DEFINE_GUID(CLSID_CZuneM4S2DecMediaObject, 0xc56fc25c, 0x0fc6, 0x404a, 0x95,0x03, 0xb1,0x0b,0xf5,0x1a,0x8a,0xb9);

#ifdef __cplusplus
class DECLSPEC_UUID("c56fc25c-0fc6-404a-9503-b10bf51a8ab9") CZuneM4S2DecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CZuneM4S2DecMediaObject, 0xc56fc25c, 0x0fc6, 0x404a, 0x95,0x03, 0xb1,0x0b,0xf5,0x1a,0x8a,0xb9)
#endif
#endif

/*****************************************************************************
 * CMpeg4EncMediaObject coclass
 */

DEFINE_GUID(CLSID_CMpeg4EncMediaObject, 0x24f258d8, 0xc651, 0x4042, 0x93,0xe4, 0xca,0x65,0x4a,0xbb,0x68,0x2c);

#ifdef __cplusplus
class DECLSPEC_UUID("24f258d8-c651-4042-93e4-ca654abb682c") CMpeg4EncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMpeg4EncMediaObject, 0x24f258d8, 0xc651, 0x4042, 0x93,0xe4, 0xca,0x65,0x4a,0xbb,0x68,0x2c)
#endif
#endif

/*****************************************************************************
 * CMpeg4sEncMediaObject coclass
 */

DEFINE_GUID(CLSID_CMpeg4sEncMediaObject, 0x6ec5a7be, 0xd81e, 0x4f9e, 0xad,0xa3, 0xcd,0x1b,0xf2,0x62,0xb6,0xd8);

#ifdef __cplusplus
class DECLSPEC_UUID("6ec5a7be-d81e-4f9e-ada3-cd1bf262b6d8") CMpeg4sEncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMpeg4sEncMediaObject, 0x6ec5a7be, 0xd81e, 0x4f9e, 0xad,0xa3, 0xcd,0x1b,0xf2,0x62,0xb6,0xd8)
#endif
#endif

/*****************************************************************************
 * CMSSCDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CMSSCDecMediaObject, 0x7bafb3b1, 0xd8f4, 0x4279, 0x92,0x53, 0x27,0xda,0x42,0x31,0x08,0xde);

#ifdef __cplusplus
class DECLSPEC_UUID("7bafb3b1-d8f4-4279-9253-27da423108de") CMSSCDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMSSCDecMediaObject, 0x7bafb3b1, 0xd8f4, 0x4279, 0x92,0x53, 0x27,0xda,0x42,0x31,0x08,0xde)
#endif
#endif

/*****************************************************************************
 * CMSSCEncMediaObject coclass
 */

DEFINE_GUID(CLSID_CMSSCEncMediaObject, 0x8cb9cc06, 0xd139, 0x4ae6, 0x8b,0xb4, 0x41,0xe6,0x12,0xe1,0x41,0xd5);

#ifdef __cplusplus
class DECLSPEC_UUID("8cb9cc06-d139-4ae6-8bb4-41e612e141d5") CMSSCEncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMSSCEncMediaObject, 0x8cb9cc06, 0xd139, 0x4ae6, 0x8b,0xb4, 0x41,0xe6,0x12,0xe1,0x41,0xd5)
#endif
#endif

/*****************************************************************************
 * CMSSCEncMediaObject2 coclass
 */

DEFINE_GUID(CLSID_CMSSCEncMediaObject2, 0xf7ffe0a0, 0xa4f5, 0x44b5, 0x94,0x9e, 0x15,0xed,0x2b,0xc6,0x6f,0x9d);

#ifdef __cplusplus
class DECLSPEC_UUID("f7ffe0a0-a4f5-44b5-949e-15ed2bc66f9d") CMSSCEncMediaObject2;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMSSCEncMediaObject2, 0xf7ffe0a0, 0xa4f5, 0x44b5, 0x94,0x9e, 0x15,0xed,0x2b,0xc6,0x6f,0x9d)
#endif
#endif

/*****************************************************************************
 * CWMADecMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMADecMediaObject, 0x2eeb4adf, 0x4578, 0x4d10, 0xbc,0xa7, 0xbb,0x95,0x5f,0x56,0x32,0x0a);

#ifdef __cplusplus
class DECLSPEC_UUID("2eeb4adf-4578-4d10-bca7-bb955f56320a") CWMADecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMADecMediaObject, 0x2eeb4adf, 0x4578, 0x4d10, 0xbc,0xa7, 0xbb,0x95,0x5f,0x56,0x32,0x0a)
#endif
#endif

/*****************************************************************************
 * CWMAEncMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMAEncMediaObject, 0x70f598e9, 0xf4ab, 0x495a, 0x99,0xe2, 0xa7,0xc4,0xd3,0xd8,0x9a,0xbf);

#ifdef __cplusplus
class DECLSPEC_UUID("70f598e9-f4ab-495a-99e2-a7c4d3d89abf") CWMAEncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMAEncMediaObject, 0x70f598e9, 0xf4ab, 0x495a, 0x99,0xe2, 0xa7,0xc4,0xd3,0xd8,0x9a,0xbf)
#endif
#endif

/*****************************************************************************
 * CWMATransMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMATransMediaObject, 0xedcad9cb, 0x3127, 0x40df, 0xb5,0x27, 0x01,0x52,0xcc,0xb3,0xf6,0xf5);

#ifdef __cplusplus
class DECLSPEC_UUID("edcad9cb-3127-40df-b527-0152ccb3f6f5") CWMATransMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMATransMediaObject, 0xedcad9cb, 0x3127, 0x40df, 0xb5,0x27, 0x01,0x52,0xcc,0xb3,0xf6,0xf5)
#endif
#endif

/*****************************************************************************
 * CWMSPDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMSPDecMediaObject, 0x874131cb, 0x4ecc, 0x443b, 0x89,0x48, 0x74,0x6b,0x89,0x59,0x5d,0x20);

#ifdef __cplusplus
class DECLSPEC_UUID("874131cb-4ecc-443b-8948-746b89595d20") CWMSPDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMSPDecMediaObject, 0x874131cb, 0x4ecc, 0x443b, 0x89,0x48, 0x74,0x6b,0x89,0x59,0x5d,0x20)
#endif
#endif

/*****************************************************************************
 * CWMSPEncMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMSPEncMediaObject, 0x67841b03, 0xc689, 0x4188, 0xad,0x3f, 0x4c,0x9e,0xbe,0xec,0x71,0x0b);

#ifdef __cplusplus
class DECLSPEC_UUID("67841b03-c689-4188-ad3f-4c9ebeec710b") CWMSPEncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMSPEncMediaObject, 0x67841b03, 0xc689, 0x4188, 0xad,0x3f, 0x4c,0x9e,0xbe,0xec,0x71,0x0b)
#endif
#endif

/*****************************************************************************
 * CWMSPEncMediaObject2 coclass
 */

DEFINE_GUID(CLSID_CWMSPEncMediaObject2, 0x1f1f4e1a, 0x2252, 0x4063, 0x84,0xbb, 0xee,0xe7,0x5f,0x88,0x56,0xd5);

#ifdef __cplusplus
class DECLSPEC_UUID("1f1f4e1a-2252-4063-84bb-eee75f8856d5") CWMSPEncMediaObject2;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMSPEncMediaObject2, 0x1f1f4e1a, 0x2252, 0x4063, 0x84,0xbb, 0xee,0xe7,0x5f,0x88,0x56,0xd5)
#endif
#endif

/*****************************************************************************
 * CWMTDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMTDecMediaObject, 0xf9dbc64e, 0x2dd0, 0x45dd, 0x9b,0x52, 0x66,0x64,0x2e,0xf9,0x44,0x31);

#ifdef __cplusplus
class DECLSPEC_UUID("f9dbc64e-2dd0-45dd-9b52-66642ef94431") CWMTDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMTDecMediaObject, 0xf9dbc64e, 0x2dd0, 0x45dd, 0x9b,0x52, 0x66,0x64,0x2e,0xf9,0x44,0x31)
#endif
#endif

/*****************************************************************************
 * CWMTEncMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMTEncMediaObject, 0x60b67652, 0xe46b, 0x4e44, 0x86,0x09, 0xf7,0x4b,0xff,0xdc,0x08,0x3c);

#ifdef __cplusplus
class DECLSPEC_UUID("60b67652-e46b-4e44-8609-f74bffdc083c") CWMTEncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMTEncMediaObject, 0x60b67652, 0xe46b, 0x4e44, 0x86,0x09, 0xf7,0x4b,0xff,0xdc,0x08,0x3c)
#endif
#endif

/*****************************************************************************
 * CWMVDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMVDecMediaObject, 0x82d353df, 0x90bd, 0x4382, 0x8b,0xc2, 0x3f,0x61,0x92,0xb7,0x6e,0x34);

#ifdef __cplusplus
class DECLSPEC_UUID("82d353df-90bd-4382-8bc2-3f6192b76e34") CWMVDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMVDecMediaObject, 0x82d353df, 0x90bd, 0x4382, 0x8b,0xc2, 0x3f,0x61,0x92,0xb7,0x6e,0x34)
#endif
#endif

/*****************************************************************************
 * CWMVEncMediaObject2 coclass
 */

DEFINE_GUID(CLSID_CWMVEncMediaObject2, 0x96b57cdd, 0x8966, 0x410c, 0xbb,0x1f, 0xc9,0x7e,0xea,0x76,0x5c,0x04);

#ifdef __cplusplus
class DECLSPEC_UUID("96b57cdd-8966-410c-bb1f-c97eea765c04") CWMVEncMediaObject2;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMVEncMediaObject2, 0x96b57cdd, 0x8966, 0x410c, 0xbb,0x1f, 0xc9,0x7e,0xea,0x76,0x5c,0x04)
#endif
#endif

/*****************************************************************************
 * CWMVXEncMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMVXEncMediaObject, 0x7e320092, 0x596a, 0x41b2, 0xbb,0xeb, 0x17,0x5d,0x10,0x50,0x4e,0xb6);

#ifdef __cplusplus
class DECLSPEC_UUID("7e320092-596a-41b2-bbeb-175d10504eb6") CWMVXEncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMVXEncMediaObject, 0x7e320092, 0x596a, 0x41b2, 0xbb,0xeb, 0x17,0x5d,0x10,0x50,0x4e,0xb6)
#endif
#endif

/*****************************************************************************
 * CWMV9EncMediaObject coclass
 */

DEFINE_GUID(CLSID_CWMV9EncMediaObject, 0xd23b90d0, 0x144f, 0x46bd, 0x84,0x1d, 0x59,0xe4,0xeb,0x19,0xdc,0x59);

#ifdef __cplusplus
class DECLSPEC_UUID("d23b90d0-144f-46bd-841d-59e4eb19dc59") CWMV9EncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMV9EncMediaObject, 0xd23b90d0, 0x144f, 0x46bd, 0x84,0x1d, 0x59,0xe4,0xeb,0x19,0xdc,0x59)
#endif
#endif

/*****************************************************************************
 * CWVC1DecMediaObject coclass
 */

DEFINE_GUID(CLSID_CWVC1DecMediaObject, 0xc9bfbccf, 0xe60e, 0x4588, 0xa3,0xdf, 0x5a,0x03,0xb1,0xfd,0x95,0x85);

#ifdef __cplusplus
class DECLSPEC_UUID("c9bfbccf-e60e-4588-a3df-5a03b1fd9585") CWVC1DecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWVC1DecMediaObject, 0xc9bfbccf, 0xe60e, 0x4588, 0xa3,0xdf, 0x5a,0x03,0xb1,0xfd,0x95,0x85)
#endif
#endif

/*****************************************************************************
 * CWVC1EncMediaObject coclass
 */

DEFINE_GUID(CLSID_CWVC1EncMediaObject, 0x44653d0d, 0x8cca, 0x41e7, 0xba,0xca, 0x88,0x43,0x37,0xb7,0x47,0xac);

#ifdef __cplusplus
class DECLSPEC_UUID("44653d0d-8cca-41e7-baca-884337b747ac") CWVC1EncMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWVC1EncMediaObject, 0x44653d0d, 0x8cca, 0x41e7, 0xba,0xca, 0x88,0x43,0x37,0xb7,0x47,0xac)
#endif
#endif

/*****************************************************************************
 * CDeColorConvMediaObject coclass
 */

DEFINE_GUID(CLSID_CDeColorConvMediaObject, 0x49034c05, 0xf43c, 0x400f, 0x84,0xc1, 0x90,0xa6,0x83,0x19,0x5a,0x3a);

#ifdef __cplusplus
class DECLSPEC_UUID("49034c05-f43c-400f-84c1-90a683195a3a") CDeColorConvMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CDeColorConvMediaObject, 0x49034c05, 0xf43c, 0x400f, 0x84,0xc1, 0x90,0xa6,0x83,0x19,0x5a,0x3a)
#endif
#endif

/*****************************************************************************
 * CDVDecoderMediaObject coclass
 */

DEFINE_GUID(CLSID_CDVDecoderMediaObject, 0xe54709c5, 0x1e17, 0x4c8d, 0x94,0xe7, 0x47,0x89,0x40,0x43,0x35,0x84);

#ifdef __cplusplus
class DECLSPEC_UUID("e54709c5-1e17-4c8d-94e7-478940433584") CDVDecoderMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CDVDecoderMediaObject, 0xe54709c5, 0x1e17, 0x4c8d, 0x94,0xe7, 0x47,0x89,0x40,0x43,0x35,0x84)
#endif
#endif

/*****************************************************************************
 * CDVEncoderMediaObject coclass
 */

DEFINE_GUID(CLSID_CDVEncoderMediaObject, 0xc82ae729, 0xc327, 0x4cce, 0x91,0x4d, 0x81,0x71,0xfe,0xfe,0xbe,0xfb);

#ifdef __cplusplus
class DECLSPEC_UUID("c82ae729-c327-4cce-914d-8171fefebefb") CDVEncoderMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CDVEncoderMediaObject, 0xc82ae729, 0xc327, 0x4cce, 0x91,0x4d, 0x81,0x71,0xfe,0xfe,0xbe,0xfb)
#endif
#endif

/*****************************************************************************
 * CMpeg2DecMediaObject coclass
 */

DEFINE_GUID(CLSID_CMpeg2DecMediaObject, 0x863d66cd, 0xcdce, 0x4617, 0xb4,0x7f, 0xc8,0x92,0x9c,0xfc,0x28,0xa6);

#ifdef __cplusplus
class DECLSPEC_UUID("863d66cd-cdce-4617-b47f-c8929cfc28a6") CMpeg2DecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMpeg2DecMediaObject, 0x863d66cd, 0xcdce, 0x4617, 0xb4,0x7f, 0xc8,0x92,0x9c,0xfc,0x28,0xa6)
#endif
#endif

/*****************************************************************************
 * CPK_DS_MPEG2Decoder coclass
 */

DEFINE_GUID(CLSID_CPK_DS_MPEG2Decoder, 0x9910c5cd, 0x95c9, 0x4e06, 0x86,0x5a, 0xef,0xa1,0xc8,0x01,0x6b,0xf4);

#ifdef __cplusplus
class DECLSPEC_UUID("9910c5cd-95c9-4e06-865a-efa1c8016bf4") CPK_DS_MPEG2Decoder;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CPK_DS_MPEG2Decoder, 0x9910c5cd, 0x95c9, 0x4e06, 0x86,0x5a, 0xef,0xa1,0xc8,0x01,0x6b,0xf4)
#endif
#endif

/*****************************************************************************
 * CAC3DecMediaObject coclass
 */

DEFINE_GUID(CLSID_CAC3DecMediaObject, 0x03d7c802, 0xecfa, 0x47d9, 0xb2,0x68, 0x5f,0xb3,0xe3,0x10,0xde,0xe4);

#ifdef __cplusplus
class DECLSPEC_UUID("03d7c802-ecfa-47d9-b268-5fb3e310dee4") CAC3DecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CAC3DecMediaObject, 0x03d7c802, 0xecfa, 0x47d9, 0xb2,0x68, 0x5f,0xb3,0xe3,0x10,0xde,0xe4)
#endif
#endif

/*****************************************************************************
 * CPK_DS_AC3Decoder coclass
 */

DEFINE_GUID(CLSID_CPK_DS_AC3Decoder, 0x6c9c69d6, 0x0ffc, 0x4481, 0xaf,0xdb, 0xcd,0xf1,0xc7,0x9c,0x6f,0x3e);

#ifdef __cplusplus
class DECLSPEC_UUID("6c9c69d6-0ffc-4481-afdb-cdf1c79c6f3e") CPK_DS_AC3Decoder;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CPK_DS_AC3Decoder, 0x6c9c69d6, 0x0ffc, 0x4481, 0xaf,0xdb, 0xcd,0xf1,0xc7,0x9c,0x6f,0x3e)
#endif
#endif

/*****************************************************************************
 * CMP3DecMediaObject coclass
 */

DEFINE_GUID(CLSID_CMP3DecMediaObject, 0xbbeea841, 0x0a63, 0x4f52, 0xa7,0xab, 0xa9,0xb3,0xa8,0x4e,0xd3,0x8a);

#ifdef __cplusplus
class DECLSPEC_UUID("bbeea841-0a63-4f52-a7ab-a9b3a84ed38a") CMP3DecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMP3DecMediaObject, 0xbbeea841, 0x0a63, 0x4f52, 0xa7,0xab, 0xa9,0xb3,0xa8,0x4e,0xd3,0x8a)
#endif
#endif

/*****************************************************************************
 * CResamplerMediaObject coclass
 */

DEFINE_GUID(CLSID_CResamplerMediaObject, 0xf447b69e, 0x1884, 0x4a7e, 0x80,0x55, 0x34,0x6f,0x74,0xd6,0xed,0xb3);

#ifdef __cplusplus
class DECLSPEC_UUID("f447b69e-1884-4a7e-8055-346f74d6edb3") CResamplerMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CResamplerMediaObject, 0xf447b69e, 0x1884, 0x4a7e, 0x80,0x55, 0x34,0x6f,0x74,0xd6,0xed,0xb3)
#endif
#endif

/*****************************************************************************
 * CResizerMediaObject coclass
 */

DEFINE_GUID(CLSID_CResizerMediaObject, 0xd3ec8b8b, 0x7728, 0x4fd8, 0x9f,0xe0, 0x7b,0x67,0xd1,0x9f,0x73,0xa3);

#ifdef __cplusplus
class DECLSPEC_UUID("d3ec8b8b-7728-4fd8-9fe0-7b67d19f73a3") CResizerMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CResizerMediaObject, 0xd3ec8b8b, 0x7728, 0x4fd8, 0x9f,0xe0, 0x7b,0x67,0xd1,0x9f,0x73,0xa3)
#endif
#endif

/*****************************************************************************
 * CInterlaceMediaObject coclass
 */

DEFINE_GUID(CLSID_CInterlaceMediaObject, 0xb5a89c80, 0x4901, 0x407b, 0x9a,0xbc, 0x90,0xd9,0xa6,0x44,0xbb,0x46);

#ifdef __cplusplus
class DECLSPEC_UUID("b5a89c80-4901-407b-9abc-90d9a644bb46") CInterlaceMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CInterlaceMediaObject, 0xb5a89c80, 0x4901, 0x407b, 0x9a,0xbc, 0x90,0xd9,0xa6,0x44,0xbb,0x46)
#endif
#endif

/*****************************************************************************
 * CWMAudioLFXAPO coclass
 */

DEFINE_GUID(CLSID_CWMAudioLFXAPO, 0x62dc1a93, 0xae24, 0x464c, 0xa4,0x3e, 0x45,0x2f,0x82,0x4c,0x42,0x50);

#ifdef __cplusplus
class DECLSPEC_UUID("62dc1a93-ae24-464c-a43e-452f824c4250") CWMAudioLFXAPO;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMAudioLFXAPO, 0x62dc1a93, 0xae24, 0x464c, 0xa4,0x3e, 0x45,0x2f,0x82,0x4c,0x42,0x50)
#endif
#endif

/*****************************************************************************
 * CWMAudioGFXAPO coclass
 */

DEFINE_GUID(CLSID_CWMAudioGFXAPO, 0x637c490d, 0xeee3, 0x4c0a, 0x97,0x3f, 0x37,0x19,0x58,0x80,0x2d,0xa2);

#ifdef __cplusplus
class DECLSPEC_UUID("637c490d-eee3-4c0a-973f-371958802da2") CWMAudioGFXAPO;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMAudioGFXAPO, 0x637c490d, 0xeee3, 0x4c0a, 0x97,0x3f, 0x37,0x19,0x58,0x80,0x2d,0xa2)
#endif
#endif

/*****************************************************************************
 * CWMAudioSpdTxDMO coclass
 */

DEFINE_GUID(CLSID_CWMAudioSpdTxDMO, 0x5210f8e4, 0xb0bb, 0x47c3, 0xa8,0xd9, 0x7b,0x22,0x82,0xcc,0x79,0xed);

#ifdef __cplusplus
class DECLSPEC_UUID("5210f8e4-b0bb-47c3-a8d9-7b2282cc79ed") CWMAudioSpdTxDMO;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMAudioSpdTxDMO, 0x5210f8e4, 0xb0bb, 0x47c3, 0xa8,0xd9, 0x7b,0x22,0x82,0xcc,0x79,0xed)
#endif
#endif

/*****************************************************************************
 * CWMAudioAEC coclass
 */

DEFINE_GUID(CLSID_CWMAudioAEC, 0x745057c7, 0xf353, 0x4f2d, 0xa7,0xee, 0x58,0x43,0x44,0x77,0x73,0x0e);

#ifdef __cplusplus
class DECLSPEC_UUID("745057c7-f353-4f2d-a7ee-58434477730e") CWMAudioAEC;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CWMAudioAEC, 0x745057c7, 0xf353, 0x4f2d, 0xa7,0xee, 0x58,0x43,0x44,0x77,0x73,0x0e)
#endif
#endif

/*****************************************************************************
 * CClusterDetectorDmo coclass
 */

DEFINE_GUID(CLSID_CClusterDetectorDmo, 0x36e820c4, 0x165a, 0x4521, 0x86,0x3c, 0x61,0x9e,0x11,0x60,0xd4,0xd4);

#ifdef __cplusplus
class DECLSPEC_UUID("36e820c4-165a-4521-863c-619e1160d4d4") CClusterDetectorDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CClusterDetectorDmo, 0x36e820c4, 0x165a, 0x4521, 0x86,0x3c, 0x61,0x9e,0x11,0x60,0xd4,0xd4)
#endif
#endif

/*****************************************************************************
 * CColorControlDmo coclass
 */

DEFINE_GUID(CLSID_CColorControlDmo, 0x798059f0, 0x89ca, 0x4160, 0xb3,0x25, 0xae,0xb4,0x8e,0xfe,0x4f,0x9a);

#ifdef __cplusplus
class DECLSPEC_UUID("798059f0-89ca-4160-b325-aeb48efe4f9a") CColorControlDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CColorControlDmo, 0x798059f0, 0x89ca, 0x4160, 0xb3,0x25, 0xae,0xb4,0x8e,0xfe,0x4f,0x9a)
#endif
#endif

/*****************************************************************************
 * CColorConvertDMO coclass
 */

DEFINE_GUID(CLSID_CColorConvertDMO, 0x98230571, 0x0087, 0x4204, 0xb0,0x20, 0x32,0x82,0x53,0x8e,0x57,0xd3);

#ifdef __cplusplus
class DECLSPEC_UUID("98230571-0087-4204-b020-3282538e57d3") CColorConvertDMO;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CColorConvertDMO, 0x98230571, 0x0087, 0x4204, 0xb0,0x20, 0x32,0x82,0x53,0x8e,0x57,0xd3)
#endif
#endif

/*****************************************************************************
 * CColorLegalizerDmo coclass
 */

DEFINE_GUID(CLSID_CColorLegalizerDmo, 0xfdfaa753, 0xe48e, 0x4e33, 0x9c,0x74, 0x98,0xa2,0x7f,0xc6,0x72,0x6a);

#ifdef __cplusplus
class DECLSPEC_UUID("fdfaa753-e48e-4e33-9c74-98a27fc6726a") CColorLegalizerDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CColorLegalizerDmo, 0xfdfaa753, 0xe48e, 0x4e33, 0x9c,0x74, 0x98,0xa2,0x7f,0xc6,0x72,0x6a)
#endif
#endif

/*****************************************************************************
 * CFrameInterpDMO coclass
 */

DEFINE_GUID(CLSID_CFrameInterpDMO, 0x0a7cfe1b, 0x6ab5, 0x4334, 0x9e,0xd8, 0x3f,0x97,0xcb,0x37,0xda,0xa1);

#ifdef __cplusplus
class DECLSPEC_UUID("0a7cfe1b-6ab5-4334-9ed8-3f97cb37daa1") CFrameInterpDMO;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CFrameInterpDMO, 0x0a7cfe1b, 0x6ab5, 0x4334, 0x9e,0xd8, 0x3f,0x97,0xcb,0x37,0xda,0xa1)
#endif
#endif

/*****************************************************************************
 * CFrameRateConvertDmo coclass
 */

DEFINE_GUID(CLSID_CFrameRateConvertDmo, 0x01f36ce2, 0x0907, 0x4d8b, 0x97,0x9d, 0xf1,0x51,0xbe,0x91,0xc8,0x83);

#ifdef __cplusplus
class DECLSPEC_UUID("01f36ce2-0907-4d8b-979d-f151be91c883") CFrameRateConvertDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CFrameRateConvertDmo, 0x01f36ce2, 0x0907, 0x4d8b, 0x97,0x9d, 0xf1,0x51,0xbe,0x91,0xc8,0x83)
#endif
#endif

/*****************************************************************************
 * CResizerDMO coclass
 */

DEFINE_GUID(CLSID_CResizerDMO, 0x1ea1ea14, 0x48f4, 0x4054, 0xad,0x1a, 0xe8,0xae,0xe1,0x0a,0xc8,0x05);

#ifdef __cplusplus
class DECLSPEC_UUID("1ea1ea14-48f4-4054-ad1a-e8aee10ac805") CResizerDMO;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CResizerDMO, 0x1ea1ea14, 0x48f4, 0x4054, 0xad,0x1a, 0xe8,0xae,0xe1,0x0a,0xc8,0x05)
#endif
#endif

/*****************************************************************************
 * CShotDetectorDmo coclass
 */

DEFINE_GUID(CLSID_CShotDetectorDmo, 0x56aefacd, 0x110c, 0x4397, 0x92,0x92, 0xb0,0xa0,0xc6,0x1b,0x67,0x50);

#ifdef __cplusplus
class DECLSPEC_UUID("56aefacd-110c-4397-9292-b0a0c61b6750") CShotDetectorDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CShotDetectorDmo, 0x56aefacd, 0x110c, 0x4397, 0x92,0x92, 0xb0,0xa0,0xc6,0x1b,0x67,0x50)
#endif
#endif

/*****************************************************************************
 * CSmpteTransformsDmo coclass
 */

DEFINE_GUID(CLSID_CSmpteTransformsDmo, 0xbde6388b, 0xda25, 0x485d, 0xba,0x7f, 0xfa,0xbc,0x28,0xb2,0x03,0x18);

#ifdef __cplusplus
class DECLSPEC_UUID("bde6388b-da25-485d-ba7f-fabc28b20318") CSmpteTransformsDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CSmpteTransformsDmo, 0xbde6388b, 0xda25, 0x485d, 0xba,0x7f, 0xfa,0xbc,0x28,0xb2,0x03,0x18)
#endif
#endif

/*****************************************************************************
 * CThumbnailGeneratorDmo coclass
 */

DEFINE_GUID(CLSID_CThumbnailGeneratorDmo, 0x559c6bad, 0x1ea8, 0x4963, 0xa0,0x87, 0x8a,0x68,0x10,0xf9,0x21,0x8b);

#ifdef __cplusplus
class DECLSPEC_UUID("559c6bad-1ea8-4963-a087-8a6810f9218b") CThumbnailGeneratorDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CThumbnailGeneratorDmo, 0x559c6bad, 0x1ea8, 0x4963, 0xa0,0x87, 0x8a,0x68,0x10,0xf9,0x21,0x8b)
#endif
#endif

/*****************************************************************************
 * CTocGeneratorDmo coclass
 */

DEFINE_GUID(CLSID_CTocGeneratorDmo, 0x4dda1941, 0x77a0, 0x4fb1, 0xa5,0x18, 0xe2,0x18,0x50,0x41,0xd7,0x0c);

#ifdef __cplusplus
class DECLSPEC_UUID("4dda1941-77a0-4fb1-a518-e2185041d70c") CTocGeneratorDmo;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CTocGeneratorDmo, 0x4dda1941, 0x77a0, 0x4fb1, 0xa5,0x18, 0xe2,0x18,0x50,0x41,0xd7,0x0c)
#endif
#endif

/*****************************************************************************
 * CMPEGAACDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CMPEGAACDecMediaObject, 0x8dde1772, 0xedad, 0x41c3, 0xb4,0xbe, 0x1f,0x30,0xfb,0x4e,0xe0,0xd6);

#ifdef __cplusplus
class DECLSPEC_UUID("8dde1772-edad-41c3-b4be-1f30fb4ee0d6") CMPEGAACDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMPEGAACDecMediaObject, 0x8dde1772, 0xedad, 0x41c3, 0xb4,0xbe, 0x1f,0x30,0xfb,0x4e,0xe0,0xd6)
#endif
#endif

/*****************************************************************************
 * CNokiaAACDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CNokiaAACDecMediaObject, 0x3cb2bde4, 0x4e29, 0x4c44, 0xa7,0x3e, 0x2d,0x7c,0x2c,0x46,0xd6,0xec);

#ifdef __cplusplus
class DECLSPEC_UUID("3cb2bde4-4e29-4c44-a73e-2d7c2c46d6ec") CNokiaAACDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CNokiaAACDecMediaObject, 0x3cb2bde4, 0x4e29, 0x4c44, 0xa7,0x3e, 0x2d,0x7c,0x2c,0x46,0xd6,0xec)
#endif
#endif

/*****************************************************************************
 * CVodafoneAACDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CVodafoneAACDecMediaObject, 0x7f36f942, 0xdcf3, 0x4d82, 0x92,0x89, 0x5b,0x18,0x20,0x27,0x8f,0x7c);

#ifdef __cplusplus
class DECLSPEC_UUID("7f36f942-dcf3-4d82-9289-5b1820278f7c") CVodafoneAACDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CVodafoneAACDecMediaObject, 0x7f36f942, 0xdcf3, 0x4d82, 0x92,0x89, 0x5b,0x18,0x20,0x27,0x8f,0x7c)
#endif
#endif

/*****************************************************************************
 * CZuneAACCCDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CZuneAACCCDecMediaObject, 0xa74e98f2, 0x52d6, 0x4b4e, 0x88,0x5b, 0xe0,0xa6,0xca,0x4f,0x18,0x7a);

#ifdef __cplusplus
class DECLSPEC_UUID("a74e98f2-52d6-4b4e-885b-e0a6ca4f187a") CZuneAACCCDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CZuneAACCCDecMediaObject, 0xa74e98f2, 0x52d6, 0x4b4e, 0x88,0x5b, 0xe0,0xa6,0xca,0x4f,0x18,0x7a)
#endif
#endif

/*****************************************************************************
 * CNokiaAACCCDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CNokiaAACCCDecMediaObject, 0xeabf7a6f, 0xccba, 0x4d60, 0x86,0x20, 0xb1,0x52,0xcc,0x97,0x72,0x63);

#ifdef __cplusplus
class DECLSPEC_UUID("eabf7a6f-ccba-4d60-8620-b152cc977263") CNokiaAACCCDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CNokiaAACCCDecMediaObject, 0xeabf7a6f, 0xccba, 0x4d60, 0x86,0x20, 0xb1,0x52,0xcc,0x97,0x72,0x63)
#endif
#endif

/*****************************************************************************
 * CVodafoneAACCCDecMediaObject coclass
 */

DEFINE_GUID(CLSID_CVodafoneAACCCDecMediaObject, 0x7e76bf7f, 0xc993, 0x4e26, 0x8f,0xab, 0x47,0x0a,0x70,0xc0,0xd5,0x9c);

#ifdef __cplusplus
class DECLSPEC_UUID("7e76bf7f-c993-4e26-8fab-470a70c0d59c") CVodafoneAACCCDecMediaObject;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CVodafoneAACCCDecMediaObject, 0x7e76bf7f, 0xc993, 0x4e26, 0x8f,0xab, 0x47,0x0a,0x70,0xc0,0xd5,0x9c)
#endif
#endif

/*****************************************************************************
 * CMPEG2EncoderDS coclass
 */

DEFINE_GUID(CLSID_CMPEG2EncoderDS, 0x5f5aff4a, 0x2f7f, 0x4279, 0x88,0xc2, 0xcd,0x88,0xeb,0x39,0xd1,0x44);

#ifdef __cplusplus
class DECLSPEC_UUID("5f5aff4a-2f7f-4279-88c2-cd88eb39d144") CMPEG2EncoderDS;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMPEG2EncoderDS, 0x5f5aff4a, 0x2f7f, 0x4279, 0x88,0xc2, 0xcd,0x88,0xeb,0x39,0xd1,0x44)
#endif
#endif

/*****************************************************************************
 * CMPEG2EncoderVideoDS coclass
 */

DEFINE_GUID(CLSID_CMPEG2EncoderVideoDS, 0x42150cd9, 0xca9a, 0x4ea5, 0x99,0x39, 0x30,0xee,0x03,0x7f,0x6e,0x74);

#ifdef __cplusplus
class DECLSPEC_UUID("42150cd9-ca9a-4ea5-9939-30ee037f6e74") CMPEG2EncoderVideoDS;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMPEG2EncoderVideoDS, 0x42150cd9, 0xca9a, 0x4ea5, 0x99,0x39, 0x30,0xee,0x03,0x7f,0x6e,0x74)
#endif
#endif

/*****************************************************************************
 * CMPEG2EncoderAudioDS coclass
 */

DEFINE_GUID(CLSID_CMPEG2EncoderAudioDS, 0xacd453bc, 0xc58a, 0x44d1, 0xbb,0xf5, 0xbf,0xb3,0x25,0xbe,0x2d,0x78);

#ifdef __cplusplus
class DECLSPEC_UUID("acd453bc-c58a-44d1-bbf5-bfb325be2d78") CMPEG2EncoderAudioDS;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMPEG2EncoderAudioDS, 0xacd453bc, 0xc58a, 0x44d1, 0xbb,0xf5, 0xbf,0xb3,0x25,0xbe,0x2d,0x78)
#endif
#endif

/*****************************************************************************
 * CMPEG2AudDecoderDS coclass
 */

DEFINE_GUID(CLSID_CMPEG2AudDecoderDS, 0xe1f1a0b8, 0xbeee, 0x490d, 0xba,0x7c, 0x06,0x6c,0x40,0xb5,0xe2,0xb9);

#ifdef __cplusplus
class DECLSPEC_UUID("e1f1a0b8-beee-490d-ba7c-066c40b5e2b9") CMPEG2AudDecoderDS;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMPEG2AudDecoderDS, 0xe1f1a0b8, 0xbeee, 0x490d, 0xba,0x7c, 0x06,0x6c,0x40,0xb5,0xe2,0xb9)
#endif
#endif

/*****************************************************************************
 * CMPEG2VidDecoderDS coclass
 */

DEFINE_GUID(CLSID_CMPEG2VidDecoderDS, 0x212690fb, 0x83e5, 0x4526, 0x8f,0xd7, 0x74,0x47,0x8b,0x79,0x39,0xcd);

#ifdef __cplusplus
class DECLSPEC_UUID("212690fb-83e5-4526-8fd7-74478b7939cd") CMPEG2VidDecoderDS;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMPEG2VidDecoderDS, 0x212690fb, 0x83e5, 0x4526, 0x8f,0xd7, 0x74,0x47,0x8b,0x79,0x39,0xcd)
#endif
#endif

/*****************************************************************************
 * CDTVAudDecoderDS coclass
 */

DEFINE_GUID(CLSID_CDTVAudDecoderDS, 0x8e269032, 0xfe03, 0x4753, 0x9b,0x17, 0x18,0x25,0x3c,0x21,0x72,0x2e);

#ifdef __cplusplus
class DECLSPEC_UUID("8e269032-fe03-4753-9b17-18253c21722e") CDTVAudDecoderDS;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CDTVAudDecoderDS, 0x8e269032, 0xfe03, 0x4753, 0x9b,0x17, 0x18,0x25,0x3c,0x21,0x72,0x2e)
#endif
#endif

/*****************************************************************************
 * CDTVVidDecoderDS coclass
 */

DEFINE_GUID(CLSID_CDTVVidDecoderDS, 0x64777dc8, 0x4e24, 0x4beb, 0x9d,0x19, 0x60,0xa3,0x5b,0xe1,0xda,0xaf);

#ifdef __cplusplus
class DECLSPEC_UUID("64777dc8-4e24-4beb-9d19-60a35be1daaf") CDTVVidDecoderDS;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CDTVVidDecoderDS, 0x64777dc8, 0x4e24, 0x4beb, 0x9d,0x19, 0x60,0xa3,0x5b,0xe1,0xda,0xaf)
#endif
#endif

/*****************************************************************************
 * CMSAC3Enc coclass
 */

DEFINE_GUID(CLSID_CMSAC3Enc, 0xc6b400e2, 0x20a7, 0x4e58, 0xa2,0xfe, 0x24,0x61,0x96,0x82,0xce,0x6c);

#ifdef __cplusplus
class DECLSPEC_UUID("c6b400e2-20a7-4e58-a2fe-24619682ce6c") CMSAC3Enc;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMSAC3Enc, 0xc6b400e2, 0x20a7, 0x4e58, 0xa2,0xfe, 0x24,0x61,0x96,0x82,0xce,0x6c)
#endif
#endif

/*****************************************************************************
 * CMSH264DecoderMFT coclass
 */

DEFINE_GUID(CLSID_CMSH264DecoderMFT, 0x62ce7e72, 0x4c71, 0x4d20, 0xb1,0x5d, 0x45,0x28,0x31,0xa8,0x7d,0x9d);

#ifdef __cplusplus
class DECLSPEC_UUID("62ce7e72-4c71-4d20-b15d-452831a87d9d") CMSH264DecoderMFT;
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(CMSH264DecoderMFT, 0x62ce7e72, 0x4c71, 0x4d20, 0xb1,0x5d, 0x45,0x28,0x31,0xa8,0x7d,0x9d)
#endif
#endif

/* Begin additional prototypes for all interfaces */


/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __wmcodecdsp_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/share/mingw-w64/include/wmcontainer.h                                                           0100644 0000000 0000000 00000125451 12404413016 017044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WMCONTAINER
#define _INC_WMCONTAINER
#include <propsys.h>
#include <mfidl.h>

#if (_WIN32_WINNT >= 0x0600)

#ifdef __IMFASFSplitter_FWD_DEFINED__
#define __IMFASFSplitter_FWD_DEFINED__
typedef struct IMFASFSplitter IMFASFSplitter;
#endif

typedef struct IMFASFContentInfo IMFASFContentInfo;
typedef struct IMFASFProfile IMFASFProfile;
typedef struct IMFActivate IMFActivate;

#ifndef __MFTIME_DEFINED__
#define __MFTIME_DEFINED__
__MINGW_EXTENSION typedef LONGLONG MFTIME;
#endif

typedef enum ASF_SELECTION_STATUS {
  ASF_STATUS_NOTSELECTED       = 0,
  ASF_STATUS_CLEANPOINTSONLY   = 1,
  ASF_STATUS_ALLDATAUNITS      = 2 
} ASF_SELECTION_STATUS;

typedef enum ASF_STATUSFLAGS {
  ASF_STATUSFLAGS_INCOMPLETE       = 0x00000001,
  ASF_STATUSFLAGS_NONFATAL_ERROR   = 0x00000002 
} ASF_STATUSFLAGS;

typedef enum MFASF_MULTIPLEXERFLAGS {
  MFASF_MULTIPLEXER_AUTOADJUST_BITRATE   = 0x00000001 
} MFASF_MULTIPLEXERFLAGS;

typedef enum MFASF_SPLITTERFLAGS {
  MFASF_SPLITTER_REVERSE   = 0x00000001,
  MFASF_SPLITTER_WMDRM     = 0x00000002 
} MFASF_SPLITTERFLAGS;

typedef enum MFASF_STREAMSELECTORFLAGS {
  MFASF_STREAMSELECTOR_DISABLE_THINNING      = 0x00000001,
  MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE   = 0x00000002 
} MFASF_STREAMSELECTORFLAGS;

typedef struct ASF_MUX_STATISTICS {
  DWORD cFramesWritten;
  DWORD cFramesDropped;
} ASF_MUX_STATISTICS;

typedef struct _ASF_INDEX_IDENTIFIER {
  GUID guidIndexType;
  WORD wStreamNumber;
} ASF_INDEX_IDENTIFIER;

typedef struct _ASF_INDEX_DESCRIPTOR {
  ASF_INDEX_IDENTIFIER Identifier;
  WORD                 cPerEntryBytes;
  WCHAR                szDescription[32];
  DWORD                dwInterval;
} ASF_INDEX_DESCRIPTOR;

#undef  INTERFACE
#define INTERFACE IMFASFMutualExclusion
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFMutualExclusion,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFASFMutualExclusion methods */
    STDMETHOD_(HRESULT,AddRecord)(THIS_ DWORD *pdwRecordNumber) PURE;
    STDMETHOD_(HRESULT,AddStreamForRecord)(THIS_ DWORD dwRecordNumber,WORD wStreamNumber) PURE;
    STDMETHOD_(HRESULT,Clone)(THIS_ IMFASFMutualExclusion **ppIMutex) PURE;
    STDMETHOD_(HRESULT,GetRecordCount)(THIS_ DWORD *pdwRecordCount) PURE;
    STDMETHOD_(HRESULT,GetStreamsForRecord)(THIS_ DWORD dwRecordNumber,WORD *pwStreamNumArray,DWORD *pcStreams) PURE;
    STDMETHOD_(HRESULT,GetType)(THIS_ GUID *pguidType) PURE;
    STDMETHOD_(HRESULT,RemoveRecord)(THIS_ DWORD dwRecordNumber) PURE;
    STDMETHOD_(HRESULT,RemoveStreamFromRecord)(THIS_ DWORD dwRecordNumber,WORD wStreamNumber) PURE;
    STDMETHOD_(HRESULT,SetType)(THIS_ REFGUID guidType) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFMutualExclusion_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFMutualExclusion_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFMutualExclusion_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFMutualExclusion_AddRecord(This,pdwRecordNumber) (This)->lpVtbl->AddRecord(This,pdwRecordNumber)
#define IMFASFMutualExclusion_AddStreamForRecord(This,dwRecordNumber,wStreamNumber) (This)->lpVtbl->AddStreamForRecord(This,dwRecordNumber,wStreamNumber)
#define IMFASFMutualExclusion_Clone(This,ppIMutex) (This)->lpVtbl->Clone(This,ppIMutex)
#define IMFASFMutualExclusion_GetRecordCount(This,pdwRecordCount) (This)->lpVtbl->GetRecordCount(This,pdwRecordCount)
#define IMFASFMutualExclusion_GetStreamsForRecord(This,dwRecordNumber,pwStreamNumArray,pcStreams) (This)->lpVtbl->GetStreamsForRecord(This,dwRecordNumber,pwStreamNumArray,pcStreams)
#define IMFASFMutualExclusion_GetType(This,pguidType) (This)->lpVtbl->GetType(This,pguidType)
#define IMFASFMutualExclusion_RemoveRecord(This,dwRecordNumber) (This)->lpVtbl->RemoveRecord(This,dwRecordNumber)
#define IMFASFMutualExclusion_RemoveStreamFromRecord(This,dwRecordNumber,wStreamNumber) (This)->lpVtbl->RemoveStreamFromRecord(This,dwRecordNumber,wStreamNumber)
#define IMFASFMutualExclusion_SetType(This,guidType) (This)->lpVtbl->SetType(This,guidType)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IMFASFStreamPrioritization
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFStreamPrioritization,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFASFStreamPrioritization methods */
    STDMETHOD_(HRESULT,AddStream)(THIS_ WORD wStreamNumber,WORD wStreamFlags) PURE;
    STDMETHOD_(HRESULT,Clone)(THIS_ IMFASFStreamPrioritization **ppIStreamPrioritization) PURE;
    STDMETHOD_(HRESULT,GetStream)(THIS_ DWORD dwStreamIndex,WORD *pwStreamNumber,WORD *pwStreamFlags) PURE;
    STDMETHOD_(HRESULT,GetStreamCount)(THIS_ DWORD dwStreamIndex) PURE;
    STDMETHOD_(HRESULT,RemoveStream)(THIS_ DWORD dwStreamIndex) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFStreamPrioritization_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFStreamPrioritization_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFStreamPrioritization_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFStreamPrioritization_AddStream(This,wStreamNumber,wStreamFlags) (This)->lpVtbl->AddStream(This,wStreamNumber,wStreamFlags)
#define IMFASFStreamPrioritization_Clone(This,ppIStreamPrioritization) (This)->lpVtbl->Clone(This,ppIStreamPrioritization)
#define IMFASFStreamPrioritization_GetStream(This,dwStreamIndex,pwStreamNumber,pwStreamFlags) (This)->lpVtbl->GetStream(This,dwStreamIndex,pwStreamNumber,pwStreamFlags)
#define IMFASFStreamPrioritization_GetStreamCount(This,dwStreamIndex) (This)->lpVtbl->GetStreamCount(This,dwStreamIndex)
#define IMFASFStreamPrioritization_RemoveStream(This,dwStreamIndex) (This)->lpVtbl->RemoveStream(This,dwStreamIndex)
#endif /*COBJMACROS*/


#undef  INTERFACE
#define INTERFACE IMFASFSplitter
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFSplitter,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFASFSplitter methods */
    STDMETHOD_(HRESULT,Flush)(THIS) PURE;
    STDMETHOD_(HRESULT,GetFlags)(THIS_ DWORD *pdwFlags) PURE;
    STDMETHOD_(HRESULT,GetLastSendTime)(THIS_ DWORD *pdwLastSendTime) PURE;
    STDMETHOD_(HRESULT,GetNextSample)(THIS_ DWORD *pdwStatusFlags,WORD *pwStreamNumber,IMFSample **ppISample) PURE;
    STDMETHOD_(HRESULT,GetSelectedStreams)(THIS_ WORD *pwStreamNumbers,WORD *pwNumStreams) PURE;
    STDMETHOD_(HRESULT,Initialize)(THIS_ IMFASFContentInfo *pIContentInfo) PURE;
    STDMETHOD_(HRESULT,ParseData)(THIS_ IMFMediaBuffer *pIBuffer,DWORD cbBufferOffset,DWORD cbLength) PURE;
    STDMETHOD_(HRESULT,SelectStreams)(THIS_ WORD *pwStreamNumbers,WORD wNumStreams) PURE;
    STDMETHOD_(HRESULT,SetFlags)(THIS_ DWORD dwFlags) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFSplitter_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFSplitter_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFSplitter_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFSplitter_Flush() (This)->lpVtbl->Flush(This)
#define IMFASFSplitter_GetFlags(This,pdwFlags) (This)->lpVtbl->GetFlags(This,pdwFlags)
#define IMFASFSplitter_GetLastSendTime(This,pdwLastSendTime) (This)->lpVtbl->GetLastSendTime(This,pdwLastSendTime)
#define IMFASFSplitter_GetNextSample(This,pdwStatusFlags,pwStreamNumber,ppISample) (This)->lpVtbl->GetNextSample(This,pdwStatusFlags,pwStreamNumber,ppISample)
#define IMFASFSplitter_GetSelectedStreams(This,pwStreamNumbers,pwNumStreams) (This)->lpVtbl->GetSelectedStreams(This,pwStreamNumbers,pwNumStreams)
#define IMFASFSplitter_Initialize(This,pIContentInfo) (This)->lpVtbl->Initialize(This,pIContentInfo)
#define IMFASFSplitter_ParseData(This,pIBuffer,cbBufferOffset,cbLength) (This)->lpVtbl->ParseData(This,pIBuffer,cbBufferOffset,cbLength)
#define IMFASFSplitter_SelectStreams(This,pwStreamNumbers,wNumStreams) (This)->lpVtbl->SelectStreams(This,pwStreamNumbers,wNumStreams)
#define IMFASFSplitter_SetFlags(This,dwFlags) (This)->lpVtbl->SetFlags(This,dwFlags)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IMFASFContentInfo
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFContentInfo,IMFAttributes)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFAttributes methods */
    STDMETHOD_(HRESULT,Compare)(THIS_ IMFAttributes *pTheirs,MF_ATTRIBUTES_MATCH_TYPE MatchType,BOOL *pbResult) PURE;
    STDMETHOD_(HRESULT,CompareItem)(THIS_ REFGUID guidKey,REFPROPVARIANT Value,BOOL *pbResult) PURE;
    STDMETHOD_(HRESULT,CopyAllItems)(THIS_ IMFAttributes *pDest) PURE;
    STDMETHOD_(HRESULT,DeleteAllItems)(THIS) PURE;
    STDMETHOD_(HRESULT,DeleteItem)(THIS_ REFGUID guidKey) PURE;
    STDMETHOD_(HRESULT,GetAllocatedBlob)(THIS_ REFGUID guidKey,UINT8 **ppBuf,UINT32 *pcbSize) PURE;
    STDMETHOD_(HRESULT,GetAllocatedString)(THIS_ REFGUID guidKey,LPWSTR *ppwszValue,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetBlob)(THIS_ REFGUID guidKey,UINT8 *pBuf,UINT32 cbBufSize,UINT32 *pcbBlobSize) PURE;
    STDMETHOD_(HRESULT,GetBlobSize)(THIS_ REFGUID guidKey,UINT32 *pcbBlobSize) PURE;
    STDMETHOD_(HRESULT,GetCount)(THIS_ UINT32 *pcItems) PURE;
    STDMETHOD_(HRESULT,GetDouble)(THIS_ REFGUID guidKey,double *pfValue) PURE;
    STDMETHOD_(HRESULT,GetGUID)(THIS_ REFGUID guidKey,GUID *pguidValue) PURE;
    STDMETHOD_(HRESULT,GetItem)(THIS_ REFGUID guidKey,PROPVARIANT *pValue) PURE;
    STDMETHOD_(HRESULT,GetItemByIndex)(THIS_ UINT32 unIndex,GUID *pguidKey,PROPVARIANT *pValue) PURE;
    STDMETHOD_(HRESULT,GetItemType)(THIS_ REFGUID guidKey,MF_ATTRIBUTE_TYPE *pType) PURE;
    STDMETHOD_(HRESULT,GetString)(THIS_ REFGUID guidKey,LPWSTR pwszValue,UINT32 cchBufSize,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetStringLength)(THIS_ REFGUID guidKey,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetUINT32)(THIS_ REFGUID guidKey,UINT32 *punValue) PURE;
    STDMETHOD_(HRESULT,GetUINT64)(THIS_ REFGUID guidKey,UINT64 *punValue) PURE;
    STDMETHOD_(HRESULT,GetUnknown)(THIS_ REFGUID guidKey,REFIID riid,LPVOID *ppv) PURE;
    STDMETHOD_(HRESULT,LockStore)(THIS) PURE;
    STDMETHOD_(HRESULT,SetBlob)(THIS_ REFGUID guidKey,const UINT8 *pBuf,UINT32 cbBufSize) PURE;
    STDMETHOD_(HRESULT,SetDouble)(THIS_ REFGUID guidKey,double fValue) PURE;
    STDMETHOD_(HRESULT,SetGUID)(THIS_ REFGUID guidKey,REFGUID guidValue) PURE;
    STDMETHOD_(HRESULT,SetItem)(THIS_ REFGUID guidKey,REFPROPVARIANT Value) PURE;
    STDMETHOD_(HRESULT,SetString)(THIS_ REFGUID guidKey,LPCWSTR wszValue) PURE;
    STDMETHOD_(HRESULT,SetUINT32)(THIS_ REFGUID guidKey,UINT32 unValue) PURE;
    STDMETHOD_(HRESULT,SetUINT64)(THIS_ REFGUID guidKey,UINT64 unValue) PURE;
    STDMETHOD_(HRESULT,SetUnknown)(THIS_ REFGUID guidKey,IUnknown *pUnknown) PURE;
    STDMETHOD_(HRESULT,UnlockStore)(THIS) PURE;

    /* IMFASFContentInfo methods */
    STDMETHOD_(HRESULT,GenerateHeader)(THIS_ IMFMediaBuffer *pIHeader,DWORD *pcbHeader) PURE;
    STDMETHOD_(HRESULT,GeneratePresentationDescriptor)(THIS_ IMFPresentationDescriptor **ppIPresentationDescriptor) PURE;
    STDMETHOD_(HRESULT,GetEncodingConfigurationPropertyStore)(THIS_ WORD wStreamNumber,IPropertyStore **ppIStore) PURE;
    STDMETHOD_(HRESULT,GetHeaderSize)(THIS_ IMFMediaBuffer *pIStartOfContent,QWORD *cbHeaderSize) PURE;
    STDMETHOD_(HRESULT,GetProfile)(THIS_ IMFASFProfile **ppIProfile) PURE;
    STDMETHOD_(HRESULT,ParseHeader)(THIS_ IMFMediaBuffer *pIHeaderBuffer,QWORD cbOffsetWithinHeader) PURE;
    STDMETHOD_(HRESULT,SetProfile)(THIS_ IMFASFProfile *pIProfile) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFContentInfo_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFContentInfo_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFContentInfo_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFContentInfo_Compare(This,pTheirs,MatchType,pbResult) (This)->lpVtbl->Compare(This,pTheirs,MatchType,pbResult)
#define IMFASFContentInfo_CompareItem(This,guidKey,Value,pbResult) (This)->lpVtbl->CompareItem(This,guidKey,Value,pbResult)
#define IMFASFContentInfo_CopyAllItems(This,pDest) (This)->lpVtbl->CopyAllItems(This,pDest)
#define IMFASFContentInfo_DeleteAllItems() (This)->lpVtbl->DeleteAllItems(This)
#define IMFASFContentInfo_DeleteItem(This,guidKey) (This)->lpVtbl->DeleteItem(This,guidKey)
#define IMFASFContentInfo_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) (This)->lpVtbl->GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)
#define IMFASFContentInfo_GetAllocatedString(This,guidKey,ppwszValue,pcchLength) (This)->lpVtbl->GetAllocatedString(This,guidKey,ppwszValue,pcchLength)
#define IMFASFContentInfo_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) (This)->lpVtbl->GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)
#define IMFASFContentInfo_GetBlobSize(This,guidKey,pcbBlobSize) (This)->lpVtbl->GetBlobSize(This,guidKey,pcbBlobSize)
#define IMFASFContentInfo_GetCount(This,pcItems) (This)->lpVtbl->GetCount(This,pcItems)
#define IMFASFContentInfo_GetDouble(This,guidKey,pfValue) (This)->lpVtbl->GetDouble(This,guidKey,pfValue)
#define IMFASFContentInfo_GetGUID(This,guidKey,pguidValue) (This)->lpVtbl->GetGUID(This,guidKey,pguidValue)
#define IMFASFContentInfo_GetItem(This,guidKey,pValue) (This)->lpVtbl->GetItem(This,guidKey,pValue)
#define IMFASFContentInfo_GetItemByIndex(This,unIndex,pguidKey,pValue) (This)->lpVtbl->GetItemByIndex(This,unIndex,pguidKey,pValue)
#define IMFASFContentInfo_GetItemType(This,guidKey,pType) (This)->lpVtbl->GetItemType(This,guidKey,pType)
#define IMFASFContentInfo_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) (This)->lpVtbl->GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)
#define IMFASFContentInfo_GetStringLength(This,guidKey,pcchLength) (This)->lpVtbl->GetStringLength(This,guidKey,pcchLength)
#define IMFASFContentInfo_GetUINT32(This,guidKey,punValue) (This)->lpVtbl->GetUINT32(This,guidKey,punValue)
#define IMFASFContentInfo_GetUINT64(This,guidKey,punValue) (This)->lpVtbl->GetUINT64(This,guidKey,punValue)
#define IMFASFContentInfo_GetUnknown(This,guidKey,riid,ppv) (This)->lpVtbl->GetUnknown(This,guidKey,riid,ppv)
#define IMFASFContentInfo_LockStore() (This)->lpVtbl->LockStore(This)
#define IMFASFContentInfo_SetBlob(This,guidKey,pBuf,cbBufSize) (This)->lpVtbl->SetBlob(This,guidKey,pBuf,cbBufSize)
#define IMFASFContentInfo_SetDouble(This,guidKey,fValue) (This)->lpVtbl->SetDouble(This,guidKey,fValue)
#define IMFASFContentInfo_SetGUID(This,guidKey,guidValue) (This)->lpVtbl->SetGUID(This,guidKey,guidValue)
#define IMFASFContentInfo_SetItem(This,guidKey,Value) (This)->lpVtbl->SetItem(This,guidKey,Value)
#define IMFASFContentInfo_SetString(This,guidKey,wszValue) (This)->lpVtbl->SetString(This,guidKey,wszValue)
#define IMFASFContentInfo_SetUINT32(This,guidKey,unValue) (This)->lpVtbl->SetUINT32(This,guidKey,unValue)
#define IMFASFContentInfo_SetUINT64(This,guidKey,unValue) (This)->lpVtbl->SetUINT64(This,guidKey,unValue)
#define IMFASFContentInfo_SetUnknown(This,guidKey,pUnknown) (This)->lpVtbl->SetUnknown(This,guidKey,pUnknown)
#define IMFASFContentInfo_UnlockStore() (This)->lpVtbl->UnlockStore(This)
#define IMFASFContentInfo_GenerateHeader(This,pIHeader,pcbHeader) (This)->lpVtbl->GenerateHeader(This,pIHeader,pcbHeader)
#define IMFASFContentInfo_GeneratePresentationDescriptor(This,ppIPresentationDescriptor) (This)->lpVtbl->GeneratePresentationDescriptor(This,ppIPresentationDescriptor)
#define IMFASFContentInfo_GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore) (This)->lpVtbl->GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore)
#define IMFASFContentInfo_GetHeaderSize(This,pIStartOfContent,cbHeaderSize) (This)->lpVtbl->GetHeaderSize(This,pIStartOfContent,cbHeaderSize)
#define IMFASFContentInfo_GetProfile(This,ppIProfile) (This)->lpVtbl->GetProfile(This,ppIProfile)
#define IMFASFContentInfo_ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader) (This)->lpVtbl->ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader)
#define IMFASFContentInfo_SetProfile(This,pIProfile) (This)->lpVtbl->SetProfile(This,pIProfile)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IMFASFStreamConfig
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFStreamConfig,IMFAttributes)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFAttributes methods */
    STDMETHOD_(HRESULT,Compare)(THIS_ IMFAttributes *pTheirs,MF_ATTRIBUTES_MATCH_TYPE MatchType,BOOL *pbResult) PURE;
    STDMETHOD_(HRESULT,CompareItem)(THIS_ REFGUID guidKey,REFPROPVARIANT Value,BOOL *pbResult) PURE;
    STDMETHOD_(HRESULT,CopyAllItems)(THIS_ IMFAttributes *pDest) PURE;
    STDMETHOD_(HRESULT,DeleteAllItems)(THIS) PURE;
    STDMETHOD_(HRESULT,DeleteItem)(THIS_ REFGUID guidKey) PURE;
    STDMETHOD_(HRESULT,GetAllocatedBlob)(THIS_ REFGUID guidKey,UINT8 **ppBuf,UINT32 *pcbSize) PURE;
    STDMETHOD_(HRESULT,GetAllocatedString)(THIS_ REFGUID guidKey,LPWSTR *ppwszValue,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetBlob)(THIS_ REFGUID guidKey,UINT8 *pBuf,UINT32 cbBufSize,UINT32 *pcbBlobSize) PURE;
    STDMETHOD_(HRESULT,GetBlobSize)(THIS_ REFGUID guidKey,UINT32 *pcbBlobSize) PURE;
    STDMETHOD_(HRESULT,GetCount)(THIS_ UINT32 *pcItems) PURE;
    STDMETHOD_(HRESULT,GetDouble)(THIS_ REFGUID guidKey,double *pfValue) PURE;
    STDMETHOD_(HRESULT,GetGUID)(THIS_ REFGUID guidKey,GUID *pguidValue) PURE;
    STDMETHOD_(HRESULT,GetItem)(THIS_ REFGUID guidKey,PROPVARIANT *pValue) PURE;
    STDMETHOD_(HRESULT,GetItemByIndex)(THIS_ UINT32 unIndex,GUID *pguidKey,PROPVARIANT *pValue) PURE;
    STDMETHOD_(HRESULT,GetItemType)(THIS_ REFGUID guidKey,MF_ATTRIBUTE_TYPE *pType) PURE;
    STDMETHOD_(HRESULT,GetString)(THIS_ REFGUID guidKey,LPWSTR pwszValue,UINT32 cchBufSize,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetStringLength)(THIS_ REFGUID guidKey,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetUINT32)(THIS_ REFGUID guidKey,UINT32 *punValue) PURE;
    STDMETHOD_(HRESULT,GetUINT64)(THIS_ REFGUID guidKey,UINT64 *punValue) PURE;
    STDMETHOD_(HRESULT,GetUnknown)(THIS_ REFGUID guidKey,REFIID riid,LPVOID *ppv) PURE;
    STDMETHOD_(HRESULT,LockStore)(THIS) PURE;
    STDMETHOD_(HRESULT,SetBlob)(THIS_ REFGUID guidKey,const UINT8 *pBuf,UINT32 cbBufSize) PURE;
    STDMETHOD_(HRESULT,SetDouble)(THIS_ REFGUID guidKey,double fValue) PURE;
    STDMETHOD_(HRESULT,SetGUID)(THIS_ REFGUID guidKey,REFGUID guidValue) PURE;
    STDMETHOD_(HRESULT,SetItem)(THIS_ REFGUID guidKey,REFPROPVARIANT Value) PURE;
    STDMETHOD_(HRESULT,SetString)(THIS_ REFGUID guidKey,LPCWSTR wszValue) PURE;
    STDMETHOD_(HRESULT,SetUINT32)(THIS_ REFGUID guidKey,UINT32 unValue) PURE;
    STDMETHOD_(HRESULT,SetUINT64)(THIS_ REFGUID guidKey,UINT64 unValue) PURE;
    STDMETHOD_(HRESULT,SetUnknown)(THIS_ REFGUID guidKey,IUnknown *pUnknown) PURE;
    STDMETHOD_(HRESULT,UnlockStore)(THIS) PURE;

    /* IMFASFStreamConfig methods */
    STDMETHOD_(HRESULT,AddPayloadExtension)(THIS_ GUID guidExtensionSystemID,WORD cbExtensionDataSize,BYTE *pbExtensionSystemInfo,DWORD cbExtensionSystemInfo) PURE;
    STDMETHOD_(HRESULT,Clone)(THIS_ IMFASFStreamConfig **ppIStreamConfig) PURE;
    STDMETHOD_(HRESULT,GetMediaType)(THIS_ IMFMediaType **ppIMediaType) PURE;
    STDMETHOD_(HRESULT,GetPayloadExtension)(THIS_ WORD wPayloadExtensionNumber,GUID *pguidExtensionSystemID,WORD *pcbExtensionDataSize,BYTE *pbExtensionSystemInfo,DWORD *pcbExtensionSystemInfo) PURE;
    STDMETHOD_(HRESULT,GetPayloadExtensionCount)(THIS_ WORD *pcPayloadExtensions) PURE;
    STDMETHOD_(WORD,GetStreamNumber)(THIS) PURE;
    STDMETHOD_(HRESULT,GetStreamType)(THIS_ GUID *pguidStreamType) PURE;
    STDMETHOD_(HRESULT,RemoveAllPayloadExtensions)(THIS) PURE;
    STDMETHOD_(HRESULT,SetMediaType)(THIS_ IMFMediaType *pIMediaType) PURE;
    STDMETHOD_(HRESULT,SetStreamNumber)(THIS_ WORD wStreamNum) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFStreamConfig_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFStreamConfig_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFStreamConfig_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFStreamConfig_Compare(This,pTheirs,MatchType,pbResult) (This)->lpVtbl->Compare(This,pTheirs,MatchType,pbResult)
#define IMFASFStreamConfig_CompareItem(This,guidKey,Value,pbResult) (This)->lpVtbl->CompareItem(This,guidKey,Value,pbResult)
#define IMFASFStreamConfig_CopyAllItems(This,pDest) (This)->lpVtbl->CopyAllItems(This,pDest)
#define IMFASFStreamConfig_DeleteAllItems() (This)->lpVtbl->DeleteAllItems(This)
#define IMFASFStreamConfig_DeleteItem(This,guidKey) (This)->lpVtbl->DeleteItem(This,guidKey)
#define IMFASFStreamConfig_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) (This)->lpVtbl->GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)
#define IMFASFStreamConfig_GetAllocatedString(This,guidKey,ppwszValue,pcchLength) (This)->lpVtbl->GetAllocatedString(This,guidKey,ppwszValue,pcchLength)
#define IMFASFStreamConfig_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) (This)->lpVtbl->GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)
#define IMFASFStreamConfig_GetBlobSize(This,guidKey,pcbBlobSize) (This)->lpVtbl->GetBlobSize(This,guidKey,pcbBlobSize)
#define IMFASFStreamConfig_GetCount(This,pcItems) (This)->lpVtbl->GetCount(This,pcItems)
#define IMFASFStreamConfig_GetDouble(This,guidKey,pfValue) (This)->lpVtbl->GetDouble(This,guidKey,pfValue)
#define IMFASFStreamConfig_GetGUID(This,guidKey,pguidValue) (This)->lpVtbl->GetGUID(This,guidKey,pguidValue)
#define IMFASFStreamConfig_GetItem(This,guidKey,pValue) (This)->lpVtbl->GetItem(This,guidKey,pValue)
#define IMFASFStreamConfig_GetItemByIndex(This,unIndex,pguidKey,pValue) (This)->lpVtbl->GetItemByIndex(This,unIndex,pguidKey,pValue)
#define IMFASFStreamConfig_GetItemType(This,guidKey,pType) (This)->lpVtbl->GetItemType(This,guidKey,pType)
#define IMFASFStreamConfig_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) (This)->lpVtbl->GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)
#define IMFASFStreamConfig_GetStringLength(This,guidKey,pcchLength) (This)->lpVtbl->GetStringLength(This,guidKey,pcchLength)
#define IMFASFStreamConfig_GetUINT32(This,guidKey,punValue) (This)->lpVtbl->GetUINT32(This,guidKey,punValue)
#define IMFASFStreamConfig_GetUINT64(This,guidKey,punValue) (This)->lpVtbl->GetUINT64(This,guidKey,punValue)
#define IMFASFStreamConfig_GetUnknown(This,guidKey,riid,ppv) (This)->lpVtbl->GetUnknown(This,guidKey,riid,ppv)
#define IMFASFStreamConfig_LockStore() (This)->lpVtbl->LockStore(This)
#define IMFASFStreamConfig_SetBlob(This,guidKey,pBuf,cbBufSize) (This)->lpVtbl->SetBlob(This,guidKey,pBuf,cbBufSize)
#define IMFASFStreamConfig_SetDouble(This,guidKey,fValue) (This)->lpVtbl->SetDouble(This,guidKey,fValue)
#define IMFASFStreamConfig_SetGUID(This,guidKey,guidValue) (This)->lpVtbl->SetGUID(This,guidKey,guidValue)
#define IMFASFStreamConfig_SetItem(This,guidKey,Value) (This)->lpVtbl->SetItem(This,guidKey,Value)
#define IMFASFStreamConfig_SetString(This,guidKey,wszValue) (This)->lpVtbl->SetString(This,guidKey,wszValue)
#define IMFASFStreamConfig_SetUINT32(This,guidKey,unValue) (This)->lpVtbl->SetUINT32(This,guidKey,unValue)
#define IMFASFStreamConfig_SetUINT64(This,guidKey,unValue) (This)->lpVtbl->SetUINT64(This,guidKey,unValue)
#define IMFASFStreamConfig_SetUnknown(This,guidKey,pUnknown) (This)->lpVtbl->SetUnknown(This,guidKey,pUnknown)
#define IMFASFStreamConfig_UnlockStore() (This)->lpVtbl->UnlockStore(This)
#define IMFASFStreamConfig_AddPayloadExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo) (This)->lpVtbl->AddPayloadExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo)
#define IMFASFStreamConfig_Clone(This,ppIStreamConfig) (This)->lpVtbl->Clone(This,ppIStreamConfig)
#define IMFASFStreamConfig_GetMediaType(This,ppIMediaType) (This)->lpVtbl->GetMediaType(This,ppIMediaType)
#define IMFASFStreamConfig_GetPayloadExtension(This,wPayloadExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo) (This)->lpVtbl->GetPayloadExtension(This,wPayloadExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo)
#define IMFASFStreamConfig_GetPayloadExtensionCount(This,pcPayloadExtensions) (This)->lpVtbl->GetPayloadExtensionCount(This,pcPayloadExtensions)
#define IMFASFStreamConfig_GetStreamNumber() (This)->lpVtbl->GetStreamNumber(This)
#define IMFASFStreamConfig_GetStreamType(This,pguidStreamType) (This)->lpVtbl->GetStreamType(This,pguidStreamType)
#define IMFASFStreamConfig_RemoveAllPayloadExtensions() (This)->lpVtbl->RemoveAllPayloadExtensions(This)
#define IMFASFStreamConfig_SetMediaType(This,pIMediaType) (This)->lpVtbl->SetMediaType(This,pIMediaType)
#define IMFASFStreamConfig_SetStreamNumber(This,wStreamNum) (This)->lpVtbl->SetStreamNumber(This,wStreamNum)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IMFASFProfile
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFProfile,IMFAttributes)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFAttributes methods */
    STDMETHOD_(HRESULT,Compare)(THIS_ IMFAttributes *pTheirs,MF_ATTRIBUTES_MATCH_TYPE MatchType,BOOL *pbResult) PURE;
    STDMETHOD_(HRESULT,CompareItem)(THIS_ REFGUID guidKey,REFPROPVARIANT Value,BOOL *pbResult) PURE;
    STDMETHOD_(HRESULT,CopyAllItems)(THIS_ IMFAttributes *pDest) PURE;
    STDMETHOD_(HRESULT,DeleteAllItems)(THIS) PURE;
    STDMETHOD_(HRESULT,DeleteItem)(THIS_ REFGUID guidKey) PURE;
    STDMETHOD_(HRESULT,GetAllocatedBlob)(THIS_ REFGUID guidKey,UINT8 **ppBuf,UINT32 *pcbSize) PURE;
    STDMETHOD_(HRESULT,GetAllocatedString)(THIS_ REFGUID guidKey,LPWSTR *ppwszValue,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetBlob)(THIS_ REFGUID guidKey,UINT8 *pBuf,UINT32 cbBufSize,UINT32 *pcbBlobSize) PURE;
    STDMETHOD_(HRESULT,GetBlobSize)(THIS_ REFGUID guidKey,UINT32 *pcbBlobSize) PURE;
    STDMETHOD_(HRESULT,GetCount)(THIS_ UINT32 *pcItems) PURE;
    STDMETHOD_(HRESULT,GetDouble)(THIS_ REFGUID guidKey,double *pfValue) PURE;
    STDMETHOD_(HRESULT,GetGUID)(THIS_ REFGUID guidKey,GUID *pguidValue) PURE;
    STDMETHOD_(HRESULT,GetItem)(THIS_ REFGUID guidKey,PROPVARIANT *pValue) PURE;
    STDMETHOD_(HRESULT,GetItemByIndex)(THIS_ UINT32 unIndex,GUID *pguidKey,PROPVARIANT *pValue) PURE;
    STDMETHOD_(HRESULT,GetItemType)(THIS_ REFGUID guidKey,MF_ATTRIBUTE_TYPE *pType) PURE;
    STDMETHOD_(HRESULT,GetString)(THIS_ REFGUID guidKey,LPWSTR pwszValue,UINT32 cchBufSize,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetStringLength)(THIS_ REFGUID guidKey,UINT32 *pcchLength) PURE;
    STDMETHOD_(HRESULT,GetUINT32)(THIS_ REFGUID guidKey,UINT32 *punValue) PURE;
    STDMETHOD_(HRESULT,GetUINT64)(THIS_ REFGUID guidKey,UINT64 *punValue) PURE;
    STDMETHOD_(HRESULT,GetUnknown)(THIS_ REFGUID guidKey,REFIID riid,LPVOID *ppv) PURE;
    STDMETHOD_(HRESULT,LockStore)(THIS) PURE;
    STDMETHOD_(HRESULT,SetBlob)(THIS_ REFGUID guidKey,const UINT8 *pBuf,UINT32 cbBufSize) PURE;
    STDMETHOD_(HRESULT,SetDouble)(THIS_ REFGUID guidKey,double fValue) PURE;
    STDMETHOD_(HRESULT,SetGUID)(THIS_ REFGUID guidKey,REFGUID guidValue) PURE;
    STDMETHOD_(HRESULT,SetItem)(THIS_ REFGUID guidKey,REFPROPVARIANT Value) PURE;
    STDMETHOD_(HRESULT,SetString)(THIS_ REFGUID guidKey,LPCWSTR wszValue) PURE;
    STDMETHOD_(HRESULT,SetUINT32)(THIS_ REFGUID guidKey,UINT32 unValue) PURE;
    STDMETHOD_(HRESULT,SetUINT64)(THIS_ REFGUID guidKey,UINT64 unValue) PURE;
    STDMETHOD_(HRESULT,SetUnknown)(THIS_ REFGUID guidKey,IUnknown *pUnknown) PURE;
    STDMETHOD_(HRESULT,UnlockStore)(THIS) PURE;

    /* IMFASFProfile methods */
    STDMETHOD_(HRESULT,AddMutualExclusion)(THIS_ IMFASFMutualExclusion *pIMutex) PURE;
    STDMETHOD_(HRESULT,AddStreamPrioritization)(THIS_ IMFASFStreamPrioritization *pIStreamPrioritization) PURE;
    STDMETHOD_(HRESULT,Clone)(THIS_ IMFASFProfile **ppIProfile) PURE;
    STDMETHOD_(HRESULT,CreateMutualExclusion)(THIS_ IMFASFMutualExclusion **ppIMutex) PURE;
    STDMETHOD_(HRESULT,CreateStream)(THIS_ IMFMediaType *pIMediaType,IMFASFStreamConfig **ppIStream) PURE;
    STDMETHOD_(HRESULT,CreateStreamPrioritization)(THIS_ IMFASFStreamPrioritization **ppIStreamPrioritization) PURE;
    STDMETHOD_(HRESULT,GetMutualExclusion)(THIS_ DWORD dwMutexIndex,IMFASFMutualExclusion **ppIMutex) PURE;
    STDMETHOD_(HRESULT,GetMutualExclusionCount)(THIS_ DWORD *pcMutexs) PURE;
    STDMETHOD_(HRESULT,GetStream)(THIS_ DWORD dwStreamIndex,WORD *pwStreamNumber,IMFASFStreamConfig **ppIStream) PURE;
    STDMETHOD_(HRESULT,GetStreamByNumber)(THIS_ WORD wStreamNumber,IMFASFStreamConfig **ppIStream) PURE;
    STDMETHOD_(HRESULT,GetStreamCount)(THIS_ DWORD *pcStreams) PURE;
    STDMETHOD_(HRESULT,GetStreamPrioritization)(THIS_ IMFASFStreamPrioritization **ppIStreamPrioritization) PURE;
    STDMETHOD_(HRESULT,RemoveMutualExclusion)(THIS_ DWORD dwMutexIndex) PURE;
    STDMETHOD_(HRESULT,RemoveStream)(THIS_ WORD wStreamNumber) PURE;
    STDMETHOD_(HRESULT,RemoveStreamPrioritization)(THIS) PURE;
    STDMETHOD_(HRESULT,SetStream)(THIS_ IMFASFStreamConfig *pIStream) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFProfile_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFProfile_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFProfile_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFProfile_Compare(This,pTheirs,MatchType,pbResult) (This)->lpVtbl->Compare(This,pTheirs,MatchType,pbResult)
#define IMFASFProfile_CompareItem(This,guidKey,Value,pbResult) (This)->lpVtbl->CompareItem(This,guidKey,Value,pbResult)
#define IMFASFProfile_CopyAllItems(This,pDest) (This)->lpVtbl->CopyAllItems(This,pDest)
#define IMFASFProfile_DeleteAllItems() (This)->lpVtbl->DeleteAllItems(This)
#define IMFASFProfile_DeleteItem(This,guidKey) (This)->lpVtbl->DeleteItem(This,guidKey)
#define IMFASFProfile_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) (This)->lpVtbl->GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)
#define IMFASFProfile_GetAllocatedString(This,guidKey,ppwszValue,pcchLength) (This)->lpVtbl->GetAllocatedString(This,guidKey,ppwszValue,pcchLength)
#define IMFASFProfile_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) (This)->lpVtbl->GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)
#define IMFASFProfile_GetBlobSize(This,guidKey,pcbBlobSize) (This)->lpVtbl->GetBlobSize(This,guidKey,pcbBlobSize)
#define IMFASFProfile_GetCount(This,pcItems) (This)->lpVtbl->GetCount(This,pcItems)
#define IMFASFProfile_GetDouble(This,guidKey,pfValue) (This)->lpVtbl->GetDouble(This,guidKey,pfValue)
#define IMFASFProfile_GetGUID(This,guidKey,pguidValue) (This)->lpVtbl->GetGUID(This,guidKey,pguidValue)
#define IMFASFProfile_GetItem(This,guidKey,pValue) (This)->lpVtbl->GetItem(This,guidKey,pValue)
#define IMFASFProfile_GetItemByIndex(This,unIndex,pguidKey,pValue) (This)->lpVtbl->GetItemByIndex(This,unIndex,pguidKey,pValue)
#define IMFASFProfile_GetItemType(This,guidKey,pType) (This)->lpVtbl->GetItemType(This,guidKey,pType)
#define IMFASFProfile_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) (This)->lpVtbl->GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)
#define IMFASFProfile_GetStringLength(This,guidKey,pcchLength) (This)->lpVtbl->GetStringLength(This,guidKey,pcchLength)
#define IMFASFProfile_GetUINT32(This,guidKey,punValue) (This)->lpVtbl->GetUINT32(This,guidKey,punValue)
#define IMFASFProfile_GetUINT64(This,guidKey,punValue) (This)->lpVtbl->GetUINT64(This,guidKey,punValue)
#define IMFASFProfile_GetUnknown(This,guidKey,riid,ppv) (This)->lpVtbl->GetUnknown(This,guidKey,riid,ppv)
#define IMFASFProfile_LockStore() (This)->lpVtbl->LockStore(This)
#define IMFASFProfile_SetBlob(This,guidKey,pBuf,cbBufSize) (This)->lpVtbl->SetBlob(This,guidKey,pBuf,cbBufSize)
#define IMFASFProfile_SetDouble(This,guidKey,fValue) (This)->lpVtbl->SetDouble(This,guidKey,fValue)
#define IMFASFProfile_SetGUID(This,guidKey,guidValue) (This)->lpVtbl->SetGUID(This,guidKey,guidValue)
#define IMFASFProfile_SetItem(This,guidKey,Value) (This)->lpVtbl->SetItem(This,guidKey,Value)
#define IMFASFProfile_SetString(This,guidKey,wszValue) (This)->lpVtbl->SetString(This,guidKey,wszValue)
#define IMFASFProfile_SetUINT32(This,guidKey,unValue) (This)->lpVtbl->SetUINT32(This,guidKey,unValue)
#define IMFASFProfile_SetUINT64(This,guidKey,unValue) (This)->lpVtbl->SetUINT64(This,guidKey,unValue)
#define IMFASFProfile_SetUnknown(This,guidKey,pUnknown) (This)->lpVtbl->SetUnknown(This,guidKey,pUnknown)
#define IMFASFProfile_UnlockStore() (This)->lpVtbl->UnlockStore(This)
#define IMFASFProfile_AddMutualExclusion(This,pIMutex) (This)->lpVtbl->AddMutualExclusion(This,pIMutex)
#define IMFASFProfile_AddStreamPrioritization(This,pIStreamPrioritization) (This)->lpVtbl->AddStreamPrioritization(This,pIStreamPrioritization)
#define IMFASFProfile_Clone(This,ppIProfile) (This)->lpVtbl->Clone(This,ppIProfile)
#define IMFASFProfile_CreateMutualExclusion(This,ppIMutex) (This)->lpVtbl->CreateMutualExclusion(This,ppIMutex)
#define IMFASFProfile_CreateStream(This,pIMediaType,ppIStream) (This)->lpVtbl->CreateStream(This,pIMediaType,ppIStream)
#define IMFASFProfile_CreateStreamPrioritization(This,ppIStreamPrioritization) (This)->lpVtbl->CreateStreamPrioritization(This,ppIStreamPrioritization)
#define IMFASFProfile_GetMutualExclusion(This,dwMutexIndex,ppIMutex) (This)->lpVtbl->GetMutualExclusion(This,dwMutexIndex,ppIMutex)
#define IMFASFProfile_GetMutualExclusionCount(This,pcMutexs) (This)->lpVtbl->GetMutualExclusionCount(This,pcMutexs)
#define IMFASFProfile_GetStream(This,dwStreamIndex,pwStreamNumber,ppIStream) (This)->lpVtbl->GetStream(This,dwStreamIndex,pwStreamNumber,ppIStream)
#define IMFASFProfile_GetStreamByNumber(This,wStreamNumber,ppIStream) (This)->lpVtbl->GetStreamByNumber(This,wStreamNumber,ppIStream)
#define IMFASFProfile_GetStreamCount(This,pcStreams) (This)->lpVtbl->GetStreamCount(This,pcStreams)
#define IMFASFProfile_GetStreamPrioritization(This,ppIStreamPrioritization) (This)->lpVtbl->GetStreamPrioritization(This,ppIStreamPrioritization)
#define IMFASFProfile_RemoveMutualExclusion(This,dwMutexIndex) (This)->lpVtbl->RemoveMutualExclusion(This,dwMutexIndex)
#define IMFASFProfile_RemoveStream(This,wStreamNumber) (This)->lpVtbl->RemoveStream(This,wStreamNumber)
#define IMFASFProfile_RemoveStreamPrioritization() (This)->lpVtbl->RemoveStreamPrioritization(This)
#define IMFASFProfile_SetStream(This,pIStream) (This)->lpVtbl->SetStream(This,pIStream)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IMFASFIndexer
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFIndexer,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFASFIndexer methods */
    STDMETHOD_(HRESULT,CommitIndex)(THIS_ IMFASFContentInfo *pIContentInfo) PURE;
    STDMETHOD_(HRESULT,GenerateIndexEntries)(THIS_ IMFSample *pIASFPacketSample) PURE;
    STDMETHOD_(HRESULT,GetCompletedIndex)(THIS_ IMFMediaBuffer *pIIndexBuffer,QWORD cbOffsetWithinIndex) PURE;
    STDMETHOD_(HRESULT,GetFlags)(THIS_ DWORD *pdwFlags) PURE;
    STDMETHOD_(HRESULT,GetIndexByteStreamCount)(THIS_ DWORD *pcByteStreams) PURE;
    STDMETHOD_(HRESULT,GetIndexPosition)(THIS_ IMFASFContentInfo *pIContentInfo,QWORD *pcbIndexOffset) PURE;
    STDMETHOD_(HRESULT,GetIndexStatus)(THIS_ ASF_INDEX_IDENTIFIER *pIndexIdentifier,WINBOOL *pfIsIndexed,BYTE *pbIndexDescriptor,DWORD *pcbIndexDescriptor) PURE;
    STDMETHOD_(HRESULT,GetIndexWriteSpace)(THIS_ QWORD *pcbIndexWriteSpace) PURE;
    STDMETHOD_(HRESULT,GetSeekPositionForValue)(THIS_ const PROPVARIANT *pvarValue,ASF_INDEX_IDENTIFIER *pIndexIdentifier,QWORD *pcbOffsetWithinData,MFTIME *phnsApproxTime,DWORD *pdwPayloadNumberOfStreamWithinPacket) PURE;
    STDMETHOD_(HRESULT,Initialize)(THIS_ IMFASFContentInfo *pIContentInfo) PURE;
    STDMETHOD_(HRESULT,SetFlags)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(HRESULT,SetIndexByteStreams)(THIS_ IMFByteStream **ppIByteStreams,DWORD cByteStreams) PURE;
    STDMETHOD_(HRESULT,SetIndexStatus)(THIS_ BYTE *pIndexDescriptor,DWORD cbIndexDescriptor,WINBOOL fGenerateIndex) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFIndexer_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFIndexer_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFIndexer_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFIndexer_CommitIndex(This,pIContentInfo) (This)->lpVtbl->CommitIndex(This,pIContentInfo)
#define IMFASFIndexer_GenerateIndexEntries(This,pIASFPacketSample) (This)->lpVtbl->GenerateIndexEntries(This,pIASFPacketSample)
#define IMFASFIndexer_GetCompletedIndex(This,pIIndexBuffer,cbOffsetWithinIndex) (This)->lpVtbl->GetCompletedIndex(This,pIIndexBuffer,cbOffsetWithinIndex)
#define IMFASFIndexer_GetFlags(This,pdwFlags) (This)->lpVtbl->GetFlags(This,pdwFlags)
#define IMFASFIndexer_GetIndexByteStreamCount(This,pcByteStreams) (This)->lpVtbl->GetIndexByteStreamCount(This,pcByteStreams)
#define IMFASFIndexer_GetIndexPosition(This,pIContentInfo,pcbIndexOffset) (This)->lpVtbl->GetIndexPosition(This,pIContentInfo,pcbIndexOffset)
#define IMFASFIndexer_GetIndexStatus(This,pIndexIdentifier,pfIsIndexed,pbIndexDescriptor,pcbIndexDescriptor) (This)->lpVtbl->GetIndexStatus(This,pIndexIdentifier,pfIsIndexed,pbIndexDescriptor,pcbIndexDescriptor)
#define IMFASFIndexer_GetIndexWriteSpace(This,pcbIndexWriteSpace) (This)->lpVtbl->GetIndexWriteSpace(This,pcbIndexWriteSpace)
#define IMFASFIndexer_GetSeekPositionForValue(This,pvarValue,pIndexIdentifier,pcbOffsetWithinData,phnsApproxTime,pdwPayloadNumberOfStreamWithinPacket) (This)->lpVtbl->GetSeekPositionForValue(This,pvarValue,pIndexIdentifier,pcbOffsetWithinData,phnsApproxTime,pdwPayloadNumberOfStreamWithinPacket)
#define IMFASFIndexer_Initialize(This,pIContentInfo) (This)->lpVtbl->Initialize(This,pIContentInfo)
#define IMFASFIndexer_SetFlags(This,dwFlags) (This)->lpVtbl->SetFlags(This,dwFlags)
#define IMFASFIndexer_SetIndexByteStreams(This,ppIByteStreams,cByteStreams) (This)->lpVtbl->SetIndexByteStreams(This,ppIByteStreams,cByteStreams)
#define IMFASFIndexer_SetIndexStatus(This,pIndexDescriptor,cbIndexDescriptor,fGenerateIndex) (This)->lpVtbl->SetIndexStatus(This,pIndexDescriptor,cbIndexDescriptor,fGenerateIndex)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IMFASFMultiplexer
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IMFASFMultiplexer,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IMFASFMultiplexer methods */
    STDMETHOD_(HRESULT,End)(THIS_ IMFASFContentInfo *pIContentInfo) PURE;
    STDMETHOD_(HRESULT,Flush)(THIS) PURE;
    STDMETHOD_(HRESULT,GetFlags)(THIS_ DWORD *pdwFlags) PURE;
    STDMETHOD_(HRESULT,GetNextPacket)(THIS_ DWORD *pdwStatusFlags,IMFSample **ppIPacket) PURE;
    STDMETHOD_(HRESULT,GetStatistics)(THIS_ WORD wStreamNumber,ASF_MUX_STATISTICS *pMuxStats) PURE;
    STDMETHOD_(HRESULT,Initialize)(THIS_ IMFASFContentInfo *pIContentInfo) PURE;
    STDMETHOD_(HRESULT,ProcessSample)(THIS_ WORD wStreamNumber,IMFSample *pISample,LONGLONG hnsTimestampAdjust) PURE;
    STDMETHOD_(HRESULT,SetFlags)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(HRESULT,SetSyncTolerance)(THIS_ DWORD msSyncTolerance) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IMFASFMultiplexer_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IMFASFMultiplexer_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IMFASFMultiplexer_Release(This) (This)->lpVtbl->Release(This)
#define IMFASFMultiplexer_End(This,pIContentInfo) (This)->lpVtbl->End(This,pIContentInfo)
#define IMFASFMultiplexer_Flush() (This)->lpVtbl->Flush(This)
#define IMFASFMultiplexer_GetFlags(This,pdwFlags) (This)->lpVtbl->GetFlags(This,pdwFlags)
#define IMFASFMultiplexer_GetNextPacket(This,pdwStatusFlags,ppIPacket) (This)->lpVtbl->GetNextPacket(This,pdwStatusFlags,ppIPacket)
#define IMFASFMultiplexer_GetStatistics(This,wStreamNumber,pMuxStats) (This)->lpVtbl->GetStatistics(This,wStreamNumber,pMuxStats)
#define IMFASFMultiplexer_Initialize(This,pIContentInfo) (This)->lpVtbl->Initialize(This,pIContentInfo)
#define IMFASFMultiplexer_ProcessSample(This,wStreamNumber,pISample,hnsTimestampAdjust) (This)->lpVtbl->ProcessSample(This,wStreamNumber,pISample,hnsTimestampAdjust)
#define IMFASFMultiplexer_SetFlags(This,dwFlags) (This)->lpVtbl->SetFlags(This,dwFlags)
#define IMFASFMultiplexer_SetSyncTolerance(This,msSyncTolerance) (This)->lpVtbl->SetSyncTolerance(This,msSyncTolerance)
#endif /*COBJMACROS*/

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI MFCreateASFSplitter(IMFASFSplitter **ppISplitter);
HRESULT WINAPI MFCreateAttributes(IMFAttributes **ppMFAttributes,UINT32 cInitialSize);
HRESULT WINAPI MFCreateWMAEncoderActivate(IMFMediaType *pMediaType,IPropertyStore *pEncodingConfigurationProperties,IMFActivate **ppActivate);
HRESULT WINAPI MFCreateWMVEncoderActivate(IMFMediaType *pMediaType,IPropertyStore *pEncodingConfigurationProperties,IMFActivate **ppActivate);

#ifdef __cplusplus
}
#endif

#endif /* (_WIN32_WINNT >= 0x0600) */
#endif /*_INC_WMCONTAINER*/
                                                                                                                                                                                                                       usr/share/mingw-w64/include/wmiatlprov.h                                                            0100644 0000000 0000000 00000040626 12404413016 016722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __ATLWMIPROV_H__
#define __ATLWMIPROV_H__

#ifndef __cplusplus
#error Requires C++ compilation (use a .cpp suffix)
#endif

#include <wbemprov.h>
#include <wmiutils.h>

namespace ATL {
  class ATL_NO_VTABLE IWbemInstProviderImpl : public IWbemServices,public IWbemProviderInit {
  public:
    HRESULT WINAPI OpenNamespace(const BSTR Namespace,__LONG32 lFlags,IWbemContext *pCtx,IWbemServices **ppWorkingNamespace,IWbemCallResult **ppResult) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI CancelAsyncCall(IWbemObjectSink *pSink) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI QueryObjectSink(__LONG32 lFlags,IWbemObjectSink **ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI GetObject(const BSTR ObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject **ppObject,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI PutClass(IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI PutClassAsync(IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI DeleteClass(const BSTR Class,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI DeleteClassAsync(const BSTR Class,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI CreateClassEnum(const BSTR Superclass,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI CreateClassEnumAsync(const BSTR Superclass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI PutInstance(IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI DeleteInstance(const BSTR ObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI CreateInstanceEnum(const BSTR Class,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI ExecQuery(const BSTR QueryLanguage,const BSTR Query,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI ExecNotificationQuery(const BSTR QueryLanguage,const BSTR Query,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI ExecNotificationQueryAsync(const BSTR QueryLanguage,const BSTR Query,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI ExecMethod(const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemClassObject **ppOutParams,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    HRESULT WINAPI ExecMethodAsync(const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
  };

  class CProviderHelper {
  private:
    CComPtr<IWbemClassObject> m_pErrorObject;
    HRESULT m_hr;
  public:
    CProviderHelper(IWbemServices *pNamespace,IWbemContext *pCtx) {
      m_hr = WBEM_E_FAILED;
      m_pErrorObject = NULL;
      if(!pNamespace) {
	m_hr = WBEM_E_INVALID_PARAMETER;
	ATLASSERT (0);
	return;
      }
      BSTR bstrString = SysAllocString(L"__ExtendedStatus");
      if(!bstrString) {
	m_hr = WBEM_E_OUT_OF_MEMORY;
	return;
      }
      m_hr = pNamespace->GetObject(bstrString,0,pCtx,&m_pErrorObject,NULL);
      SysFreeString(bstrString);
      return;
    }
    virtual ~CProviderHelper() { }
    HRESULT WINAPI ConstructErrorObject (const ULONG ulStatusCode,const BSTR bstrDescription,const BSTR bstrOperation,const BSTR bstrParameter,const BSTR bstrProviderName,IWbemClassObject **ppErrorObject) {
      static const LPWSTR lpwstrDescription = L"Description";
      static const LPWSTR lpwstrOperation = L"Operation";
      static const LPWSTR lpwstrStatusCode = L"StatusCode";
      static const LPWSTR lpwstrParameterInfo = L"ParameterInfo";
      static const LPWSTR lpwstrProviderName = L"ProviderName";

      if(FAILED (m_hr)) {
	ATLASSERT (0);
	return m_hr;
      }
      if(!ppErrorObject) {
	ATLASSERT (0);
	return WBEM_E_INVALID_PARAMETER;
      }
      HRESULT hr = m_pErrorObject->SpawnInstance(0,ppErrorObject);
      if(FAILED(hr)) return hr;
      VARIANT var;
      VariantInit(&var);
      var.vt = VT_I4;
      var.lVal = ulStatusCode;
      hr = (*ppErrorObject)->Put(lpwstrStatusCode,0,&var,0);
      if(FAILED(hr)) return hr;
      var.vt = VT_BSTR;
      if(bstrDescription!=NULL) {
	var.bstrVal = bstrDescription;
	hr = (*ppErrorObject)->Put(lpwstrDescription,0,&var,0);
	if(FAILED(hr)) return hr;
      }
      if(bstrOperation!=NULL) {
	var.bstrVal = bstrOperation;
	hr = (*ppErrorObject)->Put(lpwstrOperation,0,&var,0);
	if(FAILED(hr)) return hr;
      }
      if(bstrParameter!=NULL) {
	var.bstrVal = bstrParameter;
	hr = (*ppErrorObject)->Put(lpwstrParameterInfo,0,&var,0);
	if(FAILED(hr)) return hr;
      }
      if(bstrProviderName!=NULL) {
	var.bstrVal = bstrProviderName;
	hr = (*ppErrorObject)->Put(lpwstrProviderName,0,&var,0);
	if(FAILED(hr)) return hr;
      }
      return hr;
    }
  };

  class CIntrinsicEventProviderHelper : public CProviderHelper {
  private:
    CComPtr<IWbemClassObject> m_pCreationEventClass;
    CComPtr<IWbemClassObject> m_pDeletionEventClass;
    CComPtr<IWbemClassObject> m_pModificationEventClass;
    HRESULT m_hr;
  public:
    CIntrinsicEventProviderHelper(IWbemServices *pNamespace,IWbemContext *pCtx) : CProviderHelper (pNamespace,pCtx) {
      m_hr = WBEM_E_FAILED;
      if(!pNamespace || !pCtx) {
	m_hr = WBEM_E_INVALID_PARAMETER;
	ATLASSERT (0);
	return;
      }
      m_pCreationEventClass = NULL;
      m_pModificationEventClass = NULL;
      m_pDeletionEventClass = NULL;
      BSTR bstrString = SysAllocString(L"__InstanceCreationEvent");
      if(!bstrString) {
	m_hr = WBEM_E_OUT_OF_MEMORY;
	return;
      }
      m_hr = pNamespace->GetObject(bstrString,0,pCtx,&m_pCreationEventClass,NULL);
      SysFreeString(bstrString);
      bstrString=NULL;
      if(FAILED(m_hr)) return;
      bstrString = SysAllocString(L"__InstanceModificationEvent");
      if(!bstrString) {
	m_hr = WBEM_E_OUT_OF_MEMORY;
	return;
      }
      m_hr = pNamespace->GetObject(bstrString,0,pCtx,&m_pModificationEventClass,NULL);
      SysFreeString(bstrString);
      bstrString=NULL;
      if(FAILED(m_hr)) return;
      bstrString = SysAllocString(L"__InstanceDeletionEvent");
      if(!bstrString) {
	m_hr = WBEM_E_OUT_OF_MEMORY;
	return;
      }
      m_hr = pNamespace->GetObject(bstrString,0,pCtx,&m_pDeletionEventClass,NULL);
      SysFreeString(bstrString);
      bstrString=NULL;
      if(FAILED(m_hr)) return;
      return;
    }
    virtual ~CIntrinsicEventProviderHelper() { }
    HRESULT WINAPI FireCreationEvent(IWbemClassObject *pNewInstance,IWbemObjectSink *pSink) {
      if(FAILED(m_hr)) {
	ATLASSERT (0);
	return m_hr;
      }
      if(!pNewInstance || !pSink) {
	ATLASSERT (0);
	return WBEM_E_INVALID_PARAMETER;
      }
      CComPtr<IWbemClassObject> pEvtInstance;
      HRESULT hr = m_pCreationEventClass->SpawnInstance(0,&pEvtInstance);
      if(FAILED(hr)) return hr;
      VARIANT var;
      VariantInit(&var);
      var.vt = VT_UNKNOWN;
      CComQIPtr<IUnknown,&IID_IUnknown>pTemp(pNewInstance);
      var.punkVal = pTemp;
      hr = pEvtInstance->Put(L"TargetInstance",0,&var,0);
      if(FAILED(hr)) return hr;
      IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
      return pSink->Indicate(1,&_pEvtInstance);
    }
    HRESULT WINAPI FireDeletionEvent(IWbemClassObject *pInstanceToDelete,IWbemObjectSink *pSink) {
      if(FAILED (m_hr)) {
	ATLASSERT (0);
	return m_hr;
      }
      if(!pInstanceToDelete || !pSink) {
	ATLASSERT (0);
	return WBEM_E_INVALID_PARAMETER;
      }
      CComPtr<IWbemClassObject> pEvtInstance;
      HRESULT hr = m_pDeletionEventClass->SpawnInstance(0,&pEvtInstance);
      if(FAILED(hr)) return hr;
      VARIANT var;
      VariantInit(&var);
      var.vt = VT_UNKNOWN;
      CComQIPtr<IUnknown,&IID_IUnknown>pTemp(pInstanceToDelete);
      var.punkVal = pTemp;
      hr = pEvtInstance->Put(L"TargetInstance",0,&var,0);
      if(FAILED(hr)) return hr;
      IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
      return pSink->Indicate(1,&_pEvtInstance);
    }
    HRESULT WINAPI FireModificationEvent(IWbemClassObject *pOldInstance,IWbemClassObject *pNewInstance,IWbemObjectSink *pSink) {
      if(FAILED (m_hr)) {
	ATLASSERT (0);
	return m_hr;
      }
      if(!pOldInstance || !pNewInstance || !pSink) {
	ATLASSERT (0);
	return WBEM_E_INVALID_PARAMETER;
      }
      CComPtr<IWbemClassObject> pEvtInstance;
      HRESULT hr = m_pModificationEventClass->SpawnInstance(0,&pEvtInstance);
      if(FAILED(hr)) return hr;
      VARIANT var;
      VariantInit(&var);
      var.vt = VT_UNKNOWN;
      CComQIPtr<IUnknown,&IID_IUnknown>pTempNew(pNewInstance);
      var.punkVal = pTempNew;
      hr = pEvtInstance->Put(L"TargetInstance",0,&var,0);
      if(FAILED(hr)) return hr;
      CComQIPtr<IUnknown,&IID_IUnknown>pTempOld(pOldInstance);
      var.punkVal = pTempOld;
      hr = pEvtInstance->Put(L"PreviousInstance",0,&var,0);
      if(FAILED(hr)) return hr;
      IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
      return pSink->Indicate(1,&_pEvtInstance);
    }
  };

  class CInstanceProviderHelper : public CProviderHelper {
  public:
    CInstanceProviderHelper (IWbemServices *pNamespace,IWbemContext *pCtx) : CProviderHelper (pNamespace,pCtx) { }
    virtual ~CInstanceProviderHelper() { }
    HRESULT WINAPI CheckInstancePath(IClassFactory *pParserFactory,const BSTR ObjectPath,const BSTR ClassName,ULONGLONG ullTest) {
      if(!pParserFactory) {
	ATLASSERT (0);
	return WBEM_E_INVALID_PARAMETER;
      }
      CComPtr<IWbemPath>pPath;
      HRESULT hr = pParserFactory->CreateInstance(NULL,IID_IWbemPath,(void **) &pPath);
      if(FAILED(hr)) return WBEM_E_INVALID_PARAMETER;
      hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,ObjectPath);
      if(FAILED(hr)) return hr;
      unsigned int nPathLen = SysStringLen(ObjectPath);
      if(nPathLen >= (unsigned __LONG32)(-1)) return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
      unsigned __LONG32 ulBufLen = (unsigned __LONG32)(nPathLen + 1);
      WCHAR *wClass = new WCHAR[ulBufLen];
      if(!wClass) return WBEM_E_OUT_OF_MEMORY;
      hr = pPath->GetClassName(&ulBufLen,wClass);
      if(FAILED(hr)) {
	delete[] wClass;
	return hr;
      }
      DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);
      if(CSTR_EQUAL!=CompareStringW(lcid,NORM_IGNORECASE,ClassName,-1,wClass,-1)) {
	delete[] wClass;
	return WBEM_E_NOT_FOUND;
      }
      delete[] wClass;
      __MINGW_EXTENSION unsigned __int64 ullPathInfo;
      hr = pPath->GetInfo((ULONG)0,&ullPathInfo);
      if(FAILED(hr)) return hr;
      if(!(ullPathInfo & ullTest)) return WBEM_E_INVALID_OBJECT_PATH;
      return WBEM_S_NO_ERROR;
    }
  };

  template <class T> class ATL_NO_VTABLE IWbemPullClassProviderImpl : public IWbemServices,public IWbemProviderInit {
  public:
    virtual HRESULT WINAPI OpenNamespace(const BSTR strNamespace,__LONG32 lFlags,IWbemContext *pCtx,IWbemServices **ppWorkingNamespace,IWbemCallResult **ppResult){return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI CancelAsyncCall(IWbemObjectSink *pSink){return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI QueryObjectSink(__LONG32 lFlags,IWbemObjectSink **ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI GetObject(const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject **ppObject,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI PutClass(IWbemClassObject *pObject,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI DeleteClass(const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI CreateClassEnum(const BSTR strSuperclass,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI PutInstance(IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI PutInstanceAsync(IWbemClassObject *pInst,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI DeleteInstance(const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemCallResult **ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI DeleteInstanceAsync(const BSTR strObjectPath,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI CreateInstanceEnum(const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI CreateInstanceEnumAsync(const BSTR strClass,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI ExecQuery(const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI ExecNotificationQuery(const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IEnumWbemClassObject **ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI ExecNotificationQueryAsync(const BSTR strQueryLanguage,const BSTR strQuery,__LONG32 lFlags,IWbemContext *pCtx,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI ExecMethod(const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemClassObject **ppOutParams,IWbemCallResult **ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    virtual HRESULT WINAPI ExecMethodAsync(const BSTR strObjectPath,const BSTR strMethodName,__LONG32 lFlags,IWbemContext *pCtx,IWbemClassObject *pInParams,IWbemObjectSink *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
  };

  class CImpersonateClientHelper {
  private:
    WINBOOL m_bImpersonate;
  public:
    CImpersonateClientHelper() { m_bImpersonate = FALSE; }
    ~CImpersonateClientHelper() {
      if(m_bImpersonate)
	CoRevertToSelf();
    }
    HRESULT ImpersonateClient() {
      HRESULT hr = S_OK;
      if(SUCCEEDED(hr = CoImpersonateClient())) m_bImpersonate = TRUE;
      return hr;
    }
    HRESULT GetCurrentImpersonationLevel (DWORD & a_Level) {
      DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
      HANDLE t_ThreadToken = NULL;
      HRESULT t_Result = S_OK;
      if(SUCCEEDED(t_Result = CoImpersonateClient())) {
	WINBOOL t_Status = OpenThreadToken (GetCurrentThread() ,TOKEN_QUERY,TRUE,&t_ThreadToken);
	if(t_Status) {
	  SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous;
	  DWORD t_Returned = 0;
	  t_Status = GetTokenInformation (t_ThreadToken ,TokenImpersonationLevel ,&t_Level ,sizeof(SECURITY_IMPERSONATION_LEVEL),&t_Returned);
	  CloseHandle (t_ThreadToken);
	  if(t_Status==FALSE) {
	    t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
	  } else {
	    switch(t_Level) {
	    case SecurityAnonymous:
	      {
		t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
	      }
	      break;
	    case SecurityIdentification:
	      {
		t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY;
	      }
	      break;
	    case SecurityImpersonation:
	      {
		t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	      }
	      break;
	    case SecurityDelegation:
	      {
		t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE;
	      }
	      break;
	    default:
	      {
		t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,E_UNEXPECTED);
	      }
	      break;
	    }
	  }
	} else {
	  t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
	}
	CoRevertToSelf();
      }
      a_Level = t_ImpersonationLevel;
      return t_Result;
    }
  };
}
#endif
                                                                                                          usr/share/mingw-w64/include/wmistr.h                                                                0100644 0000000 0000000 00000012674 12404413016 016045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WMISTR_
#define _WMISTR_

typedef struct _WNODE_HEADER {
  ULONG BufferSize;
  ULONG ProviderId;
  __C89_NAMELESS union {
    ULONG64 HistoricalContext;
    __C89_NAMELESS struct {
      ULONG Version;
      ULONG Linkage;
    };
  };
  __C89_NAMELESS union {
    ULONG CountLost;
    HANDLE KernelHandle;
    LARGE_INTEGER TimeStamp;
  };
  GUID Guid;
  ULONG ClientContext;
  ULONG Flags;
} WNODE_HEADER,*PWNODE_HEADER;

#define WNODE_FLAG_ALL_DATA 0x00000001
#define WNODE_FLAG_SINGLE_INSTANCE 0x00000002
#define WNODE_FLAG_SINGLE_ITEM 0x00000004
#define WNODE_FLAG_EVENT_ITEM 0x00000008
#define WNODE_FLAG_FIXED_INSTANCE_SIZE 0x00000010
#define WNODE_FLAG_TOO_SMALL 0x00000020
#define WNODE_FLAG_INSTANCES_SAME 0x00000040
#define WNODE_FLAG_STATIC_INSTANCE_NAMES 0x00000080
#define WNODE_FLAG_INTERNAL 0x00000100
#define WNODE_FLAG_USE_TIMESTAMP 0x00000200
#define WNODE_FLAG_PERSIST_EVENT 0x00000400
#define WNODE_FLAG_EVENT_REFERENCE 0x00002000
#define WNODE_FLAG_ANSI_INSTANCENAMES 0x00004000
#define WNODE_FLAG_METHOD_ITEM 0x00008000
#define WNODE_FLAG_PDO_INSTANCE_NAMES 0x00010000
#define WNODE_FLAG_TRACED_GUID 0x00020000
#define WNODE_FLAG_LOG_WNODE 0x00040000
#define WNODE_FLAG_USE_GUID_PTR 0x00080000
#define WNODE_FLAG_USE_MOF_PTR 0x00100000
#define WNODE_FLAG_NO_HEADER 0x00200000
#define WNODE_FLAG_SEVERITY_MASK 0xff000000

typedef struct {
  ULONG OffsetInstanceData;
  ULONG LengthInstanceData;
} OFFSETINSTANCEDATAANDLENGTH,*POFFSETINSTANCEDATAANDLENGTH;

typedef struct tagWNODE_ALL_DATA {
  struct _WNODE_HEADER WnodeHeader;
  ULONG DataBlockOffset;
  ULONG InstanceCount;
  ULONG OffsetInstanceNameOffsets;
  __C89_NAMELESS union {
    ULONG FixedInstanceSize;
    OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[1];
  };
} WNODE_ALL_DATA,*PWNODE_ALL_DATA;

typedef struct tagWNODE_SINGLE_INSTANCE {
  struct _WNODE_HEADER WnodeHeader;
  ULONG OffsetInstanceName;
  ULONG InstanceIndex;
  ULONG DataBlockOffset;
  ULONG SizeDataBlock;
  UCHAR VariableData[];
} WNODE_SINGLE_INSTANCE,*PWNODE_SINGLE_INSTANCE;

typedef struct tagWNODE_SINGLE_ITEM {
  struct _WNODE_HEADER WnodeHeader;
  ULONG OffsetInstanceName;
  ULONG InstanceIndex;
  ULONG ItemId;
  ULONG DataBlockOffset;
  ULONG SizeDataItem;
  UCHAR VariableData[];
} WNODE_SINGLE_ITEM,*PWNODE_SINGLE_ITEM;

typedef struct tagWNODE_METHOD_ITEM {
  struct _WNODE_HEADER WnodeHeader;
  ULONG OffsetInstanceName;
  ULONG InstanceIndex;
  ULONG MethodId;
  ULONG DataBlockOffset;
  ULONG SizeDataBlock;
  UCHAR VariableData[];
} WNODE_METHOD_ITEM,*PWNODE_METHOD_ITEM;

typedef struct tagWNODE_EVENT_ITEM {
  struct _WNODE_HEADER WnodeHeader;
} WNODE_EVENT_ITEM,*PWNODE_EVENT_ITEM;

typedef struct tagWNODE_EVENT_REFERENCE {
  struct _WNODE_HEADER WnodeHeader;
  GUID TargetGuid;
  ULONG TargetDataBlockSize;
  __C89_NAMELESS union {
    ULONG TargetInstanceIndex;
    WCHAR TargetInstanceName[1];
  };
} WNODE_EVENT_REFERENCE,*PWNODE_EVENT_REFERENCE;

typedef struct tagWNODE_TOO_SMALL {
  struct _WNODE_HEADER WnodeHeader;
  ULONG SizeNeeded;
} WNODE_TOO_SMALL,*PWNODE_TOO_SMALL;

typedef struct {
  GUID Guid;
  ULONG Flags;
  ULONG InstanceCount;
  __C89_NAMELESS union {
    ULONG InstanceNameList;
    ULONG BaseNameOffset;
    ULONG_PTR Pdo;
    ULONG_PTR InstanceInfo;
  };
} WMIREGGUIDW,*PWMIREGGUIDW;

typedef WMIREGGUIDW WMIREGGUID;
typedef PWMIREGGUIDW PWMIREGGUID;

#define WMIREG_FLAG_EXPENSIVE 0x00000001
#define WMIREG_FLAG_INSTANCE_LIST 0x00000004
#define WMIREG_FLAG_INSTANCE_BASENAME 0x00000008
#define WMIREG_FLAG_INSTANCE_PDO 0x00000020
#define WMIREG_FLAG_REMOVE_GUID 0x00010000
#define WMIREG_FLAG_RESERVED1 0x00020000
#define WMIREG_FLAG_RESERVED2 0x00040000
#define WMIREG_FLAG_TRACED_GUID 0x00080000
#define WMIREG_FLAG_TRACE_CONTROL_GUID 0x00001000
#define WMIREG_FLAG_EVENT_ONLY_GUID 0x00000040

typedef struct {
  ULONG BufferSize;
  ULONG NextWmiRegInfo;
  ULONG RegistryPath;
  ULONG MofResourceName;
  ULONG GuidCount;
  WMIREGGUIDW WmiRegGuid[];
} WMIREGINFOW,*PWMIREGINFOW;

typedef WMIREGINFOW WMIREGINFO;
typedef PWMIREGINFOW PWMIREGINFO;

typedef enum {
  WMI_GET_ALL_DATA = 0,WMI_GET_SINGLE_INSTANCE = 1,WMI_SET_SINGLE_INSTANCE = 2,WMI_SET_SINGLE_ITEM = 3,WMI_ENABLE_EVENTS = 4,WMI_DISABLE_EVENTS = 5,
  WMI_ENABLE_COLLECTION = 6,WMI_DISABLE_COLLECTION = 7,WMI_REGINFO = 8,WMI_EXECUTE_METHOD = 9
} WMIDPREQUESTCODE;

#if defined(_WINNT_) || defined(WINNT)

#define WMI_GUIDTYPE_TRACECONTROL 0
#define WMI_GUIDTYPE_TRACE 1
#define WMI_GUIDTYPE_DATA 2
#define WMI_GUIDTYPE_EVENT 3

#define WMIGUID_QUERY 0x0001
#define WMIGUID_SET 0x0002
#define WMIGUID_NOTIFICATION 0x0004
#define WMIGUID_READ_DESCRIPTION 0x0008
#define WMIGUID_EXECUTE 0x0010
#define TRACELOG_CREATE_REALTIME 0x0020
#define TRACELOG_CREATE_ONDISK 0x0040
#define TRACELOG_GUID_ENABLE 0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC 0x0200
#define TRACELOG_ACCESS_REALTIME 0x0400
#define TRACELOG_REGISTER_GUIDS 0x0800

#define WMIGUID_ALL_ACCESS (STANDARD_RIGHTS_READ | SYNCHRONIZE | WMIGUID_QUERY | WMIGUID_SET | WMIGUID_NOTIFICATION | WMIGUID_READ_DESCRIPTION | WMIGUID_EXECUTE | TRACELOG_CREATE_REALTIME | TRACELOG_CREATE_ONDISK | TRACELOG_GUID_ENABLE | TRACELOG_ACCESS_KERNEL_LOGGER | TRACELOG_CREATE_INPROC | TRACELOG_ACCESS_REALTIME | TRACELOG_REGISTER_GUIDS)

#define WMI_GLOBAL_LOGGER_ID 0x0001
#endif
#endif
                                                                    usr/share/mingw-w64/include/wmiutils.h                                                              0100644 0000000 0000000 00000105520 12404413016 016366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error This stub requires an updated version of <rpcndr.h>
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif

#ifndef __wmiutils_h__
#define __wmiutils_h__

#ifndef __IWbemPathKeyList_FWD_DEFINED__
#define __IWbemPathKeyList_FWD_DEFINED__
typedef struct IWbemPathKeyList IWbemPathKeyList;
#endif

#ifndef __IWbemPath_FWD_DEFINED__
#define __IWbemPath_FWD_DEFINED__
typedef struct IWbemPath IWbemPath;
#endif

#ifndef __WbemDefPath_FWD_DEFINED__
#define __WbemDefPath_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemDefPath WbemDefPath;
#else
typedef struct WbemDefPath WbemDefPath;
#endif
#endif

#ifndef __IWbemQuery_FWD_DEFINED__
#define __IWbemQuery_FWD_DEFINED__
typedef struct IWbemQuery IWbemQuery;
#endif

#ifndef __WbemQuery_FWD_DEFINED__
#define __WbemQuery_FWD_DEFINED__
#ifdef __cplusplus
typedef class WbemQuery WbemQuery;
#else
typedef struct WbemQuery WbemQuery;
#endif
#endif

#ifndef __IWbemQuery_FWD_DEFINED__
#define __IWbemQuery_FWD_DEFINED__
typedef struct IWbemQuery IWbemQuery;
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __MIDL_user_allocate_free_DEFINED__
#define __MIDL_user_allocate_free_DEFINED__
  void *__RPC_API MIDL_user_allocate(size_t);
  void __RPC_API MIDL_user_free(void *);
#endif

  extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0000_v0_0_c_ifspec;
  extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0000_v0_0_s_ifspec;

#ifndef __WbemUtilities_v1_LIBRARY_DEFINED__
#define __WbemUtilities_v1_LIBRARY_DEFINED__

  typedef enum tag_WBEM_PATH_STATUS_FLAG {
    WBEMPATH_INFO_ANON_LOCAL_MACHINE = 0x1,WBEMPATH_INFO_HAS_MACHINE_NAME = 0x2,WBEMPATH_INFO_IS_CLASS_REF = 0x4,WBEMPATH_INFO_IS_INST_REF = 0x8,
    WBEMPATH_INFO_HAS_SUBSCOPES = 0x10,WBEMPATH_INFO_IS_COMPOUND = 0x20,WBEMPATH_INFO_HAS_V2_REF_PATHS = 0x40,WBEMPATH_INFO_HAS_IMPLIED_KEY = 0x80,
    WBEMPATH_INFO_CONTAINS_SINGLETON = 0x100,WBEMPATH_INFO_V1_COMPLIANT = 0x200,WBEMPATH_INFO_V2_COMPLIANT = 0x400,WBEMPATH_INFO_CIM_COMPLIANT = 0x800,
    WBEMPATH_INFO_IS_SINGLETON = 0x1000,WBEMPATH_INFO_IS_PARENT = 0x2000,WBEMPATH_INFO_SERVER_NAMESPACE_ONLY = 0x4000,WBEMPATH_INFO_NATIVE_PATH = 0x8000,
    WBEMPATH_INFO_WMI_PATH = 0x10000,WBEMPATH_INFO_PATH_HAD_SERVER = 0x20000
  } tag_WBEM_PATH_STATUS_FLAG;

  typedef enum tag_WBEM_PATH_CREATE_FLAG {
    WBEMPATH_CREATE_ACCEPT_RELATIVE = 0x1,WBEMPATH_CREATE_ACCEPT_ABSOLUTE = 0x2,WBEMPATH_CREATE_ACCEPT_ALL = 0x4,WBEMPATH_TREAT_SINGLE_IDENT_AS_NS = 0x8
  } tag_WBEM_PATH_CREATE_FLAG;

  typedef enum tag_WBEM_GET_TEXT_FLAGS {
    WBEMPATH_COMPRESSED = 0x1,WBEMPATH_GET_RELATIVE_ONLY = 0x2,WBEMPATH_GET_SERVER_TOO = 0x4,WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY = 0x8,
    WBEMPATH_GET_NAMESPACE_ONLY = 0x10,WBEMPATH_GET_ORIGINAL = 0x20
  } tag_WBEM_GET_TEXT_FLAGS;

  typedef enum tag_WBEM_GET_KEY_FLAGS {
    WBEMPATH_TEXT = 0x1,WBEMPATH_QUOTEDTEXT = 0x2
  } tag_WBEM_GET_KEY_FLAGS;

  EXTERN_C const IID LIBID_WbemUtilities_v1;
#ifndef __IWbemPathKeyList_INTERFACE_DEFINED__
#define __IWbemPathKeyList_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemPathKeyList;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemPathKeyList : public IUnknown {
  public:
    virtual HRESULT WINAPI GetCount(ULONG *puKeyCount) = 0;
    virtual HRESULT WINAPI SetKey(LPCWSTR wszName,ULONG uFlags,ULONG uCimType,LPVOID pKeyVal) = 0;
    virtual HRESULT WINAPI SetKey2(LPCWSTR wszName,ULONG uFlags,ULONG uCimType,VARIANT *pKeyVal) = 0;
    virtual HRESULT WINAPI GetKey(ULONG uKeyIx,ULONG uFlags,ULONG *puNameBufSize,LPWSTR pszKeyName,ULONG *puKeyValBufSize,LPVOID pKeyVal,ULONG *puApparentCimType) = 0;
    virtual HRESULT WINAPI GetKey2(ULONG uKeyIx,ULONG uFlags,ULONG *puNameBufSize,LPWSTR pszKeyName,VARIANT *pKeyValue,ULONG *puApparentCimType) = 0;
    virtual HRESULT WINAPI RemoveKey(LPCWSTR wszName,ULONG uFlags) = 0;
    virtual HRESULT WINAPI RemoveAllKeys(ULONG uFlags) = 0;
    virtual HRESULT WINAPI MakeSingleton(boolean bSet) = 0;
    virtual HRESULT WINAPI GetInfo(ULONG uRequestedInfo,ULONGLONG *puResponse) = 0;
    virtual HRESULT WINAPI GetText(__LONG32 lFlags,ULONG *puBuffLength,LPWSTR pszText) = 0;
  };
#else
  typedef struct IWbemPathKeyListVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemPathKeyList *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemPathKeyList *This);
      ULONG (WINAPI *Release)(IWbemPathKeyList *This);
      HRESULT (WINAPI *GetCount)(IWbemPathKeyList *This,ULONG *puKeyCount);
      HRESULT (WINAPI *SetKey)(IWbemPathKeyList *This,LPCWSTR wszName,ULONG uFlags,ULONG uCimType,LPVOID pKeyVal);
      HRESULT (WINAPI *SetKey2)(IWbemPathKeyList *This,LPCWSTR wszName,ULONG uFlags,ULONG uCimType,VARIANT *pKeyVal);
      HRESULT (WINAPI *GetKey)(IWbemPathKeyList *This,ULONG uKeyIx,ULONG uFlags,ULONG *puNameBufSize,LPWSTR pszKeyName,ULONG *puKeyValBufSize,LPVOID pKeyVal,ULONG *puApparentCimType);
      HRESULT (WINAPI *GetKey2)(IWbemPathKeyList *This,ULONG uKeyIx,ULONG uFlags,ULONG *puNameBufSize,LPWSTR pszKeyName,VARIANT *pKeyValue,ULONG *puApparentCimType);
      HRESULT (WINAPI *RemoveKey)(IWbemPathKeyList *This,LPCWSTR wszName,ULONG uFlags);
      HRESULT (WINAPI *RemoveAllKeys)(IWbemPathKeyList *This,ULONG uFlags);
      HRESULT (WINAPI *MakeSingleton)(IWbemPathKeyList *This,boolean bSet);
      HRESULT (WINAPI *GetInfo)(IWbemPathKeyList *This,ULONG uRequestedInfo,ULONGLONG *puResponse);
      HRESULT (WINAPI *GetText)(IWbemPathKeyList *This,__LONG32 lFlags,ULONG *puBuffLength,LPWSTR pszText);
    END_INTERFACE
  } IWbemPathKeyListVtbl;
  struct IWbemPathKeyList {
    CONST_VTBL struct IWbemPathKeyListVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemPathKeyList_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemPathKeyList_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemPathKeyList_Release(This) (This)->lpVtbl->Release(This)
#define IWbemPathKeyList_GetCount(This,puKeyCount) (This)->lpVtbl->GetCount(This,puKeyCount)
#define IWbemPathKeyList_SetKey(This,wszName,uFlags,uCimType,pKeyVal) (This)->lpVtbl->SetKey(This,wszName,uFlags,uCimType,pKeyVal)
#define IWbemPathKeyList_SetKey2(This,wszName,uFlags,uCimType,pKeyVal) (This)->lpVtbl->SetKey2(This,wszName,uFlags,uCimType,pKeyVal)
#define IWbemPathKeyList_GetKey(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,puKeyValBufSize,pKeyVal,puApparentCimType) (This)->lpVtbl->GetKey(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,puKeyValBufSize,pKeyVal,puApparentCimType)
#define IWbemPathKeyList_GetKey2(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,pKeyValue,puApparentCimType) (This)->lpVtbl->GetKey2(This,uKeyIx,uFlags,puNameBufSize,pszKeyName,pKeyValue,puApparentCimType)
#define IWbemPathKeyList_RemoveKey(This,wszName,uFlags) (This)->lpVtbl->RemoveKey(This,wszName,uFlags)
#define IWbemPathKeyList_RemoveAllKeys(This,uFlags) (This)->lpVtbl->RemoveAllKeys(This,uFlags)
#define IWbemPathKeyList_MakeSingleton(This,bSet) (This)->lpVtbl->MakeSingleton(This,bSet)
#define IWbemPathKeyList_GetInfo(This,uRequestedInfo,puResponse) (This)->lpVtbl->GetInfo(This,uRequestedInfo,puResponse)
#define IWbemPathKeyList_GetText(This,lFlags,puBuffLength,pszText) (This)->lpVtbl->GetText(This,lFlags,puBuffLength,pszText)
#endif
#endif
  HRESULT WINAPI IWbemPathKeyList_GetCount_Proxy(IWbemPathKeyList *This,ULONG *puKeyCount);
  void __RPC_STUB IWbemPathKeyList_GetCount_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_SetKey_Proxy(IWbemPathKeyList *This,LPCWSTR wszName,ULONG uFlags,ULONG uCimType,LPVOID pKeyVal);
  void __RPC_STUB IWbemPathKeyList_SetKey_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_SetKey2_Proxy(IWbemPathKeyList *This,LPCWSTR wszName,ULONG uFlags,ULONG uCimType,VARIANT *pKeyVal);
  void __RPC_STUB IWbemPathKeyList_SetKey2_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_GetKey_Proxy(IWbemPathKeyList *This,ULONG uKeyIx,ULONG uFlags,ULONG *puNameBufSize,LPWSTR pszKeyName,ULONG *puKeyValBufSize,LPVOID pKeyVal,ULONG *puApparentCimType);
  void __RPC_STUB IWbemPathKeyList_GetKey_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_GetKey2_Proxy(IWbemPathKeyList *This,ULONG uKeyIx,ULONG uFlags,ULONG *puNameBufSize,LPWSTR pszKeyName,VARIANT *pKeyValue,ULONG *puApparentCimType);
  void __RPC_STUB IWbemPathKeyList_GetKey2_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_RemoveKey_Proxy(IWbemPathKeyList *This,LPCWSTR wszName,ULONG uFlags);
  void __RPC_STUB IWbemPathKeyList_RemoveKey_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_RemoveAllKeys_Proxy(IWbemPathKeyList *This,ULONG uFlags);
  void __RPC_STUB IWbemPathKeyList_RemoveAllKeys_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_MakeSingleton_Proxy(IWbemPathKeyList *This,boolean bSet);
  void __RPC_STUB IWbemPathKeyList_MakeSingleton_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_GetInfo_Proxy(IWbemPathKeyList *This,ULONG uRequestedInfo,ULONGLONG *puResponse);
  void __RPC_STUB IWbemPathKeyList_GetInfo_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPathKeyList_GetText_Proxy(IWbemPathKeyList *This,__LONG32 lFlags,ULONG *puBuffLength,LPWSTR pszText);
  void __RPC_STUB IWbemPathKeyList_GetText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IWbemPath_INTERFACE_DEFINED__
#define __IWbemPath_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemPath;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemPath : public IUnknown {
  public:
    virtual HRESULT WINAPI SetText(ULONG uMode,LPCWSTR pszPath) = 0;
    virtual HRESULT WINAPI GetText(__LONG32 lFlags,ULONG *puBuffLength,LPWSTR pszText) = 0;
    virtual HRESULT WINAPI GetInfo(ULONG uRequestedInfo,ULONGLONG *puResponse) = 0;
    virtual HRESULT WINAPI SetServer(LPCWSTR Name) = 0;
    virtual HRESULT WINAPI GetServer(ULONG *puNameBufLength,LPWSTR pName) = 0;
    virtual HRESULT WINAPI GetNamespaceCount(ULONG *puCount) = 0;
    virtual HRESULT WINAPI SetNamespaceAt(ULONG uIndex,LPCWSTR pszName) = 0;
    virtual HRESULT WINAPI GetNamespaceAt(ULONG uIndex,ULONG *puNameBufLength,LPWSTR pName) = 0;
    virtual HRESULT WINAPI RemoveNamespaceAt(ULONG uIndex) = 0;
    virtual HRESULT WINAPI RemoveAllNamespaces(void) = 0;
    virtual HRESULT WINAPI GetScopeCount(ULONG *puCount) = 0;
    virtual HRESULT WINAPI SetScope(ULONG uIndex,LPWSTR pszClass) = 0;
    virtual HRESULT WINAPI SetScopeFromText(ULONG uIndex,LPWSTR pszText) = 0;
    virtual HRESULT WINAPI GetScope(ULONG uIndex,ULONG *puClassNameBufSize,LPWSTR pszClass,IWbemPathKeyList **pKeyList) = 0;
    virtual HRESULT WINAPI GetScopeAsText(ULONG uIndex,ULONG *puTextBufSize,LPWSTR pszText) = 0;
    virtual HRESULT WINAPI RemoveScope(ULONG uIndex) = 0;
    virtual HRESULT WINAPI RemoveAllScopes(void) = 0;
    virtual HRESULT WINAPI SetClassName(LPCWSTR Name) = 0;
    virtual HRESULT WINAPI GetClassName(ULONG *puBuffLength,LPWSTR pszName) = 0;
    virtual HRESULT WINAPI GetKeyList(IWbemPathKeyList **pOut) = 0;
    virtual HRESULT WINAPI CreateClassPart(__LONG32 lFlags,LPCWSTR Name) = 0;
    virtual HRESULT WINAPI DeleteClassPart(__LONG32 lFlags) = 0;
    virtual WINBOOL WINAPI IsRelative(LPWSTR wszMachine,LPWSTR wszNamespace) = 0;
    virtual WINBOOL WINAPI IsRelativeOrChild(LPWSTR wszMachine,LPWSTR wszNamespace,__LONG32 lFlags) = 0;
    virtual WINBOOL WINAPI IsLocal(LPCWSTR wszMachine) = 0;
    virtual WINBOOL WINAPI IsSameClassName(LPCWSTR wszClass) = 0;
  };
#else
  typedef struct IWbemPathVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemPath *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemPath *This);
      ULONG (WINAPI *Release)(IWbemPath *This);
      HRESULT (WINAPI *SetText)(IWbemPath *This,ULONG uMode,LPCWSTR pszPath);
      HRESULT (WINAPI *GetText)(IWbemPath *This,__LONG32 lFlags,ULONG *puBuffLength,LPWSTR pszText);
      HRESULT (WINAPI *GetInfo)(IWbemPath *This,ULONG uRequestedInfo,ULONGLONG *puResponse);
      HRESULT (WINAPI *SetServer)(IWbemPath *This,LPCWSTR Name);
      HRESULT (WINAPI *GetServer)(IWbemPath *This,ULONG *puNameBufLength,LPWSTR pName);
      HRESULT (WINAPI *GetNamespaceCount)(IWbemPath *This,ULONG *puCount);
      HRESULT (WINAPI *SetNamespaceAt)(IWbemPath *This,ULONG uIndex,LPCWSTR pszName);
      HRESULT (WINAPI *GetNamespaceAt)(IWbemPath *This,ULONG uIndex,ULONG *puNameBufLength,LPWSTR pName);
      HRESULT (WINAPI *RemoveNamespaceAt)(IWbemPath *This,ULONG uIndex);
      HRESULT (WINAPI *RemoveAllNamespaces)(IWbemPath *This);
      HRESULT (WINAPI *GetScopeCount)(IWbemPath *This,ULONG *puCount);
      HRESULT (WINAPI *SetScope)(IWbemPath *This,ULONG uIndex,LPWSTR pszClass);
      HRESULT (WINAPI *SetScopeFromText)(IWbemPath *This,ULONG uIndex,LPWSTR pszText);
      HRESULT (WINAPI *GetScope)(IWbemPath *This,ULONG uIndex,ULONG *puClassNameBufSize,LPWSTR pszClass,IWbemPathKeyList **pKeyList);
      HRESULT (WINAPI *GetScopeAsText)(IWbemPath *This,ULONG uIndex,ULONG *puTextBufSize,LPWSTR pszText);
      HRESULT (WINAPI *RemoveScope)(IWbemPath *This,ULONG uIndex);
      HRESULT (WINAPI *RemoveAllScopes)(IWbemPath *This);
      HRESULT (WINAPI *SetClassName)(IWbemPath *This,LPCWSTR Name);
      HRESULT (WINAPI *GetClassName)(IWbemPath *This,ULONG *puBuffLength,LPWSTR pszName);
      HRESULT (WINAPI *GetKeyList)(IWbemPath *This,IWbemPathKeyList **pOut);
      HRESULT (WINAPI *CreateClassPart)(IWbemPath *This,__LONG32 lFlags,LPCWSTR Name);
      HRESULT (WINAPI *DeleteClassPart)(IWbemPath *This,__LONG32 lFlags);
      WINBOOL (WINAPI *IsRelative)(IWbemPath *This,LPWSTR wszMachine,LPWSTR wszNamespace);
      WINBOOL (WINAPI *IsRelativeOrChild)(IWbemPath *This,LPWSTR wszMachine,LPWSTR wszNamespace,__LONG32 lFlags);
      WINBOOL (WINAPI *IsLocal)(IWbemPath *This,LPCWSTR wszMachine);
      WINBOOL (WINAPI *IsSameClassName)(IWbemPath *This,LPCWSTR wszClass);
    END_INTERFACE
  } IWbemPathVtbl;
  struct IWbemPath {
    CONST_VTBL struct IWbemPathVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemPath_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemPath_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemPath_Release(This) (This)->lpVtbl->Release(This)
#define IWbemPath_SetText(This,uMode,pszPath) (This)->lpVtbl->SetText(This,uMode,pszPath)
#define IWbemPath_GetText(This,lFlags,puBuffLength,pszText) (This)->lpVtbl->GetText(This,lFlags,puBuffLength,pszText)
#define IWbemPath_GetInfo(This,uRequestedInfo,puResponse) (This)->lpVtbl->GetInfo(This,uRequestedInfo,puResponse)
#define IWbemPath_SetServer(This,Name) (This)->lpVtbl->SetServer(This,Name)
#define IWbemPath_GetServer(This,puNameBufLength,pName) (This)->lpVtbl->GetServer(This,puNameBufLength,pName)
#define IWbemPath_GetNamespaceCount(This,puCount) (This)->lpVtbl->GetNamespaceCount(This,puCount)
#define IWbemPath_SetNamespaceAt(This,uIndex,pszName) (This)->lpVtbl->SetNamespaceAt(This,uIndex,pszName)
#define IWbemPath_GetNamespaceAt(This,uIndex,puNameBufLength,pName) (This)->lpVtbl->GetNamespaceAt(This,uIndex,puNameBufLength,pName)
#define IWbemPath_RemoveNamespaceAt(This,uIndex) (This)->lpVtbl->RemoveNamespaceAt(This,uIndex)
#define IWbemPath_RemoveAllNamespaces(This) (This)->lpVtbl->RemoveAllNamespaces(This)
#define IWbemPath_GetScopeCount(This,puCount) (This)->lpVtbl->GetScopeCount(This,puCount)
#define IWbemPath_SetScope(This,uIndex,pszClass) (This)->lpVtbl->SetScope(This,uIndex,pszClass)
#define IWbemPath_SetScopeFromText(This,uIndex,pszText) (This)->lpVtbl->SetScopeFromText(This,uIndex,pszText)
#define IWbemPath_GetScope(This,uIndex,puClassNameBufSize,pszClass,pKeyList) (This)->lpVtbl->GetScope(This,uIndex,puClassNameBufSize,pszClass,pKeyList)
#define IWbemPath_GetScopeAsText(This,uIndex,puTextBufSize,pszText) (This)->lpVtbl->GetScopeAsText(This,uIndex,puTextBufSize,pszText)
#define IWbemPath_RemoveScope(This,uIndex) (This)->lpVtbl->RemoveScope(This,uIndex)
#define IWbemPath_RemoveAllScopes(This) (This)->lpVtbl->RemoveAllScopes(This)
#define IWbemPath_SetClassName(This,Name) (This)->lpVtbl->SetClassName(This,Name)
#define IWbemPath_GetClassName(This,puBuffLength,pszName) (This)->lpVtbl->GetClassName(This,puBuffLength,pszName)
#define IWbemPath_GetKeyList(This,pOut) (This)->lpVtbl->GetKeyList(This,pOut)
#define IWbemPath_CreateClassPart(This,lFlags,Name) (This)->lpVtbl->CreateClassPart(This,lFlags,Name)
#define IWbemPath_DeleteClassPart(This,lFlags) (This)->lpVtbl->DeleteClassPart(This,lFlags)
#define IWbemPath_IsRelative(This,wszMachine,wszNamespace) (This)->lpVtbl->IsRelative(This,wszMachine,wszNamespace)
#define IWbemPath_IsRelativeOrChild(This,wszMachine,wszNamespace,lFlags) (This)->lpVtbl->IsRelativeOrChild(This,wszMachine,wszNamespace,lFlags)
#define IWbemPath_IsLocal(This,wszMachine) (This)->lpVtbl->IsLocal(This,wszMachine)
#define IWbemPath_IsSameClassName(This,wszClass) (This)->lpVtbl->IsSameClassName(This,wszClass)
#endif
#endif
  HRESULT WINAPI IWbemPath_SetText_Proxy(IWbemPath *This,ULONG uMode,LPCWSTR pszPath);
  void __RPC_STUB IWbemPath_SetText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetText_Proxy(IWbemPath *This,__LONG32 lFlags,ULONG *puBuffLength,LPWSTR pszText);
  void __RPC_STUB IWbemPath_GetText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetInfo_Proxy(IWbemPath *This,ULONG uRequestedInfo,ULONGLONG *puResponse);
  void __RPC_STUB IWbemPath_GetInfo_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_SetServer_Proxy(IWbemPath *This,LPCWSTR Name);
  void __RPC_STUB IWbemPath_SetServer_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetServer_Proxy(IWbemPath *This,ULONG *puNameBufLength,LPWSTR pName);
  void __RPC_STUB IWbemPath_GetServer_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetNamespaceCount_Proxy(IWbemPath *This,ULONG *puCount);
  void __RPC_STUB IWbemPath_GetNamespaceCount_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_SetNamespaceAt_Proxy(IWbemPath *This,ULONG uIndex,LPCWSTR pszName);
  void __RPC_STUB IWbemPath_SetNamespaceAt_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetNamespaceAt_Proxy(IWbemPath *This,ULONG uIndex,ULONG *puNameBufLength,LPWSTR pName);
  void __RPC_STUB IWbemPath_GetNamespaceAt_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_RemoveNamespaceAt_Proxy(IWbemPath *This,ULONG uIndex);
  void __RPC_STUB IWbemPath_RemoveNamespaceAt_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_RemoveAllNamespaces_Proxy(IWbemPath *This);
  void __RPC_STUB IWbemPath_RemoveAllNamespaces_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetScopeCount_Proxy(IWbemPath *This,ULONG *puCount);
  void __RPC_STUB IWbemPath_GetScopeCount_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_SetScope_Proxy(IWbemPath *This,ULONG uIndex,LPWSTR pszClass);
  void __RPC_STUB IWbemPath_SetScope_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_SetScopeFromText_Proxy(IWbemPath *This,ULONG uIndex,LPWSTR pszText);
  void __RPC_STUB IWbemPath_SetScopeFromText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetScope_Proxy(IWbemPath *This,ULONG uIndex,ULONG *puClassNameBufSize,LPWSTR pszClass,IWbemPathKeyList **pKeyList);
  void __RPC_STUB IWbemPath_GetScope_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetScopeAsText_Proxy(IWbemPath *This,ULONG uIndex,ULONG *puTextBufSize,LPWSTR pszText);
  void __RPC_STUB IWbemPath_GetScopeAsText_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_RemoveScope_Proxy(IWbemPath *This,ULONG uIndex);
  void __RPC_STUB IWbemPath_RemoveScope_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_RemoveAllScopes_Proxy(IWbemPath *This);
  void __RPC_STUB IWbemPath_RemoveAllScopes_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_SetClassName_Proxy(IWbemPath *This,LPCWSTR Name);
  void __RPC_STUB IWbemPath_SetClassName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetClassName_Proxy(IWbemPath *This,ULONG *puBuffLength,LPWSTR pszName);
  void __RPC_STUB IWbemPath_GetClassName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_GetKeyList_Proxy(IWbemPath *This,IWbemPathKeyList **pOut);
  void __RPC_STUB IWbemPath_GetKeyList_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_CreateClassPart_Proxy(IWbemPath *This,__LONG32 lFlags,LPCWSTR Name);
  void __RPC_STUB IWbemPath_CreateClassPart_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemPath_DeleteClassPart_Proxy(IWbemPath *This,__LONG32 lFlags);
  void __RPC_STUB IWbemPath_DeleteClassPart_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  WINBOOL WINAPI IWbemPath_IsRelative_Proxy(IWbemPath *This,LPWSTR wszMachine,LPWSTR wszNamespace);
  void __RPC_STUB IWbemPath_IsRelative_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  WINBOOL WINAPI IWbemPath_IsRelativeOrChild_Proxy(IWbemPath *This,LPWSTR wszMachine,LPWSTR wszNamespace,__LONG32 lFlags);
  void __RPC_STUB IWbemPath_IsRelativeOrChild_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  WINBOOL WINAPI IWbemPath_IsLocal_Proxy(IWbemPath *This,LPCWSTR wszMachine);
  void __RPC_STUB IWbemPath_IsLocal_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  WINBOOL WINAPI IWbemPath_IsSameClassName_Proxy(IWbemPath *This,LPCWSTR wszClass);
  void __RPC_STUB IWbemPath_IsSameClassName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

  EXTERN_C const CLSID CLSID_WbemDefPath;
#ifdef __cplusplus
  class WbemDefPath;
#endif

#ifndef __IWbemQuery_INTERFACE_DEFINED__
#define __IWbemQuery_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWbemQuery;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWbemQuery : public IUnknown {
  public:
    virtual HRESULT WINAPI Empty(void) = 0;
    virtual HRESULT WINAPI SetLanguageFeatures(ULONG uFlags,ULONG uArraySize,ULONG *puFeatures) = 0;
    virtual HRESULT WINAPI TestLanguageFeatures(ULONG uFlags,ULONG *uArraySize,ULONG *puFeatures) = 0;
    virtual HRESULT WINAPI Parse(LPCWSTR pszLang,LPCWSTR pszQuery,ULONG uFlags) = 0;
    virtual HRESULT WINAPI GetAnalysis(ULONG uAnalysisType,ULONG uFlags,LPVOID *pAnalysis) = 0;
    virtual HRESULT WINAPI FreeMemory(LPVOID pMem) = 0;
    virtual HRESULT WINAPI GetQueryInfo(ULONG uAnalysisType,ULONG uInfoId,ULONG uBufSize,LPVOID pDestBuf) = 0;
  };
#else
  typedef struct IWbemQueryVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWbemQuery *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWbemQuery *This);
      ULONG (WINAPI *Release)(IWbemQuery *This);
      HRESULT (WINAPI *Empty)(IWbemQuery *This);
      HRESULT (WINAPI *SetLanguageFeatures)(IWbemQuery *This,ULONG uFlags,ULONG uArraySize,ULONG *puFeatures);
      HRESULT (WINAPI *TestLanguageFeatures)(IWbemQuery *This,ULONG uFlags,ULONG *uArraySize,ULONG *puFeatures);
      HRESULT (WINAPI *Parse)(IWbemQuery *This,LPCWSTR pszLang,LPCWSTR pszQuery,ULONG uFlags);
      HRESULT (WINAPI *GetAnalysis)(IWbemQuery *This,ULONG uAnalysisType,ULONG uFlags,LPVOID *pAnalysis);
      HRESULT (WINAPI *FreeMemory)(IWbemQuery *This,LPVOID pMem);
      HRESULT (WINAPI *GetQueryInfo)(IWbemQuery *This,ULONG uAnalysisType,ULONG uInfoId,ULONG uBufSize,LPVOID pDestBuf);
    END_INTERFACE
  } IWbemQueryVtbl;
  struct IWbemQuery {
    CONST_VTBL struct IWbemQueryVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWbemQuery_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWbemQuery_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWbemQuery_Release(This) (This)->lpVtbl->Release(This)
#define IWbemQuery_Empty(This) (This)->lpVtbl->Empty(This)
#define IWbemQuery_SetLanguageFeatures(This,uFlags,uArraySize,puFeatures) (This)->lpVtbl->SetLanguageFeatures(This,uFlags,uArraySize,puFeatures)
#define IWbemQuery_TestLanguageFeatures(This,uFlags,uArraySize,puFeatures) (This)->lpVtbl->TestLanguageFeatures(This,uFlags,uArraySize,puFeatures)
#define IWbemQuery_Parse(This,pszLang,pszQuery,uFlags) (This)->lpVtbl->Parse(This,pszLang,pszQuery,uFlags)
#define IWbemQuery_GetAnalysis(This,uAnalysisType,uFlags,pAnalysis) (This)->lpVtbl->GetAnalysis(This,uAnalysisType,uFlags,pAnalysis)
#define IWbemQuery_FreeMemory(This,pMem) (This)->lpVtbl->FreeMemory(This,pMem)
#define IWbemQuery_GetQueryInfo(This,uAnalysisType,uInfoId,uBufSize,pDestBuf) (This)->lpVtbl->GetQueryInfo(This,uAnalysisType,uInfoId,uBufSize,pDestBuf)
#endif
#endif
  HRESULT WINAPI IWbemQuery_Empty_Proxy(IWbemQuery *This);
  void __RPC_STUB IWbemQuery_Empty_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQuery_SetLanguageFeatures_Proxy(IWbemQuery *This,ULONG uFlags,ULONG uArraySize,ULONG *puFeatures);
  void __RPC_STUB IWbemQuery_SetLanguageFeatures_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQuery_TestLanguageFeatures_Proxy(IWbemQuery *This,ULONG uFlags,ULONG *uArraySize,ULONG *puFeatures);
  void __RPC_STUB IWbemQuery_TestLanguageFeatures_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQuery_Parse_Proxy(IWbemQuery *This,LPCWSTR pszLang,LPCWSTR pszQuery,ULONG uFlags);
  void __RPC_STUB IWbemQuery_Parse_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQuery_GetAnalysis_Proxy(IWbemQuery *This,ULONG uAnalysisType,ULONG uFlags,LPVOID *pAnalysis);
  void __RPC_STUB IWbemQuery_GetAnalysis_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQuery_FreeMemory_Proxy(IWbemQuery *This,LPVOID pMem);
  void __RPC_STUB IWbemQuery_FreeMemory_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWbemQuery_GetQueryInfo_Proxy(IWbemQuery *This,ULONG uAnalysisType,ULONG uInfoId,ULONG uBufSize,LPVOID pDestBuf);
  void __RPC_STUB IWbemQuery_GetQueryInfo_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

  EXTERN_C const CLSID CLSID_WbemQuery;
#ifdef __cplusplus
  class WbemQuery;
#endif
#endif

  typedef enum __MIDL___MIDL_itf_wmiutils_0116_0001 {
    WMIQ_ANALYSIS_RPN_SEQUENCE = 0x1,WMIQ_ANALYSIS_ASSOC_QUERY = 0x2,WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX = 0x3,WMIQ_ANALYSIS_QUERY_TEXT = 0x4,
    WMIQ_ANALYSIS_RESERVED = 0x8000000
  } WMIQ_ANALYSIS_TYPE;

  typedef enum __MIDL___MIDL_itf_wmiutils_0116_0002 {
    WMIQ_RPN_TOKEN_EXPRESSION = 1,WMIQ_RPN_TOKEN_AND = 2,WMIQ_RPN_TOKEN_OR = 3,WMIQ_RPN_TOKEN_NOT = 4,WMIQ_RPN_OP_UNDEFINED = 0,WMIQ_RPN_OP_EQ = 1,
    WMIQ_RPN_OP_NE = 2,WMIQ_RPN_OP_GE = 3,WMIQ_RPN_OP_LE = 4,WMIQ_RPN_OP_LT = 5,WMIQ_RPN_OP_GT = 6,WMIQ_RPN_OP_LIKE = 7,WMIQ_RPN_OP_ISA = 8,
    WMIQ_RPN_OP_ISNOTA = 9,WMIQ_RPN_OP_ISNULL = 10,WMIQ_RPN_OP_ISNOTNULL = 11,WMIQ_RPN_LEFT_PROPERTY_NAME = 0x1,WMIQ_RPN_RIGHT_PROPERTY_NAME = 0x2,
    WMIQ_RPN_CONST2 = 0x4,WMIQ_RPN_CONST = 0x8,WMIQ_RPN_RELOP = 0x10,WMIQ_RPN_LEFT_FUNCTION = 0x20,WMIQ_RPN_RIGHT_FUNCTION = 0x40,
    WMIQ_RPN_GET_TOKEN_TYPE = 1,WMIQ_RPN_GET_EXPR_SHAPE = 2,WMIQ_RPN_GET_LEFT_FUNCTION = 3,WMIQ_RPN_GET_RIGHT_FUNCTION = 4,WMIQ_RPN_GET_RELOP = 5,
    WMIQ_RPN_NEXT_TOKEN = 1,WMIQ_RPN_FROM_UNARY = 0x1,WMIQ_RPN_FROM_PATH = 0x2,WMIQ_RPN_FROM_CLASS_LIST = 0x4,WMIQ_RPN_FROM_MULTIPLE = 0x8
  } WMIQ_RPN_TOKEN_FLAGS;

  typedef enum __MIDL___MIDL_itf_wmiutils_0116_0003 {
    WMIQ_ASSOCQ_ASSOCIATORS = 0x1,WMIQ_ASSOCQ_REFERENCES = 0x2,WMIQ_ASSOCQ_RESULTCLASS = 0x4,WMIQ_ASSOCQ_ASSOCCLASS = 0x8,WMIQ_ASSOCQ_ROLE = 0x10,
    WMIQ_ASSOCQ_RESULTROLE = 0x20,WMIQ_ASSOCQ_REQUIREDQUALIFIER = 0x40,WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER = 0x80,WMIQ_ASSOCQ_CLASSDEFSONLY = 0x100,
    WMIQ_ASSOCQ_KEYSONLY = 0x200,WMIQ_ASSOCQ_SCHEMAONLY = 0x400,WMIQ_ASSOCQ_CLASSREFSONLY = 0x800
  } WMIQ_ASSOCQ_FLAGS;

  typedef struct tag_SWbemQueryQualifiedName {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uNameListSize;
    LPCWSTR *m_ppszNameList;
    WINBOOL m_bArraysUsed;
    WINBOOL *m_pbArrayElUsed;
    ULONG *m_puArrayIndex;
  } SWbemQueryQualifiedName;

  typedef union tag_SWbemRpnConst {
    LPCWSTR m_pszStrVal;
    WINBOOL m_bBoolVal;
    LONG m_lLongVal;
    ULONG m_uLongVal;
    double m_dblVal;
    __MINGW_EXTENSION __int64 m_lVal64;
    __MINGW_EXTENSION __int64 m_uVal64;
  } SWbemRpnConst;

  typedef struct tag_SWbemRpnQueryToken {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uSubexpressionShape;
    ULONG m_uOperator;
    SWbemQueryQualifiedName *m_pRightIdent;
    SWbemQueryQualifiedName *m_pLeftIdent;
    ULONG m_uConstApparentType;
    SWbemRpnConst m_Const;
    ULONG m_uConst2ApparentType;
    SWbemRpnConst m_Const2;
    LPCWSTR m_pszRightFunc;
    LPCWSTR m_pszLeftFunc;
  } SWbemRpnQueryToken;

  typedef struct tag_SWbemRpnTokenList {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    ULONG m_uNumTokens;
  } SWbemRpnTokenList;

  typedef enum tag_WMIQ_LANGUAGE_FEATURES {
    WMIQ_LF1_BASIC_SELECT = 1,WMIQ_LF2_CLASS_NAME_IN_QUERY = 2,WMIQ_LF3_STRING_CASE_FUNCTIONS = 3,WMIQ_LF4_PROP_TO_PROP_TESTS = 4,
    WMIQ_LF5_COUNT_STAR = 5,WMIQ_LF6_ORDER_BY = 6,WMIQ_LF7_DISTINCT = 7,WMIQ_LF8_ISA = 8,WMIQ_LF9_THIS = 9,WMIQ_LF10_COMPEX_SUBEXPRESSIONS = 10,
    WMIQ_LF11_ALIASING = 11,WMIQ_LF12_GROUP_BY_HAVING = 12,WMIQ_LF13_WMI_WITHIN = 13,WMIQ_LF14_SQL_WRITE_OPERATIONS = 14,WMIQ_LF15_GO = 15,
    WMIQ_LF16_SINGLE_LEVEL_TRANSACTIONS = 16,WMIQ_LF17_QUALIFIED_NAMES = 17,WMIQ_LF18_ASSOCIATONS = 18,WMIQ_LF19_SYSTEM_PROPERTIES = 19,
    WMIQ_LF20_EXTENDED_SYSTEM_PROPERTIES = 20,WMIQ_LF21_SQL89_JOINS = 21,WMIQ_LF22_SQL92_JOINS = 22,WMIQ_LF23_SUBSELECTS = 23,
    WMIQ_LF24_UMI_EXTENSIONS = 24,WMIQ_LF25_DATEPART = 25,WMIQ_LF26_LIKE = 26,WMIQ_LF27_CIM_TEMPORAL_CONSTRUCTS = 27,
    WMIQ_LF28_STANDARD_AGGREGATES = 28,WMIQ_LF29_MULTI_LEVEL_ORDER_BY = 29,WMIQ_LF30_WMI_PRAGMAS = 30,WMIQ_LF31_QUALIFIER_TESTS = 31,
    WMIQ_LF32_SP_EXECUTE = 32,WMIQ_LF33_ARRAY_ACCESS = 33,WMIQ_LF34_UNION = 34,WMIQ_LF35_COMPLEX_SELECT_TARGET = 35,WMIQ_LF36_REFERENCE_TESTS = 36,
    WMIQ_LF37_SELECT_INTO = 37,WMIQ_LF38_BASIC_DATETIME_TESTS = 38,WMIQ_LF39_COUNT_COLUMN = 39,WMIQ_LF40_BETWEEN = 40,WMIQ_LF_LAST = 40
  } WMIQ_LANGUAGE_FEATURES;

  typedef enum tag_WMIQ_RPNQ_FEATURE {
    WMIQ_RPNF_WHERE_CLAUSE_PRESENT = 0x1,WMIQ_RPNF_QUERY_IS_CONJUNCTIVE = 0x2,WMIQ_RPNF_QUERY_IS_DISJUNCTIVE = 0x4,WMIQ_RPNF_PROJECTION = 0x8,
    WMIQ_RPNF_FEATURE_SELECT_STAR = 0x10,WMIQ_RPNF_EQUALITY_TESTS_ONLY = 0x20,WMIQ_RPNF_COUNT_STAR = 0x40,WMIQ_RPNF_QUALIFIED_NAMES_USED = 0x80,
    WMIQ_RPNF_SYSPROP_CLASS_USED = 0x100,WMIQ_RPNF_PROP_TO_PROP_TESTS = 0x200,WMIQ_RPNF_ORDER_BY = 0x400,WMIQ_RPNF_ISA_USED = 0x800,
    WMIQ_RPNF_GROUP_BY_HAVING = 0x1000,WMIQ_RPNF_ARRAY_ACCESS_USED = 0x2000
  } WMIQ_RPNF_FEATURE;

  typedef struct tag_SWbemRpnEncodedQuery {
    ULONG m_uVersion;
    ULONG m_uTokenType;
    __MINGW_EXTENSION unsigned __int64 m_uParsedFeatureMask;
    ULONG m_uDetectedArraySize;
    ULONG *m_puDetectedFeatures;
    ULONG m_uSelectListSize;
    SWbemQueryQualifiedName **m_ppSelectList;
    ULONG m_uFromTargetType;
    LPCWSTR m_pszOptionalFromPath;
    ULONG m_uFromListSize;
    LPCWSTR *m_ppszFromList;
    ULONG m_uWhereClauseSize;
    SWbemRpnQueryToken **m_ppRpnWhereClause;
    double m_dblWithinPolling;
    double m_dblWithinWindow;
    ULONG m_uOrderByListSize;
    LPCWSTR *m_ppszOrderByList;
    ULONG *m_uOrderDirectionEl;
  } SWbemRpnEncodedQuery;

  typedef struct tag_SWbemAnalysisMatrix {
    ULONG m_uVersion;
    ULONG m_uMatrixType;
    LPCWSTR m_pszProperty;
    ULONG m_uPropertyType;
    ULONG m_uEntries;
    LPVOID *m_pValues;
    WINBOOL *m_pbTruthTable;
  } SWbemAnalysisMatrix;

  typedef struct tag_SWbemAnalysisMatrixList {
    ULONG m_uVersion;
    ULONG m_uMatrixType;
    ULONG m_uNumMatrices;
    SWbemAnalysisMatrix *m_pMatrices;
  } SWbemAnalysisMatrixList;

  typedef struct tag_SWbemAssocQueryInf {
    ULONG m_uVersion;
    ULONG m_uAnalysisType;
    ULONG m_uFeatureMask;
    IWbemPath *m_pPath;
    LPWSTR m_pszPath;
    LPWSTR m_pszQueryText;
    LPWSTR m_pszResultClass;
    LPWSTR m_pszAssocClass;
    LPWSTR m_pszRole;
    LPWSTR m_pszResultRole;
    LPWSTR m_pszRequiredQualifier;
    LPWSTR m_pszRequiredAssocQualifier;
  } SWbemAssocQueryInf;

  extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0116_v0_0_c_ifspec;
  extern RPC_IF_HANDLE __MIDL_itf_wmiutils_0116_v0_0_s_ifspec;

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                usr/share/mingw-w64/include/wmsbuffer.h                                                             0100644 0000000 0000000 00000014035 12404413016 016511  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*** Autogenerated by WIDL 1.6 from include/wmsbuffer.idl - Do not edit ***/

#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

/* Forward declarations */

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif

/* Headers for imported files */

#include <objidl.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************
 * INSSBuffer interface
 */
#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

DEFINE_GUID(IID_INSSBuffer, 0xe1cd3524, 0x03d7, 0x11d2, 0x9e,0xed, 0x00,0x60,0x97,0xd2,0xd7,0xcf);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("e1cd3524-03d7-11d2-9eed-006097d2d7cf")
INSSBuffer : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetLength(
        DWORD *pdwLength) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetLength(
        DWORD dwLength) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMaxLength(
        DWORD *pdwLength) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBuffer(
        BYTE **ppdwBuffer) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength(
        BYTE **ppdwBuffer,
        DWORD *pdwLength) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(INSSBuffer, 0xe1cd3524, 0x03d7, 0x11d2, 0x9e,0xed, 0x00,0x60,0x97,0xd2,0xd7,0xcf)
#endif
#else
typedef struct INSSBufferVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        INSSBuffer* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        INSSBuffer* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        INSSBuffer* This);

    /*** INSSBuffer methods ***/
    HRESULT (STDMETHODCALLTYPE *GetLength)(
        INSSBuffer* This,
        DWORD *pdwLength);

    HRESULT (STDMETHODCALLTYPE *SetLength)(
        INSSBuffer* This,
        DWORD dwLength);

    HRESULT (STDMETHODCALLTYPE *GetMaxLength)(
        INSSBuffer* This,
        DWORD *pdwLength);

    HRESULT (STDMETHODCALLTYPE *GetBuffer)(
        INSSBuffer* This,
        BYTE **ppdwBuffer);

    HRESULT (STDMETHODCALLTYPE *GetBufferAndLength)(
        INSSBuffer* This,
        BYTE **ppdwBuffer,
        DWORD *pdwLength);

    END_INTERFACE
} INSSBufferVtbl;
interface INSSBuffer {
    CONST_VTBL INSSBufferVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define INSSBuffer_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define INSSBuffer_AddRef(This) (This)->lpVtbl->AddRef(This)
#define INSSBuffer_Release(This) (This)->lpVtbl->Release(This)
/*** INSSBuffer methods ***/
#define INSSBuffer_GetLength(This,pdwLength) (This)->lpVtbl->GetLength(This,pdwLength)
#define INSSBuffer_SetLength(This,dwLength) (This)->lpVtbl->SetLength(This,dwLength)
#define INSSBuffer_GetMaxLength(This,pdwLength) (This)->lpVtbl->GetMaxLength(This,pdwLength)
#define INSSBuffer_GetBuffer(This,ppdwBuffer) (This)->lpVtbl->GetBuffer(This,ppdwBuffer)
#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength) (This)->lpVtbl->GetBufferAndLength(This,ppdwBuffer,pdwLength)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT INSSBuffer_QueryInterface(INSSBuffer* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG INSSBuffer_AddRef(INSSBuffer* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG INSSBuffer_Release(INSSBuffer* This) {
    return This->lpVtbl->Release(This);
}
/*** INSSBuffer methods ***/
static FORCEINLINE HRESULT INSSBuffer_GetLength(INSSBuffer* This,DWORD *pdwLength) {
    return This->lpVtbl->GetLength(This,pdwLength);
}
static FORCEINLINE HRESULT INSSBuffer_SetLength(INSSBuffer* This,DWORD dwLength) {
    return This->lpVtbl->SetLength(This,dwLength);
}
static FORCEINLINE HRESULT INSSBuffer_GetMaxLength(INSSBuffer* This,DWORD *pdwLength) {
    return This->lpVtbl->GetMaxLength(This,pdwLength);
}
static FORCEINLINE HRESULT INSSBuffer_GetBuffer(INSSBuffer* This,BYTE **ppdwBuffer) {
    return This->lpVtbl->GetBuffer(This,ppdwBuffer);
}
static FORCEINLINE HRESULT INSSBuffer_GetBufferAndLength(INSSBuffer* This,BYTE **ppdwBuffer,DWORD *pdwLength) {
    return This->lpVtbl->GetBufferAndLength(This,ppdwBuffer,pdwLength);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE INSSBuffer_GetLength_Proxy(
    INSSBuffer* This,
    DWORD *pdwLength);
void __RPC_STUB INSSBuffer_GetLength_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE INSSBuffer_SetLength_Proxy(
    INSSBuffer* This,
    DWORD dwLength);
void __RPC_STUB INSSBuffer_SetLength_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE INSSBuffer_GetMaxLength_Proxy(
    INSSBuffer* This,
    DWORD *pdwLength);
void __RPC_STUB INSSBuffer_GetMaxLength_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE INSSBuffer_GetBuffer_Proxy(
    INSSBuffer* This,
    BYTE **ppdwBuffer);
void __RPC_STUB INSSBuffer_GetBuffer_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE INSSBuffer_GetBufferAndLength_Proxy(
    INSSBuffer* This,
    BYTE **ppdwBuffer,
    DWORD *pdwLength);
void __RPC_STUB INSSBuffer_GetBufferAndLength_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __INSSBuffer_INTERFACE_DEFINED__ */

/* Begin additional prototypes for all interfaces */


/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __wmsbuffer_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/wmsdkidl.h                                                              0100644 0000000 0000000 00000166140 12404413016 016334  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*** Autogenerated by WIDL 1.6 from include/wmsdkidl.idl - Do not edit ***/

#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __wmsdkidl_h__
#define __wmsdkidl_h__

/* Forward declarations */

#ifndef __IWMStatusCallback_FWD_DEFINED__
#define __IWMStatusCallback_FWD_DEFINED__
typedef interface IWMStatusCallback IWMStatusCallback;
#endif

#ifndef __IWMReaderCallback_FWD_DEFINED__
#define __IWMReaderCallback_FWD_DEFINED__
typedef interface IWMReaderCallback IWMReaderCallback;
#endif

#ifndef __IWMMediaProps_FWD_DEFINED__
#define __IWMMediaProps_FWD_DEFINED__
typedef interface IWMMediaProps IWMMediaProps;
#endif

#ifndef __IWMOutputMediaProps_FWD_DEFINED__
#define __IWMOutputMediaProps_FWD_DEFINED__
typedef interface IWMOutputMediaProps IWMOutputMediaProps;
#endif

#ifndef __IWMMetadataEditor_FWD_DEFINED__
#define __IWMMetadataEditor_FWD_DEFINED__
typedef interface IWMMetadataEditor IWMMetadataEditor;
#endif

#ifndef __IWMReader_FWD_DEFINED__
#define __IWMReader_FWD_DEFINED__
typedef interface IWMReader IWMReader;
#endif

#ifndef __IWMSyncReader_FWD_DEFINED__
#define __IWMSyncReader_FWD_DEFINED__
typedef interface IWMSyncReader IWMSyncReader;
#endif

/* Headers for imported files */

#include <oaidl.h>
#include <wmsbuffer.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef UINT64 QWORD;
typedef struct _WMMediaType {
    GUID majortype;
    GUID subtype;
    WINBOOL bFixedSizeSamples;
    WINBOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    BYTE *pbFormat;
} WM_MEDIA_TYPE;
typedef enum WMT_ATTR_DATATYPE {
    WMT_TYPE_DWORD = 0,
    WMT_TYPE_STRING = 1,
    WMT_TYPE_BINARY = 2,
    WMT_TYPE_BOOL = 3,
    WMT_TYPE_QWORD = 4,
    WMT_TYPE_WORD = 5,
    WMT_TYPE_GUID = 6
} WMT_ATTR_DATATYPE;
typedef enum WMT_STATUS {
    WMT_ERROR = 0,
    WMT_OPENED = 1,
    WMT_BUFFERING_START = 2,
    WMT_BUFFERING_STOP = 3,
    WMT_EOF = 4,
    WMT_END_OF_FILE = 4,
    WMT_END_OF_SEGMENT = 5,
    WMT_END_OF_STREAMING = 6,
    WMT_LOCATING = 7,
    WMT_CONNECTING = 8,
    WMT_NO_RIGHTS = 9,
    WMT_MISSING_CODEC = 10,
    WMT_STARTED = 11,
    WMT_STOPPED = 12,
    WMT_CLOSED = 13,
    WMT_STRIDING = 14,
    WMT_TIMER = 15,
    WMT_INDEX_PROGRESS = 16,
    WMT_SAVEAS_START = 17,
    WMT_SAVEAS_STOP = 18,
    WMT_NEW_SOURCEFLAGS = 19,
    WMT_NEW_METADATA = 20,
    WMT_BACKUPRESTORE_BEGIN = 21,
    WMT_SOURCE_SWITCH = 22,
    WMT_ACQUIRE_LICENSE = 23,
    WMT_INDIVIDUALIZE = 24,
    WMT_NEEDS_INDIVIDUALIZATION = 25,
    WMT_NO_RIGHTS_EX = 26,
    WMT_BACKUPRESTORE_END = 27,
    WMT_BACKUPRESTORE_CONNECTING = 28,
    WMT_BACKUPRESTORE_DISCONNECTING = 29,
    WMT_ERROR_WITHURL = 30,
    WMT_RESTRICTED_LICENSE = 31,
    WMT_CLIENT_CONNECT = 32,
    WMT_CLIENT_DISCONNECT = 33,
    WMT_NATIVE_OUTPUT_PROPS_CHANGED = 34,
    WMT_RECONNECT_START = 35,
    WMT_RECONNECT_END = 36,
    WMT_CLIENT_CONNECT_EX = 37,
    WMT_CLIENT_DISCONNECT_EX = 38,
    WMT_SET_FEC_SPAN = 39,
    WMT_PREROLL_READY = 40,
    WMT_PREROLL_COMPLETE = 41,
    WMT_CLIENT_PROPERTIES = 42,
    WMT_LICENSEURL_SIGNATURE_STATE = 43,
    WMT_INIT_PLAYLIST_BURN = 44,
    WMT_TRANSCRYPTOR_INIT = 45,
    WMT_TRANSCRYPTOR_SEEKED = 46,
    WMT_TRANSCRYPTOR_READ = 47,
    WMT_TRANSCRYPTOR_CLOSED = 48,
    WMT_PROXIMITY_RESULT = 49,
    WMT_PROXIMITY_COMPLETED = 50,
    WMT_CONTENT_ENABLER = 51
} WMT_STATUS;
typedef enum WMT_STREAM_SELECTION {
    WMT_OFF = 0,
    WMT_CLEANPOINT_ONLY = 1,
    WMT_ON = 2
} WMT_STREAM_SELECTION;
/*****************************************************************************
 * IWMStatusCallback interface
 */
#ifndef __IWMStatusCallback_INTERFACE_DEFINED__
#define __IWMStatusCallback_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMStatusCallback, 0x6d7cdc70, 0x9888, 0x11d3, 0x8e,0xdc, 0x00,0xc0,0x4f,0x61,0x09,0xcf);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("6d7cdc70-9888-11d3-8edc-00c04f6109cf")
IWMStatusCallback : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE OnStatus(
        WMT_STATUS Status,
        HRESULT hr,
        WMT_ATTR_DATATYPE dwType,
        BYTE *pValue,
        void *pvContext) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMStatusCallback, 0x6d7cdc70, 0x9888, 0x11d3, 0x8e,0xdc, 0x00,0xc0,0x4f,0x61,0x09,0xcf)
#endif
#else
typedef struct IWMStatusCallbackVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMStatusCallback* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMStatusCallback* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMStatusCallback* This);

    /*** IWMStatusCallback methods ***/
    HRESULT (STDMETHODCALLTYPE *OnStatus)(
        IWMStatusCallback* This,
        WMT_STATUS Status,
        HRESULT hr,
        WMT_ATTR_DATATYPE dwType,
        BYTE *pValue,
        void *pvContext);

    END_INTERFACE
} IWMStatusCallbackVtbl;
interface IWMStatusCallback {
    CONST_VTBL IWMStatusCallbackVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMStatusCallback_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMStatusCallback_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMStatusCallback_Release(This) (This)->lpVtbl->Release(This)
/*** IWMStatusCallback methods ***/
#define IWMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext) (This)->lpVtbl->OnStatus(This,Status,hr,dwType,pValue,pvContext)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMStatusCallback_QueryInterface(IWMStatusCallback* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMStatusCallback_AddRef(IWMStatusCallback* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMStatusCallback_Release(IWMStatusCallback* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMStatusCallback methods ***/
static FORCEINLINE HRESULT IWMStatusCallback_OnStatus(IWMStatusCallback* This,WMT_STATUS Status,HRESULT hr,WMT_ATTR_DATATYPE dwType,BYTE *pValue,void *pvContext) {
    return This->lpVtbl->OnStatus(This,Status,hr,dwType,pValue,pvContext);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMStatusCallback_OnStatus_Proxy(
    IWMStatusCallback* This,
    WMT_STATUS Status,
    HRESULT hr,
    WMT_ATTR_DATATYPE dwType,
    BYTE *pValue,
    void *pvContext);
void __RPC_STUB IWMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMStatusCallback_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWMReaderCallback interface
 */
#ifndef __IWMReaderCallback_INTERFACE_DEFINED__
#define __IWMReaderCallback_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMReaderCallback, 0x96406bd8, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("96406bd8-2b2b-11d3-b36b-00c04f6108ff")
IWMReaderCallback : public IWMStatusCallback
{
    virtual HRESULT STDMETHODCALLTYPE OnSample(
        DWORD dwOutputNum,
        QWORD cnsSampleTime,
        QWORD cnsSampleDuration,
        DWORD dwFlags,
        INSSBuffer *pSample,
        void *pvContext) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMReaderCallback, 0x96406bd8, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff)
#endif
#else
typedef struct IWMReaderCallbackVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMReaderCallback* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMReaderCallback* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMReaderCallback* This);

    /*** IWMStatusCallback methods ***/
    HRESULT (STDMETHODCALLTYPE *OnStatus)(
        IWMReaderCallback* This,
        WMT_STATUS Status,
        HRESULT hr,
        WMT_ATTR_DATATYPE dwType,
        BYTE *pValue,
        void *pvContext);

    /*** IWMReaderCallback methods ***/
    HRESULT (STDMETHODCALLTYPE *OnSample)(
        IWMReaderCallback* This,
        DWORD dwOutputNum,
        QWORD cnsSampleTime,
        QWORD cnsSampleDuration,
        DWORD dwFlags,
        INSSBuffer *pSample,
        void *pvContext);

    END_INTERFACE
} IWMReaderCallbackVtbl;
interface IWMReaderCallback {
    CONST_VTBL IWMReaderCallbackVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMReaderCallback_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMReaderCallback_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMReaderCallback_Release(This) (This)->lpVtbl->Release(This)
/*** IWMStatusCallback methods ***/
#define IWMReaderCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext) (This)->lpVtbl->OnStatus(This,Status,hr,dwType,pValue,pvContext)
/*** IWMReaderCallback methods ***/
#define IWMReaderCallback_OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext) (This)->lpVtbl->OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMReaderCallback_QueryInterface(IWMReaderCallback* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMReaderCallback_AddRef(IWMReaderCallback* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMReaderCallback_Release(IWMReaderCallback* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMStatusCallback methods ***/
static FORCEINLINE HRESULT IWMReaderCallback_OnStatus(IWMReaderCallback* This,WMT_STATUS Status,HRESULT hr,WMT_ATTR_DATATYPE dwType,BYTE *pValue,void *pvContext) {
    return This->lpVtbl->OnStatus(This,Status,hr,dwType,pValue,pvContext);
}
/*** IWMReaderCallback methods ***/
static FORCEINLINE HRESULT IWMReaderCallback_OnSample(IWMReaderCallback* This,DWORD dwOutputNum,QWORD cnsSampleTime,QWORD cnsSampleDuration,DWORD dwFlags,INSSBuffer *pSample,void *pvContext) {
    return This->lpVtbl->OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMReaderCallback_OnSample_Proxy(
    IWMReaderCallback* This,
    DWORD dwOutputNum,
    QWORD cnsSampleTime,
    QWORD cnsSampleDuration,
    DWORD dwFlags,
    INSSBuffer *pSample,
    void *pvContext);
void __RPC_STUB IWMReaderCallback_OnSample_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMReaderCallback_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWMMediaProps interface
 */
#ifndef __IWMMediaProps_INTERFACE_DEFINED__
#define __IWMMediaProps_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMMediaProps, 0x96406bce, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("96406bce-2b2b-11d3-b36b-00c04f6108ff")
IWMMediaProps : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetType(
        GUID *pguidType) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMediaType(
        WM_MEDIA_TYPE *pType,
        DWORD *pcbType) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetMediaType(
        WM_MEDIA_TYPE *pType) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMMediaProps, 0x96406bce, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff)
#endif
#else
typedef struct IWMMediaPropsVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMMediaProps* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMMediaProps* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMMediaProps* This);

    /*** IWMMediaProps methods ***/
    HRESULT (STDMETHODCALLTYPE *GetType)(
        IWMMediaProps* This,
        GUID *pguidType);

    HRESULT (STDMETHODCALLTYPE *GetMediaType)(
        IWMMediaProps* This,
        WM_MEDIA_TYPE *pType,
        DWORD *pcbType);

    HRESULT (STDMETHODCALLTYPE *SetMediaType)(
        IWMMediaProps* This,
        WM_MEDIA_TYPE *pType);

    END_INTERFACE
} IWMMediaPropsVtbl;
interface IWMMediaProps {
    CONST_VTBL IWMMediaPropsVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMMediaProps_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMMediaProps_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMMediaProps_Release(This) (This)->lpVtbl->Release(This)
/*** IWMMediaProps methods ***/
#define IWMMediaProps_GetType(This,pguidType) (This)->lpVtbl->GetType(This,pguidType)
#define IWMMediaProps_GetMediaType(This,pType,pcbType) (This)->lpVtbl->GetMediaType(This,pType,pcbType)
#define IWMMediaProps_SetMediaType(This,pType) (This)->lpVtbl->SetMediaType(This,pType)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMMediaProps_QueryInterface(IWMMediaProps* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMMediaProps_AddRef(IWMMediaProps* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMMediaProps_Release(IWMMediaProps* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMMediaProps methods ***/
static FORCEINLINE HRESULT IWMMediaProps_GetType(IWMMediaProps* This,GUID *pguidType) {
    return This->lpVtbl->GetType(This,pguidType);
}
static FORCEINLINE HRESULT IWMMediaProps_GetMediaType(IWMMediaProps* This,WM_MEDIA_TYPE *pType,DWORD *pcbType) {
    return This->lpVtbl->GetMediaType(This,pType,pcbType);
}
static FORCEINLINE HRESULT IWMMediaProps_SetMediaType(IWMMediaProps* This,WM_MEDIA_TYPE *pType) {
    return This->lpVtbl->SetMediaType(This,pType);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMMediaProps_GetType_Proxy(
    IWMMediaProps* This,
    GUID *pguidType);
void __RPC_STUB IWMMediaProps_GetType_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMMediaProps_GetMediaType_Proxy(
    IWMMediaProps* This,
    WM_MEDIA_TYPE *pType,
    DWORD *pcbType);
void __RPC_STUB IWMMediaProps_GetMediaType_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMMediaProps_SetMediaType_Proxy(
    IWMMediaProps* This,
    WM_MEDIA_TYPE *pType);
void __RPC_STUB IWMMediaProps_SetMediaType_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMMediaProps_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWMOutputMediaProps interface
 */
#ifndef __IWMOutputMediaProps_INTERFACE_DEFINED__
#define __IWMOutputMediaProps_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMOutputMediaProps, 0x96406bd7, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("96406bd7-2b2b-11d3-b36b-00c04f6108ff")
IWMOutputMediaProps : public IWMMediaProps
{
    virtual HRESULT STDMETHODCALLTYPE GetStreamGroupName(
        WCHAR *pwszName,
        WORD *pcchName) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetConnectionName(
        WCHAR *pwszName,
        WORD *pcchName) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMOutputMediaProps, 0x96406bd7, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff)
#endif
#else
typedef struct IWMOutputMediaPropsVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMOutputMediaProps* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMOutputMediaProps* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMOutputMediaProps* This);

    /*** IWMMediaProps methods ***/
    HRESULT (STDMETHODCALLTYPE *GetType)(
        IWMOutputMediaProps* This,
        GUID *pguidType);

    HRESULT (STDMETHODCALLTYPE *GetMediaType)(
        IWMOutputMediaProps* This,
        WM_MEDIA_TYPE *pType,
        DWORD *pcbType);

    HRESULT (STDMETHODCALLTYPE *SetMediaType)(
        IWMOutputMediaProps* This,
        WM_MEDIA_TYPE *pType);

    /*** IWMOutputMediaProps methods ***/
    HRESULT (STDMETHODCALLTYPE *GetStreamGroupName)(
        IWMOutputMediaProps* This,
        WCHAR *pwszName,
        WORD *pcchName);

    HRESULT (STDMETHODCALLTYPE *GetConnectionName)(
        IWMOutputMediaProps* This,
        WCHAR *pwszName,
        WORD *pcchName);

    END_INTERFACE
} IWMOutputMediaPropsVtbl;
interface IWMOutputMediaProps {
    CONST_VTBL IWMOutputMediaPropsVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMOutputMediaProps_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMOutputMediaProps_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMOutputMediaProps_Release(This) (This)->lpVtbl->Release(This)
/*** IWMMediaProps methods ***/
#define IWMOutputMediaProps_GetType(This,pguidType) (This)->lpVtbl->GetType(This,pguidType)
#define IWMOutputMediaProps_GetMediaType(This,pType,pcbType) (This)->lpVtbl->GetMediaType(This,pType,pcbType)
#define IWMOutputMediaProps_SetMediaType(This,pType) (This)->lpVtbl->SetMediaType(This,pType)
/*** IWMOutputMediaProps methods ***/
#define IWMOutputMediaProps_GetStreamGroupName(This,pwszName,pcchName) (This)->lpVtbl->GetStreamGroupName(This,pwszName,pcchName)
#define IWMOutputMediaProps_GetConnectionName(This,pwszName,pcchName) (This)->lpVtbl->GetConnectionName(This,pwszName,pcchName)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMOutputMediaProps_QueryInterface(IWMOutputMediaProps* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMOutputMediaProps_AddRef(IWMOutputMediaProps* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMOutputMediaProps_Release(IWMOutputMediaProps* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMMediaProps methods ***/
static FORCEINLINE HRESULT IWMOutputMediaProps_GetType(IWMOutputMediaProps* This,GUID *pguidType) {
    return This->lpVtbl->GetType(This,pguidType);
}
static FORCEINLINE HRESULT IWMOutputMediaProps_GetMediaType(IWMOutputMediaProps* This,WM_MEDIA_TYPE *pType,DWORD *pcbType) {
    return This->lpVtbl->GetMediaType(This,pType,pcbType);
}
static FORCEINLINE HRESULT IWMOutputMediaProps_SetMediaType(IWMOutputMediaProps* This,WM_MEDIA_TYPE *pType) {
    return This->lpVtbl->SetMediaType(This,pType);
}
/*** IWMOutputMediaProps methods ***/
static FORCEINLINE HRESULT IWMOutputMediaProps_GetStreamGroupName(IWMOutputMediaProps* This,WCHAR *pwszName,WORD *pcchName) {
    return This->lpVtbl->GetStreamGroupName(This,pwszName,pcchName);
}
static FORCEINLINE HRESULT IWMOutputMediaProps_GetConnectionName(IWMOutputMediaProps* This,WCHAR *pwszName,WORD *pcchName) {
    return This->lpVtbl->GetConnectionName(This,pwszName,pcchName);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetStreamGroupName_Proxy(
    IWMOutputMediaProps* This,
    WCHAR *pwszName,
    WORD *pcchName);
void __RPC_STUB IWMOutputMediaProps_GetStreamGroupName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetConnectionName_Proxy(
    IWMOutputMediaProps* This,
    WCHAR *pwszName,
    WORD *pcchName);
void __RPC_STUB IWMOutputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMOutputMediaProps_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWMMetadataEditor interface
 */
#ifndef __IWMMetadataEditor_INTERFACE_DEFINED__
#define __IWMMetadataEditor_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMMetadataEditor, 0x96406bd9, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("96406bd9-2b2b-11d3-b36b-00c04f6108ff")
IWMMetadataEditor : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE Open(
        const WCHAR *pwszFilename) = 0;

    virtual HRESULT STDMETHODCALLTYPE Close(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMMetadataEditor, 0x96406bd9, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff)
#endif
#else
typedef struct IWMMetadataEditorVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMMetadataEditor* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMMetadataEditor* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMMetadataEditor* This);

    /*** IWMMetadataEditor methods ***/
    HRESULT (STDMETHODCALLTYPE *Open)(
        IWMMetadataEditor* This,
        const WCHAR *pwszFilename);

    HRESULT (STDMETHODCALLTYPE *Close)(
        IWMMetadataEditor* This);

    HRESULT (STDMETHODCALLTYPE *Flush)(
        IWMMetadataEditor* This);

    END_INTERFACE
} IWMMetadataEditorVtbl;
interface IWMMetadataEditor {
    CONST_VTBL IWMMetadataEditorVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMMetadataEditor_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMMetadataEditor_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMMetadataEditor_Release(This) (This)->lpVtbl->Release(This)
/*** IWMMetadataEditor methods ***/
#define IWMMetadataEditor_Open(This,pwszFilename) (This)->lpVtbl->Open(This,pwszFilename)
#define IWMMetadataEditor_Close(This) (This)->lpVtbl->Close(This)
#define IWMMetadataEditor_Flush(This) (This)->lpVtbl->Flush(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMMetadataEditor_QueryInterface(IWMMetadataEditor* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMMetadataEditor_AddRef(IWMMetadataEditor* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMMetadataEditor_Release(IWMMetadataEditor* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMMetadataEditor methods ***/
static FORCEINLINE HRESULT IWMMetadataEditor_Open(IWMMetadataEditor* This,const WCHAR *pwszFilename) {
    return This->lpVtbl->Open(This,pwszFilename);
}
static FORCEINLINE HRESULT IWMMetadataEditor_Close(IWMMetadataEditor* This) {
    return This->lpVtbl->Close(This);
}
static FORCEINLINE HRESULT IWMMetadataEditor_Flush(IWMMetadataEditor* This) {
    return This->lpVtbl->Flush(This);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Open_Proxy(
    IWMMetadataEditor* This,
    const WCHAR *pwszFilename);
void __RPC_STUB IWMMetadataEditor_Open_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Close_Proxy(
    IWMMetadataEditor* This);
void __RPC_STUB IWMMetadataEditor_Close_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Flush_Proxy(
    IWMMetadataEditor* This);
void __RPC_STUB IWMMetadataEditor_Flush_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMMetadataEditor_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWMReader interface
 */
#ifndef __IWMReader_INTERFACE_DEFINED__
#define __IWMReader_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMReader, 0x96406bd6, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("96406bd6-2b2b-11d3-b36b-00c04f6108ff")
IWMReader : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE Open(
        const WCHAR *pwszURL,
        IWMReaderCallback *pCallback,
        void *pvContext) = 0;

    virtual HRESULT STDMETHODCALLTYPE Close(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputCount(
        DWORD *pcOutputs) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputProps(
        DWORD dwOutputNum,
        IWMOutputMediaProps **ppOutput) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetOutputProps(
        DWORD dwOutputNum,
        IWMOutputMediaProps *pOutput) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount(
        DWORD dwOutputNumber,
        DWORD *pcFormats) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputFormat(
        DWORD dwOutputNumber,
        DWORD dwFormatNumber,
        IWMOutputMediaProps **ppProps) = 0;

    virtual HRESULT STDMETHODCALLTYPE Start(
        QWORD cnsStart,
        QWORD cnsDuration,
        float fRate,
        void *pvContext) = 0;

    virtual HRESULT STDMETHODCALLTYPE Stop(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Pause(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Resume(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMReader, 0x96406bd6, 0x2b2b, 0x11d3, 0xb3,0x6b, 0x00,0xc0,0x4f,0x61,0x08,0xff)
#endif
#else
typedef struct IWMReaderVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMReader* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMReader* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMReader* This);

    /*** IWMReader methods ***/
    HRESULT (STDMETHODCALLTYPE *Open)(
        IWMReader* This,
        const WCHAR *pwszURL,
        IWMReaderCallback *pCallback,
        void *pvContext);

    HRESULT (STDMETHODCALLTYPE *Close)(
        IWMReader* This);

    HRESULT (STDMETHODCALLTYPE *GetOutputCount)(
        IWMReader* This,
        DWORD *pcOutputs);

    HRESULT (STDMETHODCALLTYPE *GetOutputProps)(
        IWMReader* This,
        DWORD dwOutputNum,
        IWMOutputMediaProps **ppOutput);

    HRESULT (STDMETHODCALLTYPE *SetOutputProps)(
        IWMReader* This,
        DWORD dwOutputNum,
        IWMOutputMediaProps *pOutput);

    HRESULT (STDMETHODCALLTYPE *GetOutputFormatCount)(
        IWMReader* This,
        DWORD dwOutputNumber,
        DWORD *pcFormats);

    HRESULT (STDMETHODCALLTYPE *GetOutputFormat)(
        IWMReader* This,
        DWORD dwOutputNumber,
        DWORD dwFormatNumber,
        IWMOutputMediaProps **ppProps);

    HRESULT (STDMETHODCALLTYPE *Start)(
        IWMReader* This,
        QWORD cnsStart,
        QWORD cnsDuration,
        float fRate,
        void *pvContext);

    HRESULT (STDMETHODCALLTYPE *Stop)(
        IWMReader* This);

    HRESULT (STDMETHODCALLTYPE *Pause)(
        IWMReader* This);

    HRESULT (STDMETHODCALLTYPE *Resume)(
        IWMReader* This);

    END_INTERFACE
} IWMReaderVtbl;
interface IWMReader {
    CONST_VTBL IWMReaderVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMReader_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMReader_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMReader_Release(This) (This)->lpVtbl->Release(This)
/*** IWMReader methods ***/
#define IWMReader_Open(This,pwszURL,pCallback,pvContext) (This)->lpVtbl->Open(This,pwszURL,pCallback,pvContext)
#define IWMReader_Close(This) (This)->lpVtbl->Close(This)
#define IWMReader_GetOutputCount(This,pcOutputs) (This)->lpVtbl->GetOutputCount(This,pcOutputs)
#define IWMReader_GetOutputProps(This,dwOutputNum,ppOutput) (This)->lpVtbl->GetOutputProps(This,dwOutputNum,ppOutput)
#define IWMReader_SetOutputProps(This,dwOutputNum,pOutput) (This)->lpVtbl->SetOutputProps(This,dwOutputNum,pOutput)
#define IWMReader_GetOutputFormatCount(This,dwOutputNumber,pcFormats) (This)->lpVtbl->GetOutputFormatCount(This,dwOutputNumber,pcFormats)
#define IWMReader_GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps) (This)->lpVtbl->GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)
#define IWMReader_Start(This,cnsStart,cnsDuration,fRate,pvContext) (This)->lpVtbl->Start(This,cnsStart,cnsDuration,fRate,pvContext)
#define IWMReader_Stop(This) (This)->lpVtbl->Stop(This)
#define IWMReader_Pause(This) (This)->lpVtbl->Pause(This)
#define IWMReader_Resume(This) (This)->lpVtbl->Resume(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMReader_QueryInterface(IWMReader* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMReader_AddRef(IWMReader* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMReader_Release(IWMReader* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMReader methods ***/
static FORCEINLINE HRESULT IWMReader_Open(IWMReader* This,const WCHAR *pwszURL,IWMReaderCallback *pCallback,void *pvContext) {
    return This->lpVtbl->Open(This,pwszURL,pCallback,pvContext);
}
static FORCEINLINE HRESULT IWMReader_Close(IWMReader* This) {
    return This->lpVtbl->Close(This);
}
static FORCEINLINE HRESULT IWMReader_GetOutputCount(IWMReader* This,DWORD *pcOutputs) {
    return This->lpVtbl->GetOutputCount(This,pcOutputs);
}
static FORCEINLINE HRESULT IWMReader_GetOutputProps(IWMReader* This,DWORD dwOutputNum,IWMOutputMediaProps **ppOutput) {
    return This->lpVtbl->GetOutputProps(This,dwOutputNum,ppOutput);
}
static FORCEINLINE HRESULT IWMReader_SetOutputProps(IWMReader* This,DWORD dwOutputNum,IWMOutputMediaProps *pOutput) {
    return This->lpVtbl->SetOutputProps(This,dwOutputNum,pOutput);
}
static FORCEINLINE HRESULT IWMReader_GetOutputFormatCount(IWMReader* This,DWORD dwOutputNumber,DWORD *pcFormats) {
    return This->lpVtbl->GetOutputFormatCount(This,dwOutputNumber,pcFormats);
}
static FORCEINLINE HRESULT IWMReader_GetOutputFormat(IWMReader* This,DWORD dwOutputNumber,DWORD dwFormatNumber,IWMOutputMediaProps **ppProps) {
    return This->lpVtbl->GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps);
}
static FORCEINLINE HRESULT IWMReader_Start(IWMReader* This,QWORD cnsStart,QWORD cnsDuration,float fRate,void *pvContext) {
    return This->lpVtbl->Start(This,cnsStart,cnsDuration,fRate,pvContext);
}
static FORCEINLINE HRESULT IWMReader_Stop(IWMReader* This) {
    return This->lpVtbl->Stop(This);
}
static FORCEINLINE HRESULT IWMReader_Pause(IWMReader* This) {
    return This->lpVtbl->Pause(This);
}
static FORCEINLINE HRESULT IWMReader_Resume(IWMReader* This) {
    return This->lpVtbl->Resume(This);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMReader_Open_Proxy(
    IWMReader* This,
    const WCHAR *pwszURL,
    IWMReaderCallback *pCallback,
    void *pvContext);
void __RPC_STUB IWMReader_Open_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_Close_Proxy(
    IWMReader* This);
void __RPC_STUB IWMReader_Close_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_GetOutputCount_Proxy(
    IWMReader* This,
    DWORD *pcOutputs);
void __RPC_STUB IWMReader_GetOutputCount_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_GetOutputProps_Proxy(
    IWMReader* This,
    DWORD dwOutputNum,
    IWMOutputMediaProps **ppOutput);
void __RPC_STUB IWMReader_GetOutputProps_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_SetOutputProps_Proxy(
    IWMReader* This,
    DWORD dwOutputNum,
    IWMOutputMediaProps *pOutput);
void __RPC_STUB IWMReader_SetOutputProps_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormatCount_Proxy(
    IWMReader* This,
    DWORD dwOutputNumber,
    DWORD *pcFormats);
void __RPC_STUB IWMReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormat_Proxy(
    IWMReader* This,
    DWORD dwOutputNumber,
    DWORD dwFormatNumber,
    IWMOutputMediaProps **ppProps);
void __RPC_STUB IWMReader_GetOutputFormat_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_Start_Proxy(
    IWMReader* This,
    QWORD cnsStart,
    QWORD cnsDuration,
    float fRate,
    void *pvContext);
void __RPC_STUB IWMReader_Start_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_Stop_Proxy(
    IWMReader* This);
void __RPC_STUB IWMReader_Stop_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_Pause_Proxy(
    IWMReader* This);
void __RPC_STUB IWMReader_Pause_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMReader_Resume_Proxy(
    IWMReader* This);
void __RPC_STUB IWMReader_Resume_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMReader_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWMSyncReader interface
 */
#ifndef __IWMSyncReader_INTERFACE_DEFINED__
#define __IWMSyncReader_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWMSyncReader, 0x9397f121, 0x7705, 0x4dc9, 0xb0,0x49, 0x98,0xb6,0x98,0x18,0x84,0x14);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("9397f121-7705-4dc9-b049-98b698188414")
IWMSyncReader : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE Open(
        const WCHAR *pwszFilename) = 0;

    virtual HRESULT STDMETHODCALLTYPE Close(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetRange(
        QWORD cnsStartTime,
        LONGLONG cnsDuration) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetRangeByFrame(
        WORD wStreamNum,
        QWORD qwFrameNumber,
        LONGLONG cFramesToRead) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextSample(
        WORD wStreamNum,
        INSSBuffer **ppSample,
        QWORD *pcnsSampleTime,
        QWORD *pcnsDuration,
        DWORD *pdwFlags,
        DWORD *pdwOutputNum,
        WORD *pwStreamNum) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected(
        WORD cStreamCount,
        WORD *pwStreamNumbers,
        WMT_STREAM_SELECTION *pSelections) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetStreamSelected(
        WORD wStreamNum,
        WMT_STREAM_SELECTION *pSelection) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetReadStreamSamples(
        WORD wStreamNum,
        WINBOOL fCompressed) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetReadStreamSamples(
        WORD wStreamNum,
        WINBOOL *pfCompressed) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputSetting(
        DWORD dwOutputNum,
        LPCWSTR pszName,
        WMT_ATTR_DATATYPE *pType,
        BYTE *pValue,
        WORD *pcbLength) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetOutputSetting(
        DWORD dwOutputNum,
        LPCWSTR pszName,
        WMT_ATTR_DATATYPE Type,
        const BYTE *pValue,
        WORD cbLength) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputCount(
        DWORD *pcOutputs) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputProps(
        DWORD dwOutputNum,
        IWMOutputMediaProps **ppOutput) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetOutputProps(
        DWORD dwOutputNum,
        IWMOutputMediaProps *pOutput) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount(
        DWORD dwOutputNum,
        DWORD *pcFormats) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputFormat(
        DWORD dwOutputNum,
        DWORD dwFormatNum,
        IWMOutputMediaProps **ppProps) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetOutputNumberForStream(
        WORD wStreamNum,
        DWORD *pdwOutputNum) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetStreamNumberForOutput(
        DWORD dwOutputNum,
        WORD *pwStreamNum) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize(
        DWORD dwOutput,
        DWORD *pcbMax) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize(
        WORD wStream,
        DWORD *pcbMax) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenStream(
        IStream *pStream) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWMSyncReader, 0x9397f121, 0x7705, 0x4dc9, 0xb0,0x49, 0x98,0xb6,0x98,0x18,0x84,0x14)
#endif
#else
typedef struct IWMSyncReaderVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWMSyncReader* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWMSyncReader* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWMSyncReader* This);

    /*** IWMSyncReader methods ***/
    HRESULT (STDMETHODCALLTYPE *Open)(
        IWMSyncReader* This,
        const WCHAR *pwszFilename);

    HRESULT (STDMETHODCALLTYPE *Close)(
        IWMSyncReader* This);

    HRESULT (STDMETHODCALLTYPE *SetRange)(
        IWMSyncReader* This,
        QWORD cnsStartTime,
        LONGLONG cnsDuration);

    HRESULT (STDMETHODCALLTYPE *SetRangeByFrame)(
        IWMSyncReader* This,
        WORD wStreamNum,
        QWORD qwFrameNumber,
        LONGLONG cFramesToRead);

    HRESULT (STDMETHODCALLTYPE *GetNextSample)(
        IWMSyncReader* This,
        WORD wStreamNum,
        INSSBuffer **ppSample,
        QWORD *pcnsSampleTime,
        QWORD *pcnsDuration,
        DWORD *pdwFlags,
        DWORD *pdwOutputNum,
        WORD *pwStreamNum);

    HRESULT (STDMETHODCALLTYPE *SetStreamsSelected)(
        IWMSyncReader* This,
        WORD cStreamCount,
        WORD *pwStreamNumbers,
        WMT_STREAM_SELECTION *pSelections);

    HRESULT (STDMETHODCALLTYPE *GetStreamSelected)(
        IWMSyncReader* This,
        WORD wStreamNum,
        WMT_STREAM_SELECTION *pSelection);

    HRESULT (STDMETHODCALLTYPE *SetReadStreamSamples)(
        IWMSyncReader* This,
        WORD wStreamNum,
        WINBOOL fCompressed);

    HRESULT (STDMETHODCALLTYPE *GetReadStreamSamples)(
        IWMSyncReader* This,
        WORD wStreamNum,
        WINBOOL *pfCompressed);

    HRESULT (STDMETHODCALLTYPE *GetOutputSetting)(
        IWMSyncReader* This,
        DWORD dwOutputNum,
        LPCWSTR pszName,
        WMT_ATTR_DATATYPE *pType,
        BYTE *pValue,
        WORD *pcbLength);

    HRESULT (STDMETHODCALLTYPE *SetOutputSetting)(
        IWMSyncReader* This,
        DWORD dwOutputNum,
        LPCWSTR pszName,
        WMT_ATTR_DATATYPE Type,
        const BYTE *pValue,
        WORD cbLength);

    HRESULT (STDMETHODCALLTYPE *GetOutputCount)(
        IWMSyncReader* This,
        DWORD *pcOutputs);

    HRESULT (STDMETHODCALLTYPE *GetOutputProps)(
        IWMSyncReader* This,
        DWORD dwOutputNum,
        IWMOutputMediaProps **ppOutput);

    HRESULT (STDMETHODCALLTYPE *SetOutputProps)(
        IWMSyncReader* This,
        DWORD dwOutputNum,
        IWMOutputMediaProps *pOutput);

    HRESULT (STDMETHODCALLTYPE *GetOutputFormatCount)(
        IWMSyncReader* This,
        DWORD dwOutputNum,
        DWORD *pcFormats);

    HRESULT (STDMETHODCALLTYPE *GetOutputFormat)(
        IWMSyncReader* This,
        DWORD dwOutputNum,
        DWORD dwFormatNum,
        IWMOutputMediaProps **ppProps);

    HRESULT (STDMETHODCALLTYPE *GetOutputNumberForStream)(
        IWMSyncReader* This,
        WORD wStreamNum,
        DWORD *pdwOutputNum);

    HRESULT (STDMETHODCALLTYPE *GetStreamNumberForOutput)(
        IWMSyncReader* This,
        DWORD dwOutputNum,
        WORD *pwStreamNum);

    HRESULT (STDMETHODCALLTYPE *GetMaxOutputSampleSize)(
        IWMSyncReader* This,
        DWORD dwOutput,
        DWORD *pcbMax);

    HRESULT (STDMETHODCALLTYPE *GetMaxStreamSampleSize)(
        IWMSyncReader* This,
        WORD wStream,
        DWORD *pcbMax);

    HRESULT (STDMETHODCALLTYPE *OpenStream)(
        IWMSyncReader* This,
        IStream *pStream);

    END_INTERFACE
} IWMSyncReaderVtbl;
interface IWMSyncReader {
    CONST_VTBL IWMSyncReaderVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWMSyncReader_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWMSyncReader_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWMSyncReader_Release(This) (This)->lpVtbl->Release(This)
/*** IWMSyncReader methods ***/
#define IWMSyncReader_Open(This,pwszFilename) (This)->lpVtbl->Open(This,pwszFilename)
#define IWMSyncReader_Close(This) (This)->lpVtbl->Close(This)
#define IWMSyncReader_SetRange(This,cnsStartTime,cnsDuration) (This)->lpVtbl->SetRange(This,cnsStartTime,cnsDuration)
#define IWMSyncReader_SetRangeByFrame(This,wStreamNum,qwFrameNumber,cFramesToRead) (This)->lpVtbl->SetRangeByFrame(This,wStreamNum,qwFrameNumber,cFramesToRead)
#define IWMSyncReader_GetNextSample(This,wStreamNum,ppSample,pcnsSampleTime,pcnsDuration,pdwFlags,pdwOutputNum,pwStreamNum) (This)->lpVtbl->GetNextSample(This,wStreamNum,ppSample,pcnsSampleTime,pcnsDuration,pdwFlags,pdwOutputNum,pwStreamNum)
#define IWMSyncReader_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections) (This)->lpVtbl->SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)
#define IWMSyncReader_GetStreamSelected(This,wStreamNum,pSelection) (This)->lpVtbl->GetStreamSelected(This,wStreamNum,pSelection)
#define IWMSyncReader_SetReadStreamSamples(This,wStreamNum,fCompressed) (This)->lpVtbl->SetReadStreamSamples(This,wStreamNum,fCompressed)
#define IWMSyncReader_GetReadStreamSamples(This,wStreamNum,pfCompressed) (This)->lpVtbl->GetReadStreamSamples(This,wStreamNum,pfCompressed)
#define IWMSyncReader_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength) (This)->lpVtbl->GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)
#define IWMSyncReader_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength) (This)->lpVtbl->SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)
#define IWMSyncReader_GetOutputCount(This,pcOutputs) (This)->lpVtbl->GetOutputCount(This,pcOutputs)
#define IWMSyncReader_GetOutputProps(This,dwOutputNum,ppOutput) (This)->lpVtbl->GetOutputProps(This,dwOutputNum,ppOutput)
#define IWMSyncReader_SetOutputProps(This,dwOutputNum,pOutput) (This)->lpVtbl->SetOutputProps(This,dwOutputNum,pOutput)
#define IWMSyncReader_GetOutputFormatCount(This,dwOutputNum,pcFormats) (This)->lpVtbl->GetOutputFormatCount(This,dwOutputNum,pcFormats)
#define IWMSyncReader_GetOutputFormat(This,dwOutputNum,dwFormatNum,ppProps) (This)->lpVtbl->GetOutputFormat(This,dwOutputNum,dwFormatNum,ppProps)
#define IWMSyncReader_GetOutputNumberForStream(This,wStreamNum,pdwOutputNum) (This)->lpVtbl->GetOutputNumberForStream(This,wStreamNum,pdwOutputNum)
#define IWMSyncReader_GetStreamNumberForOutput(This,dwOutputNum,pwStreamNum) (This)->lpVtbl->GetStreamNumberForOutput(This,dwOutputNum,pwStreamNum)
#define IWMSyncReader_GetMaxOutputSampleSize(This,dwOutput,pcbMax) (This)->lpVtbl->GetMaxOutputSampleSize(This,dwOutput,pcbMax)
#define IWMSyncReader_GetMaxStreamSampleSize(This,wStream,pcbMax) (This)->lpVtbl->GetMaxStreamSampleSize(This,wStream,pcbMax)
#define IWMSyncReader_OpenStream(This,pStream) (This)->lpVtbl->OpenStream(This,pStream)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWMSyncReader_QueryInterface(IWMSyncReader* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWMSyncReader_AddRef(IWMSyncReader* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWMSyncReader_Release(IWMSyncReader* This) {
    return This->lpVtbl->Release(This);
}
/*** IWMSyncReader methods ***/
static FORCEINLINE HRESULT IWMSyncReader_Open(IWMSyncReader* This,const WCHAR *pwszFilename) {
    return This->lpVtbl->Open(This,pwszFilename);
}
static FORCEINLINE HRESULT IWMSyncReader_Close(IWMSyncReader* This) {
    return This->lpVtbl->Close(This);
}
static FORCEINLINE HRESULT IWMSyncReader_SetRange(IWMSyncReader* This,QWORD cnsStartTime,LONGLONG cnsDuration) {
    return This->lpVtbl->SetRange(This,cnsStartTime,cnsDuration);
}
static FORCEINLINE HRESULT IWMSyncReader_SetRangeByFrame(IWMSyncReader* This,WORD wStreamNum,QWORD qwFrameNumber,LONGLONG cFramesToRead) {
    return This->lpVtbl->SetRangeByFrame(This,wStreamNum,qwFrameNumber,cFramesToRead);
}
static FORCEINLINE HRESULT IWMSyncReader_GetNextSample(IWMSyncReader* This,WORD wStreamNum,INSSBuffer **ppSample,QWORD *pcnsSampleTime,QWORD *pcnsDuration,DWORD *pdwFlags,DWORD *pdwOutputNum,WORD *pwStreamNum) {
    return This->lpVtbl->GetNextSample(This,wStreamNum,ppSample,pcnsSampleTime,pcnsDuration,pdwFlags,pdwOutputNum,pwStreamNum);
}
static FORCEINLINE HRESULT IWMSyncReader_SetStreamsSelected(IWMSyncReader* This,WORD cStreamCount,WORD *pwStreamNumbers,WMT_STREAM_SELECTION *pSelections) {
    return This->lpVtbl->SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections);
}
static FORCEINLINE HRESULT IWMSyncReader_GetStreamSelected(IWMSyncReader* This,WORD wStreamNum,WMT_STREAM_SELECTION *pSelection) {
    return This->lpVtbl->GetStreamSelected(This,wStreamNum,pSelection);
}
static FORCEINLINE HRESULT IWMSyncReader_SetReadStreamSamples(IWMSyncReader* This,WORD wStreamNum,WINBOOL fCompressed) {
    return This->lpVtbl->SetReadStreamSamples(This,wStreamNum,fCompressed);
}
static FORCEINLINE HRESULT IWMSyncReader_GetReadStreamSamples(IWMSyncReader* This,WORD wStreamNum,WINBOOL *pfCompressed) {
    return This->lpVtbl->GetReadStreamSamples(This,wStreamNum,pfCompressed);
}
static FORCEINLINE HRESULT IWMSyncReader_GetOutputSetting(IWMSyncReader* This,DWORD dwOutputNum,LPCWSTR pszName,WMT_ATTR_DATATYPE *pType,BYTE *pValue,WORD *pcbLength) {
    return This->lpVtbl->GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength);
}
static FORCEINLINE HRESULT IWMSyncReader_SetOutputSetting(IWMSyncReader* This,DWORD dwOutputNum,LPCWSTR pszName,WMT_ATTR_DATATYPE Type,const BYTE *pValue,WORD cbLength) {
    return This->lpVtbl->SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength);
}
static FORCEINLINE HRESULT IWMSyncReader_GetOutputCount(IWMSyncReader* This,DWORD *pcOutputs) {
    return This->lpVtbl->GetOutputCount(This,pcOutputs);
}
static FORCEINLINE HRESULT IWMSyncReader_GetOutputProps(IWMSyncReader* This,DWORD dwOutputNum,IWMOutputMediaProps **ppOutput) {
    return This->lpVtbl->GetOutputProps(This,dwOutputNum,ppOutput);
}
static FORCEINLINE HRESULT IWMSyncReader_SetOutputProps(IWMSyncReader* This,DWORD dwOutputNum,IWMOutputMediaProps *pOutput) {
    return This->lpVtbl->SetOutputProps(This,dwOutputNum,pOutput);
}
static FORCEINLINE HRESULT IWMSyncReader_GetOutputFormatCount(IWMSyncReader* This,DWORD dwOutputNum,DWORD *pcFormats) {
    return This->lpVtbl->GetOutputFormatCount(This,dwOutputNum,pcFormats);
}
static FORCEINLINE HRESULT IWMSyncReader_GetOutputFormat(IWMSyncReader* This,DWORD dwOutputNum,DWORD dwFormatNum,IWMOutputMediaProps **ppProps) {
    return This->lpVtbl->GetOutputFormat(This,dwOutputNum,dwFormatNum,ppProps);
}
static FORCEINLINE HRESULT IWMSyncReader_GetOutputNumberForStream(IWMSyncReader* This,WORD wStreamNum,DWORD *pdwOutputNum) {
    return This->lpVtbl->GetOutputNumberForStream(This,wStreamNum,pdwOutputNum);
}
static FORCEINLINE HRESULT IWMSyncReader_GetStreamNumberForOutput(IWMSyncReader* This,DWORD dwOutputNum,WORD *pwStreamNum) {
    return This->lpVtbl->GetStreamNumberForOutput(This,dwOutputNum,pwStreamNum);
}
static FORCEINLINE HRESULT IWMSyncReader_GetMaxOutputSampleSize(IWMSyncReader* This,DWORD dwOutput,DWORD *pcbMax) {
    return This->lpVtbl->GetMaxOutputSampleSize(This,dwOutput,pcbMax);
}
static FORCEINLINE HRESULT IWMSyncReader_GetMaxStreamSampleSize(IWMSyncReader* This,WORD wStream,DWORD *pcbMax) {
    return This->lpVtbl->GetMaxStreamSampleSize(This,wStream,pcbMax);
}
static FORCEINLINE HRESULT IWMSyncReader_OpenStream(IWMSyncReader* This,IStream *pStream) {
    return This->lpVtbl->OpenStream(This,pStream);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWMSyncReader_Open_Proxy(
    IWMSyncReader* This,
    const WCHAR *pwszFilename);
void __RPC_STUB IWMSyncReader_Open_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_Close_Proxy(
    IWMSyncReader* This);
void __RPC_STUB IWMSyncReader_Close_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_SetRange_Proxy(
    IWMSyncReader* This,
    QWORD cnsStartTime,
    LONGLONG cnsDuration);
void __RPC_STUB IWMSyncReader_SetRange_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_SetRangeByFrame_Proxy(
    IWMSyncReader* This,
    WORD wStreamNum,
    QWORD qwFrameNumber,
    LONGLONG cFramesToRead);
void __RPC_STUB IWMSyncReader_SetRangeByFrame_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetNextSample_Proxy(
    IWMSyncReader* This,
    WORD wStreamNum,
    INSSBuffer **ppSample,
    QWORD *pcnsSampleTime,
    QWORD *pcnsDuration,
    DWORD *pdwFlags,
    DWORD *pdwOutputNum,
    WORD *pwStreamNum);
void __RPC_STUB IWMSyncReader_GetNextSample_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_SetStreamsSelected_Proxy(
    IWMSyncReader* This,
    WORD cStreamCount,
    WORD *pwStreamNumbers,
    WMT_STREAM_SELECTION *pSelections);
void __RPC_STUB IWMSyncReader_SetStreamsSelected_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetStreamSelected_Proxy(
    IWMSyncReader* This,
    WORD wStreamNum,
    WMT_STREAM_SELECTION *pSelection);
void __RPC_STUB IWMSyncReader_GetStreamSelected_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_SetReadStreamSamples_Proxy(
    IWMSyncReader* This,
    WORD wStreamNum,
    WINBOOL fCompressed);
void __RPC_STUB IWMSyncReader_SetReadStreamSamples_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetReadStreamSamples_Proxy(
    IWMSyncReader* This,
    WORD wStreamNum,
    WINBOOL *pfCompressed);
void __RPC_STUB IWMSyncReader_GetReadStreamSamples_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputSetting_Proxy(
    IWMSyncReader* This,
    DWORD dwOutputNum,
    LPCWSTR pszName,
    WMT_ATTR_DATATYPE *pType,
    BYTE *pValue,
    WORD *pcbLength);
void __RPC_STUB IWMSyncReader_GetOutputSetting_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_SetOutputSetting_Proxy(
    IWMSyncReader* This,
    DWORD dwOutputNum,
    LPCWSTR pszName,
    WMT_ATTR_DATATYPE Type,
    const BYTE *pValue,
    WORD cbLength);
void __RPC_STUB IWMSyncReader_SetOutputSetting_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputCount_Proxy(
    IWMSyncReader* This,
    DWORD *pcOutputs);
void __RPC_STUB IWMSyncReader_GetOutputCount_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputProps_Proxy(
    IWMSyncReader* This,
    DWORD dwOutputNum,
    IWMOutputMediaProps **ppOutput);
void __RPC_STUB IWMSyncReader_GetOutputProps_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_SetOutputProps_Proxy(
    IWMSyncReader* This,
    DWORD dwOutputNum,
    IWMOutputMediaProps *pOutput);
void __RPC_STUB IWMSyncReader_SetOutputProps_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputFormatCount_Proxy(
    IWMSyncReader* This,
    DWORD dwOutputNum,
    DWORD *pcFormats);
void __RPC_STUB IWMSyncReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputFormat_Proxy(
    IWMSyncReader* This,
    DWORD dwOutputNum,
    DWORD dwFormatNum,
    IWMOutputMediaProps **ppProps);
void __RPC_STUB IWMSyncReader_GetOutputFormat_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputNumberForStream_Proxy(
    IWMSyncReader* This,
    WORD wStreamNum,
    DWORD *pdwOutputNum);
void __RPC_STUB IWMSyncReader_GetOutputNumberForStream_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetStreamNumberForOutput_Proxy(
    IWMSyncReader* This,
    DWORD dwOutputNum,
    WORD *pwStreamNum);
void __RPC_STUB IWMSyncReader_GetStreamNumberForOutput_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetMaxOutputSampleSize_Proxy(
    IWMSyncReader* This,
    DWORD dwOutput,
    DWORD *pcbMax);
void __RPC_STUB IWMSyncReader_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_GetMaxStreamSampleSize_Proxy(
    IWMSyncReader* This,
    WORD wStream,
    DWORD *pcbMax);
void __RPC_STUB IWMSyncReader_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWMSyncReader_OpenStream_Proxy(
    IWMSyncReader* This,
    IStream *pStream);
void __RPC_STUB IWMSyncReader_OpenStream_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWMSyncReader_INTERFACE_DEFINED__ */

EXTERN_GUID(WMMEDIASUBTYPE_Base,   0x00000000,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIATYPE_Video,     0x73646976,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_RGB1,   0xe436eb78,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(WMMEDIASUBTYPE_RGB4,   0xe436eb79,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(WMMEDIASUBTYPE_RGB8,   0xe436eb7a,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(WMMEDIASUBTYPE_RGB565, 0xe436eb7b,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(WMMEDIASUBTYPE_RGB555, 0xe436eb7c,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(WMMEDIASUBTYPE_RGB24,  0xe436eb7d,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(WMMEDIASUBTYPE_RGB32,  0xe436eb7e,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
EXTERN_GUID(WMMEDIASUBTYPE_I420,   0x30323449,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_IYUV,   0x56555949,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_YV12,   0x32315659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_YUY2,   0x32595559,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_P422,   0x32323450,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_UYVY,   0x59565955,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_YVYU,   0x55595659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_YVU9,   0x39555659,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_VIDEOIMAGE, 0x1d4a45f2,0xe5f6,0x4b44,0x83,0x88,0xf0,0xae,0x5c,0x0e,0x0c,0x37);
EXTERN_GUID(WMMEDIASUBTYPE_MP43,   0x3334504d,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_MP4S,   0x5334504d,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_M4S2,   0x3253344d,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMV1,   0x31564d57,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMV2,   0x32564d57,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_MSS1,   0x3153534d,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_MPEG2_VIDEO, 0xe06d8026,0xdb46,0x11cf,0xb4,0xd1,0x00,0x80,0x5f,0x6c,0xbb,0xea);
EXTERN_GUID(WMMEDIATYPE_Audio,     0x73647561,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_PCM,    0x00000001,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_DRM,    0x00000009,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV9,        0x00000162,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMAudio_Lossless, 0x00000163,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_MSS2,   0x3253534d,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMSP1,  0x0000000a,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMSP2,  0x0000000b,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMV3,   0x33564d57,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMVP,   0x50564d57,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WVP2,   0x32505657,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WMVA,   0x41564d57,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
EXTERN_GUID(WMMEDIASUBTYPE_WVC1,   0x31435657,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
/* Begin additional prototypes for all interfaces */


/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __wmsdkidl_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/mingw-w64/include/wnnc.h                                                                  0100644 0000000 0000000 00000005346 12404413016 015463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */

#ifndef _WNNC_
#define _WNNC_

#include <winapifamily.h>

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

#define WNNC_NET_MSNET		0x00010000
#define WNNC_NET_LANMAN		WNNC_NET_SMB
#define WNNC_NET_SMB		0x00020000
#define WNNC_NET_NETWARE	0x00030000
#define WNNC_NET_VINES		0x00040000
#define WNNC_NET_10NET		0x00050000
#define WNNC_NET_LOCUS		0x00060000
#define WNNC_NET_SUN_PC_NFS	0x00070000
#define WNNC_NET_LANSTEP	0x00080000
#define WNNC_NET_9TILES		0x00090000
#define WNNC_NET_LANTASTIC	0x000a0000
#define WNNC_NET_AS400		0x000b0000
#define WNNC_NET_FTP_NFS	0x000c0000
#define WNNC_NET_PATHWORKS	0x000d0000
#define WNNC_NET_LIFENET	0x000e0000
#define WNNC_NET_POWERLAN	0x000f0000
#define WNNC_NET_BWNFS		0x00100000
#define WNNC_NET_COGENT		0x00110000
#define WNNC_NET_FARALLON	0x00120000
#define WNNC_NET_APPLETALK	0x00130000
#define WNNC_NET_INTERGRAPH	0x00140000
#define WNNC_NET_SYMFONET	0x00150000
#define WNNC_NET_CLEARCASE	0x00160000
#define WNNC_NET_FRONTIER	0x00170000
#define WNNC_NET_BMC		0x00180000
#define WNNC_NET_DCE		0x00190000
#define WNNC_NET_AVID		0x001a0000
#define WNNC_NET_DOCUSPACE	0x001b0000
#define WNNC_NET_MANGOSOFT	0x001c0000
#define WNNC_NET_SERNET		0x001d0000
#define WNNC_NET_RIVERFRONT1	0x001e0000
#define WNNC_NET_RIVERFRONT2	0x001f0000
#define WNNC_NET_DECORB		0x00200000
#define WNNC_NET_PROTSTOR	0x00210000
#define WNNC_NET_FJ_REDIR	0x00220000
#define WNNC_NET_DISTINCT	0x00230000
#define WNNC_NET_TWINS		0x00240000
#define WNNC_NET_RDR2SAMPLE	0x00250000
#define WNNC_NET_CSC		0x00260000
#define WNNC_NET_3IN1		0x00270000
#define WNNC_NET_EXTENDNET	0x00290000
#define WNNC_NET_STAC		0x002a0000
#define WNNC_NET_FOXBAT		0x002b0000
#define WNNC_NET_YAHOO		0x002c0000
#define WNNC_NET_EXIFS		0x002d0000
#define WNNC_NET_DAV		0x002e0000
#define WNNC_NET_KNOWARE	0x002f0000
#define WNNC_NET_OBJECT_DIRE	0x00300000
#define WNNC_NET_MASFAX		0x00310000
#define WNNC_NET_HOB_NFS	0x00320000
#define WNNC_NET_SHIVA		0x00330000
#define WNNC_NET_IBMAL		0x00340000
#define WNNC_NET_LOCK		0x00350000
#define WNNC_NET_TERMSRV	0x00360000
#define WNNC_NET_SRT		0x00370000
#define WNNC_NET_QUINCY		0x00380000
#define WNNC_NET_OPENAFS	0x00390000
#define WNNC_NET_AVID1		0x003a0000
#define WNNC_NET_DFS		0x003b0000
#define WNNC_NET_KWNP		0x003c0000
#define WNNC_NET_ZENWORKS	0x003d0000
#define WNNC_NET_DRIVEONWEB	0x003e0000
#define WNNC_NET_VMWARE		0x003f0000
#define WNNC_NET_RSFX		0x00400000
#define WNNC_NET_MFILES		0x00410000
#define WNNC_NET_MS_NFS		0x00420000
#define WNNC_NET_GOOGLE		0x00430000
#define WNNC_NET_NDFS		0x00440000

#define WNNC_CRED_MANAGER   0xffff0000

#endif /* WINAPI_PARTITION_DESKTOP.  */

#endif
                                                                                                                                                                                                                                                                                          usr/share/mingw-w64/include/wow64apiset.h                                                           0100644 0000000 0000000 00000001215 12404413016 016701  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */
#ifndef _WOW64APISET_H_
#define _WOW64APISET_H_

#include <apiset.h>
#include <apisetcconv.h>
#include <minwindef.h>
#include <minwinbase.h>

#ifdef __cplusplus
extern "C" {
#endif

#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)
  WINBASEAPI WINBOOL WINAPI Wow64DisableWow64FsRedirection (PVOID *OldValue);
  WINBASEAPI WINBOOL WINAPI Wow64RevertWow64FsRedirection (PVOID OlValue);
  WINBASEAPI WINBOOL WINAPI IsWow64Process (HANDLE hProcess, PBOOL Wow64Process);
#endif

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/wownt16.h                                                               0100644 0000000 0000000 00000001332 12404413016 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WOWNT16_
#define _WOWNT16_

#ifdef __cplusplus
extern "C" {
#endif

  DWORD WINAPI GetVDMPointer32W(LPVOID vp,UINT fMode);
  DWORD WINAPI LoadLibraryEx32W(LPCSTR lpszLibFile,DWORD hFile,DWORD dwFlags);
  DWORD WINAPI GetProcAddress32W(DWORD hModule,LPCSTR lpszProc);
  DWORD WINAPI FreeLibrary32W(DWORD hLibModule);
  DWORD CDECL CallProcEx32W(DWORD,DWORD,DWORD,...);

#define CPEX_DEST_STDCALL __MSABI_LONG(0x00000000)
#define CPEX_DEST_CDECL __MSABI_LONG(0x80000000)

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                      usr/share/mingw-w64/include/wownt32.h                                                               0100644 0000000 0000000 00000006410 12404413016 016032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WOWNT32_
#define _WOWNT32_

LPVOID WINAPI WOWGetVDMPointer(DWORD vp,DWORD dwBytes,WINBOOL fProtectedMode);
LPVOID WINAPI WOWGetVDMPointerFix(DWORD vp,DWORD dwBytes,WINBOOL fProtectedMode);
VOID WINAPI WOWGetVDMPointerUnfix(DWORD vp);
WORD WINAPI WOWGlobalAlloc16(WORD wFlags,DWORD cb);
WORD WINAPI WOWGlobalFree16(WORD hMem);
DWORD WINAPI WOWGlobalLock16(WORD hMem);
WINBOOL WINAPI WOWGlobalUnlock16(WORD hMem);
DWORD WINAPI WOWGlobalAllocLock16(WORD wFlags,DWORD cb,WORD *phMem);
WORD WINAPI WOWGlobalUnlockFree16(DWORD vpMem);
DWORD WINAPI WOWGlobalLockSize16(WORD hMem,PDWORD pcb);
VOID WINAPI WOWYield16(VOID);
VOID WINAPI WOWDirectedYield16(WORD htask16);

typedef enum _WOW_HANDLE_TYPE {
  WOW_TYPE_HWND,WOW_TYPE_HMENU,WOW_TYPE_HDWP,WOW_TYPE_HDROP,WOW_TYPE_HDC,WOW_TYPE_HFONT,WOW_TYPE_HMETAFILE,WOW_TYPE_HRGN,WOW_TYPE_HBITMAP,
  WOW_TYPE_HBRUSH,WOW_TYPE_HPALETTE,WOW_TYPE_HPEN,WOW_TYPE_HACCEL,WOW_TYPE_HTASK,WOW_TYPE_FULLHWND
} WOW_HANDLE_TYPE;

HANDLE WINAPI WOWHandle32 (WORD,WOW_HANDLE_TYPE);
WORD WINAPI WOWHandle16 (HANDLE,WOW_HANDLE_TYPE);

#define HWND_32(h16) ((HWND) (WOWHandle32(h16,WOW_TYPE_HWND)))
#define HMENU_32(h16) ((HMENU) (WOWHandle32(h16,WOW_TYPE_HMENU)))
#define HDWP_32(h16) ((HDWP) (WOWHandle32(h16,WOW_TYPE_HDWP)))
#define HDROP_32(h16) ((HDROP) (WOWHandle32(h16,WOW_TYPE_HDROP)))
#define HDC_32(h16) ((HDC) (WOWHandle32(h16,WOW_TYPE_HDC)))
#define HFONT_32(h16) ((HFONT) (WOWHandle32(h16,WOW_TYPE_HFONT)))
#define HMETAFILE_32(h16) ((HMETAFILE) (WOWHandle32(h16,WOW_TYPE_HMETAFILE)))
#define HRGN_32(h16) ((HRGN) (WOWHandle32(h16,WOW_TYPE_HRGN)))
#define HBITMAP_32(h16) ((HBITMAP) (WOWHandle32(h16,WOW_TYPE_HBITMAP)))
#define HBRUSH_32(h16) ((HBRUSH) (WOWHandle32(h16,WOW_TYPE_HBRUSH)))
#define HPALETTE_32(h16) ((HPALETTE) (WOWHandle32(h16,WOW_TYPE_HPALETTE)))
#define HPEN_32(h16) ((HPEN) (WOWHandle32(h16,WOW_TYPE_HPEN)))
#define HACCEL_32(h16) ((HACCEL) (WOWHandle32(h16,WOW_TYPE_HACCEL)))
#define HTASK_32(h16) ((DWORD) (WOWHandle32(h16,WOW_TYPE_HTASK)))
#define FULLHWND_32(h16) ((HWND) (WOWHandle32(h16,WOW_TYPE_FULLHWND)))

#define HWND_16(h32) (WOWHandle16(h32,WOW_TYPE_HWND))
#define HMENU_16(h32) (WOWHandle16(h32,WOW_TYPE_HMENU))
#define HDWP_16(h32) (WOWHandle16(h32,WOW_TYPE_HDWP))
#define HDROP_16(h32) (WOWHandle16(h32,WOW_TYPE_HDROP))
#define HDC_16(h32) (WOWHandle16(h32,WOW_TYPE_HDC))
#define HFONT_16(h32) (WOWHandle16(h32,WOW_TYPE_HFONT))
#define HMETAFILE_16(h32) (WOWHandle16(h32,WOW_TYPE_HMETAFILE))
#define HRGN_16(h32) (WOWHandle16(h32,WOW_TYPE_HRGN))
#define HBITMAP_16(h32) (WOWHandle16(h32,WOW_TYPE_HBITMAP))
#define HBRUSH_16(h32) (WOWHandle16(h32,WOW_TYPE_HBRUSH))
#define HPALETTE_16(h32) (WOWHandle16(h32,WOW_TYPE_HPALETTE))
#define HPEN_16(h32) (WOWHandle16(h32,WOW_TYPE_HPEN))
#define HACCEL_16(h32) (WOWHandle16(h32,WOW_TYPE_HACCEL))
#define HTASK_16(h32) (WOWHandle16(h32,WOW_TYPE_HTASK))

DWORD WINAPI WOWCallback16(DWORD vpfn16,DWORD dwParam);

#define WCB16_MAX_CBARGS (16)

#define WCB16_PASCAL (0x0)
#define WCB16_CDECL (0x1)

WINBOOL WINAPI WOWCallback16Ex(DWORD vpfn16,DWORD dwFlags,DWORD cbArgs,PVOID pArgs,PDWORD pdwRetCode);
#endif
                                                                                                                                                                                                                                                        usr/share/mingw-w64/include/wpapi.h                                                                 0100644 0000000 0000000 00000006437 12404413016 015640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __WP15API_H__
#define __WP15API_H__

#include <_mingw_unicode.h>
#include <windows.h>
#include "wptypes.h"

#include <pshpack4.h>

#define WPF_NO_RECURSIVE_POST 0x00000001
#define WPF_NO_WIZARD 0x00000002
#define WPF_MINIMAL_UI 0x00000004
#define WPF_FIRST_FILE_AS_DEFAULT 0x00000008
#define WPF_NO_DIRECT_LOOKUP 0x00000010
#define WPF_NO_URL_LOOKUP 0x00000020
#define WPF_USE_PROVIDER_PASSED 0x00000040
#define WPF_NO_VERIFY_POST 0x00000080
#define WPF_NO_PROGRESS_DLGS 0x00000200
#define WPF_SHOWPAGE_WELCOME 0x00010000
#define WPF_SHOWPAGE_SRCFILE 0x00020000
#define WPF_SHOWPAGE_DESTSITE 0x00040000
#define WPF_SHOWPAGE_PROVIDER 0x00080000
#define WPF_ENABLE_LOCAL_BASE_DIR 0x00100000
#define WPF_NO_UI WPF_NO_WIZARD | WPF_NO_PROGRESS_DLGS
#define WPF_SHOWPAGE_ALL WPF_SHOWPAGE_WELCOME | WPF_SHOWPAGE_SRCFILE | WPF_SHOWPAGE_DESTSITE | WPF_SHOWPAGE_PROVIDER

#define MAX_SITENAME_LEN 128

#ifdef __cplusplus
extern "C" {
#endif

  DWORD WINAPI WpPostW(HWND hwnd,DWORD dwNumLocalPaths,LPWSTR *pwsLocalPaths,LPDWORD pdwSiteNameBufLen,LPWSTR wsSiteName,LPDWORD pdwDestURLBufLen,LPWSTR wsDestURL,DWORD dwFlag);
  DWORD WINAPI WpListSitesW(LPDWORD pdwSitesBufLen,LPWPSITEINFOW pSitesBuffer,LPDWORD pdwNumSites);
  DWORD WINAPI WpDoesSiteExistW(LPCWSTR wsSiteName,WINBOOL *pfSiteExists);
  DWORD WINAPI WpDeleteSiteW(LPCWSTR wsSiteName);
  DWORD WINAPI WpBindToSiteW(HWND hwnd,LPCWSTR wsSiteName,LPCWSTR wsSitePostingURL,DWORD dwFlag,DWORD dwReserved,PVOID *ppvUnk);
  DWORD WINAPI WpCreateSiteW(LPCWSTR wsSiteName,LPCWSTR wsSiteLocalBaseDir,LPCWSTR wsSitePostingURL,LPCWSTR wsProviderCLSID,DWORD dwFlags);
  DWORD WINAPI WpEnumProvidersW(LPDWORD pdwProvidersBufLen,LPWPPROVINFOW pProvidersBuffer,LPDWORD pdwNumProviders);
  DWORD WINAPI WpGetErrorStringW(UINT uErrCode,LPWSTR wsOutputBuf,LPDWORD pdwBufLen);
  DWORD WINAPI WpPostA(HWND hwnd,DWORD dwNumLocalPaths,LPSTR *psLocalPaths,LPDWORD pdwSiteNameBufLen,LPSTR sSiteName,LPDWORD pdwDestURLBufLen,LPSTR sDestURLBufLen,DWORD dwFlag);
  DWORD WINAPI WpListSitesA(LPDWORD pdwSitesBufLen,LPWPSITEINFOA pSitesBuffer,LPDWORD pdwNumSites);
  DWORD WINAPI WpDoesSiteExistA(LPCSTR sSiteName,WINBOOL *pfSiteExists);
  DWORD WINAPI WpDeleteSiteA(LPCSTR sSiteName);
  DWORD WINAPI WpBindToSiteA(HWND hwnd,LPCSTR sSiteName,LPCSTR sSitePostingURL,DWORD dwFlag,DWORD dwReserved,PVOID *ppvUnk);
  DWORD WINAPI WpCreateSiteA(LPCSTR sSiteName,LPCSTR sSiteLocalBaseDir,LPCSTR sSitePostingURL,LPCSTR sProviderCLSID,DWORD dwFlags);
  DWORD WINAPI WpEnumProvidersA(LPDWORD pdwProvidersBufLen,LPWPPROVINFOA pProvidersBuffer,LPDWORD pdwNumProviders);
  DWORD WINAPI WpGetErrorStringA(UINT uErrCode,LPSTR sOutputBuf,LPDWORD pdwBufLen);

#ifdef __cplusplus
}
#endif

#define WpPost __MINGW_NAME_AW(WpPost)
#define WpListSites __MINGW_NAME_AW(WpListSites)
#define WpDoesSiteExist __MINGW_NAME_AW(WpDoesSiteExist)
#define WpDeleteSite __MINGW_NAME_AW(WpDeleteSite)
#define WpBindToSite __MINGW_NAME_AW(WpBindToSite)
#define WpCreateSite __MINGW_NAME_AW(WpCreateSite)
#define WpEnumProviders __MINGW_NAME_AW(WpEnumProviders)
#define WpGetErrorString __MINGW_NAME_AW(WpGetErrorString)

#include <poppack.h>
#endif
                                                                                                                                                                                                                                 usr/share/mingw-w64/include/wpapimsg.h                                                              0100644 0000000 0000000 00000003450 12404413016 016337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#define WEBPOST_ERROR_FIRST __MSABI_LONG(0x40042100)
#define WEBPOST_ERROR_UNKNOWN __MSABI_LONG(0xC0042101)
#define WEBPOST_ERROR_PROVCLSID_UNKNOWN __MSABI_LONG(0xC0042102)
#define WEBPOST_ERROR_SITE_CORRUPT __MSABI_LONG(0xC0042103)
#define WEBPOST_ERROR_PROV_CORRUPT __MSABI_LONG(0xC0042104)
#define WEBPOST_ERROR_PROV_DLL __MSABI_LONG(0xC0042105)
#define WEBPOST_ERROR_PROV_EP __MSABI_LONG(0xC0042106)
#define WEBPOST_ERROR_INIT_FAILED __MSABI_LONG(0xC0042107)
#define WEBPOST_ERROR_LIST_SITES __MSABI_LONG(0xC0042108)
#define WEBPOST_ERROR_SITE_EXISTS __MSABI_LONG(0xC0042109)
#define WEBPOST_ERROR_CREATE_SITE __MSABI_LONG(0xC004210A)
#define WEBPOST_ERROR_SITE_DOESNOTEXIST __MSABI_LONG(0xC004210B)
#define WEBPOST_ERROR_DELETE_SITE __MSABI_LONG(0xC004210C)
#define WEBPOST_ERROR_ENUM_PROVS __MSABI_LONG(0xC004210D)
#define WEBPOST_ERROR_PROV_QI __MSABI_LONG(0xC004210E)
#define WEBPOST_ERROR_POST_FILES __MSABI_LONG(0xC004210F)
#define WEBPOST_ERROR_COCREATE_WIZARD __MSABI_LONG(0xC0042110)
#define WEBPOST_ERROR_POSTINFO_REQUIRED __MSABI_LONG(0xC0042111)
#define WEBPOST_ERROR_AUTOBIND_FAILED __MSABI_LONG(0xC0042112)
#define WEBPOST_ERROR_BAD_PROV_PTR __MSABI_LONG(0xC0042113)
#define WEBPOST_ERROR_PROV_NOT_IN_POSTINFO __MSABI_LONG(0x80042114)
#define WEBPOST_ERROR_EXTENDED_ERROR __MSABI_LONG(0xC0042116)
#define WEBPOST_ERROR_NO_EXT_ERR_INFO __MSABI_LONG(0xC0042117)
#define WEBPOST_ERROR_INVALID_POSTINFO __MSABI_LONG(0x40042118)
#define WEBPOST_ERROR_NO_POSTINFO __MSABI_LONG(0x40042119)
#define WEBPOST_ERROR_HTTP_GET_FAILED __MSABI_LONG(0x4004211A)
#define WEBPOST_ERROR_LAST __MSABI_LONG(0x400421FF)
                                                                                                                                                                                                                        usr/share/mingw-w64/include/wpcapi.h                                                                0100644 0000000 0000000 00000065170 12404413016 016002  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*** Autogenerated by WIDL 1.6 from include/wpcapi.idl - Do not edit ***/

#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __wpcapi_h__
#define __wpcapi_h__

/* Forward declarations */

#ifndef __IWPCSettings_FWD_DEFINED__
#define __IWPCSettings_FWD_DEFINED__
typedef interface IWPCSettings IWPCSettings;
#endif

#ifndef __IWPCGamesSettings_FWD_DEFINED__
#define __IWPCGamesSettings_FWD_DEFINED__
typedef interface IWPCGamesSettings IWPCGamesSettings;
#endif

#ifndef __IWPCWebSettings_FWD_DEFINED__
#define __IWPCWebSettings_FWD_DEFINED__
typedef interface IWPCWebSettings IWPCWebSettings;
#endif

#ifndef __IWindowsParentalControlsCore_FWD_DEFINED__
#define __IWindowsParentalControlsCore_FWD_DEFINED__
typedef interface IWindowsParentalControlsCore IWindowsParentalControlsCore;
#endif

#ifndef __IWindowsParentalControls_FWD_DEFINED__
#define __IWindowsParentalControls_FWD_DEFINED__
typedef interface IWindowsParentalControls IWindowsParentalControls;
#endif

/* Headers for imported files */

#include <oaidl.h>
#include <ocidl.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************
 * IWPCSettings interface
 */
#ifndef __IWPCSettings_INTERFACE_DEFINED__
#define __IWPCSettings_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWPCSettings, 0x8fdf6ca1, 0x0189, 0x47e4, 0xb6,0x70, 0x1a,0x8a,0x46,0x36,0xe3,0x40);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("8fdf6ca1-0189-47e4-b670-1a8a4636e340")
IWPCSettings : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE IsLoggingRequired(
        WINBOOL *pfRequired) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetLastSettingsChangeTime(
        SYSTEMTIME *pTime) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetRestrictions(
        DWORD *pdwRestrictions) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWPCSettings, 0x8fdf6ca1, 0x0189, 0x47e4, 0xb6,0x70, 0x1a,0x8a,0x46,0x36,0xe3,0x40)
#endif
#else
typedef struct IWPCSettingsVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWPCSettings* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWPCSettings* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWPCSettings* This);

    /*** IWPCSettings methods ***/
    HRESULT (STDMETHODCALLTYPE *IsLoggingRequired)(
        IWPCSettings* This,
        WINBOOL *pfRequired);

    HRESULT (STDMETHODCALLTYPE *GetLastSettingsChangeTime)(
        IWPCSettings* This,
        SYSTEMTIME *pTime);

    HRESULT (STDMETHODCALLTYPE *GetRestrictions)(
        IWPCSettings* This,
        DWORD *pdwRestrictions);

    END_INTERFACE
} IWPCSettingsVtbl;
interface IWPCSettings {
    CONST_VTBL IWPCSettingsVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWPCSettings_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWPCSettings_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWPCSettings_Release(This) (This)->lpVtbl->Release(This)
/*** IWPCSettings methods ***/
#define IWPCSettings_IsLoggingRequired(This,pfRequired) (This)->lpVtbl->IsLoggingRequired(This,pfRequired)
#define IWPCSettings_GetLastSettingsChangeTime(This,pTime) (This)->lpVtbl->GetLastSettingsChangeTime(This,pTime)
#define IWPCSettings_GetRestrictions(This,pdwRestrictions) (This)->lpVtbl->GetRestrictions(This,pdwRestrictions)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWPCSettings_QueryInterface(IWPCSettings* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWPCSettings_AddRef(IWPCSettings* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWPCSettings_Release(IWPCSettings* This) {
    return This->lpVtbl->Release(This);
}
/*** IWPCSettings methods ***/
static FORCEINLINE HRESULT IWPCSettings_IsLoggingRequired(IWPCSettings* This,WINBOOL *pfRequired) {
    return This->lpVtbl->IsLoggingRequired(This,pfRequired);
}
static FORCEINLINE HRESULT IWPCSettings_GetLastSettingsChangeTime(IWPCSettings* This,SYSTEMTIME *pTime) {
    return This->lpVtbl->GetLastSettingsChangeTime(This,pTime);
}
static FORCEINLINE HRESULT IWPCSettings_GetRestrictions(IWPCSettings* This,DWORD *pdwRestrictions) {
    return This->lpVtbl->GetRestrictions(This,pdwRestrictions);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWPCSettings_IsLoggingRequired_Proxy(
    IWPCSettings* This,
    WINBOOL *pfRequired);
void __RPC_STUB IWPCSettings_IsLoggingRequired_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWPCSettings_GetLastSettingsChangeTime_Proxy(
    IWPCSettings* This,
    SYSTEMTIME *pTime);
void __RPC_STUB IWPCSettings_GetLastSettingsChangeTime_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWPCSettings_GetRestrictions_Proxy(
    IWPCSettings* This,
    DWORD *pdwRestrictions);
void __RPC_STUB IWPCSettings_GetRestrictions_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWPCSettings_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWPCGamesSettings interface
 */
#ifndef __IWPCGamesSettings_INTERFACE_DEFINED__
#define __IWPCGamesSettings_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWPCGamesSettings, 0x95e87780, 0xe158, 0x489e, 0xb4,0x52, 0xbb,0xb8,0x50,0x79,0x07,0x15);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("95e87780-e158-489e-b452-bbb850790715")
IWPCGamesSettings : public IWPCSettings
{
    virtual HRESULT STDMETHODCALLTYPE IsBlocked(
        GUID guidAppID,
        DWORD *pdwReasons) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWPCGamesSettings, 0x95e87780, 0xe158, 0x489e, 0xb4,0x52, 0xbb,0xb8,0x50,0x79,0x07,0x15)
#endif
#else
typedef struct IWPCGamesSettingsVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWPCGamesSettings* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWPCGamesSettings* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWPCGamesSettings* This);

    /*** IWPCSettings methods ***/
    HRESULT (STDMETHODCALLTYPE *IsLoggingRequired)(
        IWPCGamesSettings* This,
        WINBOOL *pfRequired);

    HRESULT (STDMETHODCALLTYPE *GetLastSettingsChangeTime)(
        IWPCGamesSettings* This,
        SYSTEMTIME *pTime);

    HRESULT (STDMETHODCALLTYPE *GetRestrictions)(
        IWPCGamesSettings* This,
        DWORD *pdwRestrictions);

    /*** IWPCGamesSettings methods ***/
    HRESULT (STDMETHODCALLTYPE *IsBlocked)(
        IWPCGamesSettings* This,
        GUID guidAppID,
        DWORD *pdwReasons);

    END_INTERFACE
} IWPCGamesSettingsVtbl;
interface IWPCGamesSettings {
    CONST_VTBL IWPCGamesSettingsVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWPCGamesSettings_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWPCGamesSettings_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWPCGamesSettings_Release(This) (This)->lpVtbl->Release(This)
/*** IWPCSettings methods ***/
#define IWPCGamesSettings_IsLoggingRequired(This,pfRequired) (This)->lpVtbl->IsLoggingRequired(This,pfRequired)
#define IWPCGamesSettings_GetLastSettingsChangeTime(This,pTime) (This)->lpVtbl->GetLastSettingsChangeTime(This,pTime)
#define IWPCGamesSettings_GetRestrictions(This,pdwRestrictions) (This)->lpVtbl->GetRestrictions(This,pdwRestrictions)
/*** IWPCGamesSettings methods ***/
#define IWPCGamesSettings_IsBlocked(This,guidAppID,pdwReasons) (This)->lpVtbl->IsBlocked(This,guidAppID,pdwReasons)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWPCGamesSettings_QueryInterface(IWPCGamesSettings* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWPCGamesSettings_AddRef(IWPCGamesSettings* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWPCGamesSettings_Release(IWPCGamesSettings* This) {
    return This->lpVtbl->Release(This);
}
/*** IWPCSettings methods ***/
static FORCEINLINE HRESULT IWPCGamesSettings_IsLoggingRequired(IWPCGamesSettings* This,WINBOOL *pfRequired) {
    return This->lpVtbl->IsLoggingRequired(This,pfRequired);
}
static FORCEINLINE HRESULT IWPCGamesSettings_GetLastSettingsChangeTime(IWPCGamesSettings* This,SYSTEMTIME *pTime) {
    return This->lpVtbl->GetLastSettingsChangeTime(This,pTime);
}
static FORCEINLINE HRESULT IWPCGamesSettings_GetRestrictions(IWPCGamesSettings* This,DWORD *pdwRestrictions) {
    return This->lpVtbl->GetRestrictions(This,pdwRestrictions);
}
/*** IWPCGamesSettings methods ***/
static FORCEINLINE HRESULT IWPCGamesSettings_IsBlocked(IWPCGamesSettings* This,GUID guidAppID,DWORD *pdwReasons) {
    return This->lpVtbl->IsBlocked(This,guidAppID,pdwReasons);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWPCGamesSettings_IsBlocked_Proxy(
    IWPCGamesSettings* This,
    GUID guidAppID,
    DWORD *pdwReasons);
void __RPC_STUB IWPCGamesSettings_IsBlocked_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWPCGamesSettings_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWPCWebSettings interface
 */
#ifndef __IWPCWebSettings_INTERFACE_DEFINED__
#define __IWPCWebSettings_INTERFACE_DEFINED__

typedef enum tagWPCFLAG_WEB_SETTING {
    WPCFLAG_WEB_SETTING_NOTBLOCKED = 0,
    WPCFLAG_WEB_SETTING_DOWNLOADSBLOCKED = 1
} WPCFLAG_WEB_SETTING;
DEFINE_GUID(IID_IWPCWebSettings, 0xffccbdb8, 0x0992, 0x4c30, 0xb0,0xf1, 0x1c,0xbb,0x09,0xc2,0x40,0xaa);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("ffccbdb8-0992-4c30-b0f1-1cbb09c240aa")
IWPCWebSettings : public IWPCSettings
{
    virtual HRESULT STDMETHODCALLTYPE GetSettings(
        DWORD *pdwSettings) = 0;

    virtual HRESULT STDMETHODCALLTYPE RequestURLOverride(
        HWND hWnd,
        LPCWSTR pcszURL,
        DWORD cURLs,
        LPCWSTR *ppcszSubURLs,
        WINBOOL *pfChanged) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWPCWebSettings, 0xffccbdb8, 0x0992, 0x4c30, 0xb0,0xf1, 0x1c,0xbb,0x09,0xc2,0x40,0xaa)
#endif
#else
typedef struct IWPCWebSettingsVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWPCWebSettings* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWPCWebSettings* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWPCWebSettings* This);

    /*** IWPCSettings methods ***/
    HRESULT (STDMETHODCALLTYPE *IsLoggingRequired)(
        IWPCWebSettings* This,
        WINBOOL *pfRequired);

    HRESULT (STDMETHODCALLTYPE *GetLastSettingsChangeTime)(
        IWPCWebSettings* This,
        SYSTEMTIME *pTime);

    HRESULT (STDMETHODCALLTYPE *GetRestrictions)(
        IWPCWebSettings* This,
        DWORD *pdwRestrictions);

    /*** IWPCWebSettings methods ***/
    HRESULT (STDMETHODCALLTYPE *GetSettings)(
        IWPCWebSettings* This,
        DWORD *pdwSettings);

    HRESULT (STDMETHODCALLTYPE *RequestURLOverride)(
        IWPCWebSettings* This,
        HWND hWnd,
        LPCWSTR pcszURL,
        DWORD cURLs,
        LPCWSTR *ppcszSubURLs,
        WINBOOL *pfChanged);

    END_INTERFACE
} IWPCWebSettingsVtbl;
interface IWPCWebSettings {
    CONST_VTBL IWPCWebSettingsVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWPCWebSettings_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWPCWebSettings_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWPCWebSettings_Release(This) (This)->lpVtbl->Release(This)
/*** IWPCSettings methods ***/
#define IWPCWebSettings_IsLoggingRequired(This,pfRequired) (This)->lpVtbl->IsLoggingRequired(This,pfRequired)
#define IWPCWebSettings_GetLastSettingsChangeTime(This,pTime) (This)->lpVtbl->GetLastSettingsChangeTime(This,pTime)
#define IWPCWebSettings_GetRestrictions(This,pdwRestrictions) (This)->lpVtbl->GetRestrictions(This,pdwRestrictions)
/*** IWPCWebSettings methods ***/
#define IWPCWebSettings_GetSettings(This,pdwSettings) (This)->lpVtbl->GetSettings(This,pdwSettings)
#define IWPCWebSettings_RequestURLOverride(This,hWnd,pcszURL,cURLs,ppcszSubURLs,pfChanged) (This)->lpVtbl->RequestURLOverride(This,hWnd,pcszURL,cURLs,ppcszSubURLs,pfChanged)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWPCWebSettings_QueryInterface(IWPCWebSettings* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWPCWebSettings_AddRef(IWPCWebSettings* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWPCWebSettings_Release(IWPCWebSettings* This) {
    return This->lpVtbl->Release(This);
}
/*** IWPCSettings methods ***/
static FORCEINLINE HRESULT IWPCWebSettings_IsLoggingRequired(IWPCWebSettings* This,WINBOOL *pfRequired) {
    return This->lpVtbl->IsLoggingRequired(This,pfRequired);
}
static FORCEINLINE HRESULT IWPCWebSettings_GetLastSettingsChangeTime(IWPCWebSettings* This,SYSTEMTIME *pTime) {
    return This->lpVtbl->GetLastSettingsChangeTime(This,pTime);
}
static FORCEINLINE HRESULT IWPCWebSettings_GetRestrictions(IWPCWebSettings* This,DWORD *pdwRestrictions) {
    return This->lpVtbl->GetRestrictions(This,pdwRestrictions);
}
/*** IWPCWebSettings methods ***/
static FORCEINLINE HRESULT IWPCWebSettings_GetSettings(IWPCWebSettings* This,DWORD *pdwSettings) {
    return This->lpVtbl->GetSettings(This,pdwSettings);
}
static FORCEINLINE HRESULT IWPCWebSettings_RequestURLOverride(IWPCWebSettings* This,HWND hWnd,LPCWSTR pcszURL,DWORD cURLs,LPCWSTR *ppcszSubURLs,WINBOOL *pfChanged) {
    return This->lpVtbl->RequestURLOverride(This,hWnd,pcszURL,cURLs,ppcszSubURLs,pfChanged);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWPCWebSettings_GetSettings_Proxy(
    IWPCWebSettings* This,
    DWORD *pdwSettings);
void __RPC_STUB IWPCWebSettings_GetSettings_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWPCWebSettings_RequestURLOverride_Proxy(
    IWPCWebSettings* This,
    HWND hWnd,
    LPCWSTR pcszURL,
    DWORD cURLs,
    LPCWSTR *ppcszSubURLs,
    WINBOOL *pfChanged);
void __RPC_STUB IWPCWebSettings_RequestURLOverride_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWPCWebSettings_INTERFACE_DEFINED__ */

typedef enum tagWPCFLAG_VISIBILITY {
    WPCFLAG_WPC_VISIBLE = 0,
    WPCFLAG_WPC_HIDDEN = 1
} WPCFLAG_VISIBILITY;
/*****************************************************************************
 * IWindowsParentalControlsCore interface
 */
#ifndef __IWindowsParentalControlsCore_INTERFACE_DEFINED__
#define __IWindowsParentalControlsCore_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWindowsParentalControlsCore, 0x4ff40a0f, 0x3f3b, 0x4d7c, 0xa4,0x1b, 0x4f,0x39,0xd7,0xb4,0x4d,0x05);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("4ff40a0f-3f3b-4d7c-a41b-4f39d7b44d05")
IWindowsParentalControlsCore : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetVisibility(
        WPCFLAG_VISIBILITY *peVisibility) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetUserSettings(
        LPCWSTR pcszSID,
        IWPCSettings **ppSettings) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetWebSettings(
        LPCWSTR pcszSID,
        IWPCWebSettings **ppSettings) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetWebFilterInfo(
        GUID *pguidID,
        LPWSTR *ppszName) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWindowsParentalControlsCore, 0x4ff40a0f, 0x3f3b, 0x4d7c, 0xa4,0x1b, 0x4f,0x39,0xd7,0xb4,0x4d,0x05)
#endif
#else
typedef struct IWindowsParentalControlsCoreVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWindowsParentalControlsCore* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWindowsParentalControlsCore* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWindowsParentalControlsCore* This);

    /*** IWindowsParentalControlsCore methods ***/
    HRESULT (STDMETHODCALLTYPE *GetVisibility)(
        IWindowsParentalControlsCore* This,
        WPCFLAG_VISIBILITY *peVisibility);

    HRESULT (STDMETHODCALLTYPE *GetUserSettings)(
        IWindowsParentalControlsCore* This,
        LPCWSTR pcszSID,
        IWPCSettings **ppSettings);

    HRESULT (STDMETHODCALLTYPE *GetWebSettings)(
        IWindowsParentalControlsCore* This,
        LPCWSTR pcszSID,
        IWPCWebSettings **ppSettings);

    HRESULT (STDMETHODCALLTYPE *GetWebFilterInfo)(
        IWindowsParentalControlsCore* This,
        GUID *pguidID,
        LPWSTR *ppszName);

    END_INTERFACE
} IWindowsParentalControlsCoreVtbl;
interface IWindowsParentalControlsCore {
    CONST_VTBL IWindowsParentalControlsCoreVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWindowsParentalControlsCore_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWindowsParentalControlsCore_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWindowsParentalControlsCore_Release(This) (This)->lpVtbl->Release(This)
/*** IWindowsParentalControlsCore methods ***/
#define IWindowsParentalControlsCore_GetVisibility(This,peVisibility) (This)->lpVtbl->GetVisibility(This,peVisibility)
#define IWindowsParentalControlsCore_GetUserSettings(This,pcszSID,ppSettings) (This)->lpVtbl->GetUserSettings(This,pcszSID,ppSettings)
#define IWindowsParentalControlsCore_GetWebSettings(This,pcszSID,ppSettings) (This)->lpVtbl->GetWebSettings(This,pcszSID,ppSettings)
#define IWindowsParentalControlsCore_GetWebFilterInfo(This,pguidID,ppszName) (This)->lpVtbl->GetWebFilterInfo(This,pguidID,ppszName)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWindowsParentalControlsCore_QueryInterface(IWindowsParentalControlsCore* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWindowsParentalControlsCore_AddRef(IWindowsParentalControlsCore* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWindowsParentalControlsCore_Release(IWindowsParentalControlsCore* This) {
    return This->lpVtbl->Release(This);
}
/*** IWindowsParentalControlsCore methods ***/
static FORCEINLINE HRESULT IWindowsParentalControlsCore_GetVisibility(IWindowsParentalControlsCore* This,WPCFLAG_VISIBILITY *peVisibility) {
    return This->lpVtbl->GetVisibility(This,peVisibility);
}
static FORCEINLINE HRESULT IWindowsParentalControlsCore_GetUserSettings(IWindowsParentalControlsCore* This,LPCWSTR pcszSID,IWPCSettings **ppSettings) {
    return This->lpVtbl->GetUserSettings(This,pcszSID,ppSettings);
}
static FORCEINLINE HRESULT IWindowsParentalControlsCore_GetWebSettings(IWindowsParentalControlsCore* This,LPCWSTR pcszSID,IWPCWebSettings **ppSettings) {
    return This->lpVtbl->GetWebSettings(This,pcszSID,ppSettings);
}
static FORCEINLINE HRESULT IWindowsParentalControlsCore_GetWebFilterInfo(IWindowsParentalControlsCore* This,GUID *pguidID,LPWSTR *ppszName) {
    return This->lpVtbl->GetWebFilterInfo(This,pguidID,ppszName);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWindowsParentalControlsCore_GetVisibility_Proxy(
    IWindowsParentalControlsCore* This,
    WPCFLAG_VISIBILITY *peVisibility);
void __RPC_STUB IWindowsParentalControlsCore_GetVisibility_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWindowsParentalControlsCore_GetUserSettings_Proxy(
    IWindowsParentalControlsCore* This,
    LPCWSTR pcszSID,
    IWPCSettings **ppSettings);
void __RPC_STUB IWindowsParentalControlsCore_GetUserSettings_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWindowsParentalControlsCore_GetWebSettings_Proxy(
    IWindowsParentalControlsCore* This,
    LPCWSTR pcszSID,
    IWPCWebSettings **ppSettings);
void __RPC_STUB IWindowsParentalControlsCore_GetWebSettings_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IWindowsParentalControlsCore_GetWebFilterInfo_Proxy(
    IWindowsParentalControlsCore* This,
    GUID *pguidID,
    LPWSTR *ppszName);
void __RPC_STUB IWindowsParentalControlsCore_GetWebFilterInfo_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWindowsParentalControlsCore_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IWindowsParentalControls interface
 */
#ifndef __IWindowsParentalControls_INTERFACE_DEFINED__
#define __IWindowsParentalControls_INTERFACE_DEFINED__

DEFINE_GUID(IID_IWindowsParentalControls, 0x4ff40a0f, 0x3f3b, 0x4d7c, 0xa4,0x1b, 0x4f,0x39,0xd7,0xb4,0x4d,0x05);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("4ff40a0f-3f3b-4d7c-a41b-4f39d7b44d05")
IWindowsParentalControls : public IWindowsParentalControlsCore
{
    virtual HRESULT STDMETHODCALLTYPE GetGamesSettings(
        LPCWSTR pcszSID,
        IWPCGamesSettings **ppSettings) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IWindowsParentalControls, 0x4ff40a0f, 0x3f3b, 0x4d7c, 0xa4,0x1b, 0x4f,0x39,0xd7,0xb4,0x4d,0x05)
#endif
#else
typedef struct IWindowsParentalControlsVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IWindowsParentalControls* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IWindowsParentalControls* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IWindowsParentalControls* This);

    /*** IWindowsParentalControlsCore methods ***/
    HRESULT (STDMETHODCALLTYPE *GetVisibility)(
        IWindowsParentalControls* This,
        WPCFLAG_VISIBILITY *peVisibility);

    HRESULT (STDMETHODCALLTYPE *GetUserSettings)(
        IWindowsParentalControls* This,
        LPCWSTR pcszSID,
        IWPCSettings **ppSettings);

    HRESULT (STDMETHODCALLTYPE *GetWebSettings)(
        IWindowsParentalControls* This,
        LPCWSTR pcszSID,
        IWPCWebSettings **ppSettings);

    HRESULT (STDMETHODCALLTYPE *GetWebFilterInfo)(
        IWindowsParentalControls* This,
        GUID *pguidID,
        LPWSTR *ppszName);

    /*** IWindowsParentalControls methods ***/
    HRESULT (STDMETHODCALLTYPE *GetGamesSettings)(
        IWindowsParentalControls* This,
        LPCWSTR pcszSID,
        IWPCGamesSettings **ppSettings);

    END_INTERFACE
} IWindowsParentalControlsVtbl;
interface IWindowsParentalControls {
    CONST_VTBL IWindowsParentalControlsVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IWindowsParentalControls_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWindowsParentalControls_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWindowsParentalControls_Release(This) (This)->lpVtbl->Release(This)
/*** IWindowsParentalControlsCore methods ***/
#define IWindowsParentalControls_GetVisibility(This,peVisibility) (This)->lpVtbl->GetVisibility(This,peVisibility)
#define IWindowsParentalControls_GetUserSettings(This,pcszSID,ppSettings) (This)->lpVtbl->GetUserSettings(This,pcszSID,ppSettings)
#define IWindowsParentalControls_GetWebSettings(This,pcszSID,ppSettings) (This)->lpVtbl->GetWebSettings(This,pcszSID,ppSettings)
#define IWindowsParentalControls_GetWebFilterInfo(This,pguidID,ppszName) (This)->lpVtbl->GetWebFilterInfo(This,pguidID,ppszName)
/*** IWindowsParentalControls methods ***/
#define IWindowsParentalControls_GetGamesSettings(This,pcszSID,ppSettings) (This)->lpVtbl->GetGamesSettings(This,pcszSID,ppSettings)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IWindowsParentalControls_QueryInterface(IWindowsParentalControls* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IWindowsParentalControls_AddRef(IWindowsParentalControls* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IWindowsParentalControls_Release(IWindowsParentalControls* This) {
    return This->lpVtbl->Release(This);
}
/*** IWindowsParentalControlsCore methods ***/
static FORCEINLINE HRESULT IWindowsParentalControls_GetVisibility(IWindowsParentalControls* This,WPCFLAG_VISIBILITY *peVisibility) {
    return This->lpVtbl->GetVisibility(This,peVisibility);
}
static FORCEINLINE HRESULT IWindowsParentalControls_GetUserSettings(IWindowsParentalControls* This,LPCWSTR pcszSID,IWPCSettings **ppSettings) {
    return This->lpVtbl->GetUserSettings(This,pcszSID,ppSettings);
}
static FORCEINLINE HRESULT IWindowsParentalControls_GetWebSettings(IWindowsParentalControls* This,LPCWSTR pcszSID,IWPCWebSettings **ppSettings) {
    return This->lpVtbl->GetWebSettings(This,pcszSID,ppSettings);
}
static FORCEINLINE HRESULT IWindowsParentalControls_GetWebFilterInfo(IWindowsParentalControls* This,GUID *pguidID,LPWSTR *ppszName) {
    return This->lpVtbl->GetWebFilterInfo(This,pguidID,ppszName);
}
/*** IWindowsParentalControls methods ***/
static FORCEINLINE HRESULT IWindowsParentalControls_GetGamesSettings(IWindowsParentalControls* This,LPCWSTR pcszSID,IWPCGamesSettings **ppSettings) {
    return This->lpVtbl->GetGamesSettings(This,pcszSID,ppSettings);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IWindowsParentalControls_GetGamesSettings_Proxy(
    IWindowsParentalControls* This,
    LPCWSTR pcszSID,
    IWPCGamesSettings **ppSettings);
void __RPC_STUB IWindowsParentalControls_GetGamesSettings_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IWindowsParentalControls_INTERFACE_DEFINED__ */

/* Begin additional prototypes for all interfaces */

ULONG           __RPC_USER HWND_UserSize     (ULONG *, ULONG, HWND *);
unsigned char * __RPC_USER HWND_UserMarshal  (ULONG *, unsigned char *, HWND *);
unsigned char * __RPC_USER HWND_UserUnmarshal(ULONG *, unsigned char *, HWND *);
void            __RPC_USER HWND_UserFree     (ULONG *, HWND *);

/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __wpcapi_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                        usr/share/mingw-w64/include/wpcevent.h                                                              0100644 0000000 0000000 00000001627 12404413016 016347  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#ifndef __WPCEVENT_H__
#define __WPCEVENT_H__

#include <evntprov.h>

EXTERN_C DECLSPEC_SELECTANY const GUID WPCPROV = {0x01090065, 0xb467, 0x4503, {0x9b,0x28,0x53,0x37,0x66,0x76,0x10,0x87}};

typedef enum tagWPC_ARGS_FILEDOWNLOADEVENT {
    WPC_ARGS_FILEDOWNLOADEVENT_URL = 0,
    WPC_ARGS_FILEDOWNLOADEVENT_APPNAME,
    WPC_ARGS_FILEDOWNLOADEVENT_VERSION,
    WPC_ARGS_FILEDOWNLOADEVENT_BLOCKED,
    WPC_ARGS_FILEDOWNLOADEVENT_PATH,
    WPC_ARGS_FILEDOWNLOADEVENT_CARGS
} WPC_ARGS_FILEDOWNLOADEVENT;

EXTERN_C DECLSPEC_SELECTANY const EVENT_DESCRIPTOR WPCEVENT_WEB_FILEDOWNLOAD = {0xa,0x0,0x10,0x4,0x18,0xa,0x8000000000000030};

#define WPCEVENT_WEB_FILEDOWNLOAD_value 0xa

#endif /*__WPCEVENT_H__*/
                                                                                                         usr/share/mingw-w64/include/wpcrsmsg.h                                                              0100644 0000000 0000000 00000001544 12404413016 016357  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#define CRSWPP_ERROR_FIRST __MSABI_LONG(0x40042200)
#define CRSWPP_INVALID_POSTINFO_FILE __MSABI_LONG(0xC0042201)
#define CRSWPP_NO_MATCHING_MAPURL __MSABI_LONG(0xC0042202)
#define CRSWPP_SECURITY_PACKAGE __MSABI_LONG(0xC0042203)
#define CRSWPP_SECURITY_PACKAGE_NOT_FOUND __MSABI_LONG(0xC0042204)
#define CRSWPP_PROJECT_BINDING_INCOMPLETE __MSABI_LONG(0xC0042205)
#define CRSWPP_SERVER_BINDING_INCOMPLETE __MSABI_LONG(0xC0042206)
#define CRSWPP_SERVER_NOT_RESPONDING __MSABI_LONG(0xC0042207)
#define CRSWPP_FAILED_AUTH __MSABI_LONG(0xC0042208)
#define CRSWPP_POSTINFO_NEEDED __MSABI_LONG(0x40042209)
#define CRSWPP_BIND_FAILED __MSABI_LONG(0xC004220A)
                                                                                                                                                            usr/share/mingw-w64/include/wpftpmsg.h                                                              0100644 0000000 0000000 00000000701 12404413016 016353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#define FTPWPP_ERROR_FIRST __MSABI_LONG(0x40042300)
#define FTPWPP_ERROR_INETOPEN_FAILED __MSABI_LONG(0xC0042301)
#define FTPWPP_ERROR_AUTHENTICATION_FAILED __MSABI_LONG(0xC0042302)
#define FTPWPP_ERROR_LAST __MSABI_LONG(0x400423FF)
                                                               usr/share/mingw-w64/include/wppstmsg.h                                                              0100644 0000000 0000000 00000000770 12404413016 016376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#define WPP_ERROR_FIRST __MSABI_LONG(0x40042380)
#define WPP_POST_POSTING_URL_ERROR __MSABI_LONG(0xC0042381)
#define WPP_POST_POSTING_SERVER_ERROR __MSABI_LONG(0xC0042382)
#define WPP_POST_POSTING_NO_RESPONSE_ERROR __MSABI_LONG(0xC0042383)
#define WPP_ERROR_LAST __MSABI_LONG(0x400423FF)
        usr/share/mingw-w64/include/wpspihlp.h                                                              0100644 0000000 0000000 00000003550 12404413016 016357  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __WPSPIHLP_H__
#define __WPSPIHLP_H__

#include <windows.h>
#include "wptypes.h"

#define WPPFUNC __declspec(dllimport)

#define WPF_FORCE_BIND 0x00000100

typedef HRESULT (WINAPI *PFN_WPPBINDTOSITEA)(HWND hwnd,LPCSTR sSiteName,LPCSTR sURL,REFIID riid,DWORD dwFlag,DWORD dwReserved,PVOID *ppvUnk);
typedef HRESULT (WINAPI *PFN_WPPLISTSITESA)(LPDWORD pdwSitesBufLen,LPWPSITEINFOA pSitesBuffer,LPDWORD pdwNumSites);
typedef HRESULT (WINAPI *PFN_WPPDELETESITEA)(LPCSTR sSiteName);
typedef HRESULT (WINAPI *PFN_WPPBINDTOSITEW)(HWND hwnd,LPCWSTR sSiteName,LPCWSTR sURL,REFIID riid,DWORD dwFlag,DWORD dwReserved,PVOID *ppvUnk);
typedef HRESULT (WINAPI *PFN_WPPLISTSITESW)(LPDWORD pdwSitesBufLen,LPWPSITEINFOW pSitesBuffer,LPDWORD pdwNumSites);
typedef HRESULT (WINAPI *PFN_WPPDELETESITEW)(LPCWSTR sSiteName);

HRESULT WPPFUNC WINAPI WppBindToSiteA(HWND hwnd,LPCSTR sSiteName,LPCSTR sURL,REFIID riid,DWORD dwFlag,DWORD dwReserved,PVOID *ppvUnk);
HRESULT WPPFUNC WINAPI WppListSitesA(LPDWORD pdwSitesBufLen,LPWPSITEINFOA pSitesBuffer,LPDWORD pdwNumSites);
HRESULT WPPFUNC WINAPI WppDeleteSiteA(LPCSTR sSiteName);
HRESULT WPPFUNC WINAPI WppBindToSiteW(HWND hwnd,LPCWSTR sSiteName,LPCWSTR sURL,REFIID riid,DWORD dwFlag,DWORD dwReserved,PVOID *ppvUnk);
HRESULT WPPFUNC WINAPI WppListSitesW(LPDWORD pdwSitesBufLen,LPWPSITEINFOW pSitesBuffer,LPDWORD pdwNumSites);
HRESULT WPPFUNC WINAPI WppDeleteSiteW(LPCWSTR sSiteName);

#define EP_WPPBINDTOSITEW "WppBindToSiteW"
#define EP_WPPLISTSITESW "WppListSitesW"
#define EP_WPPDELETESITEW "WppDeleteSiteW"

#define EP_WPPBINDTOSITEA "WppBindToSiteA"
#define EP_WPPLISTSITESA "WppListSitesA"
#define EP_WPPDELETESITEA "WppDeleteSiteA"
#endif
                                                                                                                                                        usr/share/mingw-w64/include/wptypes.h                                                               0100644 0000000 0000000 00000002401 12404413016 016216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __WPTYPES_H__
#define __WPTYPES_H__

#include <_mingw_unicode.h>

#ifdef __cplusplus
extern "C" {
#endif

  typedef struct tagWPSITEINFOA {
    DWORD dwSize;
    DWORD dwFlags;
    LPSTR lpszSiteName;
    LPSTR lpszSiteURL;
  } WPSITEINFOA,*LPWPSITEINFOA;

  typedef struct tagWPSITEINFOW {
    DWORD dwSize;
    DWORD dwFlags;
    LPWSTR lpszSiteName;
    LPWSTR lpszSiteURL;
  } WPSITEINFOW,*LPWPSITEINFOW;

  typedef struct tagWPPROVINFOA {
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwPriority;
    LPSTR lpszProviderName;
    LPSTR lpszProviderCLSID;
    LPSTR lpszDllPath;
  } WPPROVINFOA,*LPWPPROVINFOA;

  typedef struct tagWPPROVINFOW {
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwPriority;
    LPWSTR lpszProviderName;
    LPWSTR lpszProviderCLSID;
    LPWSTR lpszDllPath;
  } WPPROVINFOW,*LPWPPROVINFOW;

#define WPSITEINFO __MINGW_NAME_AW(WPSITEINFO)
#define LPWPSITEINFO __MINGW_NAME_AW(LPWPSITEINFO)
#define WPPROVINFO __MINGW_NAME_AW(WPPROVINFO)
#define LPWPPROVINFO __MINGW_NAME_AW(LPWPPROVINFO)

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                               usr/share/mingw-w64/include/wpwizmsg.h                                                              0100644 0000000 0000000 00000001572 12404413016 016402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#define WPWIZ_ERROR_FIRST __MSABI_LONG(0x40042000)
#define WPWIZ_ERROR_UNKNOWN __MSABI_LONG(0xC0042001)
#define WPWIZ_ERROR_PROV_QI __MSABI_LONG(0xC0042002)
#define WPWIZ_ERROR_INIT_FAILED __MSABI_LONG(0xC0042003)
#define WPWIZ_ERROR_COCREATE_WEBPOST __MSABI_LONG(0xC0042004)
#define WPWIZ_ERROR_NO_PROVIDERS __MSABI_LONG(0xC0042005)
#define WPWIZ_ERROR_STATE_PTR __MSABI_LONG(0xC0042006)
#define WPWIZ_ERROR_WEBPOST_PTR __MSABI_LONG(0xC0042007)
#define WPWIZ_ERROR_FILE_NOT_FOUND __MSABI_LONG(0xC0042008)
#define WPWIZ_ERROR_PROPSHEET_ERROR __MSABI_LONG(0xC0042009)
#define WPWIZ_ERROR_OUTOFMEMORY __MSABI_LONG(0xC004200A)
#define WPWIZ_ERROR_LAST __MSABI_LONG(0x400420FF)
                                                                                                                                      usr/share/mingw-w64/include/ws2atm.h                                                                0100644 0000000 0000000 00000020305 12404413016 015723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WS2ATM_H_
#define _WS2ATM_H_

#include <pshpack4.h>

#define ATMPROTO_AALUSER 0x00
#define ATMPROTO_AAL1 0x01
#define ATMPROTO_AAL2 0x02
#define ATMPROTO_AAL34 0x03
#define ATMPROTO_AAL5 0x05

#define SAP_FIELD_ABSENT 0xFFFFFFFE
#define SAP_FIELD_ANY 0xFFFFFFFF
#define SAP_FIELD_ANY_AESA_SEL 0xFFFFFFFA
#define SAP_FIELD_ANY_AESA_REST 0xFFFFFFFB

#define ATM_E164 0x01
#define ATM_NSAP 0x02
#define ATM_AESA 0x02

#define ATM_ADDR_SIZE 20
typedef struct {
  DWORD AddressType;
  DWORD NumofDigits;
  UCHAR Addr[ATM_ADDR_SIZE];
} ATM_ADDRESS;

#define BLLI_L2_ISO_1745 0x01
#define BLLI_L2_Q921 0x02
#define BLLI_L2_X25L 0x06
#define BLLI_L2_X25M 0x07
#define BLLI_L2_ELAPB 0x08
#define BLLI_L2_HDLC_ARM 0x09
#define BLLI_L2_HDLC_NRM 0x0A
#define BLLI_L2_HDLC_ABM 0x0B
#define BLLI_L2_LLC 0x0C
#define BLLI_L2_X75 0x0D
#define BLLI_L2_Q922 0x0E
#define BLLI_L2_USER_SPECIFIED 0x10
#define BLLI_L2_ISO_7776 0x11

#define BLLI_L3_X25 0x06
#define BLLI_L3_ISO_8208 0x07
#define BLLI_L3_X223 0x08
#define BLLI_L3_SIO_8473 0x09
#define BLLI_L3_T70 0x0A
#define BLLI_L3_ISO_TR9577 0x0B
#define BLLI_L3_USER_SPECIFIED 0x10

#define BLLI_L3_IPI_SNAP 0x80
#define BLLI_L3_IPI_IP 0xCC

typedef struct {
  DWORD Layer2Protocol;
  DWORD Layer2UserSpecifiedProtocol;
  DWORD Layer3Protocol;
  DWORD Layer3UserSpecifiedProtocol;
  DWORD Layer3IPI;
  UCHAR SnapID[5];
} ATM_BLLI;

#define BHLI_ISO 0x00
#define BHLI_UserSpecific 0x01
#define BHLI_HighLayerProfile 0x02
#define BHLI_VendorSpecificAppId 0x03

typedef struct {
  DWORD HighLayerInfoType;
  DWORD HighLayerInfoLength;
  UCHAR HighLayerInfo[8];
} ATM_BHLI;

typedef struct sockaddr_atm {
  u_short satm_family;
  ATM_ADDRESS satm_number;
  ATM_BLLI satm_blli;
  ATM_BHLI satm_bhli;
} sockaddr_atm,SOCKADDR_ATM,*PSOCKADDR_ATM,*LPSOCKADDR_ATM;

typedef enum {
  IE_AALParameters,IE_TrafficDescriptor,IE_BroadbandBearerCapability,IE_BHLI,IE_BLLI,IE_CalledPartyNumber,IE_CalledPartySubaddress,
  IE_CallingPartyNumber,IE_CallingPartySubaddress,IE_Cause,IE_QOSClass,IE_TransitNetworkSelection
} Q2931_IE_TYPE;

typedef struct {
  Q2931_IE_TYPE IEType;
  ULONG IELength;
  UCHAR IE[1];
} Q2931_IE;

typedef enum {
  AALTYPE_5 = 5,AALTYPE_USER = 16
} AAL_TYPE;

#define AAL5_MODE_MESSAGE 0x01
#define AAL5_MODE_STREAMING 0x02

#define AAL5_SSCS_NULL 0x00
#define AAL5_SSCS_SSCOP_ASSURED 0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED 0x02
#define AAL5_SSCS_FRAME_RELAY 0x04

typedef struct {
  ULONG ForwardMaxCPCSSDUSize;
  ULONG BackwardMaxCPCSSDUSize;
  UCHAR Mode;
  UCHAR SSCSType;
} AAL5_PARAMETERS;

typedef struct {
  ULONG UserDefined;
} AALUSER_PARAMETERS;

typedef struct {
  AAL_TYPE AALType;
  union {
    AAL5_PARAMETERS AAL5Parameters;
    AALUSER_PARAMETERS AALUserParameters;
  } AALSpecificParameters;
} AAL_PARAMETERS_IE;

typedef struct {
  ULONG PeakCellRate_CLP0;
  ULONG PeakCellRate_CLP01;
  ULONG SustainableCellRate_CLP0;
  ULONG SustainableCellRate_CLP01;
  ULONG MaxBurstSize_CLP0;
  ULONG MaxBurstSize_CLP01;
  WINBOOL Tagging;
} ATM_TD;

typedef struct {
  ATM_TD Forward;
  ATM_TD Backward;
  WINBOOL BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE;

#define BCOB_A 0x01
#define BCOB_C 0x03
#define BCOB_X 0x10

#define TT_NOIND 0x00
#define TT_CBR 0x04
#define TT_VBR 0x08

#define TR_NOIND 0x00
#define TR_END_TO_END 0x01
#define TR_NO_END_TO_END 0x02

#define CLIP_NOT 0x00
#define CLIP_SUS 0x20

#define UP_P2P 0x00
#define UP_P2MP 0x01

typedef struct {
  UCHAR BearerClass;
  UCHAR TrafficType;
  UCHAR TimingRequirements;
  UCHAR ClippingSusceptability;
  UCHAR UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE;

typedef ATM_BHLI ATM_BHLI_IE;

#define BLLI_L2_MODE_NORMAL 0x40
#define BLLI_L2_MODE_EXT 0x80

#define BLLI_L3_MODE_NORMAL 0x40
#define BLLI_L3_MODE_EXT 0x80

#define BLLI_L3_PACKET_16 0x04
#define BLLI_L3_PACKET_32 0x05
#define BLLI_L3_PACKET_64 0x06
#define BLLI_L3_PACKET_128 0x07
#define BLLI_L3_PACKET_256 0x08
#define BLLI_L3_PACKET_512 0x09
#define BLLI_L3_PACKET_1024 0x0A
#define BLLI_L3_PACKET_2048 0x0B
#define BLLI_L3_PACKET_4096 0x0C

typedef struct {
  DWORD Layer2Protocol;
  UCHAR Layer2Mode;
  UCHAR Layer2WindowSize;
  DWORD Layer2UserSpecifiedProtocol;
  DWORD Layer3Protocol;
  UCHAR Layer3Mode;
  UCHAR Layer3DefaultPacketSize;
  UCHAR Layer3PacketWindowSize;
  DWORD Layer3UserSpecifiedProtocol;
  DWORD Layer3IPI;
  UCHAR SnapID[5];
} ATM_BLLI_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_NUMBER_IE;
typedef ATM_ADDRESS ATM_CALLED_PARTY_SUBADDRESS_IE;

#define PI_ALLOWED 0x00
#define PI_RESTRICTED 0x40
#define PI_NUMBER_NOT_AVAILABLE 0x80

#define SI_USER_NOT_SCREENED 0x00
#define SI_USER_PASSED 0x01
#define SI_USER_FAILED 0x02
#define SI_NETWORK 0x03

typedef struct {
  ATM_ADDRESS ATM_Number;
  UCHAR Presentation_Indication;
  UCHAR Screening_Indicator;
} ATM_CALLING_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLING_PARTY_SUBADDRESS_IE;

#define CAUSE_LOC_USER 0x00
#define CAUSE_LOC_PRIVATE_LOCAL 0x01
#define CAUSE_LOC_PUBLIC_LOCAL 0x02
#define CAUSE_LOC_TRANSIT_NETWORK 0x03
#define CAUSE_LOC_PUBLIC_REMOTE 0x04
#define CAUSE_LOC_PRIVATE_REMOTE 0x05
#define CAUSE_LOC_INTERNATIONAL_NETWORK 0x07
#define CAUSE_LOC_BEYOND_INTERWORKING 0x0A

#define CAUSE_UNALLOCATED_NUMBER 0x01
#define CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK 0x02
#define CAUSE_NO_ROUTE_TO_DESTINATION 0x03
#define CAUSE_VPI_VCI_UNACCEPTABLE 0x0A
#define CAUSE_NORMAL_CALL_CLEARING 0x10
#define CAUSE_USER_BUSY 0x11
#define CAUSE_NO_USER_RESPONDING 0x12
#define CAUSE_CALL_REJECTED 0x15
#define CAUSE_NUMBER_CHANGED 0x16
#define CAUSE_USER_REJECTS_CLIR 0x17
#define CAUSE_DESTINATION_OUT_OF_ORDER 0x1B
#define CAUSE_INVALID_NUMBER_FORMAT 0x1C
#define CAUSE_STATUS_ENQUIRY_RESPONSE 0x1E
#define CAUSE_NORMAL_UNSPECIFIED 0x1F
#define CAUSE_VPI_VCI_UNAVAILABLE 0x23
#define CAUSE_NETWORK_OUT_OF_ORDER 0x26
#define CAUSE_TEMPORARY_FAILURE 0x29
#define CAUSE_ACCESS_INFORMAION_DISCARDED 0x2B
#define CAUSE_NO_VPI_VCI_AVAILABLE 0x2D
#define CAUSE_RESOURCE_UNAVAILABLE 0x2F
#define CAUSE_QOS_UNAVAILABLE 0x31
#define CAUSE_USER_CELL_RATE_UNAVAILABLE 0x33
#define CAUSE_BEARER_CAPABILITY_UNAUTHORIZED 0x39
#define CAUSE_BEARER_CAPABILITY_UNAVAILABLE 0x3A
#define CAUSE_OPTION_UNAVAILABLE 0x3F
#define CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED 0x41
#define CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS 0x49
#define CAUSE_INVALID_CALL_REFERENCE 0x51
#define CAUSE_CHANNEL_NONEXISTENT 0x52
#define CAUSE_INCOMPATIBLE_DESTINATION 0x58
#define CAUSE_INVALID_ENDPOINT_REFERENCE 0x59
#define CAUSE_INVALID_TRANSIT_NETWORK_SELECTION 0x5B
#define CAUSE_TOO_MANY_PENDING_ADD_PARTY 0x5C
#define CAUSE_AAL_PARAMETERS_UNSUPPORTED 0x5D
#define CAUSE_MANDATORY_IE_MISSING 0x60
#define CAUSE_UNIMPLEMENTED_MESSAGE_TYPE 0x61
#define CAUSE_UNIMPLEMENTED_IE 0x63
#define CAUSE_INVALID_IE_CONTENTS 0x64
#define CAUSE_INVALID_STATE_FOR_MESSAGE 0x65
#define CAUSE_RECOVERY_ON_TIMEOUT 0x66
#define CAUSE_INCORRECT_MESSAGE_LENGTH 0x68
#define CAUSE_PROTOCOL_ERROR 0x6F

#define CAUSE_COND_UNKNOWN 0x00
#define CAUSE_COND_PERMANENT 0x01
#define CAUSE_COND_TRANSIENT 0x02

#define CAUSE_REASON_USER 0x00
#define CAUSE_REASON_IE_MISSING 0x04
#define CAUSE_REASON_IE_INSUFFICIENT 0x08

#define CAUSE_PU_PROVIDER 0x00
#define CAUSE_PU_USER 0x08

#define CAUSE_NA_NORMAL 0x00
#define CAUSE_NA_ABNORMAL 0x04

typedef struct {
  UCHAR Location;
  UCHAR Cause;
  UCHAR DiagnosticsLength;
  UCHAR Diagnostics[4];
} ATM_CAUSE_IE;

#define QOS_CLASS0 0x00
#define QOS_CLASS1 0x01
#define QOS_CLASS2 0x02
#define QOS_CLASS3 0x03
#define QOS_CLASS4 0x04

typedef struct {
  UCHAR QOSClassForward;
  UCHAR QOSClassBackward;
} ATM_QOS_CLASS_IE;

#define TNS_TYPE_NATIONAL 0x40

#define TNS_PLAN_CARRIER_ID_CODE 0x01

typedef struct {
  UCHAR TypeOfNetworkId;
  UCHAR NetworkIdPlan;
  UCHAR NetworkIdLength;
  UCHAR NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE;

#define SIO_GET_NUMBER_OF_ATM_DEVICES 0x50160001
#define SIO_GET_ATM_ADDRESS 0xd0160002
#define SIO_ASSOCIATE_PVC 0x90160003
#define SIO_GET_ATM_CONNECTION_ID 0x50160004

typedef struct {
  DWORD DeviceNumber;
  DWORD VPI;
  DWORD VCI;
} ATM_CONNECTION_ID;

typedef struct {
  ATM_CONNECTION_ID PvcConnectionId;
  QOS PvcQos;
} ATM_PVC_PARAMS;

#include <poppack.h>
#endif
                                                                                                                                                                                                                                                                                                                           usr/share/mingw-w64/include/ws2bth.h                                                                0100644 0000000 0000000 00000013035 12404413016 015721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */

#include <winapifamily.h>

#ifndef __WS2BTH__H
#define __WS2BTH__H

#if WINAPI_FAMILY_PARTITION (WINAPI_PARTITION_DESKTOP)

#include <bthdef.h>
#include <bthsdpdef.h>
#include <pshpack1.h>

#define BT_PORT_ANY ((ULONG)-1)
#define BT_PORT_MIN 0x1
#define BT_PORT_MAX 0xffff
#define BT_PORT_DYN_FIRST 0x1001

#ifndef AF_BTH
#define AF_BTH 32
#endif

#ifndef PF_BTH
#define PF_BTH AF_BTH
#endif

#ifndef NS_BTH
#define NS_BTH 16
#endif

typedef struct _SOCKADDR_BTH {
  USHORT addressFamily;
  BTH_ADDR btAddr;
  GUID serviceClassId;
  ULONG port;
} SOCKADDR_BTH,*PSOCKADDR_BTH;

DEFINE_GUID (SVCID_BTH_PROVIDER, 0x6aa63e0, 0x7d60, 0x41ff, 0xaf, 0xb2, 0x3e, 0xe6, 0xd2, 0xd9, 0x39, 0x2d);

#define BTH_ADDR_STRING_SIZE 12

#define BTHPROTO_RFCOMM 0x0003
#define BTHPROTO_L2CAP 0x0100

#define SOL_RFCOMM BTHPROTO_RFCOMM
#define SOL_L2CAP BTHPROTO_L2CAP
#define SOL_SDP 0x0101

#define SO_BTH_AUTHENTICATE 0x80000001
#define SO_BTH_ENCRYPT 0x00000002
#define SO_BTH_MTU 0x80000007
#define SO_BTH_MTU_MAX 0x80000008
#define SO_BTH_MTU_MIN 0x8000000a

#define RFCOMM_MAX_MTU 0x000003f3
#define RFCOMM_MIN_MTU 0x00000017

#define BTH_SDP_VERSION 1

typedef struct _BTH_SET_SERVICE {
  PULONG pSdpVersion;
  HANDLE *pRecordHandle;
  ULONG fCodService;
  ULONG Reserved[5];
  ULONG ulRecordLength;
  UCHAR pRecord[1];
} BTH_SET_SERVICE,*PBTH_SET_SERVICE;

#define SDP_DEFAULT_INQUIRY_SECONDS 6
#define SDP_MAX_INQUIRY_SECONDS 60

#define SDP_DEFAULT_INQUIRY_MAX_RESPONSES 255

#define SDP_SERVICE_SEARCH_REQUEST 1
#define SDP_SERVICE_ATTRIBUTE_REQUEST 2
#define SDP_SERVICE_SEARCH_ATTRIBUTE_REQUEST 3

typedef struct _BTH_QUERY_DEVICE {
  ULONG LAP;
  UCHAR length;
} BTH_QUERY_DEVICE,*PBTH_QUERY_DEVICE;
typedef struct _BTH_QUERY_SERVICE {
  ULONG type;
  ULONG serviceHandle;
  SdpQueryUuid uuids[MAX_UUIDS_IN_QUERY];
  ULONG numRange;
  SdpAttributeRange pRange[1];
} BTH_QUERY_SERVICE,*PBTH_QUERY_SERVICE;

#define BTHNS_RESULT_DEVICE_CONNECTED 0x00010000
#define BTHNS_RESULT_DEVICE_REMEMBERED 0x00020000
#define BTHNS_RESULT_DEVICE_AUTHENTICATED 0x00040000

#define SIO_RFCOMM_SEND_COMMAND _WSAIORW (IOC_VENDOR, 101)
#define SIO_RFCOMM_WAIT_COMMAND _WSAIORW (IOC_VENDOR, 102)

#define SIO_BTH_PING _WSAIORW (IOC_VENDOR, 8)
#define SIO_BTH_INFO _WSAIORW (IOC_VENDOR, 9)
#define SIO_RFCOMM_SESSION_FLOW_OFF _WSAIORW (IOC_VENDOR, 103)
#define SIO_RFCOMM_TEST _WSAIORW (IOC_VENDOR, 104)
#define SIO_RFCOMM_USECFC _WSAIORW (IOC_VENDOR, 105)

#ifndef BIT
#define BIT(b) (1 << (b))
#endif

#define MSC_EA_BIT EA_BIT
#define MSC_FC_BIT BIT (1)
#define MSC_RTC_BIT BIT (2)
#define MSC_RTR_BIT BIT (3)
#define MSC_RESERVED (BIT (4)|BIT (5))
#define MSC_IC_BIT BIT (6)
#define MSC_DV_BIT BIT (7)

#define MSC_BREAK_BIT BIT (1)
#define MSC_SET_BREAK_LENGTH (b, l) ((b) = ((b) &0x3) | (((l) &0xf) << 4))

#define RLS_ERROR 0x01
#define RLS_OVERRUN 0x02
#define RLS_PARITY 0x04
#define RLS_FRAMING 0x08

#define RPN_BAUD_2400 0
#define RPN_BAUD_4800 1
#define RPN_BAUD_7200 2
#define RPN_BAUD_9600 3
#define RPN_BAUD_19200 4
#define RPN_BAUD_38400 5
#define RPN_BAUD_57600 6
#define RPN_BAUD_115200 7
#define RPN_BAUD_230400 8

#define RPN_DATA_5 0x0
#define RPN_DATA_6 0x1
#define RPN_DATA_7 0x2
#define RPN_DATA_8 0x3

#define RPN_STOP_1 0x0
#define RPN_STOP_1_5 0x4

#define RPN_PARITY_NONE 0x00
#define RPN_PARITY_ODD 0x08
#define RPN_PARITY_EVEN 0x18
#define RPN_PARITY_MARK 0x28
#define RPN_PARITY_SPACE 0x38

#define RPN_FLOW_X_IN 0x01
#define RPN_FLOW_X_OUT 0x02
#define RPN_FLOW_RTR_IN 0x04
#define RPN_FLOW_RTR_OUT 0x08
#define RPN_FLOW_RTC_IN 0x10
#define RPN_FLOW_RTC_OUT 0x20

#define RPN_PARAM_BAUD 0x01
#define RPN_PARAM_DATA 0x02
#define RPN_PARAM_STOP 0x04
#define RPN_PARAM_PARITY 0x08
#define RPN_PARAM_P_TYPE 0x10
#define RPN_PARAM_XON 0x20
#define RPN_PARAM_XOFF 0x40

#define RPN_PARAM_X_IN 0x01
#define RPN_PARAM_X_OUT 0x02
#define RPN_PARAM_RTR_IN 0x04
#define RPN_PARAM_RTR_OUT 0x08
#define RPN_PARAM_RTC_IN 0x10
#define RPN_PARAM_RTC_OUT 0x20

#define RFCOMM_CMD_NONE 0
#define RFCOMM_CMD_MSC 1
#define RFCOMM_CMD_RLS 2
#define RFCOMM_CMD_RPN 3
#define RFCOMM_CMD_RPN_REQUEST 4
#define RFCOMM_CMD_RPN_RESPONSE 5

typedef struct _RFCOMM_MSC_DATA {
  UCHAR Signals;
  UCHAR Break;
} RFCOMM_MSC_DATA,*PRFCOMM_MSC_DATA;

typedef struct _RFCOMM_RLS_DATA {
  UCHAR LineStatus;
} RFCOMM_RLS_DATA,*PRFCOMM_RLS_DATA;

typedef struct _RFCOMM_RPN_DATA {
  UCHAR Baud;
  UCHAR Data;
  UCHAR FlowControl;
  UCHAR XonChar;
  UCHAR XoffChar;
  UCHAR ParameterMask1;
  UCHAR ParameterMask2;
} RFCOMM_RPN_DATA,*PRFCOMM_RPN_DATA;

typedef struct _RFCOMM_COMMAND {
  ULONG CmdType;
  union {
    RFCOMM_MSC_DATA MSC;
    RFCOMM_RLS_DATA RLS;
    RFCOMM_RPN_DATA RPN;
  } Data;
} RFCOMM_COMMAND,*PRFCOMM_COMMAND;

typedef struct _BTH_PING_REQ {
  BTH_ADDR btAddr;
  UCHAR dataLen;
  UCHAR data[MAX_L2CAP_PING_DATA_LENGTH];
} BTH_PING_REQ,*PBTH_PING_REQ;

typedef struct _BTH_PING_RSP {
  UCHAR dataLen;
  UCHAR data[MAX_L2CAP_PING_DATA_LENGTH];
} BTH_PING_RSP,*PBTH_PING_RSP;

typedef struct _BTH_INFO_REQ {
  BTH_ADDR btAddr;
  USHORT infoType;
} BTH_INFO_REQ,*PBTH_INFO_REQ;

typedef struct _BTH_INFO_RSP {
  USHORT result;
  UCHAR dataLen;
  __C89_NAMELESS union {
    USHORT connectionlessMTU;
    UCHAR data[MAX_L2CAP_INFO_DATA_LENGTH];
  };
} BTH_INFO_RSP,*PBTH_INFO_RSP;

typedef struct _BTH_SET_SERVICE BTHNS_SETBLOB,*PBTHNS_SETBLOB;
typedef struct _BTH_QUERY_DEVICE BTHNS_INQUIRYBLOB,*PBTHNS_INQUIRYBLOB;
typedef struct _BTH_QUERY_SERVICE BTHNS_RESTRICTIONBLOB,*PBTHNS_RESTRICTIONBLOB;

#include <poppack.h>

#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/ws2def.h                                                                0100644 0000000 0000000 00000001635 12404413016 015705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */

#ifndef _WS2DEF_
#define _WS2DEF_

#include <_mingw.h>
#include <winapifamily.h>

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

/* FIXME FIXME FIXME FIXME FIXME: Much more data need moving here.
 * This holds only SCOPE_LEVEL and SCOPE_ID so that compilations
 * do not fail.
 */

typedef enum _SCOPE_LEVEL {
  ScopeLevelInterface = 1,
  ScopeLevelLink      = 2,
  ScopeLevelSubnet    = 3,
  ScopeLevelAdmin     = 4,
  ScopeLevelSite      = 5,
  ScopeLevelOrganization = 8,
  ScopeLevelGlobal   = 14,
  ScopeLevelCount    = 16
} SCOPE_LEVEL;

typedef struct _SCOPE_ID {
  __C89_NAMELESS union {
    __C89_NAMELESS struct {
	ULONG	Zone : 28;
	ULONG	Level : 4;
    };
    ULONG Value;
  };
} SCOPE_ID, *PSCOPE_ID;

#endif /* WINAPI_PARTITION_DESKTOP.  */

#endif /* _WS2DEF_ */

                                                                                                   usr/share/mingw-w64/include/ws2dnet.h                                                               0100644 0000000 0000000 00000007523 12404413016 016103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef WS2DNET_H
#define WS2DNET_H

#include <winsock2.h>

#pragma pack(push,ws2dnet,1)

#define DNPROTO_NSP 1
#define DNPROTO_RAW 255

#define DN_MAXADDL 20
#define DN_ADDL 2
#define DN_MAXOPTL 16
#define DN_MAXOBJL 16
#define DN_MAXACCL 39
#define DN_MAXALIASL 128
#define DN_MAXNODEL 7

#define WS2API_DECNET_dnet_addr 1
#define WS2API_DECNET_dnet_eof 2
#define WS2API_DECNET_dnet_getacc 3
#define WS2API_DECNET_dnet_getalias 4
#define WS2API_DECNET_dnet_htoa 5
#define WS2API_DECNET_dnet_ntoa 6
#define WS2API_DECNET_getnodeadd 7
#define WS2API_DECNET_getnodebyaddr 8
#define WS2API_DECNET_getnodebyname 9
#define WS2API_DECNET_getnodename 10
#define WS2API_DECNET_MAX 10

typedef struct dn_naddr {
  unsigned short a_len;
  unsigned char a_addr[DN_MAXADDL];
} DNNADDR,*LPDNNADDR;

typedef struct sockaddr_dn {
  unsigned short sdn_family;
  unsigned char sdn_flags;
  unsigned char sdn_objnum;
  unsigned short sdn_objnamel;
  char sdn_objname[DN_MAXOBJL];
  struct dn_naddr sdn_add;
} SOCKADDRDN,*LPSOCKADDRDN;

#define sdn_nodeaddrl sdn_add.a_len
#define sdn_nodeaddr sdn_add.a_addr

#define DNOBJECT_FAL 17
#define DNOBJECT_NICE 19
#define DNOBJECT_DTERM 23
#define DNOBJECT_MIRROR 25
#define DNOBJECT_EVR 26
#define DNOBJECT_MAIL11 27
#define DNOBJECT_PHONE 29
#define DNOBJECT_CTERM 42
#define DNOBJECT_DTR 63

typedef struct nodeent_f {
  char *n_name;
  unsigned short n_addrtype;
  unsigned short n_length;
  unsigned char *n_addr;
  unsigned char *n_params;
  unsigned char n_reserved[16];
} NODEENTF,*LPNODEENTF;

typedef struct optdata_dn {
  unsigned short opt_status;
  unsigned short opt_optl;
  unsigned char opt_data[DN_MAXOPTL];
} OPTDATADN,*LPOPTDATADN;

typedef struct accessdata_dn {
  unsigned short acc_accl;
  unsigned char acc_acc[DN_MAXACCL+1];
  unsigned short acc_passl;
  unsigned char acc_pass[DN_MAXACCL+1];
  unsigned short acc_userl;
  unsigned char acc_user[DN_MAXACCL+1];
} ACCESSDATADN,*LPACCESSDATADN;

typedef struct calldata_dn {
  struct optdata_dn optdata_dn;
  struct accessdata_dn accessdata_dn;
} CALLDATADN,*LPCALLDATADN;

typedef struct dnet_accent {
  unsigned char dac_status;
  unsigned char dac_type;
  char dac_username[DN_MAXACCL+1];
  char dac_password[DN_MAXACCL+1];
} DNETACCENT,*LPDNETACCENT;

#define DN_NONE 0x00
#define DN_RO 0x01
#define DN_WO 0x02
#define DN_RW 0x03

typedef struct linkinfo_dn {
  unsigned short idn_segsize;
  unsigned char idn_linkstate;
} LINKINFODN,*LPLINKINFODN;

#define SO_LINKINFO 7
#define LL_INACTIVE 0
#define LL_CONNECTING 1
#define LL_RUNNING 2
#define LL_DISCONNECTING 3

#pragma pack(pop,ws2dnet)

struct dn_naddr *WSAAPI dnet_addr(const char *);
int WSAAPI dnet_eof(SOCKET);
struct dnet_accent *WSAAPI dnet_getacc(const struct dnet_accent *);
char *WSAAPI dnet_getalias(const char *);
char *WSAAPI dnet_htoa(const struct dn_naddr *);
char *WSAAPI dnet_ntoa(const struct dn_naddr *);
struct dn_naddr *WSAAPI getnodeadd(void);
struct nodeent_f *WSAAPI getnodebyaddr(const unsigned char *addr,int,int);
struct nodeent_f *WSAAPI getnodebyname(const char *);
char *WSAAPI getnodename(void);

typedef struct dn_naddr *(WSAAPI *LPDNETADDR)(const char *);
typedef int (WSAAPI *LPDNETEOF)(SOCKET);
typedef struct dnet_accent *(WSAAPI *LPDNETGETACC)(const struct dnet_accent *);
typedef char *(WSAAPI *LPDNETGETALIAS)(const char *);
typedef char *(WSAAPI *LPDNETHTOA)(const struct dn_naddr *);
typedef char *(WSAAPI *LPDNETNTOA)(const struct dn_naddr *);
typedef struct dn_naddr *(WSAAPI *LPGETNODEADD)(void);
typedef struct nodeent_f *(WSAAPI *LPGETNODEBYADDR)(const unsigned char *addr,int,int);
typedef struct nodeent_f *(WSAAPI *LPGETNODEBYNAME)(const char *);
typedef char *(WSAAPI *LPGETNODENAME)(void);
#endif
                                                                                                                                                                             usr/share/mingw-w64/include/ws2ipdef.h                                                              0100644 0000000 0000000 00000006074 12404413016 016240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */
#ifndef _INC_WS2IPDEF
#define _INC_WS2IPDEF

#include <winapifamily.h>

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

#include <in6addr.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct ipv6_mreq {
  struct in6_addr ipv6mr_multiaddr;
  unsigned int ipv6mr_interface;
} IPV6_MREQ;

struct sockaddr_in6_old {
  short sin6_family;
  u_short sin6_port;
  u_long sin6_flowinfo;
  struct in6_addr sin6_addr;
};

typedef union sockaddr_gen {
  struct sockaddr Address;
  struct sockaddr_in AddressIn;
  struct sockaddr_in6_old AddressIn6;
} sockaddr_gen;

struct sockaddr_in6 {
  short sin6_family;
  u_short sin6_port;
  u_long sin6_flowinfo;
  struct in6_addr sin6_addr;
  __C89_NAMELESS union {
    u_long sin6_scope_id;
    SCOPE_ID sin6_scope_struct;
  };
};

typedef struct sockaddr_in6 SOCKADDR_IN6;
typedef struct sockaddr_in6 *PSOCKADDR_IN6;
typedef struct sockaddr_in6 *LPSOCKADDR_IN6;

typedef struct _INTERFACE_INFO {
  u_long iiFlags;
  sockaddr_gen iiAddress;
  sockaddr_gen iiBroadcastAddress;
  sockaddr_gen iiNetmask;
} INTERFACE_INFO,*LPINTERFACE_INFO;

typedef enum _MULTICAST_MODE_TYPE {
  MCAST_INCLUDE   = 0,
  MCAST_EXCLUDE
} MULTICAST_MODE_TYPE;

typedef struct _sockaddr_in6_pair {
  PSOCKADDR_IN6 SourceAddress;
  PSOCKADDR_IN6 DestinationAddress;
} SOCKADDR_IN6_PAIR, *PSOCKADDR_IN6_PAIR;

typedef union _SOCKADDR_INET {
  SOCKADDR_IN    Ipv4;
  SOCKADDR_IN6   Ipv6;
  ADDRESS_FAMILY si_family;
} SOCKADDR_INET, *PSOCKADDR_INET;

typedef struct group_filter {
  ULONG               gf_interface;
  SOCKADDR_STORAGE    gf_group;
  MULTICAST_MODE_TYPE gf_fmode;
  ULONG               gf_numsrc;
  SOCKADDR_STORAGE    gf_slist[1];
} GROUP_FILTER, *PGROUP_FILTER;

typedef struct group_req {
  ULONG            gr_interface;
  SOCKADDR_STORAGE gr_group;
} GROUP_REQ, *PGROUP_REQ;

typedef struct group_source_req {
  ULONG            gsr_interface;
  SOCKADDR_STORAGE gsr_group;
  SOCKADDR_STORAGE gsr_source;
} GROUP_SOURCE_REQ, *PGROUP_SOURCE_REQ;

#define IPV6_HOPOPTS           1
#define IPV6_HDRINCL           2
#define IPV6_UNICAST_HOPS      4
#define IPV6_MULTICAST_IF      9
#define IPV6_MULTICAST_HOPS    10
#define IPV6_MULTICAST_LOOP    11
#define IPV6_ADD_MEMBERSHIP    12
#define IPV6_JOIN_GROUP        IPV6_ADD_MEMBERSHIP
#define IPV6_DROP_MEMBERSHIP   13
#define IPV6_LEAVE_GROUP       IPV6_DROP_MEMBERSHIP
#define IPV6_DONTFRAG          14
#define IPV6_PKTINFO           19
#define IPV6_HOPLIMIT          21
#define IPV6_PROTECTION_LEVEL  23
#define IPV6_RECVIF            24
#define IPV6_RECVDSTADDR       25
#define IPV6_CHECKSUM          26
#define IPV6_V6ONLY            27
#define IPV6_IFLIST            28
#define IPV6_ADD_IFLIST        29
#define IPV6_DEL_IFLIST        30
#define IPV6_UNICAST_IF        31
#define IPV6_RTHDR             32
#define IPV6_RECVRTHDR         38
#define IPV6_TCLASS            39
#define IPV6_RECVTCLASS        40

#ifdef __cplusplus
}
#endif

#endif /* WINAPI_PARTION_DESKTOP.  */

#endif /*_INC_WS2IPDEF*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/mingw-w64/include/ws2spi.h                                                                0100644 0000000 0000000 00000050075 12404413016 015744  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WINSOCK2SPI_
#define _WINSOCK2SPI_

#ifndef _WIN64
#include <pshpack4.h>
#endif

#include <winsock2.h>

#define WSPDESCRIPTION_LEN 255

#define WSS_OPERATION_IN_PROGRESS __MSABI_LONG(0x00000103)

typedef struct WSPData {
  WORD wVersion;
  WORD wHighVersion;
  WCHAR szDescription[WSPDESCRIPTION_LEN+1];
} WSPDATA,*LPWSPDATA;

typedef struct _WSATHREADID {
  HANDLE ThreadHandle;
  DWORD_PTR Reserved;
} WSATHREADID,*LPWSATHREADID;

#define WSPAPI WSAAPI

#ifdef __cplusplus
extern "C" {
#endif

  typedef WINBOOL (CALLBACK *LPBLOCKINGCALLBACK)(DWORD_PTR dwContext);
  typedef VOID (CALLBACK *LPWSAUSERAPC)(DWORD_PTR dwContext);
  typedef SOCKET (WSPAPI *LPWSPACCEPT)(SOCKET s,struct sockaddr *addr,LPINT addrlen,LPCONDITIONPROC lpfnCondition,DWORD_PTR dwCallbackData,LPINT lpErrno);
  typedef INT (WSPAPI *LPWSPADDRESSTOSTRING)(LPSOCKADDR lpsaAddress,DWORD dwAddressLength,LPWSAPROTOCOL_INFOW lpProtocolInfo,LPWSTR lpszAddressString,LPDWORD lpdwAddressStringLength,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPASYNCSELECT)(SOCKET s,HWND hWnd,unsigned int wMsg,__LONG32 lEvent,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPBIND)(SOCKET s,const struct sockaddr *name,int namelen,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPCANCELBLOCKINGCALL)(LPINT lpErrno);
  typedef int (WSPAPI *LPWSPCLEANUP)(LPINT lpErrno);
  typedef int (WSPAPI *LPWSPCLOSESOCKET)(SOCKET s,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPCONNECT)(SOCKET s,const struct sockaddr *name,int namelen,LPWSABUF lpCallerData,LPWSABUF lpCalleeData,LPQOS lpSQOS,LPQOS lpGQOS,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPDUPLICATESOCKET)(SOCKET s,DWORD dwProcessId,LPWSAPROTOCOL_INFOW lpProtocolInfo,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPENUMNETWORKEVENTS)(SOCKET s,WSAEVENT hEventObject,LPWSANETWORKEVENTS lpNetworkEvents,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPEVENTSELECT)(SOCKET s,WSAEVENT hEventObject,__LONG32 lNetworkEvents,LPINT lpErrno);
  typedef WINBOOL (WSPAPI *LPWSPGETOVERLAPPEDRESULT)(SOCKET s,LPWSAOVERLAPPED lpOverlapped,LPDWORD lpcbTransfer,WINBOOL fWait,LPDWORD lpdwFlags,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPGETPEERNAME)(SOCKET s,struct sockaddr *name,LPINT namelen,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPGETSOCKNAME)(SOCKET s,struct sockaddr *name,LPINT namelen,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPGETSOCKOPT)(SOCKET s,int level,int optname,char *optval,LPINT optlen,LPINT lpErrno);
  typedef WINBOOL (WSPAPI *LPWSPGETQOSBYNAME)(SOCKET s,LPWSABUF lpQOSName,LPQOS lpQOS,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPIOCTL)(SOCKET s,DWORD dwIoControlCode,LPVOID lpvInBuffer,DWORD cbInBuffer,LPVOID lpvOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbBytesReturned,LPWSAOVERLAPPED lpOverlapped,LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,LPWSATHREADID lpThreadId,LPINT lpErrno);
  typedef SOCKET (WSPAPI *LPWSPJOINLEAF)(SOCKET s,const struct sockaddr *name,int namelen,LPWSABUF lpCallerData,LPWSABUF lpCalleeData,LPQOS lpSQOS,LPQOS lpGQOS,DWORD dwFlags,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPLISTEN)(SOCKET s,int backlog,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPRECV)(SOCKET s,LPWSABUF lpBuffers,DWORD dwBufferCount,LPDWORD lpNumberOfBytesRecvd,LPDWORD lpFlags,LPWSAOVERLAPPED lpOverlapped,LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,LPWSATHREADID lpThreadId,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPRECVDISCONNECT)(SOCKET s,LPWSABUF lpInboundDisconnectData,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPRECVFROM)(SOCKET s,LPWSABUF lpBuffers,DWORD dwBufferCount,LPDWORD lpNumberOfBytesRecvd,LPDWORD lpFlags,struct sockaddr *lpFrom,LPINT lpFromlen,LPWSAOVERLAPPED lpOverlapped,LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,LPWSATHREADID lpThreadId,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPSELECT)(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,const PTIMEVAL timeout,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPSEND)(SOCKET s,LPWSABUF lpBuffers,DWORD dwBufferCount,LPDWORD lpNumberOfBytesSent,DWORD dwFlags,LPWSAOVERLAPPED lpOverlapped,LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,LPWSATHREADID lpThreadId,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPSENDDISCONNECT)(SOCKET s,LPWSABUF lpOutboundDisconnectData,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPSENDTO)(SOCKET s,LPWSABUF lpBuffers,DWORD dwBufferCount,LPDWORD lpNumberOfBytesSent,DWORD dwFlags,const struct sockaddr *lpTo,int iTolen,LPWSAOVERLAPPED lpOverlapped,LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,LPWSATHREADID lpThreadId,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPSETSOCKOPT)(SOCKET s,int level,int optname,const char *optval,int optlen,LPINT lpErrno);
  typedef int (WSPAPI *LPWSPSHUTDOWN)(SOCKET s,int how,LPINT lpErrno);
  typedef SOCKET (WSPAPI *LPWSPSOCKET)(int af,int type,int protocol,LPWSAPROTOCOL_INFOW lpProtocolInfo,GROUP g,DWORD dwFlags,LPINT lpErrno);
  typedef INT (WSPAPI *LPWSPSTRINGTOADDRESS)(LPWSTR AddressString,INT AddressFamily,LPWSAPROTOCOL_INFOW lpProtocolInfo,LPSOCKADDR lpAddress,LPINT lpAddressLength,LPINT lpErrno);

  typedef struct _WSPPROC_TABLE {

    LPWSPACCEPT lpWSPAccept;
    LPWSPADDRESSTOSTRING lpWSPAddressToString;
    LPWSPASYNCSELECT lpWSPAsyncSelect;
    LPWSPBIND lpWSPBind;
    LPWSPCANCELBLOCKINGCALL lpWSPCancelBlockingCall;
    LPWSPCLEANUP lpWSPCleanup;
    LPWSPCLOSESOCKET lpWSPCloseSocket;
    LPWSPCONNECT lpWSPConnect;
    LPWSPDUPLICATESOCKET lpWSPDuplicateSocket;
    LPWSPENUMNETWORKEVENTS lpWSPEnumNetworkEvents;
    LPWSPEVENTSELECT lpWSPEventSelect;
    LPWSPGETOVERLAPPEDRESULT lpWSPGetOverlappedResult;
    LPWSPGETPEERNAME lpWSPGetPeerName;
    LPWSPGETSOCKNAME lpWSPGetSockName;
    LPWSPGETSOCKOPT lpWSPGetSockOpt;
    LPWSPGETQOSBYNAME lpWSPGetQOSByName;
    LPWSPIOCTL lpWSPIoctl;
    LPWSPJOINLEAF lpWSPJoinLeaf;
    LPWSPLISTEN lpWSPListen;
    LPWSPRECV lpWSPRecv;
    LPWSPRECVDISCONNECT lpWSPRecvDisconnect;
    LPWSPRECVFROM lpWSPRecvFrom;
    LPWSPSELECT lpWSPSelect;
    LPWSPSEND lpWSPSend;
    LPWSPSENDDISCONNECT lpWSPSendDisconnect;
    LPWSPSENDTO lpWSPSendTo;
    LPWSPSETSOCKOPT lpWSPSetSockOpt;
    LPWSPSHUTDOWN lpWSPShutdown;
    LPWSPSOCKET lpWSPSocket;
    LPWSPSTRINGTOADDRESS lpWSPStringToAddress;
  } WSPPROC_TABLE,*LPWSPPROC_TABLE;

  typedef WINBOOL (WSPAPI *LPWPUCLOSEEVENT)(WSAEVENT hEvent,LPINT lpErrno);
  typedef int (WSPAPI *LPWPUCLOSESOCKETHANDLE)(SOCKET s,LPINT lpErrno);
  typedef WSAEVENT (WSPAPI *LPWPUCREATEEVENT)(LPINT lpErrno);
  typedef SOCKET (WSPAPI *LPWPUCREATESOCKETHANDLE)(DWORD dwCatalogEntryId,DWORD_PTR dwContext,LPINT lpErrno);
  typedef int (WSPAPI *LPWPUFDISSET)(SOCKET s,fd_set *fdset);
  typedef int (WSPAPI *LPWPUGETPROVIDERPATH)(LPGUID lpProviderId,WCHAR *lpszProviderDllPath,LPINT lpProviderDllPathLen,LPINT lpErrno);
  typedef SOCKET (WSPAPI *LPWPUMODIFYIFSHANDLE)(DWORD dwCatalogEntryId,SOCKET ProposedHandle,LPINT lpErrno);
  typedef WINBOOL (WSPAPI *LPWPUPOSTMESSAGE)(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
  typedef int (WSPAPI *LPWPUQUERYBLOCKINGCALLBACK)(DWORD dwCatalogEntryId,LPBLOCKINGCALLBACK *lplpfnCallback,PDWORD_PTR lpdwContext,LPINT lpErrno);
  typedef int (WSPAPI *LPWPUQUERYSOCKETHANDLECONTEXT)(SOCKET s,PDWORD_PTR lpContext,LPINT lpErrno);
  typedef int (WSPAPI *LPWPUQUEUEAPC)(LPWSATHREADID lpThreadId,LPWSAUSERAPC lpfnUserApc,DWORD_PTR dwContext,LPINT lpErrno);
  typedef WINBOOL (WSPAPI *LPWPURESETEVENT)(WSAEVENT hEvent,LPINT lpErrno);
  typedef WINBOOL (WSPAPI *LPWPUSETEVENT)(WSAEVENT hEvent,LPINT lpErrno);
  typedef int (WSPAPI *LPWPUOPENCURRENTTHREAD)(LPWSATHREADID lpThreadId,LPINT lpErrno);
  typedef int (WSPAPI *LPWPUCLOSETHREAD)(LPWSATHREADID lpThreadId,LPINT lpErrno);
  typedef int (WSPAPI *LPWPUCOMPLETEOVERLAPPEDREQUEST)(SOCKET s,LPWSAOVERLAPPED lpOverlapped,DWORD dwError,DWORD cbTransferred,LPINT lpErrno);

  typedef struct _WSPUPCALLTABLE {
    LPWPUCLOSEEVENT lpWPUCloseEvent;
    LPWPUCLOSESOCKETHANDLE lpWPUCloseSocketHandle;
    LPWPUCREATEEVENT lpWPUCreateEvent;
    LPWPUCREATESOCKETHANDLE lpWPUCreateSocketHandle;
    LPWPUFDISSET lpWPUFDIsSet;
    LPWPUGETPROVIDERPATH lpWPUGetProviderPath;
    LPWPUMODIFYIFSHANDLE lpWPUModifyIFSHandle;
    LPWPUPOSTMESSAGE lpWPUPostMessage;
    LPWPUQUERYBLOCKINGCALLBACK lpWPUQueryBlockingCallback;
    LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
    LPWPUQUEUEAPC lpWPUQueueApc;
    LPWPURESETEVENT lpWPUResetEvent;
    LPWPUSETEVENT lpWPUSetEvent;
    LPWPUOPENCURRENTTHREAD lpWPUOpenCurrentThread;
    LPWPUCLOSETHREAD lpWPUCloseThread;
  } WSPUPCALLTABLE,*LPWSPUPCALLTABLE;

  typedef int (WSPAPI *LPWSPSTARTUP)(WORD wVersionRequested,LPWSPDATA lpWSPData,LPWSAPROTOCOL_INFOW lpProtocolInfo,WSPUPCALLTABLE UpcallTable,LPWSPPROC_TABLE lpProcTable);
  typedef int (WSPAPI *LPWSCENUMPROTOCOLS)(LPINT lpiProtocols,LPWSAPROTOCOL_INFOW lpProtocolBuffer,LPDWORD lpdwBufferLength,LPINT lpErrno);
  typedef int (WSPAPI *LPWSCDEINSTALLPROVIDER)(LPGUID lpProviderId,LPINT lpErrno);
  typedef int (WSPAPI *LPWSCINSTALLPROVIDER)(LPGUID lpProviderId,const WCHAR *lpszProviderDllPath,const LPWSAPROTOCOL_INFOW lpProtocolInfoList,DWORD dwNumberOfEntries,LPINT lpErrno);
  typedef int (WSPAPI *LPWSCGETPROVIDERPATH)(LPGUID lpProviderId,WCHAR *lpszProviderDllPath,LPINT lpProviderDllPathLen,LPINT lpErrno);
  typedef int (WSPAPI *LPWSCUPDATEPROVIDER)(LPGUID lpProviderId,const WCHAR *lpszProviderDllPath,const LPWSAPROTOCOL_INFOW lpProtocolInfoList,DWORD dwNumberOfEntries,LPINT lpErrno);
  typedef int (WSPAPI *LPWSCINSTALLQOSTEMPLATE)(const LPGUID Guid,LPWSABUF QosName,LPQOS Qos);
  typedef int (WSPAPI *LPWSCREMOVEQOSTEMPLATE)(const LPGUID Guid,LPWSABUF QosName);

  int WSPAPI WSPStartup(WORD wVersionRequested,LPWSPDATA lpWSPData,LPWSAPROTOCOL_INFOW lpProtocolInfo,WSPUPCALLTABLE UpcallTable,LPWSPPROC_TABLE lpProcTable);
  int WSPAPI WSCEnumProtocols(LPINT lpiProtocols,LPWSAPROTOCOL_INFOW lpProtocolBuffer,LPDWORD lpdwBufferLength,LPINT lpErrno);
  int WSPAPI WSCDeinstallProvider(LPGUID lpProviderId,LPINT lpErrno);
  int WSPAPI WSCInstallProvider(LPGUID lpProviderId,const WCHAR *lpszProviderDllPath,const LPWSAPROTOCOL_INFOW lpProtocolInfoList,DWORD dwNumberOfEntries,LPINT lpErrno);
  int WSPAPI WSCGetProviderPath(LPGUID lpProviderId,WCHAR *lpszProviderDllPath,LPINT lpProviderDllPathLen,LPINT lpErrno);
  int WSPAPI WSCUpdateProvider(LPGUID lpProviderId,const WCHAR *lpszProviderDllPath,const LPWSAPROTOCOL_INFOW lpProtocolInfoList,DWORD dwNumberOfEntries,LPINT lpErrno);
  int WSPAPI WSCInstallQOSTemplate (const LPGUID Guid,LPWSABUF QosName,LPQOS Qos);
  int WSPAPI WSCRemoveQOSTemplate (const LPGUID Guid,LPWSABUF QosName);

#ifdef _WIN64
  int WSPAPI WSCEnumProtocols32(LPINT lpiProtocols,LPWSAPROTOCOL_INFOW lpProtocolBuffer,LPDWORD lpdwBufferLength,LPINT lpErrno);
  int WSPAPI WSCDeinstallProvider32(LPGUID lpProviderId,LPINT lpErrno);
  int WSPAPI WSCInstallProvider64_32(LPGUID lpProviderId,const WCHAR *lpszProviderDllPath,const LPWSAPROTOCOL_INFOW lpProtocolInfoList,DWORD dwNumberOfEntries,LPINT lpErrno);
  int WSPAPI WSCGetProviderPath32(LPGUID lpProviderId,WCHAR *lpszProviderDllPath,LPINT lpProviderDllPathLen,LPINT lpErrno);
  int WSPAPI WSCUpdateProvider32(LPGUID lpProviderId,const WCHAR *lpszProviderDllPath,const LPWSAPROTOCOL_INFOW lpProtocolInfoList,DWORD dwNumberOfEntries,LPINT lpErrno);
#endif

  WINBOOL WSPAPI WPUCloseEvent(WSAEVENT hEvent,LPINT lpErrno);
  int WSPAPI WPUCloseSocketHandle(SOCKET s,LPINT lpErrno);
  WSAEVENT WSPAPI WPUCreateEvent(LPINT lpErrno);
  SOCKET WSPAPI WPUCreateSocketHandle(DWORD dwCatalogEntryId,DWORD_PTR dwContext,LPINT lpErrno);
  int WSPAPI WPUFDIsSet(SOCKET s,fd_set *fdset);
  int WSPAPI WPUGetProviderPath(LPGUID lpProviderId,WCHAR *lpszProviderDllPath,LPINT lpProviderDllPathLen,LPINT lpErrno);
  SOCKET WSPAPI WPUModifyIFSHandle(DWORD dwCatalogEntryId,SOCKET ProposedHandle,LPINT lpErrno);
  WINBOOL WSPAPI WPUPostMessage(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
  int WSPAPI WPUQueryBlockingCallback(DWORD dwCatalogEntryId,LPBLOCKINGCALLBACK *lplpfnCallback,PDWORD_PTR lpdwContext,LPINT lpErrno);
  int WSPAPI WPUQuerySocketHandleContext(SOCKET s,PDWORD_PTR lpContext,LPINT lpErrno);
  int WSPAPI WPUQueueApc(LPWSATHREADID lpThreadId,LPWSAUSERAPC lpfnUserApc,DWORD_PTR dwContext,LPINT lpErrno);
  WINBOOL WSPAPI WPUResetEvent(WSAEVENT hEvent,LPINT lpErrno);
  WINBOOL WSPAPI WPUSetEvent(WSAEVENT hEvent,LPINT lpErrno);
  int WSPAPI WPUCompleteOverlappedRequest (SOCKET s,LPWSAOVERLAPPED lpOverlapped,DWORD dwError,DWORD cbTransferred,LPINT lpErrno);
  int WSPAPI WPUOpenCurrentThread(LPWSATHREADID lpThreadId,LPINT lpErrno);
  int WSPAPI WPUCloseThread(LPWSATHREADID lpThreadId,LPINT lpErrno);
#define WSCEnumNameSpaceProviders WSAEnumNameSpaceProvidersW
#define LPFN_WSCENUMNAMESPACEPROVIDERS LPFN_WSAENUMNAMESPACEPROVIDERSW

#ifdef _WIN64
  INT WSAAPI WSCEnumNameSpaceProviders32(LPDWORD lpdwBufferLength,LPWSANAMESPACE_INFOW lpnspBuffer);
#endif

  typedef INT (WSPAPI *LPWSCINSTALLNAMESPACE)(LPWSTR lpszIdentifier,LPWSTR lpszPathName,DWORD dwNameSpace,DWORD dwVersion,LPGUID lpProviderId);
  typedef INT (WSPAPI *LPWSCUNINSTALLNAMESPACE)(LPGUID lpProviderId);
  typedef INT (WSPAPI *LPWSCENABLENSPROVIDER)(LPGUID lpProviderId,WINBOOL fEnable);

  INT WSPAPI WSCInstallNameSpace (LPWSTR lpszIdentifier,LPWSTR lpszPathName,DWORD dwNameSpace,DWORD dwVersion,LPGUID lpProviderId);
  INT WSPAPI WSCUnInstallNameSpace (LPGUID lpProviderId);
  INT WSPAPI WSCEnableNSProvider (LPGUID lpProviderId,WINBOOL fEnable);

#ifdef _WIN64
  INT WSPAPI WSCInstallNameSpace32 (LPWSTR lpszIdentifier,LPWSTR lpszPathName,DWORD dwNameSpace,DWORD dwVersion,LPGUID lpProviderId);
  INT WSPAPI WSCUnInstallNameSpace32 (LPGUID lpProviderId);
  INT WSPAPI WSCEnableNSProvider32 (LPGUID lpProviderId,WINBOOL fEnable);
#endif

  typedef INT (WSAAPI *LPNSPCLEANUP)(LPGUID lpProviderId);
  typedef INT (WSAAPI *LPNSPLOOKUPSERVICEBEGIN)(LPGUID lpProviderId,LPWSAQUERYSETW lpqsRestrictions,LPWSASERVICECLASSINFOW lpServiceClassInfo,DWORD dwControlFlags,LPHANDLE lphLookup);
  typedef INT (WSAAPI *LPNSPLOOKUPSERVICENEXT)(HANDLE hLookup,DWORD dwControlFlags,LPDWORD lpdwBufferLength,LPWSAQUERYSETW lpqsResults);
  typedef INT (WSAAPI *LPNSPIOCTL)(HANDLE hLookup,DWORD dwControlCode,LPVOID lpvInBuffer,DWORD cbInBuffer,LPVOID lpvOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbBytesReturned,LPWSACOMPLETION lpCompletion,LPWSATHREADID lpThreadId);
  typedef INT (WSAAPI *LPNSPLOOKUPSERVICEEND)(HANDLE hLookup);
  typedef INT (WSAAPI *LPNSPSETSERVICE)(LPGUID lpProviderId,LPWSASERVICECLASSINFOW lpServiceClassInfo,LPWSAQUERYSETW lpqsRegInfo,WSAESETSERVICEOP essOperation,DWORD dwControlFlags);
  typedef INT (WSAAPI *LPNSPINSTALLSERVICECLASS)(LPGUID lpProviderId,LPWSASERVICECLASSINFOW lpServiceClassInfo);
  typedef INT (WSAAPI *LPNSPREMOVESERVICECLASS)(LPGUID lpProviderId,LPGUID lpServiceClassId);
  typedef INT (WSAAPI *LPNSPGETSERVICECLASSINFO)(LPGUID lpProviderId,LPDWORD lpdwBufSize,LPWSASERVICECLASSINFOW lpServiceClassInfo);

  typedef struct _NSP_ROUTINE {
    DWORD cbSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    LPNSPCLEANUP NSPCleanup;
    LPNSPLOOKUPSERVICEBEGIN NSPLookupServiceBegin;
    LPNSPLOOKUPSERVICENEXT NSPLookupServiceNext;
    LPNSPLOOKUPSERVICEEND NSPLookupServiceEnd;
    LPNSPSETSERVICE NSPSetService;
    LPNSPINSTALLSERVICECLASS NSPInstallServiceClass;
    LPNSPREMOVESERVICECLASS NSPRemoveServiceClass;
    LPNSPGETSERVICECLASSINFO NSPGetServiceClassInfo;
    LPNSPIOCTL NSPIoctl;
  } NSP_ROUTINE,*LPNSP_ROUTINE;

  typedef INT (WSAAPI *LPNSPSTARTUP)(LPGUID lpProviderId,LPNSP_ROUTINE lpnspRoutines);

  INT WSAAPI NSPStartup(LPGUID lpProviderId,LPNSP_ROUTINE lpnspRoutines);

#if (_WIN32_WINNT >= 0x0600)

typedef int (WSAAPI *LPNSPV2CLEANUP)(
  LPGUID lpProviderId,
  LPVOID pvClientSessionArg
);

typedef int (WSAAPI *LPNSPV2CLIENTSESSIONRUNDOWN)(
  LPGUID lpProviderId,
  LPVOID pvClientSessionArg
);

typedef int (WSAAPI *LPNSPV2LOOKUPSERVICEBEGIN)(
  LPGUID lpProviderId,
  LPWSAQUERYSET2W lpqsRestrictions,
  DWORD dwControlFlags,
  LPVOID lpvClientSessionArg,
  LPHANDLE lphLookup
);

typedef int (WSAAPI *LPNSPV2LOOKUPSERVICEEND)(
  HANDLE hLookup
);

typedef int (WSAAPI *LPNSPV2LOOKUPSERVICENEXTEX)(
  HANDLE hAsyncCall,
  HANDLE hLookup,
  DWORD dwControlFlags,
  LPDWORD lpdwBufferLength,
  LPWSAQUERYSET2W lpqsResults
);

typedef int (WSAAPI *LPNSPV2SETSERVICEEX)(
  HANDLE hAsyncCall,
  LPGUID lpProviderId,
  LPWSAQUERYSET2W lpqsRegInfo,
  WSAESETSERVICEOP essOperation,
  DWORD dwControlFlags,
  LPVOID lpvClientSessionArg
);

typedef int (WSAAPI *LPNSPV2STARTUP)(
  LPGUID lpProviderId,
  LPVOID *ppvClientSessionArg
);

typedef struct _NSPV2_ROUTINE {
  DWORD                       cbSize;
  DWORD                       dwMajorVersion;
  DWORD                       dwMinorVersion;
  LPNSPV2STARTUP              NSPv2Startup;
  LPNSPV2CLEANUP              NSPv2Cleanup;
  LPNSPV2LOOKUPSERVICEBEGIN   NSPv2LookupServiceBegin;
  LPNSPV2LOOKUPSERVICENEXTEX  NSPv2LookupServiceNextEx;
  LPNSPV2LOOKUPSERVICEEND     NSPv2LookupServiceEnd;
  LPNSPV2SETSERVICEEX         NSPv2SetServiceEx;
  LPNSPV2CLIENTSESSIONRUNDOWN NSPv2ClientSessionRundown;
} NSPV2_ROUTINE, *PNSPV2_ROUTINE, *LPCNSPV2_ROUTINE;

#define LSP_SYSTEM          0x80000000
#define LSP_INSPECTOR       0x00000001
#define LSP_REDIRECTOR      0x00000002
#define LSP_PROXY           0x00000004
#define LSP_FIREWALL        0x00000008
#define LSP_INBOUND_MODIFY  0x00000010
#define LSP_OUTBOUND_MODIFY 0x00000020
#define LSP_CRYPTO_COMPRESS 0x00000040
#define LSP_LOCAL_CACHE     0x00000080

typedef enum _WSC_PROVIDER_INFO_TYPE {
  ProviderInfoLspCategories = 0,
  ProviderInfoAudit
} WSC_PROVIDER_INFO_TYPE;

typedef struct _WSC_PROVIDER_AUDIT_INFO {
  DWORD RecordSize;
  PVOID Reserved;
} WSC_PROVIDER_AUDIT_INFO, *PWSC_PROVIDER_AUDIT_INFO;

INT WSAAPI WSAAdvertiseProvider(
  const GUID *puuidProviderId,
  const LPCNSPV2_ROUTINE *pNSPv2Routine
);

INT WSPAPI WSAProviderCompleteAsyncCall(
  HANDLE hAsyncCall,
  INT iRetCode
);

INT WSPAPI WSAUnadvertiseProvider(
  const GUID *puuidProviderId
);

int WSPAPI WSCGetApplicationCategory(
  LPCWSTR Path,
  DWORD PathLength,
  LPCWSTR Extra,
  DWORD ExtraLength,
  DWORD *pPermittedLspCategories,
  LPINT lpErrno
);

int WSPAPI WSCGetProviderInfo(
  LPGUID lpProviderId,
  WSC_PROVIDER_INFO_TYPE InfoType,
  PBYTE Info,
  size_t *InfoSize,
  DWORD Flags,
  LPINT lpErrno
);

#ifndef _WIN64
int WSPAPI WSCInstallProviderAndChains(
  const LPGUID lpProviderId,
  const LPWSTR lpszProviderDllPath,
  const LPWSTR lpszLspName,
  DWORD dwServiceFlags,
  const LPWSAPROTOCOL_INFO lpProtocolInfoList,
  DWORD dwNumberOfEntries,
  LPDWORD lpdwCatalogEntryId,
  LPINT lpErrno
);
#endif /* !_WIN64 */

int WSPAPI WSCSetApplicationCategory(
  LPCWSTR Path,
  DWORD PathLength,
  LPCWSTR Extra,
  DWORD ExtraLength,
  DWORD PermittedLspCategories,
  DWORD *pPrevPermLspCat,
  LPINT lpErrno
);

int WSPAPI WSCSetProviderInfo(
  LPGUID lpProviderId,
  WSC_PROVIDER_INFO_TYPE InfoType,
  PBYTE Info,
  size_t InfoSize,
  DWORD Flags,
  LPINT lpErrno
);

int WSAAPI WSCInstallNameSpaceEx(
  LPWSTR lpszIdentifier,
  LPWSTR lpszPathName,
  DWORD dwNameSpace,
  DWORD dwVersion,
  LPGUID lpProviderId,
  LPBLOB lpProviderInfo
);

#define WSCEnumNameSpaceProvidersEx WSAEnumNameSpaceProvidersExW
#define LPFN_WSCENUMNAMESPACEPROVIDERSEX LPFN_WSAENUMNAMESPACEPROVIDERSEXW

#ifdef _WIN64
INT WSPAPI WSCEnumNameSpaceProvidersEx32(
  LPDWORD lpdwBufferLength,
  LPWSANAMESPACE_INFOEXW lpnspBuffer
);

int WSPAPI WSCGetProviderInfo32(
  LPGUID lpProviderId,
  WSC_PROVIDER_INFO_TYPE InfoType,
  PBYTE Info,
  size_t *InfoSize,
  DWORD Flags,
  LPINT lpErrno
);

int WSAAPI WSCInstallNameSpaceEx32(
  LPWSTR lpszIdentifier,
  LPWSTR lpszPathName,
  DWORD dwNameSpace,
  DWORD dwVersion,
  LPGUID lpProviderId,
  LPBLOB lpProviderInfo
);

int WSPAPI WSCInstallProviderAndChains64_32(
  const LPGUID lpProviderId,
  const LPWSTR lpszProviderDllPath,
  const LPWSTR lpszProviderDllPath32,
  const LPWSTR lpszLspName,
  DWORD dwServiceFlags,
  const LPWSAPROTOCOL_INFO lpProtocolInfoList,
  DWORD dwNumberOfEntries,
  LPDWORD lpdwCatalogEntryId,
  LPINT lpErrno
);

int WSPAPI WSCSetProviderInfo32(
  LPGUID lpProviderId,
  WSC_PROVIDER_INFO_TYPE InfoType,
  PBYTE Info,
  size_t InfoSize,
  DWORD Flags,
  LPINT lpErrno
);

#endif /* _WIN64*/

#endif /*(_WIN32_WINNT >= 0x0600)*/

#ifdef __cplusplus
}
#endif

#if !defined(_WIN64)
#include <poppack.h>
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/ws2tcpip.h                                                              0100644 0000000 0000000 00000041062 12404413016 016264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WS2TCPIP_H_
#define _WS2TCPIP_H_

#include <_mingw_unicode.h>

#include <winsock2.h>
#include <psdk_inc/_ip_mreq1.h>
#include <winapifamily.h>

struct ip_mreq_source {
  struct in_addr imr_multiaddr;
  struct in_addr imr_sourceaddr;
  struct in_addr imr_interface;
};

struct ip_msfilter {
  struct in_addr imsf_multiaddr;
  struct in_addr imsf_interface;
  u_long imsf_fmode;
  u_long imsf_numsrc;
  struct in_addr imsf_slist[1];
};

#define IP_MSFILTER_SIZE(numsrc) (sizeof(struct ip_msfilter)-sizeof(struct in_addr) + (numsrc)*sizeof(struct in_addr))

#define SIO_GET_INTERFACE_LIST _IOR('t',127,u_long)

#define SIO_GET_INTERFACE_LIST_EX _IOR('t',126,u_long)
#define SIO_SET_MULTICAST_FILTER _IOW('t',125,u_long)
#define SIO_GET_MULTICAST_FILTER _IOW('t',124 | IOC_IN,u_long)

#define IP_OPTIONS 1
#define IP_HDRINCL 2
#define IP_TOS 3
#define IP_TTL 4
#define IP_MULTICAST_IF 9
#define IP_MULTICAST_TTL 10
#define IP_MULTICAST_LOOP 11
#define IP_ADD_MEMBERSHIP 12
#define IP_DROP_MEMBERSHIP 13
#define IP_DONTFRAGMENT 14
#define IP_ADD_SOURCE_MEMBERSHIP 15
#define IP_DROP_SOURCE_MEMBERSHIP 16
#define IP_BLOCK_SOURCE 17
#define IP_UNBLOCK_SOURCE 18
#define IP_PKTINFO 19
#define IP_RECEIVE_BROADCAST 22

#define PROTECTION_LEVEL_UNRESTRICTED 10
#define PROTECTION_LEVEL_DEFAULT 20
#define PROTECTION_LEVEL_RESTRICTED 30

#define UDP_NOCHECKSUM 1
#define UDP_CHECKSUM_COVERAGE 20

#define TCP_EXPEDITED_1122 0x0002


#include <ws2ipdef.h>


#define SS_PORT(ssp) (((struct sockaddr_in*)(ssp))->sin_port)

#define IN6ADDR_ANY_INIT { 0 }
#define IN6ADDR_LOOPBACK_INIT { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

#ifdef __cplusplus
extern "C" {
#endif

  extern const struct in6_addr in6addr_any;
  extern const struct in6_addr in6addr_loopback;

#define WS2TCPIP_INLINE __CRT_INLINE

int IN6_ADDR_EQUAL(const struct in6_addr *,const struct in6_addr *);
int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);
int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);
int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);
int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);
int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);
int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);
int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);
int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);
int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);
int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);
int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);
int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);
int IN6ADDR_ISANY(const struct sockaddr_in6 *);
int IN6ADDR_ISLOOPBACK(const struct sockaddr_in6 *);
void IN6_SET_ADDR_UNSPECIFIED(struct in6_addr *);
void IN6_SET_ADDR_LOOPBACK(struct in6_addr *);
void IN6ADDR_SETANY(struct sockaddr_in6 *);
void IN6ADDR_SETLOOPBACK(struct sockaddr_in6 *);

WS2TCPIP_INLINE int IN6_ADDR_EQUAL(const struct in6_addr *a,const struct in6_addr *b) { return (memcmp(a,b,sizeof(struct in6_addr))==0); }
WS2TCPIP_INLINE int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *a) { return ((a->s6_words[0]==0) && (a->s6_words[1]==0) && (a->s6_words[2]==0) && (a->s6_words[3]==0) && (a->s6_words[4]==0) && (a->s6_words[5]==0) && (a->s6_words[6]==0) && (a->s6_words[7]==0)); }
WS2TCPIP_INLINE int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *a) { return ((a->s6_words[0]==0) && (a->s6_words[1]==0) && (a->s6_words[2]==0) && (a->s6_words[3]==0) && (a->s6_words[4]==0) && (a->s6_words[5]==0) && (a->s6_words[6]==0) && (a->s6_words[7]==0x0100)); }
WS2TCPIP_INLINE int IN6_IS_ADDR_MULTICAST(const struct in6_addr *a) { return (a->s6_bytes[0]==0xff); }
WS2TCPIP_INLINE int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *a) { return ((a->s6_bytes[0]==0xfe) && ((a->s6_bytes[1] & 0xc0)==0x80)); }
WS2TCPIP_INLINE int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *a) { return ((a->s6_bytes[0]==0xfe) && ((a->s6_bytes[1] & 0xc0)==0xc0)); }
WS2TCPIP_INLINE int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *a) { return ((a->s6_words[0]==0) && (a->s6_words[1]==0) && (a->s6_words[2]==0) && (a->s6_words[3]==0) && (a->s6_words[4]==0) && (a->s6_words[5]==0xffff)); }
WS2TCPIP_INLINE int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *a) { return ((a->s6_words[0]==0) && (a->s6_words[1]==0) && (a->s6_words[2]==0) && (a->s6_words[3]==0) && (a->s6_words[4]==0) && (a->s6_words[5]==0) && !((a->s6_words[6]==0) && (a->s6_addr[14]==0) && ((a->s6_addr[15]==0) || (a->s6_addr[15]==1)))); }
WS2TCPIP_INLINE int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *a) { return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf)==1); }
WS2TCPIP_INLINE int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *a) { return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf)==2); }
WS2TCPIP_INLINE int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *a) { return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf)==5); }
WS2TCPIP_INLINE int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *a) { return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf)==8); }
WS2TCPIP_INLINE int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *a) { return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf)==0xe); }
WS2TCPIP_INLINE int IN6ADDR_ISANY(const struct sockaddr_in6 *a) { return ((a->sin6_family==AF_INET6) && IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr)); }
WS2TCPIP_INLINE int IN6ADDR_ISLOOPBACK(const struct sockaddr_in6 *a) { return ((a->sin6_family==AF_INET6) && IN6_IS_ADDR_LOOPBACK(&a->sin6_addr)); }
WS2TCPIP_INLINE void IN6_SET_ADDR_UNSPECIFIED(struct in6_addr *a) { memset(a->s6_bytes,0,sizeof(struct in6_addr)); }
WS2TCPIP_INLINE void IN6_SET_ADDR_LOOPBACK(struct in6_addr *a) {
  memset(a->s6_bytes,0,sizeof(struct in6_addr));
  a->s6_bytes[15] = 1;
}
WS2TCPIP_INLINE void IN6ADDR_SETANY(struct sockaddr_in6 *a) {
  a->sin6_family = AF_INET6;
  a->sin6_port = 0;
  a->sin6_flowinfo = 0;
  IN6_SET_ADDR_UNSPECIFIED(&a->sin6_addr);
  a->sin6_scope_id = 0;
}
WS2TCPIP_INLINE void IN6ADDR_SETLOOPBACK(struct sockaddr_in6 *a) {
  a->sin6_family = AF_INET6;
  a->sin6_port = 0;
  a->sin6_flowinfo = 0;
  IN6_SET_ADDR_LOOPBACK(&a->sin6_addr);
  a->sin6_scope_id = 0;
}

#ifdef __cplusplus
}
#endif

typedef struct _INTERFACE_INFO_EX {
  u_long iiFlags;
  SOCKET_ADDRESS iiAddress;
  SOCKET_ADDRESS iiBroadcastAddress;
  SOCKET_ADDRESS iiNetmask;
} INTERFACE_INFO_EX,*LPINTERFACE_INFO_EX;

#define IFF_UP 0x00000001
#define IFF_BROADCAST 0x00000002
#define IFF_LOOPBACK 0x00000004
#define IFF_POINTTOPOINT 0x00000008
#define IFF_MULTICAST 0x00000010

typedef struct in_pktinfo {
  IN_ADDR ipi_addr;
  UINT ipi_ifindex;
} IN_PKTINFO;

C_ASSERT(sizeof(IN_PKTINFO)==8);

typedef struct in6_pktinfo {
  IN6_ADDR ipi6_addr;
  UINT ipi6_ifindex;
} IN6_PKTINFO;

C_ASSERT(sizeof(IN6_PKTINFO)==20);

#define EAI_AGAIN WSATRY_AGAIN
#define EAI_BADFLAGS WSAEINVAL
#define EAI_FAIL WSANO_RECOVERY
#define EAI_FAMILY WSAEAFNOSUPPORT
#define EAI_MEMORY WSA_NOT_ENOUGH_MEMORY

#define EAI_NONAME WSAHOST_NOT_FOUND
#define EAI_SERVICE WSATYPE_NOT_FOUND
#define EAI_SOCKTYPE WSAESOCKTNOSUPPORT

#define EAI_NODATA 11004 /* WSANO_DATA */

#endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */

typedef struct addrinfo {
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  size_t ai_addrlen;
  char *ai_canonname;
  struct sockaddr *ai_addr;
  struct addrinfo *ai_next;
} ADDRINFOA,*PADDRINFOA;

typedef struct addrinfoW {
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  size_t ai_addrlen;
  PWSTR ai_canonname;
  struct sockaddr *ai_addr;
  struct addrinfoW *ai_next;
} ADDRINFOW,*PADDRINFOW;

typedef __MINGW_NAME_AW(ADDRINFO) ADDRINFOT,*PADDRINFOT;

typedef ADDRINFOA ADDRINFO,*LPADDRINFO;

#define AI_PASSIVE 0x1
#define AI_CANONNAME 0x2
#define AI_NUMERICHOST 0x4
#if (_WIN32_WINNT >= 0x0600)
#define AI_ADDRCONFIG             0x0400
#define AI_NON_AUTHORITATIVE      0x04000
#define AI_SECURE                 0x08000
#define AI_RETURN_PREFERRED_NAMES 0x010000
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define GetAddrInfo __MINGW_NAME_AW(GetAddrInfo)

  WINSOCK_API_LINKAGE int WSAAPI getaddrinfo(const char *nodename,const char *servname,const struct addrinfo *hints,struct addrinfo **res);
  WINSOCK_API_LINKAGE int WSAAPI GetAddrInfoW(PCWSTR pNodeName,PCWSTR pServiceName,const ADDRINFOW *pHints,PADDRINFOW *ppResult);

#define GetAddrInfoA getaddrinfo

#if INCL_WINSOCK_API_TYPEDEFS
  typedef int (WSAAPI *LPFN_GETADDRINFO)(const char *nodename,const char *servname,const struct addrinfo *hints,struct addrinfo **res);
  typedef int (WSAAPI *LPFN_GETADDRINFOW)(PCWSTR pNodeName,PCWSTR pServiceName,const ADDRINFOW *pHints,PADDRINFOW *ppResult);

#define LPFN_GETADDRINFOA LPFN_GETADDRINFO

#define LPFN_GETADDRINFOT __MINGW_NAME_AW(LPFN_GETADDRINFO)
#endif

#define FreeAddrInfo __MINGW_NAME_AW(FreeAddrInfo)

  WINSOCK_API_LINKAGE void WSAAPI freeaddrinfo(LPADDRINFO pAddrInfo);
  WINSOCK_API_LINKAGE void WSAAPI FreeAddrInfoW(PADDRINFOW pAddrInfo);

#define FreeAddrInfoA freeaddrinfo

#if INCL_WINSOCK_API_TYPEDEFS
  typedef void (WSAAPI *LPFN_FREEADDRINFO)(struct addrinfo *ai);
  typedef void (WSAAPI *LPFN_FREEADDRINFOW)(PADDRINFOW pAddrInfo);

#define LPFN_FREEADDRINFOA LPFN_FREEADDRINFO

#define LPFN_FREEADDRINFOT __MINGW_NAME_AW(LPFN_FREEADDRINFO)
#endif

  typedef int socklen_t;

#define GetNameInfo __MINGW_NAME_AW(GetNameInfo)

  WINSOCK_API_LINKAGE int WSAAPI getnameinfo(const struct sockaddr *sa,socklen_t salen,char *host,DWORD hostlen,char *serv,DWORD servlen,int flags);
  WINSOCK_API_LINKAGE INT WSAAPI GetNameInfoW(const SOCKADDR *pSockaddr,socklen_t SockaddrLength,PWCHAR pNodeBuffer,DWORD NodeBufferSize,PWCHAR pServiceBuffer,DWORD ServiceBufferSize,INT Flags);

#define GetNameInfoA getnameinfo

#if INCL_WINSOCK_API_TYPEDEFS
  typedef int (WSAAPI *LPFN_GETNAMEINFO)(const struct sockaddr *sa,socklen_t salen,char *host,DWORD hostlen,char *serv,DWORD servlen,int flags);
  typedef INT (WSAAPI *LPFN_GETNAMEINFOW)(const SOCKADDR *pSockaddr,socklen_t SockaddrLength,PWCHAR pNodeBuffer,DWORD NodeBufferSize,PWCHAR pServiceBuffer,DWORD ServiceBufferSize,INT Flags);

#define LPFN_GETNAMEINFOA LPFN_GETNAMEINFO

#define LPFN_GETNAMEINFOT __MINGW_NAME_AW(LPFN_GETNAMEINFO)
#endif

#define gai_strerror __MINGW_NAME_AW(gai_strerror)

#define GAI_STRERROR_BUFFER_SIZE 1024

char *gai_strerrorA (int);
WCHAR *gai_strerrorW(int);

#define NI_MAXHOST 1025
#define NI_MAXSERV 32

#define INET_ADDRSTRLEN 22
#define INET6_ADDRSTRLEN 65

#define NI_NOFQDN 0x01
#define NI_NUMERICHOST 0x02
#define NI_NAMEREQD 0x04
#define NI_NUMERICSERV 0x08
#define NI_DGRAM 0x10

#include <mstcpip.h>

#if (_WIN32_WINNT >= 0x0600)
#define addrinfoEx __MINGW_NAME_AW(addrinfoEx)
#define PADDRINFOEX __MINGW_NAME_AW(PADDRINFOEX)
#define GetAddrInfoEx __MINGW_NAME_AW(GetAddrInfoEx)
#define SetAddrInfoEx __MINGW_NAME_AW(SetAddrInfoEx)
#define FreeAddrInfoEx __MINGW_NAME_AW(FreeAddrInfoEx)

  typedef struct addrinfoExA {
    int                ai_flags;
    int                ai_family;
    int                ai_socktype;
    int                ai_protocol;
    size_t             ai_addrlen;
    LPCSTR             ai_canonname;
    struct sockaddr    *ai_addr;
    void               *ai_blob;
    size_t             ai_bloblen;
    LPGUID             ai_provider;
    struct addrinfoexA *ai_next;
  } ADDRINFOEXA, *PADDRINFOEXA;

  typedef struct addrinfoExW {
    int                ai_flags;
    int                ai_family;
    int                ai_socktype;
    int                ai_protocol;
    size_t             ai_addrlen;
    LPCWSTR            ai_canonname;
    struct sockaddr    *ai_addr;
    void               *ai_blob;
    size_t             ai_bloblen;
    LPGUID             ai_provider;
    struct addrinfoexW *ai_next;
  } ADDRINFOEXW, *PADDRINFOEXW;

typedef PVOID LPLOOKUPSERVICE_COMPLETION_ROUTINE; /*reserved*/

WINSOCK_API_LINKAGE int WSAAPI GetAddrInfoExA(PCSTR pName, PCSTR pServiceName, DWORD dwNameSpace,
					      LPGUID lpNspId,const ADDRINFOEXA *pHints,PADDRINFOEXA *ppResult,
					      PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					      LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					      LPHANDLE lpNameHandle);
WINSOCK_API_LINKAGE int WSAAPI GetAddrInfoExW(PCWSTR pName,PCWSTR pServiceName,DWORD dwNameSpace,
					      LPGUID lpNspId,const ADDRINFOEXW *pHints,PADDRINFOEXW *ppResult,
					      PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					      LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					      LPHANDLE lpNameHandle);

WINSOCK_API_LINKAGE int WSAAPI SetAddrInfoExA(PCSTR pName, PCSTR pServiceName, SOCKET_ADDRESS *pAddresses,
					      DWORD dwAddressCount,LPBLOB lpBlob,DWORD dwFlags,DWORD dwNameSpace,
					      LPGUID lpNspId,PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					      LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					      LPHANDLE lpNameHandle);
WINSOCK_API_LINKAGE int WSAAPI SetAddrInfoExW(PCWSTR pName,PCWSTR pServiceName,SOCKET_ADDRESS *pAddresses,
					      DWORD dwAddressCount,LPBLOB lpBlob,DWORD dwFlags,DWORD dwNameSpace,
					      LPGUID lpNspId,PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					      LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					      LPHANDLE lpNameHandle);

WINSOCK_API_LINKAGE void WSAAPI FreeAddrInfoExA(PADDRINFOEXA pAddrInfo);
WINSOCK_API_LINKAGE void WSAAPI FreeAddrInfoExW(PADDRINFOEXW pAddrInfo);

#if INCL_WINSOCK_API_TYPEDEFS
#define LPFN_GETADDRINFOEX __MINGW_NAME_AW(LPFN_GETADDRINFOEX)
  typedef int (WSAAPI *LPFN_GETADDRINFOEXA)(PCSTR pName, PCSTR pServiceName, DWORD dwNameSpace,
					    LPGUID lpNspId,const ADDRINFOEXA *pHints,PADDRINFOEXA *ppResult,
					    PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					    LPHANDLE lpNameHandle);
  typedef int (WSAAPI *LPFN_GETADDRINFOEXW)(PCWSTR pName,PCWSTR pServiceName,DWORD dwNameSpace,
					    LPGUID lpNspId,const ADDRINFOEXW *pHints,PADDRINFOEXW *ppResult,
					    PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					    LPHANDLE lpNameHandle);

#define LPFN_SETADDRINFOEX __MINGW_NAME_AW(LPFN_SETADDRINFOEX)
  typedef int (WSAAPI *LPFN_SETADDRINFOEXA)(PCSTR pName, PCSTR pServiceName, SOCKET_ADDRESS *pAddresses,
					    DWORD dwAddressCount,LPBLOB lpBlob,DWORD dwFlags,DWORD dwNameSpace,
					    LPGUID lpNspId,PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					    LPHANDLE lpNameHandle);
  typedef int (WSAAPI *LPFN_SETADDRINFOEXW)(PCWSTR pName,PCWSTR pServiceName,SOCKET_ADDRESS *pAddresses,
					    DWORD dwAddressCount,LPBLOB lpBlob,DWORD dwFlags,DWORD dwNameSpace,
					    LPGUID lpNspId,PTIMEVAL timeout,LPOVERLAPPED lpOverlapped,
					    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
					    LPHANDLE lpNameHandle);

#define LPFN_FREEADDRINFOEX __MINGW_NAME_AW(LPFN_FREEADDRINFOEX)
  typedef void (WSAAPI *LPFN_FREEADDRINFOEXA)(PADDRINFOEXA pAddrInfo);
  typedef void (WSAAPI *LPFN_FREEADDRINFOEXW)(PADDRINFOEXW pAddrInfo);
#endif /* INCL_WINSOCK_API_TYPEDEFS */


WINSOCK_API_LINKAGE int WSAAPI WSAImpersonateSocketPeer(
  SOCKET Socket,
  const struct sockaddr *PeerAddress,
  ULONG peerAddressLen
);

WINSOCK_API_LINKAGE int WSAAPI WSAQuerySocketSecurity(
  SOCKET Socket,
  const SOCKET_SECURITY_QUERY_TEMPLATE *SecurityQueryTemplate,
  ULONG SecurityQueryTemplateLen,
  SOCKET_SECURITY_QUERY_INFO *SecurityQueryInfo,
  ULONG *SecurityQueryInfoLen,
  LPWSAOVERLAPPED Overlapped,
  LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE int WSAAPI WSARevertImpersonation(void);

WINSOCK_API_LINKAGE int WSAAPI WSASetSocketPeerTargetName(
  SOCKET Socket,
  const SOCKET_PEER_TARGET_NAME *PeerTargetName,
  ULONG PeerTargetNameLen,
  LPWSAOVERLAPPED Overlapped,
  LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE int WSAAPI WSASetSocketSecurity(
  SOCKET Socket,
  const SOCKET_SECURITY_SETTINGS *SecuritySettings,
  ULONG SecuritySettingsLen,
  LPWSAOVERLAPPED Overlapped,
  LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

#define InetNtopA inet_ntop

WINSOCK_API_LINKAGE LPCWSTR WSAAPI InetNtopW(INT Family, PVOID pAddr, LPWSTR pStringBuf, size_t StringBufSIze);
WINSOCK_API_LINKAGE LPCSTR WSAAPI InetNtopA(INT Family, PVOID pAddr, LPSTR pStringBuf, size_t StringBufSize);

#define InetNtop __MINGW_NAME_AW(InetNtop)

#define InetPtonA inet_pton

WINSOCK_API_LINKAGE INT WSAAPI InetPtonW(INT Family, LPCWSTR pStringBuf, PVOID pAddr);
WINSOCK_API_LINKAGE INT WSAAPI InetPtonA(INT Family, LPCSTR pStringBuf, PVOID pAddr);

#define InetPton __MINGW_NAME_AW(InetPton)

#endif /*(_WIN32_WINNT >= 0x0600)*/

#ifdef __cplusplus
}
#endif

#endif /* _WS2TCPIP_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/share/mingw-w64/include/wsdapi.h                                                                0100644 0000000 0000000 00000003424 12404413016 016000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDAPI
#define _INC_WSDAPI
#if (_WIN32_WINNT >= 0x0600)

#ifdef __cplusplus
extern "C" {
#endif

typedef struct IWSDAsyncResult IWSDAsyncResult;
typedef struct IWSDServiceProxy IWSDServiceProxy;
typedef struct IWSDEndpointProxy IWSDEndpointProxy;

typedef struct IWSDMessageParameters IWSDMessageParameters;
typedef struct IWSDServiceMessaging IWSDServiceMessaging;

typedef struct _WSD_EVENT WSD_EVENT;
typedef struct _WSD_SOAP_FAULT_SUBCODE WSD_SOAP_FAULT_SUBCODE;
typedef struct _WSD_LOCALIZED_STRING_LIST WSD_LOCALIZED_STRING_LIST;
typedef struct _WSD_URI_LIST WSD_URI_LIST;
typedef struct _WSD_NAME_LIST WSD_NAME_LIST;
typedef struct _WSD_SERVICE_METADATA_LIST WSD_SERVICE_METADATA_LIST;
typedef struct _WSD_PROBE_MATCH_LIST WSD_PROBE_MATCH_LIST;

typedef struct _WSDXML_NAME WSDXML_NAME;
typedef struct _WSDXML_ELEMENT WSDXML_ELEMENT;
typedef struct _WSDXML_NODE WSDXML_NODE;
typedef struct _WSDXML_ATTRIBUTE WSDXML_ATTRIBUTE;
typedef struct _WSDXML_PREFIX_MAPPING WSDXML_PREFIX_MAPPING;
typedef struct _WSDXML_ELEMENT_LIST WSDXML_ELEMENT_LIST;
typedef struct _WSDXML_TYPE WSDXML_TYPE;
typedef struct _WSD_METADATA_SECTION_LIST WSD_METADATA_SECTION_LIST;
typedef struct _WSD_METADATA_SECTION WSD_METADATA_SECTION;
typedef struct _WSD_ENDPOINT_REFERENCE_LIST WSD_ENDPOINT_REFERENCE_LIST;

#ifdef __cplusplus
}
#endif

#include <wsdtypes.h>
#include <wsdbase.h>
#include <wsdxmldom.h>
#include <wsdxml.h>
#include <wsdhost.h>
#include <wsdutil.h>
#include <wsdclient.h>
#include <wsddisco.h>
#include <wsdattachment.h>

#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDAPI*/
                                                                                                                                                                                                                                            usr/share/mingw-w64/include/wsdattachment.h                                                         0100644 0000000 0000000 00000010143 12404413016 017353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDATTACHMENT
#define _INC_WSDATTACHMENT

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#undef  INTERFACE
#define INTERFACE IWSDAttachment
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDAttachment,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDAttachment methods */

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDAttachment_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDAttachment_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDAttachment_Release(This) (This)->lpVtbl->Release(This)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDInboundAttachment
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDInboundAttachment,IWSDAttachment)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDAttachment methods */

    /* IWSDInboundAttachment methods */
    STDMETHOD_(HRESULT,Read)(THIS_ BYTE *pBuffer,DWORD dwBytesToRead,LPDWORD pdwNumberofBytesRead) PURE;
    STDMETHOD_(HRESULT,Close)(THIS) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDInboundAttachment_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDInboundAttachment_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDInboundAttachment_Release(This) (This)->lpVtbl->Release(This)
#define IWSDInboundAttachment_Read(This,pBuffer,dwBytesToRead,pdwNumberofBytesRead) (This)->lpVtbl->Read(This,pBuffer,dwBytesToRead,pdwNumberofBytesRead)
#define IWSDInboundAttachment_Close() (This)->lpVtbl->Close(This)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDOutboundAttachment
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDOutboundAttachment,IWSDAttachment)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDAttachment methods */

    /* IWSDOutboundAttachment methods */
    STDMETHOD_(HRESULT,Write)(THIS_ const BYTE *pBuffer,DWORD dwBytesToWrite,LPDWORD pdwNumberofBytesWritten) PURE;
    STDMETHOD_(HRESULT,Close)(THIS) PURE;
    STDMETHOD_(HRESULT,Abort)(THIS) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDOutboundAttachment_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDOutboundAttachment_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDOutboundAttachment_Release(This) (This)->lpVtbl->Release(This)
#define IWSDOutboundAttachment_Write(This,pBuffer,dwBytesToWrite,pdwNumberofBytesWritten) (This)->lpVtbl->Write(This,pBuffer,dwBytesToWrite,pdwNumberofBytesWritten)
#define IWSDOutboundAttachment_Close() (This)->lpVtbl->Close(This)
#define IWSDOutboundAttachment_Abort() (This)->lpVtbl->Abort(This)
#endif /*COBJMACROS*/

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI WSDCreateOutboundAttachment(
  IWSDOutboundAttachment **attachmentOut
);

#ifdef __cplusplus
}
#endif

#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDATTACHMENT*/
                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/mingw-w64/include/wsdbase.h                                                               0100644 0000000 0000000 00000042371 12404413016 016145  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDBASE
#define _INC_WSDBASE

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#warning COM interfaces layout in this header has not been validated.
#warning COM interfaces with incorrect layout may not work at all.

typedef enum _WSDUdpMessageType {
  ONE_WAY   = 0,
  TWO_WAY   = 1 
} WSDUdpMessageType;

typedef struct _WSDUpdRetransmitParams {
  ULONG ulSendDelay;
  ULONG ulRepeat;
  ULONG ulRepeatMinDelay;
  ULONG ulRepeatMaxDelay;
  ULONG ulRepeatUpperDelay;
} WSDUdpRetransmitParams, *PWSDUdpRetransmitParams;

#undef  INTERFACE
#define INTERFACE IWSDTransportAddress
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDTransportAddress,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDTransportAddress methods */
    STDMETHOD_(HRESULT,GetPort)(THIS_ WORD *pwPort) PURE;
    STDMETHOD_(HRESULT,SetPort)(THIS_ WORD wPort) PURE;
    STDMETHOD_(HRESULT,GetTransportAddress)(THIS_ LPCWSTR *ppszAddress) PURE;
    STDMETHOD_(HRESULT,GetTransportAddressEx)(THIS_ WINBOOL fSafe,LPCWSTR *ppszAddress) PURE;
    STDMETHOD_(HRESULT,SetTransportAddress)(THIS_ LPCWSTR pszAddress) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDTransportAddress_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDTransportAddress_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDTransportAddress_Release(This) (This)->lpVtbl->Release(This)
#define IWSDTransportAddress_GetPort(This,pwPort) (This)->lpVtbl->GetPort(This,pwPort)
#define IWSDTransportAddress_SetPort(This,wPort) (This)->lpVtbl->SetPort(This,wPort)
#define IWSDTransportAddress_GetTransportAddress(This,ppszAddress) (This)->lpVtbl->GetTransportAddress(This,ppszAddress)
#define IWSDTransportAddress_GetTransportAddressEx(This,fSafe,ppszAddress) (This)->lpVtbl->GetTransportAddressEx(This,fSafe,ppszAddress)
#define IWSDTransportAddress_SetTransportAddress(This,pszAddress) (This)->lpVtbl->SetTransportAddress(This,pszAddress)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDHttpAddress
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDHttpAddress,IWSDTransportAddress)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDTransportAddress methods */
    STDMETHOD_(HRESULT,GetPort)(THIS_ WORD *pwPort) PURE;
    STDMETHOD_(HRESULT,SetPort)(THIS_ WORD wPort) PURE;
    STDMETHOD_(HRESULT,GetTransportAddress)(THIS_ LPCWSTR *ppszAddress) PURE;
    STDMETHOD_(HRESULT,GetTransportAddressEx)(THIS_ WINBOOL fSafe,LPCWSTR *ppszAddress) PURE;
    STDMETHOD_(HRESULT,SetTransportAddress)(THIS_ LPCWSTR pszAddress) PURE;

    /* IWSDHttpAddress methods */
    STDMETHOD_(HRESULT,GetSecure)(THIS) PURE;
    STDMETHOD_(HRESULT,SetSecure)(THIS_ WINBOOL fSecure) PURE;
    STDMETHOD_(HRESULT,GetPath)(THIS_ LPCWSTR *ppszPath) PURE;
    STDMETHOD_(HRESULT,SetPath)(THIS_ LPCWSTR pszPath) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDHttpAddress_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDHttpAddress_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDHttpAddress_Release(This) (This)->lpVtbl->Release(This)
#define IWSDHttpAddress_GetPort(This,pwPort) (This)->lpVtbl->GetPort(This,pwPort)
#define IWSDHttpAddress_SetPort(This,wPort) (This)->lpVtbl->SetPort(This,wPort)
#define IWSDHttpAddress_GetTransportAddress(This,ppszAddress) (This)->lpVtbl->GetTransportAddress(This,ppszAddress)
#define IWSDHttpAddress_GetTransportAddressEx(This,fSafe,ppszAddress) (This)->lpVtbl->GetTransportAddressEx(This,fSafe,ppszAddress)
#define IWSDHttpAddress_SetTransportAddress(This,pszAddress) (This)->lpVtbl->SetTransportAddress(This,pszAddress)
#define IWSDHttpAddress_GetSecure() (This)->lpVtbl->GetSecure(This)
#define IWSDHttpAddress_SetSecure(This,fSecure) (This)->lpVtbl->SetSecure(This,fSecure)
#define IWSDHttpAddress_GetPath(This,ppszPath) (This)->lpVtbl->GetPath(This,ppszPath)
#define IWSDHttpAddress_SetPath(This,pszPath) (This)->lpVtbl->SetPath(This,pszPath)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDUdpAddress
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDUdpAddress,IWSDTransportAddress)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDTransportAddress methods */
    STDMETHOD_(HRESULT,GetPort)(THIS_ WORD *pwPort) PURE;
    STDMETHOD_(HRESULT,SetPort)(THIS_ WORD wPort) PURE;
    STDMETHOD_(HRESULT,GetTransportAddress)(THIS_ LPCWSTR *ppszAddress) PURE;
    STDMETHOD_(HRESULT,GetTransportAddressEx)(THIS_ WINBOOL fSafe,LPCWSTR *ppszAddress) PURE;
    STDMETHOD_(HRESULT,SetTransportAddress)(THIS_ LPCWSTR pszAddress) PURE;

    /* IWSDUdpAddress methods */
    STDMETHOD_(HRESULT,SetSockaddr)(THIS_ const SOCKADDR_STORAGE *pSockAddr) PURE;
    STDMETHOD_(HRESULT *,GetSockaddr)(THIS_ SOCKADDR_STORAGE *pSockAddr) PURE;
    STDMETHOD_(HRESULT,SetExclusive)(THIS_ WINBOOL fExclusive) PURE;
    STDMETHOD_(HRESULT,GetExclusive)(THIS) PURE;
    STDMETHOD_(HRESULT,SetMessageType)(THIS_ WSDUdpMessageType messageType) PURE;
    STDMETHOD_(HRESULT,GetMessageType)(THIS_ WSDUdpMessageType *pMessageType) PURE;
    STDMETHOD_(HRESULT,SetTTL)(THIS_ DWORD dwTTL) PURE;
    STDMETHOD_(HRESULT,GetTTL)(THIS_ DWORD *pdwTTL) PURE;
    STDMETHOD_(HRESULT,SetAlias)(THIS_ const GUID *pAlias) PURE;
    STDMETHOD_(HRESULT,GetAlias)(THIS_ GUID *pAlias) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDUdpAddress_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDUdpAddress_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDUdpAddress_Release(This) (This)->lpVtbl->Release(This)
#define IWSDUdpAddress_GetPort(This,pwPort) (This)->lpVtbl->GetPort(This,pwPort)
#define IWSDUdpAddress_SetPort(This,wPort) (This)->lpVtbl->SetPort(This,wPort)
#define IWSDUdpAddress_GetTransportAddress(This,ppszAddress) (This)->lpVtbl->GetTransportAddress(This,ppszAddress)
#define IWSDUdpAddress_GetTransportAddressEx(This,fSafe,ppszAddress) (This)->lpVtbl->GetTransportAddressEx(This,fSafe,ppszAddress)
#define IWSDUdpAddress_SetTransportAddress(This,pszAddress) (This)->lpVtbl->SetTransportAddress(This,pszAddress)
#define IWSDUdpAddress_SetSockaddr(This,pSockAddr) (This)->lpVtbl->SetSockaddr(This,pSockAddr)
#define IWSDUdpAddress_GetSockaddr(This,pSockAddr) (This)->lpVtbl->GetSockaddr(This,pSockAddr)
#define IWSDUdpAddress_SetExclusive(This,fExclusive) (This)->lpVtbl->SetExclusive(This,fExclusive)
#define IWSDUdpAddress_GetExclusive() (This)->lpVtbl->GetExclusive(This)
#define IWSDUdpAddress_SetMessageType(This,messageType) (This)->lpVtbl->SetMessageType(This,messageType)
#define IWSDUdpAddress_GetMessageType(This,pMessageType) (This)->lpVtbl->GetMessageType(This,pMessageType)
#define IWSDUdpAddress_SetTTL(This,dwTTL) (This)->lpVtbl->SetTTL(This,dwTTL)
#define IWSDUdpAddress_GetTTL(This,pdwTTL) (This)->lpVtbl->GetTTL(This,pdwTTL)
#define IWSDUdpAddress_SetAlias(This,pAlias) (This)->lpVtbl->SetAlias(This,pAlias)
#define IWSDUdpAddress_GetAlias(This,pAlias) (This)->lpVtbl->GetAlias(This,pAlias)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDAddress
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDAddress,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDAddress methods */
    STDMETHOD_(HRESULT,Serialize)(THIS_ LPWSTR pszBuffer,DWORD cchLength,WINBOOL fSafe) PURE;
    STDMETHOD_(HRESULT,Deserialize)(THIS_ LPCWSTR pszBuffer) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDAddress_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDAddress_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDAddress_Release(This) (This)->lpVtbl->Release(This)
#define IWSDAddress_Serialize(This,pszBuffer,cchLength,fSafe) (This)->lpVtbl->Serialize(This,pszBuffer,cchLength,fSafe)
#define IWSDAddress_Deserialize(This,pszBuffer) (This)->lpVtbl->Deserialize(This,pszBuffer)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDMessageParameters
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDMessageParameters,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDServiceMessaging methods */
    STDMETHOD_(HRESULT,GetLocalAddress)(THIS_ IWSDAddress **ppAddress) PURE;
    STDMETHOD_(HRESULT,SetLocalAddress)(THIS_ IWSDAddress *pAddress) PURE;
    STDMETHOD_(HRESULT,GetRemoteAddress)(THIS_ IWSDAddress **ppAddress) PURE;
    STDMETHOD_(HRESULT,SetRemoteAddress)(THIS_ IWSDAddress *pAddress) PURE;
    STDMETHOD_(HRESULT,GetLowerParameters)(THIS_ IWSDMessageParameters **ppTxParams) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDMessageParameters_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDMessageParameters_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDMessageParameters_Release(This) (This)->lpVtbl->Release(This)
#define IWSDMessageParameters_GetLocalAddress(This,ppAddress) (This)->lpVtbl->GetLocalAddress(This,ppAddress)
#define IWSDMessageParameters_SetLocalAddress(This,pAddress) (This)->lpVtbl->SetLocalAddress(This,pAddress)
#define IWSDMessageParameters_GetRemoteAddress(This,ppAddress) (This)->lpVtbl->GetRemoteAddress(This,ppAddress)
#define IWSDMessageParameters_SetRemoteAddress(This,pAddress) (This)->lpVtbl->SetRemoteAddress(This,pAddress)
#define IWSDMessageParameters_GetLowerParameters(This,ppTxParams) (This)->lpVtbl->GetLowerParameters(This,ppTxParams)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDHttpMessageParameters
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDHttpMessageParameters,IWSDMessageParameters)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDServiceMessaging methods */
    STDMETHOD_(HRESULT,GetLocalAddress)(THIS_ IWSDAddress **ppAddress) PURE;
    STDMETHOD_(HRESULT,SetLocalAddress)(THIS_ IWSDAddress *pAddress) PURE;
    STDMETHOD_(HRESULT,GetRemoteAddress)(THIS_ IWSDAddress **ppAddress) PURE;
    STDMETHOD_(HRESULT,SetRemoteAddress)(THIS_ IWSDAddress *pAddress) PURE;
    STDMETHOD_(HRESULT,GetLowerParameters)(THIS_ IWSDMessageParameters **ppTxParams) PURE;

    /* IWSDHttpMessageParameters methods */
    STDMETHOD_(HRESULT,SetInboundHttpHeaders)(THIS_ LPCWSTR pszHeaders) PURE;
    STDMETHOD_(HRESULT,GetInboundHttpHeaders)(THIS_ LPCWSTR *ppszHeaders) PURE;
    STDMETHOD_(HRESULT,SetOutboundHttpHeaders)(THIS_ LPCWSTR pszHeaders) PURE;
    STDMETHOD_(HRESULT,GetOutboundHttpHeaders)(THIS_ LPCWSTR *ppszHeaders) PURE;
    STDMETHOD_(HRESULT,SetID)(THIS_ LPCWSTR pszId) PURE;
    STDMETHOD_(HRESULT,GetID)(THIS_ LPCWSTR *ppszId) PURE;
    STDMETHOD_(HRESULT,SetContext)(THIS_ IUnknown *pContext) PURE;
    STDMETHOD_(HRESULT,GetContext)(THIS_ IUnknown **ppContext) PURE;
    STDMETHOD_(HRESULT,Clear)(THIS) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDHttpMessageParameters_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDHttpMessageParameters_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDHttpMessageParameters_Release(This) (This)->lpVtbl->Release(This)
#define IWSDHttpMessageParameters_GetLocalAddress(This,ppAddress) (This)->lpVtbl->GetLocalAddress(This,ppAddress)
#define IWSDHttpMessageParameters_SetLocalAddress(This,pAddress) (This)->lpVtbl->SetLocalAddress(This,pAddress)
#define IWSDHttpMessageParameters_GetRemoteAddress(This,ppAddress) (This)->lpVtbl->GetRemoteAddress(This,ppAddress)
#define IWSDHttpMessageParameters_SetRemoteAddress(This,pAddress) (This)->lpVtbl->SetRemoteAddress(This,pAddress)
#define IWSDHttpMessageParameters_GetLowerParameters(This,ppTxParams) (This)->lpVtbl->GetLowerParameters(This,ppTxParams)
#define IWSDHttpMessageParameters_SetInboundHttpHeaders(This,pszHeaders) (This)->lpVtbl->SetInboundHttpHeaders(This,pszHeaders)
#define IWSDHttpMessageParameters_GetInboundHttpHeaders(This,ppszHeaders) (This)->lpVtbl->GetInboundHttpHeaders(This,ppszHeaders)
#define IWSDHttpMessageParameters_SetOutboundHttpHeaders(This,pszHeaders) (This)->lpVtbl->SetOutboundHttpHeaders(This,pszHeaders)
#define IWSDHttpMessageParameters_GetOutboundHttpHeaders(This,ppszHeaders) (This)->lpVtbl->GetOutboundHttpHeaders(This,ppszHeaders)
#define IWSDHttpMessageParameters_SetID(This,pszId) (This)->lpVtbl->SetID(This,pszId)
#define IWSDHttpMessageParameters_GetID(This,ppszId) (This)->lpVtbl->GetID(This,ppszId)
#define IWSDHttpMessageParameters_SetContext(This,pContext) (This)->lpVtbl->SetContext(This,pContext)
#define IWSDHttpMessageParameters_GetContext(This,ppContext) (This)->lpVtbl->GetContext(This,ppContext)
#define IWSDHttpMessageParameters_Clear() (This)->lpVtbl->Clear(This)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDUdpMessageParameters
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDUdpMessageParameters,IWSDMessageParameters)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDServiceMessaging methods */
    STDMETHOD_(HRESULT,GetLocalAddress)(THIS_ IWSDAddress **ppAddress) PURE;
    STDMETHOD_(HRESULT,SetLocalAddress)(THIS_ IWSDAddress *pAddress) PURE;
    STDMETHOD_(HRESULT,GetRemoteAddress)(THIS_ IWSDAddress **ppAddress) PURE;
    STDMETHOD_(HRESULT,SetRemoteAddress)(THIS_ IWSDAddress *pAddress) PURE;
    STDMETHOD_(HRESULT,GetLowerParameters)(THIS_ IWSDMessageParameters **ppTxParams) PURE;

    /* IWSDUdpMessageParameters methods */
    STDMETHOD_(HRESULT,SetRetransmitParams)(THIS_ const WSDUdpRetransmitParams *pParams) PURE;
    STDMETHOD_(HRESULT,GetRetransmitParams)(THIS_ WSDUdpRetransmitParams *pParams) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDUdpMessageParameters_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDUdpMessageParameters_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDUdpMessageParameters_Release(This) (This)->lpVtbl->Release(This)
#define IWSDUdpMessageParameters_GetLocalAddress(This,ppAddress) (This)->lpVtbl->GetLocalAddress(This,ppAddress)
#define IWSDUdpMessageParameters_SetLocalAddress(This,pAddress) (This)->lpVtbl->SetLocalAddress(This,pAddress)
#define IWSDUdpMessageParameters_GetRemoteAddress(This,ppAddress) (This)->lpVtbl->GetRemoteAddress(This,ppAddress)
#define IWSDUdpMessageParameters_SetRemoteAddress(This,pAddress) (This)->lpVtbl->SetRemoteAddress(This,pAddress)
#define IWSDUdpMessageParameters_GetLowerParameters(This,ppTxParams) (This)->lpVtbl->GetLowerParameters(This,ppTxParams)
#define IWSDUdpMessageParameters_SetRetransmitParams(This,pParams) (This)->lpVtbl->SetRetransmitParams(This,pParams)
#define IWSDUdpMessageParameters_GetRetransmitParams(This,pParams) (This)->lpVtbl->GetRetransmitParams(This,pParams)
#endif /*COBJMACROS*/

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI WSDCreateHttpAddress(
  IWSDHttpAddress **ppAddress
);

HRESULT WINAPI WSDCreateHttpMessageParameters(
  IWSDHttpMessageParameters **ppTxParams
);

HRESULT WINAPI WSDCreateUdpAddress(
  IWSDUdpAddress **ppAddress
);

HRESULT WINAPI WSDCreateUdpMessageParameters(
  IWSDUdpMessageParameters **ppTxParams
);

#ifdef __cplusplus
}
#endif
#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDBASE*/
                                                                                                                                                                                                                                                                       usr/share/mingw-w64/include/wsdclient.h                                                             0100644 0000000 0000000 00000034671 12404413016 016515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDCLIENT
#define _INC_WSDCLIENT

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#undef  INTERFACE
#define INTERFACE IWSDEventingStatus
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDEventingStatus,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDEventingStatus methods */
    STDMETHOD(SubscriptionRenewed)(THIS_ LPCWSTR pszSubscriptionAction) PURE;
    STDMETHOD(SubscriptionRenewalFailed)(THIS_ LPCWSTR pszSubscriptionAction,HRESULT hr) PURE;
    STDMETHOD(SubscriptionEnded)(THIS_ LPCWSTR pszSubscriptionAction) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDEventingStatus_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDEventingStatus_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDEventingStatus_Release(This) (This)->lpVtbl->Release(This)
#define IWSDEventingStatus_SubscriptionRenewed(This,pszSubscriptionAction) (This)->lpVtbl->SubscriptionRenewed(This,pszSubscriptionAction)
#define IWSDEventingStatus_SubscriptionRenewalFailed(This,pszSubscriptionAction,hr) (This)->lpVtbl->SubscriptionRenewalFailed(This,pszSubscriptionAction,hr)
#define IWSDEventingStatus_SubscriptionEnded(This,pszSubscriptionAction) (This)->lpVtbl->SubscriptionEnded(This,pszSubscriptionAction)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDAsyncCallback
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDAsyncCallback,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDAsyncCallback methods */
    STDMETHOD_(HRESULT,AsyncOperationComplete)(THIS_ IWSDAsyncResult *pAsyncResult,IUnknown *pAsyncState) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDAsyncCallback_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDAsyncCallback_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDAsyncCallback_Release(This) (This)->lpVtbl->Release(This)
#define IWSDAsyncCallback_AsyncOperationComplete(This,pAsyncResult,pAsyncState) (This)->lpVtbl->AsyncOperationComplete(This,pAsyncResult,pAsyncState)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDAsyncResult
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDAsyncResult,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDAsyncResult methods */
    STDMETHOD_(HRESULT,SetCallback)(THIS_ IWSDAsyncCallback *pCallback,IUnknown *pAsyncState) PURE;
    STDMETHOD_(HRESULT,SetWaitHandle)(THIS_ HANDLE hWaitHandle) PURE;
    STDMETHOD_(HRESULT,HasCompleted)(THIS) PURE;
    STDMETHOD_(HRESULT,GetAsyncState)(THIS_ IUnknown **ppAsyncState) PURE;
    STDMETHOD_(HRESULT,Abort)(THIS) PURE;
    STDMETHOD_(HRESULT,GetEvent)(THIS_ WSD_EVENT *pEvent) PURE;
    STDMETHOD_(HRESULT,GetEndpointProxy)(THIS_ IWSDEndpointProxy **ppEndpoint) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDAsyncResult_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDAsyncResult_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDAsyncResult_Release(This) (This)->lpVtbl->Release(This)
#define IWSDAsyncResult_SetCallback(This,pCallback,pAsyncState) (This)->lpVtbl->SetCallback(This,pCallback,pAsyncState)
#define IWSDAsyncResult_SetWaitHandle(This,hWaitHandle) (This)->lpVtbl->SetWaitHandle(This,hWaitHandle)
#define IWSDAsyncResult_HasCompleted() (This)->lpVtbl->HasCompleted(This)
#define IWSDAsyncResult_GetAsyncState(This,ppAsyncState) (This)->lpVtbl->GetAsyncState(This,ppAsyncState)
#define IWSDAsyncResult_Abort() (This)->lpVtbl->Abort(This)
#define IWSDAsyncResult_GetEvent(This,pEvent) (This)->lpVtbl->GetEvent(This,pEvent)
#define IWSDAsyncResult_GetEndpointProxy(This,ppEndpoint) (This)->lpVtbl->GetEndpointProxy(This,ppEndpoint)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDDeviceProxy
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDDeviceProxy,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDDeviceProxy methods */
    STDMETHOD_(HRESULT,Init)(THIS_ LPCWSTR pszDeviceId,IWSDAddress *pDeviceAddress,LPCWSTR pszLocalId,IWSDDeviceProxy *pSponsor) PURE;
    STDMETHOD_(HRESULT,BeginGetMetadata)(THIS_ IWSDAsyncResult **ppResult) PURE;
    STDMETHOD_(HRESULT,EndGetMetadata)(THIS_ IWSDAsyncResult *pResult) PURE;
    STDMETHOD_(HRESULT,GetHostMetadata)(THIS_ WSD_HOST_METADATA **ppHostMetadata) PURE;
    STDMETHOD_(HRESULT,GetThisModelMetadata)(THIS_ WSD_THIS_MODEL_METADATA **ppManufacturerMetadata) PURE;
    STDMETHOD_(HRESULT,GetThisDeviceMetadata)(THIS_ WSD_THIS_DEVICE_METADATA **ppThisDeviceMetadata) PURE;
    STDMETHOD_(HRESULT,GetAllMetadata)(THIS_ WSD_METADATA_SECTION_LIST **ppMetadata) PURE;
    STDMETHOD_(HRESULT,GetServiceProxyById)(THIS_ LPCWSTR pszServiceId,IWSDServiceProxy **ppServiceProxy) PURE;
    STDMETHOD_(HRESULT,GetServiceProxyByType)(THIS_ const WSDXML_NAME *pType,IWSDServiceProxy **ppServiceProxy) PURE;
    STDMETHOD_(HRESULT,GetEndpointProxy)(THIS_ IWSDEndpointProxy **ppProxy) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDDeviceProxy_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDDeviceProxy_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDDeviceProxy_Release(This) (This)->lpVtbl->Release(This)
#define IWSDDeviceProxy_Init(This,pszDeviceId,pDeviceAddress,pszLocalId,pSponsor) (This)->lpVtbl->Init(This,pszDeviceId,pDeviceAddress,pszLocalId,pSponsor)
#define IWSDDeviceProxy_BeginGetMetadata(This,ppResult) (This)->lpVtbl->BeginGetMetadata(This,ppResult)
#define IWSDDeviceProxy_EndGetMetadata(This,pResult) (This)->lpVtbl->EndGetMetadata(This,pResult)
#define IWSDDeviceProxy_GetHostMetadata(This,ppHostMetadata) (This)->lpVtbl->GetHostMetadata(This,ppHostMetadata)
#define IWSDDeviceProxy_GetThisModelMetadata(This,ppManufacturerMetadata) (This)->lpVtbl->GetThisModelMetadata(This,ppManufacturerMetadata)
#define IWSDDeviceProxy_GetThisDeviceMetadata(This,ppThisDeviceMetadata) (This)->lpVtbl->GetThisDeviceMetadata(This,ppThisDeviceMetadata)
#define IWSDDeviceProxy_GetAllMetadata(This,ppMetadata) (This)->lpVtbl->GetAllMetadata(This,ppMetadata)
#define IWSDDeviceProxy_GetServiceProxyById(This,pszServiceId,ppServiceProxy) (This)->lpVtbl->GetServiceProxyById(This,pszServiceId,ppServiceProxy)
#define IWSDDeviceProxy_GetServiceProxyByType(This,pType,ppServiceProxy) (This)->lpVtbl->GetServiceProxyByType(This,pType,ppServiceProxy)
#define IWSDDeviceProxy_GetEndpointProxy(This,ppProxy) (This)->lpVtbl->GetEndpointProxy(This,ppProxy)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDMetadataExchange
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDMetadataExchange,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDMetadataExchange methods */
    STDMETHOD_(HRESULT,GetMetadata)(THIS_ WSD_METADATA_SECTION_LIST **MetadataOut) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDMetadataExchange_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDMetadataExchange_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDMetadataExchange_Release(This) (This)->lpVtbl->Release(This)
#define IWSDMetadataExchange_GetMetadata(This,MetadataOut) (This)->lpVtbl->GetMetadata(This,MetadataOut)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDServiceProxy
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDServiceProxy,IWSDMetadataExchange)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDMetadataExchange methods */
    STDMETHOD_(HRESULT,GetMetadata)(THIS_ WSD_METADATA_SECTION_LIST **MetadataOut) PURE;

    /* IWSDServiceProxy methods */
    STDMETHOD_(HRESULT,BeginGetMetadata)(THIS_ IWSDAsyncResult **ppResult) PURE;
    STDMETHOD_(HRESULT,EndGetMetadata)(THIS_ IWSDAsyncResult *pResult,WSD_METADATA_SECTION_LIST **ppMetadata) PURE;
    STDMETHOD_(HRESULT,GetServiceMetadata)(THIS_ WSD_SERVICE_METADATA **ppServiceMetadata) PURE;
    STDMETHOD_(HRESULT,SubscribeToOperation)(THIS_ const WSD_OPERATION *pOperation,IUnknown *pUnknown,const WSDXML_ELEMENT *pAny,WSDXML_ELEMENT **ppAny) PURE;
    STDMETHOD_(HRESULT,UnsubscribeToOperation)(THIS_ const WSD_OPERATION *pOperation) PURE;
    STDMETHOD_(HRESULT,SetEventingStatusCallback)(THIS_ IWSDEventingStatus *pStatus) PURE;
    STDMETHOD_(HRESULT,GetEndpointProxy)(THIS_ IWSDEndpointProxy **ppProxy) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDServiceProxy_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDServiceProxy_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDServiceProxy_Release(This) (This)->lpVtbl->Release(This)
#define IWSDServiceProxy_BeginGetMetadata(This,ppResult) (This)->lpVtbl->BeginGetMetadata(This,ppResult)
#define IWSDServiceProxy_EndGetMetadata(This,pResult,ppMetadata) (This)->lpVtbl->EndGetMetadata(This,pResult,ppMetadata)
#define IWSDServiceProxy_GetServiceMetadata(This,ppServiceMetadata) (This)->lpVtbl->GetServiceMetadata(This,ppServiceMetadata)
#define IWSDServiceProxy_SubscribeToOperation(This,pOperation,pUnknown,pAny,ppAny) (This)->lpVtbl->SubscribeToOperation(This,pOperation,pUnknown,pAny,ppAny)
#define IWSDServiceProxy_UnsubscribeToOperation(This,pOperation) (This)->lpVtbl->UnsubscribeToOperation(This,pOperation)
#define IWSDServiceProxy_SetEventingStatusCallback(This,pStatus) (This)->lpVtbl->SetEventingStatusCallback(This,pStatus)
#define IWSDServiceProxy_GetEndpointProxy(This,ppProxy) (This)->lpVtbl->GetEndpointProxy(This,ppProxy)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDEndpointProxy
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDEndpointProxy,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDEndpointProxy methods */
    STDMETHOD_(HRESULT,SendOneWayRequest)(THIS_ const void *pBody,const WSD_OPERATION *pOperation) PURE;
    STDMETHOD_(HRESULT,SendTwoWayRequest)(THIS_ const void *pBody,const WSD_OPERATION *pOperation,WSD_SYNCHRONOUS_RESPONSE_CONTEXT *pResponseContext) PURE;
    STDMETHOD_(HRESULT,SendTwoWayRequestAsync)(THIS_ const void *pBody,const WSD_OPERATION *pOperation,IUnknown *pAsyncState,IWSDAsyncCallback *pCallback,IWSDAsyncResult **pResult) PURE;
    STDMETHOD_(HRESULT,AbortAsyncOperation)(THIS_ IWSDAsyncResult *pAsyncResult) PURE;
    STDMETHOD_(HRESULT,ProcessFault)(THIS_ const WSD_SOAP_FAULT *pFault) PURE;
    STDMETHOD_(HRESULT,GetErrorInfo)(THIS_ const LPCWSTR *ppszErrorInfo) PURE;
    STDMETHOD_(HRESULT,GetFaultInfo)(THIS_ WSD_SOAP_FAULT **ppFault) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDEndpointProxy_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDEndpointProxy_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDEndpointProxy_Release(This) (This)->lpVtbl->Release(This)
#define IWSDEndpointProxy_SendOneWayRequest(This,pBody,pOperation) (This)->lpVtbl->SendOneWayRequest(This,pBody,pOperation)
#define IWSDEndpointProxy_SendTwoWayRequest(This,pBody,pOperation,pResponseContext) (This)->lpVtbl->SendTwoWayRequest(This,pBody,pOperation,pResponseContext)
#define IWSDEndpointProxy_SendTwoWayRequestAsync(This,pBody,pOperation,pAsyncState,pCallback,pResult) (This)->lpVtbl->SendTwoWayRequestAsync(This,pBody,pOperation,pAsyncState,pCallback,pResult)
#define IWSDEndpointProxy_AbortAsyncOperation(This,pAsyncResult) (This)->lpVtbl->AbortAsyncOperation(This,pAsyncResult)
#define IWSDEndpointProxy_ProcessFault(This,pFault) (This)->lpVtbl->ProcessFault(This,pFault)
#define IWSDEndpointProxy_GetErrorInfo(This,ppszErrorInfo) (This)->lpVtbl->GetErrorInfo(This,ppszErrorInfo)
#define IWSDEndpointProxy_GetFaultInfo(This,ppFault) (This)->lpVtbl->GetFaultInfo(This,ppFault)
#endif /*COBJMACROS*/

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI WSDCreateDeviceProxy(
  const WCHAR *pszDeviceId,
  const WCHAR *pszLocalId,
  IWSDXMLContext *pContext,
  IWSDDeviceProxy **ppDeviceProxy
);

HRESULT WINAPI WSDCreateDeviceProxyAdvanced(
  const WCHAR *pszDeviceId,
  IWSDAddress *pDeviceAddress,
  const WCHAR *pszLocalId,
  IWSDXMLContext *pContext,
  IWSDDeviceProxy **ppDeviceProxy
);

#ifdef __cplusplus
}
#endif
#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDCLIENT*/
                                                                       usr/share/mingw-w64/include/wsddisco.h                                                              0100644 0000000 0000000 00000036757 12404413016 016347  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDDISCO
#define _INC_WSDDISCO

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#undef  INTERFACE
#define INTERFACE IWSDScopeMatchingRule
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDScopeMatchingRule,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDScopeMatchingRule methods */
    STDMETHOD_(HRESULT,GetScopeRule)(THIS_ LPCWSTR *ppszScopeMatchingRule) PURE;
    STDMETHOD_(HRESULT,MatchScopes)(THIS_ LPCWSTR pszScope1,LPCWSTR pszScope2,BOOL *pfMatch) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDScopeMatchingRule_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDScopeMatchingRule_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDScopeMatchingRule_Release(This) (This)->lpVtbl->Release(This)
#define IWSDScopeMatchingRule_GetScopeRule(This,ppszScopeMatchingRule) (This)->lpVtbl->GetScopeRule(This,ppszScopeMatchingRule)
#define IWSDScopeMatchingRule_MatchScopes(This,pszScope1,pszScope2,pfMatch) (This)->lpVtbl->MatchScopes(This,pszScope1,pszScope2,pfMatch)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDiscoveryPublisherNotify
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDiscoveryPublisherNotify,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDiscoveryPublisherNotify methods */
    STDMETHOD_(HRESULT,ProbeHandler)(THIS_ const WSD_SOAP_MESSAGE *pSoap,IWSDMessageParameters *pMessageParameters) PURE;
    STDMETHOD_(HRESULT,ResolveHandler)(THIS_ const WSD_SOAP_MESSAGE *pSoap,IWSDMessageParameters *pMessageParameters) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDiscoveryPublisherNotify_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDiscoveryPublisherNotify_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDiscoveryPublisherNotify_Release(This) (This)->lpVtbl->Release(This)
#define IWSDiscoveryPublisherNotify_ProbeHandler(This,pSoap,pMessageParameters) (This)->lpVtbl->ProbeHandler(This,pSoap,pMessageParameters)
#define IWSDiscoveryPublisherNotify_ResolveHandler(This,pSoap,pMessageParameters) (This)->lpVtbl->ResolveHandler(This,pSoap,pMessageParameters)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDiscoveredService
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDiscoveredService,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDiscoveryProviderNotify methods */
    STDMETHOD_(HRESULT *,GetEndpointReference)(THIS_ WSD_ENDPOINT_REFERENCE **ppEndPointReference) PURE;
    STDMETHOD_(HRESULT,GetTypes)(THIS_ WSD_NAME_LIST **ppTypesList) PURE;
    STDMETHOD_(HRESULT,GetScopes)(THIS_ WSD_URI_LIST **ppScopesList) PURE;
    STDMETHOD_(HRESULT,GetXAddrs)(THIS_ WSD_URI_LIST **ppXAddrsList) PURE;
    STDMETHOD_(HRESULT,GetMetadataVersion)(THIS_ ULONGLONG *pullMetadataVersion) PURE;
    STDMETHOD_(HRESULT,GetExtendedDiscoXML)(THIS_ WSDXML_ELEMENT **ppHeaderAny,WSDXML_ELEMENT **ppBodyAny) PURE;
    STDMETHOD_(HRESULT,GetProbeResolveTag)(THIS_ LPCWSTR *ppszTag) PURE;
    STDMETHOD_(HRESULT,GetRemoteTransportAddress)(THIS_ LPCWSTR *ppszRemoteTransportAddress) PURE;
    STDMETHOD_(HRESULT,GetLocalTransportAddress)(THIS_ LPCWSTR *ppszLocalTransportAddress) PURE;
    STDMETHOD_(HRESULT,GetLocalInterfaceGUID)(THIS_ GUID *pGuid) PURE;
    STDMETHOD_(HRESULT *,GetInstanceId)(THIS_ ULONGLONG *pullInstanceId) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDiscoveredService_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDiscoveredService_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDiscoveredService_Release(This) (This)->lpVtbl->Release(This)
#define IWSDiscoveredService_GetEndpointReference(This,ppEndPointReference) (This)->lpVtbl->GetEndpointReference(This,ppEndPointReference)
#define IWSDiscoveredService_GetTypes(This,ppTypesList) (This)->lpVtbl->GetTypes(This,ppTypesList)
#define IWSDiscoveredService_GetScopes(This,ppScopesList) (This)->lpVtbl->GetScopes(This,ppScopesList)
#define IWSDiscoveredService_GetXAddrs(This,ppXAddrsList) (This)->lpVtbl->GetXAddrs(This,ppXAddrsList)
#define IWSDiscoveredService_GetMetadataVersion(This,pullMetadataVersion) (This)->lpVtbl->GetMetadataVersion(This,pullMetadataVersion)
#define IWSDiscoveredService_GetExtendedDiscoXML(This,ppHeaderAny,ppBodyAny) (This)->lpVtbl->GetExtendedDiscoXML(This,ppHeaderAny,ppBodyAny)
#define IWSDiscoveredService_GetProbeResolveTag(This,ppszTag) (This)->lpVtbl->GetProbeResolveTag(This,ppszTag)
#define IWSDiscoveredService_GetRemoteTransportAddress(This,ppszRemoteTransportAddress) (This)->lpVtbl->GetRemoteTransportAddress(This,ppszRemoteTransportAddress)
#define IWSDiscoveredService_GetLocalTransportAddress(This,ppszLocalTransportAddress) (This)->lpVtbl->GetLocalTransportAddress(This,ppszLocalTransportAddress)
#define IWSDiscoveredService_GetLocalInterfaceGUID(This,pGuid) (This)->lpVtbl->GetLocalInterfaceGUID(This,pGuid)
#define IWSDiscoveredService_GetInstanceId(This,pullInstanceId) (This)->lpVtbl->GetInstanceId(This,pullInstanceId)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDiscoveryProviderNotify
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDiscoveryProviderNotify,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDiscoveryProviderNotify methods */
    STDMETHOD_(HRESULT,Add)(THIS_ IWSDiscoveredService *pService) PURE;
    STDMETHOD_(HRESULT,Remove)(THIS_ IWSDiscoveredService *pService) PURE;
    STDMETHOD_(HRESULT,SearchFailed)(THIS_ HRESULT hr,LPCWSTR pszTag) PURE;
    STDMETHOD_(HRESULT,SearchComplete)(THIS_ LPCWSTR pszTag) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDiscoveryProviderNotify_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDiscoveryProviderNotify_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDiscoveryProviderNotify_Release(This) (This)->lpVtbl->Release(This)
#define IWSDiscoveryProviderNotify_Add(This,pService) (This)->lpVtbl->Add(This,pService)
#define IWSDiscoveryProviderNotify_Remove(This,pService) (This)->lpVtbl->Remove(This,pService)
#define IWSDiscoveryProviderNotify_SearchFailed(This,hr,pszTag) (This)->lpVtbl->SearchFailed(This,hr,pszTag)
#define IWSDiscoveryProviderNotify_SearchComplete(This,pszTag) (This)->lpVtbl->SearchComplete(This,pszTag)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDiscoveryProvider
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDiscoveryProvider,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDiscoveryProvider methods */
    STDMETHOD_(HRESULT,SetAddressFamily)(THIS_ DWORD dwAddressFamily) PURE;
    STDMETHOD_(HRESULT,Attach)(THIS_ IWSDiscoveryProviderNotify *pSink) PURE;
    STDMETHOD_(HRESULT,Detach)(THIS) PURE;
    STDMETHOD_(HRESULT,SearchById)(THIS_ LPCWSTR pszId,LPCWSTR pszTag) PURE;
    STDMETHOD_(HRESULT,SearchByAddress)(THIS_ LPCWSTR pszAddress,LPCWSTR pszTag) PURE;
    STDMETHOD_(HRESULT,SearchByType)(THIS_ LPCWSTR pszTag) PURE;
    STDMETHOD_(HRESULT,GetXMLContext)(THIS_ IWSDXMLContext **ppContext) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDiscoveryProvider_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDiscoveryProvider_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDiscoveryProvider_Release(This) (This)->lpVtbl->Release(This)
#define IWSDiscoveryProvider_SetAddressFamily(This,dwAddressFamily) (This)->lpVtbl->SetAddressFamily(This,dwAddressFamily)
#define IWSDiscoveryProvider_Attach(This,pSink) (This)->lpVtbl->Attach(This,pSink)
#define IWSDiscoveryProvider_Detach() (This)->lpVtbl->Detach(This)
#define IWSDiscoveryProvider_SearchById(This,pszId,pszTag) (This)->lpVtbl->SearchById(This,pszId,pszTag)
#define IWSDiscoveryProvider_SearchByAddress(This,pszAddress,pszTag) (This)->lpVtbl->SearchByAddress(This,pszAddress,pszTag)
#define IWSDiscoveryProvider_SearchByType(This,pszTag) (This)->lpVtbl->SearchByType(This,pszTag)
#define IWSDiscoveryProvider_GetXMLContext(This,ppContext) (This)->lpVtbl->GetXMLContext(This,ppContext)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDiscoveryPublisher
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDiscoveryPublisher,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDiscoveryPublisher methods */
    STDMETHOD_(HRESULT,SetAddressFamily)(THIS_ DWORD dwAddressFamily) PURE;
    STDMETHOD_(HRESULT,RegisterNotificationSink)(THIS_ IWSDiscoveryPublisherNotify *pSink) PURE;
    STDMETHOD_(HRESULT,UnRegisterNotificationSink)(THIS_ IWSDiscoveryPublisherNotify *pSink) PURE;
    STDMETHOD_(HRESULT,Publish)(THIS_ LPCWSTR pszId,ULONGLONG ullMetadataVersion,ULONGLONG ullInstanceId,ULONGLONG ullMessageNumber,const WSD_URI_LIST *pXAddrsList) PURE;
    STDMETHOD_(HRESULT,UnPublish)(THIS_ LPCWSTR pszDeviceId,ULONGLONG ullInstanceId,ULONGLONG ullMessageNumber,const WSDXML_ELEMENT *pAny) PURE;
    STDMETHOD_(HRESULT,MatchProbe)(THIS_ const WSD_SOAP_MESSAGE *pProbeMessage,IWSDMessageParameters *pMessageParameters,LPCWSTR pszId,ULONGLONG ullMetadataVersion,ULONGLONG ullInstanceId,ULONGLONG ullMessageNumber,const WSD_URI_LIST *pXAddrsList) PURE;
    STDMETHOD_(HRESULT,MatchResolve)(THIS_ const WSD_SOAP_MESSAGE *pResolveMessage,IWSDMessageParameters *pMessageParameters,LPCWSTR pszId,ULONGLONG ullMetadataVersion,ULONGLONG ullInstanceId,ULONGLONG ullMessageNumber,const WSD_URI_LIST *pXAddrsList) PURE;
    STDMETHOD_(HRESULT,PublishEx)(THIS_ LPCWSTR pszId,ULONGLONG ullMetadataVersion,ULONGLONG ullInstanceId,ULONGLONG ullMessageNumber,const WSDXML_ELEMENT *pAny) PURE;
    STDMETHOD_(HRESULT,MatchProbeEx)(THIS_ const WSD_SOAP_MESSAGE *pProbeMessage,IWSDMessageParameters *pMessageParameters,LPCWSTR pszId,ULONGLONG ullMetadataVersion,ULONGLONG ullInstanceId,ULONGLONG ullMessageNumber,const WSDXML_ELEMENT *pAny) PURE;
    STDMETHOD_(HRESULT,MatchResolveEx)(THIS_ const WSD_SOAP_MESSAGE *pResolveMessage,IWSDMessageParameters *pMessageParameters,LPCWSTR pszId,ULONGLONG ullMetadataVersion,ULONGLONG ullInstanceId,ULONGLONG ullMessageNumber,const WSDXML_ELEMENT *pAny) PURE;
    STDMETHOD_(HRESULT,RegisterScopeMatchingRule)(THIS_ IWSDScopeMatchingRule *pScopeMatchingRule) PURE;
    STDMETHOD_(HRESULT,UnRegisterScopeMatchingRule)(THIS_ IWSDScopeMatchingRule *pScopeMatchingRule) PURE;
    STDMETHOD_(HRESULT,GetXMLContext)(THIS_ IWSDXMLContext **ppContext) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDiscoveryPublisher_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDiscoveryPublisher_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDiscoveryPublisher_Release(This) (This)->lpVtbl->Release(This)
#define IWSDiscoveryPublisher_SetAddressFamily(This,dwAddressFamily) (This)->lpVtbl->SetAddressFamily(This,dwAddressFamily)
#define IWSDiscoveryPublisher_RegisterNotificationSink(This,pSink) (This)->lpVtbl->RegisterNotificationSink(This,pSink)
#define IWSDiscoveryPublisher_UnRegisterNotificationSink(This,pSink) (This)->lpVtbl->UnRegisterNotificationSink(This,pSink)
#define IWSDiscoveryPublisher_Publish(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pXAddrsList) (This)->lpVtbl->Publish(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pXAddrsList)
#define IWSDiscoveryPublisher_UnPublish(This,pszDeviceId,ullInstanceId,ullMessageNumber,pAny) (This)->lpVtbl->UnPublish(This,pszDeviceId,ullInstanceId,ullMessageNumber,pAny)
#define IWSDiscoveryPublisher_MatchProbe(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pXAddrsList) (This)->lpVtbl->MatchProbe(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pXAddrsList)
#define IWSDiscoveryPublisher_MatchResolve(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pXAddrsList) (This)->lpVtbl->MatchResolve(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pXAddrsList)
#define IWSDiscoveryPublisher_PublishEx(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pAny) (This)->lpVtbl->PublishEx(This,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pAny)
#define IWSDiscoveryPublisher_MatchProbeEx(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pAny) (This)->lpVtbl->MatchProbeEx(This,pProbeMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pAny)
#define IWSDiscoveryPublisher_MatchResolveEx(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pAny) (This)->lpVtbl->MatchResolveEx(This,pResolveMessage,pMessageParameters,pszId,ullMetadataVersion,ullInstanceId,ullMessageNumber,pAny)
#define IWSDiscoveryPublisher_RegisterScopeMatchingRule(This,pScopeMatchingRule) (This)->lpVtbl->RegisterScopeMatchingRule(This,pScopeMatchingRule)
#define IWSDiscoveryPublisher_UnRegisterScopeMatchingRule(This,pScopeMatchingRule) (This)->lpVtbl->UnRegisterScopeMatchingRule(This,pScopeMatchingRule)
#define IWSDiscoveryPublisher_GetXMLContext(This,ppContext) (This)->lpVtbl->GetXMLContext(This,ppContext)
#endif /*COBJMACROS*/

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI WSDCreateDiscoveryProvider(
  IWSDXMLContext *pContext,
  IWSDiscoveryProvider **ppProvider
);

HRESULT WINAPI WSDCreateDiscoveryPublisher(
  IWSDXMLContext *pContext,
  IWSDiscoveryPublisher **ppPublisher
);

#ifdef __cplusplus
}
#endif
#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDDISCO*/
                 usr/share/mingw-w64/include/wsdhost.h                                                               0100644 0000000 0000000 00000015632 12404413016 016210  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDHOST
#define _INC_WSDHOST

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#undef  INTERFACE
#define INTERFACE IWSDServiceMessaging
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDServiceMessaging,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDServiceMessaging methods */
    STDMETHOD_(HRESULT,FaultRequest)(THIS_ WSD_SOAP_HEADER *pRequestHeader,IWSDMessageParameters *pMessageParameters,WSD_SOAP_FAULT *pFault) PURE;
    STDMETHOD_(HRESULT,SendResponse)(THIS_ void *pBody,WSD_OPERATION *pOperation,IWSDMessageParameters *pMessageParameters) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDServiceMessaging_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDServiceMessaging_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDServiceMessaging_Release(This) (This)->lpVtbl->Release(This)
#define IWSDServiceMessaging_FaultRequest(This,pRequestHeader,pMessageParameters,pFault) (This)->lpVtbl->FaultRequest(This,pRequestHeader,pMessageParameters,pFault)
#define IWSDServiceMessaging_SendResponse(This,pBody,pOperation,pMessageParameters) (This)->lpVtbl->SendResponse(This,pBody,pOperation,pMessageParameters)
#endif /*COBJMACROS*/

#undef  INTERFACE
#define INTERFACE IWSDDeviceHostNotify
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDDeviceHostNotify,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDDeviceHostNotify methods */
    STDMETHOD_(HRESULT,GetService)(THIS_ LPCWSTR pszServiceId,IUnknown **ppService) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDDeviceHostNotify_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDDeviceHostNotify_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDDeviceHostNotify_Release(This) (This)->lpVtbl->Release(This)
#define IWSDDeviceHostNotify_GetService(This,pszServiceId,ppService) (This)->lpVtbl->GetService(This,pszServiceId,ppService)
#endif /*COBJMACROS*/

#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
#warning IWSDDeviceHost is unverified.
#endif

#undef  INTERFACE
#define INTERFACE IWSDDeviceHost
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDDeviceHost,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDDeviceHost methods */
    STDMETHOD_(HRESULT,Init)(THIS_ LPCWSTR pszLocalId,DWORD dwHostAddressCount) PURE;
    STDMETHOD_(HRESULT,Start)(THIS_ ULONGLONG ullInstanceId,const WSD_URI_LIST *pScopeList,IWSDDeviceHostNotify *pNotificationSink) PURE;
    STDMETHOD_(HRESULT,Stop)(THIS) PURE;
    STDMETHOD_(HRESULT,Terminate)(THIS) PURE;
    STDMETHOD_(HRESULT,RegisterPortType)(THIS_ const WSD_PORT_TYPE *pPortType) PURE;
    STDMETHOD_(HRESULT,SetMetadata)(THIS_ const WSD_THIS_MODEL_METADATA *pThisModelMetadata,const WSD_THIS_DEVICE_METADATA *pThisDeviceMetadata,const WSD_METADATA_SECTION_LIST *pCustomMetadata) PURE;
    STDMETHOD_(HRESULT,RegisterService)(THIS_ LPCWSTR pszServiceId,IUnknown *pService) PURE;
    STDMETHOD_(HRESULT,RetireService)(THIS_ LPCWSTR pszServiceId) PURE;
    STDMETHOD_(HRESULT,AddDynamicService)(THIS_ LPCWSTR pszServiceId,IUnknown *pService) PURE;
    STDMETHOD_(HRESULT,RemoveDynamicService)(THIS_ LPCWSTR pszServiceId) PURE;
    STDMETHOD_(HRESULT,SetServiceDiscoverable)(THIS_ const WCHAR *pszServiceId,WINBOOL fDiscoverable) PURE;
    STDMETHOD_(HRESULT,SignalEvent)(THIS_ LPCWSTR pszServiceId,const void *pBody,const WSD_OPERATION *pOperation) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDDeviceHost_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDDeviceHost_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDDeviceHost_Release(This) (This)->lpVtbl->Release(This)
#define IWSDDeviceHost_Init(This,pszLocalId,dwHostAddressCount) (This)->lpVtbl->Init(This,pszLocalId,dwHostAddressCount)
#define IWSDDeviceHost_Start(This,ullInstanceId,pScopeList,pNotificationSink) (This)->lpVtbl->Start(This,ullInstanceId,pScopeList,pNotificationSink)
#define IWSDDeviceHost_Stop() (This)->lpVtbl->Stop(This)
#define IWSDDeviceHost_Terminate() (This)->lpVtbl->Terminate(This)
#define IWSDDeviceHost_RegisterPortType(This,pPortType) (This)->lpVtbl->RegisterPortType(This,pPortType)
#define IWSDDeviceHost_SetMetadata(This,pThisModelMetadata,pThisDeviceMetadata,pCustomMetadata) (This)->lpVtbl->SetMetadata(This,pThisModelMetadata,pThisDeviceMetadata,pCustomMetadata)
#define IWSDDeviceHost_RegisterService(This,pszServiceId,pService) (This)->lpVtbl->RegisterService(This,pszServiceId,pService)
#define IWSDDeviceHost_RetireService(This,pszServiceId) (This)->lpVtbl->RetireService(This,pszServiceId)
#define IWSDDeviceHost_AddDynamicService(This,pszServiceId,pService) (This)->lpVtbl->AddDynamicService(This,pszServiceId,pService)
#define IWSDDeviceHost_RemoveDynamicService(This,pszServiceId) (This)->lpVtbl->RemoveDynamicService(This,pszServiceId)
#define IWSDDeviceHost_SetServiceDiscoverable(This,pszServiceId,fDiscoverable) (This)->lpVtbl->SetServiceDiscoverable(This,pszServiceId,fDiscoverable)
#define IWSDDeviceHost_SignalEvent(This,pszServiceId,pBody,pOperation) (This)->lpVtbl->SignalEvent(This,pszServiceId,pBody,pOperation)
#endif /*COBJMACROS*/

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI WSDCreateDeviceHost(
  const WCHAR *pszLocalId,
  IWSDXMLContext *pContext,
  IWSDDeviceHost **ppDeviceHost
);

HRESULT WSDCreateDeviceHostAdvanced(
  const WCHAR *pszLocalId,
  IWSDXMLContext *pContext,
  IWSDAddress **ppHostAddresses,
  DWORD dwHostAddressCount,
  IWSDDeviceHost **ppDeviceHost
);

#ifdef __cplusplus
}
#endif

#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDHOST*/
                                                                                                      usr/share/mingw-w64/include/wsdtypes.h                                                              0100644 0000000 0000000 00000024230 12404413016 016371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDTYPES
#define _INC_WSDTYPES

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _WSD_PROTOCOL_TYPE {
  WSD_PT_NONE    = 0x00,
  WSD_PT_UDP     = 0x01,
  WSD_PT_HTTP    = 0x02,
  WSD_PT_HTTPS   = 0x04,
  WSD_PT_ALL     = 0xff 
} WSD_PROTOCOL_TYPE;

typedef enum _WSDEventType {
  WSDET_NONE                   = 0,
  WSDET_INCOMING_MESSAGE       = 1,
  WSDET_INCOMING_FAULT         = 2,
  WSDET_TRANSMISSION_FAILURE   = 3,
  WSDET_RESPONSE_TIMEOUT       = 4 
} WSDEventType;

typedef HRESULT ( *PWSD_SOAP_MESSAGE_HANDLER )(
    IUnknown *thisUnknown,
    WSD_EVENT *event
);

typedef HRESULT ( *WSD_STUB_FUNCTION )(
    IUnknown *server,
    IWSDServiceMessaging *session,
    WSD_EVENT *event
);

typedef struct _WSD_HANDLER_CONTEXT {
  PWSD_SOAP_MESSAGE_HANDLER Handler;
  void                      *PVoid;
  IUnknown                  *Unknown;
} WSD_HANDLER_CONTEXT;

typedef struct _WSD_REFERENCE_PROPERTIES {
  WSDXML_ELEMENT *Any;
} WSD_REFERENCE_PROPERTIES;

typedef struct _WSD_REFERENCE_PARAMETERS {
  WSDXML_ELEMENT *Any;
} WSD_REFERENCE_PARAMETERS;

typedef struct _WSD_ENDPOINT_REFERENCE {
  const WCHAR              *Address;
  WSD_REFERENCE_PROPERTIES ReferenceProperties;
  WSD_REFERENCE_PARAMETERS ReferenceParameters;
  WSDXML_NAME              *PortType;
  WSDXML_NAME              *ServiceName;
  WSDXML_ELEMENT           *Any;
} WSD_ENDPOINT_REFERENCE;

typedef struct _WSD_APP_SEQUENCE {
  ULONGLONG   InstanceId;
  const WCHAR *SequenceId;
  ULONGLONG   MessageNumber;
} WSD_APP_SEQUENCE;

typedef struct _WSD_HEADER_RELATESTO {
  WSDXML_NAME *RelationshipType;
  const WCHAR *MessageID;
} WSD_HEADER_RELATESTO;

typedef struct _WSD_SOAP_HEADER {
  const WCHAR            *To;
  const WCHAR            *Action;
  const WCHAR            *MessageID;
  WSD_HEADER_RELATESTO   RelatesTo;
  WSD_ENDPOINT_REFERENCE *ReplyTo;
  WSD_ENDPOINT_REFERENCE *From;
  WSD_ENDPOINT_REFERENCE *FaultTo;
  WSD_APP_SEQUENCE       *AppSequence;
  WSDXML_ELEMENT         *AnyHeaders;
} WSD_SOAP_HEADER;

typedef struct _WSD_SOAP_MESSAGE {
  WSD_SOAP_HEADER Header;
  void            *Body;
  WSDXML_TYPE     *BodyType;
} WSD_SOAP_MESSAGE;

typedef struct _WSD_OPERATION {
  WSDXML_TYPE       *RequestType;
  WSDXML_TYPE       *ResponseType;
  WSD_STUB_FUNCTION RequestStubFunction;
} WSD_OPERATION;

typedef struct _WSD_EVENT {
  HRESULT               Hr;
  DWORD                 EventType;
  WCHAR                 *DispatchTag;
  WSD_HANDLER_CONTEXT   HandlerContext;
  WSD_SOAP_MESSAGE      *Soap;
  WSD_OPERATION         *Operation;
  IWSDMessageParameters *MessageParameters;
} WSD_EVENT;

typedef struct _WSD_SOAP_FAULT_SUBCODE {
  WSDXML_NAME            *Value;
  WSD_SOAP_FAULT_SUBCODE *Subcode;
} WSD_SOAP_FAULT_SUBCODE;

typedef struct _WSD_SOAP_FAULT_CODE {
  WSDXML_NAME            *Value;
  WSD_SOAP_FAULT_SUBCODE *Subcode;
} WSD_SOAP_FAULT_CODE;

typedef struct _WSD_LOCALIZED_STRING {
  const WCHAR *lang;
  const WCHAR *String;
} WSD_LOCALIZED_STRING;

typedef struct _WSD_LOCALIZED_STRING_LIST {
  WSD_LOCALIZED_STRING_LIST *Next;
  WSD_LOCALIZED_STRING      *Element;
} WSD_LOCALIZED_STRING_LIST;

typedef struct _WSD_SOAP_FAULT_REASON {
  WSD_LOCALIZED_STRING_LIST *Text;
} WSD_SOAP_FAULT_REASON;

typedef struct _WSD_SOAP_FAULT {
  WSD_SOAP_FAULT_CODE   *Code;
  WSD_SOAP_FAULT_REASON *Reason;
  const WCHAR           *Node;
  const WCHAR           *Role;
  WSDXML_ELEMENT        *Detail;
} WSD_SOAP_FAULT;

typedef struct _REQUESTBODY_GetStatus {
  WSDXML_ELEMENT *Any;
} REQUESTBODY_GetStatus;

typedef struct _WSD_DURATION {
  WINBOOL isPositive;
  ULONG year;
  ULONG month;
  ULONG day;
  ULONG hour;
  ULONG minute;
  ULONG second;
  ULONG millisecond;
} WSD_DURATION;

typedef struct _WSD_DATETIME {
  WINBOOL isPositive;
  ULONG year;
  UCHAR month;
  UCHAR day;
  UCHAR hour;
  UCHAR minute;
  UCHAR second;
  UINT  millisecond;
  WINBOOL TZIsLocal;
  WINBOOL TZIsPositive;
  UCHAR TZHour;
  UCHAR TZMinute;
} WSD_DATETIME;

typedef struct _WSD_EVENTING_EXPIRES {
  WSD_DURATION *Duration;
  WSD_DATETIME *DateTime;
} WSD_EVENTING_EXPIRES;

typedef struct _REQUESTBODY_Renew {
  WSD_EVENTING_EXPIRES *Expires;
  WSDXML_ELEMENT       *Any;
} REQUESTBODY_Renew;

typedef struct _WSD_EVENTING_DELIVERY_MODE {
  const WCHAR *Mode;
  void        *Data;
} WSD_EVENTING_DELIVERY_MODE;

typedef struct _WSD_EVENTING_FILTER {
  const WCHAR *Dialect;
  void        *Data;
} WSD_EVENTING_FILTER;

typedef struct _REQUESTBODY_Subscribe {
  WSD_ENDPOINT_REFERENCE     *EndTo;
  WSD_EVENTING_DELIVERY_MODE *Delivery;
  WSD_EVENTING_EXPIRES       *Expires;
  WSD_EVENTING_FILTER        *Filter;
  WSDXML_ELEMENT             *Any;
} REQUESTBODY_Subscribe;

typedef struct _REQUESTBODY_Unsubscribe {
  WSDXML_ELEMENT *any;
} REQUESTBODY_Unsubscribe;

typedef struct _WSD_METADATA_SECTION_LIST {
  WSD_METADATA_SECTION_LIST *Next;
  WSD_METADATA_SECTION      *Element;
} WSD_METADATA_SECTION_LIST;

typedef struct _RESPONSEBODY_GetMetadata {
  WSD_METADATA_SECTION_LIST *Metadata;
} RESPONSEBODY_GetMetadata;

typedef struct _RESPONSEBODY_GetStatus {
  WSD_EVENTING_EXPIRES *expires;
  WSDXML_ELEMENT       *any;
} RESPONSEBODY_GetStatus;

typedef struct _RESPONSEBODY_Renew {
  WSD_EVENTING_EXPIRES *expires;
  WSDXML_ELEMENT       *Any;
} RESPONSEBODY_Renew;

typedef struct _RESPONSEBODY_Subscribe {
  WSD_ENDPOINT_REFERENCE *SubscriptionManager;
  WSD_EVENTING_EXPIRES   *expires;
  WSDXML_ELEMENT         *Any;
} RESPONSEBODY_Subscribe;

typedef struct _RESPONSEBODY_SubscriptionEnd {
  WSD_ENDPOINT_REFERENCE *SubscriptionManager;
  const WCHAR            *Status;
  WSD_LOCALIZED_STRING   *Reason;
  WSDXML_ELEMENT         *Any;
} RESPONSEBODY_SubscriptionEnd;

typedef struct _WSD_BYE {
  WSD_ENDPOINT_REFERENCE *EndpointReference;
  WSDXML_ELEMENT         *Any;
} WSD_BYE;

typedef struct _WSD_ENDPOINT_REFERENCE_LIST {
  WSD_ENDPOINT_REFERENCE_LIST *Next;
  WSD_ENDPOINT_REFERENCE      *Element;
} WSD_ENDPOINT_REFERENCE_LIST;

typedef struct _WSD_EVENTING_DELIVERY_MODE_PUSH {
  WSD_ENDPOINT_REFERENCE *NotifyTo;
} WSD_EVENTING_DELIVERY_MODE_PUSH;

typedef struct _WSD_URI_LIST {
  WSD_URI_LIST *Next;
  const WCHAR  *Element;
} WSD_URI_LIST;

typedef struct _WSD_EVENTING_FILTER_ACTION {
  WSD_URI_LIST *Actions;
} WSD_EVENTING_FILTER_ACTION;

typedef struct _WSD_NAME_LIST {
  WSD_NAME_LIST *Next;
  WSDXML_NAME   *Element;
} WSD_NAME_LIST;

typedef struct _WSD_SCOPES {
  const WCHAR  *MatchBy;
  WSD_URI_LIST *Scopes;
} WSD_SCOPES;

typedef struct _WSD_HELLO {
  WSD_ENDPOINT_REFERENCE *EndpointReference;
  WSD_NAME_LIST          *Types;
  WSD_SCOPES             *Scopes;
  WSD_URI_LIST           *XAddrs;
  ULONGLONG              MetadataVersion;
  WSDXML_ELEMENT         *Any;
} WSD_HELLO;

typedef struct _WSD_SERVICE_METADATA {
  WSD_ENDPOINT_REFERENCE_LIST *EndpointReference;
  WSD_NAME_LIST               *Types;
  const WCHAR                 *ServiceId;
  WSDXML_ELEMENT              *Any;
} WSD_SERVICE_METADATA;

typedef struct _WSD_SERVICE_METADATA_LIST {
  WSD_SERVICE_METADATA_LIST *Next;
  WSD_SERVICE_METADATA      *Element;
} WSD_SERVICE_METADATA_LIST;

typedef struct _WSD_HOST_METADATA {
  WSD_SERVICE_METADATA      *Host;
  WSD_SERVICE_METADATA_LIST *Hosted;
} WSD_HOST_METADATA;

typedef struct _WSD_METADATA_SECTION {
  const WCHAR            *Dialect;
  const WCHAR            *Identifier;
  void                   *Data;
  WSD_ENDPOINT_REFERENCE *MetadataReference;
  const WCHAR            *Location;
  WSDXML_ELEMENT         *Any;
} WSD_METADATA_SECTION;

typedef struct _WSD_PORT_TYPE {
  DWORD             EncodedName;
  DWORD             OperationCount;
  WSD_OPERATION     *Operations;
  WSD_PROTOCOL_TYPE ProtocolType;
} WSD_PORT_TYPE;

typedef struct _WSD_PROBE {
  WSD_NAME_LIST  *Types;
  WSD_SCOPES     *Scopes;
  WSDXML_ELEMENT *Any;
} WSD_PROBE;

typedef struct _WSD_PROBE_MATCH {
  WSD_ENDPOINT_REFERENCE *EndpointReference;
  WSD_NAME_LIST          *Types;
  WSD_SCOPES             *Scopes;
  WSD_URI_LIST           *XAddrs;
  ULONGLONG              MetadataVersion;
  WSDXML_ELEMENT         *Any;
} WSD_PROBE_MATCH;

typedef struct _WSD_PROBE_MATCH_LIST {
  WSD_PROBE_MATCH_LIST *Next;
  WSD_PROBE_MATCH      *Element;
} WSD_PROBE_MATCH_LIST;

typedef struct _WSD_PROBE_MATCHES {
  WSD_PROBE_MATCH_LIST *ProbeMatch;
  WSDXML_ELEMENT       *Any;
} WSD_PROBE_MATCHES;

typedef struct _WSD_RELATIONSHIP_METADATA {
  const WCHAR       *Type;
  WSD_HOST_METADATA *Data;
  WSDXML_ELEMENT    *Any;
} WSD_RELATIONSHIP_METADATA;

typedef struct _WSD_RESOLVE {
  WSD_ENDPOINT_REFERENCE *EndpointReference;
  WSDXML_ELEMENT         *Any;
} WSD_RESOLVE;

typedef struct _WSD_RESOLVE_MATCH {
  WSD_ENDPOINT_REFERENCE *EndpointReference;
  WSD_NAME_LIST          *Types;
  WSD_SCOPES             *Scopes;
  WSD_URI_LIST           *XAddrs;
  ULONGLONG              MetadataVersion;
  WSDXML_ELEMENT         *Any;
} WSD_RESOLVE_MATCH;

typedef struct _WSD_RESOLVE_MATCHES {
  WSD_RESOLVE_MATCH *ResolveMatch;
  WSDXML_ELEMENT    *Any;
} WSD_RESOLVE_MATCHES;

typedef struct _WSD_SYNCHRONOUS_RESPONSE_CONTEXT {
  HRESULT               hr;
  HANDLE                eventHandle;
  IWSDMessageParameters *messageParameters;
  void                  *results;
} WSD_SYNCHRONOUS_RESPONSE_CONTEXT;

typedef struct _WSD_THIS_DEVICE_METADATA {
  WSD_LOCALIZED_STRING_LIST *FriendlyName;
  const WCHAR               *FirmwareVersion;
  const WCHAR               *SerialNumber;
  WSDXML_ELEMENT            *Any;
} WSD_THIS_DEVICE_METADATA;

typedef struct _WSD_THIS_MODEL_METADATA {
  WSD_LOCALIZED_STRING_LIST *Manufacturer;
  const WCHAR               *ManufacturerUrl;
  WSD_LOCALIZED_STRING_LIST *ModelName;
  const WCHAR               *ModelNumber;
  const WCHAR               *ModelUrl;
  const WCHAR               *PresentationUrl;
  WSDXML_ELEMENT            *Any;
} WSD_THIS_MODEL_METADATA;

typedef struct _WSD_UNKNOWN_LOOKUP {
  WSDXML_ELEMENT *Any;
} WSD_UNKNOWN_LOOKUP;

#ifdef __cplusplus
}
#endif
#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDTYPES*/
                                                                                                                                                                                                                                                                                                                                                                        usr/share/mingw-w64/include/wsdutil.h                                                               0100644 0000000 0000000 00000003566 12404413016 016213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDUTIL
#define _INC_WSDUTIL

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#ifdef __cplusplus
extern "C" {
#endif

void* WINAPI WSDAllocateLinkedMemory(
  void *pParent,
  size_t cbSize
);

void WINAPI WSDAttachLinkedMemory(
  void *pParent,
  void *pChild
);

void WINAPI WSDDetachLinkedMemory(
  void *pVoid
);

void WINAPI WSDFreeLinkedMemory(
  void *pVoid
);

HRESULT WINAPI WSDGenerateFault(
  const LPCWSTR *pszCode,
  const LPCWSTR *pszSubCode,
  const LPCWSTR *pszReason,
  const LPCWSTR *pszDetail,
  IWSDXMLContext *pContext,
  WSD_SOAP_FAULT **ppFault
);

#define WSDAPI_OPTION_MAX_INBOUND_MESSAGE_SIZE 0x0001

HRESULT WINAPI WSDGenerateFaultEx(
  WSDXML_NAME *pCode,
  WSDXML_NAME *pSubCode,
  WSD_LOCALIZED_STRING_LIST *pReasons,
  const LPCWSTR *pszDetail,
  WSD_SOAP_FAULT **ppFault
);

HRESULT WINAPI WSDGetConfigurationOption(
  DWORD dwOption,
  LPVOID pVoid,
  DWORD cbOutBuffer
);

HRESULT WINAPI WSDSetConfigurationOption(
  DWORD dwOption,
  LPVOID pVoid,
  DWORD cbInBuffer
);

STDAPI WSDXMLAddChild(
  WSDXML_ELEMENT *pParent,
  WSDXML_ELEMENT *pChild
);

STDAPI WSDXMLAddSibling(
  WSDXML_ELEMENT *pFirst,
  WSDXML_ELEMENT *pSecond
);

STDAPI WSDXMLBuildAnyForSingleElement(
  WSDXML_NAME *pElementName,
  const LPCWSTR *pszText,
  WSDXML_ELEMENT **ppAny
);

HRESULT WINAPI WSDXMLCleanupElement(
  WSDXML_ELEMENT *pAny
);

STDAPI WSDXMLGetValueFromAny(
  const WCHAR *pszNamespace,
  const WCHAR *pszName,
  WSDXML_ELEMENT *pAny,
  const LPCWSTR *ppszValue
);

#ifdef __cplusplus
}
#endif

#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDUTIL*/
                                                                                                                                          usr/share/mingw-w64/include/wsdxml.h                                                                0100644 0000000 0000000 00000004463 12404413016 016033  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDXML
#define _INC_WSDXML

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#undef  INTERFACE
#define INTERFACE IWSDXMLContext
#ifdef __GNUC__
#warning COM interfaces layout in this header has not been verified.
#warning COM interfaces with incorrect layout may not work at all.
__MINGW_BROKEN_INTERFACE(INTERFACE)
#endif
DECLARE_INTERFACE_(IWSDXMLContext,IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppvObject) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IWSDXMLContext methods */
    STDMETHOD_(HRESULT,SetNamespaces)(THIS_ const PCWSDXML_NAMESPACE *pNamespaces,WORD wNamespacesCount,BYTE bLayerNumber) PURE;
    STDMETHOD_(HRESULT,SetTypes)(THIS_ const PCWSDXML_TYPE *pTypes,DWORD dwTypesCount,BYTE bLayerNumber) PURE;
    STDMETHOD_(HRESULT,AddNamespace)(THIS_ const LPCWSTR *pszUri,const LPCWSTR *pszSuggestedPrefix,WSDXML_NAMESPACE **ppNamespace) PURE;

    END_INTERFACE
};
#ifdef COBJMACROS
#define IWSDXMLContext_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWSDXMLContext_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWSDXMLContext_Release(This) (This)->lpVtbl->Release(This)
#define IWSDXMLContext_SetNamespaces(This,pNamespaces,wNamespacesCount,bLayerNumber) (This)->lpVtbl->SetNamespaces(This,pNamespaces,wNamespacesCount,bLayerNumber)
#define IWSDXMLContext_SetTypes(This,pTypes,dwTypesCount,bLayerNumber) (This)->lpVtbl->SetTypes(This,pTypes,dwTypesCount,bLayerNumber)
#define IWSDXMLContext_AddNamespace(This,pszUri,pszSuggestedPrefix,ppNamespace) (This)->lpVtbl->AddNamespace(This,pszUri,pszSuggestedPrefix,ppNamespace)
#endif /*COBJMACROS*/

/* In WsdXml.idl
HRESULT WINAPI WSDXMLCreateContext(
  __out  IWSDXMLContext **ppContext
);

HRESULT WINAPI WSDXMLGetNameFromBuiltinNamespace(
    LPCWSTR pszNamespace,
    LPCWSTR pszName,
    WSDXML_NAME **ppName
);

*/

#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDXML*/
                                                                                                                                                                                                             usr/share/mingw-w64/include/wsdxmldom.h                                                             0100644 0000000 0000000 00000003661 12404413016 016532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WSDXMLDOM
#define _INC_WSDXMLDOM

#ifndef _INC_WSDAPI
#error Please include wsdapi.h instead of this header. This header cannot be used directly.
#endif

#if (_WIN32_WINNT >= 0x0600)

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WSDXML_TYPE {
  WCHAR *Uri;
  BYTE  *Table;
} WSDXML_TYPE;

typedef const WSDXML_TYPE *PCWSDXML_TYPE;

typedef struct _WSDXML_NAMESPACE {
  const WCHAR *Uri;
  const WCHAR *PreferredPrefix;
  WSDXML_NAME *Names;
  WORD        NamesCount;
  WORD        Encoding;
} WSDXML_NAMESPACE;

typedef const WSDXML_NAMESPACE *PCWSDXML_NAMESPACE;

typedef struct _WSDXML_NAME {
  WSDXML_NAMESPACE *Space;
  WCHAR            *LocalName;
} WSDXML_NAME;

typedef struct _WSDXML_NODE {
  enum DUMMYUNIONNAME {
     ElementType,
     TextType
  }           Type;
  WSDXML_ELEMENT *Parent;
  WSDXML_NODE    *Next;
} WSDXML_NODE;

typedef struct _WSDXML_TEXT {
  WSDXML_NODE Node;
  WCHAR       *Text;
} WSDXML_TEXT;

typedef struct _WSDXML_ATTRIBUTE {
  WSDXML_ELEMENT   *Element;
  WSDXML_ATTRIBUTE *Next;
  WSDXML_NAME      *Name;
  WCHAR            *Value;
} WSDXML_ATTRIBUTE;

typedef struct _WSDXML_PREFIX_MAPPING {
  DWORD                 Refs;
  WSDXML_PREFIX_MAPPING *Next;
  WSDXML_NAMESPACE      *Space;
  WCHAR                 *Prefix;
} WSDXML_PREFIX_MAPPING;

typedef struct _WSDXML_ELEMENT {
  WSDXML_NODE           Node;
  WSDXML_NAME           *Name;
  WSDXML_ATTRIBUTE      *FirstAttribute;
  WSDXML_NODE           *FirstChild;
  WSDXML_PREFIX_MAPPING *PrefixMappings;
} WSDXML_ELEMENT;

typedef struct _WSDXML_ELEMENT_LIST {
  WSDXML_ELEMENT_LIST *Next;
  WSDXML_ELEMENT      *Element;
} WSDXML_ELEMENT_LIST;

#ifdef __cplusplus
}
#endif
#endif /*(_WIN32_WINNT >= 0x0600)*/
#endif /*_INC_WSDXMLDOM*/
                                                                               usr/share/mingw-w64/include/wshisotp.h                                                              0100644 0000000 0000000 00000002402 12404413016 016364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSHISOTP_
#define _WSHISOTP_

#define ISOPROTO_TP0 25
#define ISOPROTO_TP1 26
#define ISOPROTO_TP2 27
#define ISOPROTO_TP3 28
#define ISOPROTO_TP4 29
#define ISOPROTO_TP ISOPROTO_TP4
#define ISOPROTO_CLTP 30
#define ISOPROTO_CLNP 31
#define ISOPROTO_X25 32
#define ISOPROTO_INACT_NL 33
#define ISOPROTO_ESIS 34
#define ISOPROTO_INTRAISIS 35

#define IPPROTO_RAW 255
#define IPPROTO_MAX 256

#define ISO_MAX_ADDR_LENGTH 64
#define ISO_HIERARCHICAL 0
#define ISO_NON_HIERARCHICAL 1

typedef struct sockaddr_tp {
  u_short tp_family;
  u_short tp_addr_type;
  u_short tp_taddr_len;
  u_short tp_tsel_len;
  u_char tp_addr[ISO_MAX_ADDR_LENGTH];
} SOCKADDR_TP,*PSOCKADDR_TP,*LPSOCKADDR_TP;

#define ISO_SET_TP_ADDR(sa_tp,port,portlen,node,nodelen) (sa_tp)->tp_family = AF_ISO; (sa_tp)->tp_addr_type = ISO_HIERARCHICAL; (sa_tp)->tp_tsel_len = (portlen); (sa_tp)->tp_taddr_len = (portlen) + (nodelen); memcpy(&(sa_tp)->tp_addr,(port),(portlen)); memcpy(&(sa_tp)->tp_addr[portlen],(node),(nodelen));

#define ISO_EXP_DATA_USE 00
#define ISO_EXP_DATA_NUSE 01
#endif
                                                                                                                                                                                                                                                              usr/share/mingw-w64/include/wsipv6ok.h                                                              0100644 0000000 0000000 00000005545 12404413016 016307  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSIPV6OK_
#define _WSIPV6OK_

#ifdef IPV6STRICT

#include <ws2tcpip.h>
#include <wspiapi.h>

#undef AF_INET
#define AF_INET AF_INET_IPV6INCOMPATIBLE
#undef PF_INET
#define PF_INET PF_INET_IPV6INCOMPATIBLE
#undef in_addr
#define in_addr in_addr_IPV6INCOMPATIBLE
#undef IN_ADDR
#define IN_ADDR IN_ADDR_IPV6INCOMPATIBLE
#undef PIN_ADDR
#define PIN_ADDR PIN_ADDR_IPV6INCOMPATIBLE
#undef LPIN_ADDR
#define LPIN_ADDR LPIN_ADDR_IPV6INCOMPATIBLE
#undef IPAddr
#define IPAddr IPAddr_IPV6INCOMPATIBLE
#undef sockaddr_in
#define sockaddr_in sockaddr_in_IPV6INCOMPATIBLE
#undef SOCKADDR_IN
#define SOCKADDR_IN SOCKADDR_IN_IPV6INCOMPATIBLE
#undef PSOCKADDR_IN
#define PSOCKADDR_IN PSOCKADDR_IN_IPV6INCOMPATIBLE
#undef LPSOCKADDR_IN
#define LPSOCKADDR_IN LPSOCKADDR_IN_IPV6INCOMPATIBLE
#undef INADDR_ANY
#define INADDR_ANY INADDR_ANY_IPV6INCOMPATIBLE
#undef INADDR_LOOPBACK
#define INADDR_LOOPBACK INADDR_LOOPBACK_IPV6INCOMPATIBLE
#undef IPPROTO_IP
#define IPPROTO_IP IPPROTO_IP_IPV6INCOMPATIBLE
#undef IP_MULTICAST_IF
#define IP_MULTICAST_IF IP_MULTICAST_IF_IPV6INCOMPATIBLE
#undef IP_MULTICAST_TTL
#define IP_MULTICAST_TTL IP_MULTICAST_TTL_IPV6INCOMPATIBLE
#undef IP_MULTICAST_LOOP
#define IP_MULTICAST_LOOP IP_MULTICAST_LOOP_IPV6INCOMPATIBLE
#undef IP_ADD_MEMBERSHIP
#define IP_ADD_MEMBERSHIP IP_ADD_MEMBERSHIP_IPV6INCOMPATIBLE
#undef IP_DROP_MEMBERSHIP
#define IP_DROP_MEMBERSHIP IP_DROP_MEMBERSHIP_IPV6INCOMPATIBLE
#undef ip_mreq
#define ip_mreq ip_mreq_IPV6INCOMPATIBLE
#undef gethostbyname
#define gethostbyname(a) gethostbyname_IPV6INCOMPATIBLE
#undef hostent
#define hostent hostent_IPV6INCOMPATIBLE
#undef HOSTENT
#define HOSTENT HOSTENT_IPV6INCOMPATIBLE
#undef PHOSTENT
#define PHOSTENT PHOSTENT_IPV6INCOMPATIBLE
#undef LPHOSTENT
#define LPHOSTENT LPHOSTENT_IPV6INCOMPATIBLE
#undef inet_addr
#define inet_addr(a) inet_addr_IPV6INCOMPATIBLE
#undef gethostbyaddr
#define gethostbyaddr(a,b,c) gethostbyaddr_IPV6INCOMPATIBLE
#undef inet_ntoa
#define inet_ntoa(a) inet_ntoa_IPV6INCOMPATIBLE
#undef IN_MULTICAST
#define IN_MULTICAST(a) IN_MULTICAST_IPV6INCOMPATIBLE
#undef IN_CLASSD
#define IN_CLASSD(a) IN_CLASSD_IPV6INCOMPATIBLE
#undef IP_TTL
#define IP_TTL IP_TTL_IPV6INCOMPATIBLE
#undef IN_CLASSA
#define IN_CLASSA(a) IN_CLASSA_IPV6INCOMPATIBLE
#undef IN_CLASSB
#define IN_CLASSB(a) IN_CLASSB_IPV6INCOMPATIBLE
#undef IN_CLASSC
#define IN_CLASSC(a) IN_CLASSC_IPV6INCOMPATIBLE
#undef INADDR_BROADCAST
#define INADDR_BROADCAST(a) INADDR_BROADCAST_IPV6INCOMPATIBLE
#undef WSAAsyncGetHostByAddr
#define WSAAsyncGetHostByAddr(a,b,c,d,e,f,g) WSAAsyncGetHostByAddr_IPV6INCOMPATIBLE
#undef WSAAsyncGetHostByName
#define WSAAsyncGetHostByName(a,b,c,d,e) WSAAsyncGetHostByName_IPV6INCOMPATIBLE
#endif
#endif
                                                                                                                                                           usr/share/mingw-w64/include/wsipx.h                                                                 0100644 0000000 0000000 00000000765 12404413015 015667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSIPX_
#define _WSIPX_

typedef struct sockaddr_ipx {
  short sa_family;
  char sa_netnum[4];
  char sa_nodenum[6];
  unsigned short sa_socket;
} SOCKADDR_IPX,*PSOCKADDR_IPX,*LPSOCKADDR_IPX;

#define NSPROTO_IPX 1000
#define NSPROTO_SPX 1256
#define NSPROTO_SPXII 1257
#endif
           usr/share/mingw-w64/include/wsnetbs.h                                                               0100644 0000000 0000000 00000001703 12404413015 016173  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSNETBS_
#define _WSNETBS_

#define NETBIOS_NAME_LENGTH 16

typedef struct sockaddr_nb {
  short snb_family;
  u_short snb_type;
  char snb_name[NETBIOS_NAME_LENGTH];
} SOCKADDR_NB,*PSOCKADDR_NB,*LPSOCKADDR_NB;

#define NETBIOS_UNIQUE_NAME (0x0000)
#define NETBIOS_GROUP_NAME (0x0001)
#define NETBIOS_TYPE_QUICK_UNIQUE (0x0002)
#define NETBIOS_TYPE_QUICK_GROUP (0x0003)

#define SET_NETBIOS_SOCKADDR(_snb,_type,_name,_port) { int _i; (_snb)->snb_family = AF_NETBIOS; (_snb)->snb_type = (_type); for (_i=0; _i<NETBIOS_NAME_LENGTH-1; _i++) { (_snb)->snb_name[_i] = ' '; } for (_i=0; *((_name)+_i)!='\0' && _i<NETBIOS_NAME_LENGTH-1; _i++) { (_snb)->snb_name[_i] = *((_name)+_i); } (_snb)->snb_name[NETBIOS_NAME_LENGTH-1] = (_port); }
#endif
                                                             usr/share/mingw-w64/include/wsnwlink.h                                                              0100644 0000000 0000000 00000003274 12404413015 016367  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSNWLINK_
#define _WSNWLINK_

#define IPX_PTYPE 0x4000

#define IPX_FILTERPTYPE 0x4001
#define IPX_STOPFILTERPTYPE 0x4003
#define IPX_DSTYPE 0x4002
#define IPX_EXTENDED_ADDRESS 0x4004
#define IPX_RECVHDR 0x4005
#define IPX_MAXSIZE 0x4006
#define IPX_ADDRESS 0x4007

typedef struct _IPX_ADDRESS_DATA {
  INT adapternum;
  UCHAR netnum[4];
  UCHAR nodenum[6];
  BOOLEAN wan;
  BOOLEAN status;
  INT maxpkt;
  ULONG linkspeed;
} IPX_ADDRESS_DATA,*PIPX_ADDRESS_DATA;

#define IPX_GETNETINFO 0x4008

typedef struct _IPX_NETNUM_DATA {
  UCHAR netnum[4];
  USHORT hopcount;
  USHORT netdelay;
  INT cardnum;
  UCHAR router[6];
} IPX_NETNUM_DATA,*PIPX_NETNUM_DATA;

#define IPX_GETNETINFO_NORIP 0x4009
#define IPX_SPXGETCONNECTIONSTATUS 0x400B

typedef struct _IPX_SPXCONNSTATUS_DATA {
  UCHAR ConnectionState;
  UCHAR WatchDogActive;
  USHORT LocalConnectionId;
  USHORT RemoteConnectionId;
  USHORT LocalSequenceNumber;
  USHORT LocalAckNumber;
  USHORT LocalAllocNumber;
  USHORT RemoteAckNumber;
  USHORT RemoteAllocNumber;
  USHORT LocalSocket;
  UCHAR ImmediateAddress[6];
  UCHAR RemoteNetwork[4];
  UCHAR RemoteNode[6];
  USHORT RemoteSocket;
  USHORT RetransmissionCount;
  USHORT EstimatedRoundTripDelay;
  USHORT RetransmittedPackets;
  USHORT SuppressedPacket;
} IPX_SPXCONNSTATUS_DATA,*PIPX_SPXCONNSTATUS_DATA;

#define IPX_ADDRESS_NOTIFY 0x400C
#define IPX_MAX_ADAPTER_NUM 0x400D
#define IPX_RERIPNETNUMBER 0x400E
#define IPX_RECEIVE_BROADCAST 0x400F
#define IPX_IMMEDIATESPXACK 0x4010
#endif
                                                                                                                                                                                                                                                                                                                                    usr/share/mingw-w64/include/wspiapi.h                                                               0100644 0000000 0000000 00000015006 12404413015 016163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSPIAPI_H_
#define _WSPIAPI_H_

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <ws2tcpip.h>

#include <_mingw_print_push.h>

#define _WSPIAPI_STRCPY_S(_Dst,_Size,_Src) strcpy((_Dst),(_Src))
#define _WSPIAPI_STRCAT_S(_Dst,_Size,_Src) strcat((_Dst),(_Src))
#define _WSPIAPI_STRNCPY_S(_Dst,_Size,_Src,_Count) strncpy((_Dst),(_Src),(_Count)); (_Dst)[(_Size) - 1] = 0
#define _WSPIAPI_SPRINTF_S_1(_Dst,_Size,_Format,_Arg1) sprintf((_Dst),(_Format),(_Arg1))

#ifndef _WSPIAPI_COUNTOF
#ifndef __cplusplus
#define _WSPIAPI_COUNTOF(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
template <typename __CountofType,size_t _N> char (&__wspiapi_countof_helper(__CountofType (&_Array)[_N]))[_N];
#define _WSPIAPI_COUNTOF(_Array) sizeof(__wspiapi_countof_helper(_Array))
#endif
#endif

#define WspiapiMalloc(tSize) calloc(1,(tSize))
#define WspiapiFree(p) free(p)
#define WspiapiSwap(a,b,c) { (c) = (a); (a) = (b); (b) = (c); }
#define getaddrinfo WspiapiGetAddrInfo
#define getnameinfo WspiapiGetNameInfo
#define freeaddrinfo WspiapiFreeAddrInfo

typedef int (WINAPI *WSPIAPI_PGETADDRINFO)(const char *nodename,const char *servname,const struct addrinfo *hints,struct addrinfo **res);
typedef int (WINAPI *WSPIAPI_PGETNAMEINFO)(const struct sockaddr *sa,socklen_t salen,char *host,size_t hostlen,char *serv,size_t servlen,int flags);
typedef void (WINAPI *WSPIAPI_PFREEADDRINFO)(struct addrinfo *ai);

#ifdef __cplusplus
extern "C" {
#endif
  typedef struct {
    char const *pszName;
    FARPROC pfAddress;
  } WSPIAPI_FUNCTION;

#define WSPIAPI_FUNCTION_ARRAY { { "getaddrinfo",(FARPROC) WspiapiLegacyGetAddrInfo }, \
  { "getnameinfo",(FARPROC) WspiapiLegacyGetNameInfo }, \
  { "freeaddrinfo",(FARPROC) WspiapiLegacyFreeAddrInfo } }

  char *WINAPI WspiapiStrdup (const char *pszString);
  WINBOOL WINAPI WspiapiParseV4Address (const char *pszAddress,PDWORD pdwAddress);
  struct addrinfo * WINAPI WspiapiNewAddrInfo (int iSocketType,int iProtocol,WORD wPort,DWORD dwAddress);
  int WINAPI WspiapiQueryDNS (const char *pszNodeName,int iSocketType,int iProtocol,WORD wPort,char pszAlias[NI_MAXHOST],struct addrinfo **pptResult);
  int WINAPI WspiapiLookupNode (const char *pszNodeName,int iSocketType,int iProtocol,WORD wPort,WINBOOL bAI_CANONNAME,struct addrinfo **pptResult);
  int WINAPI WspiapiClone (WORD wPort,struct addrinfo *ptResult);
  void WINAPI WspiapiLegacyFreeAddrInfo (struct addrinfo *ptHead);
  int WINAPI WspiapiLegacyGetAddrInfo(const char *pszNodeName,const char *pszServiceName,const struct addrinfo *ptHints,struct addrinfo **pptResult);
  int WINAPI WspiapiLegacyGetNameInfo(const struct sockaddr *ptSocketAddress,socklen_t tSocketLength,char *pszNodeName,size_t tNodeLength,char *pszServiceName,size_t tServiceLength,int iFlags);
  FARPROC WINAPI WspiapiLoad(WORD wFunction);
  int WINAPI WspiapiGetAddrInfo(const char *nodename,const char *servname,const struct addrinfo *hints,struct addrinfo **res);
  int WINAPI WspiapiGetNameInfo (const struct sockaddr *sa,socklen_t salen,char *host,size_t hostlen,char *serv,size_t servlen,int flags);
  void WINAPI WspiapiFreeAddrInfo (struct addrinfo *ai);

#ifndef __CRT__NO_INLINE
  __CRT_INLINE char * WINAPI
  WspiapiStrdup (const char *pszString)
  {
    char *rstr;
    size_t szlen;

    if(!pszString)
      return NULL;
    szlen = strlen(pszString) + 1;
    rstr = (char *) WspiapiMalloc (szlen);
    if (!rstr)
      return NULL;
    strcpy (rstr, pszString);
    return rstr;
  }

  __CRT_INLINE WINBOOL WINAPI
  WspiapiParseV4Address (const char *pszAddress, PDWORD pdwAddress)
  {
    DWORD dwAddress = 0;
    const char *h = NULL;
    int cnt;

    for (cnt = 0,h = pszAddress; *h != 0; h++)
      if (h[0] == '.')
	cnt++;
    if (cnt != 3)
      return FALSE;
    dwAddress = inet_addr (pszAddress);
    if (dwAddress == INADDR_NONE)
      return FALSE;
    *pdwAddress = dwAddress;
    return TRUE;
  }

  __CRT_INLINE struct addrinfo * WINAPI
  WspiapiNewAddrInfo (int iSocketType,int iProtocol, WORD wPort,DWORD dwAddress)
  {
    struct addrinfo *n;
    struct sockaddr_in *pa;

    if ((n = (struct addrinfo *) WspiapiMalloc (sizeof (struct addrinfo))) == NULL)
      return NULL;
    if ((pa = (struct sockaddr_in *) WspiapiMalloc (sizeof(struct sockaddr_in))) == NULL)
      {
	WspiapiFree(n);
	return NULL;
      }
    pa->sin_family = AF_INET;
    pa->sin_port = wPort;
    pa->sin_addr.s_addr = dwAddress;
    n->ai_family = PF_INET;
    n->ai_socktype = iSocketType;
    n->ai_protocol = iProtocol;
    n->ai_addrlen = sizeof (struct sockaddr_in);
    n->ai_addr = (struct sockaddr *) pa;
    return n;
  }

  __CRT_INLINE int WINAPI
  WspiapiLookupNode (const char *pszNodeName, int iSocketType, int iProtocol, WORD wPort,
		     WINBOOL bAI_CANONNAME, struct addrinfo **pptResult)
  {
    int err = 0, cntAlias = 0;
    char name[NI_MAXHOST] = "";
    char alias[NI_MAXHOST] = "";
    char *pname = name, *palias = alias, *tmp = NULL;

    strncpy (pname, pszNodeName, NI_MAXHOST - 1);
    pname[NI_MAXHOST - 1] = 0;
    for (;;)
      {
	err = WspiapiQueryDNS (pszNodeName, iSocketType, iProtocol, wPort, palias, pptResult);
	if (err)
	  break;
	if (*pptResult)
	  break;
	++cntAlias;
	if (strlen (palias) == 0 || !strcmp (pname, palias) || cntAlias == 16)
	  {
	    err = EAI_FAIL;
	    break;
	  }
	WspiapiSwap(pname, palias, tmp);
      }
    if (!err && bAI_CANONNAME)
      {
        (*pptResult)->ai_canonname = WspiapiStrdup (palias);
        if (!(*pptResult)->ai_canonname)
	  err = EAI_MEMORY;
      }
    return err;
  }

  __CRT_INLINE int WINAPI
  WspiapiClone (WORD wPort,struct addrinfo *ptResult)
  {
    struct addrinfo *p = NULL;
    struct addrinfo *n = NULL;

    for (p = ptResult; p != NULL;)
      {
	n = WspiapiNewAddrInfo (SOCK_DGRAM, p->ai_protocol, wPort,
				((struct sockaddr_in *) p->ai_addr)->sin_addr.s_addr);
	if (!n)
	  break;
	n->ai_next = p->ai_next;
	p->ai_next = n;
	p = n->ai_next;
      }
    if (p != NULL)
      return EAI_MEMORY;
    return 0;
  }

  __CRT_INLINE void WINAPI
  WspiapiLegacyFreeAddrInfo (struct addrinfo *ptHead)
  {
    struct addrinfo *p;

    for (p = ptHead; p != NULL; p = ptHead)
      {
	if (p->ai_canonname)
	  WspiapiFree (p->ai_canonname);
	if (p->ai_addr)
	  WspiapiFree (p->ai_addr);
	ptHead = p->ai_next;
	WspiapiFree (p);
      }
  }
#endif /* !__CRT__NO_INLINE */

#ifdef __cplusplus
}
#endif

#include <_mingw_print_pop.h>

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/mingw-w64/include/wsrm.h                                                                  0100644 0000000 0000000 00000005473 12404413015 015506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSRM_H_
#define _WSRM_H_

#define IPPROTO_RM 113
#define MAX_MCAST_TTL 255

#define RM_OPTIONSBASE 1000
#define RM_RATE_WINDOW_SIZE (RM_OPTIONSBASE + 1)
#define RM_SET_MESSAGE_BOUNDARY (RM_OPTIONSBASE + 2)
#define RM_FLUSHCACHE (RM_OPTIONSBASE + 3)
#define RM_SENDER_WINDOW_ADVANCE_METHOD (RM_OPTIONSBASE + 4)
#define RM_SENDER_STATISTICS (RM_OPTIONSBASE + 5)
#define RM_LATEJOIN (RM_OPTIONSBASE + 6)
#define RM_SET_SEND_IF (RM_OPTIONSBASE + 7)
#define RM_ADD_RECEIVE_IF (RM_OPTIONSBASE + 8)
#define RM_DEL_RECEIVE_IF (RM_OPTIONSBASE + 9)
#define RM_SEND_WINDOW_ADV_RATE (RM_OPTIONSBASE + 10)
#define RM_USE_FEC (RM_OPTIONSBASE + 11)
#define RM_SET_MCAST_TTL (RM_OPTIONSBASE + 12)
#define RM_RECEIVER_STATISTICS (RM_OPTIONSBASE + 13)
#define RM_HIGH_SPEED_INTRANET_OPT (RM_OPTIONSBASE + 14)

#define SENDER_DEFAULT_RATE_KBITS_PER_SEC 56
#define SENDER_DEFAULT_WINDOW_SIZE_BYTES 10 *1000*1000
#define SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE 15

#define MAX_WINDOW_INCREMENT_PERCENTAGE 25
#define SENDER_DEFAULT_LATE_JOINER_PERCENTAGE 0
#define SENDER_MAX_LATE_JOINER_PERCENTAGE 75

#define BITS_PER_BYTE 8
#define LOG2_BITS_PER_BYTE 3

enum eWINDOW_ADVANCE_METHOD {
  E_WINDOW_ADVANCE_BY_TIME = 1,E_WINDOW_USE_AS_DATA_CACHE
};

typedef struct _RM_SEND_WINDOW {
  ULONG RateKbitsPerSec;
  ULONG WindowSizeInMSecs;
  ULONG WindowSizeInBytes;
} RM_SEND_WINDOW;

typedef struct _RM_SENDER_STATS {
  ULONGLONG DataBytesSent;
  ULONGLONG TotalBytesSent;
  ULONGLONG NaksReceived;
  ULONGLONG NaksReceivedTooLate;
  ULONGLONG NumOutstandingNaks;
  ULONGLONG NumNaksAfterRData;
  ULONGLONG RepairPacketsSent;
  ULONGLONG BufferSpaceAvailable;
  ULONGLONG TrailingEdgeSeqId;
  ULONGLONG LeadingEdgeSeqId;
  ULONGLONG RateKBitsPerSecOverall;
  ULONGLONG RateKBitsPerSecLast;
  ULONGLONG TotalODataPacketsSent;
} RM_SENDER_STATS;

typedef struct _RM_RECEIVER_STATS {
  ULONGLONG NumODataPacketsReceived;
  ULONGLONG NumRDataPacketsReceived;
  ULONGLONG NumDuplicateDataPackets;
  ULONGLONG DataBytesReceived;
  ULONGLONG TotalBytesReceived;
  ULONGLONG RateKBitsPerSecOverall;
  ULONGLONG RateKBitsPerSecLast;
  ULONGLONG TrailingEdgeSeqId;
  ULONGLONG LeadingEdgeSeqId;
  ULONGLONG AverageSequencesInWindow;
  ULONGLONG MinSequencesInWindow;
  ULONGLONG MaxSequencesInWindow;
  ULONGLONG FirstNakSequenceNumber;
  ULONGLONG NumPendingNaks;
  ULONGLONG NumOutstandingNaks;
  ULONGLONG NumDataPacketsBuffered;
  ULONGLONG TotalSelectiveNaksSent;
  ULONGLONG TotalParityNaksSent;
} RM_RECEIVER_STATS;

typedef struct _RM_FEC_INFO {
  USHORT FECBlockSize;
  USHORT FECProActivePackets;
  UCHAR FECGroupSize;
  BOOLEAN fFECOnDemandParityEnabled;
} RM_FEC_INFO;

#endif
                                                                                                                                                                                                     usr/share/mingw-w64/include/wsvns.h                                                                 0100644 0000000 0000000 00000001031 12404413015 015660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _WSVNS_
#define _WSVNS_

typedef struct sockaddr_vns {
  u_short sin_family;
  u_char net_address[4];
  u_char subnet_addr[2];
  u_char port[2];
  u_char hops;
  u_char filler[5];
} SOCKADDR_VNS,*PSOCKADDR_VNS,*LPSOCKADDR_VNS;

#define VNSPROTO_IPC 1
#define VNSPROTO_RELIABLE_IPC 2
#define VNSPROTO_SPP 3
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/mingw-w64/include/wtsapi32.h                                                              0100644 0000000 0000000 00000031002 12404413015 016155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _INC_WTSAPI
#define _INC_WTSAPI

#include <_mingw_unicode.h>

#ifdef __cplusplus
extern "C" {
#endif

#define WTS_CURRENT_SERVER ((HANDLE)NULL)
#define WTS_CURRENT_SERVER_HANDLE ((HANDLE)NULL)
#define WTS_CURRENT_SERVER_NAME (NULL)

#define WTS_CURRENT_SESSION ((DWORD)-1)

#ifndef IDTIMEOUT
#define IDTIMEOUT 32000
#endif
#ifndef IDASYNC
#define IDASYNC 32001
#endif

#define WTS_WSD_LOGOFF 0x1
#define WTS_WSD_SHUTDOWN 0x2
#define WTS_WSD_REBOOT 0x4
#define WTS_WSD_POWEROFF 0x8

#define WTS_WSD_FASTREBOOT 0x10

  typedef enum _WTS_CONNECTSTATE_CLASS {
    WTSActive,WTSConnected,WTSConnectQuery,WTSShadow,WTSDisconnected,WTSIdle,WTSListen,WTSReset,WTSDown,WTSInit
  } WTS_CONNECTSTATE_CLASS;

  typedef struct _WTS_SERVER_INFOW {
    LPWSTR pServerName;
  } WTS_SERVER_INFOW,*PWTS_SERVER_INFOW;

  typedef struct _WTS_SERVER_INFOA {
    LPSTR pServerName;
  } WTS_SERVER_INFOA,*PWTS_SERVER_INFOA;

#define WTS_SERVER_INFO __MINGW_NAME_AW(WTS_SERVER_INFO)
#define PWTS_SERVER_INFO __MINGW_NAME_AW(PWTS_SERVER_INFO)

  typedef struct _WTS_SESSION_INFOW {
    DWORD SessionId;
    LPWSTR pWinStationName;
    WTS_CONNECTSTATE_CLASS State;
  } WTS_SESSION_INFOW,*PWTS_SESSION_INFOW;

  typedef struct _WTS_SESSION_INFOA {
    DWORD SessionId;
    LPSTR pWinStationName;
    WTS_CONNECTSTATE_CLASS State;
  } WTS_SESSION_INFOA,*PWTS_SESSION_INFOA;

#define WTS_SESSION_INFO __MINGW_NAME_AW(WTS_SESSION_INFO)
#define PWTS_SESSION_INFO __MINGW_NAME_AW(PWTS_SESSION_INFO)

  typedef struct _WTS_PROCESS_INFOW {
    DWORD SessionId;
    DWORD ProcessId;
    LPWSTR pProcessName;
    PSID pUserSid;
  } WTS_PROCESS_INFOW,*PWTS_PROCESS_INFOW;

  typedef struct _WTS_PROCESS_INFOA {
    DWORD SessionId;
    DWORD ProcessId;
    LPSTR pProcessName;
    PSID pUserSid;
  } WTS_PROCESS_INFOA,*PWTS_PROCESS_INFOA;

#define WTS_PROCESS_INFO __MINGW_NAME_AW(WTS_PROCESS_INFO)
#define PWTS_PROCESS_INFO __MINGW_NAME_AW(PWTS_PROCESS_INFO)

#define WTS_PROTOCOL_TYPE_CONSOLE 0
#define WTS_PROTOCOL_TYPE_ICA 1
#define WTS_PROTOCOL_TYPE_RDP 2

  typedef enum _WTS_INFO_CLASS {
    WTSInitialProgram       = 0,
    WTSApplicationName      = 1,
    WTSWorkingDirectory     = 2,
    WTSOEMId                = 3,
    WTSSessionId            = 4,
    WTSUserName             = 5,
    WTSWinStationName       = 6,
    WTSDomainName           = 7,
    WTSConnectState         = 8,
    WTSClientBuildNumber    = 9,
    WTSClientName           = 10,
    WTSClientDirectory      = 11,
    WTSClientProductId      = 12,
    WTSClientHardwareId     = 13,
    WTSClientAddress        = 14,
    WTSClientDisplay        = 15,
    WTSClientProtocolType   = 16,
    WTSIdleTime             = 17,
    WTSLogonTime            = 18,
    WTSIncomingBytes        = 19,
    WTSOutgoingBytes        = 20,
    WTSIncomingFrames       = 21,
    WTSOutgoingFrames       = 22,
    WTSClientInfo           = 23,
    WTSSessionInfo          = 24
  } WTS_INFO_CLASS;

  typedef struct _WTS_CLIENT_ADDRESS {
    DWORD AddressFamily;
    BYTE Address[20];
  } WTS_CLIENT_ADDRESS,*PWTS_CLIENT_ADDRESS;

  typedef struct _WTS_CLIENT_DISPLAY {
    DWORD HorizontalResolution;
    DWORD VerticalResolution;
    DWORD ColorDepth;
  } WTS_CLIENT_DISPLAY,*PWTS_CLIENT_DISPLAY;

  typedef enum _WTS_CONFIG_CLASS {
    WTSUserConfigInitialProgram,WTSUserConfigWorkingDirectory,WTSUserConfigfInheritInitialProgram,WTSUserConfigfAllowLogonTerminalServer,
    WTSUserConfigTimeoutSettingsConnections,WTSUserConfigTimeoutSettingsDisconnections,WTSUserConfigTimeoutSettingsIdle,
    WTSUserConfigfDeviceClientDrives,WTSUserConfigfDeviceClientPrinters,WTSUserConfigfDeviceClientDefaultPrinter,WTSUserConfigBrokenTimeoutSettings,
    WTSUserConfigReconnectSettings,WTSUserConfigModemCallbackSettings,WTSUserConfigModemCallbackPhoneNumber,WTSUserConfigShadowingSettings,
    WTSUserConfigTerminalServerProfilePath,WTSUserConfigTerminalServerHomeDir,WTSUserConfigTerminalServerHomeDirDrive,
    WTSUserConfigfTerminalServerRemoteHomeDir
  } WTS_CONFIG_CLASS;

#define WTS_EVENT_NONE 0x0
#define WTS_EVENT_CREATE 0x1
#define WTS_EVENT_DELETE 0x2
#define WTS_EVENT_RENAME 0x4
#define WTS_EVENT_CONNECT 0x8
#define WTS_EVENT_DISCONNECT 0x10
#define WTS_EVENT_LOGON 0x20
#define WTS_EVENT_LOGOFF 0x40
#define WTS_EVENT_STATECHANGE 0x80
#define WTS_EVENT_LICENSE 0x100
#define WTS_EVENT_ALL 0x7fffffff
#define WTS_EVENT_FLUSH 0x80000000

  typedef enum _WTS_VIRTUAL_CLASS {
    WTSVirtualClientData,WTSVirtualFileHandle
  } WTS_VIRTUAL_CLASS;

#define WTSEnumerateServers __MINGW_NAME_AW(WTSEnumerateServers)
#define WTSOpenServer __MINGW_NAME_AW(WTSOpenServer)
#define WTSEnumerateSessions __MINGW_NAME_AW(WTSEnumerateSessions)
#define WTSEnumerateProcesses __MINGW_NAME_AW(WTSEnumerateProcesses)
#define WTSQuerySessionInformation __MINGW_NAME_AW(WTSQuerySessionInformation)
#define WTSQueryUserConfig __MINGW_NAME_AW(WTSQueryUserConfig)
#define WTSSetUserConfig __MINGW_NAME_AW(WTSSetUserConfig)
#define WTSSendMessage __MINGW_NAME_AW(WTSSendMessage)

  WINBOOL WINAPI WTSEnumerateServersW(LPWSTR pDomainName,DWORD Reserved,DWORD Version,PWTS_SERVER_INFOW *ppServerInfo,DWORD *pCount);
  WINBOOL WINAPI WTSEnumerateServersA(LPSTR pDomainName,DWORD Reserved,DWORD Version,PWTS_SERVER_INFOA *ppServerInfo,DWORD *pCount);
  HANDLE WINAPI WTSOpenServerW(LPWSTR pServerName);
  HANDLE WINAPI WTSOpenServerA(LPSTR pServerName);
  VOID WINAPI WTSCloseServer(HANDLE hServer);
  WINBOOL WINAPI WTSEnumerateSessionsW(HANDLE hServer,DWORD Reserved,DWORD Version,PWTS_SESSION_INFOW *ppSessionInfo,DWORD *pCount);
  WINBOOL WINAPI WTSEnumerateSessionsA(HANDLE hServer,DWORD Reserved,DWORD Version,PWTS_SESSION_INFOA *ppSessionInfo,DWORD *pCount);
  WINBOOL WINAPI WTSEnumerateProcessesW(HANDLE hServer,DWORD Reserved,DWORD Version,PWTS_PROCESS_INFOW *ppProcessInfo,DWORD *pCount);
  WINBOOL WINAPI WTSEnumerateProcessesA(HANDLE hServer,DWORD Reserved,DWORD Version,PWTS_PROCESS_INFOA *ppProcessInfo,DWORD *pCount);
  WINBOOL WINAPI WTSTerminateProcess(HANDLE hServer,DWORD ProcessId,DWORD ExitCode);
  WINBOOL WINAPI WTSQuerySessionInformationW(HANDLE hServer,DWORD SessionId,WTS_INFO_CLASS WTSInfoClass,LPWSTR *ppBuffer,DWORD *pBytesReturned);
  WINBOOL WINAPI WTSQuerySessionInformationA(HANDLE hServer,DWORD SessionId,WTS_INFO_CLASS WTSInfoClass,LPSTR *ppBuffer,DWORD *pBytesReturned);
  WINBOOL WINAPI WTSQueryUserConfigW(LPWSTR pServerName,LPWSTR pUserName,WTS_CONFIG_CLASS WTSConfigClass,LPWSTR *ppBuffer,DWORD *pBytesReturned);
  WINBOOL WINAPI WTSQueryUserConfigA(LPSTR pServerName,LPSTR pUserName,WTS_CONFIG_CLASS WTSConfigClass,LPSTR *ppBuffer,DWORD *pBytesReturned);
  WINBOOL WINAPI WTSSetUserConfigW(LPWSTR pServerName,LPWSTR pUserName,WTS_CONFIG_CLASS WTSConfigClass,LPWSTR pBuffer,DWORD DataLength);
  WINBOOL WINAPI WTSSetUserConfigA(LPSTR pServerName,LPSTR pUserName,WTS_CONFIG_CLASS WTSConfigClass,LPSTR pBuffer,DWORD DataLength);
  WINBOOL WINAPI WTSSendMessageW(HANDLE hServer,DWORD SessionId,LPWSTR pTitle,DWORD TitleLength,LPWSTR pMessage,DWORD MessageLength,DWORD Style,DWORD Timeout,DWORD *pResponse,WINBOOL bWait);
  WINBOOL WINAPI WTSSendMessageA(HANDLE hServer,DWORD SessionId,LPSTR pTitle,DWORD TitleLength,LPSTR pMessage,DWORD MessageLength,DWORD Style,DWORD Timeout,DWORD *pResponse,WINBOOL bWait);
  WINBOOL WINAPI WTSDisconnectSession(HANDLE hServer,DWORD SessionId,WINBOOL bWait);
  WINBOOL WINAPI WTSLogoffSession(HANDLE hServer,DWORD SessionId,WINBOOL bWait);
  WINBOOL WINAPI WTSShutdownSystem(HANDLE hServer,DWORD ShutdownFlag);
  WINBOOL WINAPI WTSWaitSystemEvent(HANDLE hServer,DWORD EventMask,DWORD *pEventFlags);
  HANDLE WINAPI WTSVirtualChannelOpen(HANDLE hServer,DWORD SessionId,LPSTR pVirtualName);
  WINBOOL WINAPI WTSVirtualChannelClose(HANDLE hChannelHandle);
  WINBOOL WINAPI WTSVirtualChannelRead(HANDLE hChannelHandle,ULONG TimeOut,PCHAR Buffer,ULONG BufferSize,PULONG pBytesRead);
  WINBOOL WINAPI WTSVirtualChannelWrite(HANDLE hChannelHandle,PCHAR Buffer,ULONG Length,PULONG pBytesWritten);
  WINBOOL WINAPI WTSVirtualChannelPurgeInput(HANDLE hChannelHandle);
  WINBOOL WINAPI WTSVirtualChannelPurgeOutput(HANDLE hChannelHandle);
  WINBOOL WINAPI WTSVirtualChannelQuery(HANDLE hChannelHandle,WTS_VIRTUAL_CLASS,PVOID *ppBuffer,DWORD *pBytesReturned);
  VOID WINAPI WTSFreeMemory(PVOID pMemory);

#define NOTIFY_FOR_ALL_SESSIONS 1
#define NOTIFY_FOR_THIS_SESSION 0

  WINBOOL WINAPI WTSRegisterSessionNotification(HWND hWnd,DWORD dwFlags);
  WINBOOL WINAPI WTSUnRegisterSessionNotification(HWND hWnd);
  WINBOOL WINAPI WTSQueryUserToken(ULONG SessionId,PHANDLE phToken);


#define USERNAME_LENGTH         20
#define CLIENTNAME_LENGTH       20
#define CLIENTADDRESS_LENGTH    30
#define WINSTATIONNAME_LENGTH   32
#define DOMAIN_LENGTH           17

#if (_WIN32_WINNT >= 0x0600)
typedef struct _WTSCLIENTW {
  WCHAR   ClientName[CLIENTNAME_LENGTH + 1];
  WCHAR   Domain[DOMAIN_LENGTH + 1 ];
  WCHAR   UserName[USERNAME_LENGTH + 1];
  WCHAR   WorkDirectory[MAX_PATH + 1];
  WCHAR   InitialProgram[MAX_PATH + 1];
  BYTE    EncryptionLevel;
  ULONG   ClientAddressFamily;
  USHORT  ClientAddress[CLIENTADDRESS_LENGTH + 1];
  USHORT  HRes;
  USHORT  VRes;
  USHORT  ColorDepth;
  WCHAR   ClientDirectory[MAX_PATH + 1];
  ULONG   ClientBuildNumber;
  ULONG   ClientHardwareId;
  USHORT  ClientProductId;
  USHORT  OutBufCountHost;
  USHORT  OutBufCountClient;
  USHORT  OutBufLength;
  WCHAR     DeviceId[MAX_PATH + 1];
} WTSCLIENTW, *PWTSCLIENTW;

typedef struct _WTSCLIENTA {
  CHAR   ClientName[CLIENTNAME_LENGTH + 1];
  CHAR   Domain[DOMAIN_LENGTH + 1 ];
  CHAR   UserName[USERNAME_LENGTH + 1];
  CHAR   WorkDirectory[MAX_PATH + 1];
  CHAR   InitialProgram[MAX_PATH + 1];
  BYTE    EncryptionLevel;
  ULONG   ClientAddressFamily;
  USHORT  ClientAddress[CLIENTADDRESS_LENGTH + 1];
  USHORT  HRes;
  USHORT  VRes;
  USHORT  ColorDepth;
  CHAR   ClientDirectory[MAX_PATH + 1];
  ULONG   ClientBuildNumber;
  ULONG   ClientHardwareId;
  USHORT  ClientProductId;
  USHORT  OutBufCountHost;
  USHORT  OutBufCountClient;
  USHORT  OutBufLength;
  CHAR     DeviceId[MAX_PATH + 1];
} WTSCLIENTA, *PWTSCLIENTA;

__MINGW_TYPEDEF_AW(WTSCLIENT)
__MINGW_TYPEDEF_AW(PWTSCLIENT)

typedef struct _WTSINFOW {
  WTS_CONNECTSTATE_CLASS State;
  DWORD                  SessionId;
  DWORD                  IncomingBytes;
  DWORD                  OutgoingBytes;
  DWORD                  IncomingCompressedBytes;
  DWORD                  OutgoingCompressedBytes;
  WCHAR                  WinStationName[WINSTATIONNAME_LENGTH];
  WCHAR                  Domain[DOMAIN_LENGTH];
  WCHAR                  UserName[USERNAME_LENGTH+1];
  LARGE_INTEGER          ConnectTime;
  LARGE_INTEGER          DisconnectTime;
  LARGE_INTEGER          LastInputTime;
  LARGE_INTEGER          LogonTime;
  LARGE_INTEGER          CurrentTime;
} WTSINFOW, *PWTSINFOW;

typedef struct _WTSINFOA {
  WTS_CONNECTSTATE_CLASS State;
  DWORD                  SessionId;
  DWORD                  IncomingBytes;
  DWORD                  OutgoingBytes;
  DWORD                  IncomingCompressedBytes;
  DWORD                  OutgoingCompressedBytes;
  CHAR                   WinStationName[WINSTATIONNAME_LENGTH];
  CHAR                   Domain[DOMAIN_LENGTH];
  CHAR                   UserName[USERNAME_LENGTH+1];
  LARGE_INTEGER          ConnectTime;
  LARGE_INTEGER          DisconnectTime;
  LARGE_INTEGER          LastInputTime;
  LARGE_INTEGER          LogonTime;
  LARGE_INTEGER          CurrentTime;
} WTSINFOA, *PWTSINFOA;

__MINGW_TYPEDEF_AW(WTSINFO)
__MINGW_TYPEDEF_AW(PWTSINFO)

WINBOOL WINAPI WTSConnectSessionA(
  ULONG LogonId,
  ULONG TargetLogonId,
  PSTR   pPassword,
  WINBOOL bWait
);

WINBOOL WINAPI WTSConnectSessionW(
  ULONG LogonId,
  ULONG TargetLogonId,
  PWSTR  pPassword,
  WINBOOL bWait
);

WINBOOL WTSRegisterSessionNotificationEx(
  HANDLE hServer,
  HWND hWnd,
  DWORD dwFlags
);

WINBOOL WINAPI WTSStartRemoteControlSessionA(
  LPSTR pTargetServerName,
  ULONG TargetLogonId,
  BYTE HotkeyVk,
  USHORT HotkeyModifiers
);

WINBOOL WINAPI WTSStartRemoteControlSessionW(
  LPWSTR pTargetServerName,
  ULONG TargetLogonId,
  BYTE HotkeyVk,
  USHORT HotkeyModifiers
);

#define WTSStartRemoteControlSession __MINGW_NAME_AW(WTSStartRemoteControlSession)
#define WTSConnectSession __MINGW_NAME_AW(WTSConnectSession)

WINBOOL WINAPI WTSStopRemoteControlSession(
  ULONG LogonId
);

WINBOOL WINAPI WTSUnRegisterSessionNotificationEx(
  HANDLE hServer,
  HWND hWnd
);

HANDLE WINAPI WTSVirtualChannelOpenEx(
  DWORD SessionId,
  LPSTR pVirtualName,
  DWORD flags
);

#endif /*(_WIN32_WINNT >= 0x0600)*/

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/share/mingw-w64/include/wtypes.h                                                                0100644 0000000 0000000 00000030005 12404413015 016036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*** Autogenerated by WIDL 1.6 from include/wtypes.idl - Do not edit ***/

#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __wtypes_h__
#define __wtypes_h__

/* Forward declarations */

/* Headers for imported files */

#include <wtypesbase.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */


/*****************************************************************************
 * IWinTypes interface (v0.1)
 */
#ifndef __IWinTypes_INTERFACE_DEFINED__
#define __IWinTypes_INTERFACE_DEFINED__

extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
typedef struct tagRemHGLOBAL {
    LONG fNullHGlobal;
    ULONG cbData;
    byte data[1];
} RemHGLOBAL;

typedef struct tagRemHMETAFILEPICT {
    LONG mm;
    LONG xExt;
    LONG yExt;
    ULONG cbData;
    byte data[1];
} RemHMETAFILEPICT;

typedef struct tagRemHENHMETAFILE {
    ULONG cbData;
    byte data[1];
} RemHENHMETAFILE;
typedef struct tagRemHBITMAP {
    ULONG cbData;
    byte data[1];
} RemHBITMAP;

typedef struct tagRemHPALETTE {
    ULONG cbData;
    byte data[1];
} RemHPALETTE;

typedef struct tagRemBRUSH {
    ULONG cbData;
    byte data[1];
} RemHBRUSH;
#if 0
typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;
typedef void *HMODULE;
typedef void *HINSTANCE;
typedef void *HTASK;
typedef void *HKEY;
typedef void *HDESK;
typedef void *HMF;
typedef void *HEMF;
typedef void *HPEN;
typedef void *HRSRC;
typedef void *HSTR;
typedef void *HWINSTA;
typedef void *HKL;
typedef void *HGDIOBJ;
typedef HANDLE HDWP;
typedef INT HFILE;
typedef DWORD COLORREF;
typedef DWORD *LPCOLORREF;
typedef struct _RECTL {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECTL;
typedef struct _RECTL *PRECTL;
typedef struct _RECTL *LPRECTL;
typedef struct tagPOINT {
    LONG x;
    LONG y;
} POINT;
typedef struct tagPOINT *PPOINT;
typedef struct tagPOINT *LPPOINT;
typedef struct _POINTL {
    LONG x;
    LONG y;
} POINTL;
typedef struct _POINTL *PPOINTL;
typedef struct tagSIZE {
    LONG cx;
    LONG cy;
} SIZE;
typedef struct tagSIZE *PSIZE;
typedef struct tagSIZE *LPSIZE;
typedef struct tagSIZEL {
    LONG cx;
    LONG cy;
} SIZEL;
typedef struct tagSIZEL *PSIZEL;
typedef struct tagSIZEL *LPSIZEL;
#endif

#ifndef _PALETTEENTRY_DEFINED
#define _PALETTEENTRY_DEFINED

typedef struct tagPALETTEENTRY {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
} PALETTEENTRY;
typedef struct tagPALETTEENTRY *PPALETTEENTRY;
typedef struct tagPALETTEENTRY *LPPALETTEENTRY;
#endif

#ifndef _LOGPALETTE_DEFINED
#define _LOGPALETTE_DEFINED

typedef struct tagLOGPALETTE {
    WORD palVersion;
    WORD palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef struct tagLOGPALETTE *PLOGPALETTE;
typedef struct tagLOGPALETTE *LPLOGPALETTE;
#endif

#ifndef _WINDEF_
typedef const RECTL *LPCRECTL;
typedef struct tagRECT {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT;
typedef struct tagRECT *PRECT;
typedef struct tagRECT *LPRECT;
typedef const RECT *LPCRECT;
#endif

#if 0
typedef FMTID *REFFMTID;
#endif

#ifndef _ROTFLAGS_DEFINED
#define _ROTFLAGS_DEFINED
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 0x1
#define ROTFLAGS_ALLOWANYCLIENT 0x2
#endif

#ifndef _ROT_COMPARE_MAX_DEFINED
#define _ROT_COMPARE_MAX_DEFINED
#define ROT_COMPARE_MAX 2048
#endif

typedef enum tagDVASPECT {
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;

typedef enum tagSTGC {
    STGC_DEFAULT = 0,
    STGC_OVERWRITE = 1,
    STGC_ONLYIFCURRENT = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
    STGC_CONSOLIDATE = 8
} STGC;

typedef enum tagSTGMOVE {
    STGMOVE_MOVE = 0,
    STGMOVE_COPY = 1,
    STGMOVE_SHALLOWCOPY = 2
} STGMOVE;

typedef enum tagSTATFLAG {
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1,
    STATFLAG_NOOPEN = 2
} STATFLAG;
typedef void *HCONTEXT;

#ifndef _LCID_DEFINED
#define _LCID_DEFINED
typedef DWORD LCID;
#endif

#ifndef _LANGID_DEFINED
#define _LANGID_DEFINED
typedef USHORT LANGID;
#endif

#define WDT_INPROC_CALL (0x48746457)

#define WDT_REMOTE_CALL (0x52746457)

#define WDT_INPROC64_CALL (0x50746457)


typedef struct _userCLIPFORMAT {
    LONG fContext;
    union {
        DWORD dwValue;
        wchar_t *pwszName;
    } u;
} userCLIPFORMAT;

typedef userCLIPFORMAT *wireCLIPFORMAT;
typedef WORD CLIPFORMAT;

typedef struct _GDI_NONREMOTE {
    LONG fContext;
    union {
        LONG hInproc;
        DWORD_BLOB *hRemote;
    } u;
} GDI_NONREMOTE;

typedef struct _userHGLOBAL {
    LONG fContext;
    union {
        LONG hInproc;
        FLAGGED_BYTE_BLOB *hRemote;
        INT64 hInproc64;
    } u;
} userHGLOBAL;

typedef userHGLOBAL *wireHGLOBAL;

typedef struct _userHMETAFILE {
    LONG fContext;
    union {
        LONG hInproc;
        BYTE_BLOB *hRemote;
        INT64 hInproc64;
    } u;
} userHMETAFILE;

typedef struct _remoteMETAFILEPICT {
    LONG mm;
    LONG xExt;
    LONG yExt;
    userHMETAFILE *hMF;
} remoteMETAFILEPICT;

typedef struct _userHMETAFILEPICT {
    LONG fContext;
    union {
        LONG hInproc;
        remoteMETAFILEPICT *hRemote;
        INT64 hInproc64;
    } u;
} userHMETAFILEPICT;

typedef struct _userHENHMETAFILE {
    LONG fContext;
    union {
        LONG hInproc;
        BYTE_BLOB *hRemote;
        INT64 hInproc64;
    } u;
} userHENHMETAFILE;

typedef struct _userBITMAP {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    ULONG cbSize;
    byte pBuffer[1];
} userBITMAP;

typedef struct _userHBITMAP {
    LONG fContext;
    union {
        LONG hInproc;
        userBITMAP *hRemote;
        INT64 hInproc64;
    } u;
} userHBITMAP;

typedef struct _userHPALETTE {
    LONG fContext;
    union {
        LONG hInproc;
        LOGPALETTE *hRemote;
        INT64 hInproc64;
    } u;
} userHPALETTE;

typedef struct _RemotableHandle {
    LONG fContext;
    union {
        LONG hInproc;
        LONG hRemote;
    } u;
} RemotableHandle;

typedef RemotableHandle *wireHWND;
typedef RemotableHandle *wireHMENU;
typedef RemotableHandle *wireHACCEL;
typedef RemotableHandle *wireHBRUSH;
typedef RemotableHandle *wireHFONT;
typedef RemotableHandle *wireHDC;
typedef RemotableHandle *wireHICON;
typedef RemotableHandle *wireHRGN;
typedef RemotableHandle *wireHMONITOR;

#if 0
typedef void *HWND;
typedef void *HMENU;
typedef void *HACCEL;
typedef void *HBRUSH;
typedef void *HFONT;
typedef void *HDC;
typedef void *HICON;
typedef void *HRGN;
typedef void *HMONITOR;

#ifndef _HCURSOR_DEFINED
#define _HCURSOR_DEFINED
typedef HICON HCURSOR;
#endif

#endif

#ifndef _TEXTMETRIC_DEFINED
#define _TEXTMETRIC_DEFINED

typedef struct tagTEXTMETRICW {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICW;
typedef struct tagTEXTMETRICW *PTEXTMETRICW;
typedef struct tagTEXTMETRICW *LPTEXTMETRICW;
#endif

#ifndef _WIN32
#ifndef WINAPI
typedef struct tagMSG {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
} MSG;
typedef struct tagMSG *PMSG;
typedef struct tagMSG *NPMSG;
typedef struct tagMSG *LPMSG;
#endif
#endif

typedef userHBITMAP *wireHBITMAP;
typedef userHPALETTE *wireHPALETTE;
typedef userHENHMETAFILE *wireHENHMETAFILE;
typedef userHMETAFILE *wireHMETAFILE;
typedef userHMETAFILEPICT *wireHMETAFILEPICT;

#if 0
typedef void *HGLOBAL;
typedef HGLOBAL HLOCAL;
typedef void *HBITMAP;
typedef void *HPALETTE;
typedef void *HENHMETAFILE;
typedef void *HMETAFILE;
#endif

typedef void *HMETAFILEPICT;

#endif  /* __IWinTypes_INTERFACE_DEFINED__ */


typedef double DATE;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED

#if 0
typedef struct tagCY {
    LONGLONG int64;
} CY;
#else
typedef union tagCY {
  __C89_NAMELESS struct {
    unsigned __LONG32 Lo;
    __LONG32 Hi;
  } DUMMYSTRUCTNAME;
  LONGLONG int64;
} CY;
#endif
#endif

typedef CY *LPCY;

#if 0
typedef struct tagDEC {
    USHORT wReserved;
    BYTE scale;
    BYTE sign;
    ULONG Hi32;
    ULONGLONG Lo64;
} DECIMAL;
#else
typedef struct tagDEC {
  USHORT wReserved;
  __C89_NAMELESS union {
    __C89_NAMELESS struct {
      BYTE scale;
      BYTE sign;
    } DUMMYSTRUCTNAME;
    USHORT signscale;
  } DUMMYUNIONNAME;
  ULONG Hi32;
  __C89_NAMELESS union {
    __C89_NAMELESS struct {
      ULONG Lo32;
      ULONG Mid32;
    } DUMMYSTRUCTNAME2;
    ULONGLONG Lo64;
  } DUMMYUNIONNAME2;
} DECIMAL;

#define DECIMAL_NEG ((BYTE)0x80)
#define DECIMAL_SETZERO(dec) { (dec).Lo64 = 0; (dec).Hi32 = 0; (dec).signscale = 0; }
#endif

typedef DECIMAL *LPDECIMAL;

typedef FLAGGED_WORD_BLOB *wireBSTR;
typedef OLECHAR *BSTR;

typedef BSTR *LPBSTR;

typedef short VARIANT_BOOL;
#if 0
typedef VARIANT_BOOL _VARIANT_BOOL;
#else
#define _VARIANT_BOOL /##/
#endif

#ifndef _tagBSTRBLOB_DEFINED
#define _tagBSTRBLOB_DEFINED

typedef struct tagBSTRBLOB {
    ULONG cbSize;
    BYTE *pData;
} BSTRBLOB;
typedef struct tagBSTRBLOB *LPBSTRBLOB;
#endif

#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)

typedef struct tagCLIPDATA {
    ULONG cbSize;
    LONG ulClipFmt;
    BYTE *pClipData;
} CLIPDATA;

#define CBPCLIPDATA(clipdata) ((clipdata).cbSize - sizeof((clipdata).ulClipFmt))

typedef unsigned short VARTYPE;

enum VARENUM {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_INT_PTR = 37,
    VT_UINT_PTR = 38,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VERSIONED_STREAM = 73,
    VT_BSTR_BLOB = 0xfff,
    VT_VECTOR = 0x1000,
    VT_ARRAY = 0x2000,
    VT_BYREF = 0x4000,
    VT_RESERVED = 0x8000,
    VT_ILLEGAL = 0xffff,
    VT_ILLEGALMASKED = 0xfff,
    VT_TYPEMASK = 0xfff
};


typedef ULONG PROPID;

#ifndef PROPERTYKEY_DEFINED
#define PROPERTYKEY_DEFINED

typedef struct _tagpropertykey {
    GUID fmtid;
    DWORD pid;
} PROPERTYKEY;
#endif

typedef struct tagCSPLATFORM {
    DWORD dwPlatformId;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwProcessorArch;
} CSPLATFORM;

typedef struct tagQUERYCONTEXT {
    DWORD dwContext;
    CSPLATFORM Platform;
    LCID Locale;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
} QUERYCONTEXT;

typedef enum tagTYSPEC {
    TYSPEC_CLSID = 0,
    TYSPEC_FILEEXT = 1,
    TYSPEC_MIMETYPE = 2,
    TYSPEC_FILENAME = 3,
    TYSPEC_PROGID = 4,
    TYSPEC_PACKAGENAME = 5,
    TYSPEC_OBJECTID = 6
} TYSPEC;

typedef struct __WIDL_wtypes_generated_name_00000000 {
    DWORD tyspec;
    union {
        CLSID clsid;
        LPOLESTR pFileExt;
        LPOLESTR pMimeType;
        LPOLESTR pProgId;
        LPOLESTR pFileName;
        struct {
            LPOLESTR pPackageName;
            GUID PolicyId;
        } ByName;
        struct {
            GUID ObjectId;
            GUID PolicyId;
        } ByObjectId;
    } tagged_union;
} uCLSSPEC;
/* Begin additional prototypes for all interfaces */


/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __wtypes_h__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/share/mingw-w64/include/wtypesbase.h                                                            0100644 0000000 0000000 00000022712 12404413015 016677  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*** Autogenerated by WIDL 1.5.29 from wtypesbase.idl - Do not edit ***/

#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __wtypesbase_h__
#define __wtypesbase_h__

/* Forward declarations */

/* Headers for imported files */

#include <basetsd.h>
#include <guiddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */


/*****************************************************************************
 * IWinTypesBase interface (v0.1)
 */
#ifndef __IWinTypesBase_INTERFACE_DEFINED__
#define __IWinTypesBase_INTERFACE_DEFINED__

extern RPC_IF_HANDLE IWinTypesBase_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypesBase_v0_1_s_ifspec;

#if 0
typedef byte BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;
typedef int INT;
typedef LONG WINBOOL;
typedef LONG LONG;
typedef ULONG DWORD;
typedef void *HANDLE;
typedef WORD *LPWORD;
typedef DWORD *LPDWORD;
typedef char CHAR;
typedef CHAR *LPSTR;
typedef const CHAR *LPCSTR;
typedef wchar_t WCHAR;
typedef WCHAR TCHAR;
typedef WCHAR *LPWSTR;
typedef TCHAR *LPTSTR;
typedef const WCHAR *LPCWSTR;
typedef const TCHAR *LPCTSTR;
typedef HANDLE *LPHANDLE;
#endif

#if !defined(OLE2ANSI)
typedef WCHAR OLECHAR;
typedef OLECHAR *LPOLESTR;
typedef const OLECHAR *LPCOLESTR;

#define OLESTR(str) L##str
#else
typedef char OLECHAR;
typedef LPSTR LPOLESTR;
typedef LPCSTR LPCOLESTR;

#define OLESTR(str) str
#endif

#ifndef _WINDEF_
#ifndef _MINWINDEF_
typedef void *PVOID;
typedef void *LPVOID;
typedef float FLOAT;
#endif
#endif

typedef unsigned char UCHAR;
typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;
typedef double DOUBLE;
#ifndef _DWORDLONG_
typedef UINT64 DWORDLONG;
typedef DWORDLONG *PDWORDLONG;
#endif

#ifndef _ULONGLONG_
typedef INT64 LONGLONG;
typedef UINT64 ULONGLONG;
typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;
#endif
#if 0
typedef struct _LARGE_INTEGER {
    LONGLONG QuadPart;
} LARGE_INTEGER;
typedef LARGE_INTEGER *PLARGE_INTEGER;
typedef struct _ULARGE_INTEGER {
    ULONGLONG QuadPart;
} ULARGE_INTEGER;
#endif

#ifndef _WINBASE_
#ifndef _FILETIME_
#define _FILETIME_

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
typedef struct _FILETIME *PFILETIME;
typedef struct _FILETIME *LPFILETIME;
#endif

#ifndef _SYSTEMTIME_
#define _SYSTEMTIME_

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME;
typedef struct _SYSTEMTIME *PSYSTEMTIME;
typedef struct _SYSTEMTIME *LPSYSTEMTIME;
#endif

#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    WINBOOL bInheritHandle;
} SECURITY_ATTRIBUTES;
typedef struct _SECURITY_ATTRIBUTES *PSECURITY_ATTRIBUTES;
typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;
#endif

#ifndef SECURITY_DESCRIPTOR_REVISION
typedef USHORT SECURITY_DESCRIPTOR_CONTROL;
typedef USHORT *PSECURITY_DESCRIPTOR_CONTROL;
typedef PVOID PSID;

typedef struct _ACL {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
} ACL;

typedef ACL *PACL;

typedef struct _SECURITY_DESCRIPTOR {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
} SECURITY_DESCRIPTOR;
typedef struct _SECURITY_DESCRIPTOR *PISECURITY_DESCRIPTOR;
#endif
#endif

typedef struct _COAUTHIDENTITY {
    USHORT *User;
    ULONG UserLength;
    USHORT *Domain;
    ULONG DomainLength;
    USHORT *Password;
    ULONG PasswordLength;
    ULONG Flags;
} COAUTHIDENTITY;

typedef struct _COAUTHINFO {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    LPWSTR pwszServerPrincName;
    DWORD dwAuthnLevel;
    DWORD dwImpersonationLevel;
    COAUTHIDENTITY *pAuthIdentityData;
    DWORD dwCapabilities;
} COAUTHINFO;

typedef LONG SCODE;
typedef SCODE *PSCODE;

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
#ifdef __WIDL__
typedef LONG HRESULT;
#else
typedef __LONG32 HRESULT;
#endif
#endif

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED

typedef struct _OBJECTID {
    GUID Lineage;
    ULONG Uniquifier;
} OBJECTID;
#endif

#if 0
typedef GUID *REFGUID;
typedef IID *REFIID;
typedef CLSID *REFCLSID;
#endif

typedef enum tagMEMCTX {
    MEMCTX_TASK = 1,
    MEMCTX_SHARED = 2,
    MEMCTX_MACSYSTEM = 3,
    MEMCTX_UNKNOWN = -1,
    MEMCTX_SAME = -2
} MEMCTX;
#ifndef _ROTREGFLAGS_DEFINED
#define _ROTREGFLAGS_DEFINED

#define ROTREGFLAGS_ALLOWANYCLIENT 0x1
#endif

#ifndef _APPIDREGFLAGS_DEFINED
#define _APPIDREGFLAGS_DEFINED

#define APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP 0x1
#define APPIDREGFLAGS_SECURE_SERVER_PROCESS_SD_AND_BIND 0x2
#define APPIDREGFLAGS_ISSUE_ACTIVATION_RPC_AT_IDENTIFY 0x4
#define APPIDREGFLAGS_IUSERVER_UNMODIFIED_LOGON_TOKEN 0x8
#define APPIDREGFLAGS_IUSERVER_SELF_SID_IN_LAUNCH_PERMISSION 0x10
#define APPIDREGFLAGS_IUSERVER_ACTIVATE_IN_CLIENT_SESSION_ONLY 0x20
#define APPIDREGFLAGS_RESERVED1 0x40
#endif

#ifndef _DCOMSCM_REMOTECALL_FLAGS_DEFINED
#define _DCOMSCM_REMOTECALL_FLAGS_DEFINED

#define DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES 0x1
#define DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL 0x2
#define DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES 0x4
#define DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL 0x8
#define DCOMSCM_PING_USE_MID_AUTHNSERVICE 0x10
#define DCOMSCM_PING_DISALLOW_UNSECURE_CALL 0x20
#endif

typedef enum tagCLSCTX {
    CLSCTX_INPROC_SERVER = 0x1,
    CLSCTX_INPROC_HANDLER = 0x2,
    CLSCTX_LOCAL_SERVER = 0x4,
    CLSCTX_INPROC_SERVER16 = 0x8,
    CLSCTX_REMOTE_SERVER = 0x10,
    CLSCTX_INPROC_HANDLER16 = 0x20,
    CLSCTX_RESERVED1 = 0x40,
    CLSCTX_RESERVED2 = 0x80,
    CLSCTX_RESERVED3 = 0x100,
    CLSCTX_RESERVED4 = 0x200,
    CLSCTX_NO_CODE_DOWNLOAD = 0x400,
    CLSCTX_RESERVED5 = 0x800,
    CLSCTX_NO_CUSTOM_MARSHAL = 0x1000,
    CLSCTX_ENABLE_CODE_DOWNLOAD = 0x2000,
    CLSCTX_NO_FAILURE_LOG = 0x4000,
    CLSCTX_DISABLE_AAA = 0x8000,
    CLSCTX_ENABLE_AAA = 0x10000,
    CLSCTX_FROM_DEFAULT_CONTEXT = 0x20000,
    CLSCTX_ACTIVATE_32_BIT_SERVER = 0x40000,
    CLSCTX_ACTIVATE_64_BIT_SERVER = 0x80000,
    CLSCTX_ENABLE_CLOAKING = 0x100000,
    CLSCTX_APPCONTAINER = 0x400000,
    CLSCTX_ACTIVATE_AAA_AS_IU = 0x800000,
    CLSCTX_PS_DLL = (int)0x80000000
} CLSCTX;

#define CLSCTX_VALID_MASK (CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER16 | CLSCTX_REMOTE_SERVER | CLSCTX_NO_CODE_DOWNLOAD | CLSCTX_NO_CUSTOM_MARSHAL | CLSCTX_ENABLE_CODE_DOWNLOAD | CLSCTX_NO_FAILURE_LOG | CLSCTX_DISABLE_AAA | CLSCTX_ENABLE_AAA | CLSCTX_FROM_DEFAULT_CONTEXT | CLSCTX_ACTIVATE_32_BIT_SERVER | CLSCTX_ACTIVATE_64_BIT_SERVER | CLSCTX_ENABLE_CLOAKING | CLSCTX_APPCONTAINER | CLSCTX_ACTIVATE_AAA_AS_IU | CLSCTX_PS_DLL)

typedef enum tagMSHLFLAGS {
    MSHLFLAGS_NORMAL = 0,
    MSHLFLAGS_TABLESTRONG = 1,
    MSHLFLAGS_TABLEWEAK = 2,
    MSHLFLAGS_NOPING = 4,
    MSHLFLAGS_RESERVED1 = 8,
    MSHLFLAGS_RESERVED2 = 16,
    MSHLFLAGS_RESERVED3 = 32,
    MSHLFLAGS_RESERVED4 = 64
} MSHLFLAGS;

typedef enum tagMSHCTX {
    MSHCTX_LOCAL = 0,
    MSHCTX_NOSHAREDMEM = 1,
    MSHCTX_DIFFERENTMACHINE = 2,
    MSHCTX_INPROC = 3,
    MSHCTX_CROSSCTX = 4
} MSHCTX;

typedef struct _BYTE_BLOB {
    ULONG clSize;
    byte abData[1];
} BYTE_BLOB;

typedef BYTE_BLOB *UP_BYTE_BLOB;

typedef struct _WORD_BLOB {
    ULONG clSize;
    unsigned short asData[1];
} WORD_BLOB;

typedef WORD_BLOB *UP_WORD_BLOB;

typedef struct _DWORD_BLOB {
    ULONG clSize;
    ULONG alData[1];
} DWORD_BLOB;

typedef DWORD_BLOB *UP_DWORD_BLOB;

typedef struct _FLAGGED_BYTE_BLOB {
    ULONG fFlags;
    ULONG clSize;
    byte abData[1];
} FLAGGED_BYTE_BLOB;

typedef FLAGGED_BYTE_BLOB *UP_FLAGGED_BYTE_BLOB;

typedef struct _FLAGGED_WORD_BLOB {
    ULONG fFlags;
    ULONG clSize;
    unsigned short asData[1];
} FLAGGED_WORD_BLOB;

typedef FLAGGED_WORD_BLOB *UP_FLAGGED_WORD_BLOB;

typedef struct _BYTE_SIZEDARR {
    ULONG clSize;
    byte *pData;
} BYTE_SIZEDARR;

typedef struct _SHORT_SIZEDARR {
    ULONG clSize;
    unsigned short *pData;
} WORD_SIZEDARR;

typedef struct _LONG_SIZEDARR {
    ULONG clSize;
    ULONG *pData;
} DWORD_SIZEDARR;

typedef struct _HYPER_SIZEDARR {
    ULONG clSize;
    hyper *pData;
} HYPER_SIZEDARR;

#endif  /* __IWinTypesBase_INTERFACE_DEFINED__ */


typedef boolean BOOLEAN;
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED

typedef struct tagBLOB {
    ULONG cbSize;
    BYTE *pBlobData;
} BLOB;
typedef struct tagBLOB *LPBLOB;
#endif

#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
typedef struct _SID_IDENTIFIER_AUTHORITY {
    UCHAR Value[6];
} SID_IDENTIFIER_AUTHORITY;
typedef struct _SID_IDENTIFIER_AUTHORITY *PSID_IDENTIFIER_AUTHORITY;
#endif

#ifndef SID_DEFINED
#define SID_DEFINED

typedef struct _SID {
    BYTE Revision;
    BYTE SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG SubAuthority[1];
} SID;
typedef struct _SID *PISID;

typedef struct _SID_AND_ATTRIBUTES {
    SID *Sid;
    DWORD Attributes;
} SID_AND_ATTRIBUTES;
typedef struct _SID_AND_ATTRIBUTES *PSID_AND_ATTRIBUTES;
#endif
/* Begin additional prototypes for all interfaces */


/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __wtypesbase_h__ */
                                                      usr/share/mingw-w64/include/xa.h                                                                    0100644 0000000 0000000 00000007006 12404413015 015120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef XA_H
#define XA_H

#define XIDDATASIZE 128
#define MAXGTRIDSIZE 64
#define MAXBQUALSIZE 64

#ifndef _XID_T_DEFINED
#define _XID_T_DEFINED
struct xid_t {
  __LONG32 formatID;
  __LONG32 gtrid_length;
  __LONG32 bqual_length;
  char data[XIDDATASIZE];
};
#endif

typedef struct xid_t XID;

#ifdef _TMPROTOTYPES
extern int __cdecl ax_reg(int,XID *,__LONG32);
extern int __cdecl ax_unreg(int,__LONG32);
#else
extern int __cdecl ax_reg();
extern int __cdecl ax_unreg();
#endif

#define RMNAMESZ 32

#define MAXINFOSIZE 256

#ifndef _XA_SWITCH_T_DEFINED
#define _XA_SWITCH_T_DEFINED
struct xa_switch_t {
  char name[RMNAMESZ];
  __LONG32 flags;
  __LONG32 version;
  int (__cdecl *xa_open_entry)(char *,int,__LONG32);
  int (__cdecl *xa_close_entry)(char *,int,__LONG32);
  int (__cdecl *xa_start_entry)(XID *,int,__LONG32);
  int (__cdecl *xa_end_entry)(XID *,int,__LONG32);
  int (__cdecl *xa_rollback_entry)(XID *,int,__LONG32);
  int (__cdecl *xa_prepare_entry)(XID *,int,__LONG32);
  int (__cdecl *xa_commit_entry)(XID *,int,__LONG32);
  int (__cdecl *xa_recover_entry)(XID *,__LONG32,int,__LONG32);

  int (__cdecl *xa_forget_entry)(XID *,int,__LONG32);
  int (__cdecl *xa_complete_entry)(int *,int *,int,__LONG32);

};

typedef struct xa_switch_t xa_switch_t;
#endif

#define TMNOFLAGS __MSABI_LONG(0x00000000)
#define TMREGISTER __MSABI_LONG(0x00000001)
#define TMNOMIGRATE __MSABI_LONG(0x00000002)
#define TMUSEASYNC __MSABI_LONG(0x00000004)

#define TMASYNC __MSABI_LONG(0x80000000)
#define TMONEPHASE __MSABI_LONG(0x40000000)
#define TMFAIL __MSABI_LONG(0x20000000)
#define TMNOWAIT __MSABI_LONG(0x10000000)
#define TMRESUME __MSABI_LONG(0x08000000)
#define TMSUCCESS __MSABI_LONG(0x04000000)
#define TMSUSPEND __MSABI_LONG(0x02000000)
#define TMSTARTRSCAN __MSABI_LONG(0x01000000)
#define TMENDRSCAN __MSABI_LONG(0x00800000)
#define TMMULTIPLE __MSABI_LONG(0x00400000)
#define TMJOIN __MSABI_LONG(0x00200000)
#define TMMIGRATE __MSABI_LONG(0x00100000)

#define TM_JOIN 2
#define TM_RESUME 1
#define TM_OK 0
#define TMER_TMERR (-1)
#define TMER_INVAL (-2)
#define TMER_PROTO (-3)

#define XA_RBBASE 100
#define XA_RBROLLBACK XA_RBBASE
#define XA_RBCOMMFAIL XA_RBBASE+1
#define XA_RBDEADLOCK XA_RBBASE+2
#define XA_RBINTEGRITY XA_RBBASE+3
#define XA_RBOTHER XA_RBBASE+4
#define XA_RBPROTO XA_RBBASE+5
#define XA_RBTIMEOUT XA_RBBASE+6
#define XA_RBTRANSIENT XA_RBBASE+7
#define XA_RBEND XA_RBTRANSIENT

#define XA_NOMIGRATE 9
#define XA_HEURHAZ 8
#define XA_HEURCOM 7
#define XA_HEURRB 6
#define XA_HEURMIX 5
#define XA_RETRY 4
#define XA_RDONLY 3
#define XA_OK 0
#define XAER_ASYNC (-2)
#define XAER_RMERR (-3)
#define XAER_NOTA (-4)
#define XAER_INVAL (-5)
#define XAER_PROTO (-6)
#define XAER_RMFAIL (-7)
#define XAER_DUPID (-8)
#define XAER_OUTSIDE (-9)

typedef int (__cdecl *XA_OPEN_EPT)(char *,int,__LONG32);
typedef int (__cdecl *XA_CLOSE_EPT)(char *,int,__LONG32);
typedef int (__cdecl *XA_START_EPT)(XID *,int,__LONG32);
typedef int (__cdecl *XA_END_EPT)(XID *,int,__LONG32);
typedef int (__cdecl *XA_ROLLBACK_EPT)(XID *,int,__LONG32);
typedef int (__cdecl *XA_PREPARE_EPT)(XID *,int,__LONG32);
typedef int (__cdecl *XA_COMMIT_EPT)(XID *,int,__LONG32);
typedef int (__cdecl *XA_RECOVER_EPT)(XID *,__LONG32,int,__LONG32);
typedef int (__cdecl *XA_FORGET_EPT)(XID *,int,__LONG32);
typedef int (__cdecl *XA_COMPLETE_EPT)(int *,int *,int,__LONG32);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/mingw-w64/include/xcmc.h                                                                  0100644 0000000 0000000 00000023221 12404413015 015437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _XCMC_H
#define _XCMC_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DIFFERENT_PLATFORM
  typedef char CMC_sint8;
  typedef short CMC_sint16;
  typedef __LONG32 CMC_sint32;
  typedef unsigned short int CMC_uint16;
  typedef unsigned __LONG32 CMC_uint32;
  typedef void *CMC_buffer;
  typedef char *CMC_string;
#endif

  typedef CMC_uint16 CMC_boolean;
  typedef CMC_sint32 CMC_enum;
  typedef CMC_uint32 CMC_return_code;
  typedef CMC_uint32 CMC_flags;
  typedef CMC_string CMC_object_identifier;

#define CMC_FALSE ((CMC_boolean)0)
#define CMC_TRUE ((CMC_boolean)1)

  typedef struct {
    CMC_uint32 length;
    char string[1];
  } CMC_counted_string;

  typedef CMC_uint32 CMC_session_id;

  typedef struct {
    CMC_sint8 second;
    CMC_sint8 minute;
    CMC_sint8 hour;
    CMC_sint8 day;
    CMC_sint8 month;
    CMC_sint8 year;
    CMC_sint8 isdst;
    CMC_sint8 unused1;
    CMC_sint16 tmzone;
    CMC_sint16 unused2;
  } CMC_time;

#define CMC_NO_TIMEZONE ((CMC_sint16) 0x8000)

  typedef CMC_uint32 CMC_ui_id;

  typedef struct {
    CMC_uint32 item_code;
    CMC_uint32 item_data;
    CMC_buffer item_reference;
    CMC_flags extension_flags;
  } CMC_extension;

#define CMC_EXT_REQUIRED ((CMC_flags) 0x00010000)
#define CMC_EXT_OUTPUT ((CMC_flags) 0x00020000)
#define CMC_EXT_LAST_ELEMENT ((CMC_flags) 0x80000000)
#define CMC_EXT_RSV_FLAG_MASK ((CMC_flags) 0xFFFF0000)
#define CMC_EXT_ITEM_FLAG_MASK ((CMC_flags) 0x0000FFFF)

  typedef struct {
    CMC_string attach_title;
    CMC_object_identifier attach_type;
    CMC_string attach_filename;
    CMC_flags attach_flags;
    CMC_extension *attach_extensions;
  } CMC_attachment;

#define CMC_ATT_APP_OWNS_FILE ((CMC_flags) 1)
#define CMC_ATT_LAST_ELEMENT ((CMC_flags) 0x80000000)

#define CMC_ATT_OID_BINARY "? ? ? ? ? ?"
#define CMC_ATT_OID_TEXT "? ? ? ? ? ?"

  typedef CMC_counted_string CMC_message_reference;

  typedef struct {
    CMC_string name;
    CMC_enum name_type;
    CMC_string address;
    CMC_enum role;
    CMC_flags recip_flags;
    CMC_extension *recip_extensions;
  } CMC_recipient;

#define CMC_TYPE_UNKNOWN ((CMC_enum) 0)
#define CMC_TYPE_INDIVIDUAL ((CMC_enum) 1)
#define CMC_TYPE_GROUP ((CMC_enum) 2)

#define CMC_ROLE_TO ((CMC_enum) 0)
#define CMC_ROLE_CC ((CMC_enum) 1)
#define CMC_ROLE_BCC ((CMC_enum) 2)
#define CMC_ROLE_ORIGINATOR ((CMC_enum) 3)
#define CMC_ROLE_AUTHORIZING_USER ((CMC_enum) 4)

#define CMC_RECIP_IGNORE ((CMC_flags) 1)
#define CMC_RECIP_LIST_TRUNCATED ((CMC_flags) 2)
#define CMC_RECIP_LAST_ELEMENT ((CMC_flags) 0x80000000)

  typedef struct {
    CMC_message_reference *message_reference;
    CMC_string message_type;
    CMC_string subject;
    CMC_time time_sent;
    CMC_string text_note;
    CMC_recipient *recipients;
    CMC_attachment *attachments;
    CMC_flags message_flags;
    CMC_extension *message_extensions;
  } CMC_message;

#define CMC_MSG_READ ((CMC_flags) 1)
#define CMC_MSG_TEXT_NOTE_AS_FILE ((CMC_flags) 2)
#define CMC_MSG_UNSENT ((CMC_flags) 4)
#define CMC_MSG_LAST_ELEMENT ((CMC_flags) 0x80000000)

  typedef struct {
    CMC_message_reference *message_reference;
    CMC_string message_type;
    CMC_string subject;
    CMC_time time_sent;
    CMC_uint32 byte_length;
    CMC_recipient *originator;
    CMC_flags summary_flags;
    CMC_extension *message_summary_extensions;
  } CMC_message_summary;

#define CMC_SUM_READ ((CMC_flags) 1)
#define CMC_SUM_UNSENT ((CMC_flags) 2)
#define CMC_SUM_LAST_ELEMENT ((CMC_flags) 0x80000000)

#define CMC_ERROR_UI_ALLOWED ((CMC_flags) 0x01000000)
#define CMC_LOGON_UI_ALLOWED ((CMC_flags) 0x02000000)
#define CMC_COUNTED_STRING_TYPE ((CMC_flags) 0x04000000)

  CMC_return_code WINAPI cmc_send(CMC_session_id session,CMC_message *message,CMC_flags send_flags,CMC_ui_id ui_id,CMC_extension *send_extensions);

#define CMC_SEND_UI_REQUESTED ((CMC_flags) 1)

  CMC_return_code WINAPI cmc_send_documents(CMC_string recipient_addresses,CMC_string subject,CMC_string text_note,CMC_flags send_doc_flags,CMC_string file_paths,CMC_string file_names,CMC_string delimiter,CMC_ui_id ui_id);

#define CMC_FIRST_ATTACH_AS_TEXT_NOTE ((CMC_flags) 2)

  CMC_return_code WINAPI cmc_act_on(CMC_session_id session,CMC_message_reference *message_reference,CMC_enum operation,CMC_flags act_on_flags,CMC_ui_id ui_id,CMC_extension *act_on_extensions);

#define CMC_ACT_ON_EXTENDED ((CMC_enum) 0)
#define CMC_ACT_ON_DELETE ((CMC_enum) 1)

  CMC_return_code WINAPI cmc_list(CMC_session_id session,CMC_string message_type,CMC_flags list_flags,CMC_message_reference *seed,CMC_uint32 *count,CMC_ui_id ui_id,CMC_message_summary **result,CMC_extension *list_extensions);

#define CMC_LIST_UNREAD_ONLY ((CMC_flags) 1)
#define CMC_LIST_MSG_REFS_ONLY ((CMC_flags) 2)
#define CMC_LIST_COUNT_ONLY ((CMC_flags) 4)

#define CMC_LENGTH_UNKNOWN 0xFFFFFFFF

  CMC_return_code WINAPI cmc_read(CMC_session_id session,CMC_message_reference *message_reference,CMC_flags read_flags,CMC_message **message,CMC_ui_id ui_id,CMC_extension *read_extensions);

#define CMC_DO_NOT_MARK_AS_READ ((CMC_flags) 1)
#define CMC_MSG_AND_ATT_HDRS_ONLY ((CMC_flags) 2)
#define CMC_READ_FIRST_UNREAD_MESSAGE ((CMC_flags) 4)

  CMC_return_code WINAPI cmc_look_up(CMC_session_id session,CMC_recipient *recipient_in,CMC_flags look_up_flags,CMC_ui_id ui_id,CMC_uint32 *count,CMC_recipient **recipient_out,CMC_extension *look_up_extensions);

#define CMC_LOOKUP_RESOLVE_PREFIX_SEARCH ((CMC_flags) 1)
#define CMC_LOOKUP_RESOLVE_IDENTITY ((CMC_flags) 2)
#define CMC_LOOKUP_RESOLVE_UI ((CMC_flags) 4)
#define CMC_LOOKUP_DETAILS_UI ((CMC_flags) 8)
#define CMC_LOOKUP_ADDRESSING_UI ((CMC_flags) 16)

  CMC_return_code WINAPI cmc_free(CMC_buffer memory);
  CMC_return_code WINAPI cmc_logoff(CMC_session_id session,CMC_ui_id ui_id,CMC_flags logoff_flags,CMC_extension *logoff_extensions);

#define CMC_LOGOFF_UI_ALLOWED ((CMC_flags) 1)

  CMC_return_code WINAPI cmc_logon(CMC_string service,CMC_string user,CMC_string password,CMC_object_identifier character_set,CMC_ui_id ui_id,CMC_uint16 caller_cmc_version,CMC_flags logon_flags,CMC_session_id *session,CMC_extension *logon_extensions);

#define CMC_VERSION ((CMC_uint16) 100)

  CMC_return_code WINAPI cmc_query_configuration(CMC_session_id session,CMC_enum item,CMC_buffer reference,CMC_extension *config_extensions);

#define CMC_CONFIG_CHARACTER_SET ((CMC_enum) 1)
#define CMC_CONFIG_LINE_TERM ((CMC_enum) 2)
#define CMC_CONFIG_DEFAULT_SERVICE ((CMC_enum) 3)
#define CMC_CONFIG_DEFAULT_USER ((CMC_enum) 4)
#define CMC_CONFIG_REQ_PASSWORD ((CMC_enum) 5)
#define CMC_CONFIG_REQ_SERVICE ((CMC_enum) 6)
#define CMC_CONFIG_REQ_USER ((CMC_enum) 7)
#define CMC_CONFIG_UI_AVAIL ((CMC_enum) 8)
#define CMC_CONFIG_SUP_NOMKMSGREAD ((CMC_enum) 9)
#define CMC_CONFIG_SUP_COUNTED_STR ((CMC_enum) 10)
#define CMC_CONFIG_VER_IMPLEM ((CMC_enum) 11)
#define CMC_CONFIG_VER_SPEC ((CMC_enum) 12)

#define CMC_LINE_TERM_CRLF ((CMC_enum) 0)
#define CMC_LINE_TERM_CR ((CMC_enum) 1)
#define CMC_LINE_TERM_LF ((CMC_enum) 2)

#define CMC_REQUIRED_NO ((CMC_enum) 0)
#define CMC_REQUIRED_YES ((CMC_enum) 1)
#define CMC_REQUIRED_OPT ((CMC_enum) 2)

#define CMC_CHAR_CP437 "1 2 840 113556 3 2 437"
#define CMC_CHAR_CP850 "1 2 840 113556 3 2 850"
#define CMC_CHAR_CP1252 "1 2 840 113556 3 2 1252"
#define CMC_CHAR_ISTRING "1 2 840 113556 3 2 0"
#define CMC_CHAR_UNICODE "1 2 840 113556 3 2 1"

#define CMC_ERROR_DISPLAYED ((CMC_return_code) 0x00008000)
#define CMC_ERROR_RSV_MASK ((CMC_return_code) 0x0000FFFF)
#define CMC_ERROR_IMPL_MASK ((CMC_return_code) 0xFFFF0000)

#define CMC_SUCCESS ((CMC_return_code) 0)

#define CMC_E_AMBIGUOUS_RECIPIENT ((CMC_return_code) 1)
#define CMC_E_ATTACHMENT_NOT_FOUND ((CMC_return_code) 2)
#define CMC_E_ATTACHMENT_OPEN_FAILURE ((CMC_return_code) 3)
#define CMC_E_ATTACHMENT_READ_FAILURE ((CMC_return_code) 4)
#define CMC_E_ATTACHMENT_WRITE_FAILURE ((CMC_return_code) 5)
#define CMC_E_COUNTED_STRING_UNSUPPORTED ((CMC_return_code) 6)
#define CMC_E_DISK_FULL ((CMC_return_code) 7)
#define CMC_E_FAILURE ((CMC_return_code) 8)
#define CMC_E_INSUFFICIENT_MEMORY ((CMC_return_code) 9)
#define CMC_E_INVALID_CONFIGURATION ((CMC_return_code) 10)
#define CMC_E_INVALID_ENUM ((CMC_return_code) 11)
#define CMC_E_INVALID_FLAG ((CMC_return_code) 12)
#define CMC_E_INVALID_MEMORY ((CMC_return_code) 13)
#define CMC_E_INVALID_MESSAGE_PARAMETER ((CMC_return_code) 14)
#define CMC_E_INVALID_MESSAGE_REFERENCE ((CMC_return_code) 15)
#define CMC_E_INVALID_PARAMETER ((CMC_return_code) 16)
#define CMC_E_INVALID_SESSION_ID ((CMC_return_code) 17)
#define CMC_E_INVALID_UI_ID ((CMC_return_code) 18)
#define CMC_E_LOGON_FAILURE ((CMC_return_code) 19)
#define CMC_E_MESSAGE_IN_USE ((CMC_return_code) 20)
#define CMC_E_NOT_SUPPORTED ((CMC_return_code) 21)
#define CMC_E_PASSWORD_REQUIRED ((CMC_return_code) 22)
#define CMC_E_RECIPIENT_NOT_FOUND ((CMC_return_code) 23)
#define CMC_E_SERVICE_UNAVAILABLE ((CMC_return_code) 24)
#define CMC_E_TEXT_TOO_LARGE ((CMC_return_code) 25)
#define CMC_E_TOO_MANY_FILES ((CMC_return_code) 26)
#define CMC_E_TOO_MANY_RECIPIENTS ((CMC_return_code) 27)
#define CMC_E_UNABLE_TO_NOT_MARK_AS_READ ((CMC_return_code) 28)
#define CMC_E_UNRECOGNIZED_MESSAGE_TYPE ((CMC_return_code) 29)
#define CMC_E_UNSUPPORTED_ACTION ((CMC_return_code) 30)
#define CMC_E_UNSUPPORTED_CHARACTER_SET ((CMC_return_code) 31)
#define CMC_E_UNSUPPORTED_DATA_EXT ((CMC_return_code) 32)
#define CMC_E_UNSUPPORTED_FLAG ((CMC_return_code) 33)
#define CMC_E_UNSUPPORTED_FUNCTION_EXT ((CMC_return_code) 34)
#define CMC_E_UNSUPPORTED_VERSION ((CMC_return_code) 35)
#define CMC_E_USER_CANCEL ((CMC_return_code) 36)
#define CMC_E_USER_NOT_LOGGED_ON ((CMC_return_code) 37)

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                               usr/share/mingw-w64/include/xcmcext.h                                                               0100644 0000000 0000000 00000003406 12404413015 016163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _XCMCEXT_H
#define _XCMCEXT_H

#include <xcmc.h>

#ifdef __cplusplus
extern "C" {
#endif

#define CMC_XS_COM ((CMC_uint32) 0)
#define CMC_X_COM_SUPPORT_EXT ((CMC_uint32) 16)

  typedef struct {
    CMC_uint32 item_code;
    CMC_flags flags;
  } CMC_X_COM_support;

#define CMC_X_COM_SUPPORTED ((CMC_flags) 1)
#define CMC_X_COM_NOT_SUPPORTED ((CMC_flags) 2)
#define CMC_X_COM_DATA_EXT_SUPPORTED ((CMC_flags) 4)
#define CMC_X_COM_FUNC_EXT_SUPPORTED ((CMC_flags) 8)
#define CMC_X_COM_SUP_EXCLUDE ((CMC_flags) 16)

#define CMC_X_COM_CONFIG_DATA ((CMC_uint32) 17)

  typedef struct {
    CMC_uint16 ver_spec;
    CMC_uint16 ver_implem;
    CMC_object_identifier *character_set;
    CMC_enum line_term;
    CMC_string default_service;
    CMC_string default_user;
    CMC_enum req_password;
    CMC_enum req_service;
    CMC_enum req_user;
    CMC_boolean ui_avail;
    CMC_boolean sup_nomkmsgread;
    CMC_boolean sup_counted_str;
  } CMC_X_COM_configuration;

#define CMC_X_COM_CAN_SEND_RECIP ((CMC_uint32) 18)
#define CMC_X_COM_READY ((CMC_enum) 0)
#define CMC_X_COM_NOT_READY ((CMC_enum) 1)
#define CMC_X_COM_DEFER ((CMC_enum) 2)
#define CMC_X_COM_SAVE_MESSAGE ((CMC_uint32) 19)
#define CMC_X_COM_SENT_MESSAGE ((CMC_uint32) 20)
#define CMC_X_COM_TIME_RECEIVED ((CMC_uint32) 128)
#define CMC_X_COM_RECIP_ID ((CMC_uint32) 129)
#define CMC_X_COM_ATTACH_CHARPOS ((CMC_uint32) 130)
#define CMC_X_COM_PRIORITY ((CMC_uint32) 131)
#define CMC_X_COM_NORMAL ((CMC_enum) 0)
#define CMC_X_COM_URGENT ((CMC_enum) 1)
#define CMC_X_COM_LOW ((CMC_enum) 2)

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                          usr/share/mingw-w64/include/xcmcmsx2.h                                                              0100644 0000000 0000000 00000001315 12404413015 016251  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _XCMCMSX2_H
#define _XCMCMSX2_H

#include <xcmcmsxt.h>
#include <mapidefs.h>
#include <xcmc.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef MAPIX_H
  STDMETHODIMP_(SCODE) ScMAPIXFromCMC(CMC_session_id cmc_session,ULONG ulFlags,LPCIID lpInterface,LPMAPISESSION *lppMAPISession);
#endif

#define CMC_X_MS_ATTACH_MESSAGE ((CMC_flags) 4)

  typedef struct {
    CMC_message_reference *message;
    CMC_uint32 id;
    CMC_buffer object;
  } CMC_X_MS_ATTACH;

#ifdef __cplusplus
}
#endif
#endif

                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/xcmcmsxt.h                                                              0100644 0000000 0000000 00000002213 12404413015 016351  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef XCMCMSXT_H
#define XCMCMSXT_H

#ifdef __cplusplus
extern "C" {
#endif

#define MS_EXT_SET_ID (512)

#define CMC_XS_MS ((CMC_uint32) MS_EXT_SET_ID)
#define CMC_X_MS_SESSION_FLAGS ((CMC_uint32) MS_EXT_SET_ID + 16)
#define CMC_X_MS_NEW_SESSION ((CMC_flags) 1)
#define CMC_X_MS_FORCE_DOWNLOAD ((CMC_flags) 4)
#define CMC_X_MS_FUNCTION_FLAGS ((CMC_uint32) MS_EXT_SET_ID + 17)
#define CMC_X_MS_READ_ENV_ONLY ((CMC_flags) 1)
#define CMC_X_MS_READ_BODY_AS_FILE ((CMC_flags) 2)
#define CMC_X_MS_LIST_GUARANTEE_FIFO ((CMC_flags) 4)
#define CMC_X_MS_AB_NO_MODIFY ((CMC_flags) 8)
#define CMC_X_MS_ADDRESS_UI ((CMC_uint32) MS_EXT_SET_ID + 18)
#define CMC_X_MS_ATTACH_DATA ((CMC_uint32) MS_EXT_SET_ID + 128)
#define CMC_X_MS_ATTACH_OLE ((CMC_flags) 1)
#define CMC_X_MS_ATTACH_OLE_STATIC ((CMC_flags) 2)
#define CMC_X_MS_MESSAGE_DATA ((CMC_uint32) MS_EXT_SET_ID + 129)
#define CMC_X_MS_MSG_RECEIPT_REQ ((CMC_flags) 1)

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                     usr/share/mingw-w64/include/xenroll.h                                                               0100644 0000000 0000000 00000610631 12404413015 016177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error This stub requires an updated version of <rpcndr.h>
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif

#ifndef __xenroll_h__
#define __xenroll_h__

#ifndef __ICEnroll_FWD_DEFINED__
#define __ICEnroll_FWD_DEFINED__
typedef struct ICEnroll ICEnroll;
#endif

#ifndef __ICEnroll2_FWD_DEFINED__
#define __ICEnroll2_FWD_DEFINED__
typedef struct ICEnroll2 ICEnroll2;
#endif

#ifndef __ICEnroll3_FWD_DEFINED__
#define __ICEnroll3_FWD_DEFINED__
typedef struct ICEnroll3 ICEnroll3;
#endif

#ifndef __ICEnroll4_FWD_DEFINED__
#define __ICEnroll4_FWD_DEFINED__
typedef struct ICEnroll4 ICEnroll4;
#endif

#ifndef __IEnroll_FWD_DEFINED__
#define __IEnroll_FWD_DEFINED__
typedef struct IEnroll IEnroll;
#endif

#ifndef __IEnroll2_FWD_DEFINED__
#define __IEnroll2_FWD_DEFINED__
typedef struct IEnroll2 IEnroll2;
#endif

#ifndef __IEnroll4_FWD_DEFINED__
#define __IEnroll4_FWD_DEFINED__
typedef struct IEnroll4 IEnroll4;
#endif

#ifndef __CEnroll2_FWD_DEFINED__
#define __CEnroll2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEnroll2 CEnroll2;
#else
typedef struct CEnroll2 CEnroll2;
#endif
#endif

#ifndef __CEnroll_FWD_DEFINED__
#define __CEnroll_FWD_DEFINED__
#ifdef __cplusplus
typedef class CEnroll CEnroll;
#else
typedef struct CEnroll CEnroll;
#endif
#endif

#include "oaidl.h"
#include "ocidl.h"
#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __MIDL_user_allocate_free_DEFINED__
#define __MIDL_user_allocate_free_DEFINED__
  void *__RPC_API MIDL_user_allocate(size_t);
  void __RPC_API MIDL_user_free(void *);
#endif

#ifndef __ICEnroll_INTERFACE_DEFINED__
#define __ICEnroll_INTERFACE_DEFINED__

  extern const IID IID_ICEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __cplusplus
}
#endif
  struct ICEnroll : public IDispatch {
  public:
    virtual HRESULT WINAPI createFilePKCS10(BSTR DNName,BSTR Usage,BSTR wszPKCS10FileName) = 0;
    virtual HRESULT WINAPI acceptFilePKCS7(BSTR wszPKCS7FileName) = 0;
    virtual HRESULT WINAPI createPKCS10(BSTR DNName,BSTR Usage,BSTR *pPKCS10) = 0;
    virtual HRESULT WINAPI acceptPKCS7(BSTR PKCS7) = 0;
    virtual HRESULT WINAPI getCertFromPKCS7(BSTR wszPKCS7,BSTR *pbstrCert) = 0;
    virtual HRESULT WINAPI enumProviders(LONG dwIndex,LONG dwFlags,BSTR *pbstrProvName) = 0;
    virtual HRESULT WINAPI enumContainers(LONG dwIndex,BSTR *pbstr) = 0;
    virtual HRESULT WINAPI freeRequestInfo(BSTR PKCS7OrPKCS10) = 0;
    virtual HRESULT WINAPI get_MyStoreName(BSTR *pbstrName) = 0;
    virtual HRESULT WINAPI put_MyStoreName(BSTR bstrName) = 0;
    virtual HRESULT WINAPI get_MyStoreType(BSTR *pbstrType) = 0;
    virtual HRESULT WINAPI put_MyStoreType(BSTR bstrType) = 0;
    virtual HRESULT WINAPI get_MyStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_MyStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_CAStoreName(BSTR *pbstrName) = 0;
    virtual HRESULT WINAPI put_CAStoreName(BSTR bstrName) = 0;
    virtual HRESULT WINAPI get_CAStoreType(BSTR *pbstrType) = 0;
    virtual HRESULT WINAPI put_CAStoreType(BSTR bstrType) = 0;
    virtual HRESULT WINAPI get_CAStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_CAStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_RootStoreName(BSTR *pbstrName) = 0;
    virtual HRESULT WINAPI put_RootStoreName(BSTR bstrName) = 0;
    virtual HRESULT WINAPI get_RootStoreType(BSTR *pbstrType) = 0;
    virtual HRESULT WINAPI put_RootStoreType(BSTR bstrType) = 0;
    virtual HRESULT WINAPI get_RootStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_RootStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_RequestStoreName(BSTR *pbstrName) = 0;
    virtual HRESULT WINAPI put_RequestStoreName(BSTR bstrName) = 0;
    virtual HRESULT WINAPI get_RequestStoreType(BSTR *pbstrType) = 0;
    virtual HRESULT WINAPI put_RequestStoreType(BSTR bstrType) = 0;
    virtual HRESULT WINAPI get_RequestStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_RequestStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_ContainerName(BSTR *pbstrContainer) = 0;
    virtual HRESULT WINAPI put_ContainerName(BSTR bstrContainer) = 0;
    virtual HRESULT WINAPI get_ProviderName(BSTR *pbstrProvider) = 0;
    virtual HRESULT WINAPI put_ProviderName(BSTR bstrProvider) = 0;
    virtual HRESULT WINAPI get_ProviderType(LONG *pdwType) = 0;
    virtual HRESULT WINAPI put_ProviderType(LONG dwType) = 0;
    virtual HRESULT WINAPI get_KeySpec(LONG *pdw) = 0;
    virtual HRESULT WINAPI put_KeySpec(LONG dw) = 0;
    virtual HRESULT WINAPI get_ProviderFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_ProviderFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_UseExistingKeySet(WINBOOL *fUseExistingKeys) = 0;
    virtual HRESULT WINAPI put_UseExistingKeySet(WINBOOL fUseExistingKeys) = 0;
    virtual HRESULT WINAPI get_GenKeyFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_GenKeyFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_DeleteRequestCert(WINBOOL *fDelete) = 0;
    virtual HRESULT WINAPI put_DeleteRequestCert(WINBOOL fDelete) = 0;
    virtual HRESULT WINAPI get_WriteCertToCSP(WINBOOL *fBool) = 0;
    virtual HRESULT WINAPI put_WriteCertToCSP(WINBOOL fBool) = 0;
    virtual HRESULT WINAPI get_SPCFileName(BSTR *pbstr) = 0;
    virtual HRESULT WINAPI put_SPCFileName(BSTR bstr) = 0;
    virtual HRESULT WINAPI get_PVKFileName(BSTR *pbstr) = 0;
    virtual HRESULT WINAPI put_PVKFileName(BSTR bstr) = 0;
    virtual HRESULT WINAPI get_HashAlgorithm(BSTR *pbstr) = 0;
    virtual HRESULT WINAPI put_HashAlgorithm(BSTR bstr) = 0;
  };
#ifdef __cplusplus
  extern "C" {
#endif
#else
  typedef struct ICEnrollVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(ICEnroll *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(ICEnroll *This);
      ULONG (WINAPI *Release)(ICEnroll *This);
      HRESULT (WINAPI *GetTypeInfoCount)(ICEnroll *This,UINT *pctinfo);
      HRESULT (WINAPI *GetTypeInfo)(ICEnroll *This,UINT iTInfo,LCID lcid,ITypeInfo **ppTInfo);
      HRESULT (WINAPI *GetIDsOfNames)(ICEnroll *This,REFIID riid,LPOLESTR *rgszNames,UINT cNames,LCID lcid,DISPID *rgDispId);
      HRESULT (WINAPI *Invoke)(ICEnroll *This,DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);
      HRESULT (WINAPI *createFilePKCS10)(ICEnroll *This,BSTR DNName,BSTR Usage,BSTR wszPKCS10FileName);
      HRESULT (WINAPI *acceptFilePKCS7)(ICEnroll *This,BSTR wszPKCS7FileName);
      HRESULT (WINAPI *createPKCS10)(ICEnroll *This,BSTR DNName,BSTR Usage,BSTR *pPKCS10);
      HRESULT (WINAPI *acceptPKCS7)(ICEnroll *This,BSTR PKCS7);
      HRESULT (WINAPI *getCertFromPKCS7)(ICEnroll *This,BSTR wszPKCS7,BSTR *pbstrCert);
      HRESULT (WINAPI *enumProviders)(ICEnroll *This,LONG dwIndex,LONG dwFlags,BSTR *pbstrProvName);
      HRESULT (WINAPI *enumContainers)(ICEnroll *This,LONG dwIndex,BSTR *pbstr);
      HRESULT (WINAPI *freeRequestInfo)(ICEnroll *This,BSTR PKCS7OrPKCS10);
      HRESULT (WINAPI *get_MyStoreName)(ICEnroll *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_MyStoreName)(ICEnroll *This,BSTR bstrName);
      HRESULT (WINAPI *get_MyStoreType)(ICEnroll *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_MyStoreType)(ICEnroll *This,BSTR bstrType);
      HRESULT (WINAPI *get_MyStoreFlags)(ICEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_MyStoreFlags)(ICEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_CAStoreName)(ICEnroll *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_CAStoreName)(ICEnroll *This,BSTR bstrName);
      HRESULT (WINAPI *get_CAStoreType)(ICEnroll *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_CAStoreType)(ICEnroll *This,BSTR bstrType);
      HRESULT (WINAPI *get_CAStoreFlags)(ICEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_CAStoreFlags)(ICEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_RootStoreName)(ICEnroll *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RootStoreName)(ICEnroll *This,BSTR bstrName);
      HRESULT (WINAPI *get_RootStoreType)(ICEnroll *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RootStoreType)(ICEnroll *This,BSTR bstrType);
      HRESULT (WINAPI *get_RootStoreFlags)(ICEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RootStoreFlags)(ICEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_RequestStoreName)(ICEnroll *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RequestStoreName)(ICEnroll *This,BSTR bstrName);
      HRESULT (WINAPI *get_RequestStoreType)(ICEnroll *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RequestStoreType)(ICEnroll *This,BSTR bstrType);
      HRESULT (WINAPI *get_RequestStoreFlags)(ICEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RequestStoreFlags)(ICEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_ContainerName)(ICEnroll *This,BSTR *pbstrContainer);
      HRESULT (WINAPI *put_ContainerName)(ICEnroll *This,BSTR bstrContainer);
      HRESULT (WINAPI *get_ProviderName)(ICEnroll *This,BSTR *pbstrProvider);
      HRESULT (WINAPI *put_ProviderName)(ICEnroll *This,BSTR bstrProvider);
      HRESULT (WINAPI *get_ProviderType)(ICEnroll *This,LONG *pdwType);
      HRESULT (WINAPI *put_ProviderType)(ICEnroll *This,LONG dwType);
      HRESULT (WINAPI *get_KeySpec)(ICEnroll *This,LONG *pdw);
      HRESULT (WINAPI *put_KeySpec)(ICEnroll *This,LONG dw);
      HRESULT (WINAPI *get_ProviderFlags)(ICEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_ProviderFlags)(ICEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_UseExistingKeySet)(ICEnroll *This,WINBOOL *fUseExistingKeys);
      HRESULT (WINAPI *put_UseExistingKeySet)(ICEnroll *This,WINBOOL fUseExistingKeys);
      HRESULT (WINAPI *get_GenKeyFlags)(ICEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_GenKeyFlags)(ICEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_DeleteRequestCert)(ICEnroll *This,WINBOOL *fDelete);
      HRESULT (WINAPI *put_DeleteRequestCert)(ICEnroll *This,WINBOOL fDelete);
      HRESULT (WINAPI *get_WriteCertToCSP)(ICEnroll *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToCSP)(ICEnroll *This,WINBOOL fBool);
      HRESULT (WINAPI *get_SPCFileName)(ICEnroll *This,BSTR *pbstr);
      HRESULT (WINAPI *put_SPCFileName)(ICEnroll *This,BSTR bstr);
      HRESULT (WINAPI *get_PVKFileName)(ICEnroll *This,BSTR *pbstr);
      HRESULT (WINAPI *put_PVKFileName)(ICEnroll *This,BSTR bstr);
      HRESULT (WINAPI *get_HashAlgorithm)(ICEnroll *This,BSTR *pbstr);
      HRESULT (WINAPI *put_HashAlgorithm)(ICEnroll *This,BSTR bstr);
    END_INTERFACE
  } ICEnrollVtbl;
  struct ICEnroll {
    CONST_VTBL struct ICEnrollVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define ICEnroll_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ICEnroll_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ICEnroll_Release(This) (This)->lpVtbl->Release(This)
#define ICEnroll_GetTypeInfoCount(This,pctinfo) (This)->lpVtbl->GetTypeInfoCount(This,pctinfo)
#define ICEnroll_GetTypeInfo(This,iTInfo,lcid,ppTInfo) (This)->lpVtbl->GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ICEnroll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) (This)->lpVtbl->GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ICEnroll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) (This)->lpVtbl->Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define ICEnroll_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) (This)->lpVtbl->createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)
#define ICEnroll_acceptFilePKCS7(This,wszPKCS7FileName) (This)->lpVtbl->acceptFilePKCS7(This,wszPKCS7FileName)
#define ICEnroll_createPKCS10(This,DNName,Usage,pPKCS10) (This)->lpVtbl->createPKCS10(This,DNName,Usage,pPKCS10)
#define ICEnroll_acceptPKCS7(This,PKCS7) (This)->lpVtbl->acceptPKCS7(This,PKCS7)
#define ICEnroll_getCertFromPKCS7(This,wszPKCS7,pbstrCert) (This)->lpVtbl->getCertFromPKCS7(This,wszPKCS7,pbstrCert)
#define ICEnroll_enumProviders(This,dwIndex,dwFlags,pbstrProvName) (This)->lpVtbl->enumProviders(This,dwIndex,dwFlags,pbstrProvName)
#define ICEnroll_enumContainers(This,dwIndex,pbstr) (This)->lpVtbl->enumContainers(This,dwIndex,pbstr)
#define ICEnroll_freeRequestInfo(This,PKCS7OrPKCS10) (This)->lpVtbl->freeRequestInfo(This,PKCS7OrPKCS10)
#define ICEnroll_get_MyStoreName(This,pbstrName) (This)->lpVtbl->get_MyStoreName(This,pbstrName)
#define ICEnroll_put_MyStoreName(This,bstrName) (This)->lpVtbl->put_MyStoreName(This,bstrName)
#define ICEnroll_get_MyStoreType(This,pbstrType) (This)->lpVtbl->get_MyStoreType(This,pbstrType)
#define ICEnroll_put_MyStoreType(This,bstrType) (This)->lpVtbl->put_MyStoreType(This,bstrType)
#define ICEnroll_get_MyStoreFlags(This,pdwFlags) (This)->lpVtbl->get_MyStoreFlags(This,pdwFlags)
#define ICEnroll_put_MyStoreFlags(This,dwFlags) (This)->lpVtbl->put_MyStoreFlags(This,dwFlags)
#define ICEnroll_get_CAStoreName(This,pbstrName) (This)->lpVtbl->get_CAStoreName(This,pbstrName)
#define ICEnroll_put_CAStoreName(This,bstrName) (This)->lpVtbl->put_CAStoreName(This,bstrName)
#define ICEnroll_get_CAStoreType(This,pbstrType) (This)->lpVtbl->get_CAStoreType(This,pbstrType)
#define ICEnroll_put_CAStoreType(This,bstrType) (This)->lpVtbl->put_CAStoreType(This,bstrType)
#define ICEnroll_get_CAStoreFlags(This,pdwFlags) (This)->lpVtbl->get_CAStoreFlags(This,pdwFlags)
#define ICEnroll_put_CAStoreFlags(This,dwFlags) (This)->lpVtbl->put_CAStoreFlags(This,dwFlags)
#define ICEnroll_get_RootStoreName(This,pbstrName) (This)->lpVtbl->get_RootStoreName(This,pbstrName)
#define ICEnroll_put_RootStoreName(This,bstrName) (This)->lpVtbl->put_RootStoreName(This,bstrName)
#define ICEnroll_get_RootStoreType(This,pbstrType) (This)->lpVtbl->get_RootStoreType(This,pbstrType)
#define ICEnroll_put_RootStoreType(This,bstrType) (This)->lpVtbl->put_RootStoreType(This,bstrType)
#define ICEnroll_get_RootStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RootStoreFlags(This,pdwFlags)
#define ICEnroll_put_RootStoreFlags(This,dwFlags) (This)->lpVtbl->put_RootStoreFlags(This,dwFlags)
#define ICEnroll_get_RequestStoreName(This,pbstrName) (This)->lpVtbl->get_RequestStoreName(This,pbstrName)
#define ICEnroll_put_RequestStoreName(This,bstrName) (This)->lpVtbl->put_RequestStoreName(This,bstrName)
#define ICEnroll_get_RequestStoreType(This,pbstrType) (This)->lpVtbl->get_RequestStoreType(This,pbstrType)
#define ICEnroll_put_RequestStoreType(This,bstrType) (This)->lpVtbl->put_RequestStoreType(This,bstrType)
#define ICEnroll_get_RequestStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RequestStoreFlags(This,pdwFlags)
#define ICEnroll_put_RequestStoreFlags(This,dwFlags) (This)->lpVtbl->put_RequestStoreFlags(This,dwFlags)
#define ICEnroll_get_ContainerName(This,pbstrContainer) (This)->lpVtbl->get_ContainerName(This,pbstrContainer)
#define ICEnroll_put_ContainerName(This,bstrContainer) (This)->lpVtbl->put_ContainerName(This,bstrContainer)
#define ICEnroll_get_ProviderName(This,pbstrProvider) (This)->lpVtbl->get_ProviderName(This,pbstrProvider)
#define ICEnroll_put_ProviderName(This,bstrProvider) (This)->lpVtbl->put_ProviderName(This,bstrProvider)
#define ICEnroll_get_ProviderType(This,pdwType) (This)->lpVtbl->get_ProviderType(This,pdwType)
#define ICEnroll_put_ProviderType(This,dwType) (This)->lpVtbl->put_ProviderType(This,dwType)
#define ICEnroll_get_KeySpec(This,pdw) (This)->lpVtbl->get_KeySpec(This,pdw)
#define ICEnroll_put_KeySpec(This,dw) (This)->lpVtbl->put_KeySpec(This,dw)
#define ICEnroll_get_ProviderFlags(This,pdwFlags) (This)->lpVtbl->get_ProviderFlags(This,pdwFlags)
#define ICEnroll_put_ProviderFlags(This,dwFlags) (This)->lpVtbl->put_ProviderFlags(This,dwFlags)
#define ICEnroll_get_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->get_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll_put_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->put_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll_get_GenKeyFlags(This,pdwFlags) (This)->lpVtbl->get_GenKeyFlags(This,pdwFlags)
#define ICEnroll_put_GenKeyFlags(This,dwFlags) (This)->lpVtbl->put_GenKeyFlags(This,dwFlags)
#define ICEnroll_get_DeleteRequestCert(This,fDelete) (This)->lpVtbl->get_DeleteRequestCert(This,fDelete)
#define ICEnroll_put_DeleteRequestCert(This,fDelete) (This)->lpVtbl->put_DeleteRequestCert(This,fDelete)
#define ICEnroll_get_WriteCertToCSP(This,fBool) (This)->lpVtbl->get_WriteCertToCSP(This,fBool)
#define ICEnroll_put_WriteCertToCSP(This,fBool) (This)->lpVtbl->put_WriteCertToCSP(This,fBool)
#define ICEnroll_get_SPCFileName(This,pbstr) (This)->lpVtbl->get_SPCFileName(This,pbstr)
#define ICEnroll_put_SPCFileName(This,bstr) (This)->lpVtbl->put_SPCFileName(This,bstr)
#define ICEnroll_get_PVKFileName(This,pbstr) (This)->lpVtbl->get_PVKFileName(This,pbstr)
#define ICEnroll_put_PVKFileName(This,bstr) (This)->lpVtbl->put_PVKFileName(This,bstr)
#define ICEnroll_get_HashAlgorithm(This,pbstr) (This)->lpVtbl->get_HashAlgorithm(This,pbstr)
#define ICEnroll_put_HashAlgorithm(This,bstr) (This)->lpVtbl->put_HashAlgorithm(This,bstr)
#endif
#endif
  HRESULT WINAPI ICEnroll_createFilePKCS10_Proxy(ICEnroll *This,BSTR DNName,BSTR Usage,BSTR wszPKCS10FileName);
  void __RPC_STUB ICEnroll_createFilePKCS10_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_acceptFilePKCS7_Proxy(ICEnroll *This,BSTR wszPKCS7FileName);
  void __RPC_STUB ICEnroll_acceptFilePKCS7_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_createPKCS10_Proxy(ICEnroll *This,BSTR DNName,BSTR Usage,BSTR *pPKCS10);
  void __RPC_STUB ICEnroll_createPKCS10_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_acceptPKCS7_Proxy(ICEnroll *This,BSTR PKCS7);
  void __RPC_STUB ICEnroll_acceptPKCS7_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_getCertFromPKCS7_Proxy(ICEnroll *This,BSTR wszPKCS7,BSTR *pbstrCert);
  void __RPC_STUB ICEnroll_getCertFromPKCS7_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_enumProviders_Proxy(ICEnroll *This,LONG dwIndex,LONG dwFlags,BSTR *pbstrProvName);
  void __RPC_STUB ICEnroll_enumProviders_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_enumContainers_Proxy(ICEnroll *This,LONG dwIndex,BSTR *pbstr);
  void __RPC_STUB ICEnroll_enumContainers_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_freeRequestInfo_Proxy(ICEnroll *This,BSTR PKCS7OrPKCS10);
  void __RPC_STUB ICEnroll_freeRequestInfo_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_MyStoreName_Proxy(ICEnroll *This,BSTR *pbstrName);
  void __RPC_STUB ICEnroll_get_MyStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_MyStoreName_Proxy(ICEnroll *This,BSTR bstrName);
  void __RPC_STUB ICEnroll_put_MyStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_MyStoreType_Proxy(ICEnroll *This,BSTR *pbstrType);
  void __RPC_STUB ICEnroll_get_MyStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_MyStoreType_Proxy(ICEnroll *This,BSTR bstrType);
  void __RPC_STUB ICEnroll_put_MyStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_MyStoreFlags_Proxy(ICEnroll *This,LONG *pdwFlags);
  void __RPC_STUB ICEnroll_get_MyStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_MyStoreFlags_Proxy(ICEnroll *This,LONG dwFlags);
  void __RPC_STUB ICEnroll_put_MyStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_CAStoreName_Proxy(ICEnroll *This,BSTR *pbstrName);
  void __RPC_STUB ICEnroll_get_CAStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_CAStoreName_Proxy(ICEnroll *This,BSTR bstrName);
  void __RPC_STUB ICEnroll_put_CAStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_CAStoreType_Proxy(ICEnroll *This,BSTR *pbstrType);
  void __RPC_STUB ICEnroll_get_CAStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_CAStoreType_Proxy(ICEnroll *This,BSTR bstrType);
  void __RPC_STUB ICEnroll_put_CAStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_CAStoreFlags_Proxy(ICEnroll *This,LONG *pdwFlags);
  void __RPC_STUB ICEnroll_get_CAStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_CAStoreFlags_Proxy(ICEnroll *This,LONG dwFlags);
  void __RPC_STUB ICEnroll_put_CAStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_RootStoreName_Proxy(ICEnroll *This,BSTR *pbstrName);
  void __RPC_STUB ICEnroll_get_RootStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_RootStoreName_Proxy(ICEnroll *This,BSTR bstrName);
  void __RPC_STUB ICEnroll_put_RootStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_RootStoreType_Proxy(ICEnroll *This,BSTR *pbstrType);
  void __RPC_STUB ICEnroll_get_RootStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_RootStoreType_Proxy(ICEnroll *This,BSTR bstrType);
  void __RPC_STUB ICEnroll_put_RootStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_RootStoreFlags_Proxy(ICEnroll *This,LONG *pdwFlags);
  void __RPC_STUB ICEnroll_get_RootStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_RootStoreFlags_Proxy(ICEnroll *This,LONG dwFlags);
  void __RPC_STUB ICEnroll_put_RootStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_RequestStoreName_Proxy(ICEnroll *This,BSTR *pbstrName);
  void __RPC_STUB ICEnroll_get_RequestStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_RequestStoreName_Proxy(ICEnroll *This,BSTR bstrName);
  void __RPC_STUB ICEnroll_put_RequestStoreName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_RequestStoreType_Proxy(ICEnroll *This,BSTR *pbstrType);
  void __RPC_STUB ICEnroll_get_RequestStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_RequestStoreType_Proxy(ICEnroll *This,BSTR bstrType);
  void __RPC_STUB ICEnroll_put_RequestStoreType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_RequestStoreFlags_Proxy(ICEnroll *This,LONG *pdwFlags);
  void __RPC_STUB ICEnroll_get_RequestStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_RequestStoreFlags_Proxy(ICEnroll *This,LONG dwFlags);
  void __RPC_STUB ICEnroll_put_RequestStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_ContainerName_Proxy(ICEnroll *This,BSTR *pbstrContainer);
  void __RPC_STUB ICEnroll_get_ContainerName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_ContainerName_Proxy(ICEnroll *This,BSTR bstrContainer);
  void __RPC_STUB ICEnroll_put_ContainerName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_ProviderName_Proxy(ICEnroll *This,BSTR *pbstrProvider);
  void __RPC_STUB ICEnroll_get_ProviderName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_ProviderName_Proxy(ICEnroll *This,BSTR bstrProvider);
  void __RPC_STUB ICEnroll_put_ProviderName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_ProviderType_Proxy(ICEnroll *This,LONG *pdwType);
  void __RPC_STUB ICEnroll_get_ProviderType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_ProviderType_Proxy(ICEnroll *This,LONG dwType);
  void __RPC_STUB ICEnroll_put_ProviderType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_KeySpec_Proxy(ICEnroll *This,LONG *pdw);
  void __RPC_STUB ICEnroll_get_KeySpec_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_KeySpec_Proxy(ICEnroll *This,LONG dw);
  void __RPC_STUB ICEnroll_put_KeySpec_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_ProviderFlags_Proxy(ICEnroll *This,LONG *pdwFlags);
  void __RPC_STUB ICEnroll_get_ProviderFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_ProviderFlags_Proxy(ICEnroll *This,LONG dwFlags);
  void __RPC_STUB ICEnroll_put_ProviderFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_UseExistingKeySet_Proxy(ICEnroll *This,WINBOOL *fUseExistingKeys);
  void __RPC_STUB ICEnroll_get_UseExistingKeySet_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_UseExistingKeySet_Proxy(ICEnroll *This,WINBOOL fUseExistingKeys);
  void __RPC_STUB ICEnroll_put_UseExistingKeySet_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_GenKeyFlags_Proxy(ICEnroll *This,LONG *pdwFlags);
  void __RPC_STUB ICEnroll_get_GenKeyFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_GenKeyFlags_Proxy(ICEnroll *This,LONG dwFlags);
  void __RPC_STUB ICEnroll_put_GenKeyFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_DeleteRequestCert_Proxy(ICEnroll *This,WINBOOL *fDelete);
  void __RPC_STUB ICEnroll_get_DeleteRequestCert_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_DeleteRequestCert_Proxy(ICEnroll *This,WINBOOL fDelete);
  void __RPC_STUB ICEnroll_put_DeleteRequestCert_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_WriteCertToCSP_Proxy(ICEnroll *This,WINBOOL *fBool);
  void __RPC_STUB ICEnroll_get_WriteCertToCSP_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_WriteCertToCSP_Proxy(ICEnroll *This,WINBOOL fBool);
  void __RPC_STUB ICEnroll_put_WriteCertToCSP_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_SPCFileName_Proxy(ICEnroll *This,BSTR *pbstr);
  void __RPC_STUB ICEnroll_get_SPCFileName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_SPCFileName_Proxy(ICEnroll *This,BSTR bstr);
  void __RPC_STUB ICEnroll_put_SPCFileName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_PVKFileName_Proxy(ICEnroll *This,BSTR *pbstr);
  void __RPC_STUB ICEnroll_get_PVKFileName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_PVKFileName_Proxy(ICEnroll *This,BSTR bstr);
  void __RPC_STUB ICEnroll_put_PVKFileName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_get_HashAlgorithm_Proxy(ICEnroll *This,BSTR *pbstr);
  void __RPC_STUB ICEnroll_get_HashAlgorithm_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll_put_HashAlgorithm_Proxy(ICEnroll *This,BSTR bstr);
  void __RPC_STUB ICEnroll_put_HashAlgorithm_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __ICEnroll2_INTERFACE_DEFINED__
#define __ICEnroll2_INTERFACE_DEFINED__
  extern const IID IID_ICEnroll2;
#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __cplusplus
}
#endif
  struct ICEnroll2 : public ICEnroll {
  public:
    virtual HRESULT WINAPI addCertTypeToRequest(BSTR CertType) = 0;
    virtual HRESULT WINAPI addNameValuePairToSignature(BSTR Name,BSTR Value) = 0;
    virtual HRESULT WINAPI get_WriteCertToUserDS(WINBOOL *fBool) = 0;
    virtual HRESULT WINAPI put_WriteCertToUserDS(WINBOOL fBool) = 0;
    virtual HRESULT WINAPI get_EnableT61DNEncoding(WINBOOL *fBool) = 0;
    virtual HRESULT WINAPI put_EnableT61DNEncoding(WINBOOL fBool) = 0;
  };
#ifdef __cplusplus
  extern "C" {
#endif
#else
  typedef struct ICEnroll2Vtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(ICEnroll2 *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(ICEnroll2 *This);
      ULONG (WINAPI *Release)(ICEnroll2 *This);
      HRESULT (WINAPI *GetTypeInfoCount)(ICEnroll2 *This,UINT *pctinfo);
      HRESULT (WINAPI *GetTypeInfo)(ICEnroll2 *This,UINT iTInfo,LCID lcid,ITypeInfo **ppTInfo);
      HRESULT (WINAPI *GetIDsOfNames)(ICEnroll2 *This,REFIID riid,LPOLESTR *rgszNames,UINT cNames,LCID lcid,DISPID *rgDispId);
      HRESULT (WINAPI *Invoke)(ICEnroll2 *This,DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);
      HRESULT (WINAPI *createFilePKCS10)(ICEnroll2 *This,BSTR DNName,BSTR Usage,BSTR wszPKCS10FileName);
      HRESULT (WINAPI *acceptFilePKCS7)(ICEnroll2 *This,BSTR wszPKCS7FileName);
      HRESULT (WINAPI *createPKCS10)(ICEnroll2 *This,BSTR DNName,BSTR Usage,BSTR *pPKCS10);
      HRESULT (WINAPI *acceptPKCS7)(ICEnroll2 *This,BSTR PKCS7);
      HRESULT (WINAPI *getCertFromPKCS7)(ICEnroll2 *This,BSTR wszPKCS7,BSTR *pbstrCert);
      HRESULT (WINAPI *enumProviders)(ICEnroll2 *This,LONG dwIndex,LONG dwFlags,BSTR *pbstrProvName);
      HRESULT (WINAPI *enumContainers)(ICEnroll2 *This,LONG dwIndex,BSTR *pbstr);
      HRESULT (WINAPI *freeRequestInfo)(ICEnroll2 *This,BSTR PKCS7OrPKCS10);
      HRESULT (WINAPI *get_MyStoreName)(ICEnroll2 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_MyStoreName)(ICEnroll2 *This,BSTR bstrName);
      HRESULT (WINAPI *get_MyStoreType)(ICEnroll2 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_MyStoreType)(ICEnroll2 *This,BSTR bstrType);
      HRESULT (WINAPI *get_MyStoreFlags)(ICEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_MyStoreFlags)(ICEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_CAStoreName)(ICEnroll2 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_CAStoreName)(ICEnroll2 *This,BSTR bstrName);
      HRESULT (WINAPI *get_CAStoreType)(ICEnroll2 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_CAStoreType)(ICEnroll2 *This,BSTR bstrType);
      HRESULT (WINAPI *get_CAStoreFlags)(ICEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_CAStoreFlags)(ICEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RootStoreName)(ICEnroll2 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RootStoreName)(ICEnroll2 *This,BSTR bstrName);
      HRESULT (WINAPI *get_RootStoreType)(ICEnroll2 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RootStoreType)(ICEnroll2 *This,BSTR bstrType);
      HRESULT (WINAPI *get_RootStoreFlags)(ICEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RootStoreFlags)(ICEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RequestStoreName)(ICEnroll2 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RequestStoreName)(ICEnroll2 *This,BSTR bstrName);
      HRESULT (WINAPI *get_RequestStoreType)(ICEnroll2 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RequestStoreType)(ICEnroll2 *This,BSTR bstrType);
      HRESULT (WINAPI *get_RequestStoreFlags)(ICEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RequestStoreFlags)(ICEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_ContainerName)(ICEnroll2 *This,BSTR *pbstrContainer);
      HRESULT (WINAPI *put_ContainerName)(ICEnroll2 *This,BSTR bstrContainer);
      HRESULT (WINAPI *get_ProviderName)(ICEnroll2 *This,BSTR *pbstrProvider);
      HRESULT (WINAPI *put_ProviderName)(ICEnroll2 *This,BSTR bstrProvider);
      HRESULT (WINAPI *get_ProviderType)(ICEnroll2 *This,LONG *pdwType);
      HRESULT (WINAPI *put_ProviderType)(ICEnroll2 *This,LONG dwType);
      HRESULT (WINAPI *get_KeySpec)(ICEnroll2 *This,LONG *pdw);
      HRESULT (WINAPI *put_KeySpec)(ICEnroll2 *This,LONG dw);
      HRESULT (WINAPI *get_ProviderFlags)(ICEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_ProviderFlags)(ICEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_UseExistingKeySet)(ICEnroll2 *This,WINBOOL *fUseExistingKeys);
      HRESULT (WINAPI *put_UseExistingKeySet)(ICEnroll2 *This,WINBOOL fUseExistingKeys);
      HRESULT (WINAPI *get_GenKeyFlags)(ICEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_GenKeyFlags)(ICEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_DeleteRequestCert)(ICEnroll2 *This,WINBOOL *fDelete);
      HRESULT (WINAPI *put_DeleteRequestCert)(ICEnroll2 *This,WINBOOL fDelete);
      HRESULT (WINAPI *get_WriteCertToCSP)(ICEnroll2 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToCSP)(ICEnroll2 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_SPCFileName)(ICEnroll2 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_SPCFileName)(ICEnroll2 *This,BSTR bstr);
      HRESULT (WINAPI *get_PVKFileName)(ICEnroll2 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_PVKFileName)(ICEnroll2 *This,BSTR bstr);
      HRESULT (WINAPI *get_HashAlgorithm)(ICEnroll2 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_HashAlgorithm)(ICEnroll2 *This,BSTR bstr);
      HRESULT (WINAPI *addCertTypeToRequest)(ICEnroll2 *This,BSTR CertType);
      HRESULT (WINAPI *addNameValuePairToSignature)(ICEnroll2 *This,BSTR Name,BSTR Value);
      HRESULT (WINAPI *get_WriteCertToUserDS)(ICEnroll2 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToUserDS)(ICEnroll2 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_EnableT61DNEncoding)(ICEnroll2 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_EnableT61DNEncoding)(ICEnroll2 *This,WINBOOL fBool);
    END_INTERFACE
  } ICEnroll2Vtbl;
  struct ICEnroll2 {
    CONST_VTBL struct ICEnroll2Vtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define ICEnroll2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ICEnroll2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ICEnroll2_Release(This) (This)->lpVtbl->Release(This)
#define ICEnroll2_GetTypeInfoCount(This,pctinfo) (This)->lpVtbl->GetTypeInfoCount(This,pctinfo)
#define ICEnroll2_GetTypeInfo(This,iTInfo,lcid,ppTInfo) (This)->lpVtbl->GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ICEnroll2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) (This)->lpVtbl->GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ICEnroll2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) (This)->lpVtbl->Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define ICEnroll2_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) (This)->lpVtbl->createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)
#define ICEnroll2_acceptFilePKCS7(This,wszPKCS7FileName) (This)->lpVtbl->acceptFilePKCS7(This,wszPKCS7FileName)
#define ICEnroll2_createPKCS10(This,DNName,Usage,pPKCS10) (This)->lpVtbl->createPKCS10(This,DNName,Usage,pPKCS10)
#define ICEnroll2_acceptPKCS7(This,PKCS7) (This)->lpVtbl->acceptPKCS7(This,PKCS7)
#define ICEnroll2_getCertFromPKCS7(This,wszPKCS7,pbstrCert) (This)->lpVtbl->getCertFromPKCS7(This,wszPKCS7,pbstrCert)
#define ICEnroll2_enumProviders(This,dwIndex,dwFlags,pbstrProvName) (This)->lpVtbl->enumProviders(This,dwIndex,dwFlags,pbstrProvName)
#define ICEnroll2_enumContainers(This,dwIndex,pbstr) (This)->lpVtbl->enumContainers(This,dwIndex,pbstr)
#define ICEnroll2_freeRequestInfo(This,PKCS7OrPKCS10) (This)->lpVtbl->freeRequestInfo(This,PKCS7OrPKCS10)
#define ICEnroll2_get_MyStoreName(This,pbstrName) (This)->lpVtbl->get_MyStoreName(This,pbstrName)
#define ICEnroll2_put_MyStoreName(This,bstrName) (This)->lpVtbl->put_MyStoreName(This,bstrName)
#define ICEnroll2_get_MyStoreType(This,pbstrType) (This)->lpVtbl->get_MyStoreType(This,pbstrType)
#define ICEnroll2_put_MyStoreType(This,bstrType) (This)->lpVtbl->put_MyStoreType(This,bstrType)
#define ICEnroll2_get_MyStoreFlags(This,pdwFlags) (This)->lpVtbl->get_MyStoreFlags(This,pdwFlags)
#define ICEnroll2_put_MyStoreFlags(This,dwFlags) (This)->lpVtbl->put_MyStoreFlags(This,dwFlags)
#define ICEnroll2_get_CAStoreName(This,pbstrName) (This)->lpVtbl->get_CAStoreName(This,pbstrName)
#define ICEnroll2_put_CAStoreName(This,bstrName) (This)->lpVtbl->put_CAStoreName(This,bstrName)
#define ICEnroll2_get_CAStoreType(This,pbstrType) (This)->lpVtbl->get_CAStoreType(This,pbstrType)
#define ICEnroll2_put_CAStoreType(This,bstrType) (This)->lpVtbl->put_CAStoreType(This,bstrType)
#define ICEnroll2_get_CAStoreFlags(This,pdwFlags) (This)->lpVtbl->get_CAStoreFlags(This,pdwFlags)
#define ICEnroll2_put_CAStoreFlags(This,dwFlags) (This)->lpVtbl->put_CAStoreFlags(This,dwFlags)
#define ICEnroll2_get_RootStoreName(This,pbstrName) (This)->lpVtbl->get_RootStoreName(This,pbstrName)
#define ICEnroll2_put_RootStoreName(This,bstrName) (This)->lpVtbl->put_RootStoreName(This,bstrName)
#define ICEnroll2_get_RootStoreType(This,pbstrType) (This)->lpVtbl->get_RootStoreType(This,pbstrType)
#define ICEnroll2_put_RootStoreType(This,bstrType) (This)->lpVtbl->put_RootStoreType(This,bstrType)
#define ICEnroll2_get_RootStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RootStoreFlags(This,pdwFlags)
#define ICEnroll2_put_RootStoreFlags(This,dwFlags) (This)->lpVtbl->put_RootStoreFlags(This,dwFlags)
#define ICEnroll2_get_RequestStoreName(This,pbstrName) (This)->lpVtbl->get_RequestStoreName(This,pbstrName)
#define ICEnroll2_put_RequestStoreName(This,bstrName) (This)->lpVtbl->put_RequestStoreName(This,bstrName)
#define ICEnroll2_get_RequestStoreType(This,pbstrType) (This)->lpVtbl->get_RequestStoreType(This,pbstrType)
#define ICEnroll2_put_RequestStoreType(This,bstrType) (This)->lpVtbl->put_RequestStoreType(This,bstrType)
#define ICEnroll2_get_RequestStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RequestStoreFlags(This,pdwFlags)
#define ICEnroll2_put_RequestStoreFlags(This,dwFlags) (This)->lpVtbl->put_RequestStoreFlags(This,dwFlags)
#define ICEnroll2_get_ContainerName(This,pbstrContainer) (This)->lpVtbl->get_ContainerName(This,pbstrContainer)
#define ICEnroll2_put_ContainerName(This,bstrContainer) (This)->lpVtbl->put_ContainerName(This,bstrContainer)
#define ICEnroll2_get_ProviderName(This,pbstrProvider) (This)->lpVtbl->get_ProviderName(This,pbstrProvider)
#define ICEnroll2_put_ProviderName(This,bstrProvider) (This)->lpVtbl->put_ProviderName(This,bstrProvider)
#define ICEnroll2_get_ProviderType(This,pdwType) (This)->lpVtbl->get_ProviderType(This,pdwType)
#define ICEnroll2_put_ProviderType(This,dwType) (This)->lpVtbl->put_ProviderType(This,dwType)
#define ICEnroll2_get_KeySpec(This,pdw) (This)->lpVtbl->get_KeySpec(This,pdw)
#define ICEnroll2_put_KeySpec(This,dw) (This)->lpVtbl->put_KeySpec(This,dw)
#define ICEnroll2_get_ProviderFlags(This,pdwFlags) (This)->lpVtbl->get_ProviderFlags(This,pdwFlags)
#define ICEnroll2_put_ProviderFlags(This,dwFlags) (This)->lpVtbl->put_ProviderFlags(This,dwFlags)
#define ICEnroll2_get_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->get_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll2_put_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->put_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll2_get_GenKeyFlags(This,pdwFlags) (This)->lpVtbl->get_GenKeyFlags(This,pdwFlags)
#define ICEnroll2_put_GenKeyFlags(This,dwFlags) (This)->lpVtbl->put_GenKeyFlags(This,dwFlags)
#define ICEnroll2_get_DeleteRequestCert(This,fDelete) (This)->lpVtbl->get_DeleteRequestCert(This,fDelete)
#define ICEnroll2_put_DeleteRequestCert(This,fDelete) (This)->lpVtbl->put_DeleteRequestCert(This,fDelete)
#define ICEnroll2_get_WriteCertToCSP(This,fBool) (This)->lpVtbl->get_WriteCertToCSP(This,fBool)
#define ICEnroll2_put_WriteCertToCSP(This,fBool) (This)->lpVtbl->put_WriteCertToCSP(This,fBool)
#define ICEnroll2_get_SPCFileName(This,pbstr) (This)->lpVtbl->get_SPCFileName(This,pbstr)
#define ICEnroll2_put_SPCFileName(This,bstr) (This)->lpVtbl->put_SPCFileName(This,bstr)
#define ICEnroll2_get_PVKFileName(This,pbstr) (This)->lpVtbl->get_PVKFileName(This,pbstr)
#define ICEnroll2_put_PVKFileName(This,bstr) (This)->lpVtbl->put_PVKFileName(This,bstr)
#define ICEnroll2_get_HashAlgorithm(This,pbstr) (This)->lpVtbl->get_HashAlgorithm(This,pbstr)
#define ICEnroll2_put_HashAlgorithm(This,bstr) (This)->lpVtbl->put_HashAlgorithm(This,bstr)
#define ICEnroll2_addCertTypeToRequest(This,CertType) (This)->lpVtbl->addCertTypeToRequest(This,CertType)
#define ICEnroll2_addNameValuePairToSignature(This,Name,Value) (This)->lpVtbl->addNameValuePairToSignature(This,Name,Value)
#define ICEnroll2_get_WriteCertToUserDS(This,fBool) (This)->lpVtbl->get_WriteCertToUserDS(This,fBool)
#define ICEnroll2_put_WriteCertToUserDS(This,fBool) (This)->lpVtbl->put_WriteCertToUserDS(This,fBool)
#define ICEnroll2_get_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->get_EnableT61DNEncoding(This,fBool)
#define ICEnroll2_put_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->put_EnableT61DNEncoding(This,fBool)
#endif
#endif
  HRESULT WINAPI ICEnroll2_addCertTypeToRequest_Proxy(ICEnroll2 *This,BSTR CertType);
  void __RPC_STUB ICEnroll2_addCertTypeToRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll2_addNameValuePairToSignature_Proxy(ICEnroll2 *This,BSTR Name,BSTR Value);
  void __RPC_STUB ICEnroll2_addNameValuePairToSignature_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll2_get_WriteCertToUserDS_Proxy(ICEnroll2 *This,WINBOOL *fBool);
  void __RPC_STUB ICEnroll2_get_WriteCertToUserDS_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll2_put_WriteCertToUserDS_Proxy(ICEnroll2 *This,WINBOOL fBool);
  void __RPC_STUB ICEnroll2_put_WriteCertToUserDS_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll2_get_EnableT61DNEncoding_Proxy(ICEnroll2 *This,WINBOOL *fBool);
  void __RPC_STUB ICEnroll2_get_EnableT61DNEncoding_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll2_put_EnableT61DNEncoding_Proxy(ICEnroll2 *This,WINBOOL fBool);
  void __RPC_STUB ICEnroll2_put_EnableT61DNEncoding_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __ICEnroll3_INTERFACE_DEFINED__
#define __ICEnroll3_INTERFACE_DEFINED__
  extern const IID IID_ICEnroll3;
#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __cplusplus
}
#endif
  struct ICEnroll3 : public ICEnroll2 {
  public:
    virtual HRESULT WINAPI InstallPKCS7(BSTR PKCS7) = 0;
    virtual HRESULT WINAPI Reset(void) = 0;
    virtual HRESULT WINAPI GetSupportedKeySpec(LONG *pdwKeySpec) = 0;
    virtual HRESULT WINAPI GetKeyLen(WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize) = 0;
    virtual HRESULT WINAPI EnumAlgs(LONG dwIndex,LONG algClass,LONG *pdwAlgID) = 0;
    virtual HRESULT WINAPI GetAlgName(LONG algID,BSTR *pbstr) = 0;
    virtual HRESULT WINAPI put_ReuseHardwareKeyIfUnableToGenNew(WINBOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
    virtual HRESULT WINAPI get_ReuseHardwareKeyIfUnableToGenNew(WINBOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
    virtual HRESULT WINAPI put_HashAlgID(LONG hashAlgID) = 0;
    virtual HRESULT WINAPI get_HashAlgID(LONG *hashAlgID) = 0;
    virtual HRESULT WINAPI put_LimitExchangeKeyToEncipherment(WINBOOL fLimitExchangeKeyToEncipherment) = 0;
    virtual HRESULT WINAPI get_LimitExchangeKeyToEncipherment(WINBOOL *fLimitExchangeKeyToEncipherment) = 0;
    virtual HRESULT WINAPI put_EnableSMIMECapabilities(WINBOOL fEnableSMIMECapabilities) = 0;
    virtual HRESULT WINAPI get_EnableSMIMECapabilities(WINBOOL *fEnableSMIMECapabilities) = 0;
  };
#ifdef __cplusplus
  extern "C" {
#endif
#else
  typedef struct ICEnroll3Vtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(ICEnroll3 *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(ICEnroll3 *This);
      ULONG (WINAPI *Release)(ICEnroll3 *This);
      HRESULT (WINAPI *GetTypeInfoCount)(ICEnroll3 *This,UINT *pctinfo);
      HRESULT (WINAPI *GetTypeInfo)(ICEnroll3 *This,UINT iTInfo,LCID lcid,ITypeInfo **ppTInfo);
      HRESULT (WINAPI *GetIDsOfNames)(ICEnroll3 *This,REFIID riid,LPOLESTR *rgszNames,UINT cNames,LCID lcid,DISPID *rgDispId);
      HRESULT (WINAPI *Invoke)(ICEnroll3 *This,DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);
      HRESULT (WINAPI *createFilePKCS10)(ICEnroll3 *This,BSTR DNName,BSTR Usage,BSTR wszPKCS10FileName);
      HRESULT (WINAPI *acceptFilePKCS7)(ICEnroll3 *This,BSTR wszPKCS7FileName);
      HRESULT (WINAPI *createPKCS10)(ICEnroll3 *This,BSTR DNName,BSTR Usage,BSTR *pPKCS10);
      HRESULT (WINAPI *acceptPKCS7)(ICEnroll3 *This,BSTR PKCS7);
      HRESULT (WINAPI *getCertFromPKCS7)(ICEnroll3 *This,BSTR wszPKCS7,BSTR *pbstrCert);
      HRESULT (WINAPI *enumProviders)(ICEnroll3 *This,LONG dwIndex,LONG dwFlags,BSTR *pbstrProvName);
      HRESULT (WINAPI *enumContainers)(ICEnroll3 *This,LONG dwIndex,BSTR *pbstr);
      HRESULT (WINAPI *freeRequestInfo)(ICEnroll3 *This,BSTR PKCS7OrPKCS10);
      HRESULT (WINAPI *get_MyStoreName)(ICEnroll3 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_MyStoreName)(ICEnroll3 *This,BSTR bstrName);
      HRESULT (WINAPI *get_MyStoreType)(ICEnroll3 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_MyStoreType)(ICEnroll3 *This,BSTR bstrType);
      HRESULT (WINAPI *get_MyStoreFlags)(ICEnroll3 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_MyStoreFlags)(ICEnroll3 *This,LONG dwFlags);
      HRESULT (WINAPI *get_CAStoreName)(ICEnroll3 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_CAStoreName)(ICEnroll3 *This,BSTR bstrName);
      HRESULT (WINAPI *get_CAStoreType)(ICEnroll3 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_CAStoreType)(ICEnroll3 *This,BSTR bstrType);
      HRESULT (WINAPI *get_CAStoreFlags)(ICEnroll3 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_CAStoreFlags)(ICEnroll3 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RootStoreName)(ICEnroll3 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RootStoreName)(ICEnroll3 *This,BSTR bstrName);
      HRESULT (WINAPI *get_RootStoreType)(ICEnroll3 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RootStoreType)(ICEnroll3 *This,BSTR bstrType);
      HRESULT (WINAPI *get_RootStoreFlags)(ICEnroll3 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RootStoreFlags)(ICEnroll3 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RequestStoreName)(ICEnroll3 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RequestStoreName)(ICEnroll3 *This,BSTR bstrName);
      HRESULT (WINAPI *get_RequestStoreType)(ICEnroll3 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RequestStoreType)(ICEnroll3 *This,BSTR bstrType);
      HRESULT (WINAPI *get_RequestStoreFlags)(ICEnroll3 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RequestStoreFlags)(ICEnroll3 *This,LONG dwFlags);
      HRESULT (WINAPI *get_ContainerName)(ICEnroll3 *This,BSTR *pbstrContainer);
      HRESULT (WINAPI *put_ContainerName)(ICEnroll3 *This,BSTR bstrContainer);
      HRESULT (WINAPI *get_ProviderName)(ICEnroll3 *This,BSTR *pbstrProvider);
      HRESULT (WINAPI *put_ProviderName)(ICEnroll3 *This,BSTR bstrProvider);
      HRESULT (WINAPI *get_ProviderType)(ICEnroll3 *This,LONG *pdwType);
      HRESULT (WINAPI *put_ProviderType)(ICEnroll3 *This,LONG dwType);
      HRESULT (WINAPI *get_KeySpec)(ICEnroll3 *This,LONG *pdw);
      HRESULT (WINAPI *put_KeySpec)(ICEnroll3 *This,LONG dw);
      HRESULT (WINAPI *get_ProviderFlags)(ICEnroll3 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_ProviderFlags)(ICEnroll3 *This,LONG dwFlags);
      HRESULT (WINAPI *get_UseExistingKeySet)(ICEnroll3 *This,WINBOOL *fUseExistingKeys);
      HRESULT (WINAPI *put_UseExistingKeySet)(ICEnroll3 *This,WINBOOL fUseExistingKeys);
      HRESULT (WINAPI *get_GenKeyFlags)(ICEnroll3 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_GenKeyFlags)(ICEnroll3 *This,LONG dwFlags);
      HRESULT (WINAPI *get_DeleteRequestCert)(ICEnroll3 *This,WINBOOL *fDelete);
      HRESULT (WINAPI *put_DeleteRequestCert)(ICEnroll3 *This,WINBOOL fDelete);
      HRESULT (WINAPI *get_WriteCertToCSP)(ICEnroll3 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToCSP)(ICEnroll3 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_SPCFileName)(ICEnroll3 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_SPCFileName)(ICEnroll3 *This,BSTR bstr);
      HRESULT (WINAPI *get_PVKFileName)(ICEnroll3 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_PVKFileName)(ICEnroll3 *This,BSTR bstr);
      HRESULT (WINAPI *get_HashAlgorithm)(ICEnroll3 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_HashAlgorithm)(ICEnroll3 *This,BSTR bstr);
      HRESULT (WINAPI *addCertTypeToRequest)(ICEnroll3 *This,BSTR CertType);
      HRESULT (WINAPI *addNameValuePairToSignature)(ICEnroll3 *This,BSTR Name,BSTR Value);
      HRESULT (WINAPI *get_WriteCertToUserDS)(ICEnroll3 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToUserDS)(ICEnroll3 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_EnableT61DNEncoding)(ICEnroll3 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_EnableT61DNEncoding)(ICEnroll3 *This,WINBOOL fBool);
      HRESULT (WINAPI *InstallPKCS7)(ICEnroll3 *This,BSTR PKCS7);
      HRESULT (WINAPI *Reset)(ICEnroll3 *This);
      HRESULT (WINAPI *GetSupportedKeySpec)(ICEnroll3 *This,LONG *pdwKeySpec);
      HRESULT (WINAPI *GetKeyLen)(ICEnroll3 *This,WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize);
      HRESULT (WINAPI *EnumAlgs)(ICEnroll3 *This,LONG dwIndex,LONG algClass,LONG *pdwAlgID);
      HRESULT (WINAPI *GetAlgName)(ICEnroll3 *This,LONG algID,BSTR *pbstr);
      HRESULT (WINAPI *put_ReuseHardwareKeyIfUnableToGenNew)(ICEnroll3 *This,WINBOOL fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *get_ReuseHardwareKeyIfUnableToGenNew)(ICEnroll3 *This,WINBOOL *fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *put_HashAlgID)(ICEnroll3 *This,LONG hashAlgID);
      HRESULT (WINAPI *get_HashAlgID)(ICEnroll3 *This,LONG *hashAlgID);
      HRESULT (WINAPI *put_LimitExchangeKeyToEncipherment)(ICEnroll3 *This,WINBOOL fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *get_LimitExchangeKeyToEncipherment)(ICEnroll3 *This,WINBOOL *fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *put_EnableSMIMECapabilities)(ICEnroll3 *This,WINBOOL fEnableSMIMECapabilities);
      HRESULT (WINAPI *get_EnableSMIMECapabilities)(ICEnroll3 *This,WINBOOL *fEnableSMIMECapabilities);
    END_INTERFACE
  } ICEnroll3Vtbl;
  struct ICEnroll3 {
    CONST_VTBL struct ICEnroll3Vtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define ICEnroll3_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ICEnroll3_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ICEnroll3_Release(This) (This)->lpVtbl->Release(This)
#define ICEnroll3_GetTypeInfoCount(This,pctinfo) (This)->lpVtbl->GetTypeInfoCount(This,pctinfo)
#define ICEnroll3_GetTypeInfo(This,iTInfo,lcid,ppTInfo) (This)->lpVtbl->GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ICEnroll3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) (This)->lpVtbl->GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ICEnroll3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) (This)->lpVtbl->Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define ICEnroll3_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) (This)->lpVtbl->createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)
#define ICEnroll3_acceptFilePKCS7(This,wszPKCS7FileName) (This)->lpVtbl->acceptFilePKCS7(This,wszPKCS7FileName)
#define ICEnroll3_createPKCS10(This,DNName,Usage,pPKCS10) (This)->lpVtbl->createPKCS10(This,DNName,Usage,pPKCS10)
#define ICEnroll3_acceptPKCS7(This,PKCS7) (This)->lpVtbl->acceptPKCS7(This,PKCS7)
#define ICEnroll3_getCertFromPKCS7(This,wszPKCS7,pbstrCert) (This)->lpVtbl->getCertFromPKCS7(This,wszPKCS7,pbstrCert)
#define ICEnroll3_enumProviders(This,dwIndex,dwFlags,pbstrProvName) (This)->lpVtbl->enumProviders(This,dwIndex,dwFlags,pbstrProvName)
#define ICEnroll3_enumContainers(This,dwIndex,pbstr) (This)->lpVtbl->enumContainers(This,dwIndex,pbstr)
#define ICEnroll3_freeRequestInfo(This,PKCS7OrPKCS10) (This)->lpVtbl->freeRequestInfo(This,PKCS7OrPKCS10)
#define ICEnroll3_get_MyStoreName(This,pbstrName) (This)->lpVtbl->get_MyStoreName(This,pbstrName)
#define ICEnroll3_put_MyStoreName(This,bstrName) (This)->lpVtbl->put_MyStoreName(This,bstrName)
#define ICEnroll3_get_MyStoreType(This,pbstrType) (This)->lpVtbl->get_MyStoreType(This,pbstrType)
#define ICEnroll3_put_MyStoreType(This,bstrType) (This)->lpVtbl->put_MyStoreType(This,bstrType)
#define ICEnroll3_get_MyStoreFlags(This,pdwFlags) (This)->lpVtbl->get_MyStoreFlags(This,pdwFlags)
#define ICEnroll3_put_MyStoreFlags(This,dwFlags) (This)->lpVtbl->put_MyStoreFlags(This,dwFlags)
#define ICEnroll3_get_CAStoreName(This,pbstrName) (This)->lpVtbl->get_CAStoreName(This,pbstrName)
#define ICEnroll3_put_CAStoreName(This,bstrName) (This)->lpVtbl->put_CAStoreName(This,bstrName)
#define ICEnroll3_get_CAStoreType(This,pbstrType) (This)->lpVtbl->get_CAStoreType(This,pbstrType)
#define ICEnroll3_put_CAStoreType(This,bstrType) (This)->lpVtbl->put_CAStoreType(This,bstrType)
#define ICEnroll3_get_CAStoreFlags(This,pdwFlags) (This)->lpVtbl->get_CAStoreFlags(This,pdwFlags)
#define ICEnroll3_put_CAStoreFlags(This,dwFlags) (This)->lpVtbl->put_CAStoreFlags(This,dwFlags)
#define ICEnroll3_get_RootStoreName(This,pbstrName) (This)->lpVtbl->get_RootStoreName(This,pbstrName)
#define ICEnroll3_put_RootStoreName(This,bstrName) (This)->lpVtbl->put_RootStoreName(This,bstrName)
#define ICEnroll3_get_RootStoreType(This,pbstrType) (This)->lpVtbl->get_RootStoreType(This,pbstrType)
#define ICEnroll3_put_RootStoreType(This,bstrType) (This)->lpVtbl->put_RootStoreType(This,bstrType)
#define ICEnroll3_get_RootStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RootStoreFlags(This,pdwFlags)
#define ICEnroll3_put_RootStoreFlags(This,dwFlags) (This)->lpVtbl->put_RootStoreFlags(This,dwFlags)
#define ICEnroll3_get_RequestStoreName(This,pbstrName) (This)->lpVtbl->get_RequestStoreName(This,pbstrName)
#define ICEnroll3_put_RequestStoreName(This,bstrName) (This)->lpVtbl->put_RequestStoreName(This,bstrName)
#define ICEnroll3_get_RequestStoreType(This,pbstrType) (This)->lpVtbl->get_RequestStoreType(This,pbstrType)
#define ICEnroll3_put_RequestStoreType(This,bstrType) (This)->lpVtbl->put_RequestStoreType(This,bstrType)
#define ICEnroll3_get_RequestStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RequestStoreFlags(This,pdwFlags)
#define ICEnroll3_put_RequestStoreFlags(This,dwFlags) (This)->lpVtbl->put_RequestStoreFlags(This,dwFlags)
#define ICEnroll3_get_ContainerName(This,pbstrContainer) (This)->lpVtbl->get_ContainerName(This,pbstrContainer)
#define ICEnroll3_put_ContainerName(This,bstrContainer) (This)->lpVtbl->put_ContainerName(This,bstrContainer)
#define ICEnroll3_get_ProviderName(This,pbstrProvider) (This)->lpVtbl->get_ProviderName(This,pbstrProvider)
#define ICEnroll3_put_ProviderName(This,bstrProvider) (This)->lpVtbl->put_ProviderName(This,bstrProvider)
#define ICEnroll3_get_ProviderType(This,pdwType) (This)->lpVtbl->get_ProviderType(This,pdwType)
#define ICEnroll3_put_ProviderType(This,dwType) (This)->lpVtbl->put_ProviderType(This,dwType)
#define ICEnroll3_get_KeySpec(This,pdw) (This)->lpVtbl->get_KeySpec(This,pdw)
#define ICEnroll3_put_KeySpec(This,dw) (This)->lpVtbl->put_KeySpec(This,dw)
#define ICEnroll3_get_ProviderFlags(This,pdwFlags) (This)->lpVtbl->get_ProviderFlags(This,pdwFlags)
#define ICEnroll3_put_ProviderFlags(This,dwFlags) (This)->lpVtbl->put_ProviderFlags(This,dwFlags)
#define ICEnroll3_get_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->get_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll3_put_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->put_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll3_get_GenKeyFlags(This,pdwFlags) (This)->lpVtbl->get_GenKeyFlags(This,pdwFlags)
#define ICEnroll3_put_GenKeyFlags(This,dwFlags) (This)->lpVtbl->put_GenKeyFlags(This,dwFlags)
#define ICEnroll3_get_DeleteRequestCert(This,fDelete) (This)->lpVtbl->get_DeleteRequestCert(This,fDelete)
#define ICEnroll3_put_DeleteRequestCert(This,fDelete) (This)->lpVtbl->put_DeleteRequestCert(This,fDelete)
#define ICEnroll3_get_WriteCertToCSP(This,fBool) (This)->lpVtbl->get_WriteCertToCSP(This,fBool)
#define ICEnroll3_put_WriteCertToCSP(This,fBool) (This)->lpVtbl->put_WriteCertToCSP(This,fBool)
#define ICEnroll3_get_SPCFileName(This,pbstr) (This)->lpVtbl->get_SPCFileName(This,pbstr)
#define ICEnroll3_put_SPCFileName(This,bstr) (This)->lpVtbl->put_SPCFileName(This,bstr)
#define ICEnroll3_get_PVKFileName(This,pbstr) (This)->lpVtbl->get_PVKFileName(This,pbstr)
#define ICEnroll3_put_PVKFileName(This,bstr) (This)->lpVtbl->put_PVKFileName(This,bstr)
#define ICEnroll3_get_HashAlgorithm(This,pbstr) (This)->lpVtbl->get_HashAlgorithm(This,pbstr)
#define ICEnroll3_put_HashAlgorithm(This,bstr) (This)->lpVtbl->put_HashAlgorithm(This,bstr)
#define ICEnroll3_addCertTypeToRequest(This,CertType) (This)->lpVtbl->addCertTypeToRequest(This,CertType)
#define ICEnroll3_addNameValuePairToSignature(This,Name,Value) (This)->lpVtbl->addNameValuePairToSignature(This,Name,Value)
#define ICEnroll3_get_WriteCertToUserDS(This,fBool) (This)->lpVtbl->get_WriteCertToUserDS(This,fBool)
#define ICEnroll3_put_WriteCertToUserDS(This,fBool) (This)->lpVtbl->put_WriteCertToUserDS(This,fBool)
#define ICEnroll3_get_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->get_EnableT61DNEncoding(This,fBool)
#define ICEnroll3_put_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->put_EnableT61DNEncoding(This,fBool)
#define ICEnroll3_InstallPKCS7(This,PKCS7) (This)->lpVtbl->InstallPKCS7(This,PKCS7)
#define ICEnroll3_Reset(This) (This)->lpVtbl->Reset(This)
#define ICEnroll3_GetSupportedKeySpec(This,pdwKeySpec) (This)->lpVtbl->GetSupportedKeySpec(This,pdwKeySpec)
#define ICEnroll3_GetKeyLen(This,fMin,fExchange,pdwKeySize) (This)->lpVtbl->GetKeyLen(This,fMin,fExchange,pdwKeySize)
#define ICEnroll3_EnumAlgs(This,dwIndex,algClass,pdwAlgID) (This)->lpVtbl->EnumAlgs(This,dwIndex,algClass,pdwAlgID)
#define ICEnroll3_GetAlgName(This,algID,pbstr) (This)->lpVtbl->GetAlgName(This,algID,pbstr)
#define ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define ICEnroll3_put_HashAlgID(This,hashAlgID) (This)->lpVtbl->put_HashAlgID(This,hashAlgID)
#define ICEnroll3_get_HashAlgID(This,hashAlgID) (This)->lpVtbl->get_HashAlgID(This,hashAlgID)
#define ICEnroll3_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define ICEnroll3_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define ICEnroll3_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#define ICEnroll3_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#endif
#endif
  HRESULT WINAPI ICEnroll3_InstallPKCS7_Proxy(ICEnroll3 *This,BSTR PKCS7);
  void __RPC_STUB ICEnroll3_InstallPKCS7_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_Reset_Proxy(ICEnroll3 *This);
  void __RPC_STUB ICEnroll3_Reset_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_GetSupportedKeySpec_Proxy(ICEnroll3 *This,LONG *pdwKeySpec);
  void __RPC_STUB ICEnroll3_GetSupportedKeySpec_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_GetKeyLen_Proxy(ICEnroll3 *This,WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize);
  void __RPC_STUB ICEnroll3_GetKeyLen_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_EnumAlgs_Proxy(ICEnroll3 *This,LONG dwIndex,LONG algClass,LONG *pdwAlgID);
  void __RPC_STUB ICEnroll3_EnumAlgs_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_GetAlgName_Proxy(ICEnroll3 *This,LONG algID,BSTR *pbstr);
  void __RPC_STUB ICEnroll3_GetAlgName_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew_Proxy(ICEnroll3 *This,WINBOOL fReuseHardwareKeyIfUnableToGenNew);
  void __RPC_STUB ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew_Proxy(ICEnroll3 *This,WINBOOL *fReuseHardwareKeyIfUnableToGenNew);
  void __RPC_STUB ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_put_HashAlgID_Proxy(ICEnroll3 *This,LONG hashAlgID);
  void __RPC_STUB ICEnroll3_put_HashAlgID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_get_HashAlgID_Proxy(ICEnroll3 *This,LONG *hashAlgID);
  void __RPC_STUB ICEnroll3_get_HashAlgID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_put_LimitExchangeKeyToEncipherment_Proxy(ICEnroll3 *This,WINBOOL fLimitExchangeKeyToEncipherment);
  void __RPC_STUB ICEnroll3_put_LimitExchangeKeyToEncipherment_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_get_LimitExchangeKeyToEncipherment_Proxy(ICEnroll3 *This,WINBOOL *fLimitExchangeKeyToEncipherment);
  void __RPC_STUB ICEnroll3_get_LimitExchangeKeyToEncipherment_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_put_EnableSMIMECapabilities_Proxy(ICEnroll3 *This,WINBOOL fEnableSMIMECapabilities);
  void __RPC_STUB ICEnroll3_put_EnableSMIMECapabilities_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll3_get_EnableSMIMECapabilities_Proxy(ICEnroll3 *This,WINBOOL *fEnableSMIMECapabilities);
  void __RPC_STUB ICEnroll3_get_EnableSMIMECapabilities_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __ICEnroll4_INTERFACE_DEFINED__
#define __ICEnroll4_INTERFACE_DEFINED__
  extern const IID IID_ICEnroll4;
#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __cplusplus
}
#endif
  struct ICEnroll4 : public ICEnroll3 {
  public:
    virtual HRESULT WINAPI put_PrivateKeyArchiveCertificate(BSTR bstrCert) = 0;
    virtual HRESULT WINAPI get_PrivateKeyArchiveCertificate(BSTR *pbstrCert) = 0;
    virtual HRESULT WINAPI put_ThumbPrint(BSTR bstrThumbPrint) = 0;
    virtual HRESULT WINAPI get_ThumbPrint(BSTR *pbstrThumbPrint) = 0;
    virtual HRESULT WINAPI binaryToString(LONG Flags,BSTR strBinary,BSTR *pstrEncoded) = 0;
    virtual HRESULT WINAPI stringToBinary(LONG Flags,BSTR strEncoded,BSTR *pstrBinary) = 0;
    virtual HRESULT WINAPI addExtensionToRequest(LONG Flags,BSTR strName,BSTR strValue) = 0;
    virtual HRESULT WINAPI addAttributeToRequest(LONG Flags,BSTR strName,BSTR strValue) = 0;
    virtual HRESULT WINAPI addNameValuePairToRequest(LONG Flags,BSTR strName,BSTR strValue) = 0;
    virtual HRESULT WINAPI resetExtensions(void) = 0;
    virtual HRESULT WINAPI resetAttributes(void) = 0;
    virtual HRESULT WINAPI createRequest(LONG Flags,BSTR strDNName,BSTR Usage,BSTR *pstrRequest) = 0;
    virtual HRESULT WINAPI createFileRequest(LONG Flags,BSTR strDNName,BSTR strUsage,BSTR strRequestFileName) = 0;
    virtual HRESULT WINAPI acceptResponse(BSTR strResponse) = 0;
    virtual HRESULT WINAPI acceptFileResponse(BSTR strResponseFileName) = 0;
    virtual HRESULT WINAPI getCertFromResponse(BSTR strResponse,BSTR *pstrCert) = 0;
    virtual HRESULT WINAPI getCertFromFileResponse(BSTR strResponseFileName,BSTR *pstrCert) = 0;
    virtual HRESULT WINAPI createPFX(BSTR strPassword,BSTR *pstrPFX) = 0;
    virtual HRESULT WINAPI createFilePFX(BSTR strPassword,BSTR strPFXFileName) = 0;
    virtual HRESULT WINAPI setPendingRequestInfo(LONG lRequestID,BSTR strCADNS,BSTR strCAName,BSTR strFriendlyName) = 0;
    virtual HRESULT WINAPI enumPendingRequest(LONG lIndex,LONG lDesiredProperty,VARIANT *pvarProperty) = 0;
    virtual HRESULT WINAPI removePendingRequest(BSTR strThumbprint) = 0;
    virtual HRESULT WINAPI GetKeyLenEx(LONG lSizeSpec,LONG lKeySpec,LONG *pdwKeySize) = 0;
    virtual HRESULT WINAPI InstallPKCS7Ex(BSTR PKCS7,LONG *plCertInstalled) = 0;
    virtual HRESULT WINAPI addCertTypeToRequestEx(LONG lType,BSTR bstrOIDOrName,LONG lMajorVersion,WINBOOL fMinorVersion,LONG lMinorVersion) = 0;
    virtual HRESULT WINAPI getProviderType(BSTR strProvName,LONG *plProvType) = 0;
    virtual HRESULT WINAPI put_SignerCertificate(BSTR bstrCert) = 0;
    virtual HRESULT WINAPI put_ClientId(LONG lClientId) = 0;
    virtual HRESULT WINAPI get_ClientId(LONG *plClientId) = 0;
    virtual HRESULT WINAPI addBlobPropertyToCertificate(LONG lPropertyId,LONG lReserved,BSTR bstrProperty) = 0;
    virtual HRESULT WINAPI resetBlobProperties(void) = 0;
    virtual HRESULT WINAPI put_IncludeSubjectKeyID(WINBOOL fInclude) = 0;
    virtual HRESULT WINAPI get_IncludeSubjectKeyID(WINBOOL *pfInclude) = 0;
  };
#ifdef __cplusplus
  extern "C" {
#endif
#else
  typedef struct ICEnroll4Vtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(ICEnroll4 *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(ICEnroll4 *This);
      ULONG (WINAPI *Release)(ICEnroll4 *This);
      HRESULT (WINAPI *GetTypeInfoCount)(ICEnroll4 *This,UINT *pctinfo);
      HRESULT (WINAPI *GetTypeInfo)(ICEnroll4 *This,UINT iTInfo,LCID lcid,ITypeInfo **ppTInfo);
      HRESULT (WINAPI *GetIDsOfNames)(ICEnroll4 *This,REFIID riid,LPOLESTR *rgszNames,UINT cNames,LCID lcid,DISPID *rgDispId);
      HRESULT (WINAPI *Invoke)(ICEnroll4 *This,DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);
      HRESULT (WINAPI *createFilePKCS10)(ICEnroll4 *This,BSTR DNName,BSTR Usage,BSTR wszPKCS10FileName);
      HRESULT (WINAPI *acceptFilePKCS7)(ICEnroll4 *This,BSTR wszPKCS7FileName);
      HRESULT (WINAPI *createPKCS10)(ICEnroll4 *This,BSTR DNName,BSTR Usage,BSTR *pPKCS10);
      HRESULT (WINAPI *acceptPKCS7)(ICEnroll4 *This,BSTR PKCS7);
      HRESULT (WINAPI *getCertFromPKCS7)(ICEnroll4 *This,BSTR wszPKCS7,BSTR *pbstrCert);
      HRESULT (WINAPI *enumProviders)(ICEnroll4 *This,LONG dwIndex,LONG dwFlags,BSTR *pbstrProvName);
      HRESULT (WINAPI *enumContainers)(ICEnroll4 *This,LONG dwIndex,BSTR *pbstr);
      HRESULT (WINAPI *freeRequestInfo)(ICEnroll4 *This,BSTR PKCS7OrPKCS10);
      HRESULT (WINAPI *get_MyStoreName)(ICEnroll4 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_MyStoreName)(ICEnroll4 *This,BSTR bstrName);
      HRESULT (WINAPI *get_MyStoreType)(ICEnroll4 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_MyStoreType)(ICEnroll4 *This,BSTR bstrType);
      HRESULT (WINAPI *get_MyStoreFlags)(ICEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_MyStoreFlags)(ICEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_CAStoreName)(ICEnroll4 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_CAStoreName)(ICEnroll4 *This,BSTR bstrName);
      HRESULT (WINAPI *get_CAStoreType)(ICEnroll4 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_CAStoreType)(ICEnroll4 *This,BSTR bstrType);
      HRESULT (WINAPI *get_CAStoreFlags)(ICEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_CAStoreFlags)(ICEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RootStoreName)(ICEnroll4 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RootStoreName)(ICEnroll4 *This,BSTR bstrName);
      HRESULT (WINAPI *get_RootStoreType)(ICEnroll4 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RootStoreType)(ICEnroll4 *This,BSTR bstrType);
      HRESULT (WINAPI *get_RootStoreFlags)(ICEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RootStoreFlags)(ICEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RequestStoreName)(ICEnroll4 *This,BSTR *pbstrName);
      HRESULT (WINAPI *put_RequestStoreName)(ICEnroll4 *This,BSTR bstrName);
      HRESULT (WINAPI *get_RequestStoreType)(ICEnroll4 *This,BSTR *pbstrType);
      HRESULT (WINAPI *put_RequestStoreType)(ICEnroll4 *This,BSTR bstrType);
      HRESULT (WINAPI *get_RequestStoreFlags)(ICEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RequestStoreFlags)(ICEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_ContainerName)(ICEnroll4 *This,BSTR *pbstrContainer);
      HRESULT (WINAPI *put_ContainerName)(ICEnroll4 *This,BSTR bstrContainer);
      HRESULT (WINAPI *get_ProviderName)(ICEnroll4 *This,BSTR *pbstrProvider);
      HRESULT (WINAPI *put_ProviderName)(ICEnroll4 *This,BSTR bstrProvider);
      HRESULT (WINAPI *get_ProviderType)(ICEnroll4 *This,LONG *pdwType);
      HRESULT (WINAPI *put_ProviderType)(ICEnroll4 *This,LONG dwType);
      HRESULT (WINAPI *get_KeySpec)(ICEnroll4 *This,LONG *pdw);
      HRESULT (WINAPI *put_KeySpec)(ICEnroll4 *This,LONG dw);
      HRESULT (WINAPI *get_ProviderFlags)(ICEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_ProviderFlags)(ICEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_UseExistingKeySet)(ICEnroll4 *This,WINBOOL *fUseExistingKeys);
      HRESULT (WINAPI *put_UseExistingKeySet)(ICEnroll4 *This,WINBOOL fUseExistingKeys);
      HRESULT (WINAPI *get_GenKeyFlags)(ICEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_GenKeyFlags)(ICEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_DeleteRequestCert)(ICEnroll4 *This,WINBOOL *fDelete);
      HRESULT (WINAPI *put_DeleteRequestCert)(ICEnroll4 *This,WINBOOL fDelete);
      HRESULT (WINAPI *get_WriteCertToCSP)(ICEnroll4 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToCSP)(ICEnroll4 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_SPCFileName)(ICEnroll4 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_SPCFileName)(ICEnroll4 *This,BSTR bstr);
      HRESULT (WINAPI *get_PVKFileName)(ICEnroll4 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_PVKFileName)(ICEnroll4 *This,BSTR bstr);
      HRESULT (WINAPI *get_HashAlgorithm)(ICEnroll4 *This,BSTR *pbstr);
      HRESULT (WINAPI *put_HashAlgorithm)(ICEnroll4 *This,BSTR bstr);
      HRESULT (WINAPI *addCertTypeToRequest)(ICEnroll4 *This,BSTR CertType);
      HRESULT (WINAPI *addNameValuePairToSignature)(ICEnroll4 *This,BSTR Name,BSTR Value);
      HRESULT (WINAPI *get_WriteCertToUserDS)(ICEnroll4 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToUserDS)(ICEnroll4 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_EnableT61DNEncoding)(ICEnroll4 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_EnableT61DNEncoding)(ICEnroll4 *This,WINBOOL fBool);
      HRESULT (WINAPI *InstallPKCS7)(ICEnroll4 *This,BSTR PKCS7);
      HRESULT (WINAPI *Reset)(ICEnroll4 *This);
      HRESULT (WINAPI *GetSupportedKeySpec)(ICEnroll4 *This,LONG *pdwKeySpec);
      HRESULT (WINAPI *GetKeyLen)(ICEnroll4 *This,WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize);
      HRESULT (WINAPI *EnumAlgs)(ICEnroll4 *This,LONG dwIndex,LONG algClass,LONG *pdwAlgID);
      HRESULT (WINAPI *GetAlgName)(ICEnroll4 *This,LONG algID,BSTR *pbstr);
      HRESULT (WINAPI *put_ReuseHardwareKeyIfUnableToGenNew)(ICEnroll4 *This,WINBOOL fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *get_ReuseHardwareKeyIfUnableToGenNew)(ICEnroll4 *This,WINBOOL *fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *put_HashAlgID)(ICEnroll4 *This,LONG hashAlgID);
      HRESULT (WINAPI *get_HashAlgID)(ICEnroll4 *This,LONG *hashAlgID);
      HRESULT (WINAPI *put_LimitExchangeKeyToEncipherment)(ICEnroll4 *This,WINBOOL fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *get_LimitExchangeKeyToEncipherment)(ICEnroll4 *This,WINBOOL *fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *put_EnableSMIMECapabilities)(ICEnroll4 *This,WINBOOL fEnableSMIMECapabilities);
      HRESULT (WINAPI *get_EnableSMIMECapabilities)(ICEnroll4 *This,WINBOOL *fEnableSMIMECapabilities);
      HRESULT (WINAPI *put_PrivateKeyArchiveCertificate)(ICEnroll4 *This,BSTR bstrCert);
      HRESULT (WINAPI *get_PrivateKeyArchiveCertificate)(ICEnroll4 *This,BSTR *pbstrCert);
      HRESULT (WINAPI *put_ThumbPrint)(ICEnroll4 *This,BSTR bstrThumbPrint);
      HRESULT (WINAPI *get_ThumbPrint)(ICEnroll4 *This,BSTR *pbstrThumbPrint);
      HRESULT (WINAPI *binaryToString)(ICEnroll4 *This,LONG Flags,BSTR strBinary,BSTR *pstrEncoded);
      HRESULT (WINAPI *stringToBinary)(ICEnroll4 *This,LONG Flags,BSTR strEncoded,BSTR *pstrBinary);
      HRESULT (WINAPI *addExtensionToRequest)(ICEnroll4 *This,LONG Flags,BSTR strName,BSTR strValue);
      HRESULT (WINAPI *addAttributeToRequest)(ICEnroll4 *This,LONG Flags,BSTR strName,BSTR strValue);
      HRESULT (WINAPI *addNameValuePairToRequest)(ICEnroll4 *This,LONG Flags,BSTR strName,BSTR strValue);
      HRESULT (WINAPI *resetExtensions)(ICEnroll4 *This);
      HRESULT (WINAPI *resetAttributes)(ICEnroll4 *This);
      HRESULT (WINAPI *createRequest)(ICEnroll4 *This,LONG Flags,BSTR strDNName,BSTR Usage,BSTR *pstrRequest);
      HRESULT (WINAPI *createFileRequest)(ICEnroll4 *This,LONG Flags,BSTR strDNName,BSTR strUsage,BSTR strRequestFileName);
      HRESULT (WINAPI *acceptResponse)(ICEnroll4 *This,BSTR strResponse);
      HRESULT (WINAPI *acceptFileResponse)(ICEnroll4 *This,BSTR strResponseFileName);
      HRESULT (WINAPI *getCertFromResponse)(ICEnroll4 *This,BSTR strResponse,BSTR *pstrCert);
      HRESULT (WINAPI *getCertFromFileResponse)(ICEnroll4 *This,BSTR strResponseFileName,BSTR *pstrCert);
      HRESULT (WINAPI *createPFX)(ICEnroll4 *This,BSTR strPassword,BSTR *pstrPFX);
      HRESULT (WINAPI *createFilePFX)(ICEnroll4 *This,BSTR strPassword,BSTR strPFXFileName);
      HRESULT (WINAPI *setPendingRequestInfo)(ICEnroll4 *This,LONG lRequestID,BSTR strCADNS,BSTR strCAName,BSTR strFriendlyName);
      HRESULT (WINAPI *enumPendingRequest)(ICEnroll4 *This,LONG lIndex,LONG lDesiredProperty,VARIANT *pvarProperty);
      HRESULT (WINAPI *removePendingRequest)(ICEnroll4 *This,BSTR strThumbprint);
      HRESULT (WINAPI *GetKeyLenEx)(ICEnroll4 *This,LONG lSizeSpec,LONG lKeySpec,LONG *pdwKeySize);
      HRESULT (WINAPI *InstallPKCS7Ex)(ICEnroll4 *This,BSTR PKCS7,LONG *plCertInstalled);
      HRESULT (WINAPI *addCertTypeToRequestEx)(ICEnroll4 *This,LONG lType,BSTR bstrOIDOrName,LONG lMajorVersion,WINBOOL fMinorVersion,LONG lMinorVersion);
      HRESULT (WINAPI *getProviderType)(ICEnroll4 *This,BSTR strProvName,LONG *plProvType);
      HRESULT (WINAPI *put_SignerCertificate)(ICEnroll4 *This,BSTR bstrCert);
      HRESULT (WINAPI *put_ClientId)(ICEnroll4 *This,LONG lClientId);
      HRESULT (WINAPI *get_ClientId)(ICEnroll4 *This,LONG *plClientId);
      HRESULT (WINAPI *addBlobPropertyToCertificate)(ICEnroll4 *This,LONG lPropertyId,LONG lReserved,BSTR bstrProperty);
      HRESULT (WINAPI *resetBlobProperties)(ICEnroll4 *This);
      HRESULT (WINAPI *put_IncludeSubjectKeyID)(ICEnroll4 *This,WINBOOL fInclude);
      HRESULT (WINAPI *get_IncludeSubjectKeyID)(ICEnroll4 *This,WINBOOL *pfInclude);
    END_INTERFACE
  } ICEnroll4Vtbl;
  struct ICEnroll4 {
    CONST_VTBL struct ICEnroll4Vtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define ICEnroll4_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ICEnroll4_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ICEnroll4_Release(This) (This)->lpVtbl->Release(This)
#define ICEnroll4_GetTypeInfoCount(This,pctinfo) (This)->lpVtbl->GetTypeInfoCount(This,pctinfo)
#define ICEnroll4_GetTypeInfo(This,iTInfo,lcid,ppTInfo) (This)->lpVtbl->GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ICEnroll4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) (This)->lpVtbl->GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ICEnroll4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) (This)->lpVtbl->Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define ICEnroll4_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) (This)->lpVtbl->createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)
#define ICEnroll4_acceptFilePKCS7(This,wszPKCS7FileName) (This)->lpVtbl->acceptFilePKCS7(This,wszPKCS7FileName)
#define ICEnroll4_createPKCS10(This,DNName,Usage,pPKCS10) (This)->lpVtbl->createPKCS10(This,DNName,Usage,pPKCS10)
#define ICEnroll4_acceptPKCS7(This,PKCS7) (This)->lpVtbl->acceptPKCS7(This,PKCS7)
#define ICEnroll4_getCertFromPKCS7(This,wszPKCS7,pbstrCert) (This)->lpVtbl->getCertFromPKCS7(This,wszPKCS7,pbstrCert)
#define ICEnroll4_enumProviders(This,dwIndex,dwFlags,pbstrProvName) (This)->lpVtbl->enumProviders(This,dwIndex,dwFlags,pbstrProvName)
#define ICEnroll4_enumContainers(This,dwIndex,pbstr) (This)->lpVtbl->enumContainers(This,dwIndex,pbstr)
#define ICEnroll4_freeRequestInfo(This,PKCS7OrPKCS10) (This)->lpVtbl->freeRequestInfo(This,PKCS7OrPKCS10)
#define ICEnroll4_get_MyStoreName(This,pbstrName) (This)->lpVtbl->get_MyStoreName(This,pbstrName)
#define ICEnroll4_put_MyStoreName(This,bstrName) (This)->lpVtbl->put_MyStoreName(This,bstrName)
#define ICEnroll4_get_MyStoreType(This,pbstrType) (This)->lpVtbl->get_MyStoreType(This,pbstrType)
#define ICEnroll4_put_MyStoreType(This,bstrType) (This)->lpVtbl->put_MyStoreType(This,bstrType)
#define ICEnroll4_get_MyStoreFlags(This,pdwFlags) (This)->lpVtbl->get_MyStoreFlags(This,pdwFlags)
#define ICEnroll4_put_MyStoreFlags(This,dwFlags) (This)->lpVtbl->put_MyStoreFlags(This,dwFlags)
#define ICEnroll4_get_CAStoreName(This,pbstrName) (This)->lpVtbl->get_CAStoreName(This,pbstrName)
#define ICEnroll4_put_CAStoreName(This,bstrName) (This)->lpVtbl->put_CAStoreName(This,bstrName)
#define ICEnroll4_get_CAStoreType(This,pbstrType) (This)->lpVtbl->get_CAStoreType(This,pbstrType)
#define ICEnroll4_put_CAStoreType(This,bstrType) (This)->lpVtbl->put_CAStoreType(This,bstrType)
#define ICEnroll4_get_CAStoreFlags(This,pdwFlags) (This)->lpVtbl->get_CAStoreFlags(This,pdwFlags)
#define ICEnroll4_put_CAStoreFlags(This,dwFlags) (This)->lpVtbl->put_CAStoreFlags(This,dwFlags)
#define ICEnroll4_get_RootStoreName(This,pbstrName) (This)->lpVtbl->get_RootStoreName(This,pbstrName)
#define ICEnroll4_put_RootStoreName(This,bstrName) (This)->lpVtbl->put_RootStoreName(This,bstrName)
#define ICEnroll4_get_RootStoreType(This,pbstrType) (This)->lpVtbl->get_RootStoreType(This,pbstrType)
#define ICEnroll4_put_RootStoreType(This,bstrType) (This)->lpVtbl->put_RootStoreType(This,bstrType)
#define ICEnroll4_get_RootStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RootStoreFlags(This,pdwFlags)
#define ICEnroll4_put_RootStoreFlags(This,dwFlags) (This)->lpVtbl->put_RootStoreFlags(This,dwFlags)
#define ICEnroll4_get_RequestStoreName(This,pbstrName) (This)->lpVtbl->get_RequestStoreName(This,pbstrName)
#define ICEnroll4_put_RequestStoreName(This,bstrName) (This)->lpVtbl->put_RequestStoreName(This,bstrName)
#define ICEnroll4_get_RequestStoreType(This,pbstrType) (This)->lpVtbl->get_RequestStoreType(This,pbstrType)
#define ICEnroll4_put_RequestStoreType(This,bstrType) (This)->lpVtbl->put_RequestStoreType(This,bstrType)
#define ICEnroll4_get_RequestStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RequestStoreFlags(This,pdwFlags)
#define ICEnroll4_put_RequestStoreFlags(This,dwFlags) (This)->lpVtbl->put_RequestStoreFlags(This,dwFlags)
#define ICEnroll4_get_ContainerName(This,pbstrContainer) (This)->lpVtbl->get_ContainerName(This,pbstrContainer)
#define ICEnroll4_put_ContainerName(This,bstrContainer) (This)->lpVtbl->put_ContainerName(This,bstrContainer)
#define ICEnroll4_get_ProviderName(This,pbstrProvider) (This)->lpVtbl->get_ProviderName(This,pbstrProvider)
#define ICEnroll4_put_ProviderName(This,bstrProvider) (This)->lpVtbl->put_ProviderName(This,bstrProvider)
#define ICEnroll4_get_ProviderType(This,pdwType) (This)->lpVtbl->get_ProviderType(This,pdwType)
#define ICEnroll4_put_ProviderType(This,dwType) (This)->lpVtbl->put_ProviderType(This,dwType)
#define ICEnroll4_get_KeySpec(This,pdw) (This)->lpVtbl->get_KeySpec(This,pdw)
#define ICEnroll4_put_KeySpec(This,dw) (This)->lpVtbl->put_KeySpec(This,dw)
#define ICEnroll4_get_ProviderFlags(This,pdwFlags) (This)->lpVtbl->get_ProviderFlags(This,pdwFlags)
#define ICEnroll4_put_ProviderFlags(This,dwFlags) (This)->lpVtbl->put_ProviderFlags(This,dwFlags)
#define ICEnroll4_get_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->get_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll4_put_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->put_UseExistingKeySet(This,fUseExistingKeys)
#define ICEnroll4_get_GenKeyFlags(This,pdwFlags) (This)->lpVtbl->get_GenKeyFlags(This,pdwFlags)
#define ICEnroll4_put_GenKeyFlags(This,dwFlags) (This)->lpVtbl->put_GenKeyFlags(This,dwFlags)
#define ICEnroll4_get_DeleteRequestCert(This,fDelete) (This)->lpVtbl->get_DeleteRequestCert(This,fDelete)
#define ICEnroll4_put_DeleteRequestCert(This,fDelete) (This)->lpVtbl->put_DeleteRequestCert(This,fDelete)
#define ICEnroll4_get_WriteCertToCSP(This,fBool) (This)->lpVtbl->get_WriteCertToCSP(This,fBool)
#define ICEnroll4_put_WriteCertToCSP(This,fBool) (This)->lpVtbl->put_WriteCertToCSP(This,fBool)
#define ICEnroll4_get_SPCFileName(This,pbstr) (This)->lpVtbl->get_SPCFileName(This,pbstr)
#define ICEnroll4_put_SPCFileName(This,bstr) (This)->lpVtbl->put_SPCFileName(This,bstr)
#define ICEnroll4_get_PVKFileName(This,pbstr) (This)->lpVtbl->get_PVKFileName(This,pbstr)
#define ICEnroll4_put_PVKFileName(This,bstr) (This)->lpVtbl->put_PVKFileName(This,bstr)
#define ICEnroll4_get_HashAlgorithm(This,pbstr) (This)->lpVtbl->get_HashAlgorithm(This,pbstr)
#define ICEnroll4_put_HashAlgorithm(This,bstr) (This)->lpVtbl->put_HashAlgorithm(This,bstr)
#define ICEnroll4_addCertTypeToRequest(This,CertType) (This)->lpVtbl->addCertTypeToRequest(This,CertType)
#define ICEnroll4_addNameValuePairToSignature(This,Name,Value) (This)->lpVtbl->addNameValuePairToSignature(This,Name,Value)
#define ICEnroll4_get_WriteCertToUserDS(This,fBool) (This)->lpVtbl->get_WriteCertToUserDS(This,fBool)
#define ICEnroll4_put_WriteCertToUserDS(This,fBool) (This)->lpVtbl->put_WriteCertToUserDS(This,fBool)
#define ICEnroll4_get_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->get_EnableT61DNEncoding(This,fBool)
#define ICEnroll4_put_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->put_EnableT61DNEncoding(This,fBool)
#define ICEnroll4_InstallPKCS7(This,PKCS7) (This)->lpVtbl->InstallPKCS7(This,PKCS7)
#define ICEnroll4_Reset(This) (This)->lpVtbl->Reset(This)
#define ICEnroll4_GetSupportedKeySpec(This,pdwKeySpec) (This)->lpVtbl->GetSupportedKeySpec(This,pdwKeySpec)
#define ICEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize) (This)->lpVtbl->GetKeyLen(This,fMin,fExchange,pdwKeySize)
#define ICEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID) (This)->lpVtbl->EnumAlgs(This,dwIndex,algClass,pdwAlgID)
#define ICEnroll4_GetAlgName(This,algID,pbstr) (This)->lpVtbl->GetAlgName(This,algID,pbstr)
#define ICEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define ICEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define ICEnroll4_put_HashAlgID(This,hashAlgID) (This)->lpVtbl->put_HashAlgID(This,hashAlgID)
#define ICEnroll4_get_HashAlgID(This,hashAlgID) (This)->lpVtbl->get_HashAlgID(This,hashAlgID)
#define ICEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define ICEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define ICEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#define ICEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#define ICEnroll4_put_PrivateKeyArchiveCertificate(This,bstrCert) (This)->lpVtbl->put_PrivateKeyArchiveCertificate(This,bstrCert)
#define ICEnroll4_get_PrivateKeyArchiveCertificate(This,pbstrCert) (This)->lpVtbl->get_PrivateKeyArchiveCertificate(This,pbstrCert)
#define ICEnroll4_put_ThumbPrint(This,bstrThumbPrint) (This)->lpVtbl->put_ThumbPrint(This,bstrThumbPrint)
#define ICEnroll4_get_ThumbPrint(This,pbstrThumbPrint) (This)->lpVtbl->get_ThumbPrint(This,pbstrThumbPrint)
#define ICEnroll4_binaryToString(This,Flags,strBinary,pstrEncoded) (This)->lpVtbl->binaryToString(This,Flags,strBinary,pstrEncoded)
#define ICEnroll4_stringToBinary(This,Flags,strEncoded,pstrBinary) (This)->lpVtbl->stringToBinary(This,Flags,strEncoded,pstrBinary)
#define ICEnroll4_addExtensionToRequest(This,Flags,strName,strValue) (This)->lpVtbl->addExtensionToRequest(This,Flags,strName,strValue)
#define ICEnroll4_addAttributeToRequest(This,Flags,strName,strValue) (This)->lpVtbl->addAttributeToRequest(This,Flags,strName,strValue)
#define ICEnroll4_addNameValuePairToRequest(This,Flags,strName,strValue) (This)->lpVtbl->addNameValuePairToRequest(This,Flags,strName,strValue)
#define ICEnroll4_resetExtensions(This) (This)->lpVtbl->resetExtensions(This)
#define ICEnroll4_resetAttributes(This) (This)->lpVtbl->resetAttributes(This)
#define ICEnroll4_createRequest(This,Flags,strDNName,Usage,pstrRequest) (This)->lpVtbl->createRequest(This,Flags,strDNName,Usage,pstrRequest)
#define ICEnroll4_createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName) (This)->lpVtbl->createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName)
#define ICEnroll4_acceptResponse(This,strResponse) (This)->lpVtbl->acceptResponse(This,strResponse)
#define ICEnroll4_acceptFileResponse(This,strResponseFileName) (This)->lpVtbl->acceptFileResponse(This,strResponseFileName)
#define ICEnroll4_getCertFromResponse(This,strResponse,pstrCert) (This)->lpVtbl->getCertFromResponse(This,strResponse,pstrCert)
#define ICEnroll4_getCertFromFileResponse(This,strResponseFileName,pstrCert) (This)->lpVtbl->getCertFromFileResponse(This,strResponseFileName,pstrCert)
#define ICEnroll4_createPFX(This,strPassword,pstrPFX) (This)->lpVtbl->createPFX(This,strPassword,pstrPFX)
#define ICEnroll4_createFilePFX(This,strPassword,strPFXFileName) (This)->lpVtbl->createFilePFX(This,strPassword,strPFXFileName)
#define ICEnroll4_setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName) (This)->lpVtbl->setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName)
#define ICEnroll4_enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty) (This)->lpVtbl->enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty)
#define ICEnroll4_removePendingRequest(This,strThumbprint) (This)->lpVtbl->removePendingRequest(This,strThumbprint)
#define ICEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize) (This)->lpVtbl->GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)
#define ICEnroll4_InstallPKCS7Ex(This,PKCS7,plCertInstalled) (This)->lpVtbl->InstallPKCS7Ex(This,PKCS7,plCertInstalled)
#define ICEnroll4_addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion) (This)->lpVtbl->addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)
#define ICEnroll4_getProviderType(This,strProvName,plProvType) (This)->lpVtbl->getProviderType(This,strProvName,plProvType)
#define ICEnroll4_put_SignerCertificate(This,bstrCert) (This)->lpVtbl->put_SignerCertificate(This,bstrCert)
#define ICEnroll4_put_ClientId(This,lClientId) (This)->lpVtbl->put_ClientId(This,lClientId)
#define ICEnroll4_get_ClientId(This,plClientId) (This)->lpVtbl->get_ClientId(This,plClientId)
#define ICEnroll4_addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty) (This)->lpVtbl->addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty)
#define ICEnroll4_resetBlobProperties(This) (This)->lpVtbl->resetBlobProperties(This)
#define ICEnroll4_put_IncludeSubjectKeyID(This,fInclude) (This)->lpVtbl->put_IncludeSubjectKeyID(This,fInclude)
#define ICEnroll4_get_IncludeSubjectKeyID(This,pfInclude) (This)->lpVtbl->get_IncludeSubjectKeyID(This,pfInclude)
#endif
#endif
  HRESULT WINAPI ICEnroll4_put_PrivateKeyArchiveCertificate_Proxy(ICEnroll4 *This,BSTR bstrCert);
  void __RPC_STUB ICEnroll4_put_PrivateKeyArchiveCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_get_PrivateKeyArchiveCertificate_Proxy(ICEnroll4 *This,BSTR *pbstrCert);
  void __RPC_STUB ICEnroll4_get_PrivateKeyArchiveCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_put_ThumbPrint_Proxy(ICEnroll4 *This,BSTR bstrThumbPrint);
  void __RPC_STUB ICEnroll4_put_ThumbPrint_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_get_ThumbPrint_Proxy(ICEnroll4 *This,BSTR *pbstrThumbPrint);
  void __RPC_STUB ICEnroll4_get_ThumbPrint_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_binaryToString_Proxy(ICEnroll4 *This,LONG Flags,BSTR strBinary,BSTR *pstrEncoded);
  void __RPC_STUB ICEnroll4_binaryToString_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_stringToBinary_Proxy(ICEnroll4 *This,LONG Flags,BSTR strEncoded,BSTR *pstrBinary);
  void __RPC_STUB ICEnroll4_stringToBinary_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_addExtensionToRequest_Proxy(ICEnroll4 *This,LONG Flags,BSTR strName,BSTR strValue);
  void __RPC_STUB ICEnroll4_addExtensionToRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_addAttributeToRequest_Proxy(ICEnroll4 *This,LONG Flags,BSTR strName,BSTR strValue);
  void __RPC_STUB ICEnroll4_addAttributeToRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_addNameValuePairToRequest_Proxy(ICEnroll4 *This,LONG Flags,BSTR strName,BSTR strValue);
  void __RPC_STUB ICEnroll4_addNameValuePairToRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_resetExtensions_Proxy(ICEnroll4 *This);
  void __RPC_STUB ICEnroll4_resetExtensions_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_resetAttributes_Proxy(ICEnroll4 *This);
  void __RPC_STUB ICEnroll4_resetAttributes_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_createRequest_Proxy(ICEnroll4 *This,LONG Flags,BSTR strDNName,BSTR Usage,BSTR *pstrRequest);
  void __RPC_STUB ICEnroll4_createRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_createFileRequest_Proxy(ICEnroll4 *This,LONG Flags,BSTR strDNName,BSTR strUsage,BSTR strRequestFileName);
  void __RPC_STUB ICEnroll4_createFileRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_acceptResponse_Proxy(ICEnroll4 *This,BSTR strResponse);
  void __RPC_STUB ICEnroll4_acceptResponse_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_acceptFileResponse_Proxy(ICEnroll4 *This,BSTR strResponseFileName);
  void __RPC_STUB ICEnroll4_acceptFileResponse_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_getCertFromResponse_Proxy(ICEnroll4 *This,BSTR strResponse,BSTR *pstrCert);
  void __RPC_STUB ICEnroll4_getCertFromResponse_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_getCertFromFileResponse_Proxy(ICEnroll4 *This,BSTR strResponseFileName,BSTR *pstrCert);
  void __RPC_STUB ICEnroll4_getCertFromFileResponse_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_createPFX_Proxy(ICEnroll4 *This,BSTR strPassword,BSTR *pstrPFX);
  void __RPC_STUB ICEnroll4_createPFX_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_createFilePFX_Proxy(ICEnroll4 *This,BSTR strPassword,BSTR strPFXFileName);
  void __RPC_STUB ICEnroll4_createFilePFX_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_setPendingRequestInfo_Proxy(ICEnroll4 *This,LONG lRequestID,BSTR strCADNS,BSTR strCAName,BSTR strFriendlyName);
  void __RPC_STUB ICEnroll4_setPendingRequestInfo_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_enumPendingRequest_Proxy(ICEnroll4 *This,LONG lIndex,LONG lDesiredProperty,VARIANT *pvarProperty);
  void __RPC_STUB ICEnroll4_enumPendingRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_removePendingRequest_Proxy(ICEnroll4 *This,BSTR strThumbprint);
  void __RPC_STUB ICEnroll4_removePendingRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_GetKeyLenEx_Proxy(ICEnroll4 *This,LONG lSizeSpec,LONG lKeySpec,LONG *pdwKeySize);
  void __RPC_STUB ICEnroll4_GetKeyLenEx_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_InstallPKCS7Ex_Proxy(ICEnroll4 *This,BSTR PKCS7,LONG *plCertInstalled);
  void __RPC_STUB ICEnroll4_InstallPKCS7Ex_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_addCertTypeToRequestEx_Proxy(ICEnroll4 *This,LONG lType,BSTR bstrOIDOrName,LONG lMajorVersion,WINBOOL fMinorVersion,LONG lMinorVersion);
  void __RPC_STUB ICEnroll4_addCertTypeToRequestEx_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_getProviderType_Proxy(ICEnroll4 *This,BSTR strProvName,LONG *plProvType);
  void __RPC_STUB ICEnroll4_getProviderType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_put_SignerCertificate_Proxy(ICEnroll4 *This,BSTR bstrCert);
  void __RPC_STUB ICEnroll4_put_SignerCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_put_ClientId_Proxy(ICEnroll4 *This,LONG lClientId);
  void __RPC_STUB ICEnroll4_put_ClientId_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_get_ClientId_Proxy(ICEnroll4 *This,LONG *plClientId);
  void __RPC_STUB ICEnroll4_get_ClientId_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_addBlobPropertyToCertificate_Proxy(ICEnroll4 *This,LONG lPropertyId,LONG lReserved,BSTR bstrProperty);
  void __RPC_STUB ICEnroll4_addBlobPropertyToCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_resetBlobProperties_Proxy(ICEnroll4 *This);
  void __RPC_STUB ICEnroll4_resetBlobProperties_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_put_IncludeSubjectKeyID_Proxy(ICEnroll4 *This,WINBOOL fInclude);
  void __RPC_STUB ICEnroll4_put_IncludeSubjectKeyID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ICEnroll4_get_IncludeSubjectKeyID_Proxy(ICEnroll4 *This,WINBOOL *pfInclude);
  void __RPC_STUB ICEnroll4_get_IncludeSubjectKeyID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IEnroll_INTERFACE_DEFINED__
#define __IEnroll_INTERFACE_DEFINED__
  extern const IID IID_IEnroll;
#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __cplusplus
}
#endif
  struct IEnroll : public IUnknown {
  public:
    virtual HRESULT WINAPI createFilePKCS10WStr(LPCWSTR DNName,LPCWSTR Usage,LPCWSTR wszPKCS10FileName) = 0;
    virtual HRESULT WINAPI acceptFilePKCS7WStr(LPCWSTR wszPKCS7FileName) = 0;
    virtual HRESULT WINAPI createPKCS10WStr(LPCWSTR DNName,LPCWSTR Usage,PCRYPT_DATA_BLOB pPkcs10Blob) = 0;
    virtual HRESULT WINAPI acceptPKCS7Blob(PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
    virtual PCCERT_CONTEXT WINAPI getCertContextFromPKCS7(PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
    virtual HCERTSTORE WINAPI getMyStore(void) = 0;
    virtual HCERTSTORE WINAPI getCAStore(void) = 0;
    virtual HCERTSTORE WINAPI getROOTHStore(void) = 0;
    virtual HRESULT WINAPI enumProvidersWStr(LONG dwIndex,LONG dwFlags,LPWSTR *pbstrProvName) = 0;
    virtual HRESULT WINAPI enumContainersWStr(LONG dwIndex,LPWSTR *pbstr) = 0;
    virtual HRESULT WINAPI freeRequestInfoBlob(CRYPT_DATA_BLOB pkcs7OrPkcs10) = 0;
    virtual HRESULT WINAPI get_MyStoreNameWStr(LPWSTR *szwName) = 0;
    virtual HRESULT WINAPI put_MyStoreNameWStr(LPWSTR szwName) = 0;
    virtual HRESULT WINAPI get_MyStoreTypeWStr(LPWSTR *szwType) = 0;
    virtual HRESULT WINAPI put_MyStoreTypeWStr(LPWSTR szwType) = 0;
    virtual HRESULT WINAPI get_MyStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_MyStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_CAStoreNameWStr(LPWSTR *szwName) = 0;
    virtual HRESULT WINAPI put_CAStoreNameWStr(LPWSTR szwName) = 0;
    virtual HRESULT WINAPI get_CAStoreTypeWStr(LPWSTR *szwType) = 0;
    virtual HRESULT WINAPI put_CAStoreTypeWStr(LPWSTR szwType) = 0;
    virtual HRESULT WINAPI get_CAStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_CAStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_RootStoreNameWStr(LPWSTR *szwName) = 0;
    virtual HRESULT WINAPI put_RootStoreNameWStr(LPWSTR szwName) = 0;
    virtual HRESULT WINAPI get_RootStoreTypeWStr(LPWSTR *szwType) = 0;
    virtual HRESULT WINAPI put_RootStoreTypeWStr(LPWSTR szwType) = 0;
    virtual HRESULT WINAPI get_RootStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_RootStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_RequestStoreNameWStr(LPWSTR *szwName) = 0;
    virtual HRESULT WINAPI put_RequestStoreNameWStr(LPWSTR szwName) = 0;
    virtual HRESULT WINAPI get_RequestStoreTypeWStr(LPWSTR *szwType) = 0;
    virtual HRESULT WINAPI put_RequestStoreTypeWStr(LPWSTR szwType) = 0;
    virtual HRESULT WINAPI get_RequestStoreFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_RequestStoreFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_ContainerNameWStr(LPWSTR *szwContainer) = 0;
    virtual HRESULT WINAPI put_ContainerNameWStr(LPWSTR szwContainer) = 0;
    virtual HRESULT WINAPI get_ProviderNameWStr(LPWSTR *szwProvider) = 0;
    virtual HRESULT WINAPI put_ProviderNameWStr(LPWSTR szwProvider) = 0;
    virtual HRESULT WINAPI get_ProviderType(LONG *pdwType) = 0;
    virtual HRESULT WINAPI put_ProviderType(LONG dwType) = 0;
    virtual HRESULT WINAPI get_KeySpec(LONG *pdw) = 0;
    virtual HRESULT WINAPI put_KeySpec(LONG dw) = 0;
    virtual HRESULT WINAPI get_ProviderFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_ProviderFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_UseExistingKeySet(WINBOOL *fUseExistingKeys) = 0;
    virtual HRESULT WINAPI put_UseExistingKeySet(WINBOOL fUseExistingKeys) = 0;
    virtual HRESULT WINAPI get_GenKeyFlags(LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI put_GenKeyFlags(LONG dwFlags) = 0;
    virtual HRESULT WINAPI get_DeleteRequestCert(WINBOOL *fDelete) = 0;
    virtual HRESULT WINAPI put_DeleteRequestCert(WINBOOL fDelete) = 0;
    virtual HRESULT WINAPI get_WriteCertToUserDS(WINBOOL *fBool) = 0;
    virtual HRESULT WINAPI put_WriteCertToUserDS(WINBOOL fBool) = 0;
    virtual HRESULT WINAPI get_EnableT61DNEncoding(WINBOOL *fBool) = 0;
    virtual HRESULT WINAPI put_EnableT61DNEncoding(WINBOOL fBool) = 0;
    virtual HRESULT WINAPI get_WriteCertToCSP(WINBOOL *fBool) = 0;
    virtual HRESULT WINAPI put_WriteCertToCSP(WINBOOL fBool) = 0;
    virtual HRESULT WINAPI get_SPCFileNameWStr(LPWSTR *szw) = 0;
    virtual HRESULT WINAPI put_SPCFileNameWStr(LPWSTR szw) = 0;
    virtual HRESULT WINAPI get_PVKFileNameWStr(LPWSTR *szw) = 0;
    virtual HRESULT WINAPI put_PVKFileNameWStr(LPWSTR szw) = 0;
    virtual HRESULT WINAPI get_HashAlgorithmWStr(LPWSTR *szw) = 0;
    virtual HRESULT WINAPI put_HashAlgorithmWStr(LPWSTR szw) = 0;
    virtual HRESULT WINAPI get_RenewalCertificate(PCCERT_CONTEXT *ppCertContext) = 0;
    virtual HRESULT WINAPI put_RenewalCertificate(PCCERT_CONTEXT pCertContext) = 0;
    virtual HRESULT WINAPI AddCertTypeToRequestWStr(LPWSTR szw) = 0;
    virtual HRESULT WINAPI AddNameValuePairToSignatureWStr(LPWSTR Name,LPWSTR Value) = 0;
    virtual HRESULT WINAPI AddExtensionsToRequest(PCERT_EXTENSIONS pCertExtensions) = 0;
    virtual HRESULT WINAPI AddAuthenticatedAttributesToPKCS7Request(PCRYPT_ATTRIBUTES pAttributes) = 0;
    virtual HRESULT WINAPI CreatePKCS7RequestFromRequest(PCRYPT_DATA_BLOB pRequest,PCCERT_CONTEXT pSigningCertContext,PCRYPT_DATA_BLOB pPkcs7Blob) = 0;
  };
#ifdef __cplusplus
  extern "C" {
#endif
#else
  typedef struct IEnrollVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IEnroll *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IEnroll *This);
      ULONG (WINAPI *Release)(IEnroll *This);
      HRESULT (WINAPI *createFilePKCS10WStr)(IEnroll *This,LPCWSTR DNName,LPCWSTR Usage,LPCWSTR wszPKCS10FileName);
      HRESULT (WINAPI *acceptFilePKCS7WStr)(IEnroll *This,LPCWSTR wszPKCS7FileName);
      HRESULT (WINAPI *createPKCS10WStr)(IEnroll *This,LPCWSTR DNName,LPCWSTR Usage,PCRYPT_DATA_BLOB pPkcs10Blob);
      HRESULT (WINAPI *acceptPKCS7Blob)(IEnroll *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      PCCERT_CONTEXT (WINAPI *getCertContextFromPKCS7)(IEnroll *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      HCERTSTORE (WINAPI *getMyStore)(IEnroll *This);
      HCERTSTORE (WINAPI *getCAStore)(IEnroll *This);
      HCERTSTORE (WINAPI *getROOTHStore)(IEnroll *This);
      HRESULT (WINAPI *enumProvidersWStr)(IEnroll *This,LONG dwIndex,LONG dwFlags,LPWSTR *pbstrProvName);
      HRESULT (WINAPI *enumContainersWStr)(IEnroll *This,LONG dwIndex,LPWSTR *pbstr);
      HRESULT (WINAPI *freeRequestInfoBlob)(IEnroll *This,CRYPT_DATA_BLOB pkcs7OrPkcs10);
      HRESULT (WINAPI *get_MyStoreNameWStr)(IEnroll *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_MyStoreNameWStr)(IEnroll *This,LPWSTR szwName);
      HRESULT (WINAPI *get_MyStoreTypeWStr)(IEnroll *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_MyStoreTypeWStr)(IEnroll *This,LPWSTR szwType);
      HRESULT (WINAPI *get_MyStoreFlags)(IEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_MyStoreFlags)(IEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_CAStoreNameWStr)(IEnroll *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_CAStoreNameWStr)(IEnroll *This,LPWSTR szwName);
      HRESULT (WINAPI *get_CAStoreTypeWStr)(IEnroll *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_CAStoreTypeWStr)(IEnroll *This,LPWSTR szwType);
      HRESULT (WINAPI *get_CAStoreFlags)(IEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_CAStoreFlags)(IEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_RootStoreNameWStr)(IEnroll *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_RootStoreNameWStr)(IEnroll *This,LPWSTR szwName);
      HRESULT (WINAPI *get_RootStoreTypeWStr)(IEnroll *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_RootStoreTypeWStr)(IEnroll *This,LPWSTR szwType);
      HRESULT (WINAPI *get_RootStoreFlags)(IEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RootStoreFlags)(IEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_RequestStoreNameWStr)(IEnroll *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_RequestStoreNameWStr)(IEnroll *This,LPWSTR szwName);
      HRESULT (WINAPI *get_RequestStoreTypeWStr)(IEnroll *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_RequestStoreTypeWStr)(IEnroll *This,LPWSTR szwType);
      HRESULT (WINAPI *get_RequestStoreFlags)(IEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RequestStoreFlags)(IEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_ContainerNameWStr)(IEnroll *This,LPWSTR *szwContainer);
      HRESULT (WINAPI *put_ContainerNameWStr)(IEnroll *This,LPWSTR szwContainer);
      HRESULT (WINAPI *get_ProviderNameWStr)(IEnroll *This,LPWSTR *szwProvider);
      HRESULT (WINAPI *put_ProviderNameWStr)(IEnroll *This,LPWSTR szwProvider);
      HRESULT (WINAPI *get_ProviderType)(IEnroll *This,LONG *pdwType);
      HRESULT (WINAPI *put_ProviderType)(IEnroll *This,LONG dwType);
      HRESULT (WINAPI *get_KeySpec)(IEnroll *This,LONG *pdw);
      HRESULT (WINAPI *put_KeySpec)(IEnroll *This,LONG dw);
      HRESULT (WINAPI *get_ProviderFlags)(IEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_ProviderFlags)(IEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_UseExistingKeySet)(IEnroll *This,WINBOOL *fUseExistingKeys);
      HRESULT (WINAPI *put_UseExistingKeySet)(IEnroll *This,WINBOOL fUseExistingKeys);
      HRESULT (WINAPI *get_GenKeyFlags)(IEnroll *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_GenKeyFlags)(IEnroll *This,LONG dwFlags);
      HRESULT (WINAPI *get_DeleteRequestCert)(IEnroll *This,WINBOOL *fDelete);
      HRESULT (WINAPI *put_DeleteRequestCert)(IEnroll *This,WINBOOL fDelete);
      HRESULT (WINAPI *get_WriteCertToUserDS)(IEnroll *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToUserDS)(IEnroll *This,WINBOOL fBool);
      HRESULT (WINAPI *get_EnableT61DNEncoding)(IEnroll *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_EnableT61DNEncoding)(IEnroll *This,WINBOOL fBool);
      HRESULT (WINAPI *get_WriteCertToCSP)(IEnroll *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToCSP)(IEnroll *This,WINBOOL fBool);
      HRESULT (WINAPI *get_SPCFileNameWStr)(IEnroll *This,LPWSTR *szw);
      HRESULT (WINAPI *put_SPCFileNameWStr)(IEnroll *This,LPWSTR szw);
      HRESULT (WINAPI *get_PVKFileNameWStr)(IEnroll *This,LPWSTR *szw);
      HRESULT (WINAPI *put_PVKFileNameWStr)(IEnroll *This,LPWSTR szw);
      HRESULT (WINAPI *get_HashAlgorithmWStr)(IEnroll *This,LPWSTR *szw);
      HRESULT (WINAPI *put_HashAlgorithmWStr)(IEnroll *This,LPWSTR szw);
      HRESULT (WINAPI *get_RenewalCertificate)(IEnroll *This,PCCERT_CONTEXT *ppCertContext);
      HRESULT (WINAPI *put_RenewalCertificate)(IEnroll *This,PCCERT_CONTEXT pCertContext);
      HRESULT (WINAPI *AddCertTypeToRequestWStr)(IEnroll *This,LPWSTR szw);
      HRESULT (WINAPI *AddNameValuePairToSignatureWStr)(IEnroll *This,LPWSTR Name,LPWSTR Value);
      HRESULT (WINAPI *AddExtensionsToRequest)(IEnroll *This,PCERT_EXTENSIONS pCertExtensions);
      HRESULT (WINAPI *AddAuthenticatedAttributesToPKCS7Request)(IEnroll *This,PCRYPT_ATTRIBUTES pAttributes);
      HRESULT (WINAPI *CreatePKCS7RequestFromRequest)(IEnroll *This,PCRYPT_DATA_BLOB pRequest,PCCERT_CONTEXT pSigningCertContext,PCRYPT_DATA_BLOB pPkcs7Blob);
    END_INTERFACE
  } IEnrollVtbl;
  struct IEnroll {
    CONST_VTBL struct IEnrollVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IEnroll_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IEnroll_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IEnroll_Release(This) (This)->lpVtbl->Release(This)
#define IEnroll_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) (This)->lpVtbl->createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)
#define IEnroll_acceptFilePKCS7WStr(This,wszPKCS7FileName) (This)->lpVtbl->acceptFilePKCS7WStr(This,wszPKCS7FileName)
#define IEnroll_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) (This)->lpVtbl->createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)
#define IEnroll_acceptPKCS7Blob(This,pBlobPKCS7) (This)->lpVtbl->acceptPKCS7Blob(This,pBlobPKCS7)
#define IEnroll_getCertContextFromPKCS7(This,pBlobPKCS7) (This)->lpVtbl->getCertContextFromPKCS7(This,pBlobPKCS7)
#define IEnroll_getMyStore(This) (This)->lpVtbl->getMyStore(This)
#define IEnroll_getCAStore(This) (This)->lpVtbl->getCAStore(This)
#define IEnroll_getROOTHStore(This) (This)->lpVtbl->getROOTHStore(This)
#define IEnroll_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) (This)->lpVtbl->enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)
#define IEnroll_enumContainersWStr(This,dwIndex,pbstr) (This)->lpVtbl->enumContainersWStr(This,dwIndex,pbstr)
#define IEnroll_freeRequestInfoBlob(This,pkcs7OrPkcs10) (This)->lpVtbl->freeRequestInfoBlob(This,pkcs7OrPkcs10)
#define IEnroll_get_MyStoreNameWStr(This,szwName) (This)->lpVtbl->get_MyStoreNameWStr(This,szwName)
#define IEnroll_put_MyStoreNameWStr(This,szwName) (This)->lpVtbl->put_MyStoreNameWStr(This,szwName)
#define IEnroll_get_MyStoreTypeWStr(This,szwType) (This)->lpVtbl->get_MyStoreTypeWStr(This,szwType)
#define IEnroll_put_MyStoreTypeWStr(This,szwType) (This)->lpVtbl->put_MyStoreTypeWStr(This,szwType)
#define IEnroll_get_MyStoreFlags(This,pdwFlags) (This)->lpVtbl->get_MyStoreFlags(This,pdwFlags)
#define IEnroll_put_MyStoreFlags(This,dwFlags) (This)->lpVtbl->put_MyStoreFlags(This,dwFlags)
#define IEnroll_get_CAStoreNameWStr(This,szwName) (This)->lpVtbl->get_CAStoreNameWStr(This,szwName)
#define IEnroll_put_CAStoreNameWStr(This,szwName) (This)->lpVtbl->put_CAStoreNameWStr(This,szwName)
#define IEnroll_get_CAStoreTypeWStr(This,szwType) (This)->lpVtbl->get_CAStoreTypeWStr(This,szwType)
#define IEnroll_put_CAStoreTypeWStr(This,szwType) (This)->lpVtbl->put_CAStoreTypeWStr(This,szwType)
#define IEnroll_get_CAStoreFlags(This,pdwFlags) (This)->lpVtbl->get_CAStoreFlags(This,pdwFlags)
#define IEnroll_put_CAStoreFlags(This,dwFlags) (This)->lpVtbl->put_CAStoreFlags(This,dwFlags)
#define IEnroll_get_RootStoreNameWStr(This,szwName) (This)->lpVtbl->get_RootStoreNameWStr(This,szwName)
#define IEnroll_put_RootStoreNameWStr(This,szwName) (This)->lpVtbl->put_RootStoreNameWStr(This,szwName)
#define IEnroll_get_RootStoreTypeWStr(This,szwType) (This)->lpVtbl->get_RootStoreTypeWStr(This,szwType)
#define IEnroll_put_RootStoreTypeWStr(This,szwType) (This)->lpVtbl->put_RootStoreTypeWStr(This,szwType)
#define IEnroll_get_RootStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RootStoreFlags(This,pdwFlags)
#define IEnroll_put_RootStoreFlags(This,dwFlags) (This)->lpVtbl->put_RootStoreFlags(This,dwFlags)
#define IEnroll_get_RequestStoreNameWStr(This,szwName) (This)->lpVtbl->get_RequestStoreNameWStr(This,szwName)
#define IEnroll_put_RequestStoreNameWStr(This,szwName) (This)->lpVtbl->put_RequestStoreNameWStr(This,szwName)
#define IEnroll_get_RequestStoreTypeWStr(This,szwType) (This)->lpVtbl->get_RequestStoreTypeWStr(This,szwType)
#define IEnroll_put_RequestStoreTypeWStr(This,szwType) (This)->lpVtbl->put_RequestStoreTypeWStr(This,szwType)
#define IEnroll_get_RequestStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RequestStoreFlags(This,pdwFlags)
#define IEnroll_put_RequestStoreFlags(This,dwFlags) (This)->lpVtbl->put_RequestStoreFlags(This,dwFlags)
#define IEnroll_get_ContainerNameWStr(This,szwContainer) (This)->lpVtbl->get_ContainerNameWStr(This,szwContainer)
#define IEnroll_put_ContainerNameWStr(This,szwContainer) (This)->lpVtbl->put_ContainerNameWStr(This,szwContainer)
#define IEnroll_get_ProviderNameWStr(This,szwProvider) (This)->lpVtbl->get_ProviderNameWStr(This,szwProvider)
#define IEnroll_put_ProviderNameWStr(This,szwProvider) (This)->lpVtbl->put_ProviderNameWStr(This,szwProvider)
#define IEnroll_get_ProviderType(This,pdwType) (This)->lpVtbl->get_ProviderType(This,pdwType)
#define IEnroll_put_ProviderType(This,dwType) (This)->lpVtbl->put_ProviderType(This,dwType)
#define IEnroll_get_KeySpec(This,pdw) (This)->lpVtbl->get_KeySpec(This,pdw)
#define IEnroll_put_KeySpec(This,dw) (This)->lpVtbl->put_KeySpec(This,dw)
#define IEnroll_get_ProviderFlags(This,pdwFlags) (This)->lpVtbl->get_ProviderFlags(This,pdwFlags)
#define IEnroll_put_ProviderFlags(This,dwFlags) (This)->lpVtbl->put_ProviderFlags(This,dwFlags)
#define IEnroll_get_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->get_UseExistingKeySet(This,fUseExistingKeys)
#define IEnroll_put_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->put_UseExistingKeySet(This,fUseExistingKeys)
#define IEnroll_get_GenKeyFlags(This,pdwFlags) (This)->lpVtbl->get_GenKeyFlags(This,pdwFlags)
#define IEnroll_put_GenKeyFlags(This,dwFlags) (This)->lpVtbl->put_GenKeyFlags(This,dwFlags)
#define IEnroll_get_DeleteRequestCert(This,fDelete) (This)->lpVtbl->get_DeleteRequestCert(This,fDelete)
#define IEnroll_put_DeleteRequestCert(This,fDelete) (This)->lpVtbl->put_DeleteRequestCert(This,fDelete)
#define IEnroll_get_WriteCertToUserDS(This,fBool) (This)->lpVtbl->get_WriteCertToUserDS(This,fBool)
#define IEnroll_put_WriteCertToUserDS(This,fBool) (This)->lpVtbl->put_WriteCertToUserDS(This,fBool)
#define IEnroll_get_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->get_EnableT61DNEncoding(This,fBool)
#define IEnroll_put_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->put_EnableT61DNEncoding(This,fBool)
#define IEnroll_get_WriteCertToCSP(This,fBool) (This)->lpVtbl->get_WriteCertToCSP(This,fBool)
#define IEnroll_put_WriteCertToCSP(This,fBool) (This)->lpVtbl->put_WriteCertToCSP(This,fBool)
#define IEnroll_get_SPCFileNameWStr(This,szw) (This)->lpVtbl->get_SPCFileNameWStr(This,szw)
#define IEnroll_put_SPCFileNameWStr(This,szw) (This)->lpVtbl->put_SPCFileNameWStr(This,szw)
#define IEnroll_get_PVKFileNameWStr(This,szw) (This)->lpVtbl->get_PVKFileNameWStr(This,szw)
#define IEnroll_put_PVKFileNameWStr(This,szw) (This)->lpVtbl->put_PVKFileNameWStr(This,szw)
#define IEnroll_get_HashAlgorithmWStr(This,szw) (This)->lpVtbl->get_HashAlgorithmWStr(This,szw)
#define IEnroll_put_HashAlgorithmWStr(This,szw) (This)->lpVtbl->put_HashAlgorithmWStr(This,szw)
#define IEnroll_get_RenewalCertificate(This,ppCertContext) (This)->lpVtbl->get_RenewalCertificate(This,ppCertContext)
#define IEnroll_put_RenewalCertificate(This,pCertContext) (This)->lpVtbl->put_RenewalCertificate(This,pCertContext)
#define IEnroll_AddCertTypeToRequestWStr(This,szw) (This)->lpVtbl->AddCertTypeToRequestWStr(This,szw)
#define IEnroll_AddNameValuePairToSignatureWStr(This,Name,Value) (This)->lpVtbl->AddNameValuePairToSignatureWStr(This,Name,Value)
#define IEnroll_AddExtensionsToRequest(This,pCertExtensions) (This)->lpVtbl->AddExtensionsToRequest(This,pCertExtensions)
#define IEnroll_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) (This)->lpVtbl->AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)
#define IEnroll_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) (This)->lpVtbl->CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)
#endif
#endif
  HRESULT WINAPI IEnroll_createFilePKCS10WStr_Proxy(IEnroll *This,LPCWSTR DNName,LPCWSTR Usage,LPCWSTR wszPKCS10FileName);
  void __RPC_STUB IEnroll_createFilePKCS10WStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_acceptFilePKCS7WStr_Proxy(IEnroll *This,LPCWSTR wszPKCS7FileName);
  void __RPC_STUB IEnroll_acceptFilePKCS7WStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_createPKCS10WStr_Proxy(IEnroll *This,LPCWSTR DNName,LPCWSTR Usage,PCRYPT_DATA_BLOB pPkcs10Blob);
  void __RPC_STUB IEnroll_createPKCS10WStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_acceptPKCS7Blob_Proxy(IEnroll *This,PCRYPT_DATA_BLOB pBlobPKCS7);
  void __RPC_STUB IEnroll_acceptPKCS7Blob_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  PCCERT_CONTEXT WINAPI IEnroll_getCertContextFromPKCS7_Proxy(IEnroll *This,PCRYPT_DATA_BLOB pBlobPKCS7);
  void __RPC_STUB IEnroll_getCertContextFromPKCS7_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HCERTSTORE WINAPI IEnroll_getMyStore_Proxy(IEnroll *This);
  void __RPC_STUB IEnroll_getMyStore_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HCERTSTORE WINAPI IEnroll_getCAStore_Proxy(IEnroll *This);
  void __RPC_STUB IEnroll_getCAStore_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HCERTSTORE WINAPI IEnroll_getROOTHStore_Proxy(IEnroll *This);
  void __RPC_STUB IEnroll_getROOTHStore_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_enumProvidersWStr_Proxy(IEnroll *This,LONG dwIndex,LONG dwFlags,LPWSTR *pbstrProvName);
  void __RPC_STUB IEnroll_enumProvidersWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_enumContainersWStr_Proxy(IEnroll *This,LONG dwIndex,LPWSTR *pbstr);
  void __RPC_STUB IEnroll_enumContainersWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_freeRequestInfoBlob_Proxy(IEnroll *This,CRYPT_DATA_BLOB pkcs7OrPkcs10);
  void __RPC_STUB IEnroll_freeRequestInfoBlob_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_MyStoreNameWStr_Proxy(IEnroll *This,LPWSTR *szwName);
  void __RPC_STUB IEnroll_get_MyStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_MyStoreNameWStr_Proxy(IEnroll *This,LPWSTR szwName);
  void __RPC_STUB IEnroll_put_MyStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_MyStoreTypeWStr_Proxy(IEnroll *This,LPWSTR *szwType);
  void __RPC_STUB IEnroll_get_MyStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_MyStoreTypeWStr_Proxy(IEnroll *This,LPWSTR szwType);
  void __RPC_STUB IEnroll_put_MyStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_MyStoreFlags_Proxy(IEnroll *This,LONG *pdwFlags);
  void __RPC_STUB IEnroll_get_MyStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_MyStoreFlags_Proxy(IEnroll *This,LONG dwFlags);
  void __RPC_STUB IEnroll_put_MyStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_CAStoreNameWStr_Proxy(IEnroll *This,LPWSTR *szwName);
  void __RPC_STUB IEnroll_get_CAStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_CAStoreNameWStr_Proxy(IEnroll *This,LPWSTR szwName);
  void __RPC_STUB IEnroll_put_CAStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_CAStoreTypeWStr_Proxy(IEnroll *This,LPWSTR *szwType);
  void __RPC_STUB IEnroll_get_CAStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_CAStoreTypeWStr_Proxy(IEnroll *This,LPWSTR szwType);
  void __RPC_STUB IEnroll_put_CAStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_CAStoreFlags_Proxy(IEnroll *This,LONG *pdwFlags);
  void __RPC_STUB IEnroll_get_CAStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_CAStoreFlags_Proxy(IEnroll *This,LONG dwFlags);
  void __RPC_STUB IEnroll_put_CAStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_RootStoreNameWStr_Proxy(IEnroll *This,LPWSTR *szwName);
  void __RPC_STUB IEnroll_get_RootStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_RootStoreNameWStr_Proxy(IEnroll *This,LPWSTR szwName);
  void __RPC_STUB IEnroll_put_RootStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_RootStoreTypeWStr_Proxy(IEnroll *This,LPWSTR *szwType);
  void __RPC_STUB IEnroll_get_RootStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_RootStoreTypeWStr_Proxy(IEnroll *This,LPWSTR szwType);
  void __RPC_STUB IEnroll_put_RootStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_RootStoreFlags_Proxy(IEnroll *This,LONG *pdwFlags);
  void __RPC_STUB IEnroll_get_RootStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_RootStoreFlags_Proxy(IEnroll *This,LONG dwFlags);
  void __RPC_STUB IEnroll_put_RootStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_RequestStoreNameWStr_Proxy(IEnroll *This,LPWSTR *szwName);
  void __RPC_STUB IEnroll_get_RequestStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_RequestStoreNameWStr_Proxy(IEnroll *This,LPWSTR szwName);
  void __RPC_STUB IEnroll_put_RequestStoreNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_RequestStoreTypeWStr_Proxy(IEnroll *This,LPWSTR *szwType);
  void __RPC_STUB IEnroll_get_RequestStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_RequestStoreTypeWStr_Proxy(IEnroll *This,LPWSTR szwType);
  void __RPC_STUB IEnroll_put_RequestStoreTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_RequestStoreFlags_Proxy(IEnroll *This,LONG *pdwFlags);
  void __RPC_STUB IEnroll_get_RequestStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_RequestStoreFlags_Proxy(IEnroll *This,LONG dwFlags);
  void __RPC_STUB IEnroll_put_RequestStoreFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_ContainerNameWStr_Proxy(IEnroll *This,LPWSTR *szwContainer);
  void __RPC_STUB IEnroll_get_ContainerNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_ContainerNameWStr_Proxy(IEnroll *This,LPWSTR szwContainer);
  void __RPC_STUB IEnroll_put_ContainerNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_ProviderNameWStr_Proxy(IEnroll *This,LPWSTR *szwProvider);
  void __RPC_STUB IEnroll_get_ProviderNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_ProviderNameWStr_Proxy(IEnroll *This,LPWSTR szwProvider);
  void __RPC_STUB IEnroll_put_ProviderNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_ProviderType_Proxy(IEnroll *This,LONG *pdwType);
  void __RPC_STUB IEnroll_get_ProviderType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_ProviderType_Proxy(IEnroll *This,LONG dwType);
  void __RPC_STUB IEnroll_put_ProviderType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_KeySpec_Proxy(IEnroll *This,LONG *pdw);
  void __RPC_STUB IEnroll_get_KeySpec_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_KeySpec_Proxy(IEnroll *This,LONG dw);
  void __RPC_STUB IEnroll_put_KeySpec_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_ProviderFlags_Proxy(IEnroll *This,LONG *pdwFlags);
  void __RPC_STUB IEnroll_get_ProviderFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_ProviderFlags_Proxy(IEnroll *This,LONG dwFlags);
  void __RPC_STUB IEnroll_put_ProviderFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_UseExistingKeySet_Proxy(IEnroll *This,WINBOOL *fUseExistingKeys);
  void __RPC_STUB IEnroll_get_UseExistingKeySet_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_UseExistingKeySet_Proxy(IEnroll *This,WINBOOL fUseExistingKeys);
  void __RPC_STUB IEnroll_put_UseExistingKeySet_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_GenKeyFlags_Proxy(IEnroll *This,LONG *pdwFlags);
  void __RPC_STUB IEnroll_get_GenKeyFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_GenKeyFlags_Proxy(IEnroll *This,LONG dwFlags);
  void __RPC_STUB IEnroll_put_GenKeyFlags_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_DeleteRequestCert_Proxy(IEnroll *This,WINBOOL *fDelete);
  void __RPC_STUB IEnroll_get_DeleteRequestCert_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_DeleteRequestCert_Proxy(IEnroll *This,WINBOOL fDelete);
  void __RPC_STUB IEnroll_put_DeleteRequestCert_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_WriteCertToUserDS_Proxy(IEnroll *This,WINBOOL *fBool);
  void __RPC_STUB IEnroll_get_WriteCertToUserDS_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_WriteCertToUserDS_Proxy(IEnroll *This,WINBOOL fBool);
  void __RPC_STUB IEnroll_put_WriteCertToUserDS_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_EnableT61DNEncoding_Proxy(IEnroll *This,WINBOOL *fBool);
  void __RPC_STUB IEnroll_get_EnableT61DNEncoding_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_EnableT61DNEncoding_Proxy(IEnroll *This,WINBOOL fBool);
  void __RPC_STUB IEnroll_put_EnableT61DNEncoding_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_WriteCertToCSP_Proxy(IEnroll *This,WINBOOL *fBool);
  void __RPC_STUB IEnroll_get_WriteCertToCSP_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_WriteCertToCSP_Proxy(IEnroll *This,WINBOOL fBool);
  void __RPC_STUB IEnroll_put_WriteCertToCSP_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_SPCFileNameWStr_Proxy(IEnroll *This,LPWSTR *szw);
  void __RPC_STUB IEnroll_get_SPCFileNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_SPCFileNameWStr_Proxy(IEnroll *This,LPWSTR szw);
  void __RPC_STUB IEnroll_put_SPCFileNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_PVKFileNameWStr_Proxy(IEnroll *This,LPWSTR *szw);
  void __RPC_STUB IEnroll_get_PVKFileNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_PVKFileNameWStr_Proxy(IEnroll *This,LPWSTR szw);
  void __RPC_STUB IEnroll_put_PVKFileNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_HashAlgorithmWStr_Proxy(IEnroll *This,LPWSTR *szw);
  void __RPC_STUB IEnroll_get_HashAlgorithmWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_HashAlgorithmWStr_Proxy(IEnroll *This,LPWSTR szw);
  void __RPC_STUB IEnroll_put_HashAlgorithmWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_get_RenewalCertificate_Proxy(IEnroll *This,PCCERT_CONTEXT *ppCertContext);
  void __RPC_STUB IEnroll_get_RenewalCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_put_RenewalCertificate_Proxy(IEnroll *This,PCCERT_CONTEXT pCertContext);
  void __RPC_STUB IEnroll_put_RenewalCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_AddCertTypeToRequestWStr_Proxy(IEnroll *This,LPWSTR szw);
  void __RPC_STUB IEnroll_AddCertTypeToRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_AddNameValuePairToSignatureWStr_Proxy(IEnroll *This,LPWSTR Name,LPWSTR Value);
  void __RPC_STUB IEnroll_AddNameValuePairToSignatureWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_AddExtensionsToRequest_Proxy(IEnroll *This,PCERT_EXTENSIONS pCertExtensions);
  void __RPC_STUB IEnroll_AddExtensionsToRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_AddAuthenticatedAttributesToPKCS7Request_Proxy(IEnroll *This,PCRYPT_ATTRIBUTES pAttributes);
  void __RPC_STUB IEnroll_AddAuthenticatedAttributesToPKCS7Request_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll_CreatePKCS7RequestFromRequest_Proxy(IEnroll *This,PCRYPT_DATA_BLOB pRequest,PCCERT_CONTEXT pSigningCertContext,PCRYPT_DATA_BLOB pPkcs7Blob);
  void __RPC_STUB IEnroll_CreatePKCS7RequestFromRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IEnroll2_INTERFACE_DEFINED__
#define __IEnroll2_INTERFACE_DEFINED__
  extern const IID IID_IEnroll2;
#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __cplusplus
}
#endif
  struct IEnroll2 : public IEnroll {
  public:
    virtual HRESULT WINAPI InstallPKCS7Blob(PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
    virtual HRESULT WINAPI Reset(void) = 0;
    virtual HRESULT WINAPI GetSupportedKeySpec(LONG *pdwKeySpec) = 0;
    virtual HRESULT WINAPI GetKeyLen(WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize) = 0;
    virtual HRESULT WINAPI EnumAlgs(LONG dwIndex,LONG algClass,LONG *pdwAlgID) = 0;
    virtual HRESULT WINAPI GetAlgNameWStr(LONG algID,LPWSTR *ppwsz) = 0;
    virtual HRESULT WINAPI put_ReuseHardwareKeyIfUnableToGenNew(WINBOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
    virtual HRESULT WINAPI get_ReuseHardwareKeyIfUnableToGenNew(WINBOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
    virtual HRESULT WINAPI put_HashAlgID(LONG hashAlgID) = 0;
    virtual HRESULT WINAPI get_HashAlgID(LONG *hashAlgID) = 0;
    virtual HRESULT WINAPI SetHStoreMy(HCERTSTORE hStore) = 0;
    virtual HRESULT WINAPI SetHStoreCA(HCERTSTORE hStore) = 0;
    virtual HRESULT WINAPI SetHStoreROOT(HCERTSTORE hStore) = 0;
    virtual HRESULT WINAPI SetHStoreRequest(HCERTSTORE hStore) = 0;
    virtual HRESULT WINAPI put_LimitExchangeKeyToEncipherment(WINBOOL fLimitExchangeKeyToEncipherment) = 0;
    virtual HRESULT WINAPI get_LimitExchangeKeyToEncipherment(WINBOOL *fLimitExchangeKeyToEncipherment) = 0;
    virtual HRESULT WINAPI put_EnableSMIMECapabilities(WINBOOL fEnableSMIMECapabilities) = 0;
    virtual HRESULT WINAPI get_EnableSMIMECapabilities(WINBOOL *fEnableSMIMECapabilities) = 0;
  };
#ifdef __cplusplus
  extern "C" {
#endif
#else
  typedef struct IEnroll2Vtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IEnroll2 *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IEnroll2 *This);
      ULONG (WINAPI *Release)(IEnroll2 *This);
      HRESULT (WINAPI *createFilePKCS10WStr)(IEnroll2 *This,LPCWSTR DNName,LPCWSTR Usage,LPCWSTR wszPKCS10FileName);
      HRESULT (WINAPI *acceptFilePKCS7WStr)(IEnroll2 *This,LPCWSTR wszPKCS7FileName);
      HRESULT (WINAPI *createPKCS10WStr)(IEnroll2 *This,LPCWSTR DNName,LPCWSTR Usage,PCRYPT_DATA_BLOB pPkcs10Blob);
      HRESULT (WINAPI *acceptPKCS7Blob)(IEnroll2 *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      PCCERT_CONTEXT (WINAPI *getCertContextFromPKCS7)(IEnroll2 *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      HCERTSTORE (WINAPI *getMyStore)(IEnroll2 *This);
      HCERTSTORE (WINAPI *getCAStore)(IEnroll2 *This);
      HCERTSTORE (WINAPI *getROOTHStore)(IEnroll2 *This);
      HRESULT (WINAPI *enumProvidersWStr)(IEnroll2 *This,LONG dwIndex,LONG dwFlags,LPWSTR *pbstrProvName);
      HRESULT (WINAPI *enumContainersWStr)(IEnroll2 *This,LONG dwIndex,LPWSTR *pbstr);
      HRESULT (WINAPI *freeRequestInfoBlob)(IEnroll2 *This,CRYPT_DATA_BLOB pkcs7OrPkcs10);
      HRESULT (WINAPI *get_MyStoreNameWStr)(IEnroll2 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_MyStoreNameWStr)(IEnroll2 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_MyStoreTypeWStr)(IEnroll2 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_MyStoreTypeWStr)(IEnroll2 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_MyStoreFlags)(IEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_MyStoreFlags)(IEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_CAStoreNameWStr)(IEnroll2 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_CAStoreNameWStr)(IEnroll2 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_CAStoreTypeWStr)(IEnroll2 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_CAStoreTypeWStr)(IEnroll2 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_CAStoreFlags)(IEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_CAStoreFlags)(IEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RootStoreNameWStr)(IEnroll2 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_RootStoreNameWStr)(IEnroll2 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_RootStoreTypeWStr)(IEnroll2 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_RootStoreTypeWStr)(IEnroll2 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_RootStoreFlags)(IEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RootStoreFlags)(IEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RequestStoreNameWStr)(IEnroll2 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_RequestStoreNameWStr)(IEnroll2 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_RequestStoreTypeWStr)(IEnroll2 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_RequestStoreTypeWStr)(IEnroll2 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_RequestStoreFlags)(IEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RequestStoreFlags)(IEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_ContainerNameWStr)(IEnroll2 *This,LPWSTR *szwContainer);
      HRESULT (WINAPI *put_ContainerNameWStr)(IEnroll2 *This,LPWSTR szwContainer);
      HRESULT (WINAPI *get_ProviderNameWStr)(IEnroll2 *This,LPWSTR *szwProvider);
      HRESULT (WINAPI *put_ProviderNameWStr)(IEnroll2 *This,LPWSTR szwProvider);
      HRESULT (WINAPI *get_ProviderType)(IEnroll2 *This,LONG *pdwType);
      HRESULT (WINAPI *put_ProviderType)(IEnroll2 *This,LONG dwType);
      HRESULT (WINAPI *get_KeySpec)(IEnroll2 *This,LONG *pdw);
      HRESULT (WINAPI *put_KeySpec)(IEnroll2 *This,LONG dw);
      HRESULT (WINAPI *get_ProviderFlags)(IEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_ProviderFlags)(IEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_UseExistingKeySet)(IEnroll2 *This,WINBOOL *fUseExistingKeys);
      HRESULT (WINAPI *put_UseExistingKeySet)(IEnroll2 *This,WINBOOL fUseExistingKeys);
      HRESULT (WINAPI *get_GenKeyFlags)(IEnroll2 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_GenKeyFlags)(IEnroll2 *This,LONG dwFlags);
      HRESULT (WINAPI *get_DeleteRequestCert)(IEnroll2 *This,WINBOOL *fDelete);
      HRESULT (WINAPI *put_DeleteRequestCert)(IEnroll2 *This,WINBOOL fDelete);
      HRESULT (WINAPI *get_WriteCertToUserDS)(IEnroll2 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToUserDS)(IEnroll2 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_EnableT61DNEncoding)(IEnroll2 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_EnableT61DNEncoding)(IEnroll2 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_WriteCertToCSP)(IEnroll2 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToCSP)(IEnroll2 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_SPCFileNameWStr)(IEnroll2 *This,LPWSTR *szw);
      HRESULT (WINAPI *put_SPCFileNameWStr)(IEnroll2 *This,LPWSTR szw);
      HRESULT (WINAPI *get_PVKFileNameWStr)(IEnroll2 *This,LPWSTR *szw);
      HRESULT (WINAPI *put_PVKFileNameWStr)(IEnroll2 *This,LPWSTR szw);
      HRESULT (WINAPI *get_HashAlgorithmWStr)(IEnroll2 *This,LPWSTR *szw);
      HRESULT (WINAPI *put_HashAlgorithmWStr)(IEnroll2 *This,LPWSTR szw);
      HRESULT (WINAPI *get_RenewalCertificate)(IEnroll2 *This,PCCERT_CONTEXT *ppCertContext);
      HRESULT (WINAPI *put_RenewalCertificate)(IEnroll2 *This,PCCERT_CONTEXT pCertContext);
      HRESULT (WINAPI *AddCertTypeToRequestWStr)(IEnroll2 *This,LPWSTR szw);
      HRESULT (WINAPI *AddNameValuePairToSignatureWStr)(IEnroll2 *This,LPWSTR Name,LPWSTR Value);
      HRESULT (WINAPI *AddExtensionsToRequest)(IEnroll2 *This,PCERT_EXTENSIONS pCertExtensions);
      HRESULT (WINAPI *AddAuthenticatedAttributesToPKCS7Request)(IEnroll2 *This,PCRYPT_ATTRIBUTES pAttributes);
      HRESULT (WINAPI *CreatePKCS7RequestFromRequest)(IEnroll2 *This,PCRYPT_DATA_BLOB pRequest,PCCERT_CONTEXT pSigningCertContext,PCRYPT_DATA_BLOB pPkcs7Blob);
      HRESULT (WINAPI *InstallPKCS7Blob)(IEnroll2 *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      HRESULT (WINAPI *Reset)(IEnroll2 *This);
      HRESULT (WINAPI *GetSupportedKeySpec)(IEnroll2 *This,LONG *pdwKeySpec);
      HRESULT (WINAPI *GetKeyLen)(IEnroll2 *This,WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize);
      HRESULT (WINAPI *EnumAlgs)(IEnroll2 *This,LONG dwIndex,LONG algClass,LONG *pdwAlgID);
      HRESULT (WINAPI *GetAlgNameWStr)(IEnroll2 *This,LONG algID,LPWSTR *ppwsz);
      HRESULT (WINAPI *put_ReuseHardwareKeyIfUnableToGenNew)(IEnroll2 *This,WINBOOL fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *get_ReuseHardwareKeyIfUnableToGenNew)(IEnroll2 *This,WINBOOL *fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *put_HashAlgID)(IEnroll2 *This,LONG hashAlgID);
      HRESULT (WINAPI *get_HashAlgID)(IEnroll2 *This,LONG *hashAlgID);
      HRESULT (WINAPI *SetHStoreMy)(IEnroll2 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *SetHStoreCA)(IEnroll2 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *SetHStoreROOT)(IEnroll2 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *SetHStoreRequest)(IEnroll2 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *put_LimitExchangeKeyToEncipherment)(IEnroll2 *This,WINBOOL fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *get_LimitExchangeKeyToEncipherment)(IEnroll2 *This,WINBOOL *fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *put_EnableSMIMECapabilities)(IEnroll2 *This,WINBOOL fEnableSMIMECapabilities);
      HRESULT (WINAPI *get_EnableSMIMECapabilities)(IEnroll2 *This,WINBOOL *fEnableSMIMECapabilities);
    END_INTERFACE
  } IEnroll2Vtbl;
  struct IEnroll2 {
    CONST_VTBL struct IEnroll2Vtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IEnroll2_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IEnroll2_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IEnroll2_Release(This) (This)->lpVtbl->Release(This)
#define IEnroll2_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) (This)->lpVtbl->createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)
#define IEnroll2_acceptFilePKCS7WStr(This,wszPKCS7FileName) (This)->lpVtbl->acceptFilePKCS7WStr(This,wszPKCS7FileName)
#define IEnroll2_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) (This)->lpVtbl->createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)
#define IEnroll2_acceptPKCS7Blob(This,pBlobPKCS7) (This)->lpVtbl->acceptPKCS7Blob(This,pBlobPKCS7)
#define IEnroll2_getCertContextFromPKCS7(This,pBlobPKCS7) (This)->lpVtbl->getCertContextFromPKCS7(This,pBlobPKCS7)
#define IEnroll2_getMyStore(This) (This)->lpVtbl->getMyStore(This)
#define IEnroll2_getCAStore(This) (This)->lpVtbl->getCAStore(This)
#define IEnroll2_getROOTHStore(This) (This)->lpVtbl->getROOTHStore(This)
#define IEnroll2_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) (This)->lpVtbl->enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)
#define IEnroll2_enumContainersWStr(This,dwIndex,pbstr) (This)->lpVtbl->enumContainersWStr(This,dwIndex,pbstr)
#define IEnroll2_freeRequestInfoBlob(This,pkcs7OrPkcs10) (This)->lpVtbl->freeRequestInfoBlob(This,pkcs7OrPkcs10)
#define IEnroll2_get_MyStoreNameWStr(This,szwName) (This)->lpVtbl->get_MyStoreNameWStr(This,szwName)
#define IEnroll2_put_MyStoreNameWStr(This,szwName) (This)->lpVtbl->put_MyStoreNameWStr(This,szwName)
#define IEnroll2_get_MyStoreTypeWStr(This,szwType) (This)->lpVtbl->get_MyStoreTypeWStr(This,szwType)
#define IEnroll2_put_MyStoreTypeWStr(This,szwType) (This)->lpVtbl->put_MyStoreTypeWStr(This,szwType)
#define IEnroll2_get_MyStoreFlags(This,pdwFlags) (This)->lpVtbl->get_MyStoreFlags(This,pdwFlags)
#define IEnroll2_put_MyStoreFlags(This,dwFlags) (This)->lpVtbl->put_MyStoreFlags(This,dwFlags)
#define IEnroll2_get_CAStoreNameWStr(This,szwName) (This)->lpVtbl->get_CAStoreNameWStr(This,szwName)
#define IEnroll2_put_CAStoreNameWStr(This,szwName) (This)->lpVtbl->put_CAStoreNameWStr(This,szwName)
#define IEnroll2_get_CAStoreTypeWStr(This,szwType) (This)->lpVtbl->get_CAStoreTypeWStr(This,szwType)
#define IEnroll2_put_CAStoreTypeWStr(This,szwType) (This)->lpVtbl->put_CAStoreTypeWStr(This,szwType)
#define IEnroll2_get_CAStoreFlags(This,pdwFlags) (This)->lpVtbl->get_CAStoreFlags(This,pdwFlags)
#define IEnroll2_put_CAStoreFlags(This,dwFlags) (This)->lpVtbl->put_CAStoreFlags(This,dwFlags)
#define IEnroll2_get_RootStoreNameWStr(This,szwName) (This)->lpVtbl->get_RootStoreNameWStr(This,szwName)
#define IEnroll2_put_RootStoreNameWStr(This,szwName) (This)->lpVtbl->put_RootStoreNameWStr(This,szwName)
#define IEnroll2_get_RootStoreTypeWStr(This,szwType) (This)->lpVtbl->get_RootStoreTypeWStr(This,szwType)
#define IEnroll2_put_RootStoreTypeWStr(This,szwType) (This)->lpVtbl->put_RootStoreTypeWStr(This,szwType)
#define IEnroll2_get_RootStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RootStoreFlags(This,pdwFlags)
#define IEnroll2_put_RootStoreFlags(This,dwFlags) (This)->lpVtbl->put_RootStoreFlags(This,dwFlags)
#define IEnroll2_get_RequestStoreNameWStr(This,szwName) (This)->lpVtbl->get_RequestStoreNameWStr(This,szwName)
#define IEnroll2_put_RequestStoreNameWStr(This,szwName) (This)->lpVtbl->put_RequestStoreNameWStr(This,szwName)
#define IEnroll2_get_RequestStoreTypeWStr(This,szwType) (This)->lpVtbl->get_RequestStoreTypeWStr(This,szwType)
#define IEnroll2_put_RequestStoreTypeWStr(This,szwType) (This)->lpVtbl->put_RequestStoreTypeWStr(This,szwType)
#define IEnroll2_get_RequestStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RequestStoreFlags(This,pdwFlags)
#define IEnroll2_put_RequestStoreFlags(This,dwFlags) (This)->lpVtbl->put_RequestStoreFlags(This,dwFlags)
#define IEnroll2_get_ContainerNameWStr(This,szwContainer) (This)->lpVtbl->get_ContainerNameWStr(This,szwContainer)
#define IEnroll2_put_ContainerNameWStr(This,szwContainer) (This)->lpVtbl->put_ContainerNameWStr(This,szwContainer)
#define IEnroll2_get_ProviderNameWStr(This,szwProvider) (This)->lpVtbl->get_ProviderNameWStr(This,szwProvider)
#define IEnroll2_put_ProviderNameWStr(This,szwProvider) (This)->lpVtbl->put_ProviderNameWStr(This,szwProvider)
#define IEnroll2_get_ProviderType(This,pdwType) (This)->lpVtbl->get_ProviderType(This,pdwType)
#define IEnroll2_put_ProviderType(This,dwType) (This)->lpVtbl->put_ProviderType(This,dwType)
#define IEnroll2_get_KeySpec(This,pdw) (This)->lpVtbl->get_KeySpec(This,pdw)
#define IEnroll2_put_KeySpec(This,dw) (This)->lpVtbl->put_KeySpec(This,dw)
#define IEnroll2_get_ProviderFlags(This,pdwFlags) (This)->lpVtbl->get_ProviderFlags(This,pdwFlags)
#define IEnroll2_put_ProviderFlags(This,dwFlags) (This)->lpVtbl->put_ProviderFlags(This,dwFlags)
#define IEnroll2_get_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->get_UseExistingKeySet(This,fUseExistingKeys)
#define IEnroll2_put_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->put_UseExistingKeySet(This,fUseExistingKeys)
#define IEnroll2_get_GenKeyFlags(This,pdwFlags) (This)->lpVtbl->get_GenKeyFlags(This,pdwFlags)
#define IEnroll2_put_GenKeyFlags(This,dwFlags) (This)->lpVtbl->put_GenKeyFlags(This,dwFlags)
#define IEnroll2_get_DeleteRequestCert(This,fDelete) (This)->lpVtbl->get_DeleteRequestCert(This,fDelete)
#define IEnroll2_put_DeleteRequestCert(This,fDelete) (This)->lpVtbl->put_DeleteRequestCert(This,fDelete)
#define IEnroll2_get_WriteCertToUserDS(This,fBool) (This)->lpVtbl->get_WriteCertToUserDS(This,fBool)
#define IEnroll2_put_WriteCertToUserDS(This,fBool) (This)->lpVtbl->put_WriteCertToUserDS(This,fBool)
#define IEnroll2_get_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->get_EnableT61DNEncoding(This,fBool)
#define IEnroll2_put_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->put_EnableT61DNEncoding(This,fBool)
#define IEnroll2_get_WriteCertToCSP(This,fBool) (This)->lpVtbl->get_WriteCertToCSP(This,fBool)
#define IEnroll2_put_WriteCertToCSP(This,fBool) (This)->lpVtbl->put_WriteCertToCSP(This,fBool)
#define IEnroll2_get_SPCFileNameWStr(This,szw) (This)->lpVtbl->get_SPCFileNameWStr(This,szw)
#define IEnroll2_put_SPCFileNameWStr(This,szw) (This)->lpVtbl->put_SPCFileNameWStr(This,szw)
#define IEnroll2_get_PVKFileNameWStr(This,szw) (This)->lpVtbl->get_PVKFileNameWStr(This,szw)
#define IEnroll2_put_PVKFileNameWStr(This,szw) (This)->lpVtbl->put_PVKFileNameWStr(This,szw)
#define IEnroll2_get_HashAlgorithmWStr(This,szw) (This)->lpVtbl->get_HashAlgorithmWStr(This,szw)
#define IEnroll2_put_HashAlgorithmWStr(This,szw) (This)->lpVtbl->put_HashAlgorithmWStr(This,szw)
#define IEnroll2_get_RenewalCertificate(This,ppCertContext) (This)->lpVtbl->get_RenewalCertificate(This,ppCertContext)
#define IEnroll2_put_RenewalCertificate(This,pCertContext) (This)->lpVtbl->put_RenewalCertificate(This,pCertContext)
#define IEnroll2_AddCertTypeToRequestWStr(This,szw) (This)->lpVtbl->AddCertTypeToRequestWStr(This,szw)
#define IEnroll2_AddNameValuePairToSignatureWStr(This,Name,Value) (This)->lpVtbl->AddNameValuePairToSignatureWStr(This,Name,Value)
#define IEnroll2_AddExtensionsToRequest(This,pCertExtensions) (This)->lpVtbl->AddExtensionsToRequest(This,pCertExtensions)
#define IEnroll2_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) (This)->lpVtbl->AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)
#define IEnroll2_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) (This)->lpVtbl->CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)
#define IEnroll2_InstallPKCS7Blob(This,pBlobPKCS7) (This)->lpVtbl->InstallPKCS7Blob(This,pBlobPKCS7)
#define IEnroll2_Reset(This) (This)->lpVtbl->Reset(This)
#define IEnroll2_GetSupportedKeySpec(This,pdwKeySpec) (This)->lpVtbl->GetSupportedKeySpec(This,pdwKeySpec)
#define IEnroll2_GetKeyLen(This,fMin,fExchange,pdwKeySize) (This)->lpVtbl->GetKeyLen(This,fMin,fExchange,pdwKeySize)
#define IEnroll2_EnumAlgs(This,dwIndex,algClass,pdwAlgID) (This)->lpVtbl->EnumAlgs(This,dwIndex,algClass,pdwAlgID)
#define IEnroll2_GetAlgNameWStr(This,algID,ppwsz) (This)->lpVtbl->GetAlgNameWStr(This,algID,ppwsz)
#define IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define IEnroll2_put_HashAlgID(This,hashAlgID) (This)->lpVtbl->put_HashAlgID(This,hashAlgID)
#define IEnroll2_get_HashAlgID(This,hashAlgID) (This)->lpVtbl->get_HashAlgID(This,hashAlgID)
#define IEnroll2_SetHStoreMy(This,hStore) (This)->lpVtbl->SetHStoreMy(This,hStore)
#define IEnroll2_SetHStoreCA(This,hStore) (This)->lpVtbl->SetHStoreCA(This,hStore)
#define IEnroll2_SetHStoreROOT(This,hStore) (This)->lpVtbl->SetHStoreROOT(This,hStore)
#define IEnroll2_SetHStoreRequest(This,hStore) (This)->lpVtbl->SetHStoreRequest(This,hStore)
#define IEnroll2_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define IEnroll2_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define IEnroll2_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#define IEnroll2_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#endif
#endif
  HRESULT WINAPI IEnroll2_InstallPKCS7Blob_Proxy(IEnroll2 *This,PCRYPT_DATA_BLOB pBlobPKCS7);
  void __RPC_STUB IEnroll2_InstallPKCS7Blob_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_Reset_Proxy(IEnroll2 *This);
  void __RPC_STUB IEnroll2_Reset_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_GetSupportedKeySpec_Proxy(IEnroll2 *This,LONG *pdwKeySpec);
  void __RPC_STUB IEnroll2_GetSupportedKeySpec_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_GetKeyLen_Proxy(IEnroll2 *This,WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize);
  void __RPC_STUB IEnroll2_GetKeyLen_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_EnumAlgs_Proxy(IEnroll2 *This,LONG dwIndex,LONG algClass,LONG *pdwAlgID);
  void __RPC_STUB IEnroll2_EnumAlgs_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_GetAlgNameWStr_Proxy(IEnroll2 *This,LONG algID,LPWSTR *ppwsz);
  void __RPC_STUB IEnroll2_GetAlgNameWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew_Proxy(IEnroll2 *This,WINBOOL fReuseHardwareKeyIfUnableToGenNew);
  void __RPC_STUB IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew_Proxy(IEnroll2 *This,WINBOOL *fReuseHardwareKeyIfUnableToGenNew);
  void __RPC_STUB IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_put_HashAlgID_Proxy(IEnroll2 *This,LONG hashAlgID);
  void __RPC_STUB IEnroll2_put_HashAlgID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_get_HashAlgID_Proxy(IEnroll2 *This,LONG *hashAlgID);
  void __RPC_STUB IEnroll2_get_HashAlgID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_SetHStoreMy_Proxy(IEnroll2 *This,HCERTSTORE hStore);
  void __RPC_STUB IEnroll2_SetHStoreMy_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_SetHStoreCA_Proxy(IEnroll2 *This,HCERTSTORE hStore);
  void __RPC_STUB IEnroll2_SetHStoreCA_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_SetHStoreROOT_Proxy(IEnroll2 *This,HCERTSTORE hStore);
  void __RPC_STUB IEnroll2_SetHStoreROOT_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_SetHStoreRequest_Proxy(IEnroll2 *This,HCERTSTORE hStore);
  void __RPC_STUB IEnroll2_SetHStoreRequest_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_put_LimitExchangeKeyToEncipherment_Proxy(IEnroll2 *This,WINBOOL fLimitExchangeKeyToEncipherment);
  void __RPC_STUB IEnroll2_put_LimitExchangeKeyToEncipherment_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_get_LimitExchangeKeyToEncipherment_Proxy(IEnroll2 *This,WINBOOL *fLimitExchangeKeyToEncipherment);
  void __RPC_STUB IEnroll2_get_LimitExchangeKeyToEncipherment_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_put_EnableSMIMECapabilities_Proxy(IEnroll2 *This,WINBOOL fEnableSMIMECapabilities);
  void __RPC_STUB IEnroll2_put_EnableSMIMECapabilities_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll2_get_EnableSMIMECapabilities_Proxy(IEnroll2 *This,WINBOOL *fEnableSMIMECapabilities);
  void __RPC_STUB IEnroll2_get_EnableSMIMECapabilities_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __IEnroll4_INTERFACE_DEFINED__
#define __IEnroll4_INTERFACE_DEFINED__
  extern const IID IID_IEnroll4;
#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __cplusplus
}
#endif
  struct IEnroll4 : public IEnroll2 {
  public:
    virtual HRESULT WINAPI put_ThumbPrintWStr(CRYPT_DATA_BLOB thumbPrintBlob) = 0;
    virtual HRESULT WINAPI get_ThumbPrintWStr(PCRYPT_DATA_BLOB thumbPrintBlob) = 0;
    virtual HRESULT WINAPI SetPrivateKeyArchiveCertificate(PCCERT_CONTEXT pPrivateKeyArchiveCert) = 0;
    virtual PCCERT_CONTEXT WINAPI GetPrivateKeyArchiveCertificate(void) = 0;
    virtual HRESULT WINAPI binaryBlobToString(LONG Flags,PCRYPT_DATA_BLOB pblobBinary,LPWSTR *ppwszString) = 0;
    virtual HRESULT WINAPI stringToBinaryBlob(LONG Flags,LPCWSTR pwszString,PCRYPT_DATA_BLOB pblobBinary,LONG *pdwSkip,LONG *pdwFlags) = 0;
    virtual HRESULT WINAPI addExtensionToRequestWStr(LONG Flags,LPCWSTR pwszName,PCRYPT_DATA_BLOB pblobValue) = 0;
    virtual HRESULT WINAPI addAttributeToRequestWStr(LONG Flags,LPCWSTR pwszName,PCRYPT_DATA_BLOB pblobValue) = 0;
    virtual HRESULT WINAPI addNameValuePairToRequestWStr(LONG Flags,LPCWSTR pwszName,LPCWSTR pwszValue) = 0;
    virtual HRESULT WINAPI resetExtensions(void) = 0;
    virtual HRESULT WINAPI resetAttributes(void) = 0;
    virtual HRESULT WINAPI createRequestWStr(LONG Flags,LPCWSTR pwszDNName,LPCWSTR pwszUsage,PCRYPT_DATA_BLOB pblobRequest) = 0;
    virtual HRESULT WINAPI createFileRequestWStr(LONG Flags,LPCWSTR pwszDNName,LPCWSTR pwszUsage,LPCWSTR pwszRequestFileName) = 0;
    virtual HRESULT WINAPI acceptResponseBlob(PCRYPT_DATA_BLOB pblobResponse) = 0;
    virtual HRESULT WINAPI acceptFileResponseWStr(LPCWSTR pwszResponseFileName) = 0;
    virtual HRESULT WINAPI getCertContextFromResponseBlob(PCRYPT_DATA_BLOB pblobResponse,PCCERT_CONTEXT *ppCertContext) = 0;
    virtual HRESULT WINAPI getCertContextFromFileResponseWStr(LPCWSTR pwszResponseFileName,PCCERT_CONTEXT *ppCertContext) = 0;
    virtual HRESULT WINAPI createPFXWStr(LPCWSTR pwszPassword,PCRYPT_DATA_BLOB pblobPFX) = 0;
    virtual HRESULT WINAPI createFilePFXWStr(LPCWSTR pwszPassword,LPCWSTR pwszPFXFileName) = 0;
    virtual HRESULT WINAPI setPendingRequestInfoWStr(LONG lRequestID,LPCWSTR pwszCADNS,LPCWSTR pwszCAName,LPCWSTR pwszFriendlyName) = 0;
    virtual HRESULT WINAPI enumPendingRequestWStr(LONG lIndex,LONG lDesiredProperty,LPVOID ppProperty) = 0;
    virtual HRESULT WINAPI removePendingRequestWStr(CRYPT_DATA_BLOB thumbPrintBlob) = 0;
    virtual HRESULT WINAPI GetKeyLenEx(LONG lSizeSpec,LONG lKeySpec,LONG *pdwKeySize) = 0;
    virtual HRESULT WINAPI InstallPKCS7BlobEx(PCRYPT_DATA_BLOB pBlobPKCS7,LONG *plCertInstalled) = 0;
    virtual HRESULT WINAPI AddCertTypeToRequestWStrEx(LONG lType,LPCWSTR pwszOIDOrName,LONG lMajorVersion,WINBOOL fMinorVersion,LONG lMinorVersion) = 0;
    virtual HRESULT WINAPI getProviderTypeWStr(LPCWSTR pwszProvName,LONG *plProvType) = 0;
    virtual HRESULT WINAPI addBlobPropertyToCertificateWStr(LONG lPropertyId,LONG lReserved,PCRYPT_DATA_BLOB pBlobProperty) = 0;
    virtual HRESULT WINAPI SetSignerCertificate(PCCERT_CONTEXT pSignerCert) = 0;
    virtual HRESULT WINAPI put_ClientId(LONG lClientId) = 0;
    virtual HRESULT WINAPI get_ClientId(LONG *plClientId) = 0;
    virtual HRESULT WINAPI put_IncludeSubjectKeyID(WINBOOL fInclude) = 0;
    virtual HRESULT WINAPI get_IncludeSubjectKeyID(WINBOOL *pfInclude) = 0;
  };
#ifdef __cplusplus
  extern "C" {
#endif
#else
  typedef struct IEnroll4Vtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IEnroll4 *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IEnroll4 *This);
      ULONG (WINAPI *Release)(IEnroll4 *This);
      HRESULT (WINAPI *createFilePKCS10WStr)(IEnroll4 *This,LPCWSTR DNName,LPCWSTR Usage,LPCWSTR wszPKCS10FileName);
      HRESULT (WINAPI *acceptFilePKCS7WStr)(IEnroll4 *This,LPCWSTR wszPKCS7FileName);
      HRESULT (WINAPI *createPKCS10WStr)(IEnroll4 *This,LPCWSTR DNName,LPCWSTR Usage,PCRYPT_DATA_BLOB pPkcs10Blob);
      HRESULT (WINAPI *acceptPKCS7Blob)(IEnroll4 *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      PCCERT_CONTEXT (WINAPI *getCertContextFromPKCS7)(IEnroll4 *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      HCERTSTORE (WINAPI *getMyStore)(IEnroll4 *This);
      HCERTSTORE (WINAPI *getCAStore)(IEnroll4 *This);
      HCERTSTORE (WINAPI *getROOTHStore)(IEnroll4 *This);
      HRESULT (WINAPI *enumProvidersWStr)(IEnroll4 *This,LONG dwIndex,LONG dwFlags,LPWSTR *pbstrProvName);
      HRESULT (WINAPI *enumContainersWStr)(IEnroll4 *This,LONG dwIndex,LPWSTR *pbstr);
      HRESULT (WINAPI *freeRequestInfoBlob)(IEnroll4 *This,CRYPT_DATA_BLOB pkcs7OrPkcs10);
      HRESULT (WINAPI *get_MyStoreNameWStr)(IEnroll4 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_MyStoreNameWStr)(IEnroll4 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_MyStoreTypeWStr)(IEnroll4 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_MyStoreTypeWStr)(IEnroll4 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_MyStoreFlags)(IEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_MyStoreFlags)(IEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_CAStoreNameWStr)(IEnroll4 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_CAStoreNameWStr)(IEnroll4 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_CAStoreTypeWStr)(IEnroll4 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_CAStoreTypeWStr)(IEnroll4 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_CAStoreFlags)(IEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_CAStoreFlags)(IEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RootStoreNameWStr)(IEnroll4 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_RootStoreNameWStr)(IEnroll4 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_RootStoreTypeWStr)(IEnroll4 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_RootStoreTypeWStr)(IEnroll4 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_RootStoreFlags)(IEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RootStoreFlags)(IEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_RequestStoreNameWStr)(IEnroll4 *This,LPWSTR *szwName);
      HRESULT (WINAPI *put_RequestStoreNameWStr)(IEnroll4 *This,LPWSTR szwName);
      HRESULT (WINAPI *get_RequestStoreTypeWStr)(IEnroll4 *This,LPWSTR *szwType);
      HRESULT (WINAPI *put_RequestStoreTypeWStr)(IEnroll4 *This,LPWSTR szwType);
      HRESULT (WINAPI *get_RequestStoreFlags)(IEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_RequestStoreFlags)(IEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_ContainerNameWStr)(IEnroll4 *This,LPWSTR *szwContainer);
      HRESULT (WINAPI *put_ContainerNameWStr)(IEnroll4 *This,LPWSTR szwContainer);
      HRESULT (WINAPI *get_ProviderNameWStr)(IEnroll4 *This,LPWSTR *szwProvider);
      HRESULT (WINAPI *put_ProviderNameWStr)(IEnroll4 *This,LPWSTR szwProvider);
      HRESULT (WINAPI *get_ProviderType)(IEnroll4 *This,LONG *pdwType);
      HRESULT (WINAPI *put_ProviderType)(IEnroll4 *This,LONG dwType);
      HRESULT (WINAPI *get_KeySpec)(IEnroll4 *This,LONG *pdw);
      HRESULT (WINAPI *put_KeySpec)(IEnroll4 *This,LONG dw);
      HRESULT (WINAPI *get_ProviderFlags)(IEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_ProviderFlags)(IEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_UseExistingKeySet)(IEnroll4 *This,WINBOOL *fUseExistingKeys);
      HRESULT (WINAPI *put_UseExistingKeySet)(IEnroll4 *This,WINBOOL fUseExistingKeys);
      HRESULT (WINAPI *get_GenKeyFlags)(IEnroll4 *This,LONG *pdwFlags);
      HRESULT (WINAPI *put_GenKeyFlags)(IEnroll4 *This,LONG dwFlags);
      HRESULT (WINAPI *get_DeleteRequestCert)(IEnroll4 *This,WINBOOL *fDelete);
      HRESULT (WINAPI *put_DeleteRequestCert)(IEnroll4 *This,WINBOOL fDelete);
      HRESULT (WINAPI *get_WriteCertToUserDS)(IEnroll4 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToUserDS)(IEnroll4 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_EnableT61DNEncoding)(IEnroll4 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_EnableT61DNEncoding)(IEnroll4 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_WriteCertToCSP)(IEnroll4 *This,WINBOOL *fBool);
      HRESULT (WINAPI *put_WriteCertToCSP)(IEnroll4 *This,WINBOOL fBool);
      HRESULT (WINAPI *get_SPCFileNameWStr)(IEnroll4 *This,LPWSTR *szw);
      HRESULT (WINAPI *put_SPCFileNameWStr)(IEnroll4 *This,LPWSTR szw);
      HRESULT (WINAPI *get_PVKFileNameWStr)(IEnroll4 *This,LPWSTR *szw);
      HRESULT (WINAPI *put_PVKFileNameWStr)(IEnroll4 *This,LPWSTR szw);
      HRESULT (WINAPI *get_HashAlgorithmWStr)(IEnroll4 *This,LPWSTR *szw);
      HRESULT (WINAPI *put_HashAlgorithmWStr)(IEnroll4 *This,LPWSTR szw);
      HRESULT (WINAPI *get_RenewalCertificate)(IEnroll4 *This,PCCERT_CONTEXT *ppCertContext);
      HRESULT (WINAPI *put_RenewalCertificate)(IEnroll4 *This,PCCERT_CONTEXT pCertContext);
      HRESULT (WINAPI *AddCertTypeToRequestWStr)(IEnroll4 *This,LPWSTR szw);
      HRESULT (WINAPI *AddNameValuePairToSignatureWStr)(IEnroll4 *This,LPWSTR Name,LPWSTR Value);
      HRESULT (WINAPI *AddExtensionsToRequest)(IEnroll4 *This,PCERT_EXTENSIONS pCertExtensions);
      HRESULT (WINAPI *AddAuthenticatedAttributesToPKCS7Request)(IEnroll4 *This,PCRYPT_ATTRIBUTES pAttributes);
      HRESULT (WINAPI *CreatePKCS7RequestFromRequest)(IEnroll4 *This,PCRYPT_DATA_BLOB pRequest,PCCERT_CONTEXT pSigningCertContext,PCRYPT_DATA_BLOB pPkcs7Blob);
      HRESULT (WINAPI *InstallPKCS7Blob)(IEnroll4 *This,PCRYPT_DATA_BLOB pBlobPKCS7);
      HRESULT (WINAPI *Reset)(IEnroll4 *This);
      HRESULT (WINAPI *GetSupportedKeySpec)(IEnroll4 *This,LONG *pdwKeySpec);
      HRESULT (WINAPI *GetKeyLen)(IEnroll4 *This,WINBOOL fMin,WINBOOL fExchange,LONG *pdwKeySize);
      HRESULT (WINAPI *EnumAlgs)(IEnroll4 *This,LONG dwIndex,LONG algClass,LONG *pdwAlgID);
      HRESULT (WINAPI *GetAlgNameWStr)(IEnroll4 *This,LONG algID,LPWSTR *ppwsz);
      HRESULT (WINAPI *put_ReuseHardwareKeyIfUnableToGenNew)(IEnroll4 *This,WINBOOL fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *get_ReuseHardwareKeyIfUnableToGenNew)(IEnroll4 *This,WINBOOL *fReuseHardwareKeyIfUnableToGenNew);
      HRESULT (WINAPI *put_HashAlgID)(IEnroll4 *This,LONG hashAlgID);
      HRESULT (WINAPI *get_HashAlgID)(IEnroll4 *This,LONG *hashAlgID);
      HRESULT (WINAPI *SetHStoreMy)(IEnroll4 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *SetHStoreCA)(IEnroll4 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *SetHStoreROOT)(IEnroll4 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *SetHStoreRequest)(IEnroll4 *This,HCERTSTORE hStore);
      HRESULT (WINAPI *put_LimitExchangeKeyToEncipherment)(IEnroll4 *This,WINBOOL fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *get_LimitExchangeKeyToEncipherment)(IEnroll4 *This,WINBOOL *fLimitExchangeKeyToEncipherment);
      HRESULT (WINAPI *put_EnableSMIMECapabilities)(IEnroll4 *This,WINBOOL fEnableSMIMECapabilities);
      HRESULT (WINAPI *get_EnableSMIMECapabilities)(IEnroll4 *This,WINBOOL *fEnableSMIMECapabilities);
      HRESULT (WINAPI *put_ThumbPrintWStr)(IEnroll4 *This,CRYPT_DATA_BLOB thumbPrintBlob);
      HRESULT (WINAPI *get_ThumbPrintWStr)(IEnroll4 *This,PCRYPT_DATA_BLOB thumbPrintBlob);
      HRESULT (WINAPI *SetPrivateKeyArchiveCertificate)(IEnroll4 *This,PCCERT_CONTEXT pPrivateKeyArchiveCert);
      PCCERT_CONTEXT (WINAPI *GetPrivateKeyArchiveCertificate)(IEnroll4 *This);
      HRESULT (WINAPI *binaryBlobToString)(IEnroll4 *This,LONG Flags,PCRYPT_DATA_BLOB pblobBinary,LPWSTR *ppwszString);
      HRESULT (WINAPI *stringToBinaryBlob)(IEnroll4 *This,LONG Flags,LPCWSTR pwszString,PCRYPT_DATA_BLOB pblobBinary,LONG *pdwSkip,LONG *pdwFlags);
      HRESULT (WINAPI *addExtensionToRequestWStr)(IEnroll4 *This,LONG Flags,LPCWSTR pwszName,PCRYPT_DATA_BLOB pblobValue);
      HRESULT (WINAPI *addAttributeToRequestWStr)(IEnroll4 *This,LONG Flags,LPCWSTR pwszName,PCRYPT_DATA_BLOB pblobValue);
      HRESULT (WINAPI *addNameValuePairToRequestWStr)(IEnroll4 *This,LONG Flags,LPCWSTR pwszName,LPCWSTR pwszValue);
      HRESULT (WINAPI *resetExtensions)(IEnroll4 *This);
      HRESULT (WINAPI *resetAttributes)(IEnroll4 *This);
      HRESULT (WINAPI *createRequestWStr)(IEnroll4 *This,LONG Flags,LPCWSTR pwszDNName,LPCWSTR pwszUsage,PCRYPT_DATA_BLOB pblobRequest);
      HRESULT (WINAPI *createFileRequestWStr)(IEnroll4 *This,LONG Flags,LPCWSTR pwszDNName,LPCWSTR pwszUsage,LPCWSTR pwszRequestFileName);
      HRESULT (WINAPI *acceptResponseBlob)(IEnroll4 *This,PCRYPT_DATA_BLOB pblobResponse);
      HRESULT (WINAPI *acceptFileResponseWStr)(IEnroll4 *This,LPCWSTR pwszResponseFileName);
      HRESULT (WINAPI *getCertContextFromResponseBlob)(IEnroll4 *This,PCRYPT_DATA_BLOB pblobResponse,PCCERT_CONTEXT *ppCertContext);
      HRESULT (WINAPI *getCertContextFromFileResponseWStr)(IEnroll4 *This,LPCWSTR pwszResponseFileName,PCCERT_CONTEXT *ppCertContext);
      HRESULT (WINAPI *createPFXWStr)(IEnroll4 *This,LPCWSTR pwszPassword,PCRYPT_DATA_BLOB pblobPFX);
      HRESULT (WINAPI *createFilePFXWStr)(IEnroll4 *This,LPCWSTR pwszPassword,LPCWSTR pwszPFXFileName);
      HRESULT (WINAPI *setPendingRequestInfoWStr)(IEnroll4 *This,LONG lRequestID,LPCWSTR pwszCADNS,LPCWSTR pwszCAName,LPCWSTR pwszFriendlyName);
      HRESULT (WINAPI *enumPendingRequestWStr)(IEnroll4 *This,LONG lIndex,LONG lDesiredProperty,LPVOID ppProperty);
      HRESULT (WINAPI *removePendingRequestWStr)(IEnroll4 *This,CRYPT_DATA_BLOB thumbPrintBlob);
      HRESULT (WINAPI *GetKeyLenEx)(IEnroll4 *This,LONG lSizeSpec,LONG lKeySpec,LONG *pdwKeySize);
      HRESULT (WINAPI *InstallPKCS7BlobEx)(IEnroll4 *This,PCRYPT_DATA_BLOB pBlobPKCS7,LONG *plCertInstalled);
      HRESULT (WINAPI *AddCertTypeToRequestWStrEx)(IEnroll4 *This,LONG lType,LPCWSTR pwszOIDOrName,LONG lMajorVersion,WINBOOL fMinorVersion,LONG lMinorVersion);
      HRESULT (WINAPI *getProviderTypeWStr)(IEnroll4 *This,LPCWSTR pwszProvName,LONG *plProvType);
      HRESULT (WINAPI *addBlobPropertyToCertificateWStr)(IEnroll4 *This,LONG lPropertyId,LONG lReserved,PCRYPT_DATA_BLOB pBlobProperty);
      HRESULT (WINAPI *SetSignerCertificate)(IEnroll4 *This,PCCERT_CONTEXT pSignerCert);
      HRESULT (WINAPI *put_ClientId)(IEnroll4 *This,LONG lClientId);
      HRESULT (WINAPI *get_ClientId)(IEnroll4 *This,LONG *plClientId);
      HRESULT (WINAPI *put_IncludeSubjectKeyID)(IEnroll4 *This,WINBOOL fInclude);
      HRESULT (WINAPI *get_IncludeSubjectKeyID)(IEnroll4 *This,WINBOOL *pfInclude);
    END_INTERFACE
  } IEnroll4Vtbl;
  struct IEnroll4 {
    CONST_VTBL struct IEnroll4Vtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IEnroll4_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IEnroll4_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IEnroll4_Release(This) (This)->lpVtbl->Release(This)
#define IEnroll4_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) (This)->lpVtbl->createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)
#define IEnroll4_acceptFilePKCS7WStr(This,wszPKCS7FileName) (This)->lpVtbl->acceptFilePKCS7WStr(This,wszPKCS7FileName)
#define IEnroll4_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) (This)->lpVtbl->createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)
#define IEnroll4_acceptPKCS7Blob(This,pBlobPKCS7) (This)->lpVtbl->acceptPKCS7Blob(This,pBlobPKCS7)
#define IEnroll4_getCertContextFromPKCS7(This,pBlobPKCS7) (This)->lpVtbl->getCertContextFromPKCS7(This,pBlobPKCS7)
#define IEnroll4_getMyStore(This) (This)->lpVtbl->getMyStore(This)
#define IEnroll4_getCAStore(This) (This)->lpVtbl->getCAStore(This)
#define IEnroll4_getROOTHStore(This) (This)->lpVtbl->getROOTHStore(This)
#define IEnroll4_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) (This)->lpVtbl->enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)
#define IEnroll4_enumContainersWStr(This,dwIndex,pbstr) (This)->lpVtbl->enumContainersWStr(This,dwIndex,pbstr)
#define IEnroll4_freeRequestInfoBlob(This,pkcs7OrPkcs10) (This)->lpVtbl->freeRequestInfoBlob(This,pkcs7OrPkcs10)
#define IEnroll4_get_MyStoreNameWStr(This,szwName) (This)->lpVtbl->get_MyStoreNameWStr(This,szwName)
#define IEnroll4_put_MyStoreNameWStr(This,szwName) (This)->lpVtbl->put_MyStoreNameWStr(This,szwName)
#define IEnroll4_get_MyStoreTypeWStr(This,szwType) (This)->lpVtbl->get_MyStoreTypeWStr(This,szwType)
#define IEnroll4_put_MyStoreTypeWStr(This,szwType) (This)->lpVtbl->put_MyStoreTypeWStr(This,szwType)
#define IEnroll4_get_MyStoreFlags(This,pdwFlags) (This)->lpVtbl->get_MyStoreFlags(This,pdwFlags)
#define IEnroll4_put_MyStoreFlags(This,dwFlags) (This)->lpVtbl->put_MyStoreFlags(This,dwFlags)
#define IEnroll4_get_CAStoreNameWStr(This,szwName) (This)->lpVtbl->get_CAStoreNameWStr(This,szwName)
#define IEnroll4_put_CAStoreNameWStr(This,szwName) (This)->lpVtbl->put_CAStoreNameWStr(This,szwName)
#define IEnroll4_get_CAStoreTypeWStr(This,szwType) (This)->lpVtbl->get_CAStoreTypeWStr(This,szwType)
#define IEnroll4_put_CAStoreTypeWStr(This,szwType) (This)->lpVtbl->put_CAStoreTypeWStr(This,szwType)
#define IEnroll4_get_CAStoreFlags(This,pdwFlags) (This)->lpVtbl->get_CAStoreFlags(This,pdwFlags)
#define IEnroll4_put_CAStoreFlags(This,dwFlags) (This)->lpVtbl->put_CAStoreFlags(This,dwFlags)
#define IEnroll4_get_RootStoreNameWStr(This,szwName) (This)->lpVtbl->get_RootStoreNameWStr(This,szwName)
#define IEnroll4_put_RootStoreNameWStr(This,szwName) (This)->lpVtbl->put_RootStoreNameWStr(This,szwName)
#define IEnroll4_get_RootStoreTypeWStr(This,szwType) (This)->lpVtbl->get_RootStoreTypeWStr(This,szwType)
#define IEnroll4_put_RootStoreTypeWStr(This,szwType) (This)->lpVtbl->put_RootStoreTypeWStr(This,szwType)
#define IEnroll4_get_RootStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RootStoreFlags(This,pdwFlags)
#define IEnroll4_put_RootStoreFlags(This,dwFlags) (This)->lpVtbl->put_RootStoreFlags(This,dwFlags)
#define IEnroll4_get_RequestStoreNameWStr(This,szwName) (This)->lpVtbl->get_RequestStoreNameWStr(This,szwName)
#define IEnroll4_put_RequestStoreNameWStr(This,szwName) (This)->lpVtbl->put_RequestStoreNameWStr(This,szwName)
#define IEnroll4_get_RequestStoreTypeWStr(This,szwType) (This)->lpVtbl->get_RequestStoreTypeWStr(This,szwType)
#define IEnroll4_put_RequestStoreTypeWStr(This,szwType) (This)->lpVtbl->put_RequestStoreTypeWStr(This,szwType)
#define IEnroll4_get_RequestStoreFlags(This,pdwFlags) (This)->lpVtbl->get_RequestStoreFlags(This,pdwFlags)
#define IEnroll4_put_RequestStoreFlags(This,dwFlags) (This)->lpVtbl->put_RequestStoreFlags(This,dwFlags)
#define IEnroll4_get_ContainerNameWStr(This,szwContainer) (This)->lpVtbl->get_ContainerNameWStr(This,szwContainer)
#define IEnroll4_put_ContainerNameWStr(This,szwContainer) (This)->lpVtbl->put_ContainerNameWStr(This,szwContainer)
#define IEnroll4_get_ProviderNameWStr(This,szwProvider) (This)->lpVtbl->get_ProviderNameWStr(This,szwProvider)
#define IEnroll4_put_ProviderNameWStr(This,szwProvider) (This)->lpVtbl->put_ProviderNameWStr(This,szwProvider)
#define IEnroll4_get_ProviderType(This,pdwType) (This)->lpVtbl->get_ProviderType(This,pdwType)
#define IEnroll4_put_ProviderType(This,dwType) (This)->lpVtbl->put_ProviderType(This,dwType)
#define IEnroll4_get_KeySpec(This,pdw) (This)->lpVtbl->get_KeySpec(This,pdw)
#define IEnroll4_put_KeySpec(This,dw) (This)->lpVtbl->put_KeySpec(This,dw)
#define IEnroll4_get_ProviderFlags(This,pdwFlags) (This)->lpVtbl->get_ProviderFlags(This,pdwFlags)
#define IEnroll4_put_ProviderFlags(This,dwFlags) (This)->lpVtbl->put_ProviderFlags(This,dwFlags)
#define IEnroll4_get_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->get_UseExistingKeySet(This,fUseExistingKeys)
#define IEnroll4_put_UseExistingKeySet(This,fUseExistingKeys) (This)->lpVtbl->put_UseExistingKeySet(This,fUseExistingKeys)
#define IEnroll4_get_GenKeyFlags(This,pdwFlags) (This)->lpVtbl->get_GenKeyFlags(This,pdwFlags)
#define IEnroll4_put_GenKeyFlags(This,dwFlags) (This)->lpVtbl->put_GenKeyFlags(This,dwFlags)
#define IEnroll4_get_DeleteRequestCert(This,fDelete) (This)->lpVtbl->get_DeleteRequestCert(This,fDelete)
#define IEnroll4_put_DeleteRequestCert(This,fDelete) (This)->lpVtbl->put_DeleteRequestCert(This,fDelete)
#define IEnroll4_get_WriteCertToUserDS(This,fBool) (This)->lpVtbl->get_WriteCertToUserDS(This,fBool)
#define IEnroll4_put_WriteCertToUserDS(This,fBool) (This)->lpVtbl->put_WriteCertToUserDS(This,fBool)
#define IEnroll4_get_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->get_EnableT61DNEncoding(This,fBool)
#define IEnroll4_put_EnableT61DNEncoding(This,fBool) (This)->lpVtbl->put_EnableT61DNEncoding(This,fBool)
#define IEnroll4_get_WriteCertToCSP(This,fBool) (This)->lpVtbl->get_WriteCertToCSP(This,fBool)
#define IEnroll4_put_WriteCertToCSP(This,fBool) (This)->lpVtbl->put_WriteCertToCSP(This,fBool)
#define IEnroll4_get_SPCFileNameWStr(This,szw) (This)->lpVtbl->get_SPCFileNameWStr(This,szw)
#define IEnroll4_put_SPCFileNameWStr(This,szw) (This)->lpVtbl->put_SPCFileNameWStr(This,szw)
#define IEnroll4_get_PVKFileNameWStr(This,szw) (This)->lpVtbl->get_PVKFileNameWStr(This,szw)
#define IEnroll4_put_PVKFileNameWStr(This,szw) (This)->lpVtbl->put_PVKFileNameWStr(This,szw)
#define IEnroll4_get_HashAlgorithmWStr(This,szw) (This)->lpVtbl->get_HashAlgorithmWStr(This,szw)
#define IEnroll4_put_HashAlgorithmWStr(This,szw) (This)->lpVtbl->put_HashAlgorithmWStr(This,szw)
#define IEnroll4_get_RenewalCertificate(This,ppCertContext) (This)->lpVtbl->get_RenewalCertificate(This,ppCertContext)
#define IEnroll4_put_RenewalCertificate(This,pCertContext) (This)->lpVtbl->put_RenewalCertificate(This,pCertContext)
#define IEnroll4_AddCertTypeToRequestWStr(This,szw) (This)->lpVtbl->AddCertTypeToRequestWStr(This,szw)
#define IEnroll4_AddNameValuePairToSignatureWStr(This,Name,Value) (This)->lpVtbl->AddNameValuePairToSignatureWStr(This,Name,Value)
#define IEnroll4_AddExtensionsToRequest(This,pCertExtensions) (This)->lpVtbl->AddExtensionsToRequest(This,pCertExtensions)
#define IEnroll4_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) (This)->lpVtbl->AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)
#define IEnroll4_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) (This)->lpVtbl->CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)
#define IEnroll4_InstallPKCS7Blob(This,pBlobPKCS7) (This)->lpVtbl->InstallPKCS7Blob(This,pBlobPKCS7)
#define IEnroll4_Reset(This) (This)->lpVtbl->Reset(This)
#define IEnroll4_GetSupportedKeySpec(This,pdwKeySpec) (This)->lpVtbl->GetSupportedKeySpec(This,pdwKeySpec)
#define IEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize) (This)->lpVtbl->GetKeyLen(This,fMin,fExchange,pdwKeySize)
#define IEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID) (This)->lpVtbl->EnumAlgs(This,dwIndex,algClass,pdwAlgID)
#define IEnroll4_GetAlgNameWStr(This,algID,ppwsz) (This)->lpVtbl->GetAlgNameWStr(This,algID,ppwsz)
#define IEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define IEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) (This)->lpVtbl->get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)
#define IEnroll4_put_HashAlgID(This,hashAlgID) (This)->lpVtbl->put_HashAlgID(This,hashAlgID)
#define IEnroll4_get_HashAlgID(This,hashAlgID) (This)->lpVtbl->get_HashAlgID(This,hashAlgID)
#define IEnroll4_SetHStoreMy(This,hStore) (This)->lpVtbl->SetHStoreMy(This,hStore)
#define IEnroll4_SetHStoreCA(This,hStore) (This)->lpVtbl->SetHStoreCA(This,hStore)
#define IEnroll4_SetHStoreROOT(This,hStore) (This)->lpVtbl->SetHStoreROOT(This,hStore)
#define IEnroll4_SetHStoreRequest(This,hStore) (This)->lpVtbl->SetHStoreRequest(This,hStore)
#define IEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define IEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) (This)->lpVtbl->get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)
#define IEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#define IEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) (This)->lpVtbl->get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)
#define IEnroll4_put_ThumbPrintWStr(This,thumbPrintBlob) (This)->lpVtbl->put_ThumbPrintWStr(This,thumbPrintBlob)
#define IEnroll4_get_ThumbPrintWStr(This,thumbPrintBlob) (This)->lpVtbl->get_ThumbPrintWStr(This,thumbPrintBlob)
#define IEnroll4_SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert) (This)->lpVtbl->SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert)
#define IEnroll4_GetPrivateKeyArchiveCertificate(This) (This)->lpVtbl->GetPrivateKeyArchiveCertificate(This)
#define IEnroll4_binaryBlobToString(This,Flags,pblobBinary,ppwszString) (This)->lpVtbl->binaryBlobToString(This,Flags,pblobBinary,ppwszString)
#define IEnroll4_stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags) (This)->lpVtbl->stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags)
#define IEnroll4_addExtensionToRequestWStr(This,Flags,pwszName,pblobValue) (This)->lpVtbl->addExtensionToRequestWStr(This,Flags,pwszName,pblobValue)
#define IEnroll4_addAttributeToRequestWStr(This,Flags,pwszName,pblobValue) (This)->lpVtbl->addAttributeToRequestWStr(This,Flags,pwszName,pblobValue)
#define IEnroll4_addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue) (This)->lpVtbl->addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue)
#define IEnroll4_resetExtensions(This) (This)->lpVtbl->resetExtensions(This)
#define IEnroll4_resetAttributes(This) (This)->lpVtbl->resetAttributes(This)
#define IEnroll4_createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest) (This)->lpVtbl->createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest)
#define IEnroll4_createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName) (This)->lpVtbl->createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName)
#define IEnroll4_acceptResponseBlob(This,pblobResponse) (This)->lpVtbl->acceptResponseBlob(This,pblobResponse)
#define IEnroll4_acceptFileResponseWStr(This,pwszResponseFileName) (This)->lpVtbl->acceptFileResponseWStr(This,pwszResponseFileName)
#define IEnroll4_getCertContextFromResponseBlob(This,pblobResponse,ppCertContext) (This)->lpVtbl->getCertContextFromResponseBlob(This,pblobResponse,ppCertContext)
#define IEnroll4_getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext) (This)->lpVtbl->getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext)
#define IEnroll4_createPFXWStr(This,pwszPassword,pblobPFX) (This)->lpVtbl->createPFXWStr(This,pwszPassword,pblobPFX)
#define IEnroll4_createFilePFXWStr(This,pwszPassword,pwszPFXFileName) (This)->lpVtbl->createFilePFXWStr(This,pwszPassword,pwszPFXFileName)
#define IEnroll4_setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName) (This)->lpVtbl->setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName)
#define IEnroll4_enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty) (This)->lpVtbl->enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty)
#define IEnroll4_removePendingRequestWStr(This,thumbPrintBlob) (This)->lpVtbl->removePendingRequestWStr(This,thumbPrintBlob)
#define IEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize) (This)->lpVtbl->GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)
#define IEnroll4_InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled) (This)->lpVtbl->InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled)
#define IEnroll4_AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion) (This)->lpVtbl->AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)
#define IEnroll4_getProviderTypeWStr(This,pwszProvName,plProvType) (This)->lpVtbl->getProviderTypeWStr(This,pwszProvName,plProvType)
#define IEnroll4_addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty) (This)->lpVtbl->addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty)
#define IEnroll4_SetSignerCertificate(This,pSignerCert) (This)->lpVtbl->SetSignerCertificate(This,pSignerCert)
#define IEnroll4_put_ClientId(This,lClientId) (This)->lpVtbl->put_ClientId(This,lClientId)
#define IEnroll4_get_ClientId(This,plClientId) (This)->lpVtbl->get_ClientId(This,plClientId)
#define IEnroll4_put_IncludeSubjectKeyID(This,fInclude) (This)->lpVtbl->put_IncludeSubjectKeyID(This,fInclude)
#define IEnroll4_get_IncludeSubjectKeyID(This,pfInclude) (This)->lpVtbl->get_IncludeSubjectKeyID(This,pfInclude)
#endif
#endif
  HRESULT WINAPI IEnroll4_put_ThumbPrintWStr_Proxy(IEnroll4 *This,CRYPT_DATA_BLOB thumbPrintBlob);
  void __RPC_STUB IEnroll4_put_ThumbPrintWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_get_ThumbPrintWStr_Proxy(IEnroll4 *This,PCRYPT_DATA_BLOB thumbPrintBlob);
  void __RPC_STUB IEnroll4_get_ThumbPrintWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_SetPrivateKeyArchiveCertificate_Proxy(IEnroll4 *This,PCCERT_CONTEXT pPrivateKeyArchiveCert);
  void __RPC_STUB IEnroll4_SetPrivateKeyArchiveCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  PCCERT_CONTEXT WINAPI IEnroll4_GetPrivateKeyArchiveCertificate_Proxy(IEnroll4 *This);
  void __RPC_STUB IEnroll4_GetPrivateKeyArchiveCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_binaryBlobToString_Proxy(IEnroll4 *This,LONG Flags,PCRYPT_DATA_BLOB pblobBinary,LPWSTR *ppwszString);
  void __RPC_STUB IEnroll4_binaryBlobToString_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_stringToBinaryBlob_Proxy(IEnroll4 *This,LONG Flags,LPCWSTR pwszString,PCRYPT_DATA_BLOB pblobBinary,LONG *pdwSkip,LONG *pdwFlags);
  void __RPC_STUB IEnroll4_stringToBinaryBlob_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_addExtensionToRequestWStr_Proxy(IEnroll4 *This,LONG Flags,LPCWSTR pwszName,PCRYPT_DATA_BLOB pblobValue);
  void __RPC_STUB IEnroll4_addExtensionToRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_addAttributeToRequestWStr_Proxy(IEnroll4 *This,LONG Flags,LPCWSTR pwszName,PCRYPT_DATA_BLOB pblobValue);
  void __RPC_STUB IEnroll4_addAttributeToRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_addNameValuePairToRequestWStr_Proxy(IEnroll4 *This,LONG Flags,LPCWSTR pwszName,LPCWSTR pwszValue);
  void __RPC_STUB IEnroll4_addNameValuePairToRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_resetExtensions_Proxy(IEnroll4 *This);
  void __RPC_STUB IEnroll4_resetExtensions_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_resetAttributes_Proxy(IEnroll4 *This);
  void __RPC_STUB IEnroll4_resetAttributes_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_createRequestWStr_Proxy(IEnroll4 *This,LONG Flags,LPCWSTR pwszDNName,LPCWSTR pwszUsage,PCRYPT_DATA_BLOB pblobRequest);
  void __RPC_STUB IEnroll4_createRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_createFileRequestWStr_Proxy(IEnroll4 *This,LONG Flags,LPCWSTR pwszDNName,LPCWSTR pwszUsage,LPCWSTR pwszRequestFileName);
  void __RPC_STUB IEnroll4_createFileRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_acceptResponseBlob_Proxy(IEnroll4 *This,PCRYPT_DATA_BLOB pblobResponse);
  void __RPC_STUB IEnroll4_acceptResponseBlob_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_acceptFileResponseWStr_Proxy(IEnroll4 *This,LPCWSTR pwszResponseFileName);
  void __RPC_STUB IEnroll4_acceptFileResponseWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_getCertContextFromResponseBlob_Proxy(IEnroll4 *This,PCRYPT_DATA_BLOB pblobResponse,PCCERT_CONTEXT *ppCertContext);
  void __RPC_STUB IEnroll4_getCertContextFromResponseBlob_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_getCertContextFromFileResponseWStr_Proxy(IEnroll4 *This,LPCWSTR pwszResponseFileName,PCCERT_CONTEXT *ppCertContext);
  void __RPC_STUB IEnroll4_getCertContextFromFileResponseWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_createPFXWStr_Proxy(IEnroll4 *This,LPCWSTR pwszPassword,PCRYPT_DATA_BLOB pblobPFX);
  void __RPC_STUB IEnroll4_createPFXWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_createFilePFXWStr_Proxy(IEnroll4 *This,LPCWSTR pwszPassword,LPCWSTR pwszPFXFileName);
  void __RPC_STUB IEnroll4_createFilePFXWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_setPendingRequestInfoWStr_Proxy(IEnroll4 *This,LONG lRequestID,LPCWSTR pwszCADNS,LPCWSTR pwszCAName,LPCWSTR pwszFriendlyName);
  void __RPC_STUB IEnroll4_setPendingRequestInfoWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_enumPendingRequestWStr_Proxy(IEnroll4 *This,LONG lIndex,LONG lDesiredProperty,LPVOID ppProperty);
  void __RPC_STUB IEnroll4_enumPendingRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_removePendingRequestWStr_Proxy(IEnroll4 *This,CRYPT_DATA_BLOB thumbPrintBlob);
  void __RPC_STUB IEnroll4_removePendingRequestWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_GetKeyLenEx_Proxy(IEnroll4 *This,LONG lSizeSpec,LONG lKeySpec,LONG *pdwKeySize);
  void __RPC_STUB IEnroll4_GetKeyLenEx_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_InstallPKCS7BlobEx_Proxy(IEnroll4 *This,PCRYPT_DATA_BLOB pBlobPKCS7,LONG *plCertInstalled);
  void __RPC_STUB IEnroll4_InstallPKCS7BlobEx_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_AddCertTypeToRequestWStrEx_Proxy(IEnroll4 *This,LONG lType,LPCWSTR pwszOIDOrName,LONG lMajorVersion,WINBOOL fMinorVersion,LONG lMinorVersion);
  void __RPC_STUB IEnroll4_AddCertTypeToRequestWStrEx_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_getProviderTypeWStr_Proxy(IEnroll4 *This,LPCWSTR pwszProvName,LONG *plProvType);
  void __RPC_STUB IEnroll4_getProviderTypeWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_addBlobPropertyToCertificateWStr_Proxy(IEnroll4 *This,LONG lPropertyId,LONG lReserved,PCRYPT_DATA_BLOB pBlobProperty);
  void __RPC_STUB IEnroll4_addBlobPropertyToCertificateWStr_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_SetSignerCertificate_Proxy(IEnroll4 *This,PCCERT_CONTEXT pSignerCert);
  void __RPC_STUB IEnroll4_SetSignerCertificate_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_put_ClientId_Proxy(IEnroll4 *This,LONG lClientId);
  void __RPC_STUB IEnroll4_put_ClientId_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_get_ClientId_Proxy(IEnroll4 *This,LONG *plClientId);
  void __RPC_STUB IEnroll4_get_ClientId_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_put_IncludeSubjectKeyID_Proxy(IEnroll4 *This,WINBOOL fInclude);
  void __RPC_STUB IEnroll4_put_IncludeSubjectKeyID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IEnroll4_get_IncludeSubjectKeyID_Proxy(IEnroll4 *This,WINBOOL *pfInclude);
  void __RPC_STUB IEnroll4_get_IncludeSubjectKeyID_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifndef __XENROLLLib_LIBRARY_DEFINED__
#define __XENROLLLib_LIBRARY_DEFINED__
  extern const IID LIBID_XENROLLLib;
  extern const CLSID CLSID_CEnroll2;
  extern const CLSID CLSID_CEnroll;
#ifdef __cplusplus
}
  class CEnroll2;
  class CEnroll;
  extern "C" {
#endif
#endif

  IEnroll *WINAPI PIEnrollGetNoCOM(void);
  IEnroll2 *WINAPI PIEnroll2GetNoCOM(void);
  IEnroll4 *WINAPI PIEnroll4GetNoCOM(void);

#define CRYPT_ENUM_ALL_PROVIDERS 0x1
#define XEPR_ENUM_FIRST -1
#define XEPR_CADNS 0x01
#define XEPR_CANAME 0x02
#define XEPR_CAFRIENDLYNAME 0x03
#define XEPR_REQUESTID 0x04
#define XEPR_DATE 0x05
#define XEPR_TEMPLATENAME 0x06
#define XEPR_VERSION 0x07
#define XEPR_HASH 0x08
#define XEPR_V1TEMPLATENAME 0x09
#define XEPR_V2TEMPLATEOID 0x10
#define XECR_PKCS10_V2_0 0x1
#define XECR_PKCS7 0x2
#define XECR_CMC 0x3
#define XECR_PKCS10_V1_5 0x4
#define XEKL_KEYSIZE_MIN 0x1
#define XEKL_KEYSIZE_MAX 0x2
#define XEKL_KEYSIZE_INC 0x3
#define XEKL_KEYSIZE_DEFAULT 0x4
#define XEKL_KEYSPEC_KEYX 0x1
#define XEKL_KEYSPEC_SIG 0x2
#define XECT_EXTENSION_V1 0x1
#define XECT_EXTENSION_V2 0x2
#define XECP_STRING_PROPERTY 0x1
#define XECI_DISABLE 0x0
#define XECI_XENROLL 0x1
#define XECI_AUTOENROLL 0x2
#define XECI_REQWIZARD 0x3
#define XECI_CERTREQ 0x4

  extern RPC_IF_HANDLE __MIDL_itf_xenroll_0269_v0_0_c_ifspec;
  extern RPC_IF_HANDLE __MIDL_itf_xenroll_0269_v0_0_s_ifspec;

  ULONG __RPC_API BSTR_UserSize(ULONG *,ULONG,BSTR *);
  unsigned char *__RPC_API BSTR_UserMarshal(ULONG *,unsigned char *,BSTR *);
  unsigned char *__RPC_API BSTR_UserUnmarshal(ULONG *,unsigned char *,BSTR *);
  void __RPC_API BSTR_UserFree(ULONG *,BSTR *);
  ULONG __RPC_API VARIANT_UserSize(ULONG *,ULONG,VARIANT *);
  unsigned char *__RPC_API VARIANT_UserMarshal(ULONG *,unsigned char *,VARIANT *);
  unsigned char *__RPC_API VARIANT_UserUnmarshal(ULONG *,unsigned char *,VARIANT *);
  void __RPC_API VARIANT_UserFree(ULONG *,VARIANT *);

#ifdef __cplusplus
}
#endif
#endif
                                                                                                       usr/share/mingw-w64/include/xinput.h                                                                0100644 0000000 0000000 00000017416 12404413014 016044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * The Wine project - Xinput Joystick Library
 * Copyright 2008 Andrew Fenn
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
 */

#ifndef __WINE_XINPUT_H
#define __WINE_XINPUT_H

#include <windef.h>

/*
 * Bitmasks for the joysticks buttons, determines what has
 * been pressed on the joystick, these need to be mapped
 * to whatever device you're using instead of an xbox 360
 * joystick
 */

#define XINPUT_GAMEPAD_DPAD_UP          0x0001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x0002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x0004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x0008
#define XINPUT_GAMEPAD_START            0x0010
#define XINPUT_GAMEPAD_BACK             0x0020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x0040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x0080
#define XINPUT_GAMEPAD_LEFT_SHOULDER    0x0100
#define XINPUT_GAMEPAD_RIGHT_SHOULDER   0x0200
#define XINPUT_GAMEPAD_A                0x1000
#define XINPUT_GAMEPAD_B                0x2000
#define XINPUT_GAMEPAD_X                0x4000
#define XINPUT_GAMEPAD_Y                0x8000

/*
 * Defines the flags used to determine if the user is pushing
 * down on a button, not holding a button, etc
 */

#define XINPUT_KEYSTROKE_KEYDOWN        0x0001
#define XINPUT_KEYSTROKE_KEYUP          0x0002
#define XINPUT_KEYSTROKE_REPEAT         0x0004

/*
 * Defines the codes which are returned by XInputGetKeystroke
 */

#define VK_PAD_A                        0x5800
#define VK_PAD_B                        0x5801
#define VK_PAD_X                        0x5802
#define VK_PAD_Y                        0x5803
#define VK_PAD_RSHOULDER                0x5804
#define VK_PAD_LSHOULDER                0x5805
#define VK_PAD_LTRIGGER                 0x5806
#define VK_PAD_RTRIGGER                 0x5807
#define VK_PAD_DPAD_UP                  0x5810
#define VK_PAD_DPAD_DOWN                0x5811
#define VK_PAD_DPAD_LEFT                0x5812
#define VK_PAD_DPAD_RIGHT               0x5813
#define VK_PAD_START                    0x5814
#define VK_PAD_BACK                     0x5815
#define VK_PAD_LTHUMB_PRESS             0x5816
#define VK_PAD_RTHUMB_PRESS             0x5817
#define VK_PAD_LTHUMB_UP                0x5820
#define VK_PAD_LTHUMB_DOWN              0x5821
#define VK_PAD_LTHUMB_RIGHT             0x5822
#define VK_PAD_LTHUMB_LEFT              0x5823
#define VK_PAD_LTHUMB_UPLEFT            0x5824
#define VK_PAD_LTHUMB_UPRIGHT           0x5825
#define VK_PAD_LTHUMB_DOWNRIGHT         0x5826
#define VK_PAD_LTHUMB_DOWNLEFT          0x5827
#define VK_PAD_RTHUMB_UP                0x5830
#define VK_PAD_RTHUMB_DOWN              0x5831
#define VK_PAD_RTHUMB_RIGHT             0x5832
#define VK_PAD_RTHUMB_LEFT              0x5833
#define VK_PAD_RTHUMB_UPLEFT            0x5834
#define VK_PAD_RTHUMB_UPRIGHT           0x5835
#define VK_PAD_RTHUMB_DOWNRIGHT         0x5836
#define VK_PAD_RTHUMB_DOWNLEFT          0x5837

/*
 * Deadzones are for analogue joystick controls on the joypad
 * which determine when input should be assumed to be in the
 * middle of the pad. This is a threshold to stop a joypad
 * controlling the game when the player isn't touching the
 * controls.
 */

#define XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE  7849
#define XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE 8689
#define XINPUT_GAMEPAD_TRIGGER_THRESHOLD    30


/*
 * Defines what type of abilities the type of joystick has
 * DEVTYPE_GAMEPAD is available for all joysticks, however
 * there may be more specific identifiers for other joysticks
 * which are being used.
 */

#define XINPUT_DEVTYPE_GAMEPAD          0x01
#define XINPUT_DEVSUBTYPE_GAMEPAD       0x01
#define XINPUT_DEVSUBTYPE_WHEEL         0x02
#define XINPUT_DEVSUBTYPE_ARCADE_STICK  0x03
#define XINPUT_DEVSUBTYPE_FLIGHT_SICK   0x04
#define XINPUT_DEVSUBTYPE_DANCE_PAD     0x05
#define XINPUT_DEVSUBTYPE_GUITAR        0x06
#define XINPUT_DEVSUBTYPE_DRUM_KIT      0x08

/*
 * These are used with the XInputGetCapabilities function to
 * determine the abilities to the joystick which has been
 * plugged in.
 */

#define XINPUT_CAPS_VOICE_SUPPORTED     0x0004
#define XINPUT_FLAG_GAMEPAD             0x00000001

/*
 * Defines the status of the battery if one is used in the
 * attached joystick. The first two define if the joystick
 * supports a battery. Disconnected means that the joystick
 * isn't connected. Wired shows that the joystick is a wired
 * joystick.
 */

#define BATTERY_DEVTYPE_GAMEPAD         0x00
#define BATTERY_DEVTYPE_HEADSET         0x01
#define BATTERY_TYPE_DISCONNECTED       0x00
#define BATTERY_TYPE_WIRED              0x01
#define BATTERY_TYPE_ALKALINE           0x02
#define BATTERY_TYPE_NIMH               0x03
#define BATTERY_TYPE_UNKNOWN            0xFF
#define BATTERY_LEVEL_EMPTY             0x00
#define BATTERY_LEVEL_LOW               0x01
#define BATTERY_LEVEL_MEDIUM            0x02
#define BATTERY_LEVEL_FULL              0x03

/*
 * How many joysticks can be used with this library. Games that
 * use the xinput library will not go over this number.
 */

#define XUSER_MAX_COUNT                 4
#define XUSER_INDEX_ANY                 0x000000FF

/*
 * Defines the structure of an xbox 360 joystick.
 */

typedef struct _XINPUT_GAMEPAD {
    WORD wButtons;
    BYTE bLeftTrigger;
    BYTE bRightTrigger;
    SHORT sThumbLX;
    SHORT sThumbLY;
    SHORT sThumbRX;
    SHORT sThumbRY;
} XINPUT_GAMEPAD, *PXINPUT_GAMEPAD;

typedef struct _XINPUT_STATE {
    DWORD dwPacketNumber;
    XINPUT_GAMEPAD Gamepad;
} XINPUT_STATE, *PXINPUT_STATE;

/*
 * Defines the structure of how much vibration is set on both the
 * right and left motors in a joystick. If you're not using a 360
 * joystick you will have to map these to your device.
 */

typedef struct _XINPUT_VIBRATION {
    WORD wLeftMotorSpeed;
    WORD wRightMotorSpeed;
} XINPUT_VIBRATION, *PXINPUT_VIBRATION;

/*
 * Defines the structure for what kind of abilities the joystick has
 * such abilities are things such as if the joystick has the ability
 * to send and receive audio, if the joystick is in fact a driving
 * wheel or perhaps if the joystick is some kind of dance pad or
 * guitar.
 */

typedef struct _XINPUT_CAPABILITIES {
    BYTE Type;
    BYTE SubType;
    WORD Flags;
    XINPUT_GAMEPAD Gamepad;
    XINPUT_VIBRATION Vibration;
} XINPUT_CAPABILITIES, *PXINPUT_CAPABILITIES;

/*
 * Defines the structure for a joystick input event which is
 * retrieved using the function XInputGetKeystroke
 */
typedef struct _XINPUT_KEYSTROKE {
    WORD VirtualKey;
    WCHAR Unicode;
    WORD Flags;
    BYTE UserIndex;
    BYTE HidCode;
} XINPUT_KEYSTROKE, *PXINPUT_KEYSTROKE;

typedef struct _XINPUT_BATTERY_INFORMATION
{
    BYTE BatteryType;
    BYTE BatteryLevel;
} XINPUT_BATTERY_INFORMATION, *PXINPUT_BATTERY_INFORMATION;

#ifdef __cplusplus
extern "C" {
#endif

void WINAPI XInputEnable(WINBOOL);
DWORD WINAPI XInputSetState(DWORD, XINPUT_VIBRATION*);
DWORD WINAPI XInputGetState(DWORD, XINPUT_STATE*);
DWORD WINAPI XInputGetKeystroke(DWORD, DWORD, PXINPUT_KEYSTROKE);
DWORD WINAPI XInputGetCapabilities(DWORD, DWORD, XINPUT_CAPABILITIES*);
DWORD WINAPI XInputGetDSoundAudioDeviceGuids(DWORD, GUID*, GUID*);
DWORD WINAPI XInputGetBatteryInformation(DWORD, BYTE, XINPUT_BATTERY_INFORMATION*);

#ifdef __cplusplus
}
#endif

#endif /* __WINE_XINPUT_H */
                                                                                                                                                                                                                                                  usr/share/mingw-w64/include/xlocinfo.h                                                              0100644 0000000 0000000 00000006003 12404413015 016325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#include <yvals.h>

#pragma pack(push,_CRT_PACKING)

_C_STD_BEGIN
_C_LIB_DECL

#define _XA 0x100
#define _XS 0x000
#define _BB _CONTROL
#define _CN _SPACE
#define _DI _DIGIT
#define _LO _LOWER
#define _PU _PUNCT
#define _SP _BLANK
#define _UP _UPPER
#define _XD _HEX

#define _X_ALL LC_ALL
#define _X_COLLATE LC_COLLATE
#define _X_CTYPE LC_CTYPE
#define _X_MONETARY LC_MONETARY
#define _X_NUMERIC LC_NUMERIC
#define _X_TIME LC_TIME
#define _X_MAX LC_MAX
#define _X_MESSAGES 6
#define _NCAT 7

#define _CATMASK(n) ((1 << (n)) >> 1)
#define _M_COLLATE _CATMASK(_X_COLLATE)
#define _M_CTYPE _CATMASK(_X_CTYPE)
#define _M_MONETARY _CATMASK(_X_MONETARY)
#define _M_NUMERIC _CATMASK(_X_NUMERIC)
#define _M_TIME _CATMASK(_X_TIME)
#define _M_MESSAGES _CATMASK(_X_MESSAGES)
#define _M_ALL (_CATMASK(_NCAT) - 1)

typedef struct _Collvec {
  unsigned long _Hand;
  unsigned int _Page;
} _Collvec;

typedef struct _Ctypevec {
  unsigned long _Hand;
  unsigned int _Page;
  const short *_Table;
  int _Delfl;
} _Ctypevec;

typedef struct _Cvtvec {
  unsigned long _Hand;
  unsigned int _Page;
} _Cvtvec;

_CRTIMP _Collvec __cdecl _Getcoll();
_CRTIMP _Ctypevec __cdecl _Getctype();
_CRTIMP _Cvtvec __cdecl _Getcvt();
_CRTIMP int __cdecl _Getdateorder();
_CRTIMP int __cdecl _Mbrtowc(wchar_t *,const char *,size_t,mbstate_t *,const _Cvtvec *);
_CRTIMP float __cdecl _Stof(const char *,char **,long);
_CRTIMP double __cdecl _Stod(const char *,char **,long);
_CRTIMP long double __cdecl _Stold(const char *,char **,long);
_CRTIMP int __cdecl _Strcoll(const char *,const char *,const char *,const char *,const _Collvec *);
_CRTIMP size_t __cdecl _Strxfrm(char *_String1,char *_End1,const char *,const char *,const _Collvec *);
_CRTIMP int __cdecl _Tolower(int,const _Ctypevec *);
_CRTIMP int __cdecl _Toupper(int,const _Ctypevec *);
_CRTIMP int __cdecl _Wcrtomb(char *,wchar_t,mbstate_t *,const _Cvtvec *);
_CRTIMP int __cdecl _Wcscoll(const wchar_t *,const wchar_t *,const wchar_t *,const wchar_t *,const _Collvec *);
_CRTIMP size_t __cdecl _Wcsxfrm(wchar_t *_String1,wchar_t *_End1,const wchar_t *,const wchar_t *,const _Collvec *);
_CRTIMP short __cdecl _Getwctype(wchar_t,const _Ctypevec *);
_CRTIMP const wchar_t *__cdecl _Getwctypes(const wchar_t *,const wchar_t *,short*,const _Ctypevec*);
_CRTIMP wchar_t __cdecl _Towlower(wchar_t,const _Ctypevec *);
_CRTIMP wchar_t __cdecl _Towupper(wchar_t,const _Ctypevec *);
_END_C_LIB_DECL
_C_STD_END

_C_LIB_DECL
_CRTIMP void *__cdecl _Gettnames();
_CRTIMP char *__cdecl _Getdays();
_CRTIMP char *__cdecl _Getmonths();
_CRTIMP size_t __cdecl _Strftime(char *,size_t _Maxsize,const char *,const struct tm *,void *);
_END_C_LIB_DECL

_C_LIB_DECL
_locale_t __cdecl _GetLocaleForCP(unsigned int);
_END_C_LIB_DECL

#pragma pack(pop)
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/mingw-w64/include/xmath.h                                                                 0100644 0000000 0000000 00000006135 12404413015 015633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#include <ymath.h>

_C_STD_BEGIN

#define _DBIAS 0x3fe
#define _DOFF 4
#define _FBIAS 0x7e
#define _FOFF 7
#define _FRND 1

#define _D0 3
#define _D1 2
#define _D2 1
#define _D3 0
#define _DLONG 0
#define _LBIAS 0x3fe
#define _LOFF 4

#define _DFRAC ((unsigned short)((1 << _DOFF) - 1))
#define _DMASK ((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX ((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN ((unsigned short)0x8000)
#define DSIGN(x) (((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP (int)(_DMAX *900L / 1000)
#define HUGE_RAD 2.73e9
#define SAFE_EXP ((unsigned short)(_DMAX >> 1))

#define _FFRAC ((unsigned short)((1 << _FOFF) - 1))
#define _FMASK ((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX ((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN ((unsigned short)0x8000)
#define FSIGN(x) (((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP (int)(_FMAX *900L / 1000)
#define FHUGE_RAD 31.8
#define FSAFE_EXP ((unsigned short)(_FMAX >> 1))

#define _F0 1
#define _F1 0

#define _LFRAC ((unsigned short)(-1))
#define _LMASK ((unsigned short)0x7fff)
#define _LMAX ((unsigned short)0x7fff)
#define _LSIGN ((unsigned short)0x8000)
#define LSIGN(x) (((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP (int)(_LMAX *900L / 1000)
#define LHUGE_RAD 2.73e9
#define LSAFE_EXP ((unsigned short)(_LMAX >> 1))

#define _L0 3
#define _L1 2
#define _L2 1
#define _L3 0
#define _L4 xxx

#define FINITE _FINITE
#define INF _INFCODE
#define NAN _NANCODE

#define FL_ERR 0
#define FL_DEC 1
#define FL_HEX 2
#define FL_INF 3
#define FL_NAN 4
#define FL_NEG 8

_C_LIB_DECL

_CRTIMP int __cdecl _Stopfx(const char **,char **);
_CRTIMP int __cdecl _Stoflt(const char *,const char *,char **,long[],int);
_CRTIMP int __cdecl _Stoxflt(const char *,const char *,char **,long[],int);
_CRTIMP int __cdecl _WStopfx(const wchar_t **,wchar_t **);
_CRTIMP int __cdecl _WStoflt(const wchar_t *,const wchar_t *,wchar_t **,long[],int);
_CRTIMP int __cdecl _WStoxflt(const wchar_t *,const wchar_t *,wchar_t **,long[],int);
_CRTIMP short __cdecl _Dnorm(unsigned short *);
_CRTIMP short __cdecl _Dscale(double *,long);
_CRTIMP short __cdecl _Dunscale(short *,double *);
_CRTIMP double __cdecl _Poly(double,const double *,int);

extern _CRTIMP _Dconst _Eps,_Rteps;
extern _CRTIMP double _Xbig;

_CRTIMP short __cdecl _FDnorm(unsigned short *);
_CRTIMP short __cdecl _FDscale(float *,long);
_CRTIMP short __cdecl _FDunscale(short *,float *);

extern _CRTIMP _Dconst _FEps,_FRteps;
extern _CRTIMP float _FXbig;

_CRTIMP short __cdecl _LDnorm(unsigned short *);
_CRTIMP short __cdecl _LDscale(long double *,long);
_CRTIMP short __cdecl _LDunscale(short *,long double *);
_CRTIMP long double __cdecl _LPoly(long double,const long double *,int);

extern _CRTIMP _Dconst _LEps,_LRteps;
extern _CRTIMP long double _LXbig;
_END_C_LIB_DECL
_C_STD_END
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/mingw-w64/include/xmldomdid.h                                                             0100644 0000000 0000000 00000024635 12404413015 016500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __XMLDOMDID_H__
#define __XMLDOMDID_H__

#define DISPID_DOM_BASE 0x00000001

#define DISPID_DOM_COLLECTION_BASE 1000000
#define DISPID_DOM_COLLECTION_MAX 2999999

#define DISPID_DOM_NODE (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME (DISPID_DOM_BASE + 1)
#define DISPID_DOM_NODE_NODEVALUE (DISPID_DOM_BASE + 2)
#define DISPID_DOM_NODE_NODETYPE (DISPID_DOM_BASE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM (DISPID_DOM_BASE + 4)
#define DISPID_DOM_NODE_PARENTNODE (DISPID_DOM_BASE + 5)
#define DISPID_DOM_NODE_CHILDNODES (DISPID_DOM_BASE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD (DISPID_DOM_BASE + 7)
#define DISPID_DOM_NODE_LASTCHILD (DISPID_DOM_BASE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING (DISPID_DOM_BASE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING (DISPID_DOM_BASE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES (DISPID_DOM_BASE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE (DISPID_DOM_BASE + 12)
#define DISPID_DOM_NODE_REPLACECHILD (DISPID_DOM_BASE + 13)
#define DISPID_DOM_NODE_REMOVECHILD (DISPID_DOM_BASE + 14)
#define DISPID_DOM_NODE_APPENDCHILD (DISPID_DOM_BASE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES (DISPID_DOM_BASE + 16)
#define DISPID_DOM_NODE_OWNERDOC (DISPID_DOM_BASE + 17)
#define DISPID_DOM_NODE_CLONENODE (DISPID_DOM_BASE + 18)
#define DISPID_XMLDOM_NODE (DISPID_DOM_BASE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE (DISPID_DOM_BASE + 20)
#define DISPID_XMLDOM_NODE_SPECIFIED (DISPID_DOM_BASE + 21)
#define DISPID_XMLDOM_NODE_DEFINITION (DISPID_DOM_BASE + 22)
#define DISPID_XMLDOM_NODE_TEXT (DISPID_DOM_BASE + 23)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE (DISPID_DOM_BASE + 24)
#define DISPID_XMLDOM_NODE_DATATYPE (DISPID_DOM_BASE + 25)
#define DISPID_XMLDOM_NODE_XML (DISPID_DOM_BASE + 26)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE (DISPID_DOM_BASE + 27)
#define DISPID_XMLDOM_NODE_SELECTNODES (DISPID_DOM_BASE + 28)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE (DISPID_DOM_BASE + 29)
#define DISPID_XMLDOM_NODE_PARSED (DISPID_DOM_BASE + 30)
#define DISPID_XMLDOM_NODE_NAMESPACE (DISPID_DOM_BASE + 31)
#define DISPID_XMLDOM_NODE_PREFIX (DISPID_DOM_BASE + 32)
#define DISPID_XMLDOM_NODE_BASENAME (DISPID_DOM_BASE + 33)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT (DISPID_DOM_BASE + 34)
#define DISPID_XMLDOM_NODE__TOP (DISPID_DOM_BASE + 35)
#define DISPID_DOM_DOCUMENT (DISPID_DOM_BASE + 36)
#define DISPID_DOM_DOCUMENT_DOCTYPE (DISPID_DOM_BASE + 37)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION (DISPID_DOM_BASE + 38)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT (DISPID_DOM_BASE + 39)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT (DISPID_DOM_BASE + 40)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_BASE + 41)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE (DISPID_DOM_BASE + 42)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT (DISPID_DOM_BASE + 43)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION (DISPID_DOM_BASE + 44)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_BASE + 45)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE (DISPID_DOM_BASE + 46)
#define DISPID_DOM_DOCUMENT_CREATEENTITY (DISPID_DOM_BASE + 47)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE (DISPID_DOM_BASE + 48)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME (DISPID_DOM_BASE + 49)
#define DISPID_DOM_DOCUMENT_TOP (DISPID_DOM_BASE + 50)
#define DISPID_XMLDOM_DOCUMENT (DISPID_DOM_BASE + 51)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE (DISPID_DOM_BASE + 52)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE (DISPID_DOM_BASE + 53)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX (DISPID_DOM_BASE + 54)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID (DISPID_DOM_BASE + 55)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES (DISPID_DOM_BASE + 56)
#define DISPID_XMLDOM_DOCUMENT_LOAD (DISPID_DOM_BASE + 57)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR (DISPID_DOM_BASE + 58)
#define DISPID_XMLDOM_DOCUMENT_URL (DISPID_DOM_BASE + 59)
#define DISPID_XMLDOM_DOCUMENT_ASYNC (DISPID_DOM_BASE + 60)
#define DISPID_XMLDOM_DOCUMENT_ABORT (DISPID_DOM_BASE + 61)
#define DISPID_XMLDOM_DOCUMENT_LOADXML (DISPID_DOM_BASE + 62)
#define DISPID_XMLDOM_DOCUMENT_SAVE (DISPID_DOM_BASE + 63)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE (DISPID_DOM_BASE + 64)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE (DISPID_DOM_BASE + 65)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE (DISPID_DOM_BASE + 66)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE (DISPID_DOM_BASE + 67)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE (DISPID_DOM_BASE + 68)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE (DISPID_DOM_BASE + 69)
#define DISPID_XMLDOM_DOCUMENT__TOP (DISPID_DOM_BASE + 70)
#define DISPID_DOM_NODELIST (DISPID_DOM_BASE + 71)
#define DISPID_DOM_NODELIST_ITEM (DISPID_DOM_BASE + 72)
#define DISPID_DOM_NODELIST_LENGTH (DISPID_DOM_BASE + 73)
#define DISPID_XMLDOM_NODELIST (DISPID_DOM_BASE + 74)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_DOM_BASE + 75)
#define DISPID_XMLDOM_NODELIST_RESET (DISPID_DOM_BASE + 76)
#define DISPID_XMLDOM_NODELIST_NEWENUM (DISPID_DOM_BASE + 77)
#define DISPID_XMLDOM_NODELIST__TOP (DISPID_DOM_BASE + 78)
#define DISPID_DOM_NAMEDNODEMAP (DISPID_DOM_BASE + 79)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM (DISPID_DOM_BASE + 82)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM (DISPID_DOM_BASE + 83)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM (DISPID_DOM_BASE + 84)
#define DISPID_XMLDOM_NAMEDNODEMAP (DISPID_DOM_BASE + 85)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM (DISPID_DOM_BASE + 86)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM (DISPID_DOM_BASE + 87)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE (DISPID_DOM_BASE + 88)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET (DISPID_DOM_BASE + 89)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM (DISPID_DOM_BASE + 90)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP (DISPID_DOM_BASE + 91)
#define DISPID_DOM_W3CWRAPPERS (DISPID_DOM_BASE + 92)
#define DISPID_DOM_DOCUMENTFRAGMENT (DISPID_DOM_BASE + 93)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP (DISPID_DOM_BASE + 94)
#define DISPID_DOM_ELEMENT (DISPID_DOM_BASE + 95)
#define DISPID_DOM_ELEMENT_GETTAGNAME (DISPID_DOM_BASE + 96)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES (DISPID_DOM_BASE + 97)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE (DISPID_DOM_BASE + 98)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE (DISPID_DOM_BASE + 99)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE (DISPID_DOM_BASE + 100)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE (DISPID_DOM_BASE + 101)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE (DISPID_DOM_BASE + 102)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE (DISPID_DOM_BASE + 103)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME (DISPID_DOM_BASE + 104)
#define DISPID_DOM_ELEMENT_NORMALIZE (DISPID_DOM_BASE + 105)
#define DISPID_DOM_ELEMENT__TOP (DISPID_DOM_BASE + 106)
#define DISPID_DOM_DATA (DISPID_DOM_BASE + 107)
#define DISPID_DOM_DATA_DATA (DISPID_DOM_BASE + 108)
#define DISPID_DOM_DATA_LENGTH (DISPID_DOM_BASE + 109)
#define DISPID_DOM_DATA_SUBSTRING (DISPID_DOM_BASE + 110)
#define DISPID_DOM_DATA_APPEND (DISPID_DOM_BASE + 111)
#define DISPID_DOM_DATA_INSERT (DISPID_DOM_BASE + 112)
#define DISPID_DOM_DATA_DELETE (DISPID_DOM_BASE + 113)
#define DISPID_DOM_DATA_REPLACE (DISPID_DOM_BASE + 114)
#define DISPID_DOM_DATA__TOP (DISPID_DOM_BASE + 115)
#define DISPID_DOM_ATTRIBUTE (DISPID_DOM_BASE + 116)
#define DISPID_DOM_ATTRIBUTE_GETNAME (DISPID_DOM_BASE + 117)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED (DISPID_DOM_BASE + 118)
#define DISPID_DOM_ATTRIBUTE_VALUE (DISPID_DOM_BASE + 119)
#define DISPID_DOM_ATTRIBUTE__TOP (DISPID_DOM_BASE + 120)
#define DISPID_DOM_TEXT (DISPID_DOM_BASE + 121)
#define DISPID_DOM_TEXT_SPLITTEXT (DISPID_DOM_BASE + 122)
#define DISPID_DOM_TEXT_JOINTEXT (DISPID_DOM_BASE + 123)
#define DISPID_DOM_TEXT__TOP (DISPID_DOM_BASE + 124)
#define DISPID_DOM_PI (DISPID_DOM_BASE + 125)
#define DISPID_DOM_PI_TARGET (DISPID_DOM_BASE + 126)
#define DISPID_DOM_PI_DATA (DISPID_DOM_BASE + 127)
#define DISPID_DOM_PI__TOP (DISPID_DOM_BASE + 128)
#define DISPID_DOM_DOCUMENTTYPE (DISPID_DOM_BASE + 129)
#define DISPID_DOM_DOCUMENTTYPE_NAME (DISPID_DOM_BASE + 130)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES (DISPID_DOM_BASE + 131)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS (DISPID_DOM_BASE + 132)
#define DISPID_DOM_DOCUMENTTYPE__TOP (DISPID_DOM_BASE + 133)
#define DISPID_DOM_NOTATION (DISPID_DOM_BASE + 134)
#define DISPID_DOM_NOTATION_PUBLICID (DISPID_DOM_BASE + 135)
#define DISPID_DOM_NOTATION_SYSTEMID (DISPID_DOM_BASE + 136)
#define DISPID_DOM_NOTATION__TOP (DISPID_DOM_BASE + 137)
#define DISPID_DOM_ENTITY (DISPID_DOM_BASE + 138)
#define DISPID_DOM_ENTITY_PUBLICID (DISPID_DOM_BASE + 139)
#define DISPID_DOM_ENTITY_SYSTEMID (DISPID_DOM_BASE + 140)
#define DISPID_DOM_ENTITY_NOTATIONNAME (DISPID_DOM_BASE + 141)
#define DISPID_DOM_ENTITY__TOP (DISPID_DOM_BASE + 142)
#define DISPID_DOM_W3CWRAPPERS_TOP (DISPID_DOM_BASE + 142)
#define DISPID_DOM_IMPLEMENTATION (DISPID_DOM_BASE + 143)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE (DISPID_DOM_BASE + 144)
#define DISPID_DOM_IMPLEMENTATION__TOP (DISPID_DOM_BASE + 145)
#define DISPID_DOM__TOP (DISPID_DOM_BASE + 175)
#define DISPID_DOM_ERROR (DISPID_DOM_BASE + 176)
#define DISPID_DOM_ERROR_ERRORCODE (DISPID_DOM_BASE + 177)
#define DISPID_DOM_ERROR_URL (DISPID_DOM_BASE + 178)
#define DISPID_DOM_ERROR_REASON (DISPID_DOM_BASE + 179)
#define DISPID_DOM_ERROR_SRCTEXT (DISPID_DOM_BASE + 180)
#define DISPID_DOM_ERROR_LINE (DISPID_DOM_BASE + 181)
#define DISPID_DOM_ERROR_LINEPOS (DISPID_DOM_BASE + 182)
#define DISPID_DOM_ERROR_FILEPOS (DISPID_DOM_BASE + 183)
#define DISPID_DOM_ERROR__TOP (DISPID_DOM_BASE + 184)
#define DISPID_XTLRUNTIME (DISPID_DOM_BASE + 185)
#define DISPID_XTLRUNTIME_UNIQUEID (DISPID_DOM_BASE + 186)
#define DISPID_XTLRUNTIME_DEPTH (DISPID_DOM_BASE + 187)
#define DISPID_XTLRUNTIME_CHILDNUMBER (DISPID_DOM_BASE + 188)
#define DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER (DISPID_DOM_BASE + 189)
#define DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER (DISPID_DOM_BASE + 190)
#define DISPID_XTLRUNTIME_FORMATINDEX (DISPID_DOM_BASE + 191)
#define DISPID_XTLRUNTIME_FORMATNUMBER (DISPID_DOM_BASE + 192)
#define DISPID_XTLRUNTIME_FORMATDATE (DISPID_DOM_BASE + 193)
#define DISPID_XTLRUNTIME_FORMATTIME (DISPID_DOM_BASE + 194)
#define DISPID_XTLRUNTIME__TOP (DISPID_DOM_BASE + 195)
#define DISPID_XMLDOMEVENT (DISPID_DOM_BASE + 196)
#define DISPID_XMLDOMEVENT_ONREADYSTATECHANGE (DISPID_READYSTATECHANGE)
#define DISPID_XMLDOMEVENT_ONDATAAVAILABLE (DISPID_DOM_BASE + 197)
#define DISPID_XMLDOMEVENT__TOP (DISPID_DOM_BASE + 198)
#endif
                                                                                                   usr/share/mingw-w64/include/xmldsodid.h                                                             0100644 0000000 0000000 00000001033 12404413015 016471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __XMLDSODID_H__
#define __XMLDSODID_H__

#define DISPID_XOBJ_MIN 0x00010000
#define DISPID_XOBJ_MAX 0x0001FFFF
#define DISPID_XOBJ_BASE DISPID_XOBJ_MIN

#define DISPID_XMLDSO DISPID_XOBJ_BASE
#define DISPID_XMLDSO_DOCUMENT DISPID_XMLDSO + 1
#define DISPID_XMLDSO_JAVADSOCOMPATIBLE DISPID_XMLDSO_DOCUMENT + 1
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/mingw-w64/include/xmllite.h                                                               0100644 0000000 0000000 00000150272 12404413015 016172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*** Autogenerated by WIDL 1.6 from include/xmllite.idl - Do not edit ***/

#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <rpc.h>
#include <rpcndr.h>

#ifndef COM_NO_WINDOWS_H
#include <windows.h>
#include <ole2.h>
#endif

#ifndef __xmllite_h__
#define __xmllite_h__

/* Forward declarations */

#ifndef __IXmlReader_FWD_DEFINED__
#define __IXmlReader_FWD_DEFINED__
typedef interface IXmlReader IXmlReader;
#endif

#ifndef __IXmlResolver_FWD_DEFINED__
#define __IXmlResolver_FWD_DEFINED__
typedef interface IXmlResolver IXmlResolver;
#endif

#ifndef __IXmlWriter_FWD_DEFINED__
#define __IXmlWriter_FWD_DEFINED__
typedef interface IXmlWriter IXmlWriter;
#endif

/* Headers for imported files */

#include <unknwn.h>
#include <objidl.h>
#include <oaidl.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum XmlNodeType {
    XmlNodeType_None = 0,
    XmlNodeType_Element = 1,
    XmlNodeType_Attribute = 2,
    XmlNodeType_Text = 3,
    XmlNodeType_CDATA = 4,
    XmlNodeType_ProcessingInstruction = 7,
    XmlNodeType_Comment = 8,
    XmlNodeType_DocumentType = 10,
    XmlNodeType_Whitespace = 13,
    XmlNodeType_EndElement = 15,
    XmlNodeType_XmlDeclaration = 17,
    _XmlNodeType_Last = 17
} XmlNodeType;
/*****************************************************************************
 * IXmlReader interface
 */
#ifndef __IXmlReader_INTERFACE_DEFINED__
#define __IXmlReader_INTERFACE_DEFINED__

DEFINE_GUID(IID_IXmlReader, 0x7279fc81, 0x709d, 0x4095, 0xb6,0x3d, 0x69,0xfe,0x4b,0x0d,0x90,0x30);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("7279fc81-709d-4095-b63d-69fe4b0d9030")
IXmlReader : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetInput(
        IUnknown *input) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetProperty(
        UINT property,
        LONG_PTR *value) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetProperty(
        UINT property,
        LONG_PTR value) = 0;

    virtual HRESULT STDMETHODCALLTYPE Read(
        XmlNodeType *node_type) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNodeType(
        XmlNodeType *node_type) = 0;

    virtual HRESULT STDMETHODCALLTYPE MoveToFirstAttribute(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE MoveToNextAttribute(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE MoveToAttributeByName(
        LPCWSTR local_name,
        LPCWSTR namespaceUri) = 0;

    virtual HRESULT STDMETHODCALLTYPE MoveToElement(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetQualifiedName(
        LPCWSTR *qualifiedName,
        UINT *qualifiedName_length) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNamespaceUri(
        LPCWSTR *namespaceUri,
        UINT *nnamespaceUri_length) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetLocalName(
        LPCWSTR *local_name,
        UINT *locale_name_length) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetPrefix(
        LPCWSTR *prefix,
        UINT *prefix_length) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetValue(
        LPCWSTR *value,
        UINT *value_length) = 0;

    virtual HRESULT STDMETHODCALLTYPE ReadValueChunk(
        WCHAR *buffer,
        UINT chunk_size,
        UINT *read) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBaseUri(
        LPCWSTR *baseUri,
        UINT *baseUri_length) = 0;

    virtual WINBOOL STDMETHODCALLTYPE IsDefault(
        ) = 0;

    virtual WINBOOL STDMETHODCALLTYPE IsEmptyElement(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetLineNumber(
        UINT *lineNumber) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetLinePosition(
        UINT *linePosition) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetAttributeCount(
        UINT *attributeCount) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetDepth(
        UINT *depth) = 0;

    virtual WINBOOL STDMETHODCALLTYPE IsEOF(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IXmlReader, 0x7279fc81, 0x709d, 0x4095, 0xb6,0x3d, 0x69,0xfe,0x4b,0x0d,0x90,0x30)
#endif
#else
typedef struct IXmlReaderVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IXmlReader* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IXmlReader* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IXmlReader* This);

    /*** IXmlReader methods ***/
    HRESULT (STDMETHODCALLTYPE *SetInput)(
        IXmlReader* This,
        IUnknown *input);

    HRESULT (STDMETHODCALLTYPE *GetProperty)(
        IXmlReader* This,
        UINT property,
        LONG_PTR *value);

    HRESULT (STDMETHODCALLTYPE *SetProperty)(
        IXmlReader* This,
        UINT property,
        LONG_PTR value);

    HRESULT (STDMETHODCALLTYPE *Read)(
        IXmlReader* This,
        XmlNodeType *node_type);

    HRESULT (STDMETHODCALLTYPE *GetNodeType)(
        IXmlReader* This,
        XmlNodeType *node_type);

    HRESULT (STDMETHODCALLTYPE *MoveToFirstAttribute)(
        IXmlReader* This);

    HRESULT (STDMETHODCALLTYPE *MoveToNextAttribute)(
        IXmlReader* This);

    HRESULT (STDMETHODCALLTYPE *MoveToAttributeByName)(
        IXmlReader* This,
        LPCWSTR local_name,
        LPCWSTR namespaceUri);

    HRESULT (STDMETHODCALLTYPE *MoveToElement)(
        IXmlReader* This);

    HRESULT (STDMETHODCALLTYPE *GetQualifiedName)(
        IXmlReader* This,
        LPCWSTR *qualifiedName,
        UINT *qualifiedName_length);

    HRESULT (STDMETHODCALLTYPE *GetNamespaceUri)(
        IXmlReader* This,
        LPCWSTR *namespaceUri,
        UINT *nnamespaceUri_length);

    HRESULT (STDMETHODCALLTYPE *GetLocalName)(
        IXmlReader* This,
        LPCWSTR *local_name,
        UINT *locale_name_length);

    HRESULT (STDMETHODCALLTYPE *GetPrefix)(
        IXmlReader* This,
        LPCWSTR *prefix,
        UINT *prefix_length);

    HRESULT (STDMETHODCALLTYPE *GetValue)(
        IXmlReader* This,
        LPCWSTR *value,
        UINT *value_length);

    HRESULT (STDMETHODCALLTYPE *ReadValueChunk)(
        IXmlReader* This,
        WCHAR *buffer,
        UINT chunk_size,
        UINT *read);

    HRESULT (STDMETHODCALLTYPE *GetBaseUri)(
        IXmlReader* This,
        LPCWSTR *baseUri,
        UINT *baseUri_length);

    WINBOOL (STDMETHODCALLTYPE *IsDefault)(
        IXmlReader* This);

    WINBOOL (STDMETHODCALLTYPE *IsEmptyElement)(
        IXmlReader* This);

    HRESULT (STDMETHODCALLTYPE *GetLineNumber)(
        IXmlReader* This,
        UINT *lineNumber);

    HRESULT (STDMETHODCALLTYPE *GetLinePosition)(
        IXmlReader* This,
        UINT *linePosition);

    HRESULT (STDMETHODCALLTYPE *GetAttributeCount)(
        IXmlReader* This,
        UINT *attributeCount);

    HRESULT (STDMETHODCALLTYPE *GetDepth)(
        IXmlReader* This,
        UINT *depth);

    WINBOOL (STDMETHODCALLTYPE *IsEOF)(
        IXmlReader* This);

    END_INTERFACE
} IXmlReaderVtbl;
interface IXmlReader {
    CONST_VTBL IXmlReaderVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IXmlReader_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IXmlReader_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IXmlReader_Release(This) (This)->lpVtbl->Release(This)
/*** IXmlReader methods ***/
#define IXmlReader_SetInput(This,input) (This)->lpVtbl->SetInput(This,input)
#define IXmlReader_GetProperty(This,property,value) (This)->lpVtbl->GetProperty(This,property,value)
#define IXmlReader_SetProperty(This,property,value) (This)->lpVtbl->SetProperty(This,property,value)
#define IXmlReader_Read(This,node_type) (This)->lpVtbl->Read(This,node_type)
#define IXmlReader_GetNodeType(This,node_type) (This)->lpVtbl->GetNodeType(This,node_type)
#define IXmlReader_MoveToFirstAttribute(This) (This)->lpVtbl->MoveToFirstAttribute(This)
#define IXmlReader_MoveToNextAttribute(This) (This)->lpVtbl->MoveToNextAttribute(This)
#define IXmlReader_MoveToAttributeByName(This,local_name,namespaceUri) (This)->lpVtbl->MoveToAttributeByName(This,local_name,namespaceUri)
#define IXmlReader_MoveToElement(This) (This)->lpVtbl->MoveToElement(This)
#define IXmlReader_GetQualifiedName(This,qualifiedName,qualifiedName_length) (This)->lpVtbl->GetQualifiedName(This,qualifiedName,qualifiedName_length)
#define IXmlReader_GetNamespaceUri(This,namespaceUri,nnamespaceUri_length) (This)->lpVtbl->GetNamespaceUri(This,namespaceUri,nnamespaceUri_length)
#define IXmlReader_GetLocalName(This,local_name,locale_name_length) (This)->lpVtbl->GetLocalName(This,local_name,locale_name_length)
#define IXmlReader_GetPrefix(This,prefix,prefix_length) (This)->lpVtbl->GetPrefix(This,prefix,prefix_length)
#define IXmlReader_GetValue(This,value,value_length) (This)->lpVtbl->GetValue(This,value,value_length)
#define IXmlReader_ReadValueChunk(This,buffer,chunk_size,read) (This)->lpVtbl->ReadValueChunk(This,buffer,chunk_size,read)
#define IXmlReader_GetBaseUri(This,baseUri,baseUri_length) (This)->lpVtbl->GetBaseUri(This,baseUri,baseUri_length)
#define IXmlReader_IsDefault(This) (This)->lpVtbl->IsDefault(This)
#define IXmlReader_IsEmptyElement(This) (This)->lpVtbl->IsEmptyElement(This)
#define IXmlReader_GetLineNumber(This,lineNumber) (This)->lpVtbl->GetLineNumber(This,lineNumber)
#define IXmlReader_GetLinePosition(This,linePosition) (This)->lpVtbl->GetLinePosition(This,linePosition)
#define IXmlReader_GetAttributeCount(This,attributeCount) (This)->lpVtbl->GetAttributeCount(This,attributeCount)
#define IXmlReader_GetDepth(This,depth) (This)->lpVtbl->GetDepth(This,depth)
#define IXmlReader_IsEOF(This) (This)->lpVtbl->IsEOF(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IXmlReader_QueryInterface(IXmlReader* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IXmlReader_AddRef(IXmlReader* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IXmlReader_Release(IXmlReader* This) {
    return This->lpVtbl->Release(This);
}
/*** IXmlReader methods ***/
static FORCEINLINE HRESULT IXmlReader_SetInput(IXmlReader* This,IUnknown *input) {
    return This->lpVtbl->SetInput(This,input);
}
static FORCEINLINE HRESULT IXmlReader_GetProperty(IXmlReader* This,UINT property,LONG_PTR *value) {
    return This->lpVtbl->GetProperty(This,property,value);
}
static FORCEINLINE HRESULT IXmlReader_SetProperty(IXmlReader* This,UINT property,LONG_PTR value) {
    return This->lpVtbl->SetProperty(This,property,value);
}
static FORCEINLINE HRESULT IXmlReader_Read(IXmlReader* This,XmlNodeType *node_type) {
    return This->lpVtbl->Read(This,node_type);
}
static FORCEINLINE HRESULT IXmlReader_GetNodeType(IXmlReader* This,XmlNodeType *node_type) {
    return This->lpVtbl->GetNodeType(This,node_type);
}
static FORCEINLINE HRESULT IXmlReader_MoveToFirstAttribute(IXmlReader* This) {
    return This->lpVtbl->MoveToFirstAttribute(This);
}
static FORCEINLINE HRESULT IXmlReader_MoveToNextAttribute(IXmlReader* This) {
    return This->lpVtbl->MoveToNextAttribute(This);
}
static FORCEINLINE HRESULT IXmlReader_MoveToAttributeByName(IXmlReader* This,LPCWSTR local_name,LPCWSTR namespaceUri) {
    return This->lpVtbl->MoveToAttributeByName(This,local_name,namespaceUri);
}
static FORCEINLINE HRESULT IXmlReader_MoveToElement(IXmlReader* This) {
    return This->lpVtbl->MoveToElement(This);
}
static FORCEINLINE HRESULT IXmlReader_GetQualifiedName(IXmlReader* This,LPCWSTR *qualifiedName,UINT *qualifiedName_length) {
    return This->lpVtbl->GetQualifiedName(This,qualifiedName,qualifiedName_length);
}
static FORCEINLINE HRESULT IXmlReader_GetNamespaceUri(IXmlReader* This,LPCWSTR *namespaceUri,UINT *nnamespaceUri_length) {
    return This->lpVtbl->GetNamespaceUri(This,namespaceUri,nnamespaceUri_length);
}
static FORCEINLINE HRESULT IXmlReader_GetLocalName(IXmlReader* This,LPCWSTR *local_name,UINT *locale_name_length) {
    return This->lpVtbl->GetLocalName(This,local_name,locale_name_length);
}
static FORCEINLINE HRESULT IXmlReader_GetPrefix(IXmlReader* This,LPCWSTR *prefix,UINT *prefix_length) {
    return This->lpVtbl->GetPrefix(This,prefix,prefix_length);
}
static FORCEINLINE HRESULT IXmlReader_GetValue(IXmlReader* This,LPCWSTR *value,UINT *value_length) {
    return This->lpVtbl->GetValue(This,value,value_length);
}
static FORCEINLINE HRESULT IXmlReader_ReadValueChunk(IXmlReader* This,WCHAR *buffer,UINT chunk_size,UINT *read) {
    return This->lpVtbl->ReadValueChunk(This,buffer,chunk_size,read);
}
static FORCEINLINE HRESULT IXmlReader_GetBaseUri(IXmlReader* This,LPCWSTR *baseUri,UINT *baseUri_length) {
    return This->lpVtbl->GetBaseUri(This,baseUri,baseUri_length);
}
static FORCEINLINE WINBOOL IXmlReader_IsDefault(IXmlReader* This) {
    return This->lpVtbl->IsDefault(This);
}
static FORCEINLINE WINBOOL IXmlReader_IsEmptyElement(IXmlReader* This) {
    return This->lpVtbl->IsEmptyElement(This);
}
static FORCEINLINE HRESULT IXmlReader_GetLineNumber(IXmlReader* This,UINT *lineNumber) {
    return This->lpVtbl->GetLineNumber(This,lineNumber);
}
static FORCEINLINE HRESULT IXmlReader_GetLinePosition(IXmlReader* This,UINT *linePosition) {
    return This->lpVtbl->GetLinePosition(This,linePosition);
}
static FORCEINLINE HRESULT IXmlReader_GetAttributeCount(IXmlReader* This,UINT *attributeCount) {
    return This->lpVtbl->GetAttributeCount(This,attributeCount);
}
static FORCEINLINE HRESULT IXmlReader_GetDepth(IXmlReader* This,UINT *depth) {
    return This->lpVtbl->GetDepth(This,depth);
}
static FORCEINLINE WINBOOL IXmlReader_IsEOF(IXmlReader* This) {
    return This->lpVtbl->IsEOF(This);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IXmlReader_SetInput_Proxy(
    IXmlReader* This,
    IUnknown *input);
void __RPC_STUB IXmlReader_SetInput_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetProperty_Proxy(
    IXmlReader* This,
    UINT property,
    LONG_PTR *value);
void __RPC_STUB IXmlReader_GetProperty_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_SetProperty_Proxy(
    IXmlReader* This,
    UINT property,
    LONG_PTR value);
void __RPC_STUB IXmlReader_SetProperty_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_Read_Proxy(
    IXmlReader* This,
    XmlNodeType *node_type);
void __RPC_STUB IXmlReader_Read_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetNodeType_Proxy(
    IXmlReader* This,
    XmlNodeType *node_type);
void __RPC_STUB IXmlReader_GetNodeType_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_MoveToFirstAttribute_Proxy(
    IXmlReader* This);
void __RPC_STUB IXmlReader_MoveToFirstAttribute_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_MoveToNextAttribute_Proxy(
    IXmlReader* This);
void __RPC_STUB IXmlReader_MoveToNextAttribute_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_MoveToAttributeByName_Proxy(
    IXmlReader* This,
    LPCWSTR local_name,
    LPCWSTR namespaceUri);
void __RPC_STUB IXmlReader_MoveToAttributeByName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_MoveToElement_Proxy(
    IXmlReader* This);
void __RPC_STUB IXmlReader_MoveToElement_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetQualifiedName_Proxy(
    IXmlReader* This,
    LPCWSTR *qualifiedName,
    UINT *qualifiedName_length);
void __RPC_STUB IXmlReader_GetQualifiedName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetNamespaceUri_Proxy(
    IXmlReader* This,
    LPCWSTR *namespaceUri,
    UINT *nnamespaceUri_length);
void __RPC_STUB IXmlReader_GetNamespaceUri_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetLocalName_Proxy(
    IXmlReader* This,
    LPCWSTR *local_name,
    UINT *locale_name_length);
void __RPC_STUB IXmlReader_GetLocalName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetPrefix_Proxy(
    IXmlReader* This,
    LPCWSTR *prefix,
    UINT *prefix_length);
void __RPC_STUB IXmlReader_GetPrefix_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetValue_Proxy(
    IXmlReader* This,
    LPCWSTR *value,
    UINT *value_length);
void __RPC_STUB IXmlReader_GetValue_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_ReadValueChunk_Proxy(
    IXmlReader* This,
    WCHAR *buffer,
    UINT chunk_size,
    UINT *read);
void __RPC_STUB IXmlReader_ReadValueChunk_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetBaseUri_Proxy(
    IXmlReader* This,
    LPCWSTR *baseUri,
    UINT *baseUri_length);
void __RPC_STUB IXmlReader_GetBaseUri_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
WINBOOL STDMETHODCALLTYPE IXmlReader_IsDefault_Proxy(
    IXmlReader* This);
void __RPC_STUB IXmlReader_IsDefault_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
WINBOOL STDMETHODCALLTYPE IXmlReader_IsEmptyElement_Proxy(
    IXmlReader* This);
void __RPC_STUB IXmlReader_IsEmptyElement_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetLineNumber_Proxy(
    IXmlReader* This,
    UINT *lineNumber);
void __RPC_STUB IXmlReader_GetLineNumber_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetLinePosition_Proxy(
    IXmlReader* This,
    UINT *linePosition);
void __RPC_STUB IXmlReader_GetLinePosition_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetAttributeCount_Proxy(
    IXmlReader* This,
    UINT *attributeCount);
void __RPC_STUB IXmlReader_GetAttributeCount_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlReader_GetDepth_Proxy(
    IXmlReader* This,
    UINT *depth);
void __RPC_STUB IXmlReader_GetDepth_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
WINBOOL STDMETHODCALLTYPE IXmlReader_IsEOF_Proxy(
    IXmlReader* This);
void __RPC_STUB IXmlReader_IsEOF_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IXmlReader_INTERFACE_DEFINED__ */

/*****************************************************************************
 * IXmlResolver interface
 */
#ifndef __IXmlResolver_INTERFACE_DEFINED__
#define __IXmlResolver_INTERFACE_DEFINED__

DEFINE_GUID(IID_IXmlResolver, 0x7279fc82, 0x709d, 0x4095, 0xb6,0x3d, 0x69,0xfe,0x4b,0x0d,0x90,0x30);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("7279fc82-709d-4095-b63d-69fe4b0d9030")
IXmlResolver : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE ResolveUri(
        LPCWSTR base_uri,
        LPCWSTR public_id,
        LPCWSTR system_id,
        IUnknown **input) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IXmlResolver, 0x7279fc82, 0x709d, 0x4095, 0xb6,0x3d, 0x69,0xfe,0x4b,0x0d,0x90,0x30)
#endif
#else
typedef struct IXmlResolverVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IXmlResolver* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IXmlResolver* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IXmlResolver* This);

    /*** IXmlResolver methods ***/
    HRESULT (STDMETHODCALLTYPE *ResolveUri)(
        IXmlResolver* This,
        LPCWSTR base_uri,
        LPCWSTR public_id,
        LPCWSTR system_id,
        IUnknown **input);

    END_INTERFACE
} IXmlResolverVtbl;
interface IXmlResolver {
    CONST_VTBL IXmlResolverVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IXmlResolver_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IXmlResolver_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IXmlResolver_Release(This) (This)->lpVtbl->Release(This)
/*** IXmlResolver methods ***/
#define IXmlResolver_ResolveUri(This,base_uri,public_id,system_id,input) (This)->lpVtbl->ResolveUri(This,base_uri,public_id,system_id,input)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IXmlResolver_QueryInterface(IXmlResolver* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IXmlResolver_AddRef(IXmlResolver* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IXmlResolver_Release(IXmlResolver* This) {
    return This->lpVtbl->Release(This);
}
/*** IXmlResolver methods ***/
static FORCEINLINE HRESULT IXmlResolver_ResolveUri(IXmlResolver* This,LPCWSTR base_uri,LPCWSTR public_id,LPCWSTR system_id,IUnknown **input) {
    return This->lpVtbl->ResolveUri(This,base_uri,public_id,system_id,input);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IXmlResolver_ResolveUri_Proxy(
    IXmlResolver* This,
    LPCWSTR base_uri,
    LPCWSTR public_id,
    LPCWSTR system_id,
    IUnknown **input);
void __RPC_STUB IXmlResolver_ResolveUri_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IXmlResolver_INTERFACE_DEFINED__ */

typedef enum XmlReadState {
    XmlReadState_Initial = 0,
    XmlReadState_Interactive = 1,
    XmlReadState_Error = 2,
    XmlReadState_EndOfFile = 3,
    XmlReadState_Closed = 4
} XmlReadState;
typedef enum XmlConformanceLevel {
    XmlConformanceLevel_Auto = 0,
    XmlConformanceLevel_Fragment = 1,
    XmlConformanceLevel_Document = 2,
    _XmlConformanceLevel_Last = XmlConformanceLevel_Document
} XmlConformanceLevel;
typedef enum DtdProcessing {
    DtdProcessing_Prohibit = 0,
    DtdProcessing_Parse = 1,
    _DtdProcessing_Last = DtdProcessing_Parse
} DtdProcessing;
typedef enum XmlReaderProperty {
    XmlReaderProperty_MultiLanguage = 0,
    XmlReaderProperty_ConformanceLevel = 1,
    XmlReaderProperty_RandomAccess = 2,
    XmlReaderProperty_XmlResolver = 3,
    XmlReaderProperty_DtdProcessing = 4,
    XmlReaderProperty_ReadState = 5,
    XmlReaderProperty_MaxElementDepth = 6,
    XmlReaderProperty_MaxEntityExpansion = 7,
    _XmlReaderProperty_Last = XmlReaderProperty_MaxEntityExpansion
} XmlReaderProperty;
typedef enum XmlError {
    MX_E_MX = 0xc00cee00,
    MX_E_INPUTEND = 0xc00cee01,
    MX_E_ENCODING = 0xc00cee02,
    MX_E_ENCODINGSWITCH = 0xc00cee03,
    MX_E_ENCODINGSIGNATURE = 0xc00cee04,
    WC_E_WC = 0xc00cee20,
    WC_E_WHITESPACE = 0xc00cee21,
    WC_E_SEMICOLON = 0xc00cee22,
    WC_E_GREATERTHAN = 0xc00cee23,
    WC_E_QUOTE = 0xc00cee24,
    WC_E_EQUAL = 0xc00cee25,
    WC_E_LESSTHAN = 0xc00cee26,
    WC_E_HEXDIGIT = 0xc00cee27,
    WC_E_DIGIT = 0xc00cee28,
    WC_E_LEFTBRACKET = 0xc00cee29,
    WC_E_LEFTPAREN = 0xc00cee2a,
    WC_E_XMLCHARACTER = 0xc00cee2b,
    WC_E_NAMECHARACTER = 0xc00cee2c,
    WC_E_SYNTAX = 0xc00cee2d,
    WC_E_CDSECT = 0xc00cee2e,
    WC_E_COMMENT = 0xc00cee2f,
    WC_E_CONDSECT = 0xc00cee30,
    WC_E_DECLATTLIST = 0xc00cee31,
    WC_E_DECLDOCTYPE = 0xc00cee32,
    WC_E_DECLELEMENT = 0xc00cee33,
    WC_E_DECLENTITY = 0xc00cee34,
    WC_E_DECLNOTATION = 0xc00cee35,
    WC_E_NDATA = 0xc00cee36,
    WC_E_PUBLIC = 0xc00cee37,
    WC_E_SYSTEM = 0xc00cee38,
    WC_E_NAME = 0xc00cee39,
    WC_E_ROOTELEMENT = 0xc00cee3a,
    WC_E_ELEMENTMATCH = 0xc00cee3b,
    WC_E_UNIQUEATTRIBUTE = 0xc00cee3c,
    WC_E_TEXTXMLDECL = 0xc00cee3d,
    WC_E_LEADINGXML = 0xc00cee3e,
    WC_E_TEXTDECL = 0xc00cee3f,
    WC_E_XMLDECL = 0xc00cee40,
    WC_E_ENCNAME = 0xc00cee41,
    WC_E_PUBLICID = 0xc00cee42,
    WC_E_PESINTERNALSUBSET = 0xc00cee43,
    WC_E_PESBETWEENDECLS = 0xc00cee44,
    WC_E_NORECURSION = 0xc00cee45,
    WC_E_ENTITYCONTENT = 0xc00cee46,
    WC_E_UNDECLAREDENTITY = 0xc00cee47,
    WC_E_PARSEDENTITY = 0xc00cee48,
    WC_E_NOEXTERNALENTITYREF = 0xc00cee49,
    WC_E_PI = 0xc00cee4a,
    WC_E_SYSTEMID = 0xc00cee4b,
    WC_E_QUESTIONMARK = 0xc00cee4c,
    WC_E_CDSECTEND = 0xc00cee4d,
    WC_E_MOREDATA = 0xc00cee4e,
    WC_E_DTDPROHIBITED = 0xc00cee4f,
    WC_E_INVALIDXMLSPACE = 0xc00cee50,
    NC_E_NC = 0xc00cee60,
    NC_E_QNAMECHARACTER = 0xc00cee61,
    NC_E_QNAMECOLON = 0xc00cee62,
    NC_E_NAMECOLON = 0xc00cee63,
    NC_E_DECLAREDPREFIX = 0xc00cee64,
    NC_E_UNDECLAREDPREFIX = 0xc00cee65,
    NC_E_EMPTYURI = 0xc00cee66,
    NC_E_XMLPREFIXRESERVED = 0xc00cee67,
    NC_E_XMLNSPREFIXRESERVED = 0xc00cee68,
    NC_E_XMLURIRESERVED = 0xc00cee69,
    NC_E_XMLNSURIRESERVED = 0xc00cee6a,
    SC_E_SC = 0xc00cee80,
    SC_E_MAXELEMENTDEPTH = 0xc00cee81,
    SC_E_MAXENTITYEXPANSION = 0xc00cee82,
    WR_E_WR = 0xc00cef00,
    WR_E_NONWHITESPACE = 0xc00cef01,
    WR_E_NSPREFIXDECLARED = 0xc00cef02,
    WR_E_NSPREFIXWITHEMPTYNSURI = 0xc00cef03,
    WR_E_DUPLICATEATTRIBUTE = 0xc00cef04,
    WR_E_XMLNSPREFIXDECLARATION = 0xc00cef05,
    WR_E_XMLPREFIXDECLARATION = 0xc00cef06,
    WR_E_XMLURIDECLARATION = 0xc00cef07,
    WR_E_XMLNSURIDECLARATION = 0xc00cef08,
    WR_E_NAMESPACEUNDECLARED = 0xc00cef09,
    WR_E_INVALIDXMLSPACE = 0xc00cef0a,
    WR_E_INVALIDACTION = 0xc00cef0b,
    WR_E_INVALIDSURROGATEPAIR = 0xc00cef0c,
    XML_E_INVALID_DECIMAL = 0xc00ce01d,
    XML_E_INVALID_HEXIDECIMAL = 0xc00ce01e,
    XML_E_INVALID_UNICODE = 0xc00ce01f,
    XML_E_INVALIDENCODING = 0xc00ce06e
} XmlError;
STDAPI CreateXmlReader(REFIID riid, void **ppvObject, IMalloc *pMalloc);
typedef IUnknown IXmlReaderInput;
STDAPI CreateXmlReaderInputWithEncodingName(IUnknown *stream, IMalloc *pMalloc,
                                            LPCWSTR encoding, WINBOOL hint,
                                            LPCWSTR base_uri, IXmlReaderInput **ppInput);
typedef enum XmlStandalone {
    XmlStandalone_Omit = 0,
    XmlStandalone_Yes = 1,
    XmlStandalone_No = 2,
    _XmlStandalone_Last = XmlStandalone_No
} XmlStandalone;
typedef enum XmlWriterProperty {
    XmlWriterProperty_MultiLanguage = 0,
    XmlWriterProperty_Indent = 1,
    XmlWriterProperty_ByteOrderMark = 2,
    XmlWriterProperty_OmitXmlDeclaration = 3,
    XmlWriterProperty_ConformanceLevel = 4,
    _XmlWriterProperty_Last = XmlWriterProperty_OmitXmlDeclaration
} XmlWriterProperty;
/*****************************************************************************
 * IXmlWriter interface
 */
#ifndef __IXmlWriter_INTERFACE_DEFINED__
#define __IXmlWriter_INTERFACE_DEFINED__

DEFINE_GUID(IID_IXmlWriter, 0x7279fc88, 0x709d, 0x4095, 0xb6,0x3d, 0x69,0xfe,0x4b,0x0d,0x90,0x30);
#if defined(__cplusplus) && !defined(CINTERFACE)
MIDL_INTERFACE("7279fc88-709d-4095-b63d-69fe4b0d9030")
IXmlWriter : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetOutput(
        IUnknown *pOutput) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetProperty(
        UINT nProperty,
        LONG_PTR *ppValue) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetProperty(
        UINT nProperty,
        LONG_PTR pValue) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteAttributes(
        IXmlReader *pReader,
        WINBOOL fWriteDefaultAttributes) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteAttributeString(
        LPCWSTR pwszPrefix,
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri,
        LPCWSTR pwszValue) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteCData(
        LPCWSTR pwszText) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteCharEntity(
        WCHAR wch) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteChars(
        const WCHAR *pwch,
        UINT cwch) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteComment(
        LPCWSTR pwszComment) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteDocType(
        LPCWSTR pwszName,
        LPCWSTR pwszPublicId,
        LPCWSTR pwszSystemId,
        LPCWSTR pwszSubset) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteElementString(
        LPCWSTR pwszPrefix,
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri,
        LPCWSTR pwszValue) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteEndDocument(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteEndElement(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteEntityRef(
        LPCWSTR pwszName) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteFullEndElement(
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteName(
        LPCWSTR pwszName) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteNmToken(
        LPCWSTR pwszNmToken) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteNode(
        IXmlReader *pReader,
        WINBOOL fWriteDefaultAttributes) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteNodeShallow(
        IXmlReader *pReader,
        WINBOOL fWriteDefaultAttributes) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteProcessingInstruction(
        LPCWSTR pwszName,
        LPCWSTR pwszText) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteQualifiedName(
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteRaw(
        LPCWSTR pwszData) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteRawChars(
        const WCHAR *pwch,
        UINT cwch) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteStartDocument(
        XmlStandalone standalone) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteStartElement(
        LPCWSTR pwszPrefix,
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteString(
        LPCWSTR pwszText) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteSurrogateCharEntity(
        WCHAR wchLow,
        WCHAR wchHigh) = 0;

    virtual HRESULT STDMETHODCALLTYPE WriteWhitespace(
        LPCWSTR pwszWhitespace) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush(
        ) = 0;

};
#ifdef __CRT_UUID_DECL
__CRT_UUID_DECL(IXmlWriter, 0x7279fc88, 0x709d, 0x4095, 0xb6,0x3d, 0x69,0xfe,0x4b,0x0d,0x90,0x30)
#endif
#else
typedef struct IXmlWriterVtbl {
    BEGIN_INTERFACE

    /*** IUnknown methods ***/
    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
        IXmlWriter* This,
        REFIID riid,
        void **ppvObject);

    ULONG (STDMETHODCALLTYPE *AddRef)(
        IXmlWriter* This);

    ULONG (STDMETHODCALLTYPE *Release)(
        IXmlWriter* This);

    /*** IXmlWriter methods ***/
    HRESULT (STDMETHODCALLTYPE *SetOutput)(
        IXmlWriter* This,
        IUnknown *pOutput);

    HRESULT (STDMETHODCALLTYPE *GetProperty)(
        IXmlWriter* This,
        UINT nProperty,
        LONG_PTR *ppValue);

    HRESULT (STDMETHODCALLTYPE *SetProperty)(
        IXmlWriter* This,
        UINT nProperty,
        LONG_PTR pValue);

    HRESULT (STDMETHODCALLTYPE *WriteAttributes)(
        IXmlWriter* This,
        IXmlReader *pReader,
        WINBOOL fWriteDefaultAttributes);

    HRESULT (STDMETHODCALLTYPE *WriteAttributeString)(
        IXmlWriter* This,
        LPCWSTR pwszPrefix,
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri,
        LPCWSTR pwszValue);

    HRESULT (STDMETHODCALLTYPE *WriteCData)(
        IXmlWriter* This,
        LPCWSTR pwszText);

    HRESULT (STDMETHODCALLTYPE *WriteCharEntity)(
        IXmlWriter* This,
        WCHAR wch);

    HRESULT (STDMETHODCALLTYPE *WriteChars)(
        IXmlWriter* This,
        const WCHAR *pwch,
        UINT cwch);

    HRESULT (STDMETHODCALLTYPE *WriteComment)(
        IXmlWriter* This,
        LPCWSTR pwszComment);

    HRESULT (STDMETHODCALLTYPE *WriteDocType)(
        IXmlWriter* This,
        LPCWSTR pwszName,
        LPCWSTR pwszPublicId,
        LPCWSTR pwszSystemId,
        LPCWSTR pwszSubset);

    HRESULT (STDMETHODCALLTYPE *WriteElementString)(
        IXmlWriter* This,
        LPCWSTR pwszPrefix,
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri,
        LPCWSTR pwszValue);

    HRESULT (STDMETHODCALLTYPE *WriteEndDocument)(
        IXmlWriter* This);

    HRESULT (STDMETHODCALLTYPE *WriteEndElement)(
        IXmlWriter* This);

    HRESULT (STDMETHODCALLTYPE *WriteEntityRef)(
        IXmlWriter* This,
        LPCWSTR pwszName);

    HRESULT (STDMETHODCALLTYPE *WriteFullEndElement)(
        IXmlWriter* This);

    HRESULT (STDMETHODCALLTYPE *WriteName)(
        IXmlWriter* This,
        LPCWSTR pwszName);

    HRESULT (STDMETHODCALLTYPE *WriteNmToken)(
        IXmlWriter* This,
        LPCWSTR pwszNmToken);

    HRESULT (STDMETHODCALLTYPE *WriteNode)(
        IXmlWriter* This,
        IXmlReader *pReader,
        WINBOOL fWriteDefaultAttributes);

    HRESULT (STDMETHODCALLTYPE *WriteNodeShallow)(
        IXmlWriter* This,
        IXmlReader *pReader,
        WINBOOL fWriteDefaultAttributes);

    HRESULT (STDMETHODCALLTYPE *WriteProcessingInstruction)(
        IXmlWriter* This,
        LPCWSTR pwszName,
        LPCWSTR pwszText);

    HRESULT (STDMETHODCALLTYPE *WriteQualifiedName)(
        IXmlWriter* This,
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri);

    HRESULT (STDMETHODCALLTYPE *WriteRaw)(
        IXmlWriter* This,
        LPCWSTR pwszData);

    HRESULT (STDMETHODCALLTYPE *WriteRawChars)(
        IXmlWriter* This,
        const WCHAR *pwch,
        UINT cwch);

    HRESULT (STDMETHODCALLTYPE *WriteStartDocument)(
        IXmlWriter* This,
        XmlStandalone standalone);

    HRESULT (STDMETHODCALLTYPE *WriteStartElement)(
        IXmlWriter* This,
        LPCWSTR pwszPrefix,
        LPCWSTR pwszLocalName,
        LPCWSTR pwszNamespaceUri);

    HRESULT (STDMETHODCALLTYPE *WriteString)(
        IXmlWriter* This,
        LPCWSTR pwszText);

    HRESULT (STDMETHODCALLTYPE *WriteSurrogateCharEntity)(
        IXmlWriter* This,
        WCHAR wchLow,
        WCHAR wchHigh);

    HRESULT (STDMETHODCALLTYPE *WriteWhitespace)(
        IXmlWriter* This,
        LPCWSTR pwszWhitespace);

    HRESULT (STDMETHODCALLTYPE *Flush)(
        IXmlWriter* This);

    END_INTERFACE
} IXmlWriterVtbl;
interface IXmlWriter {
    CONST_VTBL IXmlWriterVtbl* lpVtbl;
};

#ifdef COBJMACROS
#ifndef WIDL_C_INLINE_WRAPPERS
/*** IUnknown methods ***/
#define IXmlWriter_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IXmlWriter_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IXmlWriter_Release(This) (This)->lpVtbl->Release(This)
/*** IXmlWriter methods ***/
#define IXmlWriter_SetOutput(This,pOutput) (This)->lpVtbl->SetOutput(This,pOutput)
#define IXmlWriter_GetProperty(This,nProperty,ppValue) (This)->lpVtbl->GetProperty(This,nProperty,ppValue)
#define IXmlWriter_SetProperty(This,nProperty,pValue) (This)->lpVtbl->SetProperty(This,nProperty,pValue)
#define IXmlWriter_WriteAttributes(This,pReader,fWriteDefaultAttributes) (This)->lpVtbl->WriteAttributes(This,pReader,fWriteDefaultAttributes)
#define IXmlWriter_WriteAttributeString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue) (This)->lpVtbl->WriteAttributeString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue)
#define IXmlWriter_WriteCData(This,pwszText) (This)->lpVtbl->WriteCData(This,pwszText)
#define IXmlWriter_WriteCharEntity(This,wch) (This)->lpVtbl->WriteCharEntity(This,wch)
#define IXmlWriter_WriteChars(This,pwch,cwch) (This)->lpVtbl->WriteChars(This,pwch,cwch)
#define IXmlWriter_WriteComment(This,pwszComment) (This)->lpVtbl->WriteComment(This,pwszComment)
#define IXmlWriter_WriteDocType(This,pwszName,pwszPublicId,pwszSystemId,pwszSubset) (This)->lpVtbl->WriteDocType(This,pwszName,pwszPublicId,pwszSystemId,pwszSubset)
#define IXmlWriter_WriteElementString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue) (This)->lpVtbl->WriteElementString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue)
#define IXmlWriter_WriteEndDocument(This) (This)->lpVtbl->WriteEndDocument(This)
#define IXmlWriter_WriteEndElement(This) (This)->lpVtbl->WriteEndElement(This)
#define IXmlWriter_WriteEntityRef(This,pwszName) (This)->lpVtbl->WriteEntityRef(This,pwszName)
#define IXmlWriter_WriteFullEndElement(This) (This)->lpVtbl->WriteFullEndElement(This)
#define IXmlWriter_WriteName(This,pwszName) (This)->lpVtbl->WriteName(This,pwszName)
#define IXmlWriter_WriteNmToken(This,pwszNmToken) (This)->lpVtbl->WriteNmToken(This,pwszNmToken)
#define IXmlWriter_WriteNode(This,pReader,fWriteDefaultAttributes) (This)->lpVtbl->WriteNode(This,pReader,fWriteDefaultAttributes)
#define IXmlWriter_WriteNodeShallow(This,pReader,fWriteDefaultAttributes) (This)->lpVtbl->WriteNodeShallow(This,pReader,fWriteDefaultAttributes)
#define IXmlWriter_WriteProcessingInstruction(This,pwszName,pwszText) (This)->lpVtbl->WriteProcessingInstruction(This,pwszName,pwszText)
#define IXmlWriter_WriteQualifiedName(This,pwszLocalName,pwszNamespaceUri) (This)->lpVtbl->WriteQualifiedName(This,pwszLocalName,pwszNamespaceUri)
#define IXmlWriter_WriteRaw(This,pwszData) (This)->lpVtbl->WriteRaw(This,pwszData)
#define IXmlWriter_WriteRawChars(This,pwch,cwch) (This)->lpVtbl->WriteRawChars(This,pwch,cwch)
#define IXmlWriter_WriteStartDocument(This,standalone) (This)->lpVtbl->WriteStartDocument(This,standalone)
#define IXmlWriter_WriteStartElement(This,pwszPrefix,pwszLocalName,pwszNamespaceUri) (This)->lpVtbl->WriteStartElement(This,pwszPrefix,pwszLocalName,pwszNamespaceUri)
#define IXmlWriter_WriteString(This,pwszText) (This)->lpVtbl->WriteString(This,pwszText)
#define IXmlWriter_WriteSurrogateCharEntity(This,wchLow,wchHigh) (This)->lpVtbl->WriteSurrogateCharEntity(This,wchLow,wchHigh)
#define IXmlWriter_WriteWhitespace(This,pwszWhitespace) (This)->lpVtbl->WriteWhitespace(This,pwszWhitespace)
#define IXmlWriter_Flush(This) (This)->lpVtbl->Flush(This)
#else
/*** IUnknown methods ***/
static FORCEINLINE HRESULT IXmlWriter_QueryInterface(IXmlWriter* This,REFIID riid,void **ppvObject) {
    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
}
static FORCEINLINE ULONG IXmlWriter_AddRef(IXmlWriter* This) {
    return This->lpVtbl->AddRef(This);
}
static FORCEINLINE ULONG IXmlWriter_Release(IXmlWriter* This) {
    return This->lpVtbl->Release(This);
}
/*** IXmlWriter methods ***/
static FORCEINLINE HRESULT IXmlWriter_SetOutput(IXmlWriter* This,IUnknown *pOutput) {
    return This->lpVtbl->SetOutput(This,pOutput);
}
static FORCEINLINE HRESULT IXmlWriter_GetProperty(IXmlWriter* This,UINT nProperty,LONG_PTR *ppValue) {
    return This->lpVtbl->GetProperty(This,nProperty,ppValue);
}
static FORCEINLINE HRESULT IXmlWriter_SetProperty(IXmlWriter* This,UINT nProperty,LONG_PTR pValue) {
    return This->lpVtbl->SetProperty(This,nProperty,pValue);
}
static FORCEINLINE HRESULT IXmlWriter_WriteAttributes(IXmlWriter* This,IXmlReader *pReader,WINBOOL fWriteDefaultAttributes) {
    return This->lpVtbl->WriteAttributes(This,pReader,fWriteDefaultAttributes);
}
static FORCEINLINE HRESULT IXmlWriter_WriteAttributeString(IXmlWriter* This,LPCWSTR pwszPrefix,LPCWSTR pwszLocalName,LPCWSTR pwszNamespaceUri,LPCWSTR pwszValue) {
    return This->lpVtbl->WriteAttributeString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue);
}
static FORCEINLINE HRESULT IXmlWriter_WriteCData(IXmlWriter* This,LPCWSTR pwszText) {
    return This->lpVtbl->WriteCData(This,pwszText);
}
static FORCEINLINE HRESULT IXmlWriter_WriteCharEntity(IXmlWriter* This,WCHAR wch) {
    return This->lpVtbl->WriteCharEntity(This,wch);
}
static FORCEINLINE HRESULT IXmlWriter_WriteChars(IXmlWriter* This,const WCHAR *pwch,UINT cwch) {
    return This->lpVtbl->WriteChars(This,pwch,cwch);
}
static FORCEINLINE HRESULT IXmlWriter_WriteComment(IXmlWriter* This,LPCWSTR pwszComment) {
    return This->lpVtbl->WriteComment(This,pwszComment);
}
static FORCEINLINE HRESULT IXmlWriter_WriteDocType(IXmlWriter* This,LPCWSTR pwszName,LPCWSTR pwszPublicId,LPCWSTR pwszSystemId,LPCWSTR pwszSubset) {
    return This->lpVtbl->WriteDocType(This,pwszName,pwszPublicId,pwszSystemId,pwszSubset);
}
static FORCEINLINE HRESULT IXmlWriter_WriteElementString(IXmlWriter* This,LPCWSTR pwszPrefix,LPCWSTR pwszLocalName,LPCWSTR pwszNamespaceUri,LPCWSTR pwszValue) {
    return This->lpVtbl->WriteElementString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue);
}
static FORCEINLINE HRESULT IXmlWriter_WriteEndDocument(IXmlWriter* This) {
    return This->lpVtbl->WriteEndDocument(This);
}
static FORCEINLINE HRESULT IXmlWriter_WriteEndElement(IXmlWriter* This) {
    return This->lpVtbl->WriteEndElement(This);
}
static FORCEINLINE HRESULT IXmlWriter_WriteEntityRef(IXmlWriter* This,LPCWSTR pwszName) {
    return This->lpVtbl->WriteEntityRef(This,pwszName);
}
static FORCEINLINE HRESULT IXmlWriter_WriteFullEndElement(IXmlWriter* This) {
    return This->lpVtbl->WriteFullEndElement(This);
}
static FORCEINLINE HRESULT IXmlWriter_WriteName(IXmlWriter* This,LPCWSTR pwszName) {
    return This->lpVtbl->WriteName(This,pwszName);
}
static FORCEINLINE HRESULT IXmlWriter_WriteNmToken(IXmlWriter* This,LPCWSTR pwszNmToken) {
    return This->lpVtbl->WriteNmToken(This,pwszNmToken);
}
static FORCEINLINE HRESULT IXmlWriter_WriteNode(IXmlWriter* This,IXmlReader *pReader,WINBOOL fWriteDefaultAttributes) {
    return This->lpVtbl->WriteNode(This,pReader,fWriteDefaultAttributes);
}
static FORCEINLINE HRESULT IXmlWriter_WriteNodeShallow(IXmlWriter* This,IXmlReader *pReader,WINBOOL fWriteDefaultAttributes) {
    return This->lpVtbl->WriteNodeShallow(This,pReader,fWriteDefaultAttributes);
}
static FORCEINLINE HRESULT IXmlWriter_WriteProcessingInstruction(IXmlWriter* This,LPCWSTR pwszName,LPCWSTR pwszText) {
    return This->lpVtbl->WriteProcessingInstruction(This,pwszName,pwszText);
}
static FORCEINLINE HRESULT IXmlWriter_WriteQualifiedName(IXmlWriter* This,LPCWSTR pwszLocalName,LPCWSTR pwszNamespaceUri) {
    return This->lpVtbl->WriteQualifiedName(This,pwszLocalName,pwszNamespaceUri);
}
static FORCEINLINE HRESULT IXmlWriter_WriteRaw(IXmlWriter* This,LPCWSTR pwszData) {
    return This->lpVtbl->WriteRaw(This,pwszData);
}
static FORCEINLINE HRESULT IXmlWriter_WriteRawChars(IXmlWriter* This,const WCHAR *pwch,UINT cwch) {
    return This->lpVtbl->WriteRawChars(This,pwch,cwch);
}
static FORCEINLINE HRESULT IXmlWriter_WriteStartDocument(IXmlWriter* This,XmlStandalone standalone) {
    return This->lpVtbl->WriteStartDocument(This,standalone);
}
static FORCEINLINE HRESULT IXmlWriter_WriteStartElement(IXmlWriter* This,LPCWSTR pwszPrefix,LPCWSTR pwszLocalName,LPCWSTR pwszNamespaceUri) {
    return This->lpVtbl->WriteStartElement(This,pwszPrefix,pwszLocalName,pwszNamespaceUri);
}
static FORCEINLINE HRESULT IXmlWriter_WriteString(IXmlWriter* This,LPCWSTR pwszText) {
    return This->lpVtbl->WriteString(This,pwszText);
}
static FORCEINLINE HRESULT IXmlWriter_WriteSurrogateCharEntity(IXmlWriter* This,WCHAR wchLow,WCHAR wchHigh) {
    return This->lpVtbl->WriteSurrogateCharEntity(This,wchLow,wchHigh);
}
static FORCEINLINE HRESULT IXmlWriter_WriteWhitespace(IXmlWriter* This,LPCWSTR pwszWhitespace) {
    return This->lpVtbl->WriteWhitespace(This,pwszWhitespace);
}
static FORCEINLINE HRESULT IXmlWriter_Flush(IXmlWriter* This) {
    return This->lpVtbl->Flush(This);
}
#endif
#endif

#endif

HRESULT STDMETHODCALLTYPE IXmlWriter_SetOutput_Proxy(
    IXmlWriter* This,
    IUnknown *pOutput);
void __RPC_STUB IXmlWriter_SetOutput_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_GetProperty_Proxy(
    IXmlWriter* This,
    UINT nProperty,
    LONG_PTR *ppValue);
void __RPC_STUB IXmlWriter_GetProperty_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_SetProperty_Proxy(
    IXmlWriter* This,
    UINT nProperty,
    LONG_PTR pValue);
void __RPC_STUB IXmlWriter_SetProperty_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteAttributes_Proxy(
    IXmlWriter* This,
    IXmlReader *pReader,
    WINBOOL fWriteDefaultAttributes);
void __RPC_STUB IXmlWriter_WriteAttributes_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteAttributeString_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszPrefix,
    LPCWSTR pwszLocalName,
    LPCWSTR pwszNamespaceUri,
    LPCWSTR pwszValue);
void __RPC_STUB IXmlWriter_WriteAttributeString_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteCData_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszText);
void __RPC_STUB IXmlWriter_WriteCData_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteCharEntity_Proxy(
    IXmlWriter* This,
    WCHAR wch);
void __RPC_STUB IXmlWriter_WriteCharEntity_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteChars_Proxy(
    IXmlWriter* This,
    const WCHAR *pwch,
    UINT cwch);
void __RPC_STUB IXmlWriter_WriteChars_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteComment_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszComment);
void __RPC_STUB IXmlWriter_WriteComment_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteDocType_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszName,
    LPCWSTR pwszPublicId,
    LPCWSTR pwszSystemId,
    LPCWSTR pwszSubset);
void __RPC_STUB IXmlWriter_WriteDocType_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteElementString_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszPrefix,
    LPCWSTR pwszLocalName,
    LPCWSTR pwszNamespaceUri,
    LPCWSTR pwszValue);
void __RPC_STUB IXmlWriter_WriteElementString_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteEndDocument_Proxy(
    IXmlWriter* This);
void __RPC_STUB IXmlWriter_WriteEndDocument_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteEndElement_Proxy(
    IXmlWriter* This);
void __RPC_STUB IXmlWriter_WriteEndElement_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteEntityRef_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszName);
void __RPC_STUB IXmlWriter_WriteEntityRef_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteFullEndElement_Proxy(
    IXmlWriter* This);
void __RPC_STUB IXmlWriter_WriteFullEndElement_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteName_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszName);
void __RPC_STUB IXmlWriter_WriteName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteNmToken_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszNmToken);
void __RPC_STUB IXmlWriter_WriteNmToken_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteNode_Proxy(
    IXmlWriter* This,
    IXmlReader *pReader,
    WINBOOL fWriteDefaultAttributes);
void __RPC_STUB IXmlWriter_WriteNode_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteNodeShallow_Proxy(
    IXmlWriter* This,
    IXmlReader *pReader,
    WINBOOL fWriteDefaultAttributes);
void __RPC_STUB IXmlWriter_WriteNodeShallow_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteProcessingInstruction_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszName,
    LPCWSTR pwszText);
void __RPC_STUB IXmlWriter_WriteProcessingInstruction_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteQualifiedName_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszLocalName,
    LPCWSTR pwszNamespaceUri);
void __RPC_STUB IXmlWriter_WriteQualifiedName_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteRaw_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszData);
void __RPC_STUB IXmlWriter_WriteRaw_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteRawChars_Proxy(
    IXmlWriter* This,
    const WCHAR *pwch,
    UINT cwch);
void __RPC_STUB IXmlWriter_WriteRawChars_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteStartDocument_Proxy(
    IXmlWriter* This,
    XmlStandalone standalone);
void __RPC_STUB IXmlWriter_WriteStartDocument_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteStartElement_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszPrefix,
    LPCWSTR pwszLocalName,
    LPCWSTR pwszNamespaceUri);
void __RPC_STUB IXmlWriter_WriteStartElement_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteString_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszText);
void __RPC_STUB IXmlWriter_WriteString_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteSurrogateCharEntity_Proxy(
    IXmlWriter* This,
    WCHAR wchLow,
    WCHAR wchHigh);
void __RPC_STUB IXmlWriter_WriteSurrogateCharEntity_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_WriteWhitespace_Proxy(
    IXmlWriter* This,
    LPCWSTR pwszWhitespace);
void __RPC_STUB IXmlWriter_WriteWhitespace_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);
HRESULT STDMETHODCALLTYPE IXmlWriter_Flush_Proxy(
    IXmlWriter* This);
void __RPC_STUB IXmlWriter_Flush_Stub(
    IRpcStubBuffer* This,
    IRpcChannelBuffer* pRpcChannelBuffer,
    PRPC_MESSAGE pRpcMessage,
    DWORD* pdwStubPhase);

#endif  /* __IXmlWriter_INTERFACE_DEFINED__ */

/* Begin additional prototypes for all interfaces */


/* End additional prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __xmllite_h__ */
                                                                                                                                                                                                                                                                                                                                      usr/share/mingw-w64/include/xmltrnsf.h                                                              0100644 0000000 0000000 00000065032 12404413015 016370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error This stub requires an updated version of <rpcndr.h>
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif

#ifndef __xmltrnsf_h__
#define __xmltrnsf_h__

#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef struct IWmiXMLTransformer IWmiXMLTransformer;
#endif

#ifndef __WmiXMLTransformer_FWD_DEFINED__
#define __WmiXMLTransformer_FWD_DEFINED__
#ifdef __cplusplus
typedef class WmiXMLTransformer WmiXMLTransformer;
#else
typedef struct WmiXMLTransformer WmiXMLTransformer;
#endif
#endif

#ifndef __ISWbemXMLDocumentSet_FWD_DEFINED__
#define __ISWbemXMLDocumentSet_FWD_DEFINED__
typedef struct ISWbemXMLDocumentSet ISWbemXMLDocumentSet;
#endif

#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef struct IWmiXMLTransformer IWmiXMLTransformer;
#endif

#include "msxml.h"
#include "wbemdisp.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __MIDL_user_allocate_free_DEFINED__
#define__MIDL_user_allocate_free_DEFINED__
  void *__RPC_API MIDL_user_allocate(size_t);
  void __RPC_API MIDL_user_free(void *);
#endif

#ifndef __WmiXMLTransformer_LIBRARY_DEFINED__
#define __WmiXMLTransformer_LIBRARY_DEFINED__

  typedef enum WmiXMLEncoding {
    wmiXML_CIM_DTD_2_0 = 0,wmiXML_WMI_DTD_2_0 = 0x1,wmiXML_WMI_DTD_WHISTLER = 0x2
  } WmiXMLEncoding;

  typedef enum WmiXMLCompilationTypeEnum {
    WmiXMLCompilationWellFormCheck = 0,WmiXMLCompilationValidityCheck = 0x1,WmiXMLCompilationFullCompileAndLoad = 0x2
  } WmiXMLCompilationTypeEnum;

  EXTERN_C const IID LIBID_WmiXMLTransformer;
#ifndef __IWmiXMLTransformer_INTERFACE_DEFINED__
#define __IWmiXMLTransformer_INTERFACE_DEFINED__
  EXTERN_C const IID IID_IWmiXMLTransformer;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct IWmiXMLTransformer : public IDispatch {
  public:
    virtual HRESULT WINAPI get_XMLEncodingType(WmiXMLEncoding *piEncoding) = 0;
    virtual HRESULT WINAPI put_XMLEncodingType(WmiXMLEncoding iEncoding) = 0;
    virtual HRESULT WINAPI get_QualifierFilter(VARIANT_BOOL *bQualifierFilter) = 0;
    virtual HRESULT WINAPI put_QualifierFilter(VARIANT_BOOL bQualifierFilter) = 0;
    virtual HRESULT WINAPI get_ClassOriginFilter(VARIANT_BOOL *bClassOriginFilter) = 0;
    virtual HRESULT WINAPI put_ClassOriginFilter(VARIANT_BOOL bClassOriginFilter) = 0;
    virtual HRESULT WINAPI get_User(BSTR *strUser) = 0;
    virtual HRESULT WINAPI put_User(BSTR strUser) = 0;
    virtual HRESULT WINAPI get_Password(BSTR *strPassword) = 0;
    virtual HRESULT WINAPI put_Password(BSTR strPassword) = 0;
    virtual HRESULT WINAPI get_Authority(BSTR *strAuthority) = 0;
    virtual HRESULT WINAPI put_Authority(BSTR strAuthority) = 0;
    virtual HRESULT WINAPI get_ImpersonationLevel(DWORD *pdwImpersonationLevel) = 0;
    virtual HRESULT WINAPI put_ImpersonationLevel(DWORD dwImpersonationLevel) = 0;
    virtual HRESULT WINAPI get_AuthenticationLevel(DWORD *pdwAuthenticationLevel) = 0;
    virtual HRESULT WINAPI put_AuthenticationLevel(DWORD dwAuthenticationLevel) = 0;
    virtual HRESULT WINAPI get_Locale(BSTR *strLocale) = 0;
    virtual HRESULT WINAPI put_Locale(BSTR strLocale) = 0;
    virtual HRESULT WINAPI get_LocalOnly(VARIANT_BOOL *bLocalOnly) = 0;
    virtual HRESULT WINAPI put_LocalOnly(VARIANT_BOOL bLocalOnly) = 0;
    virtual HRESULT WINAPI GetObject(BSTR strObjectPath,IDispatch *pCtx,IXMLDOMDocument **ppXMLDocument) = 0;
    virtual HRESULT WINAPI ExecQuery(BSTR strNamespacePath,BSTR strQuery,BSTR strQueryLanguage,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
    virtual HRESULT WINAPI EnumClasses(BSTR strSuperClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
    virtual HRESULT WINAPI EnumInstances(BSTR strClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
    virtual HRESULT WINAPI EnumClassNames(BSTR strSuperClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
    virtual HRESULT WINAPI EnumInstanceNames(BSTR strClassPath,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
    virtual HRESULT WINAPI Compile(VARIANT *pvInputSource,BSTR strNamespacePath,LONG lClassFlags,LONG lInstanceFlags,WmiXMLCompilationTypeEnum iOperation,IDispatch *pCtx,VARIANT_BOOL *pStatus) = 0;
    virtual HRESULT WINAPI get_Privileges(ISWbemPrivilegeSet **objWbemPrivilegeSet) = 0;
    virtual HRESULT WINAPI get_CompilationErrors(BSTR *pstrErrors) = 0;
  };
#else
  typedef struct IWmiXMLTransformerVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(IWmiXMLTransformer *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(IWmiXMLTransformer *This);
      ULONG (WINAPI *Release)(IWmiXMLTransformer *This);
      HRESULT (WINAPI *GetTypeInfoCount)(IWmiXMLTransformer *This,UINT *pctinfo);
      HRESULT (WINAPI *GetTypeInfo)(IWmiXMLTransformer *This,UINT iTInfo,LCID lcid,ITypeInfo **ppTInfo);
      HRESULT (WINAPI *GetIDsOfNames)(IWmiXMLTransformer *This,REFIID riid,LPOLESTR *rgszNames,UINT cNames,LCID lcid,DISPID *rgDispId);
      HRESULT (WINAPI *Invoke)(IWmiXMLTransformer *This,DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);
      HRESULT (WINAPI *get_XMLEncodingType)(IWmiXMLTransformer *This,WmiXMLEncoding *piEncoding);
      HRESULT (WINAPI *put_XMLEncodingType)(IWmiXMLTransformer *This,WmiXMLEncoding iEncoding);
      HRESULT (WINAPI *get_QualifierFilter)(IWmiXMLTransformer *This,VARIANT_BOOL *bQualifierFilter);
      HRESULT (WINAPI *put_QualifierFilter)(IWmiXMLTransformer *This,VARIANT_BOOL bQualifierFilter);
      HRESULT (WINAPI *get_ClassOriginFilter)(IWmiXMLTransformer *This,VARIANT_BOOL *bClassOriginFilter);
      HRESULT (WINAPI *put_ClassOriginFilter)(IWmiXMLTransformer *This,VARIANT_BOOL bClassOriginFilter);
      HRESULT (WINAPI *get_User)(IWmiXMLTransformer *This,BSTR *strUser);
      HRESULT (WINAPI *put_User)(IWmiXMLTransformer *This,BSTR strUser);
      HRESULT (WINAPI *get_Password)(IWmiXMLTransformer *This,BSTR *strPassword);
      HRESULT (WINAPI *put_Password)(IWmiXMLTransformer *This,BSTR strPassword);
      HRESULT (WINAPI *get_Authority)(IWmiXMLTransformer *This,BSTR *strAuthority);
      HRESULT (WINAPI *put_Authority)(IWmiXMLTransformer *This,BSTR strAuthority);
      HRESULT (WINAPI *get_ImpersonationLevel)(IWmiXMLTransformer *This,DWORD *pdwImpersonationLevel);
      HRESULT (WINAPI *put_ImpersonationLevel)(IWmiXMLTransformer *This,DWORD dwImpersonationLevel);
      HRESULT (WINAPI *get_AuthenticationLevel)(IWmiXMLTransformer *This,DWORD *pdwAuthenticationLevel);
      HRESULT (WINAPI *put_AuthenticationLevel)(IWmiXMLTransformer *This,DWORD dwAuthenticationLevel);
      HRESULT (WINAPI *get_Locale)(IWmiXMLTransformer *This,BSTR *strLocale);
      HRESULT (WINAPI *put_Locale)(IWmiXMLTransformer *This,BSTR strLocale);
      HRESULT (WINAPI *get_LocalOnly)(IWmiXMLTransformer *This,VARIANT_BOOL *bLocalOnly);
      HRESULT (WINAPI *put_LocalOnly)(IWmiXMLTransformer *This,VARIANT_BOOL bLocalOnly);
      HRESULT (WINAPI *GetObject)(IWmiXMLTransformer *This,BSTR strObjectPath,IDispatch *pCtx,IXMLDOMDocument **ppXMLDocument);
      HRESULT (WINAPI *ExecQuery)(IWmiXMLTransformer *This,BSTR strNamespacePath,BSTR strQuery,BSTR strQueryLanguage,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
      HRESULT (WINAPI *EnumClasses)(IWmiXMLTransformer *This,BSTR strSuperClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
      HRESULT (WINAPI *EnumInstances)(IWmiXMLTransformer *This,BSTR strClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
      HRESULT (WINAPI *EnumClassNames)(IWmiXMLTransformer *This,BSTR strSuperClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
      HRESULT (WINAPI *EnumInstanceNames)(IWmiXMLTransformer *This,BSTR strClassPath,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
      HRESULT (WINAPI *Compile)(IWmiXMLTransformer *This,VARIANT *pvInputSource,BSTR strNamespacePath,LONG lClassFlags,LONG lInstanceFlags,WmiXMLCompilationTypeEnum iOperation,IDispatch *pCtx,VARIANT_BOOL *pStatus);
      HRESULT (WINAPI *get_Privileges)(IWmiXMLTransformer *This,ISWbemPrivilegeSet **objWbemPrivilegeSet);
      HRESULT (WINAPI *get_CompilationErrors)(IWmiXMLTransformer *This,BSTR *pstrErrors);
    END_INTERFACE
  } IWmiXMLTransformerVtbl;
  struct IWmiXMLTransformer {
    CONST_VTBL struct IWmiXMLTransformerVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define IWmiXMLTransformer_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define IWmiXMLTransformer_AddRef(This) (This)->lpVtbl->AddRef(This)
#define IWmiXMLTransformer_Release(This) (This)->lpVtbl->Release(This)
#define IWmiXMLTransformer_GetTypeInfoCount(This,pctinfo) (This)->lpVtbl->GetTypeInfoCount(This,pctinfo)
#define IWmiXMLTransformer_GetTypeInfo(This,iTInfo,lcid,ppTInfo) (This)->lpVtbl->GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define IWmiXMLTransformer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) (This)->lpVtbl->GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define IWmiXMLTransformer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) (This)->lpVtbl->Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define IWmiXMLTransformer_get_XMLEncodingType(This,piEncoding) (This)->lpVtbl->get_XMLEncodingType(This,piEncoding)
#define IWmiXMLTransformer_put_XMLEncodingType(This,iEncoding) (This)->lpVtbl->put_XMLEncodingType(This,iEncoding)
#define IWmiXMLTransformer_get_QualifierFilter(This,bQualifierFilter) (This)->lpVtbl->get_QualifierFilter(This,bQualifierFilter)
#define IWmiXMLTransformer_put_QualifierFilter(This,bQualifierFilter) (This)->lpVtbl->put_QualifierFilter(This,bQualifierFilter)
#define IWmiXMLTransformer_get_ClassOriginFilter(This,bClassOriginFilter) (This)->lpVtbl->get_ClassOriginFilter(This,bClassOriginFilter)
#define IWmiXMLTransformer_put_ClassOriginFilter(This,bClassOriginFilter) (This)->lpVtbl->put_ClassOriginFilter(This,bClassOriginFilter)
#define IWmiXMLTransformer_get_User(This,strUser) (This)->lpVtbl->get_User(This,strUser)
#define IWmiXMLTransformer_put_User(This,strUser) (This)->lpVtbl->put_User(This,strUser)
#define IWmiXMLTransformer_get_Password(This,strPassword) (This)->lpVtbl->get_Password(This,strPassword)
#define IWmiXMLTransformer_put_Password(This,strPassword) (This)->lpVtbl->put_Password(This,strPassword)
#define IWmiXMLTransformer_get_Authority(This,strAuthority) (This)->lpVtbl->get_Authority(This,strAuthority)
#define IWmiXMLTransformer_put_Authority(This,strAuthority) (This)->lpVtbl->put_Authority(This,strAuthority)
#define IWmiXMLTransformer_get_ImpersonationLevel(This,pdwImpersonationLevel) (This)->lpVtbl->get_ImpersonationLevel(This,pdwImpersonationLevel)
#define IWmiXMLTransformer_put_ImpersonationLevel(This,dwImpersonationLevel) (This)->lpVtbl->put_ImpersonationLevel(This,dwImpersonationLevel)
#define IWmiXMLTransformer_get_AuthenticationLevel(This,pdwAuthenticationLevel) (This)->lpVtbl->get_AuthenticationLevel(This,pdwAuthenticationLevel)
#define IWmiXMLTransformer_put_AuthenticationLevel(This,dwAuthenticationLevel) (This)->lpVtbl->put_AuthenticationLevel(This,dwAuthenticationLevel)
#define IWmiXMLTransformer_get_Locale(This,strLocale) (This)->lpVtbl->get_Locale(This,strLocale)
#define IWmiXMLTransformer_put_Locale(This,strLocale) (This)->lpVtbl->put_Locale(This,strLocale)
#define IWmiXMLTransformer_get_LocalOnly(This,bLocalOnly) (This)->lpVtbl->get_LocalOnly(This,bLocalOnly)
#define IWmiXMLTransformer_put_LocalOnly(This,bLocalOnly) (This)->lpVtbl->put_LocalOnly(This,bLocalOnly)
#define IWmiXMLTransformer_GetObject(This,strObjectPath,pCtx,ppXMLDocument) (This)->lpVtbl->GetObject(This,strObjectPath,pCtx,ppXMLDocument)
#define IWmiXMLTransformer_ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet) (This)->lpVtbl->ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet)
#define IWmiXMLTransformer_EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet) (This)->lpVtbl->EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)
#define IWmiXMLTransformer_EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet) (This)->lpVtbl->EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet)
#define IWmiXMLTransformer_EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet) (This)->lpVtbl->EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)
#define IWmiXMLTransformer_EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet) (This)->lpVtbl->EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet)
#define IWmiXMLTransformer_Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus) (This)->lpVtbl->Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus)
#define IWmiXMLTransformer_get_Privileges(This,objWbemPrivilegeSet) (This)->lpVtbl->get_Privileges(This,objWbemPrivilegeSet)
#define IWmiXMLTransformer_get_CompilationErrors(This,pstrErrors) (This)->lpVtbl->get_CompilationErrors(This,pstrErrors)
#endif
#endif
  HRESULT WINAPI IWmiXMLTransformer_get_XMLEncodingType_Proxy(IWmiXMLTransformer *This,WmiXMLEncoding *piEncoding);
  void __RPC_STUB IWmiXMLTransformer_get_XMLEncodingType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_XMLEncodingType_Proxy(IWmiXMLTransformer *This,WmiXMLEncoding iEncoding);
  void __RPC_STUB IWmiXMLTransformer_put_XMLEncodingType_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_QualifierFilter_Proxy(IWmiXMLTransformer *This,VARIANT_BOOL *bQualifierFilter);
  void __RPC_STUB IWmiXMLTransformer_get_QualifierFilter_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_QualifierFilter_Proxy(IWmiXMLTransformer *This,VARIANT_BOOL bQualifierFilter);
  void __RPC_STUB IWmiXMLTransformer_put_QualifierFilter_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_ClassOriginFilter_Proxy(IWmiXMLTransformer *This,VARIANT_BOOL *bClassOriginFilter);
  void __RPC_STUB IWmiXMLTransformer_get_ClassOriginFilter_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_ClassOriginFilter_Proxy(IWmiXMLTransformer *This,VARIANT_BOOL bClassOriginFilter);
  void __RPC_STUB IWmiXMLTransformer_put_ClassOriginFilter_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_User_Proxy(IWmiXMLTransformer *This,BSTR *strUser);
  void __RPC_STUB IWmiXMLTransformer_get_User_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_User_Proxy(IWmiXMLTransformer *This,BSTR strUser);
  void __RPC_STUB IWmiXMLTransformer_put_User_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_Password_Proxy(IWmiXMLTransformer *This,BSTR *strPassword);
  void __RPC_STUB IWmiXMLTransformer_get_Password_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_Password_Proxy(IWmiXMLTransformer *This,BSTR strPassword);
  void __RPC_STUB IWmiXMLTransformer_put_Password_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_Authority_Proxy(IWmiXMLTransformer *This,BSTR *strAuthority);
  void __RPC_STUB IWmiXMLTransformer_get_Authority_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_Authority_Proxy(IWmiXMLTransformer *This,BSTR strAuthority);
  void __RPC_STUB IWmiXMLTransformer_put_Authority_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_ImpersonationLevel_Proxy(IWmiXMLTransformer *This,DWORD *pdwImpersonationLevel);
  void __RPC_STUB IWmiXMLTransformer_get_ImpersonationLevel_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_ImpersonationLevel_Proxy(IWmiXMLTransformer *This,DWORD dwImpersonationLevel);
  void __RPC_STUB IWmiXMLTransformer_put_ImpersonationLevel_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_AuthenticationLevel_Proxy(IWmiXMLTransformer *This,DWORD *pdwAuthenticationLevel);
  void __RPC_STUB IWmiXMLTransformer_get_AuthenticationLevel_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_AuthenticationLevel_Proxy(IWmiXMLTransformer *This,DWORD dwAuthenticationLevel);
  void __RPC_STUB IWmiXMLTransformer_put_AuthenticationLevel_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_Locale_Proxy(IWmiXMLTransformer *This,BSTR *strLocale);
  void __RPC_STUB IWmiXMLTransformer_get_Locale_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_Locale_Proxy(IWmiXMLTransformer *This,BSTR strLocale);
  void __RPC_STUB IWmiXMLTransformer_put_Locale_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_LocalOnly_Proxy(IWmiXMLTransformer *This,VARIANT_BOOL *bLocalOnly);
  void __RPC_STUB IWmiXMLTransformer_get_LocalOnly_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_put_LocalOnly_Proxy(IWmiXMLTransformer *This,VARIANT_BOOL bLocalOnly);
  void __RPC_STUB IWmiXMLTransformer_put_LocalOnly_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_GetObject_Proxy(IWmiXMLTransformer *This,BSTR strObjectPath,IDispatch *pCtx,IXMLDOMDocument **ppXMLDocument);
  void __RPC_STUB IWmiXMLTransformer_GetObject_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_ExecQuery_Proxy(IWmiXMLTransformer *This,BSTR strNamespacePath,BSTR strQuery,BSTR strQueryLanguage,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
  void __RPC_STUB IWmiXMLTransformer_ExecQuery_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_EnumClasses_Proxy(IWmiXMLTransformer *This,BSTR strSuperClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
  void __RPC_STUB IWmiXMLTransformer_EnumClasses_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_EnumInstances_Proxy(IWmiXMLTransformer *This,BSTR strClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
  void __RPC_STUB IWmiXMLTransformer_EnumInstances_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_EnumClassNames_Proxy(IWmiXMLTransformer *This,BSTR strSuperClassPath,VARIANT_BOOL bDeep,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
  void __RPC_STUB IWmiXMLTransformer_EnumClassNames_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_EnumInstanceNames_Proxy(IWmiXMLTransformer *This,BSTR strClassPath,IDispatch *pCtx,ISWbemXMLDocumentSet **ppXMLDocumentSet);
  void __RPC_STUB IWmiXMLTransformer_EnumInstanceNames_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_Compile_Proxy(IWmiXMLTransformer *This,VARIANT *pvInputSource,BSTR strNamespacePath,LONG lClassFlags,LONG lInstanceFlags,WmiXMLCompilationTypeEnum iOperation,IDispatch *pCtx,VARIANT_BOOL *pStatus);
  void __RPC_STUB IWmiXMLTransformer_Compile_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_Privileges_Proxy(IWmiXMLTransformer *This,ISWbemPrivilegeSet **objWbemPrivilegeSet);
  void __RPC_STUB IWmiXMLTransformer_get_Privileges_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI IWmiXMLTransformer_get_CompilationErrors_Proxy(IWmiXMLTransformer *This,BSTR *pstrErrors);
  void __RPC_STUB IWmiXMLTransformer_get_CompilationErrors_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

  EXTERN_C const CLSID CLSID_WmiXMLTransformer;
#ifdef __cplusplus
  class WmiXMLTransformer;
#endif
#endif

#ifndef __ISWbemXMLDocumentSet_INTERFACE_DEFINED__
#define __ISWbemXMLDocumentSet_INTERFACE_DEFINED__
  EXTERN_C const IID IID_ISWbemXMLDocumentSet;
#if defined(__cplusplus) && !defined(CINTERFACE)
  struct ISWbemXMLDocumentSet : public IDispatch {
  public:
    virtual HRESULT WINAPI get__NewEnum(IUnknown **pUnk) = 0;
    virtual HRESULT WINAPI Item(BSTR strObjectPath,__LONG32 iFlags,IXMLDOMDocument **ppXMLDocument) = 0;
    virtual HRESULT WINAPI get_Count(__LONG32 *iCount) = 0;
    virtual HRESULT WINAPI NextDocument(IXMLDOMDocument **ppDoc) = 0;
    virtual HRESULT WINAPI SkipNextDocument(void) = 0;
  };
#else
  typedef struct ISWbemXMLDocumentSetVtbl {
    BEGIN_INTERFACE
      HRESULT (WINAPI *QueryInterface)(ISWbemXMLDocumentSet *This,REFIID riid,void **ppvObject);
      ULONG (WINAPI *AddRef)(ISWbemXMLDocumentSet *This);
      ULONG (WINAPI *Release)(ISWbemXMLDocumentSet *This);
      HRESULT (WINAPI *GetTypeInfoCount)(ISWbemXMLDocumentSet *This,UINT *pctinfo);
      HRESULT (WINAPI *GetTypeInfo)(ISWbemXMLDocumentSet *This,UINT iTInfo,LCID lcid,ITypeInfo **ppTInfo);
      HRESULT (WINAPI *GetIDsOfNames)(ISWbemXMLDocumentSet *This,REFIID riid,LPOLESTR *rgszNames,UINT cNames,LCID lcid,DISPID *rgDispId);
      HRESULT (WINAPI *Invoke)(ISWbemXMLDocumentSet *This,DISPID dispIdMember,REFIID riid,LCID lcid,WORD wFlags,DISPPARAMS *pDispParams,VARIANT *pVarResult,EXCEPINFO *pExcepInfo,UINT *puArgErr);
      HRESULT (WINAPI *get__NewEnum)(ISWbemXMLDocumentSet *This,IUnknown **pUnk);
      HRESULT (WINAPI *Item)(ISWbemXMLDocumentSet *This,BSTR strObjectPath,__LONG32 iFlags,IXMLDOMDocument **ppXMLDocument);
      HRESULT (WINAPI *get_Count)(ISWbemXMLDocumentSet *This,__LONG32 *iCount);
      HRESULT (WINAPI *NextDocument)(ISWbemXMLDocumentSet *This,IXMLDOMDocument **ppDoc);
      HRESULT (WINAPI *SkipNextDocument)(ISWbemXMLDocumentSet *This);
    END_INTERFACE
  } ISWbemXMLDocumentSetVtbl;
  struct ISWbemXMLDocumentSet {
    CONST_VTBL struct ISWbemXMLDocumentSetVtbl *lpVtbl;
  };
#ifdef COBJMACROS
#define ISWbemXMLDocumentSet_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
#define ISWbemXMLDocumentSet_AddRef(This) (This)->lpVtbl->AddRef(This)
#define ISWbemXMLDocumentSet_Release(This) (This)->lpVtbl->Release(This)
#define ISWbemXMLDocumentSet_GetTypeInfoCount(This,pctinfo) (This)->lpVtbl->GetTypeInfoCount(This,pctinfo)
#define ISWbemXMLDocumentSet_GetTypeInfo(This,iTInfo,lcid,ppTInfo) (This)->lpVtbl->GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ISWbemXMLDocumentSet_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) (This)->lpVtbl->GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ISWbemXMLDocumentSet_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) (This)->lpVtbl->Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define ISWbemXMLDocumentSet_get__NewEnum(This,pUnk) (This)->lpVtbl->get__NewEnum(This,pUnk)
#define ISWbemXMLDocumentSet_Item(This,strObjectPath,iFlags,ppXMLDocument) (This)->lpVtbl->Item(This,strObjectPath,iFlags,ppXMLDocument)
#define ISWbemXMLDocumentSet_get_Count(This,iCount) (This)->lpVtbl->get_Count(This,iCount)
#define ISWbemXMLDocumentSet_NextDocument(This,ppDoc) (This)->lpVtbl->NextDocument(This,ppDoc)
#define ISWbemXMLDocumentSet_SkipNextDocument(This) (This)->lpVtbl->SkipNextDocument(This)
#endif
#endif
  HRESULT WINAPI ISWbemXMLDocumentSet_get__NewEnum_Proxy(ISWbemXMLDocumentSet *This,IUnknown **pUnk);
  void __RPC_STUB ISWbemXMLDocumentSet_get__NewEnum_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ISWbemXMLDocumentSet_Item_Proxy(ISWbemXMLDocumentSet *This,BSTR strObjectPath,__LONG32 iFlags,IXMLDOMDocument **ppXMLDocument);
  void __RPC_STUB ISWbemXMLDocumentSet_Item_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ISWbemXMLDocumentSet_get_Count_Proxy(ISWbemXMLDocumentSet *This,__LONG32 *iCount);
  void __RPC_STUB ISWbemXMLDocumentSet_get_Count_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ISWbemXMLDocumentSet_NextDocument_Proxy(ISWbemXMLDocumentSet *This,IXMLDOMDocument **ppDoc);
  void __RPC_STUB ISWbemXMLDocumentSet_NextDocument_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
  HRESULT WINAPI ISWbemXMLDocumentSet_SkipNextDocument_Proxy(ISWbemXMLDocumentSet *This);
  void __RPC_STUB ISWbemXMLDocumentSet_SkipNextDocument_Stub(IRpcStubBuffer *This,IRpcChannelBuffer *_pRpcChannelBuffer,PRPC_MESSAGE _pRpcMessage,DWORD *_pdwStubPhase);
#endif

#ifdef __cplusplus
}
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/mingw-w64/include/xolehlp.h                                                               0100644 0000000 0000000 00000003443 12404413015 016164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef __XOLEHLP__H__
#define __XOLEHLP__H__

#include <_mingw_unicode.h>

#define EXPORTAPI __declspec(dllexport) HRESULT

const DWORD OLE_TM_CONFIG_VERSION_1 = 1;
const DWORD OLE_TM_FLAG_NONE = 0x00000000;
const DWORD OLE_TM_FLAG_NODEMANDSTART = 0x00000001;

const DWORD OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS = 0x80000000;
const DWORD OLE_TM_FLAG_INTERNAL_TO_TM = 0x40000000;

typedef struct _OLE_TM_CONFIG_PARAMS_V1 {
  DWORD dwVersion;
  DWORD dwcConcurrencyHint;
} OLE_TM_CONFIG_PARAMS_V1;

#define DtcGetTransactionManagerEx __MINGW_NAME_AW(DtcGetTransactionManagerEx)

EXPORTAPI __cdecl DtcGetTransactionManager(char *i_pszHost,char *i_pszTmName,REFIID i_riid,DWORD i_dwReserved1,WORD i_wcbReserved2,void *i_pvReserved2,void **o_ppvObject);
EXTERN_C HRESULT __cdecl DtcGetTransactionManagerC(char *i_pszHost,char *i_pszTmName,REFIID i_riid,DWORD i_dwReserved1,WORD i_wcbReserved2,void *i_pvReserved2,void **o_ppvObject);
EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExA(char *i_pszHost,char *i_pszTmName,REFIID i_riid,DWORD i_grfOptions,void *i_pvConfigParams,void **o_ppvObject);
EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExW(WCHAR *i_pwszHost,WCHAR *i_pwszTmName,REFIID i_riid,DWORD i_grfOptions,void *i_pvConfigParams,void **o_ppvObject);

#ifndef EXTERN_GUID
#define EXTERN_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) DEFINE_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)
#endif

EXTERN_GUID(CLSID_MSDtcTransactionManager,0x5b18ab61,0x91d,0x11d1,0x97,0xdf,0x0,0xc0,0x4f,0xb9,0x61,0x8a);
EXTERN_GUID(CLSID_MSDtcTransaction,0x39f8d76b,0x928,0x11d1,0x97,0xdf,0x0,0xc0,0x4f,0xb9,0x61,0x8a);
#endif
                                                                                                                                                                                                                             usr/share/mingw-w64/include/ymath.h                                                                 0100644 0000000 0000000 00000002712 12404413015 015631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _YMATH
#define _YMATH
#include <yvals.h>
_C_STD_BEGIN
_C_LIB_DECL

#pragma pack(push,_CRT_PACKING)

#define _DENORM (-2)
#define _FINITE (-1)
#define _INFCODE 1
#define _NANCODE 2

#define _FE_DIVBYZERO 0x04
#define _FE_INEXACT 0x20
#define _FE_INVALID 0x01
#define _FE_OVERFLOW 0x08
#define _FE_UNDERFLOW 0x10

typedef union {
  unsigned short _Word[8];
  float _Float;
  double _Double;
  long double _Long_double;
} _Dconst;

void __cdecl _Feraise(int);
_CRTIMP double __cdecl _Cosh(double,double);
_CRTIMP short __cdecl _Dtest(double *);
_CRTIMP short __cdecl _Exp(double *,double,short);
_CRTIMP double __cdecl _Sinh(double,double);
extern _CRTIMP _Dconst _Denorm,_Hugeval,_Inf,_Nan,_Snan;
_CRTIMP float __cdecl _FCosh(float,float);
_CRTIMP short __cdecl _FDtest(float *);
_CRTIMP short __cdecl _FExp(float *,float,short);
_CRTIMP float __cdecl _FSinh(float,float);
extern _CRTIMP _Dconst _FDenorm,_FInf,_FNan,_FSnan;
_CRTIMP long double __cdecl _LCosh(long double,long double);
_CRTIMP short __cdecl _LDtest(long double *);
_CRTIMP short __cdecl _LExp(long double *,long double,short);
_CRTIMP long double __cdecl _LSinh(long double,long double);
extern _CRTIMP _Dconst _LDenorm,_LInf,_LNan,_LSnan;
_END_C_LIB_DECL
_C_STD_END

#pragma pack(pop)
#endif
                                                      usr/share/mingw-w64/include/yvals.h                                                                 0100644 0000000 0000000 00000014073 12404413015 015650  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */
#ifndef _YVALS
#define _YVALS

#include <crtdefs.h>

#pragma pack(push,_CRT_PACKING)

#define _CPPLIB_VER 405
#define __PURE_APPDOMAIN_GLOBAL

#ifndef __CRTDECL
#define __CRTDECL __cdecl
#endif

#define _WIN32_C_LIB 1

#define _MULTI_THREAD 1
#define _IOSTREAM_OP_LOCKS 1
#define _GLOBAL_LOCALE 0

#define _COMPILER_TLS 1
#define _TLS_QUAL __declspec(thread)

#ifndef _HAS_EXCEPTIONS
#define _HAS_EXCEPTIONS 1
#endif

#ifndef _HAS_NAMESPACE
#define _HAS_NAMESPACE 1
#endif

#ifndef _HAS_IMMUTABLE_SETS
#define _HAS_IMMUTABLE_SETS 0
#endif

#ifndef _HAS_STRICT_CONFORMANCE
#define _HAS_STRICT_CONFORMANCE 0
#endif

#define _GLOBAL_USING 1
#define _HAS_ITERATOR_DEBUGGING 0

#define __STR2WSTR(str) L##str
#define _STR2WSTR(str) __STR2WSTR(str)

#define __FILEW__ _STR2WSTR(__FILE__)
#define __FUNCTIONW__ _STR2WSTR(__FUNCTION__)

#define _SCL_SECURE_INVALID_PARAMETER(expr) ::_invalid_parameter_noinfo()

#define _SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT _SCL_SECURE_INVALID_PARAMETER("invalid argument")
#define _SCL_SECURE_OUT_OF_RANGE_NO_ASSERT _SCL_SECURE_INVALID_PARAMETER("out of range")
#define _SCL_SECURE_ALWAYS_VALIDATE(cond) { if (!(cond)) { _ASSERTE((#cond,0)); _SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT; } }

#define _SCL_SECURE_ALWAYS_VALIDATE_RANGE(cond) { if (!(cond)) { _ASSERTE((#cond,0)); _SCL_SECURE_OUT_OF_RANGE_NO_ASSERT; } }

#define _SCL_SECURE_CRT_VALIDATE(cond,retvalue) { if (!(cond)) { _ASSERTE((#cond,0)); _SCL_SECURE_INVALID_PARAMETER(cond); return (retvalue); } }

#define _SCL_SECURE_VALIDATE(cond)
#define _SCL_SECURE_VALIDATE_RANGE(cond)

#define _SCL_SECURE_INVALID_ARGUMENT
#define _SCL_SECURE_OUT_OF_RANGE

#define _SCL_SECURE_MOVE(func,dst,size,src,count) func((dst),(src),(count))
#define _SCL_SECURE_COPY(func,dst,size,src,count) func((dst),(src),(count))

#define _SECURE_VALIDATION _Secure_validation

#define _SECURE_VALIDATION_DEFAULT false

#define _SCL_SECURE_TRAITS_VALIDATE(cond)
#define _SCL_SECURE_TRAITS_VALIDATE_RANGE(cond)

#define _SCL_SECURE_TRAITS_INVALID_ARGUMENT
#define _SCL_SECURE_TRAITS_OUT_OF_RANGE

#define _CRT_SECURE_MEMCPY(dest,destsize,source,count) ::memcpy((dest),(source),(count))
#define _CRT_SECURE_MEMMOVE(dest,destsize,source,count) ::memmove((dest),(source),(count))
#define _CRT_SECURE_WMEMCPY(dest,destsize,source,count) ::wmemcpy((dest),(source),(count))
#define _CRT_SECURE_WMEMMOVE(dest,destsize,source,count) ::wmemmove((dest),(source),(count))

#ifndef _VC6SP2
#define _VC6SP2 0
#endif

#ifndef _CRTIMP2_NCEEPURE
#define _CRTIMP2_NCEEPURE _CRTIMP
#endif

#ifndef _MRTIMP2_NPURE
#define _MRTIMP2_NPURE
#endif

#ifndef _MRTIMP2_NCEE
#define _MRTIMP2_NCEE _CRTIMP
#endif

#ifndef _MRTIMP2_NCEEPURE
#define _MRTIMP2_NCEEPURE _CRTIMP
#endif

#ifndef _MRTIMP2_NPURE_NCEEPURE
#define _MRTIMP2_NPURE_NCEEPURE
#endif

#define _DLL_CPPLIB

#ifndef _CRTIMP2_PURE
#define _CRTIMP2_PURE _CRTIMP
#endif

#ifndef _CRTDATA2
#define _CRTDATA2 _CRTIMP
#endif

#define _DEPRECATED

#ifdef __cplusplus
#define _STD_BEGIN namespace std {
#define _STD_END }
#define _STD ::std::

#define _STDEXT_BEGIN namespace stdext {
#define _STDEXT_END }
#define _STDEXT ::stdext::

#ifdef _STD_USING
#define _C_STD_BEGIN namespace std {
#define _C_STD_END }
#define _CSTD ::std::
#else

#define _C_STD_BEGIN
#define _C_STD_END
#define _CSTD ::
#endif

#define _C_LIB_DECL extern "C" {
#define _END_C_LIB_DECL }
#define _EXTERN_C extern "C" {
#define _END_EXTERN_C }
#else
#define _STD_BEGIN
#define _STD_END
#define _STD

#define _C_STD_BEGIN
#define _C_STD_END
#define _CSTD

#define _C_LIB_DECL
#define _END_C_LIB_DECL
#define _EXTERN_C
#define _END_EXTERN_C
#endif

#define _Restrict __restrict__

#ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
#endif

#define _LONGLONG /* __MINGW_EXTENSION */ __int64
#define _ULONGLONG /* __MINGW_EXTENSION */ unsigned __int64
#define _LLONG_MAX 0x7fffffffffffffffLL
#define _ULLONG_MAX 0xffffffffffffffffULL

#define _C2 1

#define _MAX_EXP_DIG 8
#define _MAX_INT_DIG 32
#define _MAX_SIG_DIG 36

__MINGW_EXTENSION typedef _LONGLONG _Longlong;
__MINGW_EXTENSION typedef _ULONGLONG _ULonglong;

#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp) ((long)(fp))
#endif

#define _IOBASE _base
#define _IOPTR _ptr
#define _IOCNT _cnt

#define _LOCK_LOCALE 0
#define _LOCK_MALLOC 1
#define _LOCK_STREAM 2
#define _LOCK_DEBUG 3
#define _MAX_LOCK 4

#ifdef __cplusplus
_STD_BEGIN

class _CRTIMP _Lockit {
public:
  explicit __thiscall _Lockit();
  explicit __thiscall _Lockit(int);
  __thiscall ~_Lockit();
  static void __cdecl _Lockit_ctor(int);
  static void __cdecl _Lockit_dtor(int);
private:
  static void __cdecl _Lockit_ctor(_Lockit *);
  static void __cdecl _Lockit_ctor(_Lockit *,int);
  static void __cdecl _Lockit_dtor(_Lockit *);
  _Lockit(const _Lockit&);
  _Lockit& operator=(const _Lockit&);
  int _Locktype;
};

#define _BEGIN_LOCK(_Kind) { _STD _Lockit _Lock(_Kind);
#define _END_LOCK() }
#define _BEGIN_LOCINFO(_VarName) { _Locinfo _VarName;
#define _END_LOCINFO() }
#define _RELIABILITY_CONTRACT

class _CRTIMP _Mutex {
public:
  __thiscall _Mutex();
  __thiscall ~_Mutex();
  void __thiscall _Lock();
  void __thiscall _Unlock();
private:
  static void __cdecl _Mutex_ctor(_Mutex *);
  static void __cdecl _Mutex_dtor(_Mutex *);
  static void __cdecl _Mutex_Lock(_Mutex *);
  static void __cdecl _Mutex_Unlock(_Mutex *);
  _Mutex(const _Mutex&);
  _Mutex& operator=(const _Mutex&);
  void *_Mtx;
};

class _CRTIMP _Init_locks {
public:
  __thiscall _Init_locks();
  __thiscall ~_Init_locks();
private:
  static void __cdecl _Init_locks_ctor(_Init_locks *);
  static void __cdecl _Init_locks_dtor(_Init_locks *);
};

_STD_END
#endif

#ifndef _RELIABILITY_CONTRACT
#define _RELIABILITY_CONTRACT
#endif

_C_STD_BEGIN
_CRTIMP void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;

#define _ATEXIT_T void
#define _Mbstinit(x) mbstate_t x = {0}
_C_STD_END

#define _EXTERN_TEMPLATE template
#define _THROW_BAD_ALLOC _THROW1(...)

#pragma pack(pop)
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/mingw-w64/include/zmouse.h                                                                0100644 0000000 0000000 00000003305 12404413015 016030  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

#include <_mingw_unicode.h>
#include <psdk_inc/_push_BOOL.h>

#define MSH_MOUSEWHEEL __MINGW_STRING_AW("MSWHEEL_ROLLMSG")

#define WHEEL_DELTA 120

#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)
#endif

#define MOUSEZ_CLASSNAME __MINGW_STRING_AW("MouseZ")
#define MOUSEZ_TITLE __MINGW_STRING_AW("Magellan MSWHEEL")

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

#define MSH_WHEELSUPPORT __MINGW_STRING_AW("MSH_WHEELSUPPORT_MSG")
#define MSH_SCROLL_LINES __MINGW_STRING_AW("MSH_SCROLL_LINES_MSG")

#ifndef WHEEL_PAGESCROLL
#define WHEEL_PAGESCROLL (UINT_MAX)
#endif

#ifndef SPI_SETWHEELSCROLLLINES
#define SPI_SETWHEELSCROLLLINES 105
#endif

#ifndef __CRT__NO_INLINE
__CRT_INLINE HWND HwndMSWheel(PUINT puiMsh_MsgMouseWheel,PUINT puiMsh_Msg3DSupport,PUINT puiMsh_MsgScrollLines,PBOOL pf3DSupport,PINT piScrollLines) {
  HWND hdlMsWheel;
  hdlMsWheel = FindWindow(MSH_WHEELMODULE_CLASS,MSH_WHEELMODULE_TITLE);
  *puiMsh_MsgMouseWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);
  *puiMsh_Msg3DSupport = RegisterWindowMessage(MSH_WHEELSUPPORT);
  *puiMsh_MsgScrollLines = RegisterWindowMessage(MSH_SCROLL_LINES);
  if(*puiMsh_Msg3DSupport) *pf3DSupport = (BOOL)SendMessage(hdlMsWheel,*puiMsh_Msg3DSupport,0,0);
  else *pf3DSupport = FALSE;
  if(*puiMsh_MsgScrollLines) *piScrollLines = (int)SendMessage(hdlMsWheel,*puiMsh_MsgScrollLines,0,0);
  else *piScrollLines = 3;
  return(hdlMsWheel);
}
#endif /* !__CRT__NO_INLINE */
#include <psdk_inc/_pop_BOOL.h>

                                                                                                                                                                                                                                                                                                                           usr/share/misc/                                                                                     0040755 0000000 0000000 00000000000 13077704277 012134  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/misc/config.guess                                                                         0100755 0000000 0000000 00000123550 12404676534 014454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /bin/sh
# Attempt to guess a canonical system name.
#   Copyright 1992-2014 Free Software Foundation, Inc.

timestamp='2014-03-23'

# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that
# program.  This Exception is an additional permission under section 7
# of the GNU General Public License, version 3 ("GPLv3").
#
# Originally written by Per Bothner.
#
# You can get the latest version of this script from:
# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
#
# Please send patches with a ChangeLog entry to config-patches@gnu.org.


me=`echo "$0" | sed -e 's,.*/,,'`

usage="\
Usage: $0 [OPTION]

Output the configuration name of the system \`$me' is run on.

Operation modes:
  -h, --help         print this help, then exit
  -t, --time-stamp   print date of last modification, then exit
  -v, --version      print version number, then exit

Report bugs and patches to <config-patches@gnu.org>."

version="\
GNU config.guess ($timestamp)

Originally written by Per Bothner.
Copyright 1992-2014 Free Software Foundation, Inc.

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."

help="
Try \`$me --help' for more information."

# Parse command line
while test $# -gt 0 ; do
  case $1 in
    --time-stamp | --time* | -t )
       echo "$timestamp" ; exit ;;
    --version | -v )
       echo "$version" ; exit ;;
    --help | --h* | -h )
       echo "$usage"; exit ;;
    -- )     # Stop option processing
       shift; break ;;
    - )	# Use stdin as input.
       break ;;
    -* )
       echo "$me: invalid option $1$help" >&2
       exit 1 ;;
    * )
       break ;;
  esac
done

if test $# != 0; then
  echo "$me: too many arguments$help" >&2
  exit 1
fi

trap 'exit 1' 1 2 15

# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
# compiler to aid in system detection is discouraged as it requires
# temporary files to be created and, as you can see below, it is a
# headache to deal with in a portable fashion.

# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
# use `HOST_CC' if defined, but it is deprecated.

# Portable tmp directory creation inspired by the Autoconf team.

set_cc_for_build='
trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
: ${TMPDIR=/tmp} ;
 { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
 { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
 { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
 { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
dummy=$tmp/dummy ;
tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
case $CC_FOR_BUILD,$HOST_CC,$CC in
 ,,)    echo "int x;" > $dummy.c ;
	for c in cc gcc c89 c99 ; do
	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
	     CC_FOR_BUILD="$c"; break ;
	  fi ;
	done ;
	if test x"$CC_FOR_BUILD" = x ; then
	  CC_FOR_BUILD=no_compiler_found ;
	fi
	;;
 ,,*)   CC_FOR_BUILD=$CC ;;
 ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
esac ; set_cc_for_build= ;'

# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
# (ghazi@noc.rutgers.edu 1994-08-24)
if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
	PATH=$PATH:/.attbin ; export PATH
fi

UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown

case "${UNAME_SYSTEM}" in
Linux|GNU|GNU/*)
	# If the system lacks a compiler, then just pick glibc.
	# We could probably try harder.
	LIBC=gnu

	eval $set_cc_for_build
	cat <<-EOF > $dummy.c
	#include <features.h>
	#if defined(__UCLIBC__)
	LIBC=uclibc
	#elif defined(__dietlibc__)
	LIBC=dietlibc
	#else
	LIBC=gnu
	#endif
	EOF
	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
	;;
esac

# Note: order is significant - the case branches are not exclusive.

case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
    *:NetBSD:*:*)
	# NetBSD (nbsd) targets should (where applicable) match one or
	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
	# switched to ELF, *-*-netbsd* would select the old
	# object file format.  This provides both forward
	# compatibility and a consistent mechanism for selecting the
	# object file format.
	#
	# Note: NetBSD doesn't particularly care about the vendor
	# portion of the name.  We always set it to "unknown".
	sysctl="sysctl -n hw.machine_arch"
	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
	case "${UNAME_MACHINE_ARCH}" in
	    armeb) machine=armeb-unknown ;;
	    arm*) machine=arm-unknown ;;
	    sh3el) machine=shl-unknown ;;
	    sh3eb) machine=sh-unknown ;;
	    sh5el) machine=sh5le-unknown ;;
	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
	esac
	# The Operating System including object format, if it has switched
	# to ELF recently, or will in the future.
	case "${UNAME_MACHINE_ARCH}" in
	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
		eval $set_cc_for_build
		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
			| grep -q __ELF__
		then
		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
		    # Return netbsd for either.  FIX?
		    os=netbsd
		else
		    os=netbsdelf
		fi
		;;
	    *)
		os=netbsd
		;;
	esac
	# The OS release
	# Debian GNU/NetBSD machines have a different userland, and
	# thus, need a distinct triplet. However, they do not need
	# kernel version information, so it can be replaced with a
	# suitable tag, in the style of linux-gnu.
	case "${UNAME_VERSION}" in
	    Debian*)
		release='-gnu'
		;;
	    *)
		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
		;;
	esac
	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
	# contains redundant information, the shorter form:
	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
	echo "${machine}-${os}${release}"
	exit ;;
    *:Bitrig:*:*)
	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
	exit ;;
    *:OpenBSD:*:*)
	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
	exit ;;
    *:ekkoBSD:*:*)
	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
	exit ;;
    *:SolidBSD:*:*)
	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
	exit ;;
    macppc:MirBSD:*:*)
	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
	exit ;;
    *:MirBSD:*:*)
	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
	exit ;;
    alpha:OSF1:*:*)
	case $UNAME_RELEASE in
	*4.0)
		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
		;;
	*5.*)
		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
		;;
	esac
	# According to Compaq, /usr/sbin/psrinfo has been available on
	# OSF/1 and Tru64 systems produced since 1995.  I hope that
	# covers most systems running today.  This code pipes the CPU
	# types through head -n 1, so we only detect the type of CPU 0.
	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
	case "$ALPHA_CPU_TYPE" in
	    "EV4 (21064)")
		UNAME_MACHINE="alpha" ;;
	    "EV4.5 (21064)")
		UNAME_MACHINE="alpha" ;;
	    "LCA4 (21066/21068)")
		UNAME_MACHINE="alpha" ;;
	    "EV5 (21164)")
		UNAME_MACHINE="alphaev5" ;;
	    "EV5.6 (21164A)")
		UNAME_MACHINE="alphaev56" ;;
	    "EV5.6 (21164PC)")
		UNAME_MACHINE="alphapca56" ;;
	    "EV5.7 (21164PC)")
		UNAME_MACHINE="alphapca57" ;;
	    "EV6 (21264)")
		UNAME_MACHINE="alphaev6" ;;
	    "EV6.7 (21264A)")
		UNAME_MACHINE="alphaev67" ;;
	    "EV6.8CB (21264C)")
		UNAME_MACHINE="alphaev68" ;;
	    "EV6.8AL (21264B)")
		UNAME_MACHINE="alphaev68" ;;
	    "EV6.8CX (21264D)")
		UNAME_MACHINE="alphaev68" ;;
	    "EV6.9A (21264/EV69A)")
		UNAME_MACHINE="alphaev69" ;;
	    "EV7 (21364)")
		UNAME_MACHINE="alphaev7" ;;
	    "EV7.9 (21364A)")
		UNAME_MACHINE="alphaev79" ;;
	esac
	# A Pn.n version is a patched version.
	# A Vn.n version is a released version.
	# A Tn.n version is a released field test version.
	# A Xn.n version is an unreleased experimental baselevel.
	# 1.2 uses "1.2" for uname -r.
	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
	exitcode=$?
	trap '' 0
	exit $exitcode ;;
    Alpha\ *:Windows_NT*:*)
	# How do we know it's Interix rather than the generic POSIX subsystem?
	# Should we change UNAME_MACHINE based on the output of uname instead
	# of the specific Alpha model?
	echo alpha-pc-interix
	exit ;;
    21064:Windows_NT:50:3)
	echo alpha-dec-winnt3.5
	exit ;;
    Amiga*:UNIX_System_V:4.0:*)
	echo m68k-unknown-sysv4
	exit ;;
    *:[Aa]miga[Oo][Ss]:*:*)
	echo ${UNAME_MACHINE}-unknown-amigaos
	exit ;;
    *:[Mm]orph[Oo][Ss]:*:*)
	echo ${UNAME_MACHINE}-unknown-morphos
	exit ;;
    *:OS/390:*:*)
	echo i370-ibm-openedition
	exit ;;
    *:z/VM:*:*)
	echo s390-ibm-zvmoe
	exit ;;
    *:OS400:*:*)
	echo powerpc-ibm-os400
	exit ;;
    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
	echo arm-acorn-riscix${UNAME_RELEASE}
	exit ;;
    arm*:riscos:*:*|arm*:RISCOS:*:*)
	echo arm-unknown-riscos
	exit ;;
    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
	echo hppa1.1-hitachi-hiuxmpp
	exit ;;
    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
	if test "`(/bin/universe) 2>/dev/null`" = att ; then
		echo pyramid-pyramid-sysv3
	else
		echo pyramid-pyramid-bsd
	fi
	exit ;;
    NILE*:*:*:dcosx)
	echo pyramid-pyramid-svr4
	exit ;;
    DRS?6000:unix:4.0:6*)
	echo sparc-icl-nx6
	exit ;;
    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
	case `/usr/bin/uname -p` in
	    sparc) echo sparc-icl-nx7; exit ;;
	esac ;;
    s390x:SunOS:*:*)
	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4H:SunOS:5.*:*)
	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
	echo i386-pc-auroraux${UNAME_RELEASE}
	exit ;;
    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
	eval $set_cc_for_build
	SUN_ARCH="i386"
	# If there is a compiler, see if it is configured for 64-bit objects.
	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
	# This test works for both compilers.
	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
		grep IS_64BIT_ARCH >/dev/null
	    then
		SUN_ARCH="x86_64"
	    fi
	fi
	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4*:SunOS:6*:*)
	# According to config.sub, this is the proper way to canonicalize
	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
	# it's likely to be more like Solaris than SunOS4.
	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4*:SunOS:*:*)
	case "`/usr/bin/arch -k`" in
	    Series*|S4*)
		UNAME_RELEASE=`uname -v`
		;;
	esac
	# Japanese Language versions have a version number like `4.1.3-JL'.
	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
	exit ;;
    sun3*:SunOS:*:*)
	echo m68k-sun-sunos${UNAME_RELEASE}
	exit ;;
    sun*:*:4.2BSD:*)
	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
	case "`/bin/arch`" in
	    sun3)
		echo m68k-sun-sunos${UNAME_RELEASE}
		;;
	    sun4)
		echo sparc-sun-sunos${UNAME_RELEASE}
		;;
	esac
	exit ;;
    aushp:SunOS:*:*)
	echo sparc-auspex-sunos${UNAME_RELEASE}
	exit ;;
    # The situation for MiNT is a little confusing.  The machine name
    # can be virtually everything (everything which is not
    # "atarist" or "atariste" at least should have a processor
    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
    # to the lowercase version "mint" (or "freemint").  Finally
    # the system name "TOS" denotes a system which is actually not
    # MiNT.  But MiNT is downward compatible to TOS, so this should
    # be no problem.
    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
	echo m68k-atari-mint${UNAME_RELEASE}
	exit ;;
    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
	echo m68k-atari-mint${UNAME_RELEASE}
	exit ;;
    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
	echo m68k-atari-mint${UNAME_RELEASE}
	exit ;;
    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
	echo m68k-milan-mint${UNAME_RELEASE}
	exit ;;
    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
	echo m68k-hades-mint${UNAME_RELEASE}
	exit ;;
    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
	echo m68k-unknown-mint${UNAME_RELEASE}
	exit ;;
    m68k:machten:*:*)
	echo m68k-apple-machten${UNAME_RELEASE}
	exit ;;
    powerpc:machten:*:*)
	echo powerpc-apple-machten${UNAME_RELEASE}
	exit ;;
    RISC*:Mach:*:*)
	echo mips-dec-mach_bsd4.3
	exit ;;
    RISC*:ULTRIX:*:*)
	echo mips-dec-ultrix${UNAME_RELEASE}
	exit ;;
    VAX*:ULTRIX*:*:*)
	echo vax-dec-ultrix${UNAME_RELEASE}
	exit ;;
    2020:CLIX:*:* | 2430:CLIX:*:*)
	echo clipper-intergraph-clix${UNAME_RELEASE}
	exit ;;
    mips:*:*:UMIPS | mips:*:*:RISCos)
	eval $set_cc_for_build
	sed 's/^	//' << EOF >$dummy.c
#ifdef __cplusplus
#include <stdio.h>  /* for printf() prototype */
	int main (int argc, char *argv[]) {
#else
	int main (argc, argv) int argc; char *argv[]; {
#endif
	#if defined (host_mips) && defined (MIPSEB)
	#if defined (SYSTYPE_SYSV)
	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
	#endif
	#if defined (SYSTYPE_SVR4)
	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
	#endif
	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
	#endif
	#endif
	  exit (-1);
	}
EOF
	$CC_FOR_BUILD -o $dummy $dummy.c &&
	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
	  SYSTEM_NAME=`$dummy $dummyarg` &&
	    { echo "$SYSTEM_NAME"; exit; }
	echo mips-mips-riscos${UNAME_RELEASE}
	exit ;;
    Motorola:PowerMAX_OS:*:*)
	echo powerpc-motorola-powermax
	exit ;;
    Motorola:*:4.3:PL8-*)
	echo powerpc-harris-powermax
	exit ;;
    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
	echo powerpc-harris-powermax
	exit ;;
    Night_Hawk:Power_UNIX:*:*)
	echo powerpc-harris-powerunix
	exit ;;
    m88k:CX/UX:7*:*)
	echo m88k-harris-cxux7
	exit ;;
    m88k:*:4*:R4*)
	echo m88k-motorola-sysv4
	exit ;;
    m88k:*:3*:R3*)
	echo m88k-motorola-sysv3
	exit ;;
    AViiON:dgux:*:*)
	# DG/UX returns AViiON for all architectures
	UNAME_PROCESSOR=`/usr/bin/uname -p`
	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
	then
	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
	       [ ${TARGET_BINARY_INTERFACE}x = x ]
	    then
		echo m88k-dg-dgux${UNAME_RELEASE}
	    else
		echo m88k-dg-dguxbcs${UNAME_RELEASE}
	    fi
	else
	    echo i586-dg-dgux${UNAME_RELEASE}
	fi
	exit ;;
    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
	echo m88k-dolphin-sysv3
	exit ;;
    M88*:*:R3*:*)
	# Delta 88k system running SVR3
	echo m88k-motorola-sysv3
	exit ;;
    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
	echo m88k-tektronix-sysv3
	exit ;;
    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
	echo m68k-tektronix-bsd
	exit ;;
    *:IRIX*:*:*)
	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
	exit ;;
    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
    i*86:AIX:*:*)
	echo i386-ibm-aix
	exit ;;
    ia64:AIX:*:*)
	if [ -x /usr/bin/oslevel ] ; then
		IBM_REV=`/usr/bin/oslevel`
	else
		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
	fi
	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
	exit ;;
    *:AIX:2:3)
	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
		eval $set_cc_for_build
		sed 's/^		//' << EOF >$dummy.c
		#include <sys/systemcfg.h>

		main()
			{
			if (!__power_pc())
				exit(1);
			puts("powerpc-ibm-aix3.2.5");
			exit(0);
			}
EOF
		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
		then
			echo "$SYSTEM_NAME"
		else
			echo rs6000-ibm-aix3.2.5
		fi
	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
		echo rs6000-ibm-aix3.2.4
	else
		echo rs6000-ibm-aix3.2
	fi
	exit ;;
    *:AIX:*:[4567])
	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
		IBM_ARCH=rs6000
	else
		IBM_ARCH=powerpc
	fi
	if [ -x /usr/bin/oslevel ] ; then
		IBM_REV=`/usr/bin/oslevel`
	else
		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
	fi
	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
	exit ;;
    *:AIX:*:*)
	echo rs6000-ibm-aix
	exit ;;
    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
	echo romp-ibm-bsd4.4
	exit ;;
    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
	exit ;;                             # report: romp-ibm BSD 4.3
    *:BOSX:*:*)
	echo rs6000-bull-bosx
	exit ;;
    DPX/2?00:B.O.S.:*:*)
	echo m68k-bull-sysv3
	exit ;;
    9000/[34]??:4.3bsd:1.*:*)
	echo m68k-hp-bsd
	exit ;;
    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
	echo m68k-hp-bsd4.4
	exit ;;
    9000/[34678]??:HP-UX:*:*)
	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
	case "${UNAME_MACHINE}" in
	    9000/31? )            HP_ARCH=m68000 ;;
	    9000/[34]?? )         HP_ARCH=m68k ;;
	    9000/[678][0-9][0-9])
		if [ -x /usr/bin/getconf ]; then
		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
		    case "${sc_cpu_version}" in
		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
		      532)                      # CPU_PA_RISC2_0
			case "${sc_kernel_bits}" in
			  32) HP_ARCH="hppa2.0n" ;;
			  64) HP_ARCH="hppa2.0w" ;;
			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
			esac ;;
		    esac
		fi
		if [ "${HP_ARCH}" = "" ]; then
		    eval $set_cc_for_build
		    sed 's/^		//' << EOF >$dummy.c

		#define _HPUX_SOURCE
		#include <stdlib.h>
		#include <unistd.h>

		int main ()
		{
		#if defined(_SC_KERNEL_BITS)
		    long bits = sysconf(_SC_KERNEL_BITS);
		#endif
		    long cpu  = sysconf (_SC_CPU_VERSION);

		    switch (cpu)
			{
			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
			case CPU_PA_RISC2_0:
		#if defined(_SC_KERNEL_BITS)
			    switch (bits)
				{
				case 64: puts ("hppa2.0w"); break;
				case 32: puts ("hppa2.0n"); break;
				default: puts ("hppa2.0"); break;
				} break;
		#else  /* !defined(_SC_KERNEL_BITS) */
			    puts ("hppa2.0"); break;
		#endif
			default: puts ("hppa1.0"); break;
			}
		    exit (0);
		}
EOF
		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
		    test -z "$HP_ARCH" && HP_ARCH=hppa
		fi ;;
	esac
	if [ ${HP_ARCH} = "hppa2.0w" ]
	then
	    eval $set_cc_for_build

	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
	    # generating 64-bit code.  GNU and HP use different nomenclature:
	    #
	    # $ CC_FOR_BUILD=cc ./config.guess
	    # => hppa2.0w-hp-hpux11.23
	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
	    # => hppa64-hp-hpux11.23

	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
		grep -q __LP64__
	    then
		HP_ARCH="hppa2.0w"
	    else
		HP_ARCH="hppa64"
	    fi
	fi
	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
	exit ;;
    ia64:HP-UX:*:*)
	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
	echo ia64-hp-hpux${HPUX_REV}
	exit ;;
    3050*:HI-UX:*:*)
	eval $set_cc_for_build
	sed 's/^	//' << EOF >$dummy.c
	#include <unistd.h>
	int
	main ()
	{
	  long cpu = sysconf (_SC_CPU_VERSION);
	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
	     results, however.  */
	  if (CPU_IS_PA_RISC (cpu))
	    {
	      switch (cpu)
		{
		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
		  default: puts ("hppa-hitachi-hiuxwe2"); break;
		}
	    }
	  else if (CPU_IS_HP_MC68K (cpu))
	    puts ("m68k-hitachi-hiuxwe2");
	  else puts ("unknown-hitachi-hiuxwe2");
	  exit (0);
	}
EOF
	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
		{ echo "$SYSTEM_NAME"; exit; }
	echo unknown-hitachi-hiuxwe2
	exit ;;
    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
	echo hppa1.1-hp-bsd
	exit ;;
    9000/8??:4.3bsd:*:*)
	echo hppa1.0-hp-bsd
	exit ;;
    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
	echo hppa1.0-hp-mpeix
	exit ;;
    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
	echo hppa1.1-hp-osf
	exit ;;
    hp8??:OSF1:*:*)
	echo hppa1.0-hp-osf
	exit ;;
    i*86:OSF1:*:*)
	if [ -x /usr/sbin/sysversion ] ; then
	    echo ${UNAME_MACHINE}-unknown-osf1mk
	else
	    echo ${UNAME_MACHINE}-unknown-osf1
	fi
	exit ;;
    parisc*:Lites*:*:*)
	echo hppa1.1-hp-lites
	exit ;;
    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
	echo c1-convex-bsd
	exit ;;
    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
	if getsysinfo -f scalar_acc
	then echo c32-convex-bsd
	else echo c2-convex-bsd
	fi
	exit ;;
    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
	echo c34-convex-bsd
	exit ;;
    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
	echo c38-convex-bsd
	exit ;;
    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
	echo c4-convex-bsd
	exit ;;
    CRAY*Y-MP:*:*:*)
	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*[A-Z]90:*:*:*)
	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
	      -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*TS:*:*:*)
	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*T3E:*:*:*)
	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*SV1:*:*:*)
	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    *:UNICOS/mp:*:*)
	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
	exit ;;
    5000:UNIX_System_V:4.*:*)
	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
	exit ;;
    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
	exit ;;
    sparc*:BSD/OS:*:*)
	echo sparc-unknown-bsdi${UNAME_RELEASE}
	exit ;;
    *:BSD/OS:*:*)
	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
	exit ;;
    *:FreeBSD:*:*)
	UNAME_PROCESSOR=`/usr/bin/uname -p`
	case ${UNAME_PROCESSOR} in
	    amd64)
		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
	    *)
		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
	esac
	exit ;;
    i*:CYGWIN*:*)
	echo ${UNAME_MACHINE}-pc-cygwin
	exit ;;
    *:MINGW64*:*)
	echo ${UNAME_MACHINE}-pc-mingw64
	exit ;;
    *:MINGW*:*)
	echo ${UNAME_MACHINE}-pc-mingw32
	exit ;;
    *:MSYS*:*)
	echo ${UNAME_MACHINE}-pc-msys
	exit ;;
    i*:windows32*:*)
	# uname -m includes "-pc" on this system.
	echo ${UNAME_MACHINE}-mingw32
	exit ;;
    i*:PW*:*)
	echo ${UNAME_MACHINE}-pc-pw32
	exit ;;
    *:Interix*:*)
	case ${UNAME_MACHINE} in
	    x86)
		echo i586-pc-interix${UNAME_RELEASE}
		exit ;;
	    authenticamd | genuineintel | EM64T)
		echo x86_64-unknown-interix${UNAME_RELEASE}
		exit ;;
	    IA64)
		echo ia64-unknown-interix${UNAME_RELEASE}
		exit ;;
	esac ;;
    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
	echo i${UNAME_MACHINE}-pc-mks
	exit ;;
    8664:Windows_NT:*)
	echo x86_64-pc-mks
	exit ;;
    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
	# How do we know it's Interix rather than the generic POSIX subsystem?
	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
	# UNAME_MACHINE based on the output of uname instead of i386?
	echo i586-pc-interix
	exit ;;
    i*:UWIN*:*)
	echo ${UNAME_MACHINE}-pc-uwin
	exit ;;
    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
	echo x86_64-unknown-cygwin
	exit ;;
    p*:CYGWIN*:*)
	echo powerpcle-unknown-cygwin
	exit ;;
    prep*:SunOS:5.*:*)
	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    *:GNU:*:*)
	# the GNU system
	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
	exit ;;
    *:GNU/*:*:*)
	# other systems with GNU libc and userland
	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
	exit ;;
    i*86:Minix:*:*)
	echo ${UNAME_MACHINE}-pc-minix
	exit ;;
    aarch64:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    aarch64_be:Linux:*:*)
	UNAME_MACHINE=aarch64_be
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    alpha:Linux:*:*)
	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
	  EV5)   UNAME_MACHINE=alphaev5 ;;
	  EV56)  UNAME_MACHINE=alphaev56 ;;
	  PCA56) UNAME_MACHINE=alphapca56 ;;
	  PCA57) UNAME_MACHINE=alphapca56 ;;
	  EV6)   UNAME_MACHINE=alphaev6 ;;
	  EV67)  UNAME_MACHINE=alphaev67 ;;
	  EV68*) UNAME_MACHINE=alphaev68 ;;
	esac
	objdump --private-headers /bin/sh | grep -q ld.so.1
	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    arc:Linux:*:* | arceb:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    arm*:Linux:*:*)
	eval $set_cc_for_build
	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
	    | grep -q __ARM_EABI__
	then
	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	else
	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
		| grep -q __ARM_PCS_VFP
	    then
		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
	    else
		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
	    fi
	fi
	exit ;;
    avr32*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    cris:Linux:*:*)
	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
	exit ;;
    crisv32:Linux:*:*)
	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
	exit ;;
    frv:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    hexagon:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    i*86:Linux:*:*)
	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
	exit ;;
    ia64:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    m32r*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    m68*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    mips:Linux:*:* | mips64:Linux:*:*)
	eval $set_cc_for_build
	sed 's/^	//' << EOF >$dummy.c
	#undef CPU
	#undef ${UNAME_MACHINE}
	#undef ${UNAME_MACHINE}el
	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
	CPU=${UNAME_MACHINE}el
	#else
	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
	CPU=${UNAME_MACHINE}
	#else
	CPU=
	#endif
	#endif
EOF
	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
	;;
    openrisc*:Linux:*:*)
	echo or1k-unknown-linux-${LIBC}
	exit ;;
    or32:Linux:*:* | or1k*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    padre:Linux:*:*)
	echo sparc-unknown-linux-${LIBC}
	exit ;;
    parisc64:Linux:*:* | hppa64:Linux:*:*)
	echo hppa64-unknown-linux-${LIBC}
	exit ;;
    parisc:Linux:*:* | hppa:Linux:*:*)
	# Look for CPU level
	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
	  *)    echo hppa-unknown-linux-${LIBC} ;;
	esac
	exit ;;
    ppc64:Linux:*:*)
	echo powerpc64-unknown-linux-${LIBC}
	exit ;;
    ppc:Linux:*:*)
	echo powerpc-unknown-linux-${LIBC}
	exit ;;
    ppc64le:Linux:*:*)
	echo powerpc64le-unknown-linux-${LIBC}
	exit ;;
    ppcle:Linux:*:*)
	echo powerpcle-unknown-linux-${LIBC}
	exit ;;
    s390:Linux:*:* | s390x:Linux:*:*)
	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
	exit ;;
    sh64*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    sh*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    sparc:Linux:*:* | sparc64:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    tile*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    vax:Linux:*:*)
	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
	exit ;;
    x86_64:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    xtensa*:Linux:*:*)
	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
	exit ;;
    i*86:DYNIX/ptx:4*:*)
	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
	# earlier versions are messed up and put the nodename in both
	# sysname and nodename.
	echo i386-sequent-sysv4
	exit ;;
    i*86:UNIX_SV:4.2MP:2.*)
	# Unixware is an offshoot of SVR4, but it has its own version
	# number series starting with 2...
	# I am not positive that other SVR4 systems won't match this,
	# I just have to hope.  -- rms.
	# Use sysv4.2uw... so that sysv4* matches it.
	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
	exit ;;
    i*86:OS/2:*:*)
	# If we were able to find `uname', then EMX Unix compatibility
	# is probably installed.
	echo ${UNAME_MACHINE}-pc-os2-emx
	exit ;;
    i*86:XTS-300:*:STOP)
	echo ${UNAME_MACHINE}-unknown-stop
	exit ;;
    i*86:atheos:*:*)
	echo ${UNAME_MACHINE}-unknown-atheos
	exit ;;
    i*86:syllable:*:*)
	echo ${UNAME_MACHINE}-pc-syllable
	exit ;;
    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
	echo i386-unknown-lynxos${UNAME_RELEASE}
	exit ;;
    i*86:*DOS:*:*)
	echo ${UNAME_MACHINE}-pc-msdosdjgpp
	exit ;;
    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
	else
		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
	fi
	exit ;;
    i*86:*:5:[678]*)
	# UnixWare 7.x, OpenUNIX and OpenServer 6.
	case `/bin/uname -X | grep "^Machine"` in
	    *486*)	     UNAME_MACHINE=i486 ;;
	    *Pentium)	     UNAME_MACHINE=i586 ;;
	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
	esac
	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
	exit ;;
    i*86:*:3.2:*)
	if test -f /usr/options/cb.name; then
		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
	elif /bin/uname -X 2>/dev/null >/dev/null ; then
		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
			&& UNAME_MACHINE=i586
		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
			&& UNAME_MACHINE=i686
		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
			&& UNAME_MACHINE=i686
		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
	else
		echo ${UNAME_MACHINE}-pc-sysv32
	fi
	exit ;;
    pc:*:*:*)
	# Left here for compatibility:
	# uname -m prints for DJGPP always 'pc', but it prints nothing about
	# the processor, so we play safe by assuming i586.
	# Note: whatever this is, it MUST be the same as what config.sub
	# prints for the "djgpp" host, or else GDB configury will decide that
	# this is a cross-build.
	echo i586-pc-msdosdjgpp
	exit ;;
    Intel:Mach:3*:*)
	echo i386-pc-mach3
	exit ;;
    paragon:*:*:*)
	echo i860-intel-osf1
	exit ;;
    i860:*:4.*:*) # i860-SVR4
	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
	else # Add other i860-SVR4 vendors below as they are discovered.
	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
	fi
	exit ;;
    mini*:CTIX:SYS*5:*)
	# "miniframe"
	echo m68010-convergent-sysv
	exit ;;
    mc68k:UNIX:SYSTEM5:3.51m)
	echo m68k-convergent-sysv
	exit ;;
    M680?0:D-NIX:5.3:*)
	echo m68k-diab-dnix
	exit ;;
    M68*:*:R3V[5678]*:*)
	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
	OS_REL=''
	test -r /etc/.relid \
	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
	  && { echo i486-ncr-sysv4; exit; } ;;
    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
	OS_REL='.3'
	test -r /etc/.relid \
	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
	echo m68k-unknown-lynxos${UNAME_RELEASE}
	exit ;;
    mc68030:UNIX_System_V:4.*:*)
	echo m68k-atari-sysv4
	exit ;;
    TSUNAMI:LynxOS:2.*:*)
	echo sparc-unknown-lynxos${UNAME_RELEASE}
	exit ;;
    rs6000:LynxOS:2.*:*)
	echo rs6000-unknown-lynxos${UNAME_RELEASE}
	exit ;;
    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
	echo powerpc-unknown-lynxos${UNAME_RELEASE}
	exit ;;
    SM[BE]S:UNIX_SV:*:*)
	echo mips-dde-sysv${UNAME_RELEASE}
	exit ;;
    RM*:ReliantUNIX-*:*:*)
	echo mips-sni-sysv4
	exit ;;
    RM*:SINIX-*:*:*)
	echo mips-sni-sysv4
	exit ;;
    *:SINIX-*:*:*)
	if uname -p 2>/dev/null >/dev/null ; then
		UNAME_MACHINE=`(uname -p) 2>/dev/null`
		echo ${UNAME_MACHINE}-sni-sysv4
	else
		echo ns32k-sni-sysv
	fi
	exit ;;
    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
			# says <Richard.M.Bartel@ccMail.Census.GOV>
	echo i586-unisys-sysv4
	exit ;;
    *:UNIX_System_V:4*:FTX*)
	# From Gerald Hewes <hewes@openmarket.com>.
	# How about differentiating between stratus architectures? -djm
	echo hppa1.1-stratus-sysv4
	exit ;;
    *:*:*:FTX*)
	# From seanf@swdc.stratus.com.
	echo i860-stratus-sysv4
	exit ;;
    i*86:VOS:*:*)
	# From Paul.Green@stratus.com.
	echo ${UNAME_MACHINE}-stratus-vos
	exit ;;
    *:VOS:*:*)
	# From Paul.Green@stratus.com.
	echo hppa1.1-stratus-vos
	exit ;;
    mc68*:A/UX:*:*)
	echo m68k-apple-aux${UNAME_RELEASE}
	exit ;;
    news*:NEWS-OS:6*:*)
	echo mips-sony-newsos6
	exit ;;
    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
	if [ -d /usr/nec ]; then
		echo mips-nec-sysv${UNAME_RELEASE}
	else
		echo mips-unknown-sysv${UNAME_RELEASE}
	fi
	exit ;;
    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
	echo powerpc-be-beos
	exit ;;
    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
	echo powerpc-apple-beos
	exit ;;
    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
	echo i586-pc-beos
	exit ;;
    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
	echo i586-pc-haiku
	exit ;;
    x86_64:Haiku:*:*)
	echo x86_64-unknown-haiku
	exit ;;
    SX-4:SUPER-UX:*:*)
	echo sx4-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-5:SUPER-UX:*:*)
	echo sx5-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-6:SUPER-UX:*:*)
	echo sx6-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-7:SUPER-UX:*:*)
	echo sx7-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-8:SUPER-UX:*:*)
	echo sx8-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-8R:SUPER-UX:*:*)
	echo sx8r-nec-superux${UNAME_RELEASE}
	exit ;;
    Power*:Rhapsody:*:*)
	echo powerpc-apple-rhapsody${UNAME_RELEASE}
	exit ;;
    *:Rhapsody:*:*)
	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
	exit ;;
    *:Darwin:*:*)
	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
	eval $set_cc_for_build
	if test "$UNAME_PROCESSOR" = unknown ; then
	    UNAME_PROCESSOR=powerpc
	fi
	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
		    grep IS_64BIT_ARCH >/dev/null
		then
		    case $UNAME_PROCESSOR in
			i386) UNAME_PROCESSOR=x86_64 ;;
			powerpc) UNAME_PROCESSOR=powerpc64 ;;
		    esac
		fi
	    fi
	elif test "$UNAME_PROCESSOR" = i386 ; then
	    # Avoid executing cc on OS X 10.9, as it ships with a stub
	    # that puts up a graphical alert prompting to install
	    # developer tools.  Any system running Mac OS X 10.7 or
	    # later (Darwin 11 and later) is required to have a 64-bit
	    # processor. This is not true of the ARM version of Darwin
	    # that Apple uses in portable devices.
	    UNAME_PROCESSOR=x86_64
	fi
	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
	exit ;;
    *:procnto*:*:* | *:QNX:[0123456789]*:*)
	UNAME_PROCESSOR=`uname -p`
	if test "$UNAME_PROCESSOR" = "x86"; then
		UNAME_PROCESSOR=i386
		UNAME_MACHINE=pc
	fi
	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
	exit ;;
    *:QNX:*:4*)
	echo i386-pc-qnx
	exit ;;
    NEO-?:NONSTOP_KERNEL:*:*)
	echo neo-tandem-nsk${UNAME_RELEASE}
	exit ;;
    NSE-*:NONSTOP_KERNEL:*:*)
	echo nse-tandem-nsk${UNAME_RELEASE}
	exit ;;
    NSR-?:NONSTOP_KERNEL:*:*)
	echo nsr-tandem-nsk${UNAME_RELEASE}
	exit ;;
    *:NonStop-UX:*:*)
	echo mips-compaq-nonstopux
	exit ;;
    BS2000:POSIX*:*:*)
	echo bs2000-siemens-sysv
	exit ;;
    DS/*:UNIX_System_V:*:*)
	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
	exit ;;
    *:Plan9:*:*)
	# "uname -m" is not consistent, so use $cputype instead. 386
	# is converted to i386 for consistency with other x86
	# operating systems.
	if test "$cputype" = "386"; then
	    UNAME_MACHINE=i386
	else
	    UNAME_MACHINE="$cputype"
	fi
	echo ${UNAME_MACHINE}-unknown-plan9
	exit ;;
    *:TOPS-10:*:*)
	echo pdp10-unknown-tops10
	exit ;;
    *:TENEX:*:*)
	echo pdp10-unknown-tenex
	exit ;;
    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
	echo pdp10-dec-tops20
	exit ;;
    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
	echo pdp10-xkl-tops20
	exit ;;
    *:TOPS-20:*:*)
	echo pdp10-unknown-tops20
	exit ;;
    *:ITS:*:*)
	echo pdp10-unknown-its
	exit ;;
    SEI:*:*:SEIUX)
	echo mips-sei-seiux${UNAME_RELEASE}
	exit ;;
    *:DragonFly:*:*)
	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
	exit ;;
    *:*VMS:*:*)
	UNAME_MACHINE=`(uname -p) 2>/dev/null`
	case "${UNAME_MACHINE}" in
	    A*) echo alpha-dec-vms ; exit ;;
	    I*) echo ia64-dec-vms ; exit ;;
	    V*) echo vax-dec-vms ; exit ;;
	esac ;;
    *:XENIX:*:SysV)
	echo i386-pc-xenix
	exit ;;
    i*86:skyos:*:*)
	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
	exit ;;
    i*86:rdos:*:*)
	echo ${UNAME_MACHINE}-pc-rdos
	exit ;;
    i*86:AROS:*:*)
	echo ${UNAME_MACHINE}-pc-aros
	exit ;;
    x86_64:VMkernel:*:*)
	echo ${UNAME_MACHINE}-unknown-esx
	exit ;;
esac

cat >&2 <<EOF
$0: unable to guess system type

This script, last modified $timestamp, has failed to recognize
the operating system you are using. It is advised that you
download the most up to date version of the config scripts from

  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
and
  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD

If the version you run ($0) is already up to date, please
send the following data and any information you think might be
pertinent to <config-patches@gnu.org> in order to provide the needed
information to handle your system.

config.guess timestamp = $timestamp

uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`

hostinfo               = `(hostinfo) 2>/dev/null`
/bin/universe          = `(/bin/universe) 2>/dev/null`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
/bin/arch              = `(/bin/arch) 2>/dev/null`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`

UNAME_MACHINE = ${UNAME_MACHINE}
UNAME_RELEASE = ${UNAME_RELEASE}
UNAME_SYSTEM  = ${UNAME_SYSTEM}
UNAME_VERSION = ${UNAME_VERSION}
EOF

exit 1

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "timestamp='"
# time-stamp-format: "%:y-%02m-%02d"
# time-stamp-end: "'"
# End:
                                                                                                                                                        usr/share/misc/config.sub                                                                           0100755 0000000 0000000 00000105775 12404676534 014130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /bin/sh
# Configuration validation subroutine script.
#   Copyright 1992-2014 Free Software Foundation, Inc.

timestamp='2014-09-11'

# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that
# program.  This Exception is an additional permission under section 7
# of the GNU General Public License, version 3 ("GPLv3").


# Please send patches with a ChangeLog entry to config-patches@gnu.org.
#
# Configuration subroutine to validate and canonicalize a configuration type.
# Supply the specified configuration type as an argument.
# If it is invalid, we print an error message on stderr and exit with code 1.
# Otherwise, we print the canonical config type on stdout and succeed.

# You can get the latest version of this script from:
# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD

# This file is supposed to be the same for all GNU packages
# and recognize all the CPU types, system types and aliases
# that are meaningful with *any* GNU software.
# Each package is responsible for reporting which valid configurations
# it does not support.  The user should be able to distinguish
# a failure to support a valid configuration from a meaningless
# configuration.

# The goal of this file is to map all the various variations of a given
# machine specification into a single specification in the form:
#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
# or in some cases, the newer four-part form:
#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
# It is wrong to echo any other type of specification.

me=`echo "$0" | sed -e 's,.*/,,'`

usage="\
Usage: $0 [OPTION] CPU-MFR-OPSYS
       $0 [OPTION] ALIAS

Canonicalize a configuration name.

Operation modes:
  -h, --help         print this help, then exit
  -t, --time-stamp   print date of last modification, then exit
  -v, --version      print version number, then exit

Report bugs and patches to <config-patches@gnu.org>."

version="\
GNU config.sub ($timestamp)

Copyright 1992-2014 Free Software Foundation, Inc.

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."

help="
Try \`$me --help' for more information."

# Parse command line
while test $# -gt 0 ; do
  case $1 in
    --time-stamp | --time* | -t )
       echo "$timestamp" ; exit ;;
    --version | -v )
       echo "$version" ; exit ;;
    --help | --h* | -h )
       echo "$usage"; exit ;;
    -- )     # Stop option processing
       shift; break ;;
    - )	# Use stdin as input.
       break ;;
    -* )
       echo "$me: invalid option $1$help"
       exit 1 ;;

    *local*)
       # First pass through any local machine types.
       echo $1
       exit ;;

    * )
       break ;;
  esac
done

case $# in
 0) echo "$me: missing argument$help" >&2
    exit 1;;
 1) ;;
 *) echo "$me: too many arguments$help" >&2
    exit 1;;
esac

# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
# Here we must recognize all the valid KERNEL-OS combinations.
maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
case $maybe_os in
  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
  knetbsd*-gnu* | netbsd*-gnu* | \
  kopensolaris*-gnu* | \
  storm-chaos* | os2-emx* | rtmk-nova*)
    os=-$maybe_os
    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
    ;;
  android-linux)
    os=-linux-android
    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
    ;;
  *)
    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
    if [ $basic_machine != $1 ]
    then os=`echo $1 | sed 's/.*-/-/'`
    else os=; fi
    ;;
esac

### Let's recognize common machines as not being operating systems so
### that things like config.sub decstation-3100 work.  We also
### recognize some manufacturers as not being operating systems, so we
### can provide default operating systems below.
case $os in
	-sun*os*)
		# Prevent following clause from handling this invalid input.
		;;
	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
	-apple | -axis | -knuth | -cray | -microblaze*)
		os=
		basic_machine=$1
		;;
	-bluegene*)
		os=-cnk
		;;
	-sim | -cisco | -oki | -wec | -winbond)
		os=
		basic_machine=$1
		;;
	-scout)
		;;
	-wrs)
		os=-vxworks
		basic_machine=$1
		;;
	-chorusos*)
		os=-chorusos
		basic_machine=$1
		;;
	-chorusrdb)
		os=-chorusrdb
		basic_machine=$1
		;;
	-hiux*)
		os=-hiuxwe2
		;;
	-sco6)
		os=-sco5v6
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco5)
		os=-sco3.2v5
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco4)
		os=-sco3.2v4
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco3.2.[4-9]*)
		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco3.2v[4-9]*)
		# Don't forget version if it is 3.2v4 or newer.
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco5v6*)
		# Don't forget version if it is 3.2v4 or newer.
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco*)
		os=-sco3.2v2
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-udk*)
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-isc)
		os=-isc2.2
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-clix*)
		basic_machine=clipper-intergraph
		;;
	-isc*)
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-lynx*178)
		os=-lynxos178
		;;
	-lynx*5)
		os=-lynxos5
		;;
	-lynx*)
		os=-lynxos
		;;
	-ptx*)
		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
		;;
	-windowsnt*)
		os=`echo $os | sed -e 's/windowsnt/winnt/'`
		;;
	-psos*)
		os=-psos
		;;
	-mint | -mint[0-9]*)
		basic_machine=m68k-atari
		os=-mint
		;;
esac

# Decode aliases for certain CPU-COMPANY combinations.
case $basic_machine in
	# Recognize the basic CPU types without company name.
	# Some are omitted here because they have special meanings below.
	1750a | 580 \
	| a29k \
	| aarch64 | aarch64_be \
	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
	| am33_2.0 \
	| arc | arceb \
	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
	| avr | avr32 \
	| be32 | be64 \
	| bfin \
	| c4x | c8051 | clipper \
	| d10v | d30v | dlx | dsp16xx \
	| epiphany \
	| fido | fr30 | frv \
	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
	| hexagon \
	| i370 | i860 | i960 | ia64 \
	| ip2k | iq2000 \
	| k1om \
	| le32 | le64 \
	| lm32 \
	| m32c | m32r | m32rle | m68000 | m68k | m88k \
	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
	| mips | mipsbe | mipseb | mipsel | mipsle \
	| mips16 \
	| mips64 | mips64el \
	| mips64octeon | mips64octeonel \
	| mips64orion | mips64orionel \
	| mips64r5900 | mips64r5900el \
	| mips64vr | mips64vrel \
	| mips64vr4100 | mips64vr4100el \
	| mips64vr4300 | mips64vr4300el \
	| mips64vr5000 | mips64vr5000el \
	| mips64vr5900 | mips64vr5900el \
	| mipsisa32 | mipsisa32el \
	| mipsisa32r2 | mipsisa32r2el \
	| mipsisa32r6 | mipsisa32r6el \
	| mipsisa64 | mipsisa64el \
	| mipsisa64r2 | mipsisa64r2el \
	| mipsisa64r6 | mipsisa64r6el \
	| mipsisa64sb1 | mipsisa64sb1el \
	| mipsisa64sr71k | mipsisa64sr71kel \
	| mipsr5900 | mipsr5900el \
	| mipstx39 | mipstx39el \
	| mn10200 | mn10300 \
	| moxie \
	| mt \
	| msp430 \
	| nds32 | nds32le | nds32be \
	| nios | nios2 | nios2eb | nios2el \
	| ns16k | ns32k \
	| open8 | or1k | or1knd | or32 \
	| pdp10 | pdp11 | pj | pjl \
	| powerpc | powerpc64 | powerpc64le | powerpcle \
	| pyramid \
	| riscv32 | riscv64 \
	| rl78 | rx \
	| score \
	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
	| sh64 | sh64le \
	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
	| spu \
	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
	| ubicom32 \
	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
	| we32k \
	| x86 | xc16x | xstormy16 | xtensa \
	| z8k | z80)
		basic_machine=$basic_machine-unknown
		;;
	c54x)
		basic_machine=tic54x-unknown
		;;
	c55x)
		basic_machine=tic55x-unknown
		;;
	c6x)
		basic_machine=tic6x-unknown
		;;
	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
		basic_machine=$basic_machine-unknown
		os=-none
		;;
	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
		;;
	ms1)
		basic_machine=mt-unknown
		;;

	strongarm | thumb | xscale)
		basic_machine=arm-unknown
		;;
	xgate)
		basic_machine=$basic_machine-unknown
		os=-none
		;;
	xscaleeb)
		basic_machine=armeb-unknown
		;;

	xscaleel)
		basic_machine=armel-unknown
		;;

	# We use `pc' rather than `unknown'
	# because (1) that's what they normally are, and
	# (2) the word "unknown" tends to confuse beginning users.
	i*86 | x86_64)
	  basic_machine=$basic_machine-pc
	  ;;
	# Object if more than one company name word.
	*-*-*)
		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
		exit 1
		;;
	# Recognize the basic CPU types with company name.
	580-* \
	| a29k-* \
	| aarch64-* | aarch64_be-* \
	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
	| avr-* | avr32-* \
	| be32-* | be64-* \
	| bfin-* | bs2000-* \
	| c[123]* | c30-* | [cjt]90-* | c4x-* \
	| c8051-* | clipper-* | craynv-* | cydra-* \
	| d10v-* | d30v-* | dlx-* \
	| elxsi-* \
	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
	| h8300-* | h8500-* \
	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
	| hexagon-* \
	| i*86-* | i860-* | i960-* | ia64-* \
	| ip2k-* | iq2000-* \
	| k1om-* \
	| le32-* | le64-* \
	| lm32-* \
	| m32c-* | m32r-* | m32rle-* \
	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
	| microblaze-* | microblazeel-* \
	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
	| mips16-* \
	| mips64-* | mips64el-* \
	| mips64octeon-* | mips64octeonel-* \
	| mips64orion-* | mips64orionel-* \
	| mips64r5900-* | mips64r5900el-* \
	| mips64vr-* | mips64vrel-* \
	| mips64vr4100-* | mips64vr4100el-* \
	| mips64vr4300-* | mips64vr4300el-* \
	| mips64vr5000-* | mips64vr5000el-* \
	| mips64vr5900-* | mips64vr5900el-* \
	| mipsisa32-* | mipsisa32el-* \
	| mipsisa32r2-* | mipsisa32r2el-* \
	| mipsisa32r6-* | mipsisa32r6el-* \
	| mipsisa64-* | mipsisa64el-* \
	| mipsisa64r2-* | mipsisa64r2el-* \
	| mipsisa64r6-* | mipsisa64r6el-* \
	| mipsisa64sb1-* | mipsisa64sb1el-* \
	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
	| mipsr5900-* | mipsr5900el-* \
	| mipstx39-* | mipstx39el-* \
	| mmix-* \
	| mt-* \
	| msp430-* \
	| nds32-* | nds32le-* | nds32be-* \
	| nios-* | nios2-* | nios2eb-* | nios2el-* \
	| none-* | np1-* | ns16k-* | ns32k-* \
	| open8-* \
	| or1k*-* \
	| orion-* \
	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
	| pyramid-* \
	| rl78-* | romp-* | rs6000-* | rx-* \
	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
	| sparclite-* \
	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
	| tahoe-* \
	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
	| tile*-* \
	| tron-* \
	| ubicom32-* \
	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
	| vax-* \
	| we32k-* \
	| x86-* | x86_64-* | xc16x-* | xps100-* \
	| xstormy16-* | xtensa*-* \
	| ymp-* \
	| z8k-* | z80-*)
		;;
	# Recognize the basic CPU types without company name, with glob match.
	xtensa*)
		basic_machine=$basic_machine-unknown
		;;
	# Recognize the various machine names and aliases which stand
	# for a CPU type and a company and sometimes even an OS.
	386bsd)
		basic_machine=i386-unknown
		os=-bsd
		;;
	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
		basic_machine=m68000-att
		;;
	3b*)
		basic_machine=we32k-att
		;;
	a29khif)
		basic_machine=a29k-amd
		os=-udi
		;;
	abacus)
		basic_machine=abacus-unknown
		;;
	adobe68k)
		basic_machine=m68010-adobe
		os=-scout
		;;
	alliant | fx80)
		basic_machine=fx80-alliant
		;;
	altos | altos3068)
		basic_machine=m68k-altos
		;;
	am29k)
		basic_machine=a29k-none
		os=-bsd
		;;
	amd64)
		basic_machine=x86_64-pc
		;;
	amd64-*)
		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	amdahl)
		basic_machine=580-amdahl
		os=-sysv
		;;
	amiga | amiga-*)
		basic_machine=m68k-unknown
		;;
	amigaos | amigados)
		basic_machine=m68k-unknown
		os=-amigaos
		;;
	amigaunix | amix)
		basic_machine=m68k-unknown
		os=-sysv4
		;;
	apollo68)
		basic_machine=m68k-apollo
		os=-sysv
		;;
	apollo68bsd)
		basic_machine=m68k-apollo
		os=-bsd
		;;
	aros)
		basic_machine=i386-pc
		os=-aros
		;;
	aux)
		basic_machine=m68k-apple
		os=-aux
		;;
	balance)
		basic_machine=ns32k-sequent
		os=-dynix
		;;
	blackfin)
		basic_machine=bfin-unknown
		os=-linux
		;;
	blackfin-*)
		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
		os=-linux
		;;
	bluegene*)
		basic_machine=powerpc-ibm
		os=-cnk
		;;
	c54x-*)
		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	c55x-*)
		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	c6x-*)
		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	c90)
		basic_machine=c90-cray
		os=-unicos
		;;
	cegcc)
		basic_machine=arm-unknown
		os=-cegcc
		;;
	convex-c1)
		basic_machine=c1-convex
		os=-bsd
		;;
	convex-c2)
		basic_machine=c2-convex
		os=-bsd
		;;
	convex-c32)
		basic_machine=c32-convex
		os=-bsd
		;;
	convex-c34)
		basic_machine=c34-convex
		os=-bsd
		;;
	convex-c38)
		basic_machine=c38-convex
		os=-bsd
		;;
	cray | j90)
		basic_machine=j90-cray
		os=-unicos
		;;
	craynv)
		basic_machine=craynv-cray
		os=-unicosmp
		;;
	cr16 | cr16-*)
		basic_machine=cr16-unknown
		os=-elf
		;;
	crds | unos)
		basic_machine=m68k-crds
		;;
	crisv32 | crisv32-* | etraxfs*)
		basic_machine=crisv32-axis
		;;
	cris | cris-* | etrax*)
		basic_machine=cris-axis
		;;
	crx)
		basic_machine=crx-unknown
		os=-elf
		;;
	da30 | da30-*)
		basic_machine=m68k-da30
		;;
	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
		basic_machine=mips-dec
		;;
	decsystem10* | dec10*)
		basic_machine=pdp10-dec
		os=-tops10
		;;
	decsystem20* | dec20*)
		basic_machine=pdp10-dec
		os=-tops20
		;;
	delta | 3300 | motorola-3300 | motorola-delta \
	      | 3300-motorola | delta-motorola)
		basic_machine=m68k-motorola
		;;
	delta88)
		basic_machine=m88k-motorola
		os=-sysv3
		;;
	dicos)
		basic_machine=i686-pc
		os=-dicos
		;;
	djgpp)
		basic_machine=i586-pc
		os=-msdosdjgpp
		;;
	dpx20 | dpx20-*)
		basic_machine=rs6000-bull
		os=-bosx
		;;
	dpx2* | dpx2*-bull)
		basic_machine=m68k-bull
		os=-sysv3
		;;
	ebmon29k)
		basic_machine=a29k-amd
		os=-ebmon
		;;
	elxsi)
		basic_machine=elxsi-elxsi
		os=-bsd
		;;
	encore | umax | mmax)
		basic_machine=ns32k-encore
		;;
	es1800 | OSE68k | ose68k | ose | OSE)
		basic_machine=m68k-ericsson
		os=-ose
		;;
	fx2800)
		basic_machine=i860-alliant
		;;
	genix)
		basic_machine=ns32k-ns
		;;
	gmicro)
		basic_machine=tron-gmicro
		os=-sysv
		;;
	go32)
		basic_machine=i386-pc
		os=-go32
		;;
	h3050r* | hiux*)
		basic_machine=hppa1.1-hitachi
		os=-hiuxwe2
		;;
	h8300hms)
		basic_machine=h8300-hitachi
		os=-hms
		;;
	h8300xray)
		basic_machine=h8300-hitachi
		os=-xray
		;;
	h8500hms)
		basic_machine=h8500-hitachi
		os=-hms
		;;
	harris)
		basic_machine=m88k-harris
		os=-sysv3
		;;
	hp300-*)
		basic_machine=m68k-hp
		;;
	hp300bsd)
		basic_machine=m68k-hp
		os=-bsd
		;;
	hp300hpux)
		basic_machine=m68k-hp
		os=-hpux
		;;
	hp3k9[0-9][0-9] | hp9[0-9][0-9])
		basic_machine=hppa1.0-hp
		;;
	hp9k2[0-9][0-9] | hp9k31[0-9])
		basic_machine=m68000-hp
		;;
	hp9k3[2-9][0-9])
		basic_machine=m68k-hp
		;;
	hp9k6[0-9][0-9] | hp6[0-9][0-9])
		basic_machine=hppa1.0-hp
		;;
	hp9k7[0-79][0-9] | hp7[0-79][0-9])
		basic_machine=hppa1.1-hp
		;;
	hp9k78[0-9] | hp78[0-9])
		# FIXME: really hppa2.0-hp
		basic_machine=hppa1.1-hp
		;;
	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
		# FIXME: really hppa2.0-hp
		basic_machine=hppa1.1-hp
		;;
	hp9k8[0-9][13679] | hp8[0-9][13679])
		basic_machine=hppa1.1-hp
		;;
	hp9k8[0-9][0-9] | hp8[0-9][0-9])
		basic_machine=hppa1.0-hp
		;;
	hppa-next)
		os=-nextstep3
		;;
	hppaosf)
		basic_machine=hppa1.1-hp
		os=-osf
		;;
	hppro)
		basic_machine=hppa1.1-hp
		os=-proelf
		;;
	i370-ibm* | ibm*)
		basic_machine=i370-ibm
		;;
	i*86v32)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-sysv32
		;;
	i*86v4*)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-sysv4
		;;
	i*86v)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-sysv
		;;
	i*86sol2)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-solaris2
		;;
	i386mach)
		basic_machine=i386-mach
		os=-mach
		;;
	i386-vsta | vsta)
		basic_machine=i386-unknown
		os=-vsta
		;;
	iris | iris4d)
		basic_machine=mips-sgi
		case $os in
		    -irix*)
			;;
		    *)
			os=-irix4
			;;
		esac
		;;
	isi68 | isi)
		basic_machine=m68k-isi
		os=-sysv
		;;
	m68knommu)
		basic_machine=m68k-unknown
		os=-linux
		;;
	m68knommu-*)
		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
		os=-linux
		;;
	m88k-omron*)
		basic_machine=m88k-omron
		;;
	magnum | m3230)
		basic_machine=mips-mips
		os=-sysv
		;;
	merlin)
		basic_machine=ns32k-utek
		os=-sysv
		;;
	microblaze*)
		basic_machine=microblaze-xilinx
		;;
	mingw64)
		basic_machine=x86_64-pc
		os=-mingw64
		;;
	mingw32)
		basic_machine=i686-pc
		os=-mingw32
		;;
	mingw32ce)
		basic_machine=arm-unknown
		os=-mingw32ce
		;;
	miniframe)
		basic_machine=m68000-convergent
		;;
	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
		basic_machine=m68k-atari
		os=-mint
		;;
	mips3*-*)
		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
		;;
	mips3*)
		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
		;;
	monitor)
		basic_machine=m68k-rom68k
		os=-coff
		;;
	morphos)
		basic_machine=powerpc-unknown
		os=-morphos
		;;
	moxiebox)
		basic_machine=moxie-unknown
		os=-moxiebox
		;;
	msdos)
		basic_machine=i386-pc
		os=-msdos
		;;
	ms1-*)
		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
		;;
	msys)
		basic_machine=i686-pc
		os=-msys
		;;
	mvs)
		basic_machine=i370-ibm
		os=-mvs
		;;
	nacl)
		basic_machine=le32-unknown
		os=-nacl
		;;
	ncr3000)
		basic_machine=i486-ncr
		os=-sysv4
		;;
	netbsd386)
		basic_machine=i386-unknown
		os=-netbsd
		;;
	netwinder)
		basic_machine=armv4l-rebel
		os=-linux
		;;
	news | news700 | news800 | news900)
		basic_machine=m68k-sony
		os=-newsos
		;;
	news1000)
		basic_machine=m68030-sony
		os=-newsos
		;;
	news-3600 | risc-news)
		basic_machine=mips-sony
		os=-newsos
		;;
	necv70)
		basic_machine=v70-nec
		os=-sysv
		;;
	next | m*-next )
		basic_machine=m68k-next
		case $os in
		    -nextstep* )
			;;
		    -ns2*)
		      os=-nextstep2
			;;
		    *)
		      os=-nextstep3
			;;
		esac
		;;
	nh3000)
		basic_machine=m68k-harris
		os=-cxux
		;;
	nh[45]000)
		basic_machine=m88k-harris
		os=-cxux
		;;
	nindy960)
		basic_machine=i960-intel
		os=-nindy
		;;
	mon960)
		basic_machine=i960-intel
		os=-mon960
		;;
	nonstopux)
		basic_machine=mips-compaq
		os=-nonstopux
		;;
	np1)
		basic_machine=np1-gould
		;;
	neo-tandem)
		basic_machine=neo-tandem
		;;
	nse-tandem)
		basic_machine=nse-tandem
		;;
	nsr-tandem)
		basic_machine=nsr-tandem
		;;
	op50n-* | op60c-*)
		basic_machine=hppa1.1-oki
		os=-proelf
		;;
	openrisc | openrisc-*)
		basic_machine=or32-unknown
		;;
	os400)
		basic_machine=powerpc-ibm
		os=-os400
		;;
	OSE68000 | ose68000)
		basic_machine=m68000-ericsson
		os=-ose
		;;
	os68k)
		basic_machine=m68k-none
		os=-os68k
		;;
	pa-hitachi)
		basic_machine=hppa1.1-hitachi
		os=-hiuxwe2
		;;
	paragon)
		basic_machine=i860-intel
		os=-osf
		;;
	parisc)
		basic_machine=hppa-unknown
		os=-linux
		;;
	parisc-*)
		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
		os=-linux
		;;
	pbd)
		basic_machine=sparc-tti
		;;
	pbb)
		basic_machine=m68k-tti
		;;
	pc532 | pc532-*)
		basic_machine=ns32k-pc532
		;;
	pc98)
		basic_machine=i386-pc
		;;
	pc98-*)
		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentium | p5 | k5 | k6 | nexgen | viac3)
		basic_machine=i586-pc
		;;
	pentiumpro | p6 | 6x86 | athlon | athlon_*)
		basic_machine=i686-pc
		;;
	pentiumii | pentium2 | pentiumiii | pentium3)
		basic_machine=i686-pc
		;;
	pentium4)
		basic_machine=i786-pc
		;;
	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentiumpro-* | p6-* | 6x86-* | athlon-*)
		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentium4-*)
		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pn)
		basic_machine=pn-gould
		;;
	power)	basic_machine=power-ibm
		;;
	ppc | ppcbe)	basic_machine=powerpc-unknown
		;;
	ppc-* | ppcbe-*)
		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ppcle | powerpclittle | ppc-le | powerpc-little)
		basic_machine=powerpcle-unknown
		;;
	ppcle-* | powerpclittle-*)
		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ppc64)	basic_machine=powerpc64-unknown
		;;
	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
		basic_machine=powerpc64le-unknown
		;;
	ppc64le-* | powerpc64little-*)
		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ps2)
		basic_machine=i386-ibm
		;;
	pw32)
		basic_machine=i586-unknown
		os=-pw32
		;;
	rdos | rdos64)
		basic_machine=x86_64-pc
		os=-rdos
		;;
	rdos32)
		basic_machine=i386-pc
		os=-rdos
		;;
	rom68k)
		basic_machine=m68k-rom68k
		os=-coff
		;;
	rm[46]00)
		basic_machine=mips-siemens
		;;
	rtpc | rtpc-*)
		basic_machine=romp-ibm
		;;
	s390 | s390-*)
		basic_machine=s390-ibm
		;;
	s390x | s390x-*)
		basic_machine=s390x-ibm
		;;
	sa29200)
		basic_machine=a29k-amd
		os=-udi
		;;
	sb1)
		basic_machine=mipsisa64sb1-unknown
		;;
	sb1el)
		basic_machine=mipsisa64sb1el-unknown
		;;
	sde)
		basic_machine=mipsisa32-sde
		os=-elf
		;;
	sei)
		basic_machine=mips-sei
		os=-seiux
		;;
	sequent)
		basic_machine=i386-sequent
		;;
	sh)
		basic_machine=sh-hitachi
		os=-hms
		;;
	sh5el)
		basic_machine=sh5le-unknown
		;;
	sh64)
		basic_machine=sh64-unknown
		;;
	sparclite-wrs | simso-wrs)
		basic_machine=sparclite-wrs
		os=-vxworks
		;;
	sps7)
		basic_machine=m68k-bull
		os=-sysv2
		;;
	spur)
		basic_machine=spur-unknown
		;;
	st2000)
		basic_machine=m68k-tandem
		;;
	stratus)
		basic_machine=i860-stratus
		os=-sysv4
		;;
	strongarm-* | thumb-*)
		basic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	sun2)
		basic_machine=m68000-sun
		;;
	sun2os3)
		basic_machine=m68000-sun
		os=-sunos3
		;;
	sun2os4)
		basic_machine=m68000-sun
		os=-sunos4
		;;
	sun3os3)
		basic_machine=m68k-sun
		os=-sunos3
		;;
	sun3os4)
		basic_machine=m68k-sun
		os=-sunos4
		;;
	sun4os3)
		basic_machine=sparc-sun
		os=-sunos3
		;;
	sun4os4)
		basic_machine=sparc-sun
		os=-sunos4
		;;
	sun4sol2)
		basic_machine=sparc-sun
		os=-solaris2
		;;
	sun3 | sun3-*)
		basic_machine=m68k-sun
		;;
	sun4)
		basic_machine=sparc-sun
		;;
	sun386 | sun386i | roadrunner)
		basic_machine=i386-sun
		;;
	sv1)
		basic_machine=sv1-cray
		os=-unicos
		;;
	symmetry)
		basic_machine=i386-sequent
		os=-dynix
		;;
	t3e)
		basic_machine=alphaev5-cray
		os=-unicos
		;;
	t90)
		basic_machine=t90-cray
		os=-unicos
		;;
	tile*)
		basic_machine=$basic_machine-unknown
		os=-linux-gnu
		;;
	tx39)
		basic_machine=mipstx39-unknown
		;;
	tx39el)
		basic_machine=mipstx39el-unknown
		;;
	toad1)
		basic_machine=pdp10-xkl
		os=-tops20
		;;
	tower | tower-32)
		basic_machine=m68k-ncr
		;;
	tpf)
		basic_machine=s390x-ibm
		os=-tpf
		;;
	udi29k)
		basic_machine=a29k-amd
		os=-udi
		;;
	ultra3)
		basic_machine=a29k-nyu
		os=-sym1
		;;
	v810 | necv810)
		basic_machine=v810-nec
		os=-none
		;;
	vaxv)
		basic_machine=vax-dec
		os=-sysv
		;;
	vms)
		basic_machine=vax-dec
		os=-vms
		;;
	vpp*|vx|vx-*)
		basic_machine=f301-fujitsu
		;;
	vxworks960)
		basic_machine=i960-wrs
		os=-vxworks
		;;
	vxworks68)
		basic_machine=m68k-wrs
		os=-vxworks
		;;
	vxworks29k)
		basic_machine=a29k-wrs
		os=-vxworks
		;;
	w65*)
		basic_machine=w65-wdc
		os=-none
		;;
	w89k-*)
		basic_machine=hppa1.1-winbond
		os=-proelf
		;;
	xbox)
		basic_machine=i686-pc
		os=-mingw32
		;;
	xps | xps100)
		basic_machine=xps100-honeywell
		;;
	xscale-* | xscalee[bl]-*)
		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
		;;
	ymp)
		basic_machine=ymp-cray
		os=-unicos
		;;
	z8k-*-coff)
		basic_machine=z8k-unknown
		os=-sim
		;;
	z80-*-coff)
		basic_machine=z80-unknown
		os=-sim
		;;
	none)
		basic_machine=none-none
		os=-none
		;;

# Here we handle the default manufacturer of certain CPU types.  It is in
# some cases the only manufacturer, in others, it is the most popular.
	w89k)
		basic_machine=hppa1.1-winbond
		;;
	op50n)
		basic_machine=hppa1.1-oki
		;;
	op60c)
		basic_machine=hppa1.1-oki
		;;
	romp)
		basic_machine=romp-ibm
		;;
	mmix)
		basic_machine=mmix-knuth
		;;
	rs6000)
		basic_machine=rs6000-ibm
		;;
	vax)
		basic_machine=vax-dec
		;;
	pdp10)
		# there are many clones, so DEC is not a safe bet
		basic_machine=pdp10-unknown
		;;
	pdp11)
		basic_machine=pdp11-dec
		;;
	we32k)
		basic_machine=we32k-att
		;;
	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
		basic_machine=sh-unknown
		;;
	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
		basic_machine=sparc-sun
		;;
	cydra)
		basic_machine=cydra-cydrome
		;;
	orion)
		basic_machine=orion-highlevel
		;;
	orion105)
		basic_machine=clipper-highlevel
		;;
	mac | mpw | mac-mpw)
		basic_machine=m68k-apple
		;;
	pmac | pmac-mpw)
		basic_machine=powerpc-apple
		;;
	*-unknown)
		# Make sure to match an already-canonicalized machine name.
		;;
	*)
		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
		exit 1
		;;
esac

# Here we canonicalize certain aliases for manufacturers.
case $basic_machine in
	*-digital*)
		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
		;;
	*-commodore*)
		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
		;;
	*)
		;;
esac

# Decode manufacturer-specific aliases for certain operating systems.

if [ x"$os" != x"" ]
then
case $os in
	# First match some system type aliases
	# that might get confused with valid system types.
	# -solaris* is a basic system type, with this one exception.
	-auroraux)
		os=-auroraux
		;;
	-solaris1 | -solaris1.*)
		os=`echo $os | sed -e 's|solaris1|sunos4|'`
		;;
	-solaris)
		os=-solaris2
		;;
	-svr4*)
		os=-sysv4
		;;
	-unixware*)
		os=-sysv4.2uw
		;;
	-gnu/linux*)
		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
		;;
	# First accept the basic system types.
	# The portable systems comes first.
	# Each alternative MUST END IN A *, to match a version number.
	# -sysv* is not here because it comes later, after sysvr4.
	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
	      | -sym* | -kopensolaris* | -plan9* \
	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
	      | -aos* | -aros* \
	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
	      | -bitrig* | -openbsd* | -solidbsd* \
	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
	      | -chorusos* | -chorusrdb* | -cegcc* \
	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
	# Remember, each alternative MUST END IN *, to match a version number.
		;;
	-qnx*)
		case $basic_machine in
		    x86-* | i*86-*)
			;;
		    *)
			os=-nto$os
			;;
		esac
		;;
	-nto-qnx*)
		;;
	-nto*)
		os=`echo $os | sed -e 's|nto|nto-qnx|'`
		;;
	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
		;;
	-mac*)
		os=`echo $os | sed -e 's|mac|macos|'`
		;;
	-linux-dietlibc)
		os=-linux-dietlibc
		;;
	-linux*)
		os=`echo $os | sed -e 's|linux|linux-gnu|'`
		;;
	-sunos5*)
		os=`echo $os | sed -e 's|sunos5|solaris2|'`
		;;
	-sunos6*)
		os=`echo $os | sed -e 's|sunos6|solaris3|'`
		;;
	-opened*)
		os=-openedition
		;;
	-os400*)
		os=-os400
		;;
	-wince*)
		os=-wince
		;;
	-osfrose*)
		os=-osfrose
		;;
	-osf*)
		os=-osf
		;;
	-utek*)
		os=-bsd
		;;
	-dynix*)
		os=-bsd
		;;
	-acis*)
		os=-aos
		;;
	-atheos*)
		os=-atheos
		;;
	-syllable*)
		os=-syllable
		;;
	-386bsd)
		os=-bsd
		;;
	-ctix* | -uts*)
		os=-sysv
		;;
	-nova*)
		os=-rtmk-nova
		;;
	-ns2 )
		os=-nextstep2
		;;
	-nsk*)
		os=-nsk
		;;
	# Preserve the version number of sinix5.
	-sinix5.*)
		os=`echo $os | sed -e 's|sinix|sysv|'`
		;;
	-sinix*)
		os=-sysv4
		;;
	-tpf*)
		os=-tpf
		;;
	-triton*)
		os=-sysv3
		;;
	-oss*)
		os=-sysv3
		;;
	-svr4)
		os=-sysv4
		;;
	-svr3)
		os=-sysv3
		;;
	-sysvr4)
		os=-sysv4
		;;
	# This must come after -sysvr4.
	-sysv*)
		;;
	-ose*)
		os=-ose
		;;
	-es1800*)
		os=-ose
		;;
	-xenix)
		os=-xenix
		;;
	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
		os=-mint
		;;
	-aros*)
		os=-aros
		;;
	-zvmoe)
		os=-zvmoe
		;;
	-dicos*)
		os=-dicos
		;;
	-nacl*)
		;;
	-none)
		;;
	*)
		# Get rid of the `-' at the beginning of $os.
		os=`echo $os | sed 's/[^-]*-//'`
		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
		exit 1
		;;
esac
else

# Here we handle the default operating systems that come with various machines.
# The value should be what the vendor currently ships out the door with their
# machine or put another way, the most popular os provided with the machine.

# Note that if you're going to try to match "-MANUFACTURER" here (say,
# "-sun"), then you have to tell the case statement up towards the top
# that MANUFACTURER isn't an operating system.  Otherwise, code above
# will signal an error saying that MANUFACTURER isn't an operating
# system, and we'll never get to this point.

case $basic_machine in
	score-*)
		os=-elf
		;;
	spu-*)
		os=-elf
		;;
	*-acorn)
		os=-riscix1.2
		;;
	arm*-rebel)
		os=-linux
		;;
	arm*-semi)
		os=-aout
		;;
	c4x-* | tic4x-*)
		os=-coff
		;;
	c8051-*)
		os=-elf
		;;
	hexagon-*)
		os=-elf
		;;
	tic54x-*)
		os=-coff
		;;
	tic55x-*)
		os=-coff
		;;
	tic6x-*)
		os=-coff
		;;
	# This must come before the *-dec entry.
	pdp10-*)
		os=-tops20
		;;
	pdp11-*)
		os=-none
		;;
	*-dec | vax-*)
		os=-ultrix4.2
		;;
	m68*-apollo)
		os=-domain
		;;
	i386-sun)
		os=-sunos4.0.2
		;;
	m68000-sun)
		os=-sunos3
		;;
	m68*-cisco)
		os=-aout
		;;
	mep-*)
		os=-elf
		;;
	mips*-cisco)
		os=-elf
		;;
	mips*-*)
		os=-elf
		;;
	or32-*)
		os=-coff
		;;
	*-tti)	# must be before sparc entry or we get the wrong os.
		os=-sysv3
		;;
	sparc-* | *-sun)
		os=-sunos4.1.1
		;;
	*-be)
		os=-beos
		;;
	*-haiku)
		os=-haiku
		;;
	*-ibm)
		os=-aix
		;;
	*-knuth)
		os=-mmixware
		;;
	*-wec)
		os=-proelf
		;;
	*-winbond)
		os=-proelf
		;;
	*-oki)
		os=-proelf
		;;
	*-hp)
		os=-hpux
		;;
	*-hitachi)
		os=-hiux
		;;
	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
		os=-sysv
		;;
	*-cbm)
		os=-amigaos
		;;
	*-dg)
		os=-dgux
		;;
	*-dolphin)
		os=-sysv3
		;;
	m68k-ccur)
		os=-rtu
		;;
	m88k-omron*)
		os=-luna
		;;
	*-next )
		os=-nextstep
		;;
	*-sequent)
		os=-ptx
		;;
	*-crds)
		os=-unos
		;;
	*-ns)
		os=-genix
		;;
	i370-*)
		os=-mvs
		;;
	*-next)
		os=-nextstep3
		;;
	*-gould)
		os=-sysv
		;;
	*-highlevel)
		os=-bsd
		;;
	*-encore)
		os=-bsd
		;;
	*-sgi)
		os=-irix
		;;
	*-siemens)
		os=-sysv4
		;;
	*-masscomp)
		os=-rtu
		;;
	f30[01]-fujitsu | f700-fujitsu)
		os=-uxpv
		;;
	*-rom68k)
		os=-coff
		;;
	*-*bug)
		os=-coff
		;;
	*-apple)
		os=-macos
		;;
	*-atari*)
		os=-mint
		;;
	*)
		os=-none
		;;
esac
fi

# Here we handle the case where we know the os, and the CPU type, but not the
# manufacturer.  We pick the logical manufacturer.
vendor=unknown
case $basic_machine in
	*-unknown)
		case $os in
			-riscix*)
				vendor=acorn
				;;
			-sunos*)
				vendor=sun
				;;
			-cnk*|-aix*)
				vendor=ibm
				;;
			-beos*)
				vendor=be
				;;
			-hpux*)
				vendor=hp
				;;
			-mpeix*)
				vendor=hp
				;;
			-hiux*)
				vendor=hitachi
				;;
			-unos*)
				vendor=crds
				;;
			-dgux*)
				vendor=dg
				;;
			-luna*)
				vendor=omron
				;;
			-genix*)
				vendor=ns
				;;
			-mvs* | -opened*)
				vendor=ibm
				;;
			-os400*)
				vendor=ibm
				;;
			-ptx*)
				vendor=sequent
				;;
			-tpf*)
				vendor=ibm
				;;
			-vxsim* | -vxworks* | -windiss*)
				vendor=wrs
				;;
			-aux*)
				vendor=apple
				;;
			-hms*)
				vendor=hitachi
				;;
			-mpw* | -macos*)
				vendor=apple
				;;
			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
				vendor=atari
				;;
			-vos*)
				vendor=stratus
				;;
		esac
		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
		;;
esac

echo $basic_machine$os
exit

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "timestamp='"
# time-stamp-format: "%:y-%02m-%02d"
# time-stamp-end: "'"
# End:
   usr/share/misc/magic                                                                                0120777 0000000 0000000 00000000000 13024405174 015252  2../file/magic                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/misc/magic.mgc                                                                            0120777 0000000 0000000 00000000000 13024405174 016564  2../file/magic.mgc                                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/                                                                                     0040755 0000000 0000000 00000000000 13077704253 012135  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/                                                                              0040755 0000000 0000000 00000000000 13077704254 012662  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/AnyDBM_File.pm                                                                0100644 0000000 0000000 00000005072 12744441327 015231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package AnyDBM_File;
use warnings;
use strict;

use 5.006_001;
our $VERSION = '1.01';
our @ISA = qw(NDBM_File DB_File GDBM_File SDBM_File ODBM_File) unless @ISA;

my $mod;
for $mod (@ISA) {
    if (eval "require $mod") {
	@ISA = ($mod);	# if we leave @ISA alone, warnings abound
	return 1;
    }
}

die "No DBM package was successfully found or installed";

__END__

=head1 NAME

AnyDBM_File - provide framework for multiple DBMs

NDBM_File, DB_File, GDBM_File, SDBM_File, ODBM_File - various DBM implementations

=head1 SYNOPSIS

    use AnyDBM_File;

=head1 DESCRIPTION

This module is a "pure virtual base class"--it has nothing of its own.
It's just there to inherit from one of the various DBM packages.  It
prefers ndbm for compatibility reasons with Perl 4, then Berkeley DB (See
L<DB_File>), GDBM, SDBM (which is always there--it comes with Perl), and
finally ODBM.   This way old programs that used to use NDBM via dbmopen()
can still do so, but new ones can reorder @ISA:

    BEGIN { @AnyDBM_File::ISA = qw(DB_File GDBM_File NDBM_File) }
    use AnyDBM_File;

Having multiple DBM implementations makes it trivial to copy database formats:

    use Fcntl; use NDBM_File; use DB_File;
    tie %newhash,  'DB_File', $new_filename, O_CREAT|O_RDWR;
    tie %oldhash,  'NDBM_File', $old_filename, 1, 0;
    %newhash = %oldhash;

=head2 DBM Comparisons

Here's a partial table of features the different packages offer:

                         odbm    ndbm    sdbm    gdbm    bsd-db
			 ----	 ----    ----    ----    ------
 Linkage comes w/ perl   yes     yes     yes     yes     yes
 Src comes w/ perl       no      no      yes     no      no
 Comes w/ many unix os   yes     yes[0]  no      no      no
 Builds ok on !unix      ?       ?       yes     yes     ?
 Code Size               ?       ?       small   big     big
 Database Size           ?       ?       small   big?    ok[1]
 Speed                   ?       ?       slow    ok      fast
 FTPable                 no      no      yes     yes     yes
 Easy to build          N/A     N/A      yes     yes     ok[2]
 Size limits             1k      4k      1k[3]   none    none
 Byte-order independent  no      no      no      no      yes
 Licensing restrictions  ?       ?       no      yes     no


=over 4

=item [0] 

on mixed universe machines, may be in the bsd compat library,
which is often shunned.

=item [1] 

Can be trimmed if you compile for one access method.

=item [2] 

See L<DB_File>. 
Requires symbolic links.  

=item [3] 

By default, but can be redefined.

=back

=head1 SEE ALSO

dbm(3), ndbm(3), DB_File(3), L<perldbmfilter>

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/App/                                                                          0040755 0000000 0000000 00000000000 13077704254 013402  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/App/Cpan.pm                                                                   0100644 0000000 0000000 00000076530 12744441327 014630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package App::Cpan;

use strict;
use warnings;
use vars qw($VERSION);

use if $] < 5.008 => "IO::Scalar";

$VERSION = '1.62';

=head1 NAME

App::Cpan - easily interact with CPAN from the command line

=head1 SYNOPSIS

	# with arguments and no switches, installs specified modules
	cpan module_name [ module_name ... ]

	# with switches, installs modules with extra behavior
	cpan [-cfFimtTw] module_name [ module_name ... ]

	# use local::lib
	cpan -I module_name [ module_name ... ]

	# with just the dot, install from the distribution in the
	# current directory
	cpan .

	# without arguments, starts CPAN.pm shell
	cpan

	# without arguments, but some switches
	cpan [-ahpruvACDLOP]

=head1 DESCRIPTION

This script provides a command interface (not a shell) to CPAN. At the
moment it uses CPAN.pm to do the work, but it is not a one-shot command
runner for CPAN.pm.

=head2 Options

=over 4

=item -a

Creates a CPAN.pm autobundle with CPAN::Shell->autobundle.

=item -A module [ module ... ]

Shows the primary maintainers for the specified modules.

=item -c module

Runs a `make clean` in the specified module's directories.

=item -C module [ module ... ]

Show the F<Changes> files for the specified modules

=item -D module [ module ... ]

Show the module details. This prints one line for each out-of-date module
(meaning, modules locally installed but have newer versions on CPAN).
Each line has three columns: module name, local version, and CPAN
version.

=item -f

Force the specified action, when it normally would have failed. Use this
to install a module even if its tests fail. When you use this option,
-i is not optional for installing a module when you need to force it:

	% cpan -f -i Module::Foo

=item -F

Turn off CPAN.pm's attempts to lock anything. You should be careful with
this since you might end up with multiple scripts trying to muck in the
same directory. This isn't so much of a concern if you're loading a special
config with C<-j>, and that config sets up its own work directories.

=item -g module [ module ... ]

Downloads to the current directory the latest distribution of the module.

=item -G module [ module ... ]

UNIMPLEMENTED

Download to the current directory the latest distribution of the
modules, unpack each distribution, and create a git repository for each
distribution.

If you want this feature, check out Yanick Champoux's C<Git::CPAN::Patch>
distribution.

=item -h

Print a help message and exit. When you specify C<-h>, it ignores all
of the other options and arguments.

=item -i

Install the specified modules. With no other switches, this switch
is implied.

=item -I

Load C<local::lib> (think like C<-I> for loading lib paths). Too bad
C<-l> was already taken.

=item -j Config.pm

Load the file that has the CPAN configuration data. This should have the
same format as the standard F<CPAN/Config.pm> file, which defines
C<$CPAN::Config> as an anonymous hash.

=item -J

Dump the configuration in the same format that CPAN.pm uses. This is useful
for checking the configuration as well as using the dump as a starting point
for a new, custom configuration.

=item -l

List all installed modules with their versions

=item -L author [ author ... ]

List the modules by the specified authors.

=item -m

Make the specified modules.

=item -n

Do a dry run, but don't actually install anything. (unimplemented)

=item -O

Show the out-of-date modules.

=item -p

Ping the configured mirrors

=item -P

Find the best mirrors you could be using (but doesn't configure them just yet)

=item -r

Recompiles dynamically loaded modules with CPAN::Shell->recompile.

=item -t

Run a `make test` on the specified modules.

=item -T

Do not test modules. Simply install them.

=item -u

Upgrade all installed modules. Blindly doing this can really break things,
so keep a backup.

=item -v

Print the script version and CPAN.pm version then exit.

=item -V

Print detailed information about the cpan client.

=item -w

UNIMPLEMENTED

Turn on cpan warnings. This checks various things, like directory permissions,
and tells you about problems you might have.

=back

=head2 Examples

	# print a help message
	cpan -h

	# print the version numbers
	cpan -v

	# create an autobundle
	cpan -a

	# recompile modules
	cpan -r

	# upgrade all installed modules
	cpan -u

	# install modules ( sole -i is optional )
	cpan -i Netscape::Booksmarks Business::ISBN

	# force install modules ( must use -i )
	cpan -fi CGI::Minimal URI


=head2 Methods

=over 4

=cut

use autouse Carp => qw(carp croak cluck);
use CPAN ();
use Config;
use autouse Cwd => qw(cwd);
use autouse 'Data::Dumper' => qw(Dumper);
use File::Spec::Functions;
use File::Basename;
use Getopt::Std;

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Internal constants
use constant TRUE  => 1;
use constant FALSE => 0;


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# The return values
use constant HEY_IT_WORKED              =>   0;
use constant I_DONT_KNOW_WHAT_HAPPENED  =>   1; # 0b0000_0001
use constant ITS_NOT_MY_FAULT           =>   2;
use constant THE_PROGRAMMERS_AN_IDIOT   =>   4;
use constant A_MODULE_FAILED_TO_INSTALL =>   8;


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# set up the order of options that we layer over CPAN::Shell
BEGIN { # most of this should be in methods
use vars qw( @META_OPTIONS $Default %CPAN_METHODS @CPAN_OPTIONS  @option_order
	%Method_table %Method_table_index );

@META_OPTIONS = qw( h v V I g G C A D O l L a r p P j: J w T);

$Default = 'default';

%CPAN_METHODS = ( # map switches to method names in CPAN::Shell
	$Default => 'install',
	'c'      => 'clean',
	'f'      => 'force',
	'i'      => 'install',
	'm'      => 'make',
	't'      => 'test',
	'u'      => 'upgrade',
	);
@CPAN_OPTIONS = grep { $_ ne $Default } sort keys %CPAN_METHODS;

@option_order = ( @META_OPTIONS, @CPAN_OPTIONS );


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# map switches to the subroutines in this script, along with other information.
# use this stuff instead of hard-coded indices and values
sub NO_ARGS   () { 0 }
sub ARGS      () { 1 }
sub GOOD_EXIT () { 0 }

%Method_table = (
# key => [ sub ref, takes args?, exit value, description ]

	# options that do their thing first, then exit
	h =>  [ \&_print_help,        NO_ARGS, GOOD_EXIT, 'Printing help'                ],
	v =>  [ \&_print_version,     NO_ARGS, GOOD_EXIT, 'Printing version'             ],
	V =>  [ \&_print_details,     NO_ARGS, GOOD_EXIT, 'Printing detailed version'    ],

	# options that affect other options
	j =>  [ \&_load_config,          ARGS, GOOD_EXIT, 'Use specified config file'    ],
	J =>  [ \&_dump_config,       NO_ARGS, GOOD_EXIT, 'Dump configuration to stdout' ],
	F =>  [ \&_lock_lobotomy,     NO_ARGS, GOOD_EXIT, 'Turn off CPAN.pm lock files'  ],
	I =>  [ \&_load_local_lib,    NO_ARGS, GOOD_EXIT, 'Loading local::lib'           ],
    w =>  [ \&_turn_on_warnings,  NO_ARGS, GOOD_EXIT, 'Turning on warnings'          ],
    T =>  [ \&_turn_off_testing,  NO_ARGS, GOOD_EXIT, 'Turning off testing'          ],

	# options that do their one thing
	g =>  [ \&_download,          NO_ARGS, GOOD_EXIT, 'Download the latest distro'        ],
	G =>  [ \&_gitify,            NO_ARGS, GOOD_EXIT, 'Down and gitify the latest distro' ],

	C =>  [ \&_show_Changes,         ARGS, GOOD_EXIT, 'Showing Changes file'         ],
	A =>  [ \&_show_Author,          ARGS, GOOD_EXIT, 'Showing Author'               ],
	D =>  [ \&_show_Details,         ARGS, GOOD_EXIT, 'Showing Details'              ],
	O =>  [ \&_show_out_of_date,  NO_ARGS, GOOD_EXIT, 'Showing Out of date'          ],
	l =>  [ \&_list_all_mods,     NO_ARGS, GOOD_EXIT, 'Listing all modules'          ],

	L =>  [ \&_show_author_mods,     ARGS, GOOD_EXIT, 'Showing author mods'          ],
	a =>  [ \&_create_autobundle, NO_ARGS, GOOD_EXIT, 'Creating autobundle'          ],
	p =>  [ \&_ping_mirrors,      NO_ARGS, GOOD_EXIT, 'Pinging mirrors'              ],
	P =>  [ \&_find_good_mirrors, NO_ARGS, GOOD_EXIT, 'Finding good mirrors'         ],

	r =>  [ \&_recompile,         NO_ARGS, GOOD_EXIT, 'Recompiling'                  ],
	u =>  [ \&_upgrade,           NO_ARGS, GOOD_EXIT, 'Running `make test`'          ],

	c =>  [ \&_default,              ARGS, GOOD_EXIT, 'Running `make clean`'         ],
	f =>  [ \&_default,              ARGS, GOOD_EXIT, 'Installing with force'        ],
	i =>  [ \&_default,              ARGS, GOOD_EXIT, 'Running `make install`'       ],
   'm' => [ \&_default,              ARGS, GOOD_EXIT, 'Running `make`'               ],
	t =>  [ \&_default,              ARGS, GOOD_EXIT, 'Running `make test`'          ],
	);

%Method_table_index = (
	code        => 0,
	takes_args  => 1,
	exit_value  => 2,
	description => 3,
	);
}


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# finally, do some argument processing

sub _stupid_interface_hack_for_non_rtfmers
	{
	no warnings 'uninitialized';
	shift @ARGV if( $ARGV[0] eq 'install' and @ARGV > 1 )
	}

sub _process_options
	{
	my %options;

	push @ARGV, grep $_, split /\s+/, $ENV{CPAN_OPTS} || '';

	# if no arguments, just drop into the shell
	if( 0 == @ARGV ) { CPAN::shell(); exit 0 }
	else
		{
		Getopt::Std::getopts(
		  join( '', @option_order ), \%options );
		 \%options;
		}
	}

sub _process_setup_options
	{
	my( $class, $options ) = @_;

	if( $options->{j} )
		{
		$Method_table{j}[ $Method_table_index{code} ]->( $options->{j} );
		delete $options->{j};
		}
	else
		{
		# this is what CPAN.pm would do otherwise
		local $CPAN::Be_Silent = 1;
		CPAN::HandleConfig->load(
			# be_silent  => 1, deprecated
			write_file => 0,
			);
		}

	foreach my $o ( qw(F I w T) )
		{
		next unless exists $options->{$o};
		$Method_table{$o}[ $Method_table_index{code} ]->( $options->{$o} );
		delete $options->{$o};
		}

	if( $options->{o} )
		{
		my @pairs = map { [ split /=/, $_, 2 ] } split /,/, $options->{o};
		foreach my $pair ( @pairs )
			{
			my( $setting, $value ) = @$pair;
			$CPAN::Config->{$setting} = $value;
		#	$logger->debug( "Setting [$setting] to [$value]" );
			}
		delete $options->{o};
		}

	my $option_count = grep { $options->{$_} } @option_order;
	no warnings 'uninitialized';
	$option_count -= $options->{'f'}; # don't count force

	# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
	# if there are no options, set -i (this line fixes RT ticket 16915)
	$options->{i}++ unless $option_count;
	}


=item run()

Just do it.

The C<run> method returns 0 on success and a positive number on
failure. See the section on EXIT CODES for details on the values.

=cut

my $logger;

sub run
	{
	my $class = shift;

	my $return_value = HEY_IT_WORKED; # assume that things will work

	$logger = $class->_init_logger;
	$logger->debug( "Using logger from @{[ref $logger]}" );

	$class->_hook_into_CPANpm_report;
	$logger->debug( "Hooked into output" );

	$class->_stupid_interface_hack_for_non_rtfmers;
	$logger->debug( "Patched cargo culting" );

	my $options = $class->_process_options;
	$logger->debug( "Options are @{[Dumper($options)]}" );

	$class->_process_setup_options( $options );

	OPTION: foreach my $option ( @option_order )
		{
		next unless $options->{$option};

		my( $sub, $takes_args, $description ) =
			map { $Method_table{$option}[ $Method_table_index{$_} ] }
			qw( code takes_args );

		unless( ref $sub eq ref sub {} )
			{
			$return_value = THE_PROGRAMMERS_AN_IDIOT;
			last OPTION;
			}

		$logger->info( "$description -- ignoring other arguments" )
			if( @ARGV && ! $takes_args );

		$return_value = $sub->( \ @ARGV, $options );

		last;
		}

	return $return_value;
	}

{
package
  Local::Null::Logger; # hide from PAUSE

sub new { bless \ my $x, $_[0] }
sub AUTOLOAD { 1 }
sub DESTROY { 1 }
}

# load a module without searching the default entry for the current
# directory
sub _safe_load_module {
  my $name = shift;

  local @INC = @INC;
  pop @INC if $INC[-1] eq '.';

  eval "require $name; 1";
}

sub _init_logger
	{
	my $log4perl_loaded = _safe_load_module("Log::Log4perl");

    unless( $log4perl_loaded )
        {
        $logger = Local::Null::Logger->new;
        return $logger;
        }

	my $LEVEL = $ENV{CPANSCRIPT_LOGLEVEL} || 'INFO';

	Log::Log4perl::init( \ <<"HERE" );
log4perl.rootLogger=$LEVEL, A1
log4perl.appender.A1=Log::Log4perl::Appender::Screen
log4perl.appender.A1.layout=PatternLayout
log4perl.appender.A1.layout.ConversionPattern=%m%n
HERE

	$logger = Log::Log4perl->get_logger( 'App::Cpan' );
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub _default
	{
	my( $args, $options ) = @_;

	my $switch = '';

	# choose the option that we're going to use
	# we'll deal with 'f' (force) later, so skip it
	foreach my $option ( @CPAN_OPTIONS )
		{
		next if $option eq 'f';
		next unless $options->{$option};
		$switch = $option;
		last;
		}

	# 1. with no switches, but arguments, use the default switch (install)
	# 2. with no switches and no args, start the shell
	# 3. With a switch but no args, die! These switches need arguments.
	   if( not $switch and     @$args ) { $switch = $Default;  }
	elsif( not $switch and not @$args ) { return CPAN::shell() }
	elsif(     $switch and not @$args )
		{ die "Nothing to $CPAN_METHODS{$switch}!\n"; }

	# Get and check the method from CPAN::Shell
	my $method = $CPAN_METHODS{$switch};
	die "CPAN.pm cannot $method!\n" unless CPAN::Shell->can( $method );

	# call the CPAN::Shell method, with force if specified
	my $action = do {
		if( $options->{f} ) { sub { CPAN::Shell->force( $method, @_ ) } }
		else                { sub { CPAN::Shell->$method( @_ )        } }
		};

	# How do I handle exit codes for multiple arguments?
	my $errors = 0;

	foreach my $arg ( @$args )
		{
		_clear_cpanpm_output();
		$action->( $arg );

		$errors += defined _cpanpm_output_indicates_failure();
		}

	$errors ? I_DONT_KNOW_WHAT_HAPPENED : HEY_IT_WORKED;
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

=for comment

CPAN.pm sends all the good stuff either to STDOUT, or to a temp
file if $CPAN::Be_Silent is set. I have to intercept that output
so I can find out what happened.

=cut

BEGIN {
my $scalar = '';

sub _hook_into_CPANpm_report
	{
	no warnings 'redefine';

	*CPAN::Shell::myprint = sub {
		my($self,$what) = @_;
		$scalar .= $what;
		$self->print_ornamented($what,
			$CPAN::Config->{colorize_print}||'bold blue on_white',
			);
		};

	*CPAN::Shell::mywarn = sub {
		my($self,$what) = @_;
		$scalar .= $what;
		$self->print_ornamented($what,
			$CPAN::Config->{colorize_warn}||'bold red on_white'
			);
		};

	}

sub _clear_cpanpm_output { $scalar = '' }

sub _get_cpanpm_output   { $scalar }

my @skip_lines = (
	qr/^\QWarning \(usually harmless\)/,
	qr/\bwill not store persistent state\b/,
	qr(//hint//),
	qr/^\s+reports\s+/,
	);

sub _get_cpanpm_last_line
	{
	my $fh;
	if ($] < 5.008) {
		$fh = IO::Scalar->new(\ $scalar);
        } else {
		eval q{open $fh, "<", \\ $scalar;};
        }

	my @lines = <$fh>;

    # This is a bit ugly. Once we examine a line, we have to
    # examine the line before it and go through all of the same
    # regexes. I could do something fancy, but this works.
    REGEXES: {
	foreach my $regex ( @skip_lines )
		{
		if( $lines[-1] =~ m/$regex/ )
            {
            pop @lines;
            redo REGEXES; # we have to go through all of them for every line!
            }
		}
	}

    $logger->debug( "Last interesting line of CPAN.pm output is:\n\t$lines[-1]" );

	$lines[-1];
	}
}

BEGIN {
my $epic_fail_words = join '|',
	qw( Error stop(?:ping)? problems force not unsupported fail(?:ed)? );

sub _cpanpm_output_indicates_failure
	{
	my $last_line = _get_cpanpm_last_line();

	my $result = $last_line =~ /\b(?:$epic_fail_words)\b/i;
	$result || ();
	}
}

sub _cpanpm_output_indicates_success
	{
	my $last_line = _get_cpanpm_last_line();

	my $result = $last_line =~ /\b(?:\s+-- OK|PASS)\b/;
	$result || ();
	}

sub _cpanpm_output_is_vague
	{
	return FALSE if
		_cpanpm_output_indicates_failure() ||
		_cpanpm_output_indicates_success();

	return TRUE;
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
sub _turn_on_warnings {
	carp "Warnings are implemented yet";
	return HEY_IT_WORKED;
	}

sub _turn_off_testing {
	$logger->debug( 'Trusting test report history' );
	$CPAN::Config->{trust_test_report_history} = 1;
	return HEY_IT_WORKED;
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
sub _print_help
	{
	$logger->info( "Use perldoc to read the documentation" );
	exec "perldoc $0";
	}

sub _print_version # -v
	{
	$logger->info(
		"$0 script version $VERSION, CPAN.pm version " . CPAN->VERSION );

	return HEY_IT_WORKED;
	}

sub _print_details # -V
	{
	_print_version();

	_check_install_dirs();

	$logger->info( '-' x 50 . "\nChecking configured mirrors..." );
	foreach my $mirror ( @{ $CPAN::Config->{urllist} } ) {
		_print_ping_report( $mirror );
		}

	$logger->info( '-' x 50 . "\nChecking for faster mirrors..." );

	{
	require CPAN::Mirrors;

      if ( $CPAN::Config->{connect_to_internet_ok} ) {
        $CPAN::Frontend->myprint(qq{Trying to fetch a mirror list from the Internet\n});
        eval { CPAN::FTP->localize('MIRRORED.BY',File::Spec->catfile($CPAN::Config->{keep_source_where},'MIRRORED.BY'),3,1) }
          or $CPAN::Frontend->mywarn(<<'HERE');
We failed to get a copy of the mirror list from the Internet.
You will need to provide CPAN mirror URLs yourself.
HERE
        $CPAN::Frontend->myprint("\n");
      }

	my $mirrors   = CPAN::Mirrors->new(  );
	$mirrors->parse_mirrored_by( File::Spec->catfile($CPAN::Config->{keep_source_where},'MIRRORED.BY') );
	my @continents = $mirrors->find_best_continents;

	my @mirrors   = $mirrors->get_mirrors_by_continents( $continents[0] );
	my @timings   = $mirrors->get_mirrors_timings( \@mirrors );

	foreach my $timing ( @timings ) {
		$logger->info( sprintf "%s (%0.2f ms)",
			$timing->hostname, $timing->rtt );
		}
	}

	return HEY_IT_WORKED;
	}

sub _check_install_dirs
	{
	my $makepl_arg   = $CPAN::Config->{makepl_arg};
	my $mbuildpl_arg = $CPAN::Config->{mbuildpl_arg};

	my @custom_dirs;
	# PERL_MM_OPT
	push @custom_dirs,
		$makepl_arg   =~ m/INSTALL_BASE\s*=\s*(\S+)/g,
		$mbuildpl_arg =~ m/--install_base\s*=\s*(\S+)/g;

	if( @custom_dirs ) {
		foreach my $dir ( @custom_dirs ) {
			_print_inc_dir_report( $dir );
			}
		}

	# XXX: also need to check makepl_args, etc

	my @checks = (
		[ 'core',         [ grep $_, @Config{qw(installprivlib installarchlib)}      ] ],
		[ 'vendor',       [ grep $_, @Config{qw(installvendorlib installvendorarch)} ] ],
		[ 'site',         [ grep $_, @Config{qw(installsitelib installsitearch)}     ] ],
		[ 'PERL5LIB',     _split_paths( $ENV{PERL5LIB} ) ],
		[ 'PERLLIB',      _split_paths( $ENV{PERLLIB} )  ],
		);

	$logger->info( '-' x 50 . "\nChecking install dirs..." );
	foreach my $tuple ( @checks ) {
		my( $label ) = $tuple->[0];

		$logger->info( "Checking $label" );
		$logger->info( "\tno directories for $label" ) unless @{ $tuple->[1] };
		foreach my $dir ( @{ $tuple->[1] } ) {
			_print_inc_dir_report( $dir );
			}
		}

	}

sub _split_paths
	{
	[ map { _expand_filename( $_ ) } split /$Config{path_sep}/, $_[0] || '' ];
	}


=pod

Stolen from File::Path::Expand

=cut

sub _expand_filename
	{
    my( $path ) = @_;
    no warnings 'uninitialized';
    $logger->debug( "Expanding path $path\n" );
    $path =~ s{\A~([^/]+)?}{
		_home_of( $1 || $> ) || "~$1"
    	}e;
    return $path;
	}

sub _home_of
	{
	require User::pwent;
    my( $user ) = @_;
    my $ent = User::pwent::getpw($user) or return;
    return $ent->dir;
	}

sub _get_default_inc
	{
	require Config;

	[ @Config::Config{ _vars() }, '.' ];
	}

sub _vars {
	qw(
	installarchlib
	installprivlib
	installsitearch
	installsitelib
	);
	}

sub _ping_mirrors {
	my $urls   = $CPAN::Config->{urllist};
	require URI;

	foreach my $url ( @$urls ) {
		my( $obj ) = URI->new( $url );
		next unless _is_pingable_scheme( $obj );
		my $host = $obj->host;
		_print_ping_report( $obj );
		}

	}

sub _is_pingable_scheme {
	my( $uri ) = @_;

	$uri->scheme eq 'file'
	}

sub _find_good_mirrors {
	require CPAN::Mirrors;

	my $mirrors = CPAN::Mirrors->new;
	my $file = do {
		my $file = 'MIRRORED.BY';
		my $local_path = File::Spec->catfile(
			$CPAN::Config->{keep_source_where}, $file );

		if( -e $local_path ) { $local_path }
		else {
			require CPAN::FTP;
			CPAN::FTP->localize( $file, $local_path, 3, 1 );
			$local_path;
			}
		};

	$mirrors->parse_mirrored_by( $file );

	my @mirrors = $mirrors->best_mirrors(
		how_many   => 3,
		verbose    => 1,
		);

	foreach my $mirror ( @mirrors ) {
		next unless eval { $mirror->can( 'http' ) };
		_print_ping_report( $mirror->http );
		}

	}

sub _print_inc_dir_report
	{
	my( $dir ) = shift;

	my $writeable = -w $dir ? '+' : '!!! (not writeable)';
	$logger->info( "\t$writeable $dir" );
	return -w $dir;
	}

sub _print_ping_report
	{
	my( $mirror ) = @_;

	my $rtt = eval { _get_ping_report( $mirror ) };

	$logger->info(
		sprintf "\t%s (%4d ms) %s", $rtt  ? '+' : '!',  $rtt * 1000, $mirror
		);
	}

sub _get_ping_report
	{
	require URI;
	my( $mirror ) = @_;
	my( $url ) = ref $mirror ? $mirror : URI->new( $mirror ); #XXX
	require Net::Ping;

	my $ping = Net::Ping->new( 'tcp', 1 );

	if( $url->scheme eq 'file' ) {
		return -e $url->file;
		}

    my( $port ) = $url->port;

    return unless $port;

    if ( $ping->can('port_number') ) {
        $ping->port_number($port);
    	}
    else {
        $ping->{'port_num'} = $port;
    	}

    $ping->hires(1) if $ping->can( 'hires' );
    my( $alive, $rtt ) = eval{ $ping->ping( $url->host ) };
	$alive ? $rtt : undef;
	}

sub _load_local_lib # -I
	{
	$logger->debug( "Loading local::lib" );

	my $rc = _safe_load_module("local::lib");
	unless( $rc ) {
		$logger->die( "Could not load local::lib" );
		}

	local::lib->import;

	return HEY_IT_WORKED;
	}

sub _create_autobundle
	{
	$logger->info(
		"Creating autobundle in $CPAN::Config->{cpan_home}/Bundle" );

	CPAN::Shell->autobundle;

	return HEY_IT_WORKED;
	}

sub _recompile
	{
	$logger->info( "Recompiling dynamically-loaded extensions" );

	CPAN::Shell->recompile;

	return HEY_IT_WORKED;
	}

sub _upgrade
	{
	$logger->info( "Upgrading all modules" );

	CPAN::Shell->upgrade();

	return HEY_IT_WORKED;
	}

sub _load_config # -j
	{
	my $file = shift || '';

	# should I clear out any existing config here?
	$CPAN::Config = {};
	delete $INC{'CPAN/Config.pm'};
	croak( "Config file [$file] does not exist!\n" ) unless -e $file;

	my $rc = eval "require '$file'";

	# CPAN::HandleConfig::require_myconfig_or_config looks for this
	$INC{'CPAN/MyConfig.pm'} = 'fake out!';

	# CPAN::HandleConfig::load looks for this
	$CPAN::Config_loaded = 'fake out';

	croak( "Could not load [$file]: $@\n") unless $rc;

	return HEY_IT_WORKED;
	}

sub _dump_config # -J
	{
	my $args = shift;
	require Data::Dumper;

	my $fh = $args->[0] || \*STDOUT;

	local $Data::Dumper::Sortkeys = 1;
	my $dd = Data::Dumper->new(
		[$CPAN::Config],
		['$CPAN::Config']
		);

	print $fh $dd->Dump, "\n1;\n__END__\n";

	return HEY_IT_WORKED;
	}

sub _lock_lobotomy # -F
	{
	no warnings 'redefine';

	*CPAN::_flock    = sub { 1 };
	*CPAN::checklock = sub { 1 };

	return HEY_IT_WORKED;
	}

sub _download
	{
	my $args = shift;

	local $CPAN::DEBUG = 1;

	my %paths;

	foreach my $module ( @$args )
		{
		$logger->info( "Checking $module" );
		my $path = CPAN::Shell->expand( "Module", $module )->cpan_file;

		$logger->debug( "Inst file would be $path\n" );

		$paths{$module} = _get_file( _make_path( $path ) );
		}

	return \%paths;
	}

sub _make_path { join "/", qw(authors id), $_[0] }

sub _get_file
	{
	my $path = shift;

	my $loaded = _safe_load_module("LWP::Simple");
	croak "You need LWP::Simple to use features that fetch files from CPAN\n"
		unless $loaded;

	my $file = substr $path, rindex( $path, '/' ) + 1;
	my $store_path = catfile( cwd(), $file );
	$logger->debug( "Store path is $store_path" );

	foreach my $site ( @{ $CPAN::Config->{urllist} } )
		{
		my $fetch_path = join "/", $site, $path;
		$logger->debug( "Trying $fetch_path" );
	    last if LWP::Simple::getstore( $fetch_path, $store_path );
		}

	return $store_path;
	}

sub _gitify
	{
	my $args = shift;

	my $loaded = _safe_load_module("Archive::Extract");
	croak "You need Archive::Extract to use features that gitify distributions\n"
		unless $loaded;

	my $starting_dir = cwd();

	foreach my $module ( @$args )
		{
		$logger->info( "Checking $module" );
		my $path = CPAN::Shell->expand( "Module", $module )->cpan_file;

		my $store_paths = _download( [ $module ] );
		$logger->debug( "gitify Store path is $store_paths->{$module}" );
		my $dirname = dirname( $store_paths->{$module} );

		my $ae = Archive::Extract->new( archive => $store_paths->{$module} );
		$ae->extract( to => $dirname );

		chdir $ae->extract_path;

		my $git = $ENV{GIT_COMMAND} || '/usr/local/bin/git';
		croak "Could not find $git"    unless -e $git;
		croak "$git is not executable" unless -x $git;

		# can we do this in Pure Perl?
		system( $git, 'init'    );
		system( $git, qw( add . ) );
		system( $git, qw( commit -a -m ), 'initial import' );
		}

	chdir $starting_dir;

	return HEY_IT_WORKED;
	}

sub _show_Changes
	{
	my $args = shift;

	foreach my $arg ( @$args )
		{
		$logger->info( "Checking $arg\n" );

		my $module = eval { CPAN::Shell->expand( "Module", $arg ) };
		my $out = _get_cpanpm_output();

		next unless eval { $module->inst_file };
		#next if $module->uptodate;

		( my $id = $module->id() ) =~ s/::/\-/;

		my $url = "http://search.cpan.org/~" . lc( $module->userid ) . "/" .
			$id . "-" . $module->cpan_version() . "/";

		#print "URL: $url\n";
		_get_changes_file($url);
		}

	return HEY_IT_WORKED;
	}

sub _get_changes_file
	{
	croak "Reading Changes files requires LWP::Simple and URI\n"
		unless _safe_load_module("LWP::Simple") && _safe_load_module("URI");

    my $url = shift;

    my $content = LWP::Simple::get( $url );
    $logger->info( "Got $url ..." ) if defined $content;
	#print $content;

	my( $change_link ) = $content =~ m|<a href="(.*?)">Changes</a>|gi;

	my $changes_url = URI->new_abs( $change_link, $url );
 	$logger->debug( "Change link is: $changes_url" );

	my $changes =  LWP::Simple::get( $changes_url );

	print $changes;

	return HEY_IT_WORKED;
	}

sub _show_Author
	{
	my $args = shift;

	foreach my $arg ( @$args )
		{
		my $module = CPAN::Shell->expand( "Module", $arg );
		unless( $module )
			{
			$logger->info( "Didn't find a $arg module, so no author!" );
			next;
			}

		my $author = CPAN::Shell->expand( "Author", $module->userid );

		next unless $module->userid;

		printf "%-25s %-8s %-25s %s\n",
			$arg, $module->userid, $author->email, $author->name;
		}

	return HEY_IT_WORKED;
	}

sub _show_Details
	{
	my $args = shift;

	foreach my $arg ( @$args )
		{
		my $module = CPAN::Shell->expand( "Module", $arg );
		my $author = CPAN::Shell->expand( "Author", $module->userid );

		next unless $module->userid;

		print "$arg\n", "-" x 73, "\n\t";
		print join "\n\t",
			$module->description ? $module->description : "(no description)",
			$module->cpan_file,
			$module->inst_file,
			'Installed: ' . $module->inst_version,
			'CPAN:      ' . $module->cpan_version . '  ' .
				($module->uptodate ? "" : "Not ") . "up to date",
			$author->fullname . " (" . $module->userid . ")",
			$author->email;
		print "\n\n";

		}

	return HEY_IT_WORKED;
	}

sub _show_out_of_date
	{
	my @modules = CPAN::Shell->expand( "Module", "/./" );

	printf "%-40s  %6s  %6s\n", "Module Name", "Local", "CPAN";
	print "-" x 73, "\n";

	foreach my $module ( @modules )
		{
		next unless $module->inst_file;
		next if $module->uptodate;
		printf "%-40s  %.4f  %.4f\n",
			$module->id,
			$module->inst_version ? $module->inst_version : '',
			$module->cpan_version;
		}

	return HEY_IT_WORKED;
	}

sub _show_author_mods
	{
	my $args = shift;

	my %hash = map { lc $_, 1 } @$args;

	my @modules = CPAN::Shell->expand( "Module", "/./" );

	foreach my $module ( @modules )
		{
		next unless exists $hash{ lc $module->userid };
		print $module->id, "\n";
		}

	return HEY_IT_WORKED;
	}

sub _list_all_mods # -l
	{
	require File::Find;

	my $args = shift;


	my $fh = \*STDOUT;

	INC: foreach my $inc ( @INC )
		{
		my( $wanted, $reporter ) = _generator();
		File::Find::find( { wanted => $wanted }, $inc );

		my $count = 0;
		FILE: foreach my $file ( @{ $reporter->() } )
			{
			my $version = _parse_version_safely( $file );

			my $module_name = _path_to_module( $inc, $file );
			next FILE unless defined $module_name;

			print $fh "$module_name\t$version\n";

			#last if $count++ > 5;
			}
		}

	return HEY_IT_WORKED;
	}

sub _generator
	{
	my @files = ();

	sub { push @files,
		File::Spec->canonpath( $File::Find::name )
		if m/\A\w+\.pm\z/ },
	sub { \@files },
	}

sub _parse_version_safely # stolen from PAUSE's mldistwatch, but refactored
	{
	my( $file ) = @_;

	local $/ = "\n";
	local $_; # don't mess with the $_ in the map calling this

	return unless open FILE, "<$file";

	my $in_pod = 0;
	my $version;
	while( <FILE> )
		{
		chomp;
		$in_pod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $in_pod;
		next if $in_pod || /^\s*#/;

		next unless /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
		my( $sigil, $var ) = ( $1, $2 );

		$version = _eval_version( $_, $sigil, $var );
		last;
		}
	close FILE;

	return 'undef' unless defined $version;

	return $version;
	}

sub _eval_version
	{
	my( $line, $sigil, $var ) = @_;

        # split package line to hide from PAUSE
	my $eval = qq{
		package
                  ExtUtils::MakeMaker::_version;

		local $sigil$var;
		\$$var=undef; do {
			$line
			}; \$$var
		};

	my $version = do {
		local $^W = 0;
		no strict;
		eval( $eval );
		};

	return $version;
	}

sub _path_to_module
	{
	my( $inc, $path ) = @_;
	return if length $path< length $inc;

	my $module_path = substr( $path, length $inc );
	$module_path =~ s/\.pm\z//;

	# XXX: this is cheating and doesn't handle everything right
	my @dirs = grep { ! /\W/ } File::Spec->splitdir( $module_path );
	shift @dirs;

	my $module_name = join "::", @dirs;

	return $module_name;
	}

1;

=back

=head1 EXIT VALUES

The script exits with zero if it thinks that everything worked, or a
positive number if it thinks that something failed. Note, however, that
in some cases it has to divine a failure by the output of things it does
not control. For now, the exit codes are vague:

	1	An unknown error

	2	The was an external problem

	4	There was an internal problem with the script

	8	A module failed to install

=head1 TO DO

* There is initial support for Log4perl if it is available, but I
haven't gone through everything to make the NullLogger work out
correctly if Log4perl is not installed.

* When I capture CPAN.pm output, I need to check for errors and
report them to the user.

* Support local::lib

* Warnings switch

* Check then exit

* ping mirrors support

* no test option

=head1 BUGS

* none noted

=head1 SEE ALSO

Most behaviour, including environment variables and configuration,
comes directly from CPAN.pm.

=head1 SOURCE AVAILABILITY

This code is in Github:

	git://github.com/briandfoy/cpan_script.git

=head1 CREDITS

Japheth Cleaver added the bits to allow a forced install (C<-f>).

Jim Brandt suggest and provided the initial implementation for the
up-to-date and Changes features.

Adam Kennedy pointed out that C<exit()> causes problems on Windows
where this script ends up with a .bat extension

David Golden helps integrate this into the C<CPAN.pm> repos.

=head1 AUTHOR

brian d foy, C<< <bdfoy@cpan.org> >>

=head1 COPYRIGHT

Copyright (c) 2001-2013, brian d foy, All Rights Reserved.

You may redistribute this under the same terms as Perl itself.

=cut
                                                                                                                                                                        usr/share/perl/5.20.2/App/Prove/                                                                    0040755 0000000 0000000 00000000000 13077704254 014475  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/App/Prove/State/                                                              0040755 0000000 0000000 00000000000 13077704254 015555  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/App/Prove/State/Result/                                                       0040755 0000000 0000000 00000000000 13077704254 017033  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/App/Prove/State/Result/Test.pm                                                0100644 0000000 0000000 00000006532 12744441327 020312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package App::Prove::State::Result::Test;

use strict;
use warnings;

=head1 NAME

App::Prove::State::Result::Test - Individual test results.

=head1 VERSION

Version 3.30

=cut

our $VERSION = '3.30';

=head1 DESCRIPTION

The C<prove> command supports a C<--state> option that instructs it to
store persistent state across runs. This module encapsulates the results for a
single test.

=head1 SYNOPSIS

    # Re-run failed tests
    $ prove --state=failed,save -rbv

=cut

my %methods = (
    name           => { method => 'name' },
    elapsed        => { method => 'elapsed', default => 0 },
    gen            => { method => 'generation', default => 1 },
    last_pass_time => { method => 'last_pass_time', default => undef },
    last_fail_time => { method => 'last_fail_time', default => undef },
    last_result    => { method => 'result', default => 0 },
    last_run_time  => { method => 'run_time', default => undef },
    last_todo      => { method => 'num_todo', default => 0 },
    mtime          => { method => 'mtime', default => undef },
    seq            => { method => 'sequence', default => 1 },
    total_passes   => { method => 'total_passes', default => 0 },
    total_failures => { method => 'total_failures', default => 0 },
    parser         => { method => 'parser' },
);

while ( my ( $key, $description ) = each %methods ) {
    my $default = $description->{default};
    no strict 'refs';
    *{ $description->{method} } = sub {
        my $self = shift;
        if (@_) {
            $self->{$key} = shift;
            return $self;
        }
        return $self->{$key} || $default;
    };
}

=head1 METHODS

=head2 Class Methods

=head3 C<new>

=cut

sub new {
    my ( $class, $arg_for ) = @_;
    $arg_for ||= {};
    bless $arg_for => $class;
}

=head2 Instance Methods

=head3 C<name>

The name of the test.  Usually a filename.

=head3 C<elapsed>

The total elapsed times the test took to run, in seconds from the epoch..

=head3 C<generation>

The number for the "generation" of the test run.  The first generation is 1
(one) and subsequent generations are 2, 3, etc.

=head3 C<last_pass_time>

The last time the test program passed, in seconds from the epoch.

Returns C<undef> if the program has never passed.

=head3 C<last_fail_time>

The last time the test suite failed, in seconds from the epoch.

Returns C<undef> if the program has never failed.

=head3 C<mtime>

Returns the mtime of the test, in seconds from the epoch.

=head3 C<raw>

Returns a hashref of raw test data, suitable for serialization by YAML.

=head3 C<result>

Currently, whether or not the test suite passed with no 'problems' (such as
TODO passed).

=head3 C<run_time>

The total time it took for the test to run, in seconds.  If C<Time::HiRes> is
available, it will have finer granularity.

=head3 C<num_todo>

The number of tests with TODO directives.

=head3 C<sequence>

The order in which this test was run for the given test suite result. 

=head3 C<total_passes>

The number of times the test has passed.

=head3 C<total_failures>

The number of times the test has failed.

=head3 C<parser>

The underlying parser object.  This is useful if you need the full
information for the test program.

=cut

sub raw {
    my $self = shift;
    my %raw  = %$self;

    # this is backwards-compatibility hack and is not guaranteed.
    delete $raw{name};
    delete $raw{parser};
    return \%raw;
}

1;
                                                                                                                                                                      usr/share/perl/5.20.2/App/Prove/State/Result.pm                                                     0100644 0000000 0000000 00000011521 12744441327 017365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package App::Prove::State::Result;

use strict;
use warnings;
use Carp 'croak';

use App::Prove::State::Result::Test;

use constant STATE_VERSION => 1;

=head1 NAME

App::Prove::State::Result - Individual test suite results.

=head1 VERSION

Version 3.30

=cut

our $VERSION = '3.30';

=head1 DESCRIPTION

The C<prove> command supports a C<--state> option that instructs it to
store persistent state across runs. This module encapsulates the results for a
single test suite run.

=head1 SYNOPSIS

    # Re-run failed tests
    $ prove --state=failed,save -rbv

=cut

=head1 METHODS

=head2 Class Methods

=head3 C<new>

    my $result = App::Prove::State::Result->new({
        generation => $generation,
        tests      => \%tests,
    });

Returns a new C<App::Prove::State::Result> instance.

=cut

sub new {
    my ( $class, $arg_for ) = @_;
    $arg_for ||= {};
    my %instance_data = %$arg_for;    # shallow copy
    $instance_data{version} = $class->state_version;
    my $tests = delete $instance_data{tests} || {};
    my $self = bless \%instance_data => $class;
    $self->_initialize($tests);
    return $self;
}

sub _initialize {
    my ( $self, $tests ) = @_;
    my %tests;
    while ( my ( $name, $test ) = each %$tests ) {
        $tests{$name} = $self->test_class->new(
            {   %$test,
                name => $name
            }
        );
    }
    $self->tests( \%tests );
    return $self;
}

=head2 C<state_version>

Returns the current version of state storage.

=cut

sub state_version {STATE_VERSION}

=head2 C<test_class>

Returns the name of the class used for tracking individual tests.  This class
should either subclass from C<App::Prove::State::Result::Test> or provide an
identical interface.

=cut

sub test_class {
    return 'App::Prove::State::Result::Test';
}

my %methods = (
    generation    => { method => 'generation',    default => 0 },
    last_run_time => { method => 'last_run_time', default => undef },
);

while ( my ( $key, $description ) = each %methods ) {
    my $default = $description->{default};
    no strict 'refs';
    *{ $description->{method} } = sub {
        my $self = shift;
        if (@_) {
            $self->{$key} = shift;
            return $self;
        }
        return $self->{$key} || $default;
    };
}

=head3 C<generation>

Getter/setter for the "generation" of the test suite run. The first
generation is 1 (one) and subsequent generations are 2, 3, etc.

=head3 C<last_run_time>

Getter/setter for the time of the test suite run.

=head3 C<tests>

Returns the tests for a given generation. This is a hashref or a hash,
depending on context called. The keys to the hash are the individual
test names and the value is a hashref with various interesting values.
Each k/v pair might resemble something like this:

 't/foo.t' => {
    elapsed        => '0.0428488254547119',
    gen            => '7',
    last_pass_time => '1219328376.07815',
    last_result    => '0',
    last_run_time  => '1219328376.07815',
    last_todo      => '0',
    mtime          => '1191708862',
    seq            => '192',
    total_passes   => '6',
  }

=cut

sub tests {
    my $self = shift;
    if (@_) {
        $self->{tests} = shift;
        return $self;
    }
    my %tests = %{ $self->{tests} };
    my @tests = sort { $a->sequence <=> $b->sequence } values %tests;
    return wantarray ? @tests : \@tests;
}

=head3 C<test>

 my $test = $result->test('t/customer/create.t');

Returns an individual C<App::Prove::State::Result::Test> instance for the
given test name (usually the filename).  Will return a new
C<App::Prove::State::Result::Test> instance if the name is not found.

=cut

sub test {
    my ( $self, $name ) = @_;
    croak("test() requires a test name") unless defined $name;

    my $tests = $self->{tests} ||= {};
    if ( my $test = $tests->{$name} ) {
        return $test;
    }
    else {
        my $test = $self->test_class->new( { name => $name } );
        $self->{tests}->{$name} = $test;
        return $test;
    }
}

=head3 C<test_names>

Returns an list of test names, sorted by run order.

=cut

sub test_names {
    my $self = shift;
    return map { $_->name } $self->tests;
}

=head3 C<remove>

 $result->remove($test_name);            # remove the test
 my $test = $result->test($test_name);   # fatal error

Removes a given test from results.  This is a no-op if the test name is not
found.

=cut

sub remove {
    my ( $self, $name ) = @_;
    delete $self->{tests}->{$name};
    return $self;
}

=head3 C<num_tests>

Returns the number of tests for a given test suite result.

=cut

sub num_tests { keys %{ shift->{tests} } }

=head3 C<raw>

Returns a hashref of raw results, suitable for serialization by YAML.

=cut

sub raw {
    my $self = shift;
    my %raw  = %$self;

    my %tests;
    for my $test ( $self->tests ) {
        $tests{ $test->name } = $test->raw;
    }
    $raw{tests} = \%tests;
    return \%raw;
}

1;
                                                                                                                                                                               usr/share/perl/5.20.2/App/Prove/State.pm                                                            0100644 0000000 0000000 00000026651 12744441327 016121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package App::Prove::State;

use strict;
use warnings;

use File::Find;
use File::Spec;
use Carp;

use App::Prove::State::Result;
use TAP::Parser::YAMLish::Reader ();
use TAP::Parser::YAMLish::Writer ();
use base 'TAP::Base';

BEGIN {
    __PACKAGE__->mk_methods('result_class');
}

use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
use constant NEED_GLOB => IS_WIN32;

=head1 NAME

App::Prove::State - State storage for the C<prove> command.

=head1 VERSION

Version 3.30

=cut

our $VERSION = '3.30';

=head1 DESCRIPTION

The C<prove> command supports a C<--state> option that instructs it to
store persistent state across runs. This module implements that state
and the operations that may be performed on it.

=head1 SYNOPSIS

    # Re-run failed tests
    $ prove --state=failed,save -rbv

=cut

=head1 METHODS

=head2 Class Methods

=head3 C<new>

Accepts a hashref with the following key/value pairs:

=over 4

=item * C<store>

The filename of the data store holding the data that App::Prove::State reads.

=item * C<extensions> (optional)

The test name extensions.  Defaults to C<.t>.

=item * C<result_class> (optional)

The name of the C<result_class>.  Defaults to C<App::Prove::State::Result>.

=back

=cut

# override TAP::Base::new:
sub new {
    my $class = shift;
    my %args = %{ shift || {} };

    my $self = bless {
        select     => [],
        seq        => 1,
        store      => delete $args{store},
        extensions => ( delete $args{extensions} || ['.t'] ),
        result_class =>
          ( delete $args{result_class} || 'App::Prove::State::Result' ),
    }, $class;

    $self->{_} = $self->result_class->new(
        {   tests      => {},
            generation => 1,
        }
    );
    my $store = $self->{store};
    $self->load($store)
      if defined $store && -f $store;

    return $self;
}

=head2 C<result_class>

Getter/setter for the name of the class used for tracking test results.  This
class should either subclass from C<App::Prove::State::Result> or provide an
identical interface.

=cut

=head2 C<extensions>

Get or set the list of extensions that files must have in order to be
considered tests. Defaults to ['.t'].

=cut

sub extensions {
    my $self = shift;
    $self->{extensions} = shift if @_;
    return $self->{extensions};
}

=head2 C<results>

Get the results of the last test run.  Returns a C<result_class()> instance.

=cut

sub results {
    my $self = shift;
    $self->{_} || $self->result_class->new;
}

=head2 C<commit>

Save the test results. Should be called after all tests have run.

=cut

sub commit {
    my $self = shift;
    if ( $self->{should_save} ) {
        $self->save;
    }
}

=head2 Instance Methods

=head3 C<apply_switch>

 $self->apply_switch('failed,save');

Apply a list of switch options to the state, updating the internal
object state as a result. Nothing is returned.

Diagnostics:
    - "Illegal state option: %s"

=over

=item C<last>

Run in the same order as last time

=item C<failed>

Run only the failed tests from last time

=item C<passed>

Run only the passed tests from last time

=item C<all>

Run all tests in normal order

=item C<hot>

Run the tests that most recently failed first

=item C<todo>

Run the tests ordered by number of todos.

=item C<slow>

Run the tests in slowest to fastest order.

=item C<fast>

Run test tests in fastest to slowest order.

=item C<new>

Run the tests in newest to oldest order.

=item C<old>

Run the tests in oldest to newest order.

=item C<save>

Save the state on exit.

=back

=cut

sub apply_switch {
    my $self = shift;
    my @opts = @_;

    my $last_gen      = $self->results->generation - 1;
    my $last_run_time = $self->results->last_run_time;
    my $now           = $self->get_time;

    my @switches = map { split /,/ } @opts;

    my %handler = (
        last => sub {
            $self->_select(
                limit => shift,
                where => sub { $_->generation >= $last_gen },
                order => sub { $_->sequence }
            );
        },
        failed => sub {
            $self->_select(
                limit => shift,
                where => sub { $_->result != 0 },
                order => sub { -$_->result }
            );
        },
        passed => sub {
            $self->_select(
                limit => shift,
                where => sub { $_->result == 0 }
            );
        },
        all => sub {
            $self->_select( limit => shift );
        },
        todo => sub {
            $self->_select(
                limit => shift,
                where => sub { $_->num_todo != 0 },
                order => sub { -$_->num_todo; }
            );
        },
        hot => sub {
            $self->_select(
                limit => shift,
                where => sub { defined $_->last_fail_time },
                order => sub { $now - $_->last_fail_time }
            );
        },
        slow => sub {
            $self->_select(
                limit => shift,
                order => sub { -$_->elapsed }
            );
        },
        fast => sub {
            $self->_select(
                limit => shift,
                order => sub { $_->elapsed }
            );
        },
        new => sub {
            $self->_select(
                limit => shift,
                order => sub { -$_->mtime }
            );
        },
        old => sub {
            $self->_select(
                limit => shift,
                order => sub { $_->mtime }
            );
        },
        fresh => sub {
            $self->_select(
                limit => shift,
                where => sub { $_->mtime >= $last_run_time }
            );
        },
        save => sub {
            $self->{should_save}++;
        },
        adrian => sub {
            unshift @switches, qw( hot all save );
        },
    );

    while ( defined( my $ele = shift @switches ) ) {
        my ( $opt, $arg )
          = ( $ele =~ /^([^:]+):(.*)/ )
          ? ( $1, $2 )
          : ( $ele, undef );
        my $code = $handler{$opt}
          || croak "Illegal state option: $opt";
        $code->($arg);
    }
    return;
}

sub _select {
    my ( $self, %spec ) = @_;
    push @{ $self->{select} }, \%spec;
}

=head3 C<get_tests>

Given a list of args get the names of tests that should run

=cut

sub get_tests {
    my $self    = shift;
    my $recurse = shift;
    my @argv    = @_;
    my %seen;

    my @selected = $self->_query;

    unless ( @argv || @{ $self->{select} } ) {
        @argv = $recurse ? '.' : 't';
        croak qq{No tests named and '@argv' directory not found}
          unless -d $argv[0];
    }

    push @selected, $self->_get_raw_tests( $recurse, @argv ) if @argv;
    return grep { !$seen{$_}++ } @selected;
}

sub _query {
    my $self = shift;
    if ( my @sel = @{ $self->{select} } ) {
        warn "No saved state, selection will be empty\n"
          unless $self->results->num_tests;
        return map { $self->_query_clause($_) } @sel;
    }
    return;
}

sub _query_clause {
    my ( $self, $clause ) = @_;
    my @got;
    my $results = $self->results;
    my $where = $clause->{where} || sub {1};

    # Select
    for my $name ( $results->test_names ) {
        next unless -f $name;
        local $_ = $results->test($name);
        push @got, $name if $where->();
    }

    # Sort
    if ( my $order = $clause->{order} ) {
        @got = map { $_->[0] }
          sort {
                 ( defined $b->[1] <=> defined $a->[1] )
              || ( ( $a->[1] || 0 ) <=> ( $b->[1] || 0 ) )
          } map {
            [   $_,
                do { local $_ = $results->test($_); $order->() }
            ]
          } @got;
    }

    if ( my $limit = $clause->{limit} ) {
        @got = splice @got, 0, $limit if @got > $limit;
    }

    return @got;
}

sub _get_raw_tests {
    my $self    = shift;
    my $recurse = shift;
    my @argv    = @_;
    my @tests;

    # Do globbing on Win32.
    if (NEED_GLOB) {
        eval "use File::Glob::Windows";    # [49732]
        @argv = map { glob "$_" } @argv;
    }
    my $extensions = $self->{extensions};

    for my $arg (@argv) {
        if ( '-' eq $arg ) {
            push @argv => <STDIN>;
            chomp(@argv);
            next;
        }

        push @tests,
            sort -d $arg
          ? $recurse
              ? $self->_expand_dir_recursive( $arg, $extensions )
              : map { glob( File::Spec->catfile( $arg, "*$_" ) ) }
              @{$extensions}
          : $arg;
    }
    return @tests;
}

sub _expand_dir_recursive {
    my ( $self, $dir, $extensions ) = @_;

    my @tests;
    my $ext_string = join( '|', map {quotemeta} @{$extensions} );

    find(
        {   follow      => 1,      #21938
            follow_skip => 2,
            wanted      => sub {
                -f 
                  && /(?:$ext_string)$/
                  && push @tests => $File::Find::name;
              }
        },
        $dir
    );
    return @tests;
}

=head3 C<observe_test>

Store the results of a test.

=cut

# Store:
#     last fail time
#     last pass time
#     last run time
#     most recent result
#     most recent todos
#     total failures
#     total passes
#     state generation
#     parser

sub observe_test {

    my ( $self, $test_info, $parser ) = @_;
    my $name = $test_info->[0];
    my $fail = scalar( $parser->failed ) + ( $parser->has_problems ? 1 : 0 );
    my $todo = scalar( $parser->todo );
    my $start_time = $parser->start_time;
    my $end_time   = $parser->end_time,

      my $test = $self->results->test($name);

    $test->sequence( $self->{seq}++ );
    $test->generation( $self->results->generation );

    $test->run_time($end_time);
    $test->result($fail);
    $test->num_todo($todo);
    $test->elapsed( $end_time - $start_time );

    $test->parser($parser);

    if ($fail) {
        $test->total_failures( $test->total_failures + 1 );
        $test->last_fail_time($end_time);
    }
    else {
        $test->total_passes( $test->total_passes + 1 );
        $test->last_pass_time($end_time);
    }
}

=head3 C<save>

Write the state to a file.

=cut

sub save {
    my ($self) = @_;

    my $store = $self->{store} or return;
    $self->results->last_run_time( $self->get_time );

    my $writer = TAP::Parser::YAMLish::Writer->new;
    local *FH;
    open FH, ">$store" or croak "Can't write $store ($!)";
    $writer->write( $self->results->raw, \*FH );
    close FH;
}

=head3 C<load>

Load the state from a file

=cut

sub load {
    my ( $self, $name ) = @_;
    my $reader = TAP::Parser::YAMLish::Reader->new;
    local *FH;
    open FH, "<$name" or croak "Can't read $name ($!)";

    # XXX this is temporary
    $self->{_} = $self->result_class->new(
        $reader->read(
            sub {
                my $line = <FH>;
                defined $line && chomp $line;
                return $line;
            }
        )
    );

    # $writer->write( $self->{tests} || {}, \*FH );
    close FH;
    $self->_regen_seq;
    $self->_prune_and_stamp;
    $self->results->generation( $self->results->generation + 1 );
}

sub _prune_and_stamp {
    my $self = shift;

    my $results = $self->results;
    my @tests   = $self->results->tests;
    for my $test (@tests) {
        my $name = $test->name;
        if ( my @stat = stat $name ) {
            $test->mtime( $stat[9] );
        }
        else {
            $results->remove($name);
        }
    }
}

sub _regen_seq {
    my $self = shift;
    for my $test ( $self->results->tests ) {
        $self->{seq} = $test->sequence + 1
          if defined $test->sequence && $test->sequence >= $self->{seq};
    }
}

1;
                                                                                       usr/share/perl/5.20.2/App/Prove.pm                                                                  0100644 0000000 0000000 00000045356 12744441327 015044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package App::Prove;

use strict;
use warnings;

use TAP::Harness;
use Text::ParseWords qw(shellwords);
use File::Spec;
use Getopt::Long;
use App::Prove::State;
use Carp;

use base 'TAP::Object';

=head1 NAME

App::Prove - Implements the C<prove> command.

=head1 VERSION

Version 3.30

=cut

our $VERSION = '3.30';

=head1 DESCRIPTION

L<Test::Harness> provides a command, C<prove>, which runs a TAP based
test suite and prints a report. The C<prove> command is a minimal
wrapper around an instance of this module.

=head1 SYNOPSIS

    use App::Prove;

    my $app = App::Prove->new;
    $app->process_args(@ARGV);
    $app->run;

=cut

use constant IS_WIN32 => ( $^O =~ /^(MS)?Win32$/ );
use constant IS_VMS => $^O eq 'VMS';
use constant IS_UNIXY => !( IS_VMS || IS_WIN32 );

use constant STATE_FILE => IS_UNIXY ? '.prove'   : '_prove';
use constant RC_FILE    => IS_UNIXY ? '.proverc' : '_proverc';

use constant PLUGINS => 'App::Prove::Plugin';

my @ATTR;

BEGIN {
    @ATTR = qw(
      archive argv blib show_count color directives exec failures comments
      formatter harness includes modules plugins jobs lib merge parse quiet
      really_quiet recurse backwards shuffle taint_fail taint_warn timer
      verbose warnings_fail warnings_warn show_help show_man show_version
      state_class test_args state dry extensions ignore_exit rules state_manager
      normalize sources tapversion trap
    );
    __PACKAGE__->mk_methods(@ATTR);
}

=head1 METHODS

=head2 Class Methods

=head3 C<new>

Create a new C<App::Prove>. Optionally a hash ref of attribute
initializers may be passed.

=cut

# new() implementation supplied by TAP::Object

sub _initialize {
    my $self = shift;
    my $args = shift || {};

    my @is_array = qw(
      argv rc_opts includes modules state plugins rules sources
    );

    # setup defaults:
    for my $key (@is_array) {
        $self->{$key} = [];
    }
    $self->{harness_class} = 'TAP::Harness';

    for my $attr (@ATTR) {
        if ( exists $args->{$attr} ) {

            # TODO: Some validation here
            $self->{$attr} = $args->{$attr};
        }
    }

    my %env_provides_default = (
        HARNESS_TIMER => 'timer',
    );

    while ( my ( $env, $attr ) = each %env_provides_default ) {
        $self->{$attr} = 1 if $ENV{$env};
    }
    $self->state_class('App::Prove::State');
    return $self;
}

=head3 C<state_class>

Getter/setter for the name of the class used for maintaining state.  This
class should either subclass from C<App::Prove::State> or provide an identical
interface.

=head3 C<state_manager>

Getter/setter for the instance of the C<state_class>.

=cut

=head3 C<add_rc_file>

    $prove->add_rc_file('myproj/.proverc');

Called before C<process_args> to prepend the contents of an rc file to
the options.

=cut

sub add_rc_file {
    my ( $self, $rc_file ) = @_;

    local *RC;
    open RC, "<$rc_file" or croak "Can't read $rc_file ($!)";
    while ( defined( my $line = <RC> ) ) {
        push @{ $self->{rc_opts} },
          grep { defined and not /^#/ }
          $line =~ m{ ' ([^']*) ' | " ([^"]*) " | (\#.*) | (\S+) }xg;
    }
    close RC;
}

=head3 C<process_args>

    $prove->process_args(@args);

Processes the command-line arguments. Attributes will be set
appropriately. Any filenames may be found in the C<argv> attribute.

Dies on invalid arguments.

=cut

sub process_args {
    my $self = shift;

    my @rc = RC_FILE;
    unshift @rc, glob '~/' . RC_FILE if IS_UNIXY;

    # Preprocess meta-args.
    my @args;
    while ( defined( my $arg = shift ) ) {
        if ( $arg eq '--norc' ) {
            @rc = ();
        }
        elsif ( $arg eq '--rc' ) {
            defined( my $rc = shift )
              or croak "Missing argument to --rc";
            push @rc, $rc;
        }
        elsif ( $arg =~ m{^--rc=(.+)$} ) {
            push @rc, $1;
        }
        else {
            push @args, $arg;
        }
    }

    # Everything after the arisdottle '::' gets passed as args to
    # test programs.
    if ( defined( my $stop_at = _first_pos( '::', @args ) ) ) {
        my @test_args = splice @args, $stop_at;
        shift @test_args;
        $self->{test_args} = \@test_args;
    }

    # Grab options from RC files
    $self->add_rc_file($_) for grep -f, @rc;
    unshift @args, @{ $self->{rc_opts} };

    if ( my @bad = map {"-$_"} grep {/^-(man|help)$/} @args ) {
        die "Long options should be written with two dashes: ",
          join( ', ', @bad ), "\n";
    }

    # And finally...

    {
        local @ARGV = @args;
        Getopt::Long::Configure(qw(no_ignore_case bundling pass_through));

        # Don't add coderefs to GetOptions
        GetOptions(
            'v|verbose'  => \$self->{verbose},
            'f|failures' => \$self->{failures},
            'o|comments' => \$self->{comments},
            'l|lib'      => \$self->{lib},
            'b|blib'     => \$self->{blib},
            's|shuffle'  => \$self->{shuffle},
            'color!'     => \$self->{color},
            'colour!'    => \$self->{color},
            'count!'     => \$self->{show_count},
            'c'          => \$self->{color},
            'D|dry'      => \$self->{dry},
            'ext=s@'     => sub {
                my ( $opt, $val ) = @_;

                # Workaround for Getopt::Long 2.25 handling of
                # multivalue options
                push @{ $self->{extensions} ||= [] }, $val;
            },
            'harness=s'    => \$self->{harness},
            'ignore-exit'  => \$self->{ignore_exit},
            'source=s@'    => $self->{sources},
            'formatter=s'  => \$self->{formatter},
            'r|recurse'    => \$self->{recurse},
            'reverse'      => \$self->{backwards},
            'p|parse'      => \$self->{parse},
            'q|quiet'      => \$self->{quiet},
            'Q|QUIET'      => \$self->{really_quiet},
            'e|exec=s'     => \$self->{exec},
            'm|merge'      => \$self->{merge},
            'I=s@'         => $self->{includes},
            'M=s@'         => $self->{modules},
            'P=s@'         => $self->{plugins},
            'state=s@'     => $self->{state},
            'directives'   => \$self->{directives},
            'h|help|?'     => \$self->{show_help},
            'H|man'        => \$self->{show_man},
            'V|version'    => \$self->{show_version},
            'a|archive=s'  => \$self->{archive},
            'j|jobs=i'     => \$self->{jobs},
            'timer'        => \$self->{timer},
            'T'            => \$self->{taint_fail},
            't'            => \$self->{taint_warn},
            'W'            => \$self->{warnings_fail},
            'w'            => \$self->{warnings_warn},
            'normalize'    => \$self->{normalize},
            'rules=s@'     => $self->{rules},
            'tapversion=s' => \$self->{tapversion},
            'trap'         => \$self->{trap},
        ) or croak('Unable to continue');

        # Stash the remainder of argv for later
        $self->{argv} = [@ARGV];
    }

    return;
}

sub _first_pos {
    my $want = shift;
    for ( 0 .. $#_ ) {
        return $_ if $_[$_] eq $want;
    }
    return;
}

sub _help {
    my ( $self, $verbosity ) = @_;

    eval('use Pod::Usage 1.12 ()');
    if ( my $err = $@ ) {
        die 'Please install Pod::Usage for the --help option '
          . '(or try `perldoc prove`.)'
          . "\n ($@)";
    }

    Pod::Usage::pod2usage( { -verbose => $verbosity } );

    return;
}

sub _color_default {
    my $self = shift;

    return -t STDOUT && !$ENV{HARNESS_NOTTY} && !IS_WIN32;
}

sub _get_args {
    my $self = shift;

    my %args;

    $args{trap} = 1 if $self->trap;

    if ( defined $self->color ? $self->color : $self->_color_default ) {
        $args{color} = 1;
    }
    if ( !defined $self->show_count ) {
        $args{show_count} = 1;
    }
    else {
        $args{show_count} = $self->show_count;
    }

    if ( $self->archive ) {
        $self->require_harness( archive => 'TAP::Harness::Archive' );
        $args{archive} = $self->archive;
    }

    if ( my $jobs = $self->jobs ) {
        $args{jobs} = $jobs;
    }

    if ( my $harness_opt = $self->harness ) {
        $self->require_harness( harness => $harness_opt );
    }

    if ( my $formatter = $self->formatter ) {
        $args{formatter_class} = $formatter;
    }

    for my $handler ( @{ $self->sources } ) {
        my ( $name, $config ) = $self->_parse_source($handler);
        $args{sources}->{$name} = $config;
    }

    if ( $self->ignore_exit ) {
        $args{ignore_exit} = 1;
    }

    if ( $self->taint_fail && $self->taint_warn ) {
        die '-t and -T are mutually exclusive';
    }

    if ( $self->warnings_fail && $self->warnings_warn ) {
        die '-w and -W are mutually exclusive';
    }

    for my $a (qw( lib switches )) {
        my $method = "_get_$a";
        my $val    = $self->$method();
        $args{$a} = $val if defined $val;
    }

    # Handle verbose, quiet, really_quiet flags
    my %verb_map = ( verbose => 1, quiet => -1, really_quiet => -2, );

    my @verb_adj = grep {$_} map { $self->$_() ? $verb_map{$_} : 0 }
      keys %verb_map;

    die "Only one of verbose, quiet or really_quiet should be specified\n"
      if @verb_adj > 1;

    $args{verbosity} = shift @verb_adj || 0;

    for my $a (qw( merge failures comments timer directives normalize )) {
        $args{$a} = 1 if $self->$a();
    }

    $args{errors} = 1 if $self->parse;

    # defined but zero-length exec runs test files as binaries
    $args{exec} = [ split( /\s+/, $self->exec ) ]
      if ( defined( $self->exec ) );

    $args{version} = $self->tapversion if defined( $self->tapversion );

    if ( defined( my $test_args = $self->test_args ) ) {
        $args{test_args} = $test_args;
    }

    if ( @{ $self->rules } ) {
        my @rules;
        for ( @{ $self->rules } ) {
            if (/^par=(.*)/) {
                push @rules, $1;
            }
            elsif (/^seq=(.*)/) {
                push @rules, { seq => $1 };
            }
        }
        $args{rules} = { par => [@rules] };
    }

    return ( \%args, $self->{harness_class} );
}

sub _find_module {
    my ( $self, $class, @search ) = @_;

    croak "Bad module name $class"
      unless $class =~ /^ \w+ (?: :: \w+ ) *$/x;

    for my $pfx (@search) {
        my $name = join( '::', $pfx, $class );
        eval "require $name";
        return $name unless $@;
    }

    eval "require $class";
    return $class unless $@;
    return;
}

sub _load_extension {
    my ( $self, $name, @search ) = @_;

    my @args = ();
    if ( $name =~ /^(.*?)=(.*)/ ) {
        $name = $1;
        @args = split( /,/, $2 );
    }

    if ( my $class = $self->_find_module( $name, @search ) ) {
        $class->import(@args);
        if ( $class->can('load') ) {
            $class->load( { app_prove => $self, args => [@args] } );
        }
    }
    else {
        croak "Can't load module $name";
    }
}

sub _load_extensions {
    my ( $self, $ext, @search ) = @_;
    $self->_load_extension( $_, @search ) for @$ext;
}

sub _parse_source {
    my ( $self, $handler ) = @_;

    # Load any options.
    ( my $opt_name = lc $handler ) =~ s/::/-/g;
    local @ARGV = @{ $self->{argv} };
    my %config;
    Getopt::Long::GetOptions(
        "$opt_name-option=s%" => sub {
            my ( $name, $k, $v ) = @_;
            if ( $v =~ /(?<!\\)=/ ) {

                # It's a hash option.
                croak "Option $name must be consistently used as a hash"
                  if exists $config{$k} && ref $config{$k} ne 'HASH';
                $config{$k} ||= {};
                my ( $hk, $hv ) = split /(?<!\\)=/, $v, 2;
                $config{$k}{$hk} = $hv;
            }
            else {
                $v =~ s/\\=/=/g;
                if ( exists $config{$k} ) {
                    $config{$k} = [ $config{$k} ]
                      unless ref $config{$k} eq 'ARRAY';
                    push @{ $config{$k} } => $v;
                }
                else {
                    $config{$k} = $v;
                }
            }
        }
    );
    $self->{argv} = \@ARGV;
    return ( $handler, \%config );
}

=head3 C<run>

Perform whatever actions the command line args specified. The C<prove>
command line tool consists of the following code:

    use App::Prove;

    my $app = App::Prove->new;
    $app->process_args(@ARGV);
    exit( $app->run ? 0 : 1 );  # if you need the exit code

=cut

sub run {
    my $self = shift;

    unless ( $self->state_manager ) {
        $self->state_manager(
            $self->state_class->new( { store => STATE_FILE } ) );
    }

    if ( $self->show_help ) {
        $self->_help(1);
    }
    elsif ( $self->show_man ) {
        $self->_help(2);
    }
    elsif ( $self->show_version ) {
        $self->print_version;
    }
    elsif ( $self->dry ) {
        print "$_\n" for $self->_get_tests;
    }
    else {

        $self->_load_extensions( $self->modules );
        $self->_load_extensions( $self->plugins, PLUGINS );

        local $ENV{TEST_VERBOSE} = 1 if $self->verbose;

        return $self->_runtests( $self->_get_args, $self->_get_tests );
    }

    return 1;
}

sub _get_tests {
    my $self = shift;

    my $state = $self->state_manager;
    my $ext   = $self->extensions;
    $state->extensions($ext) if defined $ext;
    if ( defined( my $state_switch = $self->state ) ) {
        $state->apply_switch(@$state_switch);
    }

    my @tests = $state->get_tests( $self->recurse, @{ $self->argv } );

    $self->_shuffle(@tests) if $self->shuffle;
    @tests = reverse @tests if $self->backwards;

    return @tests;
}

sub _runtests {
    my ( $self, $args, $harness_class, @tests ) = @_;
    my $harness = $harness_class->new($args);

    my $state = $self->state_manager;

    $harness->callback(
        after_test => sub {
            $state->observe_test(@_);
        }
    );

    $harness->callback(
        after_runtests => sub {
            $state->commit(@_);
        }
    );

    my $aggregator = $harness->runtests(@tests);

    return !$aggregator->has_errors;
}

sub _get_switches {
    my $self = shift;
    my @switches;

    # notes that -T or -t must be at the front of the switches!
    if ( $self->taint_fail ) {
        push @switches, '-T';
    }
    elsif ( $self->taint_warn ) {
        push @switches, '-t';
    }
    if ( $self->warnings_fail ) {
        push @switches, '-W';
    }
    elsif ( $self->warnings_warn ) {
        push @switches, '-w';
    }

    push @switches, shellwords( $ENV{HARNESS_PERL_SWITCHES} ) if defined $ENV{HARNESS_PERL_SWITCHES};

    return @switches ? \@switches : ();
}

sub _get_lib {
    my $self = shift;
    my @libs;
    if ( $self->lib ) {
        push @libs, 'lib';
    }
    if ( $self->blib ) {
        push @libs, 'blib/lib', 'blib/arch';
    }
    if ( @{ $self->includes } ) {
        push @libs, @{ $self->includes };
    }

    #24926
    @libs = map { File::Spec->rel2abs($_) } @libs;

    # Huh?
    return @libs ? \@libs : ();
}

sub _shuffle {
    my $self = shift;

    # Fisher-Yates shuffle
    my $i = @_;
    while ($i) {
        my $j = rand $i--;
        @_[ $i, $j ] = @_[ $j, $i ];
    }
    return;
}

=head3 C<require_harness>

Load a harness replacement class.

  $prove->require_harness($for => $class_name);

=cut

sub require_harness {
    my ( $self, $for, $class ) = @_;

    my ($class_name) = $class =~ /^(\w+(?:::\w+)*)/;

    # Emulate Perl's -MModule=arg1,arg2 behaviour
    $class =~ s!^(\w+(?:::\w+)*)=(.*)$!$1 split(/,/,q{$2})!;

    eval("use $class;");
    die "$class_name is required to use the --$for feature: $@" if $@;

    $self->{harness_class} = $class_name;

    return;
}

=head3 C<print_version>

Display the version numbers of the loaded L<TAP::Harness> and the
current Perl.

=cut

sub print_version {
    my $self = shift;
    printf(
        "TAP::Harness v%s and Perl v%vd\n",
        $TAP::Harness::VERSION, $^V
    );

    return;
}

1;

# vim:ts=4:sw=4:et:sta

__END__

=head2 Attributes

After command line parsing the following attributes reflect the values
of the corresponding command line switches. They may be altered before
calling C<run>.

=over

=item C<archive>

=item C<argv>

=item C<backwards>

=item C<blib>

=item C<color>

=item C<directives>

=item C<dry>

=item C<exec>

=item C<extensions>

=item C<failures>

=item C<comments>

=item C<formatter>

=item C<harness>

=item C<ignore_exit>

=item C<includes>

=item C<jobs>

=item C<lib>

=item C<merge>

=item C<modules>

=item C<parse>

=item C<plugins>

=item C<quiet>

=item C<really_quiet>

=item C<recurse>

=item C<rules>

=item C<show_count>

=item C<show_help>

=item C<show_man>

=item C<show_version>

=item C<shuffle>

=item C<state>

=item C<state_class>

=item C<taint_fail>

=item C<taint_warn>

=item C<test_args>

=item C<timer>

=item C<verbose>

=item C<warnings_fail>

=item C<warnings_warn>

=item C<tapversion>

=item C<trap>

=back

=head1 PLUGINS

C<App::Prove> provides support for 3rd-party plugins.  These are currently
loaded at run-time, I<after> arguments have been parsed (so you can not
change the way arguments are processed, sorry), typically with the
C<< -PI<plugin> >> switch, eg:

  prove -PMyPlugin

This will search for a module named C<App::Prove::Plugin::MyPlugin>, or failing
that, C<MyPlugin>.  If the plugin can't be found, C<prove> will complain & exit.

You can pass an argument to your plugin by appending an C<=> after the plugin
name, eg C<-PMyPlugin=foo>.  You can pass multiple arguments using commas:

  prove -PMyPlugin=foo,bar,baz

These are passed in to your plugin's C<load()> class method (if it has one),
along with a reference to the C<App::Prove> object that is invoking your plugin:

  sub load {
      my ($class, $p) = @_;

      my @args = @{ $p->{args} };
      # @args will contain ( 'foo', 'bar', 'baz' )
      $p->{app_prove}->do_something;
      ...
  }

Note that the user's arguments are also passed to your plugin's C<import()>
function as a list, eg:

  sub import {
      my ($class, @args) = @_;
      # @args will contain ( 'foo', 'bar', 'baz' )
      ...
  }

This is for backwards compatibility, and may be deprecated in the future.

=head2 Sample Plugin

Here's a sample plugin, for your reference:

  package App::Prove::Plugin::Foo;

  # Sample plugin, try running with:
  # prove -PFoo=bar -r -j3
  # prove -PFoo -Q
  # prove -PFoo=bar,My::Formatter

  use strict;
  use warnings;

  sub load {
      my ($class, $p) = @_;
      my @args = @{ $p->{args} };
      my $app  = $p->{app_prove};

      print "loading plugin: $class, args: ", join(', ', @args ), "\n";

      # turn on verbosity
      $app->verbose( 1 );

      # set the formatter?
      $app->formatter( $args[1] ) if @args > 1;

      # print some of App::Prove's state:
      for my $attr (qw( jobs quiet really_quiet recurse verbose )) {
          my $val = $app->$attr;
          $val    = 'undef' unless defined( $val );
          print "$attr: $val\n";
      }

      return 1;
  }

  1;

=head1 SEE ALSO

L<prove>, L<TAP::Harness>

=cut
                                                                                                                                                                                                                                                                                  usr/share/perl/5.20.2/Archive/                                                                      0040755 0000000 0000000 00000000000 13077704254 014243  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Archive/Tar/                                                                  0040755 0000000 0000000 00000000000 13077704254 014771  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Archive/Tar/Constant.pm                                                       0100644 0000000 0000000 00000010120 12744441327 017106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Archive::Tar::Constant;

BEGIN {
    require Exporter;

    $VERSION    = '1.96';
    @ISA        = qw[Exporter];

    require Time::Local if $^O eq "MacOS";
}

@EXPORT = Archive::Tar::Constant->_list_consts( __PACKAGE__ );

use constant FILE           => 0;
use constant HARDLINK       => 1;
use constant SYMLINK        => 2;
use constant CHARDEV        => 3;
use constant BLOCKDEV       => 4;
use constant DIR            => 5;
use constant FIFO           => 6;
use constant SOCKET         => 8;
use constant UNKNOWN        => 9;
use constant LONGLINK       => 'L';
use constant LABEL          => 'V';

use constant BUFFER         => 4096;
use constant HEAD           => 512;
use constant BLOCK          => 512;

use constant COMPRESS_GZIP  => 9;
use constant COMPRESS_BZIP  => 'bzip2';

use constant BLOCK_SIZE     => sub { my $n = int($_[0]/BLOCK); $n++ if $_[0] % BLOCK; $n * BLOCK };
use constant TAR_PAD        => sub { my $x = shift || return; return "\0" x (BLOCK - ($x % BLOCK) ) };
use constant TAR_END        => "\0" x BLOCK;

use constant READ_ONLY      => sub { shift() ? 'rb' : 'r' };
use constant WRITE_ONLY     => sub { $_[0] ? 'wb' . shift : 'w' };
use constant MODE_READ      => sub { $_[0] =~ /^r/ ? 1 : 0 };

# Pointless assignment to make -w shut up
my $getpwuid; $getpwuid = 'unknown' unless eval { my $f = getpwuid (0); };
my $getgrgid; $getgrgid = 'unknown' unless eval { my $f = getgrgid (0); };
use constant UNAME          => sub { $getpwuid || scalar getpwuid( shift() ) || '' };
use constant GNAME          => sub { $getgrgid || scalar getgrgid( shift() ) || '' };
use constant UID            => $>;
use constant GID            => (split ' ', $) )[0];

use constant MODE           => do { 0666 & (0777 & ~umask) };
use constant STRIP_MODE     => sub { shift() & 0777 };
use constant CHECK_SUM      => "      ";

use constant UNPACK         => 'A100 A8 A8 A8 a12 A12 A8 A1 A100 A6 A2 A32 A32 A8 A8 A155 x12';	# cdrake - size must be a12 - not A12 - or else screws up huge file sizes (>8gb)
use constant PACK           => 'a100 a8 a8 a8 a12 a12 A8 a1 a100 a6 a2 a32 a32 a8 a8 a155 x12';
use constant NAME_LENGTH    => 100;
use constant PREFIX_LENGTH  => 155;

use constant TIME_OFFSET    => ($^O eq "MacOS") ? Time::Local::timelocal(0,0,0,1,0,70) : 0;
use constant MAGIC          => "ustar";
use constant TAR_VERSION    => "00";
use constant LONGLINK_NAME  => '././@LongLink';
use constant PAX_HEADER     => 'pax_global_header';

                            ### allow ZLIB to be turned off using ENV: DEBUG only
use constant ZLIB           => do { !$ENV{'PERL5_AT_NO_ZLIB'} and
                                        eval { require IO::Zlib };
                                    $ENV{'PERL5_AT_NO_ZLIB'} || $@ ? 0 : 1
                                };

                            ### allow BZIP to be turned off using ENV: DEBUG only
use constant BZIP           => do { !$ENV{'PERL5_AT_NO_BZIP'} and
                                        eval { require IO::Uncompress::Bunzip2;
                                               require IO::Compress::Bzip2; };
                                    $ENV{'PERL5_AT_NO_BZIP'} || $@ ? 0 : 1
                                };

use constant GZIP_MAGIC_NUM => qr/^(?:\037\213|\037\235)/;
use constant BZIP_MAGIC_NUM => qr/^BZh\d/;

use constant CAN_CHOWN      => sub { ($> == 0 and $^O ne "MacOS" and $^O ne "MSWin32") };
use constant CAN_READLINK   => ($^O ne 'MSWin32' and $^O !~ /RISC(?:[ _])?OS/i and $^O ne 'VMS');
use constant ON_UNIX        => ($^O ne 'MSWin32' and $^O ne 'MacOS' and $^O ne 'VMS');
use constant ON_VMS         => $^O eq 'VMS';

sub _list_consts {
    my $class = shift;
    my $pkg   = shift;
    return unless defined $pkg; # some joker might use '0' as a pkg...

    my @rv;
    {   no strict 'refs';
        my $stash = $pkg . '::';

        for my $name (sort keys %$stash ) {

            ### is it a subentry?
            my $sub = $pkg->can( $name );
            next unless defined $sub;

            next unless defined prototype($sub) and
                     not length prototype($sub);

            push @rv, $name;
        }
    }

    return sort @rv;
}

1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Archive/Tar/File.pm                                                           0100644 0000000 0000000 00000044442 12744441327 016212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Archive::Tar::File;
use strict;

use Carp                ();
use IO::File;
use File::Spec::Unix    ();
use File::Spec          ();
use File::Basename      ();

### avoid circular use, so only require;
require Archive::Tar;
use Archive::Tar::Constant;

use vars qw[@ISA $VERSION];
#@ISA        = qw[Archive::Tar];
$VERSION    = '1.96';

### set value to 1 to oct() it during the unpack ###

my $tmpl = [
        name        => 0,   # string					A100
        mode        => 1,   # octal					A8
        uid         => 1,   # octal					A8
        gid         => 1,   # octal					A8
        size        => 0,   # octal	# cdrake - not *always* octal..	A12
        mtime       => 1,   # octal					A12
        chksum      => 1,   # octal					A8
        type        => 0,   # character					A1
        linkname    => 0,   # string					A100
        magic       => 0,   # string					A6
        version     => 0,   # 2 bytes					A2
        uname       => 0,   # string					A32
        gname       => 0,   # string					A32
        devmajor    => 1,   # octal					A8
        devminor    => 1,   # octal					A8
        prefix      => 0,	#					A155 x 12

### end UNPACK items ###
        raw         => 0,   # the raw data chunk
        data        => 0,   # the data associated with the file --
                            # This  might be very memory intensive
];

### install get/set accessors for this object.
for ( my $i=0; $i<scalar @$tmpl ; $i+=2 ) {
    my $key = $tmpl->[$i];
    no strict 'refs';
    *{__PACKAGE__."::$key"} = sub {
        my $self = shift;
        $self->{$key} = $_[0] if @_;

        ### just in case the key is not there or undef or something ###
        {   local $^W = 0;
            return $self->{$key};
        }
    }
}

=head1 NAME

Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar

=head1 SYNOPSIS

    my @items = $tar->get_files;

    print $_->name, ' ', $_->size, "\n" for @items;

    print $object->get_content;
    $object->replace_content('new content');

    $object->rename( 'new/full/path/to/file.c' );

=head1 DESCRIPTION

Archive::Tar::Files provides a neat little object layer for in-memory
extracted files. It's mostly used internally in Archive::Tar to tidy
up the code, but there's no reason users shouldn't use this API as
well.

=head2 Accessors

A lot of the methods in this package are accessors to the various
fields in the tar header:

=over 4

=item name

The file's name

=item mode

The file's mode

=item uid

The user id owning the file

=item gid

The group id owning the file

=item size

File size in bytes

=item mtime

Modification time. Adjusted to mac-time on MacOS if required

=item chksum

Checksum field for the tar header

=item type

File type -- numeric, but comparable to exported constants -- see
Archive::Tar's documentation

=item linkname

If the file is a symlink, the file it's pointing to

=item magic

Tar magic string -- not useful for most users

=item version

Tar version string -- not useful for most users

=item uname

The user name that owns the file

=item gname

The group name that owns the file

=item devmajor

Device major number in case of a special file

=item devminor

Device minor number in case of a special file

=item prefix

Any directory to prefix to the extraction path, if any

=item raw

Raw tar header -- not useful for most users

=back

=head1 Methods

=head2 Archive::Tar::File->new( file => $path )

Returns a new Archive::Tar::File object from an existing file.

Returns undef on failure.

=head2 Archive::Tar::File->new( data => $path, $data, $opt )

Returns a new Archive::Tar::File object from data.

C<$path> defines the file name (which need not exist), C<$data> the
file contents, and C<$opt> is a reference to a hash of attributes
which may be used to override the default attributes (fields in the
tar header), which are described above in the Accessors section.

Returns undef on failure.

=head2 Archive::Tar::File->new( chunk => $chunk )

Returns a new Archive::Tar::File object from a raw 512-byte tar
archive chunk.

Returns undef on failure.

=cut

sub new {
    my $class   = shift;
    my $what    = shift;

    my $obj =   ($what eq 'chunk') ? __PACKAGE__->_new_from_chunk( @_ ) :
                ($what eq 'file' ) ? __PACKAGE__->_new_from_file( @_ ) :
                ($what eq 'data' ) ? __PACKAGE__->_new_from_data( @_ ) :
                undef;

    return $obj;
}

### copies the data, creates a clone ###
sub clone {
    my $self = shift;
    return bless { %$self }, ref $self;
}

sub _new_from_chunk {
    my $class = shift;
    my $chunk = shift or return;    # 512 bytes of tar header
    my %hash  = @_;

    ### filter any arguments on defined-ness of values.
    ### this allows overriding from what the tar-header is saying
    ### about this tar-entry. Particularly useful for @LongLink files
    my %args  = map { $_ => $hash{$_} } grep { defined $hash{$_} } keys %hash;

    ### makes it start at 0 actually... :) ###
    my $i = -1;
    my %entry = map {
	my ($s,$v)=($tmpl->[++$i],$tmpl->[++$i]);	# cdrake
	($_)=($_=~/^([^\0]*)/) unless($s eq 'size');	# cdrake
	$s=> $v ? oct $_ : $_				# cdrake
	# $tmpl->[++$i] => $tmpl->[++$i] ? oct $_ : $_	# removed by cdrake - mucks up binary sizes >8gb
    } unpack( UNPACK, $chunk );				# cdrake
    # } map { /^([^\0]*)/ } unpack( UNPACK, $chunk );	# old - replaced now by cdrake


    if(substr($entry{'size'}, 0, 1) eq "\x80") {	# binary size extension for files >8gigs (> octal 77777777777777)	# cdrake
      my @sz=unpack("aCSNN",$entry{'size'}); $entry{'size'}=$sz[4]+(2**32)*$sz[3]+$sz[2]*(2**64);	# Use the low 80 bits (should use the upper 15 as well, but as at year 2011, that seems unlikely to ever be needed - the numbers are just too big...) # cdrake
    } else {	# cdrake
      ($entry{'size'})=($entry{'size'}=~/^([^\0]*)/); $entry{'size'}=oct $entry{'size'};	# cdrake
    }	# cdrake


    my $obj = bless { %entry, %args }, $class;

	### magic is a filetype string.. it should have something like 'ustar' or
	### something similar... if the chunk is garbage, skip it
	return unless $obj->magic !~ /\W/;

    ### store the original chunk ###
    $obj->raw( $chunk );

    $obj->type(FILE) if ( (!length $obj->type) or ($obj->type =~ /\W/) );
    $obj->type(DIR)  if ( ($obj->is_file) && ($obj->name =~ m|/$|) );


    return $obj;

}

sub _new_from_file {
    my $class       = shift;
    my $path        = shift;

    ### path has to at least exist
    return unless defined $path;

    my $type        = __PACKAGE__->_filetype($path);
    my $data        = '';

    READ: {
        unless ($type == DIR ) {
            my $fh = IO::File->new;

            unless( $fh->open($path) ) {
                ### dangling symlinks are fine, stop reading but continue
                ### creating the object
                last READ if $type == SYMLINK;

                ### otherwise, return from this function --
                ### anything that's *not* a symlink should be
                ### resolvable
                return;
            }

            ### binmode needed to read files properly on win32 ###
            binmode $fh;
            $data = do { local $/; <$fh> };
            close $fh;
        }
    }

    my @items       = qw[mode uid gid size mtime];
    my %hash        = map { shift(@items), $_ } (lstat $path)[2,4,5,7,9];

    if (ON_VMS) {
        ### VMS has two UID modes, traditional and POSIX.  Normally POSIX is
        ### not used.  We currently do not have an easy way to see if we are in
        ### POSIX mode.  In traditional mode, the UID is actually the VMS UIC.
        ### The VMS UIC has the upper 16 bits is the GID, which in many cases
        ### the VMS UIC will be larger than 209715, the largest that TAR can
        ### handle.  So for now, assume it is traditional if the UID is larger
        ### than 0x10000.

        if ($hash{uid} > 0x10000) {
            $hash{uid} = $hash{uid} & 0xFFFF;
        }

        ### The file length from stat() is the physical length of the file
        ### However the amount of data read in may be more for some file types.
        ### Fixed length files are read past the logical EOF to end of the block
        ### containing.  Other file types get expanded on read because record
        ### delimiters are added.

        my $data_len = length $data;
        $hash{size} = $data_len if $hash{size} < $data_len;

    }
    ### you *must* set size == 0 on symlinks, or the next entry will be
    ### though of as the contents of the symlink, which is wrong.
    ### this fixes bug #7937
    $hash{size}     = 0 if ($type == DIR or $type == SYMLINK);
    $hash{mtime}    -= TIME_OFFSET;

    ### strip the high bits off the mode, which we don't need to store
    $hash{mode}     = STRIP_MODE->( $hash{mode} );


    ### probably requires some file path munging here ... ###
    ### name and prefix are set later
    my $obj = {
        %hash,
        name        => '',
        chksum      => CHECK_SUM,
        type        => $type,
        linkname    => ($type == SYMLINK and CAN_READLINK)
                            ? readlink $path
                            : '',
        magic       => MAGIC,
        version     => TAR_VERSION,
        uname       => UNAME->( $hash{uid} ),
        gname       => GNAME->( $hash{gid} ),
        devmajor    => 0,   # not handled
        devminor    => 0,   # not handled
        prefix      => '',
        data        => $data,
    };

    bless $obj, $class;

    ### fix up the prefix and file from the path
    my($prefix,$file) = $obj->_prefix_and_file( $path );
    $obj->prefix( $prefix );
    $obj->name( $file );

    return $obj;
}

sub _new_from_data {
    my $class   = shift;
    my $path    = shift;    return unless defined $path;
    my $data    = shift;    return unless defined $data;
    my $opt     = shift;

    my $obj = {
        data        => $data,
        name        => '',
        mode        => MODE,
        uid         => UID,
        gid         => GID,
        size        => length $data,
        mtime       => time - TIME_OFFSET,
        chksum      => CHECK_SUM,
        type        => FILE,
        linkname    => '',
        magic       => MAGIC,
        version     => TAR_VERSION,
        uname       => UNAME->( UID ),
        gname       => GNAME->( GID ),
        devminor    => 0,
        devmajor    => 0,
        prefix      => '',
    };

    ### overwrite with user options, if provided ###
    if( $opt and ref $opt eq 'HASH' ) {
        for my $key ( keys %$opt ) {

            ### don't write bogus options ###
            next unless exists $obj->{$key};
            $obj->{$key} = $opt->{$key};
        }
    }

    bless $obj, $class;

    ### fix up the prefix and file from the path
    my($prefix,$file) = $obj->_prefix_and_file( $path );
    $obj->prefix( $prefix );
    $obj->name( $file );

    return $obj;
}

sub _prefix_and_file {
    my $self = shift;
    my $path = shift;

    my ($vol, $dirs, $file) = File::Spec->splitpath( $path, $self->is_dir );
    my @dirs = File::Spec->splitdir( $dirs );

    ### so sometimes the last element is '' -- probably when trailing
    ### dir slashes are encountered... this is of course pointless,
    ### so remove it
    pop @dirs while @dirs and not length $dirs[-1];

    ### if it's a directory, then $file might be empty
    $file = pop @dirs if $self->is_dir and not length $file;

    ### splitting ../ gives you the relative path in native syntax
    map { $_ = '..' if $_  eq '-' } @dirs if ON_VMS;

    my $prefix = File::Spec::Unix->catdir(
                        grep { length } $vol, @dirs
                    );
    return( $prefix, $file );
}

sub _filetype {
    my $self = shift;
    my $file = shift;

    return unless defined $file;

    return SYMLINK  if (-l $file);	# Symlink

    return FILE     if (-f _);		# Plain file

    return DIR      if (-d _);		# Directory

    return FIFO     if (-p _);		# Named pipe

    return SOCKET   if (-S _);		# Socket

    return BLOCKDEV if (-b _);		# Block special

    return CHARDEV  if (-c _);		# Character special

    ### shouldn't happen, this is when making archives, not reading ###
    return LONGLINK if ( $file eq LONGLINK_NAME );

    return UNKNOWN;		            # Something else (like what?)

}

### this method 'downgrades' a file to plain file -- this is used for
### symlinks when FOLLOW_SYMLINKS is true.
sub _downgrade_to_plainfile {
    my $entry = shift;
    $entry->type( FILE );
    $entry->mode( MODE );
    $entry->linkname('');

    return 1;
}

=head2 $bool = $file->extract( [ $alternative_name ] )

Extract this object, optionally to an alternative name.

See C<< Archive::Tar->extract_file >> for details.

Returns true on success and false on failure.

=cut

sub extract {
    my $self = shift;

    local $Carp::CarpLevel += 1;

    return Archive::Tar->_extract_file( $self, @_ );
}

=head2 $path = $file->full_path

Returns the full path from the tar header; this is basically a
concatenation of the C<prefix> and C<name> fields.

=cut

sub full_path {
    my $self = shift;

    ### if prefix field is empty
    return $self->name unless defined $self->prefix and length $self->prefix;

    ### or otherwise, catfile'd
    return File::Spec::Unix->catfile( $self->prefix, $self->name );
}


=head2 $bool = $file->validate

Done by Archive::Tar internally when reading the tar file:
validate the header against the checksum to ensure integer tar file.

Returns true on success, false on failure

=cut

sub validate {
    my $self = shift;

    my $raw = $self->raw;

    ### don't know why this one is different from the one we /write/ ###
    substr ($raw, 148, 8) = "        ";

    ### bug #43513: [PATCH] Accept wrong checksums from SunOS and HP-UX tar
    ### like GNU tar does. See here for details:
    ### http://www.gnu.org/software/tar/manual/tar.html#SEC139
    ### so we do both a signed AND unsigned validate. if one succeeds, that's
    ### good enough
	return (   (unpack ("%16C*", $raw) == $self->chksum)
	        or (unpack ("%16c*", $raw) == $self->chksum)) ? 1 : 0;
}

=head2 $bool = $file->has_content

Returns a boolean to indicate whether the current object has content.
Some special files like directories and so on never will have any
content. This method is mainly to make sure you don't get warnings
for using uninitialized values when looking at an object's content.

=cut

sub has_content {
    my $self = shift;
    return defined $self->data() && length $self->data() ? 1 : 0;
}

=head2 $content = $file->get_content

Returns the current content for the in-memory file

=cut

sub get_content {
    my $self = shift;
    $self->data( );
}

=head2 $cref = $file->get_content_by_ref

Returns the current content for the in-memory file as a scalar
reference. Normal users won't need this, but it will save memory if
you are dealing with very large data files in your tar archive, since
it will pass the contents by reference, rather than make a copy of it
first.

=cut

sub get_content_by_ref {
    my $self = shift;

    return \$self->{data};
}

=head2 $bool = $file->replace_content( $content )

Replace the current content of the file with the new content. This
only affects the in-memory archive, not the on-disk version until
you write it.

Returns true on success, false on failure.

=cut

sub replace_content {
    my $self = shift;
    my $data = shift || '';

    $self->data( $data );
    $self->size( length $data );
    return 1;
}

=head2 $bool = $file->rename( $new_name )

Rename the current file to $new_name.

Note that you must specify a Unix path for $new_name, since per tar
standard, all files in the archive must be Unix paths.

Returns true on success and false on failure.

=cut

sub rename {
    my $self = shift;
    my $path = shift;

    return unless defined $path;

    my ($prefix,$file) = $self->_prefix_and_file( $path );

    $self->name( $file );
    $self->prefix( $prefix );

	return 1;
}

=head2 $bool = $file->chmod $mode)

Change mode of $file to $mode. The mode can be a string or a number
which is interpreted as octal whether or not a leading 0 is given.

Returns true on success and false on failure.

=cut

sub chmod {
    my $self  = shift;
    my $mode = shift; return unless defined $mode && $mode =~ /^[0-7]{1,4}$/;
    $self->{mode} = oct($mode);
    return 1;
}

=head2 $bool = $file->chown( $user [, $group])

Change owner of $file to $user. If a $group is given that is changed
as well. You can also pass a single parameter with a colon separating the
use and group as in 'root:wheel'.

Returns true on success and false on failure.

=cut

sub chown {
    my $self = shift;
    my $uname = shift;
    return unless defined $uname;
    my $gname;
    if (-1 != index($uname, ':')) {
	($uname, $gname) = split(/:/, $uname);
    } else {
	$gname = shift if @_ > 0;
    }

    $self->uname( $uname );
    $self->gname( $gname ) if $gname;
	return 1;
}

=head1 Convenience methods

To quickly check the type of a C<Archive::Tar::File> object, you can
use the following methods:

=over 4

=item $file->is_file

Returns true if the file is of type C<file>

=item $file->is_dir

Returns true if the file is of type C<dir>

=item $file->is_hardlink

Returns true if the file is of type C<hardlink>

=item $file->is_symlink

Returns true if the file is of type C<symlink>

=item $file->is_chardev

Returns true if the file is of type C<chardev>

=item $file->is_blockdev

Returns true if the file is of type C<blockdev>

=item $file->is_fifo

Returns true if the file is of type C<fifo>

=item $file->is_socket

Returns true if the file is of type C<socket>

=item $file->is_longlink

Returns true if the file is of type C<LongLink>.
Should not happen after a successful C<read>.

=item $file->is_label

Returns true if the file is of type C<Label>.
Should not happen after a successful C<read>.

=item $file->is_unknown

Returns true if the file type is C<unknown>

=back

=cut

#stupid perl5.5.3 needs to warn if it's not numeric
sub is_file     { local $^W;    FILE      == $_[0]->type }
sub is_dir      { local $^W;    DIR       == $_[0]->type }
sub is_hardlink { local $^W;    HARDLINK  == $_[0]->type }
sub is_symlink  { local $^W;    SYMLINK   == $_[0]->type }
sub is_chardev  { local $^W;    CHARDEV   == $_[0]->type }
sub is_blockdev { local $^W;    BLOCKDEV  == $_[0]->type }
sub is_fifo     { local $^W;    FIFO      == $_[0]->type }
sub is_socket   { local $^W;    SOCKET    == $_[0]->type }
sub is_unknown  { local $^W;    UNKNOWN   == $_[0]->type }
sub is_longlink { local $^W;    LONGLINK  eq $_[0]->type }
sub is_label    { local $^W;    LABEL     eq $_[0]->type }

1;
                                                                                                                                                                                                                              usr/share/perl/5.20.2/Archive/Tar.pm                                                                0100644 0000000 0000000 00000222030 12744441327 015322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ### the gnu tar specification:
### http://www.gnu.org/software/tar/manual/tar.html
###
### and the pax format spec, which tar derives from:
### http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html

package Archive::Tar;
require 5.005_03;

use Cwd;
use IO::Zlib;
use IO::File;
use Carp                qw(carp croak);
use File::Spec          ();
use File::Spec::Unix    ();
use File::Path          ();

use Archive::Tar::File;
use Archive::Tar::Constant;

require Exporter;

use strict;
use vars qw[$DEBUG $error $VERSION $WARN $FOLLOW_SYMLINK $CHOWN $CHMOD
            $DO_NOT_USE_PREFIX $HAS_PERLIO $HAS_IO_STRING $SAME_PERMISSIONS
            $INSECURE_EXTRACT_MODE $ZERO_PAD_NUMBERS @ISA @EXPORT $RESOLVE_SYMLINK
         ];

@ISA                    = qw[Exporter];
@EXPORT                 = qw[ COMPRESS_GZIP COMPRESS_BZIP ];
$DEBUG                  = 0;
$WARN                   = 1;
$FOLLOW_SYMLINK         = 0;
$VERSION                = "1.96";
$CHOWN                  = 1;
$CHMOD                  = 1;
$SAME_PERMISSIONS       = $> == 0 ? 1 : 0;
$DO_NOT_USE_PREFIX      = 0;
$INSECURE_EXTRACT_MODE  = 0;
$ZERO_PAD_NUMBERS       = 0;
$RESOLVE_SYMLINK        = $ENV{'PERL5_AT_RESOLVE_SYMLINK'} || 'speed';

BEGIN {
    use Config;
    $HAS_PERLIO = $Config::Config{useperlio};

    ### try and load IO::String anyway, so you can dynamically
    ### switch between perlio and IO::String
    $HAS_IO_STRING = eval {
        require IO::String;
        import IO::String;
        1;
    } || 0;
}

=head1 NAME

Archive::Tar - module for manipulations of tar archives

=head1 SYNOPSIS

    use Archive::Tar;
    my $tar = Archive::Tar->new;

    $tar->read('origin.tgz');
    $tar->extract();

    $tar->add_files('file/foo.pl', 'docs/README');
    $tar->add_data('file/baz.txt', 'This is the contents now');

    $tar->rename('oldname', 'new/file/name');
    $tar->chown('/', 'root');
    $tar->chown('/', 'root:root');
    $tar->chmod('/tmp', '1777');

    $tar->write('files.tar');                   # plain tar
    $tar->write('files.tgz', COMPRESS_GZIP);    # gzip compressed
    $tar->write('files.tbz', COMPRESS_BZIP);    # bzip2 compressed

=head1 DESCRIPTION

Archive::Tar provides an object oriented mechanism for handling tar
files.  It provides class methods for quick and easy files handling
while also allowing for the creation of tar file objects for custom
manipulation.  If you have the IO::Zlib module installed,
Archive::Tar will also support compressed or gzipped tar files.

An object of class Archive::Tar represents a .tar(.gz) archive full
of files and things.

=head1 Object Methods

=head2 Archive::Tar->new( [$file, $compressed] )

Returns a new Tar object. If given any arguments, C<new()> calls the
C<read()> method automatically, passing on the arguments provided to
the C<read()> method.

If C<new()> is invoked with arguments and the C<read()> method fails
for any reason, C<new()> returns undef.

=cut

my $tmpl = {
    _data   => [ ],
    _file   => 'Unknown',
};

### install get/set accessors for this object.
for my $key ( keys %$tmpl ) {
    no strict 'refs';
    *{__PACKAGE__."::$key"} = sub {
        my $self = shift;
        $self->{$key} = $_[0] if @_;
        return $self->{$key};
    }
}

sub new {
    my $class = shift;
    $class = ref $class if ref $class;

    ### copying $tmpl here since a shallow copy makes it use the
    ### same aref, causing for files to remain in memory always.
    my $obj = bless { _data => [ ], _file => 'Unknown', _error => '' }, $class;

    if (@_) {
        unless ( $obj->read( @_ ) ) {
            $obj->_error(qq[No data could be read from file]);
            return;
        }
    }

    return $obj;
}

=head2 $tar->read ( $filename|$handle, [$compressed, {opt => 'val'}] )

Read the given tar file into memory.
The first argument can either be the name of a file or a reference to
an already open filehandle (or an IO::Zlib object if it's compressed)

The C<read> will I<replace> any previous content in C<$tar>!

The second argument may be considered optional, but remains for
backwards compatibility. Archive::Tar now looks at the file
magic to determine what class should be used to open the file
and will transparently Do The Right Thing.

Archive::Tar will warn if you try to pass a bzip2 compressed file and the
IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.

Note that you can currently B<not> pass a C<gzip> compressed
filehandle, which is not opened with C<IO::Zlib>, a C<bzip2> compressed
filehandle, which is not opened with C<IO::Uncompress::Bunzip2>, nor a string
containing the full archive information (either compressed or
uncompressed). These are worth while features, but not currently
implemented. See the C<TODO> section.

The third argument can be a hash reference with options. Note that
all options are case-sensitive.

=over 4

=item limit

Do not read more than C<limit> files. This is useful if you have
very big archives, and are only interested in the first few files.

=item filter

Can be set to a regular expression.  Only files with names that match
the expression will be read.

=item md5

Set to 1 and the md5sum of files will be returned (instead of file data)
    my $iter = Archive::Tar->iter( $file,  1, {md5 => 1} );
    while( my $f = $iter->() ) {
        print $f->data . "\t" . $f->full_path . $/;
    }

=item extract

If set to true, immediately extract entries when reading them. This
gives you the same memory break as the C<extract_archive> function.
Note however that entries will not be read into memory, but written
straight to disk. This means no C<Archive::Tar::File> objects are
created for you to inspect.

=back

All files are stored internally as C<Archive::Tar::File> objects.
Please consult the L<Archive::Tar::File> documentation for details.

Returns the number of files read in scalar context, and a list of
C<Archive::Tar::File> objects in list context.

=cut

sub read {
    my $self = shift;
    my $file = shift;
    my $gzip = shift || 0;
    my $opts = shift || {};

    unless( defined $file ) {
        $self->_error( qq[No file to read from!] );
        return;
    } else {
        $self->_file( $file );
    }

    my $handle = $self->_get_handle($file, $gzip, READ_ONLY->( ZLIB ) )
                    or return;

    my $data = $self->_read_tar( $handle, $opts ) or return;

    $self->_data( $data );

    return wantarray ? @$data : scalar @$data;
}

sub _get_handle {
    my $self     = shift;
    my $file     = shift;   return unless defined $file;
    my $compress = shift || 0;
    my $mode     = shift || READ_ONLY->( ZLIB ); # default to read only

    ### Check if file is a file handle or IO glob
    if ( ref $file ) {
	return $file if eval{ *$file{IO} };
	return $file if eval{ $file->isa(q{IO::Handle}) };
	$file = q{}.$file;
    }

    ### get a FH opened to the right class, so we can use it transparently
    ### throughout the program
    my $fh;
    {   ### reading magic only makes sense if we're opening a file for
        ### reading. otherwise, just use what the user requested.
        my $magic = '';
        if( MODE_READ->($mode) ) {
            open my $tmp, $file or do {
                $self->_error( qq[Could not open '$file' for reading: $!] );
                return;
            };

            ### read the first 4 bites of the file to figure out which class to
            ### use to open the file.
            sysread( $tmp, $magic, 4 );
            close $tmp;
        }

        ### is it bzip?
        ### if you asked specifically for bzip compression, or if we're in
        ### read mode and the magic numbers add up, use bzip
        if( BZIP and (
                ($compress eq COMPRESS_BZIP) or
                ( MODE_READ->($mode) and $magic =~ BZIP_MAGIC_NUM )
            )
        ) {

            ### different reader/writer modules, different error vars... sigh
            if( MODE_READ->($mode) ) {
                $fh = IO::Uncompress::Bunzip2->new( $file ) or do {
                    $self->_error( qq[Could not read '$file': ] .
                        $IO::Uncompress::Bunzip2::Bunzip2Error
                    );
                    return;
                };

            } else {
                $fh = IO::Compress::Bzip2->new( $file ) or do {
                    $self->_error( qq[Could not write to '$file': ] .
                        $IO::Compress::Bzip2::Bzip2Error
                    );
                    return;
                };
            }

        ### is it gzip?
        ### if you asked for compression, if you wanted to read or the gzip
        ### magic number is present (redundant with read)
        } elsif( ZLIB and (
                    $compress or MODE_READ->($mode) or $magic =~ GZIP_MAGIC_NUM
                 )
        ) {
            $fh = IO::Zlib->new;

            unless( $fh->open( $file, $mode ) ) {
                $self->_error(qq[Could not create filehandle for '$file': $!]);
                return;
            }

        ### is it plain tar?
        } else {
            $fh = IO::File->new;

            unless( $fh->open( $file, $mode ) ) {
                $self->_error(qq[Could not create filehandle for '$file': $!]);
                return;
            }

            ### enable bin mode on tar archives
            binmode $fh;
        }
    }

    return $fh;
}


sub _read_tar {
    my $self    = shift;
    my $handle  = shift or return;
    my $opts    = shift || {};

    my $count   = $opts->{limit}    || 0;
    my $filter  = $opts->{filter};
    my $md5  = $opts->{md5} || 0;	# cdrake
    my $filter_cb = $opts->{filter_cb};
    my $extract = $opts->{extract}  || 0;

    ### set a cap on the amount of files to extract ###
    my $limit   = 0;
    $limit = 1 if $count > 0;

    my $tarfile = [ ];
    my $chunk;
    my $read = 0;
    my $real_name;  # to set the name of a file when
                    # we're encountering @longlink
    my $data;

    LOOP:
    while( $handle->read( $chunk, HEAD ) ) {
        ### IO::Zlib doesn't support this yet
        my $offset;
        if ( ref($handle) ne 'IO::Zlib' ) {
            local $@;
            $offset = eval { tell $handle } || 'unknown';
            $@ = '';
        }
        else {
            $offset = 'unknown';
        }

        unless( $read++ ) {
            my $gzip = GZIP_MAGIC_NUM;
            if( $chunk =~ /$gzip/ ) {
                $self->_error( qq[Cannot read compressed format in tar-mode] );
                return;
            }

            ### size is < HEAD, which means a corrupted file, as the minimum
            ### length is _at least_ HEAD
            if (length $chunk != HEAD) {
                $self->_error( qq[Cannot read enough bytes from the tarfile] );
                return;
            }
        }

        ### if we can't read in all bytes... ###
        last if length $chunk != HEAD;

        ### Apparently this should really be two blocks of 512 zeroes,
        ### but GNU tar sometimes gets it wrong. See comment in the
        ### source code (tar.c) to GNU cpio.
        next if $chunk eq TAR_END;

        ### according to the posix spec, the last 12 bytes of the header are
        ### null bytes, to pad it to a 512 byte block. That means if these
        ### bytes are NOT null bytes, it's a corrupt header. See:
        ### www.koders.com/c/fidCE473AD3D9F835D690259D60AD5654591D91D5BA.aspx
        ### line 111
        {   my $nulls = join '', "\0" x 12;
            unless( $nulls eq substr( $chunk, 500, 12 ) ) {
                $self->_error( qq[Invalid header block at offset $offset] );
                next LOOP;
            }
        }

        ### pass the realname, so we can set it 'proper' right away
        ### some of the heuristics are done on the name, so important
        ### to set it ASAP
        my $entry;
        {   my %extra_args = ();
            $extra_args{'name'} = $$real_name if defined $real_name;

            unless( $entry = Archive::Tar::File->new(   chunk => $chunk,
                                                        %extra_args )
            ) {
                $self->_error( qq[Couldn't read chunk at offset $offset] );
                next LOOP;
            }
        }

        ### ignore labels:
        ### http://www.gnu.org/software/tar/manual/html_chapter/Media.html#SEC159
        next if $entry->is_label;

        if( length $entry->type and ($entry->is_file || $entry->is_longlink) ) {

            if ( $entry->is_file && !$entry->validate ) {
                ### sometimes the chunk is rather fux0r3d and a whole 512
                ### bytes ends up in the ->name area.
                ### clean it up, if need be
                my $name = $entry->name;
                $name = substr($name, 0, 100) if length $name > 100;
                $name =~ s/\n/ /g;

                $self->_error( $name . qq[: checksum error] );
                next LOOP;
            }

            my $block = BLOCK_SIZE->( $entry->size );

            $data = $entry->get_content_by_ref;

	    my $skip = 0;
	    my $ctx;			# cdrake
	    ### skip this entry if we're filtering

	    if($md5) {			# cdrake
	      $ctx = Digest::MD5->new;	# cdrake
	        $skip=5;		# cdrake

	    } elsif ($filter && $entry->name !~ $filter) {
		$skip = 1;

	    ### skip this entry if it's a pax header. This is a special file added
	    ### by, among others, git-generated tarballs. It holds comments and is
	    ### not meant for extracting. See #38932: pax_global_header extracted
	    } elsif ( $entry->name eq PAX_HEADER or $entry->type =~ /^(x|g)$/ ) {
		$skip = 2;
	    } elsif ($filter_cb && ! $filter_cb->($entry)) {
		$skip = 3;
	    }

	    if ($skip) {
		#
		# Since we're skipping, do not allocate memory for the
		# whole file.  Read it 64 BLOCKS at a time.  Do not
		# complete the skip yet because maybe what we read is a
		# longlink and it won't get skipped after all
		#
		my $amt = $block;
		my $fsz=$entry->size;	# cdrake
		while ($amt > 0) {
		    $$data = '';
		    my $this = 64 * BLOCK;
		    $this = $amt if $this > $amt;
		    if( $handle->read( $$data, $this ) < $this ) {
			$self->_error( qq[Read error on tarfile (missing data) '].
					    $entry->full_path ."' at offset $offset" );
			next LOOP;
		    }
		    $amt -= $this;
		    $fsz -= $this;	# cdrake
		substr ($$data, $fsz) = "" if ($fsz<0);	# remove external junk prior to md5	# cdrake
		$ctx->add($$data) if($skip==5);	# cdrake
		}
		$$data = $ctx->hexdigest if($skip==5 && !$entry->is_longlink && !$entry->is_unknown && !$entry->is_label ) ;	# cdrake
            } else {

		### just read everything into memory
		### can't do lazy loading since IO::Zlib doesn't support 'seek'
		### this is because Compress::Zlib doesn't support it =/
		### this reads in the whole data in one read() call.
		if ( $handle->read( $$data, $block ) < $block ) {
		    $self->_error( qq[Read error on tarfile (missing data) '].
                                    $entry->full_path ."' at offset $offset" );
		    next LOOP;
		}
		### throw away trailing garbage ###
		substr ($$data, $entry->size) = "" if defined $$data;
            }

            ### part II of the @LongLink munging -- need to do /after/
            ### the checksum check.
            if( $entry->is_longlink ) {
                ### weird thing in tarfiles -- if the file is actually a
                ### @LongLink, the data part seems to have a trailing ^@
                ### (unprintable) char. to display, pipe output through less.
                ### but that doesn't *always* happen.. so check if the last
                ### character is a control character, and if so remove it
                ### at any rate, we better remove that character here, or tests
                ### like 'eq' and hash lookups based on names will SO not work
                ### remove it by calculating the proper size, and then
                ### tossing out everything that's longer than that size.

                ### count number of nulls
                my $nulls = $$data =~ tr/\0/\0/;

                ### cut data + size by that many bytes
                $entry->size( $entry->size - $nulls );
                substr ($$data, $entry->size) = "";
            }
        }

        ### clean up of the entries.. posix tar /apparently/ has some
        ### weird 'feature' that allows for filenames > 255 characters
        ### they'll put a header in with as name '././@LongLink' and the
        ### contents will be the name of the /next/ file in the archive
        ### pretty crappy and kludgy if you ask me

        ### set the name for the next entry if this is a @LongLink;
        ### this is one ugly hack =/ but needed for direct extraction
        if( $entry->is_longlink ) {
            $real_name = $data;
            next LOOP;
        } elsif ( defined $real_name ) {
            $entry->name( $$real_name );
            $entry->prefix('');
            undef $real_name;
        }

	if ($filter && $entry->name !~ $filter) {
	    next LOOP;

	### skip this entry if it's a pax header. This is a special file added
	### by, among others, git-generated tarballs. It holds comments and is
	### not meant for extracting. See #38932: pax_global_header extracted
	} elsif ( $entry->name eq PAX_HEADER or $entry->type =~ /^(x|g)$/ ) {
	    next LOOP;
	} elsif ($filter_cb && ! $filter_cb->($entry)) {
	    next LOOP;
	}

        if ( $extract && !$entry->is_longlink
                      && !$entry->is_unknown
                      && !$entry->is_label ) {
            $self->_extract_file( $entry ) or return;
        }

        ### Guard against tarfiles with garbage at the end
	    last LOOP if $entry->name eq '';

        ### push only the name on the rv if we're extracting
        ### -- for extract_archive
        push @$tarfile, ($extract ? $entry->name : $entry);

        if( $limit ) {
            $count-- unless $entry->is_longlink || $entry->is_dir;
            last LOOP unless $count;
        }
    } continue {
        undef $data;
    }

    return $tarfile;
}

=head2 $tar->contains_file( $filename )

Check if the archive contains a certain file.
It will return true if the file is in the archive, false otherwise.

Note however, that this function does an exact match using C<eq>
on the full path. So it cannot compensate for case-insensitive file-
systems or compare 2 paths to see if they would point to the same
underlying file.

=cut

sub contains_file {
    my $self = shift;
    my $full = shift;

    return unless defined $full;

    ### don't warn if the entry isn't there.. that's what this function
    ### is for after all.
    local $WARN = 0;
    return 1 if $self->_find_entry($full);
    return;
}

=head2 $tar->extract( [@filenames] )

Write files whose names are equivalent to any of the names in
C<@filenames> to disk, creating subdirectories as necessary. This
might not work too well under VMS.
Under MacPerl, the file's modification time will be converted to the
MacOS zero of time, and appropriate conversions will be done to the
path.  However, the length of each element of the path is not
inspected to see whether it's longer than MacOS currently allows (32
characters).

If C<extract> is called without a list of file names, the entire
contents of the archive are extracted.

Returns a list of filenames extracted.

=cut

sub extract {
    my $self    = shift;
    my @args    = @_;
    my @files;

    # use the speed optimization for all extracted files
    local($self->{cwd}) = cwd() unless $self->{cwd};

    ### you requested the extraction of only certain files
    if( @args ) {
        for my $file ( @args ) {

            ### it's already an object?
            if( UNIVERSAL::isa( $file, 'Archive::Tar::File' ) ) {
                push @files, $file;
                next;

            ### go find it then
            } else {

                my $found;
                for my $entry ( @{$self->_data} ) {
                    next unless $file eq $entry->full_path;

                    ### we found the file you're looking for
                    push @files, $entry;
                    $found++;
                }

                unless( $found ) {
                    return $self->_error(
                        qq[Could not find '$file' in archive] );
                }
            }
        }

    ### just grab all the file items
    } else {
        @files = $self->get_files;
    }

    ### nothing found? that's an error
    unless( scalar @files ) {
        $self->_error( qq[No files found for ] . $self->_file );
        return;
    }

    ### now extract them
    for my $entry ( @files ) {
        unless( $self->_extract_file( $entry ) ) {
            $self->_error(q[Could not extract ']. $entry->full_path .q['] );
            return;
        }
    }

    return @files;
}

=head2 $tar->extract_file( $file, [$extract_path] )

Write an entry, whose name is equivalent to the file name provided to
disk. Optionally takes a second parameter, which is the full native
path (including filename) the entry will be written to.

For example:

    $tar->extract_file( 'name/in/archive', 'name/i/want/to/give/it' );

    $tar->extract_file( $at_file_object,   'name/i/want/to/give/it' );

Returns true on success, false on failure.

=cut

sub extract_file {
    my $self = shift;
    my $file = shift;   return unless defined $file;
    my $alt  = shift;

    my $entry = $self->_find_entry( $file )
        or $self->_error( qq[Could not find an entry for '$file'] ), return;

    return $self->_extract_file( $entry, $alt );
}

sub _extract_file {
    my $self    = shift;
    my $entry   = shift or return;
    my $alt     = shift;

    ### you wanted an alternate extraction location ###
    my $name = defined $alt ? $alt : $entry->full_path;

                            ### splitpath takes a bool at the end to indicate
                            ### that it's splitting a dir
    my ($vol,$dirs,$file);
    if ( defined $alt ) { # It's a local-OS path
        ($vol,$dirs,$file) = File::Spec->splitpath(       $alt,
                                                          $entry->is_dir );
    } else {
        ($vol,$dirs,$file) = File::Spec::Unix->splitpath( $name,
                                                          $entry->is_dir );
    }

    my $dir;
    ### is $name an absolute path? ###
    if( $vol || File::Spec->file_name_is_absolute( $dirs ) ) {

        ### absolute names are not allowed to be in tarballs under
        ### strict mode, so only allow it if a user tells us to do it
        if( not defined $alt and not $INSECURE_EXTRACT_MODE ) {
            $self->_error(
                q[Entry ']. $entry->full_path .q[' is an absolute path. ].
                q[Not extracting absolute paths under SECURE EXTRACT MODE]
            );
            return;
        }

        ### user asked us to, it's fine.
        $dir = File::Spec->catpath( $vol, $dirs, "" );

    ### it's a relative path ###
    } else {
        my $cwd     = (ref $self and defined $self->{cwd})
                        ? $self->{cwd}
                        : cwd();

        my @dirs = defined $alt
            ? File::Spec->splitdir( $dirs )         # It's a local-OS path
            : File::Spec::Unix->splitdir( $dirs );  # it's UNIX-style, likely
                                                    # straight from the tarball

        if( not defined $alt            and
            not $INSECURE_EXTRACT_MODE
        ) {

            ### paths that leave the current directory are not allowed under
            ### strict mode, so only allow it if a user tells us to do this.
            if( grep { $_ eq '..' } @dirs ) {

                $self->_error(
                    q[Entry ']. $entry->full_path .q[' is attempting to leave ].
                    q[the current working directory. Not extracting under ].
                    q[SECURE EXTRACT MODE]
                );
                return;
            }

            ### the archive may be asking us to extract into a symlink. This
            ### is not sane and a possible security issue, as outlined here:
            ### https://rt.cpan.org/Ticket/Display.html?id=30380
            ### https://bugzilla.redhat.com/show_bug.cgi?id=295021
            ### https://issues.rpath.com/browse/RPL-1716
            my $full_path = $cwd;
            for my $d ( @dirs ) {
                $full_path = File::Spec->catdir( $full_path, $d );

                ### we've already checked this one, and it's safe. Move on.
                next if ref $self and $self->{_link_cache}->{$full_path};

                if( -l $full_path ) {
                    my $to   = readlink $full_path;
                    my $diag = "symlinked directory ($full_path => $to)";

                    $self->_error(
                        q[Entry ']. $entry->full_path .q[' is attempting to ].
                        qq[extract to a $diag. This is considered a security ].
                        q[vulnerability and not allowed under SECURE EXTRACT ].
                        q[MODE]
                    );
                    return;
                }

                ### XXX keep a cache if possible, so the stats become cheaper:
                $self->{_link_cache}->{$full_path} = 1 if ref $self;
            }
        }

        ### '.' is the directory delimiter on VMS, which has to be escaped
        ### or changed to '_' on vms.  vmsify is used, because older versions
        ### of vmspath do not handle this properly.
        ### Must not add a '/' to an empty directory though.
        map { length() ? VMS::Filespec::vmsify($_.'/') : $_ } @dirs if ON_VMS;

        my ($cwd_vol,$cwd_dir,$cwd_file)
                    = File::Spec->splitpath( $cwd );
        my @cwd     = File::Spec->splitdir( $cwd_dir );
        push @cwd, $cwd_file if length $cwd_file;

        ### We need to pass '' as the last element to catpath. Craig Berry
        ### explains why (msgid <p0624083dc311ae541393@[172.16.52.1]>):
        ### The root problem is that splitpath on UNIX always returns the
        ### final path element as a file even if it is a directory, and of
        ### course there is no way it can know the difference without checking
        ### against the filesystem, which it is documented as not doing.  When
        ### you turn around and call catpath, on VMS you have to know which bits
        ### are directory bits and which bits are file bits.  In this case we
        ### know the result should be a directory.  I had thought you could omit
        ### the file argument to catpath in such a case, but apparently on UNIX
        ### you can't.
        $dir        = File::Spec->catpath(
                            $cwd_vol, File::Spec->catdir( @cwd, @dirs ), ''
                        );

        ### catdir() returns undef if the path is longer than 255 chars on
        ### older VMS systems.
        unless ( defined $dir ) {
            $^W && $self->_error( qq[Could not compose a path for '$dirs'\n] );
            return;
        }

    }

    if( -e $dir && !-d _ ) {
        $^W && $self->_error( qq['$dir' exists, but it's not a directory!\n] );
        return;
    }

    unless ( -d _ ) {
        eval { File::Path::mkpath( $dir, 0, 0777 ) };
        if( $@ ) {
            my $fp = $entry->full_path;
            $self->_error(qq[Could not create directory '$dir' for '$fp': $@]);
            return;
        }

        ### XXX chown here? that might not be the same as in the archive
        ### as we're only chown'ing to the owner of the file we're extracting
        ### not to the owner of the directory itself, which may or may not
        ### be another entry in the archive
        ### Answer: no, gnu tar doesn't do it either, it'd be the wrong
        ### way to go.
        #if( $CHOWN && CAN_CHOWN ) {
        #    chown $entry->uid, $entry->gid, $dir or
        #        $self->_error( qq[Could not set uid/gid on '$dir'] );
        #}
    }

    ### we're done if we just needed to create a dir ###
    return 1 if $entry->is_dir;

    my $full = File::Spec->catfile( $dir, $file );

    if( $entry->is_unknown ) {
        $self->_error( qq[Unknown file type for file '$full'] );
        return;
    }

    if( length $entry->type && $entry->is_file ) {
        my $fh = IO::File->new;
        $fh->open( '>' . $full ) or (
            $self->_error( qq[Could not open file '$full': $!] ),
            return
        );

        if( $entry->size ) {
            binmode $fh;
            syswrite $fh, $entry->data or (
                $self->_error( qq[Could not write data to '$full'] ),
                return
            );
        }

        close $fh or (
            $self->_error( qq[Could not close file '$full'] ),
            return
        );

    } else {
        $self->_make_special_file( $entry, $full ) or return;
    }

    ### only update the timestamp if it's not a symlink; that will change the
    ### timestamp of the original. This addresses bug #33669: Could not update
    ### timestamp warning on symlinks
    if( not -l $full ) {
        utime time, $entry->mtime - TIME_OFFSET, $full or
            $self->_error( qq[Could not update timestamp] );
    }

    if( $CHOWN && CAN_CHOWN->() and not -l $full ) {
        chown $entry->uid, $entry->gid, $full or
            $self->_error( qq[Could not set uid/gid on '$full'] );
    }

    ### only chmod if we're allowed to, but never chmod symlinks, since they'll
    ### change the perms on the file they're linking too...
    if( $CHMOD and not -l $full ) {
        my $mode = $entry->mode;
        unless ($SAME_PERMISSIONS) {
            $mode &= ~(oct(7000) | umask);
        }
        chmod $mode, $full or
            $self->_error( qq[Could not chown '$full' to ] . $entry->mode );
    }

    return 1;
}

sub _make_special_file {
    my $self    = shift;
    my $entry   = shift     or return;
    my $file    = shift;    return unless defined $file;

    my $err;

    if( $entry->is_symlink ) {
        my $fail;
        if( ON_UNIX ) {
            symlink( $entry->linkname, $file ) or $fail++;

        } else {
            $self->_extract_special_file_as_plain_file( $entry, $file )
                or $fail++;
        }

        $err =  qq[Making symbolic link '$file' to '] .
                $entry->linkname .q[' failed] if $fail;

    } elsif ( $entry->is_hardlink ) {
        my $fail;
        if( ON_UNIX ) {
            link( $entry->linkname, $file ) or $fail++;

        } else {
            $self->_extract_special_file_as_plain_file( $entry, $file )
                or $fail++;
        }

        $err =  qq[Making hard lin