sk($HANDLE);
\&        if ( defined $size ) {
\&                # proceed
\&        }
.Ve
.IP "GetMaxResourceSize \s-1HANDLE\s0" 4
.IX Item "GetMaxResourceSize HANDLE"
Like &GetResourceSizeOnDisk, GetMaxResourceSize takes a handle and returns the
size of the corresponding resource. However, GetMaxResourceSize does not check
the resource on disk; instead, it either checks the resource size in memory or,
if the resource is not in memory, calculates its size, in bytes, on the basis of
information in the resource map in memory. This gives you an approximate size for
the resource that you can count on as the resource's maximum size. It's possible
that the resource is actually smaller than the offsets in the resource map
indicate because the file has not yet been compacted. If you want the exact size
of a resource on disk, either call &GetResourceSizeOnDisk or call &UpdateResFile
before calling GetMaxResourceSize.
.Sp
.Vb 4
\&    $size = GetMaxResourceSize($HANDLE);
\&    if ( defined $size ) {
\&        # proceed
\&    }
.Ve
.IP "RsrcMapEntry \s-1HANDLE\s0" 4
.IX Item "RsrcMapEntry HANDLE"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Given a handle to a resource, RsrcMapEntry returns the offset of the specified
resource's entry from the beginning of the resource map in memory. If it doesn't
find the resource entry, RsrcMapEntry returns 0, and the ResError function
returns the result code resNotFound. If you pass a handle whose value is \s-1NIL,\s0
RsrcMapEntry returns arbitrary data.
.Sp
.Vb 4
\&    $offset = RsrcMapEntry($HANDLE);
\&    if ( defined $offset ) {
\&        # proceed
\&    }
.Ve
.IP "SetResAttrs \s-1HANDLE, ATTRS\s0" 4
.IX Item "SetResAttrs HANDLE, ATTRS"
Given a handle to a resource, SetResAttrs changes the resource attributes of the
resource to those specified in the attrs parameter. The SetResAttrs procedure
changes the information in the resource map in memory, not in the file on disk.
The resProtected attribute changes immediately. Other attribute changes take
effect the next time the specified resource is read into memory but are not made
permanent until the Resource Manager updates the resource fork.
.Sp
.Vb 5
\&    if ( SetResAttrs($HANDLE, $ATTRS) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "ChangedResource \s-1HANDLE\s0" 4
.IX Item "ChangedResource HANDLE"
Given a handle to a resource, the ChangedResource procedure sets the resChanged
attribute for that resource in the resource map in memory. If the resChanged
attribute for a resource has been set and your application calls &UpdateResFile or
quits, the Resource Manager writes the resource data for that resource (and for
all other resources whose resChanged attribute is set) and the entire resource
map to the resource fork of the corresponding file on disk. If the resChanged
attribute for a resource has been set and your application calls &WriteResource,
the Resource Manager writes only the resource data for that resource to disk.
.Sp
.Vb 5
\&    if ( ChangedResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "RemoveResource \s-1HANDLE\s0" 4
.IX Item "RemoveResource HANDLE"
Given a handle to a resource in the current resource file, RemoveResource removes
the resource entry (resource type, resource \s-1ID,\s0 resource name, if any, and
resource attributes) from the current resource file's resource map in memory.
.Sp
.Vb 5
\&    if ( RemoveResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "UpdateResFile \s-1RFD\s0" 4
.IX Item "UpdateResFile RFD"
Given the reference number of a file whose resource fork is open, UpdateResFile
performs three tasks. The first task is to change, add, or remove resource data
in the file's resource fork to match the resource map in memory. Changed resource
data for each resource is written only if that resource's resChanged bit has been
set by a successful call to &ChangedResource or &AddResource. The UpdateResFile
procedure calls the &WriteResource procedure to write changed or added resources
to the resource fork.
.Sp
.Vb 5
\&    if ( UpdateResFile($RFD) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "WriteResource \s-1HANDLE\s0" 4
.IX Item "WriteResource HANDLE"
Given a handle to a resource, WriteResource checks the resChanged attribute of
that resource. If the resChanged attribute is set to 1 (after a successful call
to the &ChangedResource or &AddResource procedure), WriteResource writes the
resource data in memory to the resource fork, then clears the resChanged
attribute in the resource's resource map in memory.
.Sp
.Vb 5
\&    if ( WriteResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "SetResPurge \s-1INSTALL\s0" 4
.IX Item "SetResPurge INSTALL"
Specify \s-1TRUE\s0 in the install parameter to make the Memory Manager pass the handle
for a resource to the Resource Manager before purging the resource data to which
the handle points. The Resource Manager determines whether the handle points to a
resource in the application heap. It also checks if the resource's resChanged
attribute is set to 1. If these two conditions are met, the Resource Manager
calls the &WriteResource procedure to write the resource's resource data to the
resource fork before returning control to the Memory Manager.
.Sp
Specify \s-1FALSE\s0 in the install parameter to restore the normal state, so that the
Memory Manager purges resource data when it needs to without calling the Resource
Manager.
.Sp
.Vb 5
\&    if ( SetResPurge(1) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "GetResFileAttrs \s-1RFD\s0" 4
.IX Item "GetResFileAttrs RFD"
Given a file reference number, the GetResFileAttrs function returns the
attributes of the file's resource fork. Specify 0 in \f(CW$RFD\fR to get
the attributes of the System file's resource fork. If there's no open resource
fork for the given file reference number, undef is returned.
.Sp
.Vb 4
\&    $rfa = GetResFileAttrs($RFD);
\&    if ( defined $rfa ) {
\&        # proceed
\&    }
.Ve
.IP "SetResFileAttrs \s-1RFD, ATTRS\s0" 4
.IX Item "SetResFileAttrs RFD, ATTRS"
Given a file reference number, the SetResFileAttrs procedure sets the attributes
of the file's resource fork to those specified in the attrs parameter. If the
refNum parameter is 0, it represents the System file's resource fork. However,
you shouldn't change the attributes of the System file's resource fork. If
there's no resource fork with the given reference number, SetResFileAttrs does
nothing, and the ResError function returns the result code noErr.
.Sp
.Vb 5
\&    if ( SetResFileAttrs($RFD, $ATTRS) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "RGetResource \s-1TYPE, ID\s0" 4
.IX Item "RGetResource TYPE, ID"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
The RGetResource function searches the resource maps in memory for the resource
specified by the parameters \f(CW$TYPE\fR and \f(CW$ID\fR. The resource maps in memory, which
represent all open resource forks, are arranged as a linked list. The
RGetResource function first uses GetResource to search this list. The GetResource
function starts with the current resource file and progresses through the list in
order (that is, in reverse chronological order in which the resource forks were
opened) until it finds the resource's entry in one of the resource maps. If
GetResource doesn't find the specified resource in its search of the resource
maps of open resource forks (which includes the System file's resource fork),
RGetResource sets the global variable RomMapInsert to \s-1TRUE,\s0 then calls
GetResource again. In response, GetResource performs the same search, but this
time it looks in the resource map of the ROM-resident resources before searching
the resource map of the System file.
.Sp
.Vb 4
\&    $handle = RGetResource("DITL", 6042);
\&    if ( defined $handle ) {
\&        # proceed
\&    }
.Ve
.IP "FSpOpenResFile \s-1SPEC, PERMISSION\s0" 4
.IX Item "FSpOpenResFile SPEC, PERMISSION"
The FSpOpenResFile function opens the resource fork of the file identified by the
spec parameter. It also makes this file the current resource file.
.Sp
.Vb 4
\&    $sp = FSpOpenResFile($SPEC);
\&    if ( defined $sp ) {
\&        # proceed
\&    }
.Ve
.Sp
In addition to opening the resource fork for the file with the specified name,
FSpOpenResFile lets you specify in the permission parameter the read/write permission
of the resource fork the first time it is opened.
.IP "FSOpenResourceFile \s-1REF, FORKNAME, PERMISSION\s0" 4
.IX Item "FSOpenResourceFile REF, FORKNAME, PERMISSION"
\&\fBMac \s-1OS X\s0 only.\fR
.Sp
The FSOpenResourceFile function is like FSpOpenResFile, except that it can open
a resource file using the data fork or resource fork.  \f(CW$REF\fR is the
path to the resource file.  \f(CW$FORKNAME\fR is
\&\*(L"rsrc\*(R" for a resource fork; else the data fork will be used.  It also makes this
file the current resource file.
.IP "FSpCreateResFile \s-1SPEC, CREATOR, FILETYPE, SCRIPTTAG\s0" 4
.IX Item "FSpCreateResFile SPEC, CREATOR, FILETYPE, SCRIPTTAG"
The FSpCreateResFile procedure creates an empty resource fork for a file with the
specified \f(CW$FILETYPE\fR, \f(CW$CREATOR\fR, and \f(CW$SCRIPTTAG\fR in the location and with the name
designated by the spec parameter. (An empty resource fork contains no resource
data but does include a resource map.)
.Sp
.Vb 5
\&    if ( FSpCreateResFile($SPEC, $CREATOR, $FILETYPE, $SCRIPTTAG) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "FSCreateResourceFile \s-1PARENTREF, FILENAME, FORKNAME\s0" 4
.IX Item "FSCreateResourceFile PARENTREF, FILENAME, FORKNAME"
\&\fBMac \s-1OS X\s0 only.\fR
.Sp
The FSCreateResourceFile procedure is like FSpCreateResFile, except that it can
create a resource file in the data fork or resource fork.  \f(CW$PARENTREF\fR is the
oath of the directory where the new \f(CW$FILENAME\fR will be located.  \f(CW$FORKNAME\fR is
\&\*(L"rsrc\*(R" for a resource fork; else the data fork will be used.
.IP "ReadPartialResource \s-1HANDLE, OFFSET, BYTECOUNT\s0" 4
.IX Item "ReadPartialResource HANDLE, OFFSET, BYTECOUNT"
The ReadPartialResource procedure reads the resource subsection identified by the
theResource, offset, and count parameters.
.Sp
.Vb 1
\&    $data = ReadPartialResource($rsrc, 2000, 256);
.Ve
.IP "WritePartialResource \s-1HANDLE, OFFSET, DATA\s0" 4
.IX Item "WritePartialResource HANDLE, OFFSET, DATA"
The WritePartialResource procedure writes the data specified by \s-1DATA \s0
to the resource subsection identified by the \s-1HANDLE\s0 and \s-1OFFSET\s0 parameters.
.Sp
.Vb 5
\&    if ( WritePartialResource($HANDLE, $OFFSET, $DATA) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "SetResourceSize \s-1HANDLE, SIZE\s0" 4
.IX Item "SetResourceSize HANDLE, SIZE"
Given a handle to a resource, SetResourceSize sets the size field of the
specified resource on disk without writing the resource data. You can change the
size of any resource, regardless of the amount of memory you have available.
.Sp
.Vb 5
\&    if ( SetResource($HANDLE, $SIZE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>,
documentation by Bob Dalgleish <bob.dalgleish@sasknet.sk.ca>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 79:" 4
.IX Item "Around line 79:"
Non-ASCII character seen before =encoding in '\*(D-1,'. Assuming \s-1ISO8859\-1\s0
                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Sound.3pm                               0100644 0001750 0001750 00000011207 12566241372 023177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sound 3"
.TH Sound 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Sound \- Macintosh Toolbox Interface to Sound Manager
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Constants"
.IX Subsection "Constants"
Not yet documented.
.SS "Structures"
.IX Subsection "Structures"
Not yet documented.
.SS "Functions"
.IX Subsection "Functions"
Not yet documented.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Sound5.16.3pm                           0100644 0001750 0001750 00000010666 12566241372 023521  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sound 3"
.TH Sound 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Sound \- Macintosh Toolbox Interface to Sound Manager
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Constants"
.IX Subsection "Constants"
Not yet documented.
.SS "Structures"
.IX Subsection "Structures"
Not yet documented.
.SS "Functions"
.IX Subsection "Functions"
Not yet documented.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Sound5.18.3pm                           0100644 0001750 0001750 00000011207 12566241372 023513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sound 3"
.TH Sound 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Sound \- Macintosh Toolbox Interface to Sound Manager
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Constants"
.IX Subsection "Constants"
Not yet documented.
.SS "Structures"
.IX Subsection "Structures"
Not yet documented.
.SS "Functions"
.IX Subsection "Functions"
Not yet documented.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Speech.3pm                              0100644 0001750 0001750 00000020164 12566241374 023322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Speech 3"
.TH Speech 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Speech \- Provide interface to PlainTalk (Speech Manager)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mac::Speech;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Variables"
.IX Subsection "Variables"
.ie n .IP "%Voice" 4
.el .IP "\f(CW%Voice\fR" 4
.IX Item "%Voice"
The \f(CW%Voice\fR hash will return the index to the first voice whose name
matches the given text.
.SS "Constants"
.IX Subsection "Constants"
.IP "kTextToSpeechSynthType" 4
.IX Item "kTextToSpeechSynthType"
.PD 0
.IP "kTextToSpeechVoiceType" 4
.IX Item "kTextToSpeechVoiceType"
.IP "kTextToSpeechVoiceFileType" 4
.IX Item "kTextToSpeechVoiceFileType"
.IP "kTextToSpeechVoiceBundleType" 4
.IX Item "kTextToSpeechVoiceBundleType"
.PD
Speech Types.
.IP "kNoEndingProsody" 4
.IX Item "kNoEndingProsody"
.PD 0
.IP "kNoSpeechInterrupt" 4
.IX Item "kNoSpeechInterrupt"
.IP "kPreflightThenPause" 4
.IX Item "kPreflightThenPause"
.PD
Synthesizer flags.
.IP "kImmediate" 4
.IX Item "kImmediate"
.PD 0
.IP "kEndOfWord" 4
.IX Item "kEndOfWord"
.IP "kEndOfSentence" 4
.IX Item "kEndOfSentence"
.PD
Where to stop.
.IP "kNeuter" 4
.IX Item "kNeuter"
.PD 0
.IP "kMale" 4
.IX Item "kMale"
.IP "kFemale" 4
.IX Item "kFemale"
.PD
Genders.
.SS "Types"
.IX Subsection "Types"
.IP "VoiceDescription" 4
.IX Item "VoiceDescription"
Voice Description Record.
.Sp
.Vb 10
\&        long        length              size of structure\-\-set by application
\&        VoiceSpec   voice               voice synthesizer and ID info
\&        long        version             version number of voice
\&        Str63       name                name of voice
\&        Str255      comment             text information about voice
\&        short       gender              neuter, male, or female
\&        short       age                 approximate age in years
\&        short       script              script code of text voice can process
\&        short       language            language code of voice output
\&        short       region              region code of voice output
.Ve
.IP "VoiceSpec" 4
.IX Item "VoiceSpec"
Voice Specification Record.
.Sp
.Vb 2
\&        OSType      creator             ID of required synthesizer
\&        OSType      id                  ID of voice on the synthesizer
.Ve
.SS "Functions"
.IX Subsection "Functions"
.IP "SpeechManagerVersion" 4
.IX Item "SpeechManagerVersion"
.PD 0
.IP "CountVoices" 4
.IX Item "CountVoices"
.IP "GetIndVoice \s-1INDEX \s0" 4
.IX Item "GetIndVoice INDEX "
.IP "GetVoiceDescription \s-1VOICE \s0" 4
.IX Item "GetVoiceDescription VOICE "
.IP "NewSpeechChannel \s-1VOICE \s0" 4
.IX Item "NewSpeechChannel VOICE "
.IP "DisposeSpeechChannel \s-1CHAN \s0" 4
.IX Item "DisposeSpeechChannel CHAN "
.IP "SpeakString S" 4
.IX Item "SpeakString S"
.IP "SpeakText \s-1CHAN, TEXT \s0" 4
.IX Item "SpeakText CHAN, TEXT "
.IP "SpeakBuffer \s-1CHAN, TEXT, CONTROLFLAGS \s0" 4
.IX Item "SpeakBuffer CHAN, TEXT, CONTROLFLAGS "
.IP "StopSpeech \s-1CHAN \s0" 4
.IX Item "StopSpeech CHAN "
.IP "StopSpeechAt \s-1CHAN, WHERETOSTOP \s0" 4
.IX Item "StopSpeechAt CHAN, WHERETOSTOP "
.IP "PauseSpeechAt \s-1CHAN, WHERETOPAUSE \s0" 4
.IX Item "PauseSpeechAt CHAN, WHERETOPAUSE "
.IP "ContinueSpeech \s-1CHAN \s0" 4
.IX Item "ContinueSpeech CHAN "
.IP "SpeechBusy" 4
.IX Item "SpeechBusy"
.IP "SpeechBusySystemWide" 4
.IX Item "SpeechBusySystemWide"
.IP "SetSpeechRate \s-1CHAN, RATE \s0" 4
.IX Item "SetSpeechRate CHAN, RATE "
.IP "GetSpeechRate \s-1CHAN \s0" 4
.IX Item "GetSpeechRate CHAN "
.IP "SetSpeechPitch \s-1CHAN, PITCH \s0" 4
.IX Item "SetSpeechPitch CHAN, PITCH "
.IP "GetSpeechPitch \s-1CHAN \s0" 4
.IX Item "GetSpeechPitch CHAN "
.IP "TextToPhonemes \s-1CHAN, TEXT\s0" 4
.IX Item "TextToPhonemes CHAN, TEXT"
.IP "SpeechToFile \s-1CHAN, PATH\s0" 4
.IX Item "SpeechToFile CHAN, PATH"
.PD
Set speech channel \s-1CHAN\s0 to output to file \s-1PATH.\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Speech5.16.3pm                          0100644 0001750 0001750 00000017706 12566241374 023644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Speech 3"
.TH Speech 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Speech \- Provide interface to PlainTalk (Speech Manager)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mac::Speech;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Variables"
.IX Subsection "Variables"
.ie n .IP "%Voice" 4
.el .IP "\f(CW%Voice\fR" 4
.IX Item "%Voice"
The \f(CW%Voice\fR hash will return the index to the first voice whose name
matches the given text.
.SS "Constants"
.IX Subsection "Constants"
.IP "kTextToSpeechSynthType" 4
.IX Item "kTextToSpeechSynthType"
.PD 0
.IP "kTextToSpeechVoiceType" 4
.IX Item "kTextToSpeechVoiceType"
.IP "kTextToSpeechVoiceFileType" 4
.IX Item "kTextToSpeechVoiceFileType"
.IP "kTextToSpeechVoiceBundleType" 4
.IX Item "kTextToSpeechVoiceBundleType"
.PD
Speech Types.
.IP "kNoEndingProsody" 4
.IX Item "kNoEndingProsody"
.PD 0
.IP "kNoSpeechInterrupt" 4
.IX Item "kNoSpeechInterrupt"
.IP "kPreflightThenPause" 4
.IX Item "kPreflightThenPause"
.PD
Synthesizer flags.
.IP "kImmediate" 4
.IX Item "kImmediate"
.PD 0
.IP "kEndOfWord" 4
.IX Item "kEndOfWord"
.IP "kEndOfSentence" 4
.IX Item "kEndOfSentence"
.PD
Where to stop.
.IP "kNeuter" 4
.IX Item "kNeuter"
.PD 0
.IP "kMale" 4
.IX Item "kMale"
.IP "kFemale" 4
.IX Item "kFemale"
.PD
Genders.
.SS "Types"
.IX Subsection "Types"
.IP "VoiceDescription" 4
.IX Item "VoiceDescription"
Voice Description Record.
.Sp
.Vb 10
\&        long        length              size of structure\-\-set by application
\&        VoiceSpec   voice               voice synthesizer and ID info
\&        long        version             version number of voice
\&        Str63       name                name of voice
\&        Str255      comment             text information about voice
\&        short       gender              neuter, male, or female
\&        short       age                 approximate age in years
\&        short       script              script code of text voice can process
\&        short       language            language code of voice output
\&        short       region              region code of voice output
.Ve
.IP "VoiceSpec" 4
.IX Item "VoiceSpec"
Voice Specification Record.
.Sp
.Vb 2
\&        OSType      creator             ID of required synthesizer
\&        OSType      id                  ID of voice on the synthesizer
.Ve
.SS "Functions"
.IX Subsection "Functions"
.IP "SpeechManagerVersion" 4
.IX Item "SpeechManagerVersion"
.PD 0
.IP "CountVoices" 4
.IX Item "CountVoices"
.IP "GetIndVoice \s-1INDEX\s0" 4
.IX Item "GetIndVoice INDEX"
.IP "GetVoiceDescription \s-1VOICE\s0" 4
.IX Item "GetVoiceDescription VOICE"
.IP "NewSpeechChannel \s-1VOICE\s0" 4
.IX Item "NewSpeechChannel VOICE"
.IP "DisposeSpeechChannel \s-1CHAN\s0" 4
.IX Item "DisposeSpeechChannel CHAN"
.IP "SpeakString S" 4
.IX Item "SpeakString S"
.IP "SpeakText \s-1CHAN\s0, \s-1TEXT\s0" 4
.IX Item "SpeakText CHAN, TEXT"
.IP "SpeakBuffer \s-1CHAN\s0, \s-1TEXT\s0, \s-1CONTROLFLAGS\s0" 4
.IX Item "SpeakBuffer CHAN, TEXT, CONTROLFLAGS"
.IP "StopSpeech \s-1CHAN\s0" 4
.IX Item "StopSpeech CHAN"
.IP "StopSpeechAt \s-1CHAN\s0, \s-1WHERETOSTOP\s0" 4
.IX Item "StopSpeechAt CHAN, WHERETOSTOP"
.IP "PauseSpeechAt \s-1CHAN\s0, \s-1WHERETOPAUSE\s0" 4
.IX Item "PauseSpeechAt CHAN, WHERETOPAUSE"
.IP "ContinueSpeech \s-1CHAN\s0" 4
.IX Item "ContinueSpeech CHAN"
.IP "SpeechBusy" 4
.IX Item "SpeechBusy"
.IP "SpeechBusySystemWide" 4
.IX Item "SpeechBusySystemWide"
.IP "SetSpeechRate \s-1CHAN\s0, \s-1RATE\s0" 4
.IX Item "SetSpeechRate CHAN, RATE"
.IP "GetSpeechRate \s-1CHAN\s0" 4
.IX Item "GetSpeechRate CHAN"
.IP "SetSpeechPitch \s-1CHAN\s0, \s-1PITCH\s0" 4
.IX Item "SetSpeechPitch CHAN, PITCH"
.IP "GetSpeechPitch \s-1CHAN\s0" 4
.IX Item "GetSpeechPitch CHAN"
.IP "TextToPhonemes \s-1CHAN\s0, \s-1TEXT\s0" 4
.IX Item "TextToPhonemes CHAN, TEXT"
.IP "SpeechToFile \s-1CHAN\s0, \s-1PATH\s0" 4
.IX Item "SpeechToFile CHAN, PATH"
.PD
Set speech channel \s-1CHAN\s0 to output to file \s-1PATH\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Speech5.18.3pm                          0100644 0001750 0001750 00000020164 12566241374 023636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Speech 3"
.TH Speech 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Speech \- Provide interface to PlainTalk (Speech Manager)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mac::Speech;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Variables"
.IX Subsection "Variables"
.ie n .IP "%Voice" 4
.el .IP "\f(CW%Voice\fR" 4
.IX Item "%Voice"
The \f(CW%Voice\fR hash will return the index to the first voice whose name
matches the given text.
.SS "Constants"
.IX Subsection "Constants"
.IP "kTextToSpeechSynthType" 4
.IX Item "kTextToSpeechSynthType"
.PD 0
.IP "kTextToSpeechVoiceType" 4
.IX Item "kTextToSpeechVoiceType"
.IP "kTextToSpeechVoiceFileType" 4
.IX Item "kTextToSpeechVoiceFileType"
.IP "kTextToSpeechVoiceBundleType" 4
.IX Item "kTextToSpeechVoiceBundleType"
.PD
Speech Types.
.IP "kNoEndingProsody" 4
.IX Item "kNoEndingProsody"
.PD 0
.IP "kNoSpeechInterrupt" 4
.IX Item "kNoSpeechInterrupt"
.IP "kPreflightThenPause" 4
.IX Item "kPreflightThenPause"
.PD
Synthesizer flags.
.IP "kImmediate" 4
.IX Item "kImmediate"
.PD 0
.IP "kEndOfWord" 4
.IX Item "kEndOfWord"
.IP "kEndOfSentence" 4
.IX Item "kEndOfSentence"
.PD
Where to stop.
.IP "kNeuter" 4
.IX Item "kNeuter"
.PD 0
.IP "kMale" 4
.IX Item "kMale"
.IP "kFemale" 4
.IX Item "kFemale"
.PD
Genders.
.SS "Types"
.IX Subsection "Types"
.IP "VoiceDescription" 4
.IX Item "VoiceDescription"
Voice Description Record.
.Sp
.Vb 10
\&        long        length              size of structure\-\-set by application
\&        VoiceSpec   voice               voice synthesizer and ID info
\&        long        version             version number of voice
\&        Str63       name                name of voice
\&        Str255      comment             text information about voice
\&        short       gender              neuter, male, or female
\&        short       age                 approximate age in years
\&        short       script              script code of text voice can process
\&        short       language            language code of voice output
\&        short       region              region code of voice output
.Ve
.IP "VoiceSpec" 4
.IX Item "VoiceSpec"
Voice Specification Record.
.Sp
.Vb 2
\&        OSType      creator             ID of required synthesizer
\&        OSType      id                  ID of voice on the synthesizer
.Ve
.SS "Functions"
.IX Subsection "Functions"
.IP "SpeechManagerVersion" 4
.IX Item "SpeechManagerVersion"
.PD 0
.IP "CountVoices" 4
.IX Item "CountVoices"
.IP "GetIndVoice \s-1INDEX \s0" 4
.IX Item "GetIndVoice INDEX "
.IP "GetVoiceDescription \s-1VOICE \s0" 4
.IX Item "GetVoiceDescription VOICE "
.IP "NewSpeechChannel \s-1VOICE \s0" 4
.IX Item "NewSpeechChannel VOICE "
.IP "DisposeSpeechChannel \s-1CHAN \s0" 4
.IX Item "DisposeSpeechChannel CHAN "
.IP "SpeakString S" 4
.IX Item "SpeakString S"
.IP "SpeakText \s-1CHAN, TEXT \s0" 4
.IX Item "SpeakText CHAN, TEXT "
.IP "SpeakBuffer \s-1CHAN, TEXT, CONTROLFLAGS \s0" 4
.IX Item "SpeakBuffer CHAN, TEXT, CONTROLFLAGS "
.IP "StopSpeech \s-1CHAN \s0" 4
.IX Item "StopSpeech CHAN "
.IP "StopSpeechAt \s-1CHAN, WHERETOSTOP \s0" 4
.IX Item "StopSpeechAt CHAN, WHERETOSTOP "
.IP "PauseSpeechAt \s-1CHAN, WHERETOPAUSE \s0" 4
.IX Item "PauseSpeechAt CHAN, WHERETOPAUSE "
.IP "ContinueSpeech \s-1CHAN \s0" 4
.IX Item "ContinueSpeech CHAN "
.IP "SpeechBusy" 4
.IX Item "SpeechBusy"
.IP "SpeechBusySystemWide" 4
.IX Item "SpeechBusySystemWide"
.IP "SetSpeechRate \s-1CHAN, RATE \s0" 4
.IX Item "SetSpeechRate CHAN, RATE "
.IP "GetSpeechRate \s-1CHAN \s0" 4
.IX Item "GetSpeechRate CHAN "
.IP "SetSpeechPitch \s-1CHAN, PITCH \s0" 4
.IX Item "SetSpeechPitch CHAN, PITCH "
.IP "GetSpeechPitch \s-1CHAN \s0" 4
.IX Item "GetSpeechPitch CHAN "
.IP "TextToPhonemes \s-1CHAN, TEXT\s0" 4
.IX Item "TextToPhonemes CHAN, TEXT"
.IP "SpeechToFile \s-1CHAN, PATH\s0" 4
.IX Item "SpeechToFile CHAN, PATH"
.PD
Set speech channel \s-1CHAN\s0 to output to file \s-1PATH.\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Types.3pm                               0100644 0001750 0001750 00000013602 12566241375 023217  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Types 3"
.TH Types 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Types \- Macintosh Toolbox Types and conversions.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Functions"
.IX Subsection "Functions"
.IP "MacPack [ \s-1CONVERTERS ...\s0] \s-1CODE, DATA ...\s0" 4
.IX Item "MacPack [ CONVERTERS ...] CODE, DATA ..."
Convert a perl value into a Mac toolbox type. Predefined codes are:
.RS 4
.IP "\s-1TEXT \s0" 4
.IX Item "TEXT "
Text (an identity operation).
.IP "enum" 4
.IX Item "enum"
.PD 0
.IP "type" 4
.IX Item "type"
.IP "keyw" 4
.IX Item "keyw"
.PD
A 4\-byte string.
.IP "bool" 4
.IX Item "bool"
A boolean.
.IP "shor" 4
.IX Item "shor"
A short integer.
.IP "long" 4
.IX Item "long"
A long integer.
.IP "sing" 4
.IX Item "sing"
A single precision float.
.IP "doub" 4
.IX Item "doub"
A double precision float.
.IP "magn" 4
.IX Item "magn"
An unsigned long.
.IP "qdrt" 4
.IX Item "qdrt"
A QuickDraw \f(CW\*(C`Rect\*(C'\fR.
.IP "'\s-1STR \s0'" 4
.IX Item "'STR '"
A pascal style string.
.IP "'STR#'" 4
.IX Item "'STR#'"
A string list.
.IP "'fss '" 4
.IX Item "'fss '"
A file specification record.
.RE
.RS 4
.Sp
You can pass further code mappings as hash references.
.RE
.IP "MacUnpack [ \s-1CONVERTERS ...\s0] \s-1CODE, DATA\s0" 4
.IX Item "MacUnpack [ CONVERTERS ...] CODE, DATA"
Convert a Mac toolbox type into a perl value. Predefined codes are as for 
\&\f(CW\*(C`MacPack\*(C'\fR. You can pass further code mappings as hash references.
.SS "\s-1XS\s0 Functions"
.IX Subsection "XS Functions"
.IP "Debugger [ \s-1MSG \s0]" 4
.IX Item "Debugger [ MSG ]"
Break into MacsBug. Don't use this if you don't know what MacsBug is.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Types5.16.3pm                           0100644 0001750 0001750 00000013275 12566241375 023537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Types 3"
.TH Types 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Types \- Macintosh Toolbox Types and conversions.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Functions"
.IX Subsection "Functions"
.IP "MacPack [ \s-1CONVERTERS\s0 ...] \s-1CODE\s0, \s-1DATA\s0 ..." 4
.IX Item "MacPack [ CONVERTERS ...] CODE, DATA ..."
Convert a perl value into a Mac toolbox type. Predefined codes are:
.RS 4
.IP "\s-1TEXT\s0" 4
.IX Item "TEXT"
Text (an identity operation).
.IP "enum" 4
.IX Item "enum"
.PD 0
.IP "type" 4
.IX Item "type"
.IP "keyw" 4
.IX Item "keyw"
.PD
A 4\-byte string.
.IP "bool" 4
.IX Item "bool"
A boolean.
.IP "shor" 4
.IX Item "shor"
A short integer.
.IP "long" 4
.IX Item "long"
A long integer.
.IP "sing" 4
.IX Item "sing"
A single precision float.
.IP "doub" 4
.IX Item "doub"
A double precision float.
.IP "magn" 4
.IX Item "magn"
An unsigned long.
.IP "qdrt" 4
.IX Item "qdrt"
A QuickDraw \f(CW\*(C`Rect\*(C'\fR.
.IP "'\s-1STR\s0 '" 4
.IX Item "'STR '"
A pascal style string.
.IP "'STR#'" 4
.IX Item "'STR#'"
A string list.
.IP "'fss '" 4
.IX Item "'fss '"
A file specification record.
.RE
.RS 4
.Sp
You can pass further code mappings as hash references.
.RE
.IP "MacUnpack [ \s-1CONVERTERS\s0 ...] \s-1CODE\s0, \s-1DATA\s0" 4
.IX Item "MacUnpack [ CONVERTERS ...] CODE, DATA"
Convert a Mac toolbox type into a perl value. Predefined codes are as for 
\&\f(CW\*(C`MacPack\*(C'\fR. You can pass further code mappings as hash references.
.SS "\s-1XS\s0 Functions"
.IX Subsection "XS Functions"
.IP "Debugger [ \s-1MSG\s0 ]" 4
.IX Item "Debugger [ MSG ]"
Break into MacsBug. Don't use this if you don't know what MacsBug is.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mac::Types5.18.3pm                           0100644 0001750 0001750 00000013602 12566241375 023533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Types 3"
.TH Types 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Types \- Macintosh Toolbox Types and conversions.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Functions"
.IX Subsection "Functions"
.IP "MacPack [ \s-1CONVERTERS ...\s0] \s-1CODE, DATA ...\s0" 4
.IX Item "MacPack [ CONVERTERS ...] CODE, DATA ..."
Convert a perl value into a Mac toolbox type. Predefined codes are:
.RS 4
.IP "\s-1TEXT \s0" 4
.IX Item "TEXT "
Text (an identity operation).
.IP "enum" 4
.IX Item "enum"
.PD 0
.IP "type" 4
.IX Item "type"
.IP "keyw" 4
.IX Item "keyw"
.PD
A 4\-byte string.
.IP "bool" 4
.IX Item "bool"
A boolean.
.IP "shor" 4
.IX Item "shor"
A short integer.
.IP "long" 4
.IX Item "long"
A long integer.
.IP "sing" 4
.IX Item "sing"
A single precision float.
.IP "doub" 4
.IX Item "doub"
A double precision float.
.IP "magn" 4
.IX Item "magn"
An unsigned long.
.IP "qdrt" 4
.IX Item "qdrt"
A QuickDraw \f(CW\*(C`Rect\*(C'\fR.
.IP "'\s-1STR \s0'" 4
.IX Item "'STR '"
A pascal style string.
.IP "'STR#'" 4
.IX Item "'STR#'"
A string list.
.IP "'fss '" 4
.IX Item "'fss '"
A file specification record.
.RE
.RS 4
.Sp
You can pass further code mappings as hash references.
.RE
.IP "MacUnpack [ \s-1CONVERTERS ...\s0] \s-1CODE, DATA\s0" 4
.IX Item "MacUnpack [ CONVERTERS ...] CODE, DATA"
Convert a Mac toolbox type into a perl value. Predefined codes are as for 
\&\f(CW\*(C`MacPack\*(C'\fR. You can pass further code mappings as hash references.
.SS "\s-1XS\s0 Functions"
.IX Subsection "XS Functions"
.IP "Debugger [ \s-1MSG \s0]" 4
.IX Item "Debugger [ MSG ]"
Break into MacsBug. Don't use this if you don't know what MacsBug is.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/MacPerl.3pm                                  0100644 0001750 0001750 00000027750 12566241354 022637  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MacPerl 3"
.TH MacPerl 3 "2009-09-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MacPerl \- Built\-in Macintosh specific routines.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
\&
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
\&    MacPerl::GetFileInfo(yin);
\&
\&    MacPerl::Quit(kMacPerlAlwaysQuit);
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "MacPerl::Answer(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Answer(PROMPT)"
.PD 0
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1)"
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1,BUTTON2\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2)"
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1,BUTTON2,BUTTON3\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2,BUTTON3)"
.PD
Presents to the user a dialog with 1, 2, or 3 buttons.
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
.Ve
.Sp
always returns 0.
.Sp
.Vb 1
\&    MacPerl::Answer("I refuse");
.Ve
.Sp
is equivalent to \f(CW\*(C`MacPerl\*(AqAnswer("I refuse", "OK");\*(C'\fR
.Sp
.Vb 1
\&    MacPerl::Answer("Delete hard disk ?", "OK", "Cancel");
.Ve
.Sp
returns 1 for \s-1OK, 0\s0 for Cancel
.Sp
.Vb 1
\&    MacPerl::Answer("Overwrite existig file", "Overwrite", "Skip", "Cancel");
.Ve
.Sp
returns 2 for Overwrite, 1 for Skip, 0 for Cancel
.IP "MacPerl::Ask(\s-1PROMPT, DEFAULT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT, DEFAULT)"
.PD 0
.IP "MacPerl::Ask(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT)"
.PD
Asks the user for a string. A default value may be given. Returns
undef if the dialog is cancelled.
.Sp
Example:
.Sp
.Vb 2
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    $name  = MacPerl::Ask("Enter your first name", "Bruce");
.Ve
.Sp
Useful for Australian database applications
.IP "MacPerl::Pick(\s-1PROMPT, VALUES\s0)" 8
.IX Item "MacPerl::Pick(PROMPT, VALUES)"
Asks the user to pick a choice from a list. \s-1VALUES\s0 is a list of choices. 
Returns undef if the dialog is cancelled.
.Sp
Examples:
.Sp
.Vb 1
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
.Ve
.IP "MacPerl::SetFileInfo(\s-1CREATOR,TYPE,FILE...\s0)" 8
.IX Item "MacPerl::SetFileInfo(CREATOR,TYPE,FILE...)"
Changes the file types and creators of the file(s).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
.Ve
.Sp
Turn yin and yang into \s-1MPW\s0 text files
.IP "MacPerl::GetFileInfo(\s-1FILE\s0)" 8
.IX Item "MacPerl::GetFileInfo(FILE)"
In scalar context, returns the file type. In array context, returns (creator,type).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::GetFileInfo(yin);
.Ve
.Sp
Returns \*(L"\s-1TEXT\*(R"\s0 or (\*(L"\s-1MPS \*(R", \*(L"TEXT\*(R"\s0).
.IP "MacPerl::DoAppleScript(\s-1SCRIPT\s0)" 8
.IX Item "MacPerl::DoAppleScript(SCRIPT)"
Execute an AppleScript script.  Returns the text of the script result.
Script error strings are returned in \f(CW$@\fR.
.Sp
Example:
.Sp
.Vb 7
\&        my $text = MacPerl::DoAppleScript(<<END_SCRIPT) or die $@;
\&        tell application "BBEdit"
\&                make new Window
\&                copy "Inserting text the hard way." to character 1 of front Window
\&                get (characters 1 through 9 of front Window) as text
\&        end tell
\&        END_SCRIPT
.Ve
.Sp
\&\fBNote\fR: calling DoAppleScript to tell MacPerl to do something via
AppleScript may yield unpredictable results, especially when waiting
on MacPerl to reply, such as when stringing multiple events together,
or expecting data to be returned.  Try wrapping the \*(L"tell\*(R" block in
\&\*(L"ignoring application responses\*(R" / \*(L"end ignoring\*(R" if necessary.
.IP "MacPerl::Reply(\s-1ANSWER\s0)" 8
.IX Item "MacPerl::Reply(ANSWER)"
Reply to current DoScript request. Useful if you are calling Perl 
scripts from other applications.
.IP "MacPerl::Quit(\s-1LEVEL\s0)" 8
.IX Item "MacPerl::Quit(LEVEL)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
If \s-1LEVEL\s0 is 0, don't quit after ending the script. If 1, quit if 
running under a runtime version, if 2, always quit. If \s-1LEVEL\s0 is 3,
quit if this was the first script to be run since starting MacPerl.
.IP "MacPerl::LoadExternals(\s-1LIBFILE\s0)" 8
.IX Item "MacPerl::LoadExternals(LIBFILE)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Load \s-1XCMD\s0 and \s-1XFCN\s0 extensions contained in file \s-1LIBFILE,\s0 which is searched
along the same path as it would be for a require. The extensions are made
accessible in the current package, unless they containing an explicit package
name.
.IP "MacPerl::FAccess(\s-1FILE, CMD, ARGS\s0)" 8
.IX Item "MacPerl::FAccess(FILE, CMD, ARGS)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
When called from the tool, manipulate various information of files. To 
get the command constants, it's convenient to require \*(L"FAccess.ph\*(R".
.RS 8
.ie n .IP "$TAB = MacPerl::FAccess(\s-1FILE, F_GTABINFO\s0)" 8
.el .IP "\f(CW$TAB\fR = MacPerl::FAccess(\s-1FILE, F_GTABINFO\s0)" 8
.IX Item "$TAB = MacPerl::FAccess(FILE, F_GTABINFO)"
.PD 0
.IP "MacPerl::FAccess(\s-1FILE, F_STABINFO, TAB\s0)" 8
.IX Item "MacPerl::FAccess(FILE, F_STABINFO, TAB)"
.PD
Manipulate tabulator setting (in spaces per tab).
.ie n .IP "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.el .IP "($FONTNAME, \f(CW$FONTSIZE\fR) = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.IX Item "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(FILE, F_GFONTINFO)"
.PD 0
.ie n .IP "$FONTNUM = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.el .IP "\f(CW$FONTNUM\fR = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.IX Item "$FONTNUM = MacPerl::FAccess(FILE, F_GFONTINFO)"
.IP "MacPerl::FAccess(\s-1FILE, F_SFONTINFO, FONT\s0 [, \s-1SIZE\s0])" 8
.IX Item "MacPerl::FAccess(FILE, F_SFONTINFO, FONT [, SIZE])"
.PD
Manipulate font and size information. Both font names and font numbers
are accepted for F_SFONTINFO; F_GFONTINFO returns a font name in an
array context, a font number in a scalar context.
.ie n .IP "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.el .IP "($STARTSEL, \f(CW$ENDSEL\fR, \f(CW$DISPLAYTOP\fR) = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.IX Item "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(FILE, F_GSELINFO)"
.PD 0
.ie n .IP "$STARTSEL = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.el .IP "\f(CW$STARTSEL\fR = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.IX Item "$STARTSEL = MacPerl::FAccess(FILE, F_GSELINFO)"
.ie n .IP "MacPerl::FAccess(\s-1FILE, F_SSELINFO, $STARTSEL, $ENDSEL\s0 [, $DISPLAYTOP])" 8
.el .IP "MacPerl::FAccess(\s-1FILE, F_SSELINFO, \f(CW$STARTSEL\fR, \f(CW$ENDSEL\fR\s0 [, \f(CW$DISPLAYTOP\fR])" 8
.IX Item "MacPerl::FAccess(FILE, F_SSELINFO, $STARTSEL, $ENDSEL [, $DISPLAYTOP])"
.PD
Manipulate the \s-1MPW\s0 selection of a file.
.ie n .IP "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item $TOP = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item MacPerl::FAccess(\s-1FILE, F_SWININFO, LEFT, TOP\s0 [, \s-1RIGHT, BOTTOM\s0])" 8
.el .IP "($LEFT, \f(CW$TOP\fR, \f(CW$RIGHT\fR, \f(CW$BOTTOM\fR) = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item \f(CW$TOP\fR = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item MacPerl::FAccess(\s-1FILE, F_SWININFO, LEFT, TOP\s0 [, \s-1RIGHT, BOTTOM\s0])" 8
.IX Item "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(FILE, F_GWININFO) =item $TOP = MacPerl::FAccess(FILE, F_GWININFO) =item MacPerl::FAccess(FILE, F_SWININFO, LEFT, TOP [, RIGHT, BOTTOM])"
Manipulate the window position.
.RE
.RS 8
.RE
.IP "MacPerl::MakeFSSpec(\s-1PATH\s0)" 8
.IX Item "MacPerl::MakeFSSpec(PATH)"
This command encodes a path name into an encoding (volume #, directory #,
File name) which is guaranteed to be unique for every file. Don't store
this encoding between runs of MacPerl!
.IP "MacPerl::MakePath(\s-1FSSPEC\s0)" 8
.IX Item "MacPerl::MakePath(FSSPEC)"
The inverse of \fIMacPerl::MakeFSSpec()\fR: turn an encoding into a path name.
.IP "\fIMacPerl::Volumes()\fR" 8
.IX Item "MacPerl::Volumes()"
In scalar context, return the \s-1FSSPEC\s0 of the startup volume. In list context, 
return FSSPECs of all volumes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
macperl
                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/MacPerl5.16.3pm                              0100644 0001750 0001750 00000027562 12566241354 023152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MacPerl 3"
.TH MacPerl 3 "2009-09-07" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MacPerl \- Built\-in Macintosh specific routines.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
\&
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
\&    MacPerl::GetFileInfo(yin);
\&
\&    MacPerl::Quit(kMacPerlAlwaysQuit);
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "MacPerl::Answer(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Answer(PROMPT)"
.PD 0
.IP "MacPerl::Answer(\s-1PROMPT\s0,BUTTON1)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1)"
.IP "MacPerl::Answer(\s-1PROMPT\s0,BUTTON1,BUTTON2)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2)"
.IP "MacPerl::Answer(\s-1PROMPT\s0,BUTTON1,BUTTON2,BUTTON3)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2,BUTTON3)"
.PD
Presents to the user a dialog with 1, 2, or 3 buttons.
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
.Ve
.Sp
always returns 0.
.Sp
.Vb 1
\&    MacPerl::Answer("I refuse");
.Ve
.Sp
is equivalent to \f(CW\*(C`MacPerl\*(AqAnswer("I refuse", "OK");\*(C'\fR
.Sp
.Vb 1
\&    MacPerl::Answer("Delete hard disk ?", "OK", "Cancel");
.Ve
.Sp
returns 1 for \s-1OK\s0, 0 for Cancel
.Sp
.Vb 1
\&    MacPerl::Answer("Overwrite existig file", "Overwrite", "Skip", "Cancel");
.Ve
.Sp
returns 2 for Overwrite, 1 for Skip, 0 for Cancel
.IP "MacPerl::Ask(\s-1PROMPT\s0, \s-1DEFAULT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT, DEFAULT)"
.PD 0
.IP "MacPerl::Ask(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT)"
.PD
Asks the user for a string. A default value may be given. Returns
undef if the dialog is cancelled.
.Sp
Example:
.Sp
.Vb 2
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    $name  = MacPerl::Ask("Enter your first name", "Bruce");
.Ve
.Sp
Useful for Australian database applications
.IP "MacPerl::Pick(\s-1PROMPT\s0, \s-1VALUES\s0)" 8
.IX Item "MacPerl::Pick(PROMPT, VALUES)"
Asks the user to pick a choice from a list. \s-1VALUES\s0 is a list of choices. 
Returns undef if the dialog is cancelled.
.Sp
Examples:
.Sp
.Vb 1
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
.Ve
.IP "MacPerl::SetFileInfo(\s-1CREATOR\s0,TYPE,FILE...)" 8
.IX Item "MacPerl::SetFileInfo(CREATOR,TYPE,FILE...)"
Changes the file types and creators of the file(s).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
.Ve
.Sp
Turn yin and yang into \s-1MPW\s0 text files
.IP "MacPerl::GetFileInfo(\s-1FILE\s0)" 8
.IX Item "MacPerl::GetFileInfo(FILE)"
In scalar context, returns the file type. In array context, returns (creator,type).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::GetFileInfo(yin);
.Ve
.Sp
Returns \*(L"\s-1TEXT\s0\*(R" or (\*(L"\s-1MPS\s0 \*(R", \*(L"\s-1TEXT\s0\*(R").
.IP "MacPerl::DoAppleScript(\s-1SCRIPT\s0)" 8
.IX Item "MacPerl::DoAppleScript(SCRIPT)"
Execute an AppleScript script.  Returns the text of the script result.
Script error strings are returned in \f(CW$@\fR.
.Sp
Example:
.Sp
.Vb 7
\&        my $text = MacPerl::DoAppleScript(<<END_SCRIPT) or die $@;
\&        tell application "BBEdit"
\&                make new Window
\&                copy "Inserting text the hard way." to character 1 of front Window
\&                get (characters 1 through 9 of front Window) as text
\&        end tell
\&        END_SCRIPT
.Ve
.Sp
\&\fBNote\fR: calling DoAppleScript to tell MacPerl to do something via
AppleScript may yield unpredictable results, especially when waiting
on MacPerl to reply, such as when stringing multiple events together,
or expecting data to be returned.  Try wrapping the \*(L"tell\*(R" block in
\&\*(L"ignoring application responses\*(R" / \*(L"end ignoring\*(R" if necessary.
.IP "MacPerl::Reply(\s-1ANSWER\s0)" 8
.IX Item "MacPerl::Reply(ANSWER)"
Reply to current DoScript request. Useful if you are calling Perl 
scripts from other applications.
.IP "MacPerl::Quit(\s-1LEVEL\s0)" 8
.IX Item "MacPerl::Quit(LEVEL)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
If \s-1LEVEL\s0 is 0, don't quit after ending the script. If 1, quit if 
running under a runtime version, if 2, always quit. If \s-1LEVEL\s0 is 3,
quit if this was the first script to be run since starting MacPerl.
.IP "MacPerl::LoadExternals(\s-1LIBFILE\s0)" 8
.IX Item "MacPerl::LoadExternals(LIBFILE)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Load \s-1XCMD\s0 and \s-1XFCN\s0 extensions contained in file \s-1LIBFILE\s0, which is searched
along the same path as it would be for a require. The extensions are made
accessible in the current package, unless they containing an explicit package
name.
.IP "MacPerl::FAccess(\s-1FILE\s0, \s-1CMD\s0, \s-1ARGS\s0)" 8
.IX Item "MacPerl::FAccess(FILE, CMD, ARGS)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
When called from the tool, manipulate various information of files. To 
get the command constants, it's convenient to require \*(L"FAccess.ph\*(R".
.RS 8
.ie n .IP "$TAB = MacPerl::FAccess(\s-1FILE\s0, F_GTABINFO)" 8
.el .IP "\f(CW$TAB\fR = MacPerl::FAccess(\s-1FILE\s0, F_GTABINFO)" 8
.IX Item "$TAB = MacPerl::FAccess(FILE, F_GTABINFO)"
.PD 0
.IP "MacPerl::FAccess(\s-1FILE\s0, F_STABINFO, \s-1TAB\s0)" 8
.IX Item "MacPerl::FAccess(FILE, F_STABINFO, TAB)"
.PD
Manipulate tabulator setting (in spaces per tab).
.ie n .IP "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(\s-1FILE\s0, F_GFONTINFO)" 8
.el .IP "($FONTNAME, \f(CW$FONTSIZE\fR) = MacPerl::FAccess(\s-1FILE\s0, F_GFONTINFO)" 8
.IX Item "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(FILE, F_GFONTINFO)"
.PD 0
.ie n .IP "$FONTNUM = MacPerl::FAccess(\s-1FILE\s0, F_GFONTINFO)" 8
.el .IP "\f(CW$FONTNUM\fR = MacPerl::FAccess(\s-1FILE\s0, F_GFONTINFO)" 8
.IX Item "$FONTNUM = MacPerl::FAccess(FILE, F_GFONTINFO)"
.IP "MacPerl::FAccess(\s-1FILE\s0, F_SFONTINFO, \s-1FONT\s0 [, \s-1SIZE\s0])" 8
.IX Item "MacPerl::FAccess(FILE, F_SFONTINFO, FONT [, SIZE])"
.PD
Manipulate font and size information. Both font names and font numbers
are accepted for F_SFONTINFO; F_GFONTINFO returns a font name in an
array context, a font number in a scalar context.
.ie n .IP "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(\s-1FILE\s0, F_GSELINFO)" 8
.el .IP "($STARTSEL, \f(CW$ENDSEL\fR, \f(CW$DISPLAYTOP\fR) = MacPerl::FAccess(\s-1FILE\s0, F_GSELINFO)" 8
.IX Item "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(FILE, F_GSELINFO)"
.PD 0
.ie n .IP "$STARTSEL = MacPerl::FAccess(\s-1FILE\s0, F_GSELINFO)" 8
.el .IP "\f(CW$STARTSEL\fR = MacPerl::FAccess(\s-1FILE\s0, F_GSELINFO)" 8
.IX Item "$STARTSEL = MacPerl::FAccess(FILE, F_GSELINFO)"
.ie n .IP "MacPerl::FAccess(\s-1FILE\s0, F_SSELINFO, $STARTSEL, $ENDSEL [, $DISPLAYTOP])" 8
.el .IP "MacPerl::FAccess(\s-1FILE\s0, F_SSELINFO, \f(CW$STARTSEL\fR, \f(CW$ENDSEL\fR [, \f(CW$DISPLAYTOP\fR])" 8
.IX Item "MacPerl::FAccess(FILE, F_SSELINFO, $STARTSEL, $ENDSEL [, $DISPLAYTOP])"
.PD
Manipulate the \s-1MPW\s0 selection of a file.
.ie n .IP "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(\s-1FILE\s0, F_GWININFO) =item $TOP = MacPerl::FAccess(\s-1FILE\s0, F_GWININFO) =item MacPerl::FAccess(\s-1FILE\s0, F_SWININFO, \s-1LEFT\s0, \s-1TOP\s0 [, \s-1RIGHT\s0, \s-1BOTTOM\s0])" 8
.el .IP "($LEFT, \f(CW$TOP\fR, \f(CW$RIGHT\fR, \f(CW$BOTTOM\fR) = MacPerl::FAccess(\s-1FILE\s0, F_GWININFO) =item \f(CW$TOP\fR = MacPerl::FAccess(\s-1FILE\s0, F_GWININFO) =item MacPerl::FAccess(\s-1FILE\s0, F_SWININFO, \s-1LEFT\s0, \s-1TOP\s0 [, \s-1RIGHT\s0, \s-1BOTTOM\s0])" 8
.IX Item "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(FILE, F_GWININFO) =item $TOP = MacPerl::FAccess(FILE, F_GWININFO) =item MacPerl::FAccess(FILE, F_SWININFO, LEFT, TOP [, RIGHT, BOTTOM])"
Manipulate the window position.
.RE
.RS 8
.RE
.IP "MacPerl::MakeFSSpec(\s-1PATH\s0)" 8
.IX Item "MacPerl::MakeFSSpec(PATH)"
This command encodes a path name into an encoding (volume #, directory #,
File name) which is guaranteed to be unique for every file. Don't store
this encoding between runs of MacPerl!
.IP "MacPerl::MakePath(\s-1FSSPEC\s0)" 8
.IX Item "MacPerl::MakePath(FSSPEC)"
The inverse of \fIMacPerl::MakeFSSpec()\fR: turn an encoding into a path name.
.IP "\fIMacPerl::Volumes()\fR" 8
.IX Item "MacPerl::Volumes()"
In scalar context, return the \s-1FSSPEC\s0 of the startup volume. In list context, 
return FSSPECs of all volumes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
macperl
                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/MacPerl5.18.3pm                              0100644 0001750 0001750 00000027750 12566241354 023153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MacPerl 3"
.TH MacPerl 3 "2009-09-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MacPerl \- Built\-in Macintosh specific routines.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
\&
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
\&    MacPerl::GetFileInfo(yin);
\&
\&    MacPerl::Quit(kMacPerlAlwaysQuit);
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "MacPerl::Answer(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Answer(PROMPT)"
.PD 0
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1)"
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1,BUTTON2\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2)"
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1,BUTTON2,BUTTON3\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2,BUTTON3)"
.PD
Presents to the user a dialog with 1, 2, or 3 buttons.
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
.Ve
.Sp
always returns 0.
.Sp
.Vb 1
\&    MacPerl::Answer("I refuse");
.Ve
.Sp
is equivalent to \f(CW\*(C`MacPerl\*(AqAnswer("I refuse", "OK");\*(C'\fR
.Sp
.Vb 1
\&    MacPerl::Answer("Delete hard disk ?", "OK", "Cancel");
.Ve
.Sp
returns 1 for \s-1OK, 0\s0 for Cancel
.Sp
.Vb 1
\&    MacPerl::Answer("Overwrite existig file", "Overwrite", "Skip", "Cancel");
.Ve
.Sp
returns 2 for Overwrite, 1 for Skip, 0 for Cancel
.IP "MacPerl::Ask(\s-1PROMPT, DEFAULT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT, DEFAULT)"
.PD 0
.IP "MacPerl::Ask(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT)"
.PD
Asks the user for a string. A default value may be given. Returns
undef if the dialog is cancelled.
.Sp
Example:
.Sp
.Vb 2
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    $name  = MacPerl::Ask("Enter your first name", "Bruce");
.Ve
.Sp
Useful for Australian database applications
.IP "MacPerl::Pick(\s-1PROMPT, VALUES\s0)" 8
.IX Item "MacPerl::Pick(PROMPT, VALUES)"
Asks the user to pick a choice from a list. \s-1VALUES\s0 is a list of choices. 
Returns undef if the dialog is cancelled.
.Sp
Examples:
.Sp
.Vb 1
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
.Ve
.IP "MacPerl::SetFileInfo(\s-1CREATOR,TYPE,FILE...\s0)" 8
.IX Item "MacPerl::SetFileInfo(CREATOR,TYPE,FILE...)"
Changes the file types and creators of the file(s).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
.Ve
.Sp
Turn yin and yang into \s-1MPW\s0 text files
.IP "MacPerl::GetFileInfo(\s-1FILE\s0)" 8
.IX Item "MacPerl::GetFileInfo(FILE)"
In scalar context, returns the file type. In array context, returns (creator,type).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::GetFileInfo(yin);
.Ve
.Sp
Returns \*(L"\s-1TEXT\*(R"\s0 or (\*(L"\s-1MPS \*(R", \*(L"TEXT\*(R"\s0).
.IP "MacPerl::DoAppleScript(\s-1SCRIPT\s0)" 8
.IX Item "MacPerl::DoAppleScript(SCRIPT)"
Execute an AppleScript script.  Returns the text of the script result.
Script error strings are returned in \f(CW$@\fR.
.Sp
Example:
.Sp
.Vb 7
\&        my $text = MacPerl::DoAppleScript(<<END_SCRIPT) or die $@;
\&        tell application "BBEdit"
\&                make new Window
\&                copy "Inserting text the hard way." to character 1 of front Window
\&                get (characters 1 through 9 of front Window) as text
\&        end tell
\&        END_SCRIPT
.Ve
.Sp
\&\fBNote\fR: calling DoAppleScript to tell MacPerl to do something via
AppleScript may yield unpredictable results, especially when waiting
on MacPerl to reply, such as when stringing multiple events together,
or expecting data to be returned.  Try wrapping the \*(L"tell\*(R" block in
\&\*(L"ignoring application responses\*(R" / \*(L"end ignoring\*(R" if necessary.
.IP "MacPerl::Reply(\s-1ANSWER\s0)" 8
.IX Item "MacPerl::Reply(ANSWER)"
Reply to current DoScript request. Useful if you are calling Perl 
scripts from other applications.
.IP "MacPerl::Quit(\s-1LEVEL\s0)" 8
.IX Item "MacPerl::Quit(LEVEL)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
If \s-1LEVEL\s0 is 0, don't quit after ending the script. If 1, quit if 
running under a runtime version, if 2, always quit. If \s-1LEVEL\s0 is 3,
quit if this was the first script to be run since starting MacPerl.
.IP "MacPerl::LoadExternals(\s-1LIBFILE\s0)" 8
.IX Item "MacPerl::LoadExternals(LIBFILE)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Load \s-1XCMD\s0 and \s-1XFCN\s0 extensions contained in file \s-1LIBFILE,\s0 which is searched
along the same path as it would be for a require. The extensions are made
accessible in the current package, unless they containing an explicit package
name.
.IP "MacPerl::FAccess(\s-1FILE, CMD, ARGS\s0)" 8
.IX Item "MacPerl::FAccess(FILE, CMD, ARGS)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
When called from the tool, manipulate various information of files. To 
get the command constants, it's convenient to require \*(L"FAccess.ph\*(R".
.RS 8
.ie n .IP "$TAB = MacPerl::FAccess(\s-1FILE, F_GTABINFO\s0)" 8
.el .IP "\f(CW$TAB\fR = MacPerl::FAccess(\s-1FILE, F_GTABINFO\s0)" 8
.IX Item "$TAB = MacPerl::FAccess(FILE, F_GTABINFO)"
.PD 0
.IP "MacPerl::FAccess(\s-1FILE, F_STABINFO, TAB\s0)" 8
.IX Item "MacPerl::FAccess(FILE, F_STABINFO, TAB)"
.PD
Manipulate tabulator setting (in spaces per tab).
.ie n .IP "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.el .IP "($FONTNAME, \f(CW$FONTSIZE\fR) = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.IX Item "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(FILE, F_GFONTINFO)"
.PD 0
.ie n .IP "$FONTNUM = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.el .IP "\f(CW$FONTNUM\fR = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.IX Item "$FONTNUM = MacPerl::FAccess(FILE, F_GFONTINFO)"
.IP "MacPerl::FAccess(\s-1FILE, F_SFONTINFO, FONT\s0 [, \s-1SIZE\s0])" 8
.IX Item "MacPerl::FAccess(FILE, F_SFONTINFO, FONT [, SIZE])"
.PD
Manipulate font and size information. Both font names and font numbers
are accepted for F_SFONTINFO; F_GFONTINFO returns a font name in an
array context, a font number in a scalar context.
.ie n .IP "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.el .IP "($STARTSEL, \f(CW$ENDSEL\fR, \f(CW$DISPLAYTOP\fR) = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.IX Item "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(FILE, F_GSELINFO)"
.PD 0
.ie n .IP "$STARTSEL = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.el .IP "\f(CW$STARTSEL\fR = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.IX Item "$STARTSEL = MacPerl::FAccess(FILE, F_GSELINFO)"
.ie n .IP "MacPerl::FAccess(\s-1FILE, F_SSELINFO, $STARTSEL, $ENDSEL\s0 [, $DISPLAYTOP])" 8
.el .IP "MacPerl::FAccess(\s-1FILE, F_SSELINFO, \f(CW$STARTSEL\fR, \f(CW$ENDSEL\fR\s0 [, \f(CW$DISPLAYTOP\fR])" 8
.IX Item "MacPerl::FAccess(FILE, F_SSELINFO, $STARTSEL, $ENDSEL [, $DISPLAYTOP])"
.PD
Manipulate the \s-1MPW\s0 selection of a file.
.ie n .IP "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item $TOP = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item MacPerl::FAccess(\s-1FILE, F_SWININFO, LEFT, TOP\s0 [, \s-1RIGHT, BOTTOM\s0])" 8
.el .IP "($LEFT, \f(CW$TOP\fR, \f(CW$RIGHT\fR, \f(CW$BOTTOM\fR) = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item \f(CW$TOP\fR = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item MacPerl::FAccess(\s-1FILE, F_SWININFO, LEFT, TOP\s0 [, \s-1RIGHT, BOTTOM\s0])" 8
.IX Item "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(FILE, F_GWININFO) =item $TOP = MacPerl::FAccess(FILE, F_GWININFO) =item MacPerl::FAccess(FILE, F_SWININFO, LEFT, TOP [, RIGHT, BOTTOM])"
Manipulate the window position.
.RE
.RS 8
.RE
.IP "MacPerl::MakeFSSpec(\s-1PATH\s0)" 8
.IX Item "MacPerl::MakeFSSpec(PATH)"
This command encodes a path name into an encoding (volume #, directory #,
File name) which is guaranteed to be unique for every file. Don't store
this encoding between runs of MacPerl!
.IP "MacPerl::MakePath(\s-1FSSPEC\s0)" 8
.IX Item "MacPerl::MakePath(FSSPEC)"
The inverse of \fIMacPerl::MakeFSSpec()\fR: turn an encoding into a path name.
.IP "\fIMacPerl::Volumes()\fR" 8
.IX Item "MacPerl::Volumes()"
In scalar context, return the \s-1FSSPEC\s0 of the startup volume. In list context, 
return FSSPECs of all volumes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
macperl
                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Address.3pm                            0100644 0001750 0001750 00000021176 12566241445 023665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Address 3"
.TH Mail::Address 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Address \- Parse mail addresses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Mail::Address;
\& my @addrs = Mail::Address\->parse($line);
\&
\& foreach $addr (@addrs) {
\&     print $addr\->format,"\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Address\*(C'\fR extracts and manipulates email addresses from a message
header.  It cannot be used to extract addresses from some random text.
You can use this module to create \s-1RFC822\s0 compliant fields.
.PP
Although \f(CW\*(C`Mail::Address\*(C'\fR is a very popular subject for books, and is
used in many applications, it does a very poor job on the more complex
message fields.  It does only handle simple address formats (which
covers about 95% of what can be found). Problems are with
.IP "\(bu" 4
no support for address groups, even not with the semi-colon as
separator between addresses;
.IP "\(bu" 4
limited support for escapes in phrases and comments.  There are
cases where it can get wrong; and
.IP "\(bu" 4
you have to take care of most escaping when you create an address yourself:
\&\f(CW\*(C`Mail::Address\*(C'\fR does not do that for you.
.PP
Often requests are made to the maintainers of this code improve this
situation, but this is not a good idea, where it will break zillions
of existing applications.  If you wish for a fully \s-1RFC2822\s0 compliant
implementation you may take a look at Mail::Message::Field::Full,
part of MailBox.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Address\->\fBnew\fR(\s-1PHRASE, ADDRESS,\s0 [ \s-1COMMENT \s0])" 4
.IX Item "Mail::Address->new(PHRASE, ADDRESS, [ COMMENT ])"
Create a new \f(CW\*(C`Mail::Address\*(C'\fR object which represents an address with the
elements given. In a message these 3 elements would be seen like:
.Sp
.Vb 2
\& PHRASE <ADDRESS> (COMMENT)
\& ADDRESS (COMMENT)
.Ve
.Sp
example:
.Sp
.Vb 1
\& Mail::Address\->new("Perl5 Porters", "perl5\-porters@africa.nicoh.com");
.Ve
.ie n .IP "$obj\->\fBparse\fR(\s-1LINE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR(\s-1LINE\s0)" 4
.IX Item "$obj->parse(LINE)"
Parse the given line a return a list of extracted \f(CW\*(C`Mail::Address\*(C'\fR objects.
The line would normally be one taken from a To,Cc or Bcc line in a message
.Sp
example:
.Sp
.Vb 1
\& my @addr = Mail::Address\->parse($line);
.Ve
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBaddress\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddress\fR()" 4
.IX Item "$obj->address()"
Return the address part of the object.
.ie n .IP "$obj\->\fBcomment\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcomment\fR()" 4
.IX Item "$obj->comment()"
Return the comment part of the object
.ie n .IP "$obj\->\fBformat\fR([ADDRESSes])" 4
.el .IP "\f(CW$obj\fR\->\fBformat\fR([ADDRESSes])" 4
.IX Item "$obj->format([ADDRESSes])"
Return a string representing the address in a suitable form to be placed
on a \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, or \f(CW\*(C`Bcc\*(C'\fR line of a message.  This method is called on
the first \s-1ADDRESS\s0 to be used; other specified ADDRESSes will be appended,
separated with commas.
.ie n .IP "$obj\->\fBphrase\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBphrase\fR()" 4
.IX Item "$obj->phrase()"
Return the phrase part of the object.
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBhost\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhost\fR()" 4
.IX Item "$obj->host()"
Return the address excluding the user id and '@'
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Using the information contained within the object attempt to identify what
the person or groups name is.
.Sp
\&\fBNote:\fR This function tries to be smart with the \*(L"phrase\*(R" of the
email address, which is probably a very bad idea.  Consider to use
\&\fIphrase()\fR itself.
.ie n .IP "$obj\->\fBuser\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBuser\fR()" 4
.IX Item "$obj->user()"
Return the address excluding the '@' and the mail domain
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Address5.16.3pm                        0100644 0001750 0001750 00000020406 12566241445 024172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Address 3"
.TH Mail::Address 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Address \- Parse mail addresses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Mail::Address;
\& my @addrs = Mail::Address\->parse($line);
\&
\& foreach $addr (@addrs) {
\&     print $addr\->format,"\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Address\*(C'\fR extracts and manipulates email addresses from a message
header.  It cannot be used to extract addresses from some random text.
You can use this module to create \s-1RFC822\s0 compliant fields.
.PP
Although \f(CW\*(C`Mail::Address\*(C'\fR is a very popular subject for books, and is
used in many applications, it does a very poor job on the more complex
message fields.  It does only handle simple address formats (which
covers about 95% of what can be found). Problems are with
.IP "\(bu" 4
no support for address groups, even not with the semi-colon as
separator between addresses;
.IP "\(bu" 4
limitted support for escapes in phrases and comments.  There are
cases where it can get wrong; and
.IP "\(bu" 4
you have to take care of most escaping when you create an address yourself:
\&\f(CW\*(C`Mail::Address\*(C'\fR does not do that for you.
.PP
Often requests are made to the maintainers of this code improve this
situation, but this is not a good idea, where it will break zillions
of existing applications.  If you wish for a fully \s-1RFC2822\s0 compliant
implementation you may take a look at Mail::Message::Field::Full,
part of MailBox.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Address\->\fBnew\fR(\s-1PHRASE\s0, \s-1ADDRESS\s0, [ \s-1COMMENT\s0 ])" 4
.IX Item "Mail::Address->new(PHRASE, ADDRESS, [ COMMENT ])"
Create a new \f(CW\*(C`Mail::Address\*(C'\fR object which represents an address with the
elements given. In a message these 3 elements would be seen like:
.Sp
.Vb 2
\& PHRASE <ADDRESS> (COMMENT)
\& ADDRESS (COMMENT)
.Ve
.Sp
example:
.Sp
.Vb 1
\& Mail::Address\->new("Perl5 Porters", "perl5\-porters@africa.nicoh.com");
.Ve
.ie n .IP "$obj\->\fBparse\fR(\s-1LINE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR(\s-1LINE\s0)" 4
.IX Item "$obj->parse(LINE)"
Parse the given line a return a list of extracted \f(CW\*(C`Mail::Address\*(C'\fR objects.
The line would normally be one taken from a To,Cc or Bcc line in a message
.Sp
example:
.Sp
.Vb 1
\& my @addr = Mail::Address\->parse($line);
.Ve
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBaddress\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddress\fR()" 4
.IX Item "$obj->address()"
Return the address part of the object.
.ie n .IP "$obj\->\fBcomment\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcomment\fR()" 4
.IX Item "$obj->comment()"
Return the comment part of the object
.ie n .IP "$obj\->\fBformat\fR([ADDRESSes])" 4
.el .IP "\f(CW$obj\fR\->\fBformat\fR([ADDRESSes])" 4
.IX Item "$obj->format([ADDRESSes])"
Return a string representing the address in a suitable form to be placed
on a \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, or \f(CW\*(C`Bcc\*(C'\fR line of a message.  This method is called on
the first \s-1ADDRESS\s0 to be used; other specified ADDRESSes will be appended,
separated with commas.
.ie n .IP "$obj\->\fBphrase\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBphrase\fR()" 4
.IX Item "$obj->phrase()"
Return the phrase part of the object.
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBhost\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhost\fR()" 4
.IX Item "$obj->host()"
Return the address excluding the user id and '@'
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Using the information contained within the object attempt to identify what
the person or groups name is.
.ie n .IP "$obj\->\fBuser\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBuser\fR()" 4
.IX Item "$obj->user()"
Return the address excluding the '@' and the mail domain
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Address5.18.3pm                        0100644 0001750 0001750 00000021176 12566241445 024201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Address 3"
.TH Mail::Address 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Address \- Parse mail addresses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Mail::Address;
\& my @addrs = Mail::Address\->parse($line);
\&
\& foreach $addr (@addrs) {
\&     print $addr\->format,"\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Address\*(C'\fR extracts and manipulates email addresses from a message
header.  It cannot be used to extract addresses from some random text.
You can use this module to create \s-1RFC822\s0 compliant fields.
.PP
Although \f(CW\*(C`Mail::Address\*(C'\fR is a very popular subject for books, and is
used in many applications, it does a very poor job on the more complex
message fields.  It does only handle simple address formats (which
covers about 95% of what can be found). Problems are with
.IP "\(bu" 4
no support for address groups, even not with the semi-colon as
separator between addresses;
.IP "\(bu" 4
limited support for escapes in phrases and comments.  There are
cases where it can get wrong; and
.IP "\(bu" 4
you have to take care of most escaping when you create an address yourself:
\&\f(CW\*(C`Mail::Address\*(C'\fR does not do that for you.
.PP
Often requests are made to the maintainers of this code improve this
situation, but this is not a good idea, where it will break zillions
of existing applications.  If you wish for a fully \s-1RFC2822\s0 compliant
implementation you may take a look at Mail::Message::Field::Full,
part of MailBox.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Address\->\fBnew\fR(\s-1PHRASE, ADDRESS,\s0 [ \s-1COMMENT \s0])" 4
.IX Item "Mail::Address->new(PHRASE, ADDRESS, [ COMMENT ])"
Create a new \f(CW\*(C`Mail::Address\*(C'\fR object which represents an address with the
elements given. In a message these 3 elements would be seen like:
.Sp
.Vb 2
\& PHRASE <ADDRESS> (COMMENT)
\& ADDRESS (COMMENT)
.Ve
.Sp
example:
.Sp
.Vb 1
\& Mail::Address\->new("Perl5 Porters", "perl5\-porters@africa.nicoh.com");
.Ve
.ie n .IP "$obj\->\fBparse\fR(\s-1LINE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR(\s-1LINE\s0)" 4
.IX Item "$obj->parse(LINE)"
Parse the given line a return a list of extracted \f(CW\*(C`Mail::Address\*(C'\fR objects.
The line would normally be one taken from a To,Cc or Bcc line in a message
.Sp
example:
.Sp
.Vb 1
\& my @addr = Mail::Address\->parse($line);
.Ve
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBaddress\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddress\fR()" 4
.IX Item "$obj->address()"
Return the address part of the object.
.ie n .IP "$obj\->\fBcomment\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcomment\fR()" 4
.IX Item "$obj->comment()"
Return the comment part of the object
.ie n .IP "$obj\->\fBformat\fR([ADDRESSes])" 4
.el .IP "\f(CW$obj\fR\->\fBformat\fR([ADDRESSes])" 4
.IX Item "$obj->format([ADDRESSes])"
Return a string representing the address in a suitable form to be placed
on a \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, or \f(CW\*(C`Bcc\*(C'\fR line of a message.  This method is called on
the first \s-1ADDRESS\s0 to be used; other specified ADDRESSes will be appended,
separated with commas.
.ie n .IP "$obj\->\fBphrase\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBphrase\fR()" 4
.IX Item "$obj->phrase()"
Return the phrase part of the object.
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBhost\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhost\fR()" 4
.IX Item "$obj->host()"
Return the address excluding the user id and '@'
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Using the information contained within the object attempt to identify what
the person or groups name is.
.Sp
\&\fBNote:\fR This function tries to be smart with the \*(L"phrase\*(R" of the
email address, which is probably a very bad idea.  Consider to use
\&\fIphrase()\fR itself.
.ie n .IP "$obj\->\fBuser\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBuser\fR()" 4
.IX Item "$obj->user()"
Return the address excluding the '@' and the mail domain
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Cap.3pm                                0100644 0001750 0001750 00000023133 12566241445 022776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Cap 3"
.TH Mail::Cap 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Cap \- Parse mailcap files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my $mc = new Mail::Cap;
\& $desc = $mc\->description(\*(Aqimage/gif\*(Aq);
\&
\& print "GIF desc: $desc\en";
\& $cmd = $mc\->viewCmd(\*(Aqtext/plain; charset=iso\-8859\-1\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parse mailcap files as specified in "\s-1RFC 1524 \-\-A\s0 User Agent
Configuration Mechanism For Multimedia Mail Format Information>.  In
the description below \f(CW$type\fR refers to the \s-1MIME\s0 type as specified in
the \f(CW\*(C`Content\-Type\*(C'\fR header of mail or \s-1HTTP\s0 messages.  Examples of
types are:
.PP
.Vb 3
\&  image/gif
\&  text/html
\&  text/plain; charset=iso\-8859\-1
.Ve
.PP
You could also take a look at the File::MimeInfo distribution, which
are accessing tables which are used by many applications on a system,
and therefore have succeeded the mail-cap specifications on modern
(\s-1UNIX\s0) systems.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Cap\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Cap->new(OPTIONS)"
Create and initialize a new Mail::Cap object.  If you give it an
argument it will try to parse the specified file.  Without any
arguments it will search for the mailcap file using the standard
mailcap path, or the \s-1MAILCAPS\s0 environment variable if it is defined.
.Sp
.Vb 3
\& \-Option  \-\-Default
\&  filename  undef
\&  take      \*(AqFIRST\*(Aq
.Ve
.RS 4
.IP "filename => \s-1FILENAME\s0" 2
.IX Item "filename => FILENAME"
Add the specified file to the list to standard locations.  This file
is tried first.
.IP "take => '\s-1ALL\s0'|'\s-1FIRST\s0'" 2
.IX Item "take => 'ALL'|'FIRST'"
Include all mailcap files you can find.  By default, only the first
file is parsed, however the \s-1RFC\s0 tells us to include \s-1ALL. \s0 To maintain
backwards compatibility, the default only takes the \s-1FIRST.\s0
.RE
.RS 4
.Sp
example:
.Sp
.Vb 5
\&  $mcap = new Mail::Cap;
\&  $mcap = new Mail::Cap "/mydir/mailcap";
\&  $mcap = new Mail::Cap filename => "/mydir/mailcap";
\&  $mcap = new Mail::Cap take => \*(AqALL\*(Aq;
\&  $mcap = Mail::Cap\->new(take => \*(AqALL\*(Aq);
.Ve
.RE
.SS "Run commands"
.IX Subsection "Run commands"
These methods invoke a suitable program presenting or manipulating the
media object in the specified file.  They all return \f(CW1\fR if a command
was found, and \f(CW0\fR otherwise.  You might test \f(CW$?\fR for the outcome
of the command.
.ie n .IP "$obj\->\fBcompose\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcompose\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->compose(TYPE, FILE)"
.PD 0
.ie n .IP "$obj\->\fBedit\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBedit\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->edit(TYPE, FILE)"
.ie n .IP "$obj\->\fBprint\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->print(TYPE, FILE)"
.ie n .IP "$obj\->\fBview\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBview\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->view(TYPE, FILE)"
.PD
.SS "Command creator"
.IX Subsection "Command creator"
These methods return a string that is suitable for feeding to \fIsystem()\fR
in order to invoke a suitable program presenting or manipulating the
media object in the specified file.  It will return \f(CW\*(C`undef\*(C'\fR if no
suitable specification exists.
.ie n .IP "$obj\->\fBcomposeCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcomposeCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->composeCmd(TYPE, FILE)"
.PD 0
.ie n .IP "$obj\->\fBeditCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBeditCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->editCmd(TYPE, FILE)"
.ie n .IP "$obj\->\fBprintCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprintCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->printCmd(TYPE, FILE)"
.ie n .IP "$obj\->\fBviewCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBviewCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->viewCmd(TYPE, FILE)"
.PD
.SS "Look-up definitions"
.IX Subsection "Look-up definitions"
Methods return the corresponding mailcap field for the type.
.ie n .IP "$obj\->\fBdescription\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdescription\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->description(TYPE)"
.PD 0
.ie n .IP "$obj\->\fBfield\fR(\s-1TYPE, FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBfield\fR(\s-1TYPE, FIELD\s0)" 4
.IX Item "$obj->field(TYPE, FIELD)"
.PD
Returns the specified field for the type.  Returns undef if no
specification exists.
.ie n .IP "$obj\->\fBnametemplate\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBnametemplate\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->nametemplate(TYPE)"
.PD 0
.ie n .IP "$obj\->\fBtextualnewlines\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtextualnewlines\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->textualnewlines(TYPE)"
.ie n .IP "$obj\->\fBx11_bitmap\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBx11_bitmap\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->x11_bitmap(TYPE)"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Cap5.16.3pm                            0100644 0001750 0001750 00000023007 12566241445 023310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Cap 3"
.TH Mail::Cap 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Cap \- Parse mailcap files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my $mc = new Mail::Cap;
\& $desc = $mc\->description(\*(Aqimage/gif\*(Aq);
\&
\& print "GIF desc: $desc\en";
\& $cmd = $mc\->viewCmd(\*(Aqtext/plain; charset=iso\-8859\-1\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parse mailcap files as specified in "\s-1RFC\s0 1524 \-\-A User Agent
Configuration Mechanism For Multimedia Mail Format Information>.  In
the description below \f(CW$type\fR refers to the \s-1MIME\s0 type as specified in
the \f(CW\*(C`Content\-Type\*(C'\fR header of mail or \s-1HTTP\s0 messages.  Examples of
types are:
.PP
.Vb 3
\&  image/gif
\&  text/html
\&  text/plain; charset=iso\-8859\-1
.Ve
.PP
You could also take a look at the File::MimeInfo distribution, which
are accessing tables which are used by many applications on a system,
and therefore have succeeded the mail-cap specifications on modern
(\s-1UNIX\s0) systems.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Cap\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Cap->new(OPTIONS)"
Create and initialize a new Mail::Cap object.  If you give it an
argument it will try to parse the specified file.  Without any
arguments it will search for the mailcap file using the standard
mailcap path, or the \s-1MAILCAPS\s0 environment variable if it is defined.
.Sp
.Vb 3
\& \-Option  \-\-Default
\&  filename  undef
\&  take      \*(AqFIRST\*(Aq
.Ve
.RS 4
.IP "filename => \s-1FILENAME\s0" 2
.IX Item "filename => FILENAME"
Add the specified file to the list to standard locations.  This file
is tried first.
.IP "take => '\s-1ALL\s0'|'\s-1FIRST\s0'" 2
.IX Item "take => 'ALL'|'FIRST'"
Include all mailcap files you can find.  By default, only the first
file is parsed, however the \s-1RFC\s0 tells us to include \s-1ALL\s0.  To maintain
backwards compatibility, the default only takes the \s-1FIRST\s0.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 5
\&  $mcap = new Mail::Cap;
\&  $mcap = new Mail::Cap "/mydir/mailcap";
\&  $mcap = new Mail::Cap filename => "/mydir/mailcap";
\&  $mcap = new Mail::Cap take => \*(AqALL\*(Aq;
\&  $mcap = Mail::Cap\->new(take => \*(AqALL\*(Aq);
.Ve
.RE
.SS "Run commands"
.IX Subsection "Run commands"
These methods invoke a suitable progam presenting or manipulating the
media object in the specified file.  They all return \f(CW1\fR if a command
was found, and \f(CW0\fR otherwise.  You might test \f(CW$?\fR for the outcome
of the command.
.ie n .IP "$obj\->\fBcompose\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcompose\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->compose(TYPE, FILE)"
.PD 0
.ie n .IP "$obj\->\fBedit\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBedit\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->edit(TYPE, FILE)"
.ie n .IP "$obj\->\fBprint\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->print(TYPE, FILE)"
.ie n .IP "$obj\->\fBview\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBview\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->view(TYPE, FILE)"
.PD
.SS "Command creator"
.IX Subsection "Command creator"
These methods return a string that is suitable for feeding to \fIsystem()\fR
in order to invoke a suitable progam presenting or manipulating the
media object in the specified file.  It will return \f(CW\*(C`undef\*(C'\fR if no
suitable specification exists.
.ie n .IP "$obj\->\fBcomposeCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcomposeCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->composeCmd(TYPE, FILE)"
.PD 0
.ie n .IP "$obj\->\fBeditCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBeditCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->editCmd(TYPE, FILE)"
.ie n .IP "$obj\->\fBprintCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprintCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->printCmd(TYPE, FILE)"
.ie n .IP "$obj\->\fBviewCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBviewCmd\fR(\s-1TYPE\s0, \s-1FILE\s0)" 4
.IX Item "$obj->viewCmd(TYPE, FILE)"
.PD
.SS "Look-up definitions"
.IX Subsection "Look-up definitions"
Methods return the corresponding mailcap field for the type.
.ie n .IP "$obj\->\fBdescription\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdescription\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->description(TYPE)"
.PD 0
.ie n .IP "$obj\->\fBfield\fR(\s-1TYPE\s0, \s-1FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBfield\fR(\s-1TYPE\s0, \s-1FIELD\s0)" 4
.IX Item "$obj->field(TYPE, FIELD)"
.PD
Returns the specified field for the type.  Returns undef if no
specification exsists.
.ie n .IP "$obj\->\fBnametemplate\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBnametemplate\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->nametemplate(TYPE)"
.PD 0
.ie n .IP "$obj\->\fBtextualnewlines\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtextualnewlines\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->textualnewlines(TYPE)"
.ie n .IP "$obj\->\fBx11_bitmap\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBx11_bitmap\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->x11_bitmap(TYPE)"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Cap5.18.3pm                            0100644 0001750 0001750 00000023133 12566241445 023312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Cap 3"
.TH Mail::Cap 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Cap \- Parse mailcap files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my $mc = new Mail::Cap;
\& $desc = $mc\->description(\*(Aqimage/gif\*(Aq);
\&
\& print "GIF desc: $desc\en";
\& $cmd = $mc\->viewCmd(\*(Aqtext/plain; charset=iso\-8859\-1\*(Aq, \*(Aqfile.txt\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parse mailcap files as specified in "\s-1RFC 1524 \-\-A\s0 User Agent
Configuration Mechanism For Multimedia Mail Format Information>.  In
the description below \f(CW$type\fR refers to the \s-1MIME\s0 type as specified in
the \f(CW\*(C`Content\-Type\*(C'\fR header of mail or \s-1HTTP\s0 messages.  Examples of
types are:
.PP
.Vb 3
\&  image/gif
\&  text/html
\&  text/plain; charset=iso\-8859\-1
.Ve
.PP
You could also take a look at the File::MimeInfo distribution, which
are accessing tables which are used by many applications on a system,
and therefore have succeeded the mail-cap specifications on modern
(\s-1UNIX\s0) systems.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Cap\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "Mail::Cap->new(OPTIONS)"
Create and initialize a new Mail::Cap object.  If you give it an
argument it will try to parse the specified file.  Without any
arguments it will search for the mailcap file using the standard
mailcap path, or the \s-1MAILCAPS\s0 environment variable if it is defined.
.Sp
.Vb 3
\& \-Option  \-\-Default
\&  filename  undef
\&  take      \*(AqFIRST\*(Aq
.Ve
.RS 4
.IP "filename => \s-1FILENAME\s0" 2
.IX Item "filename => FILENAME"
Add the specified file to the list to standard locations.  This file
is tried first.
.IP "take => '\s-1ALL\s0'|'\s-1FIRST\s0'" 2
.IX Item "take => 'ALL'|'FIRST'"
Include all mailcap files you can find.  By default, only the first
file is parsed, however the \s-1RFC\s0 tells us to include \s-1ALL. \s0 To maintain
backwards compatibility, the default only takes the \s-1FIRST.\s0
.RE
.RS 4
.Sp
example:
.Sp
.Vb 5
\&  $mcap = new Mail::Cap;
\&  $mcap = new Mail::Cap "/mydir/mailcap";
\&  $mcap = new Mail::Cap filename => "/mydir/mailcap";
\&  $mcap = new Mail::Cap take => \*(AqALL\*(Aq;
\&  $mcap = Mail::Cap\->new(take => \*(AqALL\*(Aq);
.Ve
.RE
.SS "Run commands"
.IX Subsection "Run commands"
These methods invoke a suitable program presenting or manipulating the
media object in the specified file.  They all return \f(CW1\fR if a command
was found, and \f(CW0\fR otherwise.  You might test \f(CW$?\fR for the outcome
of the command.
.ie n .IP "$obj\->\fBcompose\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcompose\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->compose(TYPE, FILE)"
.PD 0
.ie n .IP "$obj\->\fBedit\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBedit\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->edit(TYPE, FILE)"
.ie n .IP "$obj\->\fBprint\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->print(TYPE, FILE)"
.ie n .IP "$obj\->\fBview\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBview\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->view(TYPE, FILE)"
.PD
.SS "Command creator"
.IX Subsection "Command creator"
These methods return a string that is suitable for feeding to \fIsystem()\fR
in order to invoke a suitable program presenting or manipulating the
media object in the specified file.  It will return \f(CW\*(C`undef\*(C'\fR if no
suitable specification exists.
.ie n .IP "$obj\->\fBcomposeCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcomposeCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->composeCmd(TYPE, FILE)"
.PD 0
.ie n .IP "$obj\->\fBeditCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBeditCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->editCmd(TYPE, FILE)"
.ie n .IP "$obj\->\fBprintCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBprintCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->printCmd(TYPE, FILE)"
.ie n .IP "$obj\->\fBviewCmd\fR(\s-1TYPE, FILE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBviewCmd\fR(\s-1TYPE, FILE\s0)" 4
.IX Item "$obj->viewCmd(TYPE, FILE)"
.PD
.SS "Look-up definitions"
.IX Subsection "Look-up definitions"
Methods return the corresponding mailcap field for the type.
.ie n .IP "$obj\->\fBdescription\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdescription\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->description(TYPE)"
.PD 0
.ie n .IP "$obj\->\fBfield\fR(\s-1TYPE, FIELD\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBfield\fR(\s-1TYPE, FIELD\s0)" 4
.IX Item "$obj->field(TYPE, FIELD)"
.PD
Returns the specified field for the type.  Returns undef if no
specification exists.
.ie n .IP "$obj\->\fBnametemplate\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBnametemplate\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->nametemplate(TYPE)"
.PD 0
.ie n .IP "$obj\->\fBtextualnewlines\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtextualnewlines\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->textualnewlines(TYPE)"
.ie n .IP "$obj\->\fBx11_bitmap\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBx11_bitmap\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->x11_bitmap(TYPE)"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM.3pm                               0100644 0001750 0001750 00000014142 12566242060 023011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM 3"
.TH Mail::DKIM 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM \- Signs/verifies Internet mail with DKIM/DomainKey signatures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # verify a message
\&  use Mail::DKIM::Verifier;
\&
\&  # create a verifier object
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  # read an email from stdin, pass it into the verifier
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the result of the verify?
\&  my $result = $dkim\->result;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the various components of the \s-1DKIM\s0 and
DomainKeys message-signing and verifying standards for Internet mail.
It currently tries to implement these specifications:
.IP "\s-1RFC4871,\s0 for \s-1DKIM\s0" 4
.IX Item "RFC4871, for DKIM"
.PD 0
.IP "\s-1RFC4870,\s0 for DomainKeys" 4
.IX Item "RFC4870, for DomainKeys"
.PD
.PP
The module uses an object-oriented interface. You use one of
two different classes, depending on whether you are signing or verifying
a message. To sign, use the Mail::DKIM::Signer class. To verify, use
the Mail::DKIM::Verifier class. Simple, eh?
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Signer,
Mail::DKIM::Verifier
.PP
http://dkimproxy.sourceforge.net/
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
Problems passing `make test' seem to usually point at a faulty \s-1DNS\s0
configuration on your machine, or something weird about your OpenSSL
libraries.
.PP
The \*(L"author signing policy\*(R" component is still under construction. The
author signing policy is supposed to identify the practice of the message
author, so you could for example reject a message from an author who claims
they always sign their messages. See Mail::DKIM::Policy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007, 2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM5.16.3pm                           0100644 0001750 0001750 00000013621 12566242072 023327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM 3"
.TH Mail::DKIM 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM \- Signs/verifies Internet mail with DKIM/DomainKey signatures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # verify a message
\&  use Mail::DKIM::Verifier;
\&
\&  # create a verifier object
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  # read an email from stdin, pass it into the verifier
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the result of the verify?
\&  my $result = $dkim\->result;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the various components of the \s-1DKIM\s0 and
DomainKeys message-signing and verifying standards for Internet mail.
It currently tries to implement these specifications:
.IP "\s-1RFC4871\s0, for \s-1DKIM\s0" 4
.IX Item "RFC4871, for DKIM"
.PD 0
.IP "\s-1RFC4870\s0, for DomainKeys" 4
.IX Item "RFC4870, for DomainKeys"
.PD
.PP
The module uses an object-oriented interface. You use one of
two different classes, depending on whether you are signing or verifying
a message. To sign, use the Mail::DKIM::Signer class. To verify, use
the Mail::DKIM::Verifier class. Simple, eh?
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Signer,
Mail::DKIM::Verifier
.PP
http://dkimproxy.sourceforge.net/
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
Problems passing `make test' seem to usually point at a faulty \s-1DNS\s0
configuration on your machine, or something weird about your OpenSSL
libraries.
.PP
The \*(L"author signing policy\*(R" component is still under construction. The
author signing policy is supposed to identify the practice of the message
author, so you could for example reject a message from an author who claims
they always sign their messages. See Mail::DKIM::Policy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007, 2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM5.18.3pm                           0100644 0001750 0001750 00000014142 12566242060 023325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM 3"
.TH Mail::DKIM 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM \- Signs/verifies Internet mail with DKIM/DomainKey signatures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # verify a message
\&  use Mail::DKIM::Verifier;
\&
\&  # create a verifier object
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  # read an email from stdin, pass it into the verifier
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the result of the verify?
\&  my $result = $dkim\->result;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the various components of the \s-1DKIM\s0 and
DomainKeys message-signing and verifying standards for Internet mail.
It currently tries to implement these specifications:
.IP "\s-1RFC4871,\s0 for \s-1DKIM\s0" 4
.IX Item "RFC4871, for DKIM"
.PD 0
.IP "\s-1RFC4870,\s0 for DomainKeys" 4
.IX Item "RFC4870, for DomainKeys"
.PD
.PP
The module uses an object-oriented interface. You use one of
two different classes, depending on whether you are signing or verifying
a message. To sign, use the Mail::DKIM::Signer class. To verify, use
the Mail::DKIM::Verifier class. Simple, eh?
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Signer,
Mail::DKIM::Verifier
.PP
http://dkimproxy.sourceforge.net/
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
Problems passing `make test' seem to usually point at a faulty \s-1DNS\s0
configuration on your machine, or something weird about your OpenSSL
libraries.
.PP
The \*(L"author signing policy\*(R" component is still under construction. The
author signing policy is supposed to identify the practice of the message
author, so you could for example reject a message from an author who claims
they always sign their messages. See Mail::DKIM::Policy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007, 2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Algorithm::Base.3pm              0100644 0001750 0001750 00000017060 12566242060 026025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Algorithm::Base 3"
.TH Mail::DKIM::Algorithm::Base 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Algorithm::Base \- base class for DKIM "algorithms"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
\&
\&  # add headers
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
\&  $algorithm\->finish_header;
\&
\&  # add body
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
\&  $algorithm\->finish_body;
\&
\&  # now sign or verify...
\&  # TODO...
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
You should not create an object of this class directly. Instead, use one
of the \s-1DKIM\s0 algorithm implementation classes, such as rsa_sha1:
.PP
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd_body()\fP \- feeds part of the body into the algorithm/canonicalization"
.IX Subsection "add_body() - feeds part of the body into the algorithm/canonicalization"
.Vb 2
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
.Ve
.PP
The body should be fed one \*(L"line\*(R" at a time.
.SS "\fIadd_header()\fP \- feeds a header field into the algorithm/canonicalization"
.IX Subsection "add_header() - feeds a header field into the algorithm/canonicalization"
.Vb 1
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
.Ve
.PP
The header must start with the header field name and continue through any
folded lines (including the embedded <\s-1CRLF\s0> sequences). It terminates with
the <\s-1CRLF\s0> at the end of the header field.
.SS "\fIfinish_body()\fP \- signals the end of the message body"
.IX Subsection "finish_body() - signals the end of the message body"
.Vb 1
\&  $algorithm\->finish_body
.Ve
.PP
Call this method when all lines from the body have been submitted.
After calling this method, use \fIsign()\fR or \fIverify()\fR to get the results
from the algorithm.
.SS "\fIfinish_header()\fP \- signals the end of the header field block"
.IX Subsection "finish_header() - signals the end of the header field block"
.Vb 1
\&  $algorithm\->finish_header;
.Ve
.PP
Call this method when all the headers have been submitted.
.SS "\fIsign()\fP \- generates a signature using a private key"
.IX Subsection "sign() - generates a signature using a private key"
.Vb 1
\&  $base64 = $algorithm\->sign($private_key);
.Ve
.SS "\fIsignature()\fP \- get/set the signature worked on by this algorithm"
.IX Subsection "signature() - get/set the signature worked on by this algorithm"
.Vb 2
\&  my $old_signature = $algorithm\->signature;
\&  $algorithm\->signature($new_signature);
.Ve
.SS "\fIverify()\fP \- verifies a signature"
.IX Subsection "verify() - verifies a signature"
.Vb 1
\&  $result = $algorithm\->verify();
.Ve
.PP
Must be called after \fIfinish_body()\fR.
.PP
The result is a true/false value: true indicates the signature data
is valid, false indicates it is invalid.
.PP
For an invalid signature, details may be obtained from
\&\f(CW$algorithm\fR\->{verification_details} or $@.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Algorithm::Base5.16.3pm          0100644 0001750 0001750 00000016537 12566242072 026352  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Algorithm::Base 3"
.TH Mail::DKIM::Algorithm::Base 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Algorithm::Base \- base class for DKIM "algorithms"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
\&
\&  # add headers
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
\&  $algorithm\->finish_header;
\&
\&  # add body
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
\&  $algorithm\->finish_body;
\&
\&  # now sign or verify...
\&  # TODO...
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
You should not create an object of this class directly. Instead, use one
of the \s-1DKIM\s0 algorithm implementation classes, such as rsa_sha1:
.PP
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd_body()\fP \- feeds part of the body into the algorithm/canonicalization"
.IX Subsection "add_body() - feeds part of the body into the algorithm/canonicalization"
.Vb 2
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
.Ve
.PP
The body should be fed one \*(L"line\*(R" at a time.
.SS "\fIadd_header()\fP \- feeds a header field into the algorithm/canonicalization"
.IX Subsection "add_header() - feeds a header field into the algorithm/canonicalization"
.Vb 1
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
.Ve
.PP
The header must start with the header field name and continue through any
folded lines (including the embedded <\s-1CRLF\s0> sequences). It terminates with
the <\s-1CRLF\s0> at the end of the header field.
.SS "\fIfinish_body()\fP \- signals the end of the message body"
.IX Subsection "finish_body() - signals the end of the message body"
.Vb 1
\&  $algorithm\->finish_body
.Ve
.PP
Call this method when all lines from the body have been submitted.
After calling this method, use \fIsign()\fR or \fIverify()\fR to get the results
from the algorithm.
.SS "\fIfinish_header()\fP \- signals the end of the header field block"
.IX Subsection "finish_header() - signals the end of the header field block"
.Vb 1
\&  $algorithm\->finish_header;
.Ve
.PP
Call this method when all the headers have been submitted.
.SS "\fIsign()\fP \- generates a signature using a private key"
.IX Subsection "sign() - generates a signature using a private key"
.Vb 1
\&  $base64 = $algorithm\->sign($private_key);
.Ve
.SS "\fIsignature()\fP \- get/set the signature worked on by this algorithm"
.IX Subsection "signature() - get/set the signature worked on by this algorithm"
.Vb 2
\&  my $old_signature = $algorithm\->signature;
\&  $algorithm\->signature($new_signature);
.Ve
.SS "\fIverify()\fP \- verifies a signature"
.IX Subsection "verify() - verifies a signature"
.Vb 1
\&  $result = $algorithm\->verify();
.Ve
.PP
Must be called after \fIfinish_body()\fR.
.PP
The result is a true/false value: true indicates the signature data
is valid, false indicates it is invalid.
.PP
For an invalid signature, details may be obtained from
\&\f(CW$algorithm\fR\->{verification_details} or $@.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Algorithm::Base5.18.3pm          0100644 0001750 0001750 00000017060 12566242060 026341  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Algorithm::Base 3"
.TH Mail::DKIM::Algorithm::Base 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Algorithm::Base \- base class for DKIM "algorithms"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
\&
\&  # add headers
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
\&  $algorithm\->finish_header;
\&
\&  # add body
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
\&  $algorithm\->finish_body;
\&
\&  # now sign or verify...
\&  # TODO...
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
You should not create an object of this class directly. Instead, use one
of the \s-1DKIM\s0 algorithm implementation classes, such as rsa_sha1:
.PP
.Vb 3
\&  my $algorithm = new Mail::DKIM::Algorithm::rsa_sha1(
\&                      Signature => $dkim_signature
\&                  );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd_body()\fP \- feeds part of the body into the algorithm/canonicalization"
.IX Subsection "add_body() - feeds part of the body into the algorithm/canonicalization"
.Vb 2
\&  $algorithm\->add_body("This is the body.\e015\e012");
\&  $algorithm\->add_body("Another line of the body.\e015\e012");
.Ve
.PP
The body should be fed one \*(L"line\*(R" at a time.
.SS "\fIadd_header()\fP \- feeds a header field into the algorithm/canonicalization"
.IX Subsection "add_header() - feeds a header field into the algorithm/canonicalization"
.Vb 1
\&  $algorithm\->add_header("Subject: this is the subject\e015\e012");
.Ve
.PP
The header must start with the header field name and continue through any
folded lines (including the embedded <\s-1CRLF\s0> sequences). It terminates with
the <\s-1CRLF\s0> at the end of the header field.
.SS "\fIfinish_body()\fP \- signals the end of the message body"
.IX Subsection "finish_body() - signals the end of the message body"
.Vb 1
\&  $algorithm\->finish_body
.Ve
.PP
Call this method when all lines from the body have been submitted.
After calling this method, use \fIsign()\fR or \fIverify()\fR to get the results
from the algorithm.
.SS "\fIfinish_header()\fP \- signals the end of the header field block"
.IX Subsection "finish_header() - signals the end of the header field block"
.Vb 1
\&  $algorithm\->finish_header;
.Ve
.PP
Call this method when all the headers have been submitted.
.SS "\fIsign()\fP \- generates a signature using a private key"
.IX Subsection "sign() - generates a signature using a private key"
.Vb 1
\&  $base64 = $algorithm\->sign($private_key);
.Ve
.SS "\fIsignature()\fP \- get/set the signature worked on by this algorithm"
.IX Subsection "signature() - get/set the signature worked on by this algorithm"
.Vb 2
\&  my $old_signature = $algorithm\->signature;
\&  $algorithm\->signature($new_signature);
.Ve
.SS "\fIverify()\fP \- verifies a signature"
.IX Subsection "verify() - verifies a signature"
.Vb 1
\&  $result = $algorithm\->verify();
.Ve
.PP
Must be called after \fIfinish_body()\fR.
.PP
The result is a true/false value: true indicates the signature data
is valid, false indicates it is invalid.
.PP
For an invalid signature, details may be obtained from
\&\f(CW$algorithm\fR\->{verification_details} or $@.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::AuthorDomainPolicy.3pm           0100644 0001750 0001750 00000022672 12566242060 026677  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::AuthorDomainPolicy 3"
.TH Mail::DKIM::AuthorDomainPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::AuthorDomainPolicy \- represents an Author Domain Signing Practices (ADSP) record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Author Domain Signing Policies (\s-1ADSP\s0) record can be published by any
domain to help a receiver know what to do when it encounters an unsigned
message claiming to originate from that domain.
.PP
The record is published as a \s-1DNS TXT\s0 record at _adsp._domainkey.DOMAIN
where \s-1DOMAIN\s0 is the domain of the message's \*(L"From\*(R" address.
.PP
More details about this record can be found by reading the specification
itself at <http://tools.ietf.org/html/rfc5617>.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP"
.IX Subsection "fetch()"
Lookup an \s-1ADSP\s0 record in \s-1DNS.\s0
.PP
.Vb 4
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->fetch(
\&            Protocol => "dns",
\&            Author => \*(Aqjsmith@example.org\*(Aq,
\&          );
.Ve
.PP
If the \s-1ADSP\s0 record is found and appears to be valid, an object
containing that record's information will be constructed and returned.
If the \s-1ADSP\s0 record is blank or simply does not exist, an object
representing the default policy will be returned instead.
(See also \*(L"\fIis_implied_default_policy()\fR\*(R".)
If a \s-1DNS\s0 error occurs (e.g. \s-1SERVFAIL\s0 or time-out), this method
will \*(L"die\*(R".
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct a default policy object.
.PP
.Vb 1
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->new;
.Ve
.SS "\fIparse()\fP"
.IX Subsection "parse()"
Construct an \s-1ADSP\s0 record from a string.
.PP
.Vb 4
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->parse(
\&          String => "dkim=all",
\&          Domain => "aaa.example",
\&      );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
It can be considered very suspicious.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered somewhat suspicious.
.PP
Note: in the future, these values may become:
 none \- no \s-1ADSP\s0 record is published
 pass \- a passing signature is present
 fail \- \s-1ADSP\s0 record is \*(L"all\*(R" and no passing signature is found
 discard \- \s-1ADSP\s0 record is \*(L"discardable\*(R" and no passing signature is found
 nxdomain \- the \s-1DNS\s0 domain does not exist
 temperror \- transient error occurred
 permerror \- non-transient error occurred
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Tells whether this policy implied.
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Tells where the policy was fetched from.
.PP
If the policy is domain-wide, this will be domain where the policy was
published.
.PP
If the policy is user-specific, \s-1TBD.\s0
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIpolicy()\fP"
.IX Subsection "policy()"
Get or set the outbound signing policy (dkim=) tag.
.PP
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
The default. The entity may sign some or all email.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
All mail from the domain is expected to be signed, using a valid Author
signature, but the author does not suggest discarding mail without a
valid signature.
.ie n .IP """discardable""" 4
.el .IP "\f(CWdiscardable\fR" 4
.IX Item "discardable"
All mail from the domain is expected to be signed, using a valid Author
signature, and the author is so confident that non-signed mail claiming
to be from this domain can be automatically discarded by the recipient's
mail server.
.ie n .IP """NXDOMAIN""" 4
.el .IP "\f(CW``NXDOMAIN''\fR" 4
.IX Item """NXDOMAIN"""
The domain is out of scope, i.e., the domain does not exist in the
\&\s-1DNS.\s0
.SS "\fIsignall()\fP"
.IX Subsection "signall()"
True if policy is \*(L"all\*(R".
.SS "\fIsignall_discardable()\fP"
.IX Subsection "signall_discardable()"
True if policy is \*(L"strict\*(R".
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
Section 4.3 of the specification says to perform a query on the
domain itself just to see if it exists. This class is not
currently doing that, i.e. it might report \s-1NXDOMAIN\s0 because
_adsp._domainkey.example.org is nonexistent, but it should
not be treated the same as example.org being nonexistent.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::AuthorDomainPolicy5.16.3pm       0100644 0001750 0001750 00000022360 12566242072 027206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::AuthorDomainPolicy 3"
.TH Mail::DKIM::AuthorDomainPolicy 3 "2010-01-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::AuthorDomainPolicy \- represents an Author Domain Signing Practices (ADSP) record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Author Domain Signing Policies (\s-1ADSP\s0) record can be published by any
domain to help a receiver know what to do when it encounters an unsigned
message claiming to originate from that domain.
.PP
The record is published as a \s-1DNS\s0 \s-1TXT\s0 record at _adsp._domainkey.DOMAIN
where \s-1DOMAIN\s0 is the domain of the message's \*(L"From\*(R" address.
.PP
More details about this record can be found by reading the specification
itself at <http://tools.ietf.org/html/rfc5617>.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP"
.IX Subsection "fetch()"
Lookup an \s-1ADSP\s0 record in \s-1DNS\s0.
.PP
.Vb 4
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->fetch(
\&            Protocol => "dns",
\&            Author => \*(Aqjsmith@example.org\*(Aq,
\&          );
.Ve
.PP
If the \s-1ADSP\s0 record is found and appears to be valid, an object
containing that record's information will be constructed and returned.
If the \s-1ADSP\s0 record is blank or simply does not exist, an object
representing the default policy will be returned instead.
(See also \*(L"\fIis_implied_default_policy()\fR\*(R".)
If a \s-1DNS\s0 error occurs (e.g. \s-1SERVFAIL\s0 or time-out), this method
will \*(L"die\*(R".
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct a default policy object.
.PP
.Vb 1
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->new;
.Ve
.SS "\fIparse()\fP"
.IX Subsection "parse()"
Construct an \s-1ADSP\s0 record from a string.
.PP
.Vb 4
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->parse(
\&          String => "dkim=all",
\&          Domain => "aaa.example",
\&      );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
It can be considered very suspicious.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered somewhat suspicious.
.PP
Note: in the future, these values may become:
 none \- no \s-1ADSP\s0 record is published
 pass \- a passing signature is present
 fail \- \s-1ADSP\s0 record is \*(L"all\*(R" and no passing signature is found
 discard \- \s-1ADSP\s0 record is \*(L"discardable\*(R" and no passing signature is found
 nxdomain \- the \s-1DNS\s0 domain does not exist
 temperror \- transient error occurred
 permerror \- non-transient error occurred
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Tells whether this policy implied.
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Tells where the policy was fetched from.
.PP
If the policy is domain-wide, this will be domain where the policy was
published.
.PP
If the policy is user-specific, \s-1TBD\s0.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIpolicy()\fP"
.IX Subsection "policy()"
Get or set the outbound signing policy (dkim=) tag.
.PP
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
The default. The entity may sign some or all email.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
All mail from the domain is expected to be signed, using a valid Author
signature, but the author does not suggest discarding mail without a
valid signature.
.ie n .IP """discardable""" 4
.el .IP "\f(CWdiscardable\fR" 4
.IX Item "discardable"
All mail from the domain is expected to be signed, using a valid Author
signature, and the author is so confident that non-signed mail claiming
to be from this domain can be automatically discarded by the recipient's
mail server.
.ie n .IP """NXDOMAIN""" 4
.el .IP "\f(CW``NXDOMAIN''\fR" 4
.IX Item """NXDOMAIN"""
The domain is out of scope, i.e., the domain does not exist in the
\&\s-1DNS\s0.
.SS "\fIsignall()\fP"
.IX Subsection "signall()"
True if policy is \*(L"all\*(R".
.SS "\fIsignall_discardable()\fP"
.IX Subsection "signall_discardable()"
True if policy is \*(L"strict\*(R".
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
Section 4.3 of the specification says to perform a query on the
domain itself just to see if it exists. This class is not
currently doing that, i.e. it might report \s-1NXDOMAIN\s0 because
_adsp._domainkey.example.org is nonexistent, but it should
not be treated the same as example.org being nonexistent.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::AuthorDomainPolicy5.18.3pm       0100644 0001750 0001750 00000022672 12566242060 027213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::AuthorDomainPolicy 3"
.TH Mail::DKIM::AuthorDomainPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::AuthorDomainPolicy \- represents an Author Domain Signing Practices (ADSP) record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Author Domain Signing Policies (\s-1ADSP\s0) record can be published by any
domain to help a receiver know what to do when it encounters an unsigned
message claiming to originate from that domain.
.PP
The record is published as a \s-1DNS TXT\s0 record at _adsp._domainkey.DOMAIN
where \s-1DOMAIN\s0 is the domain of the message's \*(L"From\*(R" address.
.PP
More details about this record can be found by reading the specification
itself at <http://tools.ietf.org/html/rfc5617>.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP"
.IX Subsection "fetch()"
Lookup an \s-1ADSP\s0 record in \s-1DNS.\s0
.PP
.Vb 4
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->fetch(
\&            Protocol => "dns",
\&            Author => \*(Aqjsmith@example.org\*(Aq,
\&          );
.Ve
.PP
If the \s-1ADSP\s0 record is found and appears to be valid, an object
containing that record's information will be constructed and returned.
If the \s-1ADSP\s0 record is blank or simply does not exist, an object
representing the default policy will be returned instead.
(See also \*(L"\fIis_implied_default_policy()\fR\*(R".)
If a \s-1DNS\s0 error occurs (e.g. \s-1SERVFAIL\s0 or time-out), this method
will \*(L"die\*(R".
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct a default policy object.
.PP
.Vb 1
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->new;
.Ve
.SS "\fIparse()\fP"
.IX Subsection "parse()"
Construct an \s-1ADSP\s0 record from a string.
.PP
.Vb 4
\&  my $policy = Mail::DKIM::AuthorDomainPolicy\->parse(
\&          String => "dkim=all",
\&          Domain => "aaa.example",
\&      );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
It can be considered very suspicious.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered somewhat suspicious.
.PP
Note: in the future, these values may become:
 none \- no \s-1ADSP\s0 record is published
 pass \- a passing signature is present
 fail \- \s-1ADSP\s0 record is \*(L"all\*(R" and no passing signature is found
 discard \- \s-1ADSP\s0 record is \*(L"discardable\*(R" and no passing signature is found
 nxdomain \- the \s-1DNS\s0 domain does not exist
 temperror \- transient error occurred
 permerror \- non-transient error occurred
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Tells whether this policy implied.
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Tells where the policy was fetched from.
.PP
If the policy is domain-wide, this will be domain where the policy was
published.
.PP
If the policy is user-specific, \s-1TBD.\s0
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIpolicy()\fP"
.IX Subsection "policy()"
Get or set the outbound signing policy (dkim=) tag.
.PP
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
The default. The entity may sign some or all email.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
All mail from the domain is expected to be signed, using a valid Author
signature, but the author does not suggest discarding mail without a
valid signature.
.ie n .IP """discardable""" 4
.el .IP "\f(CWdiscardable\fR" 4
.IX Item "discardable"
All mail from the domain is expected to be signed, using a valid Author
signature, and the author is so confident that non-signed mail claiming
to be from this domain can be automatically discarded by the recipient's
mail server.
.ie n .IP """NXDOMAIN""" 4
.el .IP "\f(CW``NXDOMAIN''\fR" 4
.IX Item """NXDOMAIN"""
The domain is out of scope, i.e., the domain does not exist in the
\&\s-1DNS.\s0
.SS "\fIsignall()\fP"
.IX Subsection "signall()"
True if policy is \*(L"all\*(R".
.SS "\fIsignall_discardable()\fP"
.IX Subsection "signall_discardable()"
True if policy is \*(L"strict\*(R".
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
Section 4.3 of the specification says to perform a query on the
domain itself just to see if it exists. This class is not
currently doing that, i.e. it might report \s-1NXDOMAIN\s0 because
_adsp._domainkey.example.org is nonexistent, but it should
not be treated the same as example.org being nonexistent.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Canonicalization::Base.3pm       0100644 0001750 0001750 00000017632 12566242060 027371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Canonicalization::Base 3"
.TH Mail::DKIM::Canonicalization::Base 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Canonicalization::Base \- base class for canonicalization methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # canonicalization results get output to STDOUT
\&  my $method = new Mail::DKIM::Canonicalization::relaxed(
\&                    output_fh => *STDOUT,
\&                    Signature => $dkim_signature);
\&
\&  # add headers
\&  $method\->add_header("Subject: this is the subject\e015\e012");
\&  $method\->finish_header(Headers => \e@all_headers);
\&
\&  # add body
\&  $method\->add_body("This is the body.\e015\e012");
\&  $method\->add_body("Another two lines\e015\e012of the body.\e015\e012");
\&  $method\->finish_body;
\&
\&  # this adds the signature to the end
\&  $method\->finish_message;
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
Use the \fInew()\fR method of the desired canonicalization implementation class
to construct a canonicalization object. E.g.
.PP
.Vb 3
\&  my $method = new Mail::DKIM::Canonicalization::relaxed(
\&                    output_fh => *STDOUT,
\&                    Signature => $dkim_signature);
.Ve
.PP
The constructors accept these arguments:
.IP "Signature" 4
.IX Item "Signature"
(Required) Provide the \s-1DKIM\s0 signature being constructed (if the message is
being signed), or the \s-1DKIM\s0 signature being verified (if the message is
being verified). The canonicalization method either writes parameters to
the signature, or reads parameters from the signature (e.g. the h= tag).
.IP "output" 4
.IX Item "output"
If specified, the canonicalized message will be passed to this object with
the \s-1PRINT\s0 method.
.IP "output_digest" 4
.IX Item "output_digest"
If specified, the canonicalized message will be added to this digest.
(Uses the \fIadd()\fR method.)
.IP "output_fh" 4
.IX Item "output_fh"
If specified, the canonicalized message will be written to this file
handle.
.PP
If none of the output parameters are specified, then the canonicalized
message is appended to an internal buffer. The contents of this buffer
can be accessed using the \fIresult()\fR method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd_body()\fP \- feeds part of the body into the canonicalization"
.IX Subsection "add_body() - feeds part of the body into the canonicalization"
.Vb 2
\&  $method\->add_body("This is the body.\e015\e012");
\&  $method\->add_body("Another two lines\e015\e012of the body.\e015\e012");
.Ve
.PP
The body should be fed one or more \*(L"lines\*(R" at a time.
I.e. do not feed part of a line.
.SS "\fIfinish_header()\fP \- called when the header has been completely parsed"
.IX Subsection "finish_header() - called when the header has been completely parsed"
.Vb 1
\&  $method\->finish_header(Headers => \e@all_headers);
.Ve
.PP
Formerly the canonicalization object would only get the header data
through successive invocations of \fIadd_header()\fR. However, that required
the canonicalization object to store a copy of the entire header so
that it could choose the order in which headers were fed to the digest
object. This is inefficient use of memory, since a message with many
signatures may use many canonicalization objects and each
canonicalization object has its own copy of the header.
.PP
The headers array is an array of one element per header field, with
the headers not processed/canonicalized in any way.
.SS "\fIresult()\fP"
.IX Subsection "result()"
.Vb 1
\&  my $result = $method\->result;
.Ve
.PP
If you did not specify an object or handle to send the output to, the
result of the canonicalization is stored in the canonicalization method
itself, and can be accessed using this method.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Canonicalization::Base5.16.3pm   0100644 0001750 0001750 00000017311 12566242072 027700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Canonicalization::Base 3"
.TH Mail::DKIM::Canonicalization::Base 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Canonicalization::Base \- base class for canonicalization methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # canonicalization results get output to STDOUT
\&  my $method = new Mail::DKIM::Canonicalization::relaxed(
\&                    output_fh => *STDOUT,
\&                    Signature => $dkim_signature);
\&
\&  # add headers
\&  $method\->add_header("Subject: this is the subject\e015\e012");
\&  $method\->finish_header(Headers => \e@all_headers);
\&
\&  # add body
\&  $method\->add_body("This is the body.\e015\e012");
\&  $method\->add_body("Another two lines\e015\e012of the body.\e015\e012");
\&  $method\->finish_body;
\&
\&  # this adds the signature to the end
\&  $method\->finish_message;
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
Use the \fInew()\fR method of the desired canonicalization implementation class
to construct a canonicalization object. E.g.
.PP
.Vb 3
\&  my $method = new Mail::DKIM::Canonicalization::relaxed(
\&                    output_fh => *STDOUT,
\&                    Signature => $dkim_signature);
.Ve
.PP
The constructors accept these arguments:
.IP "Signature" 4
.IX Item "Signature"
(Required) Provide the \s-1DKIM\s0 signature being constructed (if the message is
being signed), or the \s-1DKIM\s0 signature being verified (if the message is
being verified). The canonicalization method either writes parameters to
the signature, or reads parameters from the signature (e.g. the h= tag).
.IP "output" 4
.IX Item "output"
If specified, the canonicalized message will be passed to this object with
the \s-1PRINT\s0 method.
.IP "output_digest" 4
.IX Item "output_digest"
If specified, the canonicalized message will be added to this digest.
(Uses the \fIadd()\fR method.)
.IP "output_fh" 4
.IX Item "output_fh"
If specified, the canonicalized message will be written to this file
handle.
.PP
If none of the output parameters are specified, then the canonicalized
message is appended to an internal buffer. The contents of this buffer
can be accessed using the \fIresult()\fR method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd_body()\fP \- feeds part of the body into the canonicalization"
.IX Subsection "add_body() - feeds part of the body into the canonicalization"
.Vb 2
\&  $method\->add_body("This is the body.\e015\e012");
\&  $method\->add_body("Another two lines\e015\e012of the body.\e015\e012");
.Ve
.PP
The body should be fed one or more \*(L"lines\*(R" at a time.
I.e. do not feed part of a line.
.SS "\fIfinish_header()\fP \- called when the header has been completely parsed"
.IX Subsection "finish_header() - called when the header has been completely parsed"
.Vb 1
\&  $method\->finish_header(Headers => \e@all_headers);
.Ve
.PP
Formerly the canonicalization object would only get the header data
through successive invocations of \fIadd_header()\fR. However, that required
the canonicalization object to store a copy of the entire header so
that it could choose the order in which headers were fed to the digest
object. This is inefficient use of memory, since a message with many
signatures may use many canonicalization objects and each
canonicalization object has its own copy of the header.
.PP
The headers array is an array of one element per header field, with
the headers not processed/canonicalized in any way.
.SS "\fIresult()\fP"
.IX Subsection "result()"
.Vb 1
\&  my $result = $method\->result;
.Ve
.PP
If you did not specify an object or handle to send the output to, the
result of the canonicalization is stored in the canonicalization method
itself, and can be accessed using this method.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Canonicalization::Base5.18.3pm   0100644 0001750 0001750 00000017632 12566242060 027705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Canonicalization::Base 3"
.TH Mail::DKIM::Canonicalization::Base 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Canonicalization::Base \- base class for canonicalization methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # canonicalization results get output to STDOUT
\&  my $method = new Mail::DKIM::Canonicalization::relaxed(
\&                    output_fh => *STDOUT,
\&                    Signature => $dkim_signature);
\&
\&  # add headers
\&  $method\->add_header("Subject: this is the subject\e015\e012");
\&  $method\->finish_header(Headers => \e@all_headers);
\&
\&  # add body
\&  $method\->add_body("This is the body.\e015\e012");
\&  $method\->add_body("Another two lines\e015\e012of the body.\e015\e012");
\&  $method\->finish_body;
\&
\&  # this adds the signature to the end
\&  $method\->finish_message;
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
Use the \fInew()\fR method of the desired canonicalization implementation class
to construct a canonicalization object. E.g.
.PP
.Vb 3
\&  my $method = new Mail::DKIM::Canonicalization::relaxed(
\&                    output_fh => *STDOUT,
\&                    Signature => $dkim_signature);
.Ve
.PP
The constructors accept these arguments:
.IP "Signature" 4
.IX Item "Signature"
(Required) Provide the \s-1DKIM\s0 signature being constructed (if the message is
being signed), or the \s-1DKIM\s0 signature being verified (if the message is
being verified). The canonicalization method either writes parameters to
the signature, or reads parameters from the signature (e.g. the h= tag).
.IP "output" 4
.IX Item "output"
If specified, the canonicalized message will be passed to this object with
the \s-1PRINT\s0 method.
.IP "output_digest" 4
.IX Item "output_digest"
If specified, the canonicalized message will be added to this digest.
(Uses the \fIadd()\fR method.)
.IP "output_fh" 4
.IX Item "output_fh"
If specified, the canonicalized message will be written to this file
handle.
.PP
If none of the output parameters are specified, then the canonicalized
message is appended to an internal buffer. The contents of this buffer
can be accessed using the \fIresult()\fR method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd_body()\fP \- feeds part of the body into the canonicalization"
.IX Subsection "add_body() - feeds part of the body into the canonicalization"
.Vb 2
\&  $method\->add_body("This is the body.\e015\e012");
\&  $method\->add_body("Another two lines\e015\e012of the body.\e015\e012");
.Ve
.PP
The body should be fed one or more \*(L"lines\*(R" at a time.
I.e. do not feed part of a line.
.SS "\fIfinish_header()\fP \- called when the header has been completely parsed"
.IX Subsection "finish_header() - called when the header has been completely parsed"
.Vb 1
\&  $method\->finish_header(Headers => \e@all_headers);
.Ve
.PP
Formerly the canonicalization object would only get the header data
through successive invocations of \fIadd_header()\fR. However, that required
the canonicalization object to store a copy of the entire header so
that it could choose the order in which headers were fed to the digest
object. This is inefficient use of memory, since a message with many
signatures may use many canonicalization objects and each
canonicalization object has its own copy of the header.
.PP
The headers array is an array of one element per header field, with
the headers not processed/canonicalized in any way.
.SS "\fIresult()\fP"
.IX Subsection "result()"
.Vb 1
\&  my $result = $method\->result;
.Ve
.PP
If you did not specify an object or handle to send the output to, the
result of the canonicalization is stored in the canonicalization method
itself, and can be accessed using this method.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Canonicalization::DkimCommon.3pm 0100644 0001750 0001750 00000010755 12566242060 030553  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Canonicalization::DkimCommon 3"
.TH Mail::DKIM::Canonicalization::DkimCommon 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Canonicalization::DkimCommon \- common canonicalization methods
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements functionality that is common to all the
currently-defined \s-1DKIM\s0 canonicalization methods, but not necessarily
common with future canonicalization methods.
.PP
For functionality that is common to all canonicalization methods
(including future methods), see Mail::DKIM::Canonicalization::Base.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Canonicalization::Base
                   Mail::DKIM::Canonicalization::DkimCommon5.16.3pm                                                    0100644 0001750 0001750 00000010434 12566242072 031003  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Canonicalization::DkimCommon 3"
.TH Mail::DKIM::Canonicalization::DkimCommon 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Canonicalization::DkimCommon \- common canonicalization methods
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements functionality that is common to all the
currently-defined \s-1DKIM\s0 canonicalization methods, but not necessarily
common with future canonicalization methods.
.PP
For functionality that is common to all canonicalization methods
(including future methods), see Mail::DKIM::Canonicalization::Base.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Canonicalization::Base
                                                                                                                                                                                                                                    Mail::DKIM::Canonicalization::DkimCommon5.18.3pm                                                    0100644 0001750 0001750 00000010755 12566242060 031010  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Canonicalization::DkimCommon 3"
.TH Mail::DKIM::Canonicalization::DkimCommon 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Canonicalization::DkimCommon \- common canonicalization methods
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements functionality that is common to all the
currently-defined \s-1DKIM\s0 canonicalization methods, but not necessarily
common with future canonicalization methods.
.PP
For functionality that is common to all canonicalization methods
(including future methods), see Mail::DKIM::Canonicalization::Base.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Canonicalization::Base
                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DNS.3pm                          0100644 0001750 0001750 00000015204 12566242060 023542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DNS 3"
.TH Mail::DKIM::DNS 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DNS \- performs DNS queries for Mail::DKIM
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the module that performs \s-1DNS\s0 queries for Mail::DKIM.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
This module has a couple configuration settings that the caller
may want to use to customize the behavior of this module.
.ie n .SS "$Mail::DKIM::DNS::TIMEOUT"
.el .SS "\f(CW$Mail::DKIM::DNS::TIMEOUT\fP"
.IX Subsection "$Mail::DKIM::DNS::TIMEOUT"
This global variable specifies the maximum amount of time (in seconds)
to wait for a single \s-1DNS\s0 query to complete. The default is 10.
.SS "\fIMail::DKIM::DNS::resolver()\fP"
.IX Subsection "Mail::DKIM::DNS::resolver()"
Use this global subroutine to get or replace the instance of
Net::DNS::Resolver that Mail::DKIM uses. If set to undef (the default),
then a brand new default instance of Net::DNS::Resolver will be
created the first time a \s-1DNS\s0 query is needed.
.PP
You will call this subroutine if you want to specify non-default options
to Net::DNS::Resolver, such as different timeouts, or to enable use
of a persistent socket. For example:
.PP
.Vb 6
\&  # first, construct a custom DNS resolver
\&  my $res = Net::DNS::Resolver\->new(
\&                    udp_timeout => 3, tcp_timeout => 3, retry => 2,
\&                 );
\&  $res\->udppacketsize(1240);
\&  $res\->persistent_udp(1);
\&
\&  # then, tell Mail::DKIM to use this resolver
\&  Mail::DKIM::DNS::resolver($res);
.Ve
.SS "\fIMail::DKIM::DNS::enable_EDNS0()\fP"
.IX Subsection "Mail::DKIM::DNS::enable_EDNS0()"
This is a convenience subroutine that will construct an appropriate \s-1DNS\s0
resolver that uses \s-1EDNS0 \s0(Extension mechanisms for \s-1DNS\s0) to support large
\&\s-1DNS\s0 replies, and configure Mail::DKIM to use it. (As such, it should \s-1NOT\s0
be used in conjunction with the \fIresolver()\fR subroutine described above.)
.PP
.Vb 1
\&  Mail::DKIM::DNS::enable_EDNS0();
.Ve
.PP
Use of \s-1EDNS0\s0 is recommended, since it reduces the need for falling back to \s-1TCP\s0
when dealing with large \s-1DNS\s0 packets. However, it is not enabled by default
because some Internet firewalls which do deep inspection of packets are not able
to process EDNS0\-enabled packets. When there is a firewall on a path to a \s-1DNS\s0
resolver, the \s-1EDNS0\s0 feature should be specifically tested before enabling.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007, 2012\-2013 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DNS5.18.3pm                      0100644 0001750 0001750 00000015204 12566242060 024056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DNS 3"
.TH Mail::DKIM::DNS 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DNS \- performs DNS queries for Mail::DKIM
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the module that performs \s-1DNS\s0 queries for Mail::DKIM.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
This module has a couple configuration settings that the caller
may want to use to customize the behavior of this module.
.ie n .SS "$Mail::DKIM::DNS::TIMEOUT"
.el .SS "\f(CW$Mail::DKIM::DNS::TIMEOUT\fP"
.IX Subsection "$Mail::DKIM::DNS::TIMEOUT"
This global variable specifies the maximum amount of time (in seconds)
to wait for a single \s-1DNS\s0 query to complete. The default is 10.
.SS "\fIMail::DKIM::DNS::resolver()\fP"
.IX Subsection "Mail::DKIM::DNS::resolver()"
Use this global subroutine to get or replace the instance of
Net::DNS::Resolver that Mail::DKIM uses. If set to undef (the default),
then a brand new default instance of Net::DNS::Resolver will be
created the first time a \s-1DNS\s0 query is needed.
.PP
You will call this subroutine if you want to specify non-default options
to Net::DNS::Resolver, such as different timeouts, or to enable use
of a persistent socket. For example:
.PP
.Vb 6
\&  # first, construct a custom DNS resolver
\&  my $res = Net::DNS::Resolver\->new(
\&                    udp_timeout => 3, tcp_timeout => 3, retry => 2,
\&                 );
\&  $res\->udppacketsize(1240);
\&  $res\->persistent_udp(1);
\&
\&  # then, tell Mail::DKIM to use this resolver
\&  Mail::DKIM::DNS::resolver($res);
.Ve
.SS "\fIMail::DKIM::DNS::enable_EDNS0()\fP"
.IX Subsection "Mail::DKIM::DNS::enable_EDNS0()"
This is a convenience subroutine that will construct an appropriate \s-1DNS\s0
resolver that uses \s-1EDNS0 \s0(Extension mechanisms for \s-1DNS\s0) to support large
\&\s-1DNS\s0 replies, and configure Mail::DKIM to use it. (As such, it should \s-1NOT\s0
be used in conjunction with the \fIresolver()\fR subroutine described above.)
.PP
.Vb 1
\&  Mail::DKIM::DNS::enable_EDNS0();
.Ve
.PP
Use of \s-1EDNS0\s0 is recommended, since it reduces the need for falling back to \s-1TCP\s0
when dealing with large \s-1DNS\s0 packets. However, it is not enabled by default
because some Internet firewalls which do deep inspection of packets are not able
to process EDNS0\-enabled packets. When there is a firewall on a path to a \s-1DNS\s0
resolver, the \s-1EDNS0\s0 feature should be specifically tested before enabling.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007, 2012\-2013 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkPolicy.3pm                     0100644 0001750 0001750 00000022443 12566242060 024637  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkPolicy 3"
.TH Mail::DKIM::DkPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkPolicy \- represents a DomainKeys Sender Signing Policy record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DomainKeys sender signing policies are described in
\&\s-1RFC4870\s0(historical). It is a record published in the message
sender's (i.e. the person who transmitted the message)
\&\s-1DNS\s0 that describes how they sign messages.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP \- fetch a sender signing policy from \s-1DNS\s0"
.IX Subsection "fetch() - fetch a sender signing policy from DNS"
.Vb 4
\&  my $policy = Mail::DKIM::DkPolicy\->fetch(
\&                   Protocol => "dns",
\&                   Sender => \*(Aqjoe@example.org\*(Aq,
\&               );
.Ve
.PP
The following named arguments are accepted:
.IP "Protocol" 4
.IX Item "Protocol"
always specify \*(L"dns\*(R"
.IP "Author" 4
.IX Item "Author"
the \*(L"author\*(R" of the message for which policy is being checked.
This is the first email address in the \*(L"From\*(R" header.
According to \s-1RFC 2822,\s0 section 3.6.2, the \*(L"From\*(R" header lists
who is responsible for writing the message.
.IP "Sender" 4
.IX Item "Sender"
the \*(L"sender\*(R" of the message for which policy is being checked.
This is the first email address in the \*(L"Sender\*(R" header,
or if there is not a \*(L"Sender\*(R" header, the \*(L"From\*(R" header.
According to \s-1RFC 2822,\s0 section 3.6.2, the \*(L"Sender\*(R" header lists
who is responsible for transmitting the message.
.PP
Depending on what type of policy is being checked, both the
Sender and Author fields may need to be specified.
.PP
If a \s-1DNS\s0 error or timeout occurs, an exception is thrown.
.PP
Otherwise, a policy object of some sort will be returned.
If no policy is actually published,
then the \*(L"default policy\*(R" will be returned.
To check when this happens, use
.PP
.Vb 1
\&  my $is_default = $policy\->is_implied_default_policy;
.Ve
.SS "\fInew()\fP \- construct a default policy object"
.IX Subsection "new() - construct a default policy object"
.Vb 1
\&  my $policy = Mail::DKIM::DkPolicy\->new;
.Ve
.SS "\fIparse()\fP \- gets a policy object by parsing a string"
.IX Subsection "parse() - gets a policy object by parsing a string"
.Vb 3
\&  my $policy = Mail::DKIM::DkPolicy\->parse(
\&                   String => "o=~; t=y"
\&               );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP \- apply the policy to the results of a \s-1DKIM\s0 verifier"
.IX Subsection "apply() - apply the policy to the results of a DKIM verifier"
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered suspicious.
.SS "\fIflags()\fP \- get or set the flags (t=) tag"
.IX Subsection "flags() - get or set the flags (t=) tag"
A vertical-bar separated list of flags.
.SS "\fIis_implied_default_policy()\fP \- is this policy implied?"
.IX Subsection "is_implied_default_policy() - is this policy implied?"
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP \- where the policy was fetched from"
.IX Subsection "location() - where the policy was fetched from"
DomainKeys policies only have per-domain policies, so this will
be the domain where the policy was published.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fInote()\fP \- get or set the human readable notes (n=) tag"
.IX Subsection "note() - get or set the human readable notes (n=) tag"
Human readable notes regarding the record. Undef if no notes specified.
.SS "\fIpolicy()\fP \- get or set the outbound signing policy (o=) tag"
.IX Subsection "policy() - get or set the outbound signing policy (o=) tag"
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """~""" 4
.el .IP "\f(CW~\fR" 4
.IX Item "~"
The default. The domain may sign some (but not all) email.
.ie n .IP """\-""" 4
.el .IP "\f(CW\-\fR" 4
.IX Item "-"
The domain signs all email.
.ie n .SS "\fIsignall()\fP \- true if policy is ""\-"""
.el .SS "\fIsignall()\fP \- true if policy is ``\-''"
.IX Subsection "signall() - true if policy is -"
.SS "\fItesting()\fP \- checks the testing flag"
.IX Subsection "testing() - checks the testing flag"
.Vb 1
\&  my $testing = $policy\->testing;
.Ve
.PP
If nonzero, the testing flag is set on the signing policy, and the
verify should not consider a message suspicious based on this policy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkPolicy5.16.3pm                 0100644 0001750 0001750 00000022122 12566242072 025146  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkPolicy 3"
.TH Mail::DKIM::DkPolicy 3 "2009-07-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkPolicy \- represents a DomainKeys Sender Signing Policy record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DomainKeys sender signing policies are described in
\&\s-1RFC4870\s0(historical). It is a record published in the message
sender's (i.e. the person who transmitted the message)
\&\s-1DNS\s0 that describes how they sign messages.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP \- fetch a sender signing policy from \s-1DNS\s0"
.IX Subsection "fetch() - fetch a sender signing policy from DNS"
.Vb 4
\&  my $policy = Mail::DKIM::DkPolicy\->fetch(
\&                   Protocol => "dns",
\&                   Sender => \*(Aqjoe@example.org\*(Aq,
\&               );
.Ve
.PP
The following named arguments are accepted:
.IP "Protocol" 4
.IX Item "Protocol"
always specify \*(L"dns\*(R"
.IP "Author" 4
.IX Item "Author"
the \*(L"author\*(R" of the message for which policy is being checked.
This is the first email address in the \*(L"From\*(R" header.
According to \s-1RFC\s0 2822, section 3.6.2, the \*(L"From\*(R" header lists
who is responsible for writing the message.
.IP "Sender" 4
.IX Item "Sender"
the \*(L"sender\*(R" of the message for which policy is being checked.
This is the first email address in the \*(L"Sender\*(R" header,
or if there is not a \*(L"Sender\*(R" header, the \*(L"From\*(R" header.
According to \s-1RFC\s0 2822, section 3.6.2, the \*(L"Sender\*(R" header lists
who is responsible for transmitting the message.
.PP
Depending on what type of policy is being checked, both the
Sender and Author fields may need to be specified.
.PP
If a \s-1DNS\s0 error or timeout occurs, an exception is thrown.
.PP
Otherwise, a policy object of some sort will be returned.
If no policy is actually published,
then the \*(L"default policy\*(R" will be returned.
To check when this happens, use
.PP
.Vb 1
\&  my $is_default = $policy\->is_implied_default_policy;
.Ve
.SS "\fInew()\fP \- construct a default policy object"
.IX Subsection "new() - construct a default policy object"
.Vb 1
\&  my $policy = Mail::DKIM::DkPolicy\->new;
.Ve
.SS "\fIparse()\fP \- gets a policy object by parsing a string"
.IX Subsection "parse() - gets a policy object by parsing a string"
.Vb 3
\&  my $policy = Mail::DKIM::DkPolicy\->parse(
\&                   String => "o=~; t=y"
\&               );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP \- apply the policy to the results of a \s-1DKIM\s0 verifier"
.IX Subsection "apply() - apply the policy to the results of a DKIM verifier"
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered suspicious.
.SS "\fIflags()\fP \- get or set the flags (t=) tag"
.IX Subsection "flags() - get or set the flags (t=) tag"
A vertical-bar separated list of flags.
.SS "\fIis_implied_default_policy()\fP \- is this policy implied?"
.IX Subsection "is_implied_default_policy() - is this policy implied?"
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP \- where the policy was fetched from"
.IX Subsection "location() - where the policy was fetched from"
DomainKeys policies only have per-domain policies, so this will
be the domain where the policy was published.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fInote()\fP \- get or set the human readable notes (n=) tag"
.IX Subsection "note() - get or set the human readable notes (n=) tag"
Human readable notes regarding the record. Undef if no notes specified.
.SS "\fIpolicy()\fP \- get or set the outbound signing policy (o=) tag"
.IX Subsection "policy() - get or set the outbound signing policy (o=) tag"
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """~""" 4
.el .IP "\f(CW~\fR" 4
.IX Item "~"
The default. The domain may sign some (but not all) email.
.ie n .IP """\-""" 4
.el .IP "\f(CW\-\fR" 4
.IX Item "-"
The domain signs all email.
.ie n .SS "\fIsignall()\fP \- true if policy is ""\-"""
.el .SS "\fIsignall()\fP \- true if policy is ``\-''"
.IX Subsection "signall() - true if policy is -"
.SS "\fItesting()\fP \- checks the testing flag"
.IX Subsection "testing() - checks the testing flag"
.Vb 1
\&  my $testing = $policy\->testing;
.Ve
.PP
If nonzero, the testing flag is set on the signing policy, and the
verify should not consider a message suspicious based on this policy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkPolicy5.18.3pm                 0100644 0001750 0001750 00000022443 12566242060 025153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkPolicy 3"
.TH Mail::DKIM::DkPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkPolicy \- represents a DomainKeys Sender Signing Policy record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DomainKeys sender signing policies are described in
\&\s-1RFC4870\s0(historical). It is a record published in the message
sender's (i.e. the person who transmitted the message)
\&\s-1DNS\s0 that describes how they sign messages.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP \- fetch a sender signing policy from \s-1DNS\s0"
.IX Subsection "fetch() - fetch a sender signing policy from DNS"
.Vb 4
\&  my $policy = Mail::DKIM::DkPolicy\->fetch(
\&                   Protocol => "dns",
\&                   Sender => \*(Aqjoe@example.org\*(Aq,
\&               );
.Ve
.PP
The following named arguments are accepted:
.IP "Protocol" 4
.IX Item "Protocol"
always specify \*(L"dns\*(R"
.IP "Author" 4
.IX Item "Author"
the \*(L"author\*(R" of the message for which policy is being checked.
This is the first email address in the \*(L"From\*(R" header.
According to \s-1RFC 2822,\s0 section 3.6.2, the \*(L"From\*(R" header lists
who is responsible for writing the message.
.IP "Sender" 4
.IX Item "Sender"
the \*(L"sender\*(R" of the message for which policy is being checked.
This is the first email address in the \*(L"Sender\*(R" header,
or if there is not a \*(L"Sender\*(R" header, the \*(L"From\*(R" header.
According to \s-1RFC 2822,\s0 section 3.6.2, the \*(L"Sender\*(R" header lists
who is responsible for transmitting the message.
.PP
Depending on what type of policy is being checked, both the
Sender and Author fields may need to be specified.
.PP
If a \s-1DNS\s0 error or timeout occurs, an exception is thrown.
.PP
Otherwise, a policy object of some sort will be returned.
If no policy is actually published,
then the \*(L"default policy\*(R" will be returned.
To check when this happens, use
.PP
.Vb 1
\&  my $is_default = $policy\->is_implied_default_policy;
.Ve
.SS "\fInew()\fP \- construct a default policy object"
.IX Subsection "new() - construct a default policy object"
.Vb 1
\&  my $policy = Mail::DKIM::DkPolicy\->new;
.Ve
.SS "\fIparse()\fP \- gets a policy object by parsing a string"
.IX Subsection "parse() - gets a policy object by parsing a string"
.Vb 3
\&  my $policy = Mail::DKIM::DkPolicy\->parse(
\&                   String => "o=~; t=y"
\&               );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP \- apply the policy to the results of a \s-1DKIM\s0 verifier"
.IX Subsection "apply() - apply the policy to the results of a DKIM verifier"
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered suspicious.
.SS "\fIflags()\fP \- get or set the flags (t=) tag"
.IX Subsection "flags() - get or set the flags (t=) tag"
A vertical-bar separated list of flags.
.SS "\fIis_implied_default_policy()\fP \- is this policy implied?"
.IX Subsection "is_implied_default_policy() - is this policy implied?"
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP \- where the policy was fetched from"
.IX Subsection "location() - where the policy was fetched from"
DomainKeys policies only have per-domain policies, so this will
be the domain where the policy was published.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fInote()\fP \- get or set the human readable notes (n=) tag"
.IX Subsection "note() - get or set the human readable notes (n=) tag"
Human readable notes regarding the record. Undef if no notes specified.
.SS "\fIpolicy()\fP \- get or set the outbound signing policy (o=) tag"
.IX Subsection "policy() - get or set the outbound signing policy (o=) tag"
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """~""" 4
.el .IP "\f(CW~\fR" 4
.IX Item "~"
The default. The domain may sign some (but not all) email.
.ie n .IP """\-""" 4
.el .IP "\f(CW\-\fR" 4
.IX Item "-"
The domain signs all email.
.ie n .SS "\fIsignall()\fP \- true if policy is ""\-"""
.el .SS "\fIsignall()\fP \- true if policy is ``\-''"
.IX Subsection "signall() - true if policy is -"
.SS "\fItesting()\fP \- checks the testing flag"
.IX Subsection "testing() - checks the testing flag"
.Vb 1
\&  my $testing = $policy\->testing;
.Ve
.PP
If nonzero, the testing flag is set on the signing policy, and the
verify should not consider a message suspicious based on this policy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkSignature.3pm                  0100644 0001750 0001750 00000021617 12566242060 025343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkSignature 3"
.TH Mail::DKIM::DkSignature 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkSignature \- represents a DomainKeys\-Signature header
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Create a new DomainKey signature from parameters
.PP
.Vb 10
\&  my $signature = Mail::DKIM::DkSignature\->new(
\&                      [ Algorithm => "rsa\-sha1", ]
\&                      [ Signature => $base64, ]
\&                      [ Method => "simple", ]
\&                      [ Domain => "example.org", ]
\&                      [ Headers => "from:subject:date:message\-id", ]
\&                      [ Query => "dns", ]
\&                      [ Selector => "alpha", ]
\&                      [ Key => $private_key, ]
\&                  );
.Ve
.SS "\fIparse()\fP"
.IX Subsection "parse()"
Create a new signature from a DomainKey-Signature header
.PP
.Vb 3
\&  my $sig = Mail::DKIM::DkSignature\->parse(
\&                  "DomainKey\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=nofws"
\&            );
.Ve
.PP
Constructs a signature by parsing the provided DomainKey-Signature header
content. You do not have to include the header name
(i.e. \*(L"DomainKey-Signature:\*(R")
but it is recommended, so the header name can be preserved and returned
the same way in \*(L"\fIas_string()\fR\*(R".
.PP
Note: The input to this constructor is in the same format as the output
of the as_string method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIas_string()\fP"
.IX Subsection "as_string()"
Convert the signature header as a string.
.PP
.Vb 1
\&  print $signature\->as_string . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DomainKey\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=nofws
.Ve
.PP
As shown in the example, the as_string method can be used to generate
the DomainKey-Signature that gets prepended to a signed message.
.SS "\fIalgorithm()\fP"
.IX Subsection "algorithm()"
Get or set the algorithm (a=) field
.PP
The algorithm used to generate the signature.
Defaults to \*(L"rsa\-sha1\*(R", an RSA-signed \s-1SHA\-1\s0 digest.
.SS "\fIcanonicalization()\fP"
.IX Subsection "canonicalization()"
Get or set the canonicalization (c=) field.
.PP
.Vb 2
\&  $signature\->canonicalization("nofws");
\&  $signature\->canonicalization("simple");
\&
\&  $method = $signature\->canonicalization;
.Ve
.PP
Message canonicalization (default is \*(L"simple\*(R"). This informs the
verifier of the type of canonicalization used to prepare the message for
signing.
.SS "\fIdomain()\fP"
.IX Subsection "domain()"
Get or set the domain (d=) field.
.PP
.Vb 2
\&  my $d = $signature\->domain;          # gets the domain value
\&  $signature\->domain("example.org");   # sets the domain value
.Ve
.PP
The domain of the signing entity, as specified in the signature.
This is the domain that will be queried for the public key.
.SS "\fIheaderlist()\fP"
.IX Subsection "headerlist()"
Get or set the signed header fields (h=) field.
.PP
.Vb 1
\&  $signature\->headerlist("a:b:c");
\&
\&  my $headerlist = $signature\->headerlist;
\&
\&  my @headers = $signature\->headerlist;
.Ve
.PP
Signed header fields. A colon-separated list of header field names
that identify the header fields presented to the signing algorithm.
.PP
In scalar context, the list of header field names will be returned
as a single string, with the names joined together with colons.
In list context, the header field names will be returned as a list.
.SS "\fIidentity()\fP"
.IX Subsection "identity()"
Get the signing identity.
.PP
.Vb 1
\&  my $i = $signature\->identity;
.Ve
.PP
In DomainKey signatures, the signing identity is the first address
found in the Sender header or the From header. This field is
populated by the Verifier when processing a DomainKey signature.
.SS "\fIidentity_source()\fP"
.IX Subsection "identity_source()"
Determine which header had the identity.
.PP
.Vb 1
\&  my $source = $signature\->identity_source;
.Ve
.PP
If the message is being verified, this method will tell you which
of the message headers was used to determine the signature identity.
Possible values are \*(L"header.sender\*(R" and \*(L"header.from\*(R".
.SS "\fIprotocol()\fP"
.IX Subsection "protocol()"
Get or set the query methods (q=) field.
.PP
A colon-separated list of query methods used to retrieve the public
key (default is \*(L"dns\*(R").
.SS "\fIselector()\fP"
.IX Subsection "selector()"
Get or set the selector (s=) field.
.PP
The selector subdivides the namespace for the \*(L"d=\*(R" (domain) tag.
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Get or set the signature data (b=) field.
.PP
The signature data. Whitespace is automatically stripped from the
returned value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Signature for DKIM-Signature headers
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007,2010 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkSignature5.16.3pm              0100644 0001750 0001750 00000021276 12566242072 025661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkSignature 3"
.TH Mail::DKIM::DkSignature 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkSignature \- represents a DomainKeys\-Signature header
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Create a new DomainKey signature from parameters
.PP
.Vb 10
\&  my $signature = Mail::DKIM::DkSignature\->new(
\&                      [ Algorithm => "rsa\-sha1", ]
\&                      [ Signature => $base64, ]
\&                      [ Method => "simple", ]
\&                      [ Domain => "example.org", ]
\&                      [ Headers => "from:subject:date:message\-id", ]
\&                      [ Query => "dns", ]
\&                      [ Selector => "alpha", ]
\&                      [ Key => $private_key, ]
\&                  );
.Ve
.SS "\fIparse()\fP"
.IX Subsection "parse()"
Create a new signature from a DomainKey-Signature header
.PP
.Vb 3
\&  my $sig = Mail::DKIM::DkSignature\->parse(
\&                  "DomainKey\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=nofws"
\&            );
.Ve
.PP
Constructs a signature by parsing the provided DomainKey-Signature header
content. You do not have to include the header name
(i.e. \*(L"DomainKey-Signature:\*(R")
but it is recommended, so the header name can be preserved and returned
the same way in \*(L"\fIas_string()\fR\*(R".
.PP
Note: The input to this constructor is in the same format as the output
of the as_string method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIas_string()\fP"
.IX Subsection "as_string()"
Convert the signature header as a string.
.PP
.Vb 1
\&  print $signature\->as_string . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DomainKey\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=nofws
.Ve
.PP
As shown in the example, the as_string method can be used to generate
the DomainKey-Signature that gets prepended to a signed message.
.SS "\fIalgorithm()\fP"
.IX Subsection "algorithm()"
Get or set the algorithm (a=) field
.PP
The algorithm used to generate the signature.
Defaults to \*(L"rsa\-sha1\*(R", an RSA-signed \s-1SHA\-1\s0 digest.
.SS "\fIcanonicalization()\fP"
.IX Subsection "canonicalization()"
Get or set the canonicalization (c=) field.
.PP
.Vb 2
\&  $signature\->canonicalization("nofws");
\&  $signature\->canonicalization("simple");
\&
\&  $method = $signature\->canonicalization;
.Ve
.PP
Message canonicalization (default is \*(L"simple\*(R"). This informs the
verifier of the type of canonicalization used to prepare the message for
signing.
.SS "\fIdomain()\fP"
.IX Subsection "domain()"
Get or set the domain (d=) field.
.PP
.Vb 2
\&  my $d = $signature\->domain;          # gets the domain value
\&  $signature\->domain("example.org");   # sets the domain value
.Ve
.PP
The domain of the signing entity, as specified in the signature.
This is the domain that will be queried for the public key.
.SS "\fIheaderlist()\fP"
.IX Subsection "headerlist()"
Get or set the signed header fields (h=) field.
.PP
.Vb 1
\&  $signature\->headerlist("a:b:c");
\&
\&  my $headerlist = $signature\->headerlist;
\&
\&  my @headers = $signature\->headerlist;
.Ve
.PP
Signed header fields. A colon-separated list of header field names
that identify the header fields presented to the signing algorithm.
.PP
In scalar context, the list of header field names will be returned
as a single string, with the names joined together with colons.
In list context, the header field names will be returned as a list.
.SS "\fIidentity()\fP"
.IX Subsection "identity()"
Get the signing identity.
.PP
.Vb 1
\&  my $i = $signature\->identity;
.Ve
.PP
In DomainKey signatures, the signing identity is the first address
found in the Sender header or the From header. This field is
populated by the Verifier when processing a DomainKey signature.
.SS "\fIidentity_source()\fP"
.IX Subsection "identity_source()"
Determine which header had the identity.
.PP
.Vb 1
\&  my $source = $signature\->identity_source;
.Ve
.PP
If the message is being verified, this method will tell you which
of the message headers was used to determine the signature identity.
Possible values are \*(L"header.sender\*(R" and \*(L"header.from\*(R".
.SS "\fIprotocol()\fP"
.IX Subsection "protocol()"
Get or set the query methods (q=) field.
.PP
A colon-separated list of query methods used to retrieve the public
key (default is \*(L"dns\*(R").
.SS "\fIselector()\fP"
.IX Subsection "selector()"
Get or set the selector (s=) field.
.PP
The selector subdivides the namespace for the \*(L"d=\*(R" (domain) tag.
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Get or set the signature data (b=) field.
.PP
The signature data. Whitespace is automatically stripped from the
returned value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Signature for DKIM-Signature headers
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007,2010 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkSignature5.18.3pm              0100644 0001750 0001750 00000021617 12566242060 025657  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkSignature 3"
.TH Mail::DKIM::DkSignature 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkSignature \- represents a DomainKeys\-Signature header
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Create a new DomainKey signature from parameters
.PP
.Vb 10
\&  my $signature = Mail::DKIM::DkSignature\->new(
\&                      [ Algorithm => "rsa\-sha1", ]
\&                      [ Signature => $base64, ]
\&                      [ Method => "simple", ]
\&                      [ Domain => "example.org", ]
\&                      [ Headers => "from:subject:date:message\-id", ]
\&                      [ Query => "dns", ]
\&                      [ Selector => "alpha", ]
\&                      [ Key => $private_key, ]
\&                  );
.Ve
.SS "\fIparse()\fP"
.IX Subsection "parse()"
Create a new signature from a DomainKey-Signature header
.PP
.Vb 3
\&  my $sig = Mail::DKIM::DkSignature\->parse(
\&                  "DomainKey\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=nofws"
\&            );
.Ve
.PP
Constructs a signature by parsing the provided DomainKey-Signature header
content. You do not have to include the header name
(i.e. \*(L"DomainKey-Signature:\*(R")
but it is recommended, so the header name can be preserved and returned
the same way in \*(L"\fIas_string()\fR\*(R".
.PP
Note: The input to this constructor is in the same format as the output
of the as_string method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIas_string()\fP"
.IX Subsection "as_string()"
Convert the signature header as a string.
.PP
.Vb 1
\&  print $signature\->as_string . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DomainKey\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=nofws
.Ve
.PP
As shown in the example, the as_string method can be used to generate
the DomainKey-Signature that gets prepended to a signed message.
.SS "\fIalgorithm()\fP"
.IX Subsection "algorithm()"
Get or set the algorithm (a=) field
.PP
The algorithm used to generate the signature.
Defaults to \*(L"rsa\-sha1\*(R", an RSA-signed \s-1SHA\-1\s0 digest.
.SS "\fIcanonicalization()\fP"
.IX Subsection "canonicalization()"
Get or set the canonicalization (c=) field.
.PP
.Vb 2
\&  $signature\->canonicalization("nofws");
\&  $signature\->canonicalization("simple");
\&
\&  $method = $signature\->canonicalization;
.Ve
.PP
Message canonicalization (default is \*(L"simple\*(R"). This informs the
verifier of the type of canonicalization used to prepare the message for
signing.
.SS "\fIdomain()\fP"
.IX Subsection "domain()"
Get or set the domain (d=) field.
.PP
.Vb 2
\&  my $d = $signature\->domain;          # gets the domain value
\&  $signature\->domain("example.org");   # sets the domain value
.Ve
.PP
The domain of the signing entity, as specified in the signature.
This is the domain that will be queried for the public key.
.SS "\fIheaderlist()\fP"
.IX Subsection "headerlist()"
Get or set the signed header fields (h=) field.
.PP
.Vb 1
\&  $signature\->headerlist("a:b:c");
\&
\&  my $headerlist = $signature\->headerlist;
\&
\&  my @headers = $signature\->headerlist;
.Ve
.PP
Signed header fields. A colon-separated list of header field names
that identify the header fields presented to the signing algorithm.
.PP
In scalar context, the list of header field names will be returned
as a single string, with the names joined together with colons.
In list context, the header field names will be returned as a list.
.SS "\fIidentity()\fP"
.IX Subsection "identity()"
Get the signing identity.
.PP
.Vb 1
\&  my $i = $signature\->identity;
.Ve
.PP
In DomainKey signatures, the signing identity is the first address
found in the Sender header or the From header. This field is
populated by the Verifier when processing a DomainKey signature.
.SS "\fIidentity_source()\fP"
.IX Subsection "identity_source()"
Determine which header had the identity.
.PP
.Vb 1
\&  my $source = $signature\->identity_source;
.Ve
.PP
If the message is being verified, this method will tell you which
of the message headers was used to determine the signature identity.
Possible values are \*(L"header.sender\*(R" and \*(L"header.from\*(R".
.SS "\fIprotocol()\fP"
.IX Subsection "protocol()"
Get or set the query methods (q=) field.
.PP
A colon-separated list of query methods used to retrieve the public
key (default is \*(L"dns\*(R").
.SS "\fIselector()\fP"
.IX Subsection "selector()"
Get or set the selector (s=) field.
.PP
The selector subdivides the namespace for the \*(L"d=\*(R" (domain) tag.
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Get or set the signature data (b=) field.
.PP
The signature data. Whitespace is automatically stripped from the
returned value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::Signature for DKIM-Signature headers
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007,2010 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkimPolicy.3pm                   0100644 0001750 0001750 00000021427 12566242060 025166  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkimPolicy 3"
.TH Mail::DKIM::DkimPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkimPolicy \- represents a DKIM Sender Signing Practices record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Sender Signing Practices (\s-1SSP\s0) record can be published by any
domain to help a receiver know what to do when it encounters an unsigned
message claiming to originate from that domain.
.PP
The record is published as a \s-1DNS TXT\s0 record at _policy._domainkey.DOMAIN
where \s-1DOMAIN\s0 is the domain of the message's \*(L"From\*(R" address.
.PP
This record format has been superceded by \s-1ADSP.\s0 See
Mail::DKIM::AuthorDomainPolicy for information about \s-1ADSP.\s0
It is implemented here because at one time it appeared this is what
would be standardized by the \s-1IETF.\s0 It will be removed from Mail::DKIM
at some point in the future.
The last version of the \s-1SSP\s0 specification can be found at
<http://tools.ietf.org/html/draft\-ietf\-dkim\-ssp\-02>.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP"
.IX Subsection "fetch()"
Lookup a \s-1DKIM\s0 signing practices record.
.PP
.Vb 4
\&  my $policy = Mail::DKIM::DkimPolicy\->fetch(
\&            Protocol => "dns",
\&            Author => \*(Aqjsmith@example.org\*(Aq,
\&          );
.Ve
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct a default policy object.
.PP
.Vb 1
\&  my $policy = Mail::DKIM::DkimPolicy\->new;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
It can be considered very suspicious.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered somewhat suspicious.
.SS "\fIflags()\fP"
.IX Subsection "flags()"
Get or set the flags (t=) tag.
.PP
A colon-separated list of flags. Flag values are:
.IP "y" 4
.IX Item "y"
The entity is testing signing practices, and the Verifier
\&\s-1SHOULD NOT\s0 consider a message suspicious based on the record.
.IP "s" 4
.IX Item "s"
The signing practices apply only to the named domain, and
not to subdomains.
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Is this policy implied?
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Where the policy was fetched from.
.PP
If the policy is domain-wide, this will be domain where the policy was
published.
.PP
If the policy is user-specific, \s-1TBD.\s0
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIpolicy()\fP"
.IX Subsection "policy()"
Get or set the outbound signing policy (dkim=) tag.
.PP
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
The default. The entity may sign some or all email.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
All mail from the entity is signed.
(The \s-1DKIM\s0 signature can use any domain, not necessarily matching
the From: address.)
.ie n .IP """strict""" 4
.el .IP "\f(CWstrict\fR" 4
.IX Item "strict"
All mail from the entity is signed with Originator signatures.
(The \s-1DKIM\s0 signature uses a domain matching the From: address.)
.SS "\fIsignall()\fP"
.IX Subsection "signall()"
True if policy is \*(L"all\*(R".
.SS "\fIsignall_strict()\fP"
.IX Subsection "signall_strict()"
True if policy is \*(L"strict\*(R".
.SS "\fItesting()\fP"
.IX Subsection "testing()"
Checks the testing flag.
.PP
.Vb 1
\&  my $testing = $policy\->testing;
.Ve
.PP
If nonzero, the testing flag is set on the signing policy, and the
verify should not consider a message suspicious based on this policy.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
If a sender signing policy is not found for a given domain, the
\&\fIfetch()\fR method should search the parent domains, according to
section 4 of the dkim-ssp Internet Draft.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkimPolicy5.16.3pm               0100644 0001750 0001750 00000021206 12566242072 025476  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkimPolicy 3"
.TH Mail::DKIM::DkimPolicy 3 "2009-07-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkimPolicy \- represents a DKIM Sender Signing Practices record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Sender Signing Practices (\s-1SSP\s0) record can be published by any
domain to help a receiver know what to do when it encounters an unsigned
message claiming to originate from that domain.
.PP
The record is published as a \s-1DNS\s0 \s-1TXT\s0 record at _policy._domainkey.DOMAIN
where \s-1DOMAIN\s0 is the domain of the message's \*(L"From\*(R" address.
.PP
This record format has been superceded by \s-1ADSP\s0. See
Mail::DKIM::AuthorDomainPolicy for information about \s-1ADSP\s0.
It is implemented here because at one time it appeared this is what
would be standardized by the \s-1IETF\s0. It will be removed from Mail::DKIM
at some point in the future.
The last version of the \s-1SSP\s0 specification can be found at
http://tools.ietf.org/html/draft\-ietf\-dkim\-ssp\-02 <http://tools.ietf.org/html/draft-ietf-dkim-ssp-02>.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP"
.IX Subsection "fetch()"
Lookup a \s-1DKIM\s0 signing practices record.
.PP
.Vb 4
\&  my $policy = Mail::DKIM::DkimPolicy\->fetch(
\&            Protocol => "dns",
\&            Author => \*(Aqjsmith@example.org\*(Aq,
\&          );
.Ve
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct a default policy object.
.PP
.Vb 1
\&  my $policy = Mail::DKIM::DkimPolicy\->new;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
It can be considered very suspicious.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered somewhat suspicious.
.SS "\fIflags()\fP"
.IX Subsection "flags()"
Get or set the flags (t=) tag.
.PP
A colon-separated list of flags. Flag values are:
.IP "y" 4
.IX Item "y"
The entity is testing signing practices, and the Verifier
\&\s-1SHOULD\s0 \s-1NOT\s0 consider a message suspicious based on the record.
.IP "s" 4
.IX Item "s"
The signing practices apply only to the named domain, and
not to subdomains.
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Is this policy implied?
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Where the policy was fetched from.
.PP
If the policy is domain-wide, this will be domain where the policy was
published.
.PP
If the policy is user-specific, \s-1TBD\s0.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIpolicy()\fP"
.IX Subsection "policy()"
Get or set the outbound signing policy (dkim=) tag.
.PP
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
The default. The entity may sign some or all email.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
All mail from the entity is signed.
(The \s-1DKIM\s0 signature can use any domain, not necessarily matching
the From: address.)
.ie n .IP """strict""" 4
.el .IP "\f(CWstrict\fR" 4
.IX Item "strict"
All mail from the entity is signed with Originator signatures.
(The \s-1DKIM\s0 signature uses a domain matching the From: address.)
.SS "\fIsignall()\fP"
.IX Subsection "signall()"
True if policy is \*(L"all\*(R".
.SS "\fIsignall_strict()\fP"
.IX Subsection "signall_strict()"
True if policy is \*(L"strict\*(R".
.SS "\fItesting()\fP"
.IX Subsection "testing()"
Checks the testing flag.
.PP
.Vb 1
\&  my $testing = $policy\->testing;
.Ve
.PP
If nonzero, the testing flag is set on the signing policy, and the
verify should not consider a message suspicious based on this policy.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
If a sender signing policy is not found for a given domain, the
\&\fIfetch()\fR method should search the parent domains, according to
section 4 of the dkim-ssp Internet Draft.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::DkimPolicy5.18.3pm               0100644 0001750 0001750 00000021427 12566242060 025502  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::DkimPolicy 3"
.TH Mail::DKIM::DkimPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::DkimPolicy \- represents a DKIM Sender Signing Practices record
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Sender Signing Practices (\s-1SSP\s0) record can be published by any
domain to help a receiver know what to do when it encounters an unsigned
message claiming to originate from that domain.
.PP
The record is published as a \s-1DNS TXT\s0 record at _policy._domainkey.DOMAIN
where \s-1DOMAIN\s0 is the domain of the message's \*(L"From\*(R" address.
.PP
This record format has been superceded by \s-1ADSP.\s0 See
Mail::DKIM::AuthorDomainPolicy for information about \s-1ADSP.\s0
It is implemented here because at one time it appeared this is what
would be standardized by the \s-1IETF.\s0 It will be removed from Mail::DKIM
at some point in the future.
The last version of the \s-1SSP\s0 specification can be found at
<http://tools.ietf.org/html/draft\-ietf\-dkim\-ssp\-02>.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fIfetch()\fP"
.IX Subsection "fetch()"
Lookup a \s-1DKIM\s0 signing practices record.
.PP
.Vb 4
\&  my $policy = Mail::DKIM::DkimPolicy\->fetch(
\&            Protocol => "dns",
\&            Author => \*(Aqjsmith@example.org\*(Aq,
\&          );
.Ve
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct a default policy object.
.PP
.Vb 1
\&  my $policy = Mail::DKIM::DkimPolicy\->new;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
It can be considered very suspicious.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered somewhat suspicious.
.SS "\fIflags()\fP"
.IX Subsection "flags()"
Get or set the flags (t=) tag.
.PP
A colon-separated list of flags. Flag values are:
.IP "y" 4
.IX Item "y"
The entity is testing signing practices, and the Verifier
\&\s-1SHOULD NOT\s0 consider a message suspicious based on the record.
.IP "s" 4
.IX Item "s"
The signing practices apply only to the named domain, and
not to subdomains.
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Is this policy implied?
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Where the policy was fetched from.
.PP
If the policy is domain-wide, this will be domain where the policy was
published.
.PP
If the policy is user-specific, \s-1TBD.\s0
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIpolicy()\fP"
.IX Subsection "policy()"
Get or set the outbound signing policy (dkim=) tag.
.PP
.Vb 1
\&  my $sp = $policy\->policy;
.Ve
.PP
Outbound signing policy for the entity. Possible values are:
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
The default. The entity may sign some or all email.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
All mail from the entity is signed.
(The \s-1DKIM\s0 signature can use any domain, not necessarily matching
the From: address.)
.ie n .IP """strict""" 4
.el .IP "\f(CWstrict\fR" 4
.IX Item "strict"
All mail from the entity is signed with Originator signatures.
(The \s-1DKIM\s0 signature uses a domain matching the From: address.)
.SS "\fIsignall()\fP"
.IX Subsection "signall()"
True if policy is \*(L"all\*(R".
.SS "\fIsignall_strict()\fP"
.IX Subsection "signall_strict()"
True if policy is \*(L"strict\*(R".
.SS "\fItesting()\fP"
.IX Subsection "testing()"
Checks the testing flag.
.PP
.Vb 1
\&  my $testing = $policy\->testing;
.Ve
.PP
If nonzero, the testing flag is set on the signing policy, and the
verify should not consider a message suspicious based on this policy.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
If a sender signing policy is not found for a given domain, the
\&\fIfetch()\fR method should search the parent domains, according to
section 4 of the dkim-ssp Internet Draft.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Policy.3pm                       0100644 0001750 0001750 00000016621 12566242060 024361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Policy 3"
.TH Mail::DKIM::Policy 3 "2013-02-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Policy \- abstract base class for originator "signing" policies
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # get all policies that apply to a verified message
\&  foreach my $policy ($dkim\->policies)
\&  {
\&
\&      # the name of this policy
\&      my $name = $policy\->name;
\&
\&      # the location in DNS where this policy was found
\&      my $location = $policy\->location;
\&
\&      # apply this policy to the message being verified
\&      my $result = $policy\->apply($dkim);
\&
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Between the various versions of the DomainKeys/DKIM standards, several
different forms of sender \*(L"signing\*(R" policies have been defined.
In order for the Mail::DKIM library to support these different
policies, it uses several different subclasses. All subclasses support
this general interface, so that a program using Mail::DKIM can
support any and all policies found for a message.
.SH "METHODS"
.IX Header "METHODS"
These methods are supported by all classes implementing the
Mail::DKIM::Policy interface.
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered suspicious.
.SS "\fIas_string()\fP"
.IX Subsection "as_string()"
The policy as a string.
.PP
Note that the string returned by this method will not necessarily have
the tags ordered the same as the text record found in \s-1DNS.\s0
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Is this policy implied?
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Where the policy was fetched from.
.PP
This is generally a domain name, the domain name where the policy
was published.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIname()\fP"
.IX Subsection "name()"
Identify what type of policy this is.
.PP
This currently returns strings like \*(L"sender\*(R", \*(L"author\*(R", and \*(L"\s-1ADSP\*(R".\s0
It is subject to change in the next version of Mail::DKIM.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::DkPolicy \- for \s-1RFC4870\s0(historical) DomainKeys
sender signing policies
.PP
Mail::DKIM::DkimPolicy \- for early draft \s-1DKIM\s0 sender signing policies
.PP
Mail::DKIM::AuthorDomainPolicy \- for Author Domain Signing Practices
(\s-1ADSP\s0)
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Policy5.16.3pm                   0100644 0001750 0001750 00000016300 12566242072 024670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Policy 3"
.TH Mail::DKIM::Policy 3 "2010-01-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Policy \- abstract base class for originator "signing" policies
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # get all policies that apply to a verified message
\&  foreach my $policy ($dkim\->policies)
\&  {
\&
\&      # the name of this policy
\&      my $name = $policy\->name;
\&
\&      # the location in DNS where this policy was found
\&      my $location = $policy\->location;
\&
\&      # apply this policy to the message being verified
\&      my $result = $policy\->apply($dkim);
\&
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Between the various versions of the DomainKeys/DKIM standards, several
different forms of sender \*(L"signing\*(R" policies have been defined.
In order for the Mail::DKIM library to support these different
policies, it uses several different subclasses. All subclasses support
this general interface, so that a program using Mail::DKIM can
support any and all policies found for a message.
.SH "METHODS"
.IX Header "METHODS"
These methods are supported by all classes implementing the
Mail::DKIM::Policy interface.
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered suspicious.
.SS "\fIas_string()\fP"
.IX Subsection "as_string()"
The policy as a string.
.PP
Note that the string returned by this method will not necessarily have
the tags ordered the same as the text record found in \s-1DNS\s0.
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Is this policy implied?
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Where the policy was fetched from.
.PP
This is generally a domain name, the domain name where the policy
was published.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIname()\fP"
.IX Subsection "name()"
Identify what type of policy this is.
.PP
This currently returns strings like \*(L"sender\*(R", \*(L"author\*(R", and \*(L"\s-1ADSP\s0\*(R".
It is subject to change in the next version of Mail::DKIM.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::DkPolicy \- for \s-1RFC4870\s0(historical) DomainKeys
sender signing policies
.PP
Mail::DKIM::DkimPolicy \- for early draft \s-1DKIM\s0 sender signing policies
.PP
Mail::DKIM::AuthorDomainPolicy \- for Author Domain Signing Practices
(\s-1ADSP\s0)
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Policy5.18.3pm                   0100644 0001750 0001750 00000016621 12566242060 024675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Policy 3"
.TH Mail::DKIM::Policy 3 "2013-02-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Policy \- abstract base class for originator "signing" policies
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # get all policies that apply to a verified message
\&  foreach my $policy ($dkim\->policies)
\&  {
\&
\&      # the name of this policy
\&      my $name = $policy\->name;
\&
\&      # the location in DNS where this policy was found
\&      my $location = $policy\->location;
\&
\&      # apply this policy to the message being verified
\&      my $result = $policy\->apply($dkim);
\&
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Between the various versions of the DomainKeys/DKIM standards, several
different forms of sender \*(L"signing\*(R" policies have been defined.
In order for the Mail::DKIM library to support these different
policies, it uses several different subclasses. All subclasses support
this general interface, so that a program using Mail::DKIM can
support any and all policies found for a message.
.SH "METHODS"
.IX Header "METHODS"
These methods are supported by all classes implementing the
Mail::DKIM::Policy interface.
.SS "\fIapply()\fP"
.IX Subsection "apply()"
Apply the policy to the results of a \s-1DKIM\s0 verifier.
.PP
.Vb 1
\&  my $result = $policy\->apply($dkim_verifier);
.Ve
.PP
The caller must provide an instance of Mail::DKIM::Verifier, one which
has already been fed the message being verified.
.PP
Possible results are:
.IP "accept" 4
.IX Item "accept"
The message is approved by the sender signing policy.
.IP "reject" 4
.IX Item "reject"
The message is rejected by the sender signing policy.
.IP "neutral" 4
.IX Item "neutral"
The message is neither approved nor rejected by the sender signing
policy. It can be considered suspicious.
.SS "\fIas_string()\fP"
.IX Subsection "as_string()"
The policy as a string.
.PP
Note that the string returned by this method will not necessarily have
the tags ordered the same as the text record found in \s-1DNS.\s0
.SS "\fIis_implied_default_policy()\fP"
.IX Subsection "is_implied_default_policy()"
Is this policy implied?
.PP
.Vb 1
\&  my $is_implied = $policy\->is_implied_default_policy;
.Ve
.PP
If you fetch the policy for a particular domain, but that domain
does not have a policy published, then the \*(L"default policy\*(R" is
in effect. Use this method to detect when that happens.
.SS "\fIlocation()\fP"
.IX Subsection "location()"
Where the policy was fetched from.
.PP
This is generally a domain name, the domain name where the policy
was published.
.PP
If nothing is published for the domain, and the default policy
was returned instead, the location will be \f(CW\*(C`undef\*(C'\fR.
.SS "\fIname()\fP"
.IX Subsection "name()"
Identify what type of policy this is.
.PP
This currently returns strings like \*(L"sender\*(R", \*(L"author\*(R", and \*(L"\s-1ADSP\*(R".\s0
It is subject to change in the next version of Mail::DKIM.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::DkPolicy \- for \s-1RFC4870\s0(historical) DomainKeys
sender signing policies
.PP
Mail::DKIM::DkimPolicy \- for early draft \s-1DKIM\s0 sender signing policies
.PP
Mail::DKIM::AuthorDomainPolicy \- for Author Domain Signing Practices
(\s-1ADSP\s0)
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::PrivateKey.3pm                   0100644 0001750 0001750 00000014127 12566242060 025204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::PrivateKey 3"
.TH Mail::DKIM::PrivateKey 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::PrivateKey \- a private key loaded in memory for DKIM signing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my $key1 = Mail::DKIM::PrivateKey\->load(
\&               File => "/path/to/private.key");
\&
\& my $key2 = Mail::DKIM::PrivateKey\->load(
\&               Data => $base64);
\&
\& # use the loaded key in a DKIM signing object
\& my $dkim = Mail::DKIM::Signer\->new(
\&               Key => $key2,
\&             );
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fIload()\fP \- loads a private key into memory"
.IX Subsection "load() - loads a private key into memory"
.Vb 2
\& my $key1 = Mail::DKIM::PrivateKey\->load(
\&               File => "/path/to/private.key");
.Ve
.PP
Loads the Base64\-encoded key from the specified file.
.PP
.Vb 1
\&  my $key2 = Mail::DKIM::PrivateKey\->load(Data => $base64);
.Ve
.PP
Loads the Base64\-encoded key from a string already in memory.
.PP
.Vb 1
\&  my $key3 = Mail::DKIM::PrivateKey\->load(Cork => $openssl_object);
.Ve
.PP
Creates a Mail::DKIM::PrivateKey wrapper object for the given
OpenSSL key object. The key object should be of type
Crypt::OpenSSL::RSA.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIcork()\fP \- access the underlying OpenSSL key object"
.IX Subsection "cork() - access the underlying OpenSSL key object"
.Vb 1
\&  $openssl_object = $key\->cork;
.Ve
.PP
The returned object is of type Crypt::OpenSSL::RSA.
.SS "\fIsign_digest()\fP"
.IX Subsection "sign_digest()"
Cryptographically sign the given message digest.
.PP
.Vb 1
\&  $key\->sign_digest("SHA\-1", sha1("my message text"));
.Ve
.PP
The first parameter is the name of the digest: one of \*(L"\s-1SHA\-1\*(R", \*(L"SHA\-256\*(R".\s0
.PP
The second parameter is the message digest as a binary string.
.PP
The result should be the signed digest as a binary string.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2008 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::PrivateKey5.16.3pm               0100644 0001750 0001750 00000013615 12566242072 025522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::PrivateKey 3"
.TH Mail::DKIM::PrivateKey 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::PrivateKey \- a private key loaded in memory for DKIM signing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my $key1 = Mail::DKIM::PrivateKey\->load(
\&               File => "/path/to/private.key");
\&
\& my $key2 = Mail::DKIM::PrivateKey\->load(
\&               Data => $base64);
\&
\& # use the loaded key in a DKIM signing object
\& my $dkim = Mail::DKIM::Signer\->new(
\&               Key => $key2,
\&             );
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fIload()\fP \- loads a private key into memory"
.IX Subsection "load() - loads a private key into memory"
.Vb 2
\& my $key1 = Mail::DKIM::PrivateKey\->load(
\&               File => "/path/to/private.key");
.Ve
.PP
Loads the Base64\-encoded key from the specified file.
.PP
.Vb 1
\&  my $key2 = Mail::DKIM::PrivateKey\->load(Data => $base64);
.Ve
.PP
Loads the Base64\-encoded key from a string already in memory.
.PP
.Vb 1
\&  my $key3 = Mail::DKIM::PrivateKey\->load(Cork => $openssl_object);
.Ve
.PP
Creates a Mail::DKIM::PrivateKey wrapper object for the given
OpenSSL key object. The key object should be of type
Crypt::OpenSSL::RSA.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIcork()\fP \- access the underlying OpenSSL key object"
.IX Subsection "cork() - access the underlying OpenSSL key object"
.Vb 1
\&  $openssl_object = $key\->cork;
.Ve
.PP
The returned object is of type Crypt::OpenSSL::RSA.
.SS "\fIsign_digest()\fP"
.IX Subsection "sign_digest()"
Cryptographically sign the given message digest.
.PP
.Vb 1
\&  $key\->sign_digest("SHA\-1", sha1("my message text"));
.Ve
.PP
The first parameter is the name of the digest: one of \*(L"\s-1SHA\-1\s0\*(R", \*(L"\s-1SHA\-256\s0\*(R".
.PP
The second parameter is the message digest as a binary string.
.PP
The result should be the signed digest as a binary string.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2008 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::PrivateKey5.18.3pm               0100644 0001750 0001750 00000014127 12566242060 025520  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::PrivateKey 3"
.TH Mail::DKIM::PrivateKey 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::PrivateKey \- a private key loaded in memory for DKIM signing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my $key1 = Mail::DKIM::PrivateKey\->load(
\&               File => "/path/to/private.key");
\&
\& my $key2 = Mail::DKIM::PrivateKey\->load(
\&               Data => $base64);
\&
\& # use the loaded key in a DKIM signing object
\& my $dkim = Mail::DKIM::Signer\->new(
\&               Key => $key2,
\&             );
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fIload()\fP \- loads a private key into memory"
.IX Subsection "load() - loads a private key into memory"
.Vb 2
\& my $key1 = Mail::DKIM::PrivateKey\->load(
\&               File => "/path/to/private.key");
.Ve
.PP
Loads the Base64\-encoded key from the specified file.
.PP
.Vb 1
\&  my $key2 = Mail::DKIM::PrivateKey\->load(Data => $base64);
.Ve
.PP
Loads the Base64\-encoded key from a string already in memory.
.PP
.Vb 1
\&  my $key3 = Mail::DKIM::PrivateKey\->load(Cork => $openssl_object);
.Ve
.PP
Creates a Mail::DKIM::PrivateKey wrapper object for the given
OpenSSL key object. The key object should be of type
Crypt::OpenSSL::RSA.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIcork()\fP \- access the underlying OpenSSL key object"
.IX Subsection "cork() - access the underlying OpenSSL key object"
.Vb 1
\&  $openssl_object = $key\->cork;
.Ve
.PP
The returned object is of type Crypt::OpenSSL::RSA.
.SS "\fIsign_digest()\fP"
.IX Subsection "sign_digest()"
Cryptographically sign the given message digest.
.PP
.Vb 1
\&  $key\->sign_digest("SHA\-1", sha1("my message text"));
.Ve
.PP
The first parameter is the name of the digest: one of \*(L"\s-1SHA\-1\*(R", \*(L"SHA\-256\*(R".\s0
.PP
The second parameter is the message digest as a binary string.
.PP
The result should be the signed digest as a binary string.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2008 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::PublicKey.3pm                    0100644 0001750 0001750 00000012535 12566242060 025011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::PublicKey 3"
.TH Mail::DKIM::PublicKey 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fIfetch()\fP \- retrieve a public key record from \s-1DNS\s0"
.IX Subsection "fetch() - retrieve a public key record from DNS"
.Vb 5
\&  my $public_key = Mail::DKIM::PublicKey\->fetch(
\&                      Protocol => "dns",
\&                      Selector => "brisbane",
\&                      Domain => "example.com",
\&                    );
.Ve
.PP
If the public key is found, a Mail::DKIM::PublicKey object
is returned, representing the information found in \s-1DNS.\s0
If the public key does not exist in \s-1DNS,\s0 then \f(CW\*(C`undef\*(C'\fR is
returned.
If a \s-1DNS\s0 error occurs while fetching the key, then this method
will \f(CW\*(C`die\*(C'\fR.
If the public key was found, but is not valid (e.g. it is \*(L"revoked\*(R"),
then this method will \f(CW\*(C`die\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIgranularity()\fP \- get or set the granularity (g=) field"
.IX Subsection "granularity() - get or set the granularity (g=) field"
.Vb 1
\&  my $g = $public_key\->granularity;
\&
\&  $public_key\->granularity("*");
.Ve
.PP
Granularity of the key. The value must match the Local-part of the
effective \*(L"i=\*(R" tag of the DKIM-Signature header field.
The granularity is a literal value, or a pattern with a single '*'
wildcard character that matches zero or more characters.
.PP
If no granularity is defined, then the default value, '*', will
be returned.
                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::PublicKey5.16.3pm                0100644 0001750 0001750 00000012214 12566242072 025320  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::PublicKey 3"
.TH Mail::DKIM::PublicKey 3 "2010-01-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fIfetch()\fP \- retrieve a public key record from \s-1DNS\s0"
.IX Subsection "fetch() - retrieve a public key record from DNS"
.Vb 5
\&  my $public_key = Mail::DKIM::PublicKey\->fetch(
\&                      Protocol => "dns",
\&                      Selector => "brisbane",
\&                      Domain => "example.com",
\&                    );
.Ve
.PP
If the public key is found, a Mail::DKIM::PublicKey object
is returned, representing the information found in \s-1DNS\s0.
If the public key does not exist in \s-1DNS\s0, then \f(CW\*(C`undef\*(C'\fR is
returned.
If a \s-1DNS\s0 error occurs while fetching the key, then this method
will \f(CW\*(C`die\*(C'\fR.
If the public key was found, but is not valid (e.g. it is \*(L"revoked\*(R"),
then this method will \f(CW\*(C`die\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIgranularity()\fP \- get or set the granularity (g=) field"
.IX Subsection "granularity() - get or set the granularity (g=) field"
.Vb 1
\&  my $g = $public_key\->granularity;
\&
\&  $public_key\->granularity("*");
.Ve
.PP
Granularity of the key. The value must match the Local-part of the
effective \*(L"i=\*(R" tag of the DKIM-Signature header field.
The granularity is a literal value, or a pattern with a single '*'
wildcard character that matches zero or more characters.
.PP
If no granularity is defined, then the default value, '*', will
be returned.
                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::PublicKey5.18.3pm                0100644 0001750 0001750 00000012535 12566242060 025325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::PublicKey 3"
.TH Mail::DKIM::PublicKey 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fIfetch()\fP \- retrieve a public key record from \s-1DNS\s0"
.IX Subsection "fetch() - retrieve a public key record from DNS"
.Vb 5
\&  my $public_key = Mail::DKIM::PublicKey\->fetch(
\&                      Protocol => "dns",
\&                      Selector => "brisbane",
\&                      Domain => "example.com",
\&                    );
.Ve
.PP
If the public key is found, a Mail::DKIM::PublicKey object
is returned, representing the information found in \s-1DNS.\s0
If the public key does not exist in \s-1DNS,\s0 then \f(CW\*(C`undef\*(C'\fR is
returned.
If a \s-1DNS\s0 error occurs while fetching the key, then this method
will \f(CW\*(C`die\*(C'\fR.
If the public key was found, but is not valid (e.g. it is \*(L"revoked\*(R"),
then this method will \f(CW\*(C`die\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIgranularity()\fP \- get or set the granularity (g=) field"
.IX Subsection "granularity() - get or set the granularity (g=) field"
.Vb 1
\&  my $g = $public_key\->granularity;
\&
\&  $public_key\->granularity("*");
.Ve
.PP
Granularity of the key. The value must match the Local-part of the
effective \*(L"i=\*(R" tag of the DKIM-Signature header field.
The granularity is a literal value, or a pattern with a single '*'
wildcard character that matches zero or more characters.
.PP
If no granularity is defined, then the default value, '*', will
be returned.
                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Signature.3pm                    0100644 0001750 0001750 00000041477 12566242060 025072  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Signature 3"
.TH Mail::DKIM::Signature 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Signature \- represents a DKIM\-Signature header
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fInew()\fP \- create a new signature from parameters"
.IX Subsection "new() - create a new signature from parameters"
.Vb 12
\&  my $signature = Mail::DKIM::Signature\->new(
\&                      [ Algorithm => "rsa\-sha1", ]
\&                      [ Signature => $base64, ]
\&                      [ Method => "relaxed", ]
\&                      [ Domain => "example.org", ]
\&                      [ Identity => \*(Aquser@example.org\*(Aq, ]
\&                      [ Headers => "from:subject:date:message\-id", ]
\&                      [ Query => "dns", ]
\&                      [ Selector => "alpha", ]
\&                      [ Timestamp => time(), ]
\&                      [ Expiration => time() + 86400, ]
\&                  );
.Ve
.SS "\fIparse()\fP \- create a new signature from a DKIM-Signature header"
.IX Subsection "parse() - create a new signature from a DKIM-Signature header"
.Vb 3
\&  my $sig = Mail::DKIM::Signature\->parse(
\&                  "DKIM\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=relaxed"
\&            );
.Ve
.PP
Constructs a signature by parsing the provided DKIM-Signature header
content. You do not have to include the header name (i.e. \*(L"DKIM-Signature:\*(R")
but it is recommended, so the header name can be preserved and returned
the same way in \fIas_string()\fR.
.PP
Note: The input to this constructor is in the same format as the output
of the as_string method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIalgorithm()\fP \- get or set the algorithm (a=) field"
.IX Subsection "algorithm() - get or set the algorithm (a=) field"
The algorithm used to generate the signature. Should be either \*(L"rsa\-sha1\*(R",
an RSA-signed \s-1SHA\-1\s0 digest, or \*(L"rsa\-sha256\*(R", an RSA-signed \s-1SHA\-256\s0 digest.
.PP
See also \fIhash_algorithm()\fR.
.SS "\fIas_string()\fP \- the signature header as a string"
.IX Subsection "as_string() - the signature header as a string"
.Vb 1
\&  print $signature\->as_string . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DKIM\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=relaxed
.Ve
.PP
As shown in the example, the as_string method can be used to generate
the DKIM-Signature that gets prepended to a signed message.
.SS "\fIas_string_without_data()\fP \- signature without the signature data"
.IX Subsection "as_string_without_data() - signature without the signature data"
.Vb 1
\&  print $signature\->as_string_without_data . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DKIM\-Signature: a=rsa\-sha1; b=; c=relaxed
.Ve
.PP
This is similar to the \fIas_string()\fR method, but it always excludes the \*(L"data\*(R"
part. This is used by the \s-1DKIM\s0 canonicalization methods, which require
incorporating this part of the signature into the signed message.
.SS "\fIbody_count()\fP \- get or set the body count (l=) field"
.IX Subsection "body_count() - get or set the body count (l=) field"
.Vb 1
\&  my $i = $signature\->body_count;
.Ve
.PP
Informs the verifier of the number of bytes in the body of the email
included in the cryptographic hash, starting from 0 immediately
following the \s-1CRLF\s0 preceding the body. Also known as the l= tag.
.PP
When creating a signature, this tag may be either omitted, or set after
the selected canonicalization system has received the entire message
body (but before it canonicalizes the DKIM-Signature).
.SS "\fIbody_hash()\fP \- get or set the body hash (bh=) field"
.IX Subsection "body_hash() - get or set the body hash (bh=) field"
.Vb 1
\&  my $bh = $signature\->body_hash;
.Ve
.PP
The hash of the body part of the message. Whitespace is ignored in this
value. This tag is required.
.PP
When accessing this value, whitespace is stripped from the tag for you.
.SS "\fIcanonicalization()\fP \- get or set the canonicalization (c=) field"
.IX Subsection "canonicalization() - get or set the canonicalization (c=) field"
.Vb 1
\&  $signature\->canonicalization("relaxed", "simple");
\&
\&  ($header, $body) = $signature\->canonicalization;
.Ve
.PP
Message canonicalization (default is \*(L"simple/simple\*(R"). This informs the
verifier of the type of canonicalization used to prepare the message for
signing.
.PP
In scalar context, this returns header/body canonicalization as a single
string separated by /. In list context, it returns a two element array,
containing first the header canonicalization, then the body.
.SS "\fIdata()\fP \- get or set the signature data (b=) field"
.IX Subsection "data() - get or set the signature data (b=) field"
.Vb 2
\&  my $base64 = $signature\->data;
\&  $signature\->data($base64);
.Ve
.PP
The signature data. Whitespace is automatically stripped from the
returned value. The data is Base64\-encoded.
.SS "\fIdomain()\fP \- get or set the domain (d=) field"
.IX Subsection "domain() - get or set the domain (d=) field"
.Vb 2
\&  my $d = $signature\->domain;          # gets the domain value
\&  $signature\->domain("example.org");   # sets the domain value
.Ve
.PP
The domain of the signing entity, as specified in the signature.
This is the domain that will be queried for the public key.
.PP
If using an \*(L"internationalized domain name\*(R", the domain name must be
converted to \s-1ASCII \s0(following section 4.1 of \s-1RFC 3490\s0) before passing
it to this method.
.SS "\fIexpiration()\fP \- get or set the signature expiration (x=) field"
.IX Subsection "expiration() - get or set the signature expiration (x=) field"
Signature expiration (default is undef, meaning no expiration).
The signature expiration, if defined, is an unsigned integer identifying
the standard Unix seconds\-since\-1970 time when the signature will
expire.
.SS "\fIget_public_key()\fP \- fetches the public key referenced by this signature"
.IX Subsection "get_public_key() - fetches the public key referenced by this signature"
.Vb 1
\&  my $pubkey = $signature\->get_public_key;
.Ve
.PP
Public key to fetch is determined by the protocol, selector, and domain
fields.
.PP
This method caches the result of the fetch, so subsequent calls will not
require additional \s-1DNS\s0 queries.
.PP
This method will \f(CW\*(C`die\*(C'\fR if an error occurs.
.SS "\fIget_tag()\fP \- access the raw value of a tag in this signature"
.IX Subsection "get_tag() - access the raw value of a tag in this signature"
.Vb 1
\&  my $raw_identity = $signature\->get_tag("i");
.Ve
.PP
Use this method to access a tag not already supported by Mail::DKIM,
or if you want to bypass decoding of the value by Mail::DKIM.
.PP
For example, the raw i= (identity) tag is encoded in quoted-printable
form. If you use the \fIidentity()\fR method, Mail::DKIM will decode from
quoted-printable before returning the value. But if you use
get_tag(\*(L"i\*(R"), you can access the encoded quoted-printable form of
the value.
.SS "\fIhash_algorithm()\fP \- access the hash algorithm specified in this signature"
.IX Subsection "hash_algorithm() - access the hash algorithm specified in this signature"
.Vb 1
\&  my $hash = $signature\->hash_algorithm;
.Ve
.PP
Determines what hashing algorithm is used as part of the signature's
specified algorithm.
.PP
For algorithm \*(L"rsa\-sha1\*(R", the hash algorithm is \*(L"sha1\*(R". Likewise, for
algorithm \*(L"rsa\-sha256\*(R", the hash algorithm is \*(L"sha256\*(R". If the algorithm
is not recognized, undef is returned.
.SS "\fIheaderlist()\fP \- get or set the signed header fields (h=) field"
.IX Subsection "headerlist() - get or set the signed header fields (h=) field"
.Vb 1
\&  $signature\->headerlist("a:b:c");
\&
\&  my $headerlist = $signature\->headerlist;
\&
\&  my @headers = $signature\->headerlist;
.Ve
.PP
Signed header fields. A colon-separated list of header field names
that identify the header fields presented to the signing algorithm.
.PP
In scalar context, the list of header field names will be returned
as a single string, with the names joined together with colons.
In list context, the header field names will be returned as a list.
.SS "\fIidentity()\fP \- get or set the signing identity (i=) field"
.IX Subsection "identity() - get or set the signing identity (i=) field"
.Vb 1
\&  my $i = $signature\->identity;
.Ve
.PP
Identity of the user or agent on behalf of which this message is signed.
The identity has an optional local part, followed by \*(L"@\*(R", then a domain
name. The domain name should be the same as or a subdomain of the
domain returned by the \f(CW\*(C`domain\*(C'\fR method.
.PP
Ideally, the identity should match the identity listed in the From:
header, or the Sender: header, but this is not required to have a
valid signature. Whether the identity used is \*(L"authorized\*(R" to sign
for the given message is not determined here.
.PP
If using an \*(L"internationalized domain name\*(R", the domain name must be
converted to \s-1ASCII \s0(following section 4.1 of \s-1RFC 3490\s0) before passing
it to this method.
.PP
Identity values are encoded in the signature in quoted-printable format.
Using this method will translate to/from quoted-printable as necessary.
If you want the raw quoted-printable version of the identity, use
\&\f(CW$signature\fR\->get_tag(\*(L"i\*(R").
.SS "\fIkey()\fP \- get or set the private key object"
.IX Subsection "key() - get or set the private key object"
.Vb 1
\&  my $key = $signature\->key;
\&
\&  $signature\->key(Mail::DKIM::PrivateKey\->load(File => "private.key"));
.Ve
.PP
The private key is used for signing messages.
It is not used for verifying messages.
.PP
The key object can be any object that implements the
\&\fIsign_digest()\fR method.
(Providing your own object can be useful if your actual keys
are stored out-of-process.)
.SS "\fImethod()\fP \- get or set the canonicalization (c=) field"
.IX Subsection "method() - get or set the canonicalization (c=) field"
Message canonicalization (default is \*(L"simple\*(R"). This informs the verifier
of the type of canonicalization used to prepare the message for signing.
.SS "\fIprotocol()\fP \- get or set the query methods (q=) field"
.IX Subsection "protocol() - get or set the query methods (q=) field"
A colon-separated list of query methods used to retrieve the public
key (default is \*(L"dns\*(R"). Each query method is of the form \*(L"type[/options]\*(R",
where the syntax and semantics of the options depends on the type.
.SS "\fIresult()\fP \- get or set the verification result"
.IX Subsection "result() - get or set the verification result"
.Vb 1
\&  my $result = $signature\->result;
\&
\&  $signature\->result("pass");
\&
\&  # to set the result with details
\&  $signature\->result("invalid", "no public key");
.Ve
.SS "\fIresult_detail()\fP \- access the result, plus details if available"
.IX Subsection "result_detail() - access the result, plus details if available"
.Vb 1
\&  my $detail = $signature\->result_detail;
.Ve
.PP
An explanation of possible detail messages can be found in the
documentation for \*(L"\fIresult_detail()\fR\*(R" in Mail::DKIM::Verifier.
.SS "\fIselector()\fP \- get or set the selector (s=) field"
.IX Subsection "selector() - get or set the selector (s=) field"
The selector subdivides the namespace for the \*(L"d=\*(R" (domain) tag.
.ie n .SS "\fIprettify()\fP \- alters the signature to look ""nicer"" as an email header"
.el .SS "\fIprettify()\fP \- alters the signature to look ``nicer'' as an email header"
.IX Subsection "prettify() - alters the signature to look nicer as an email header"
.Vb 1
\&  $signature\->prettify;
.Ve
.PP
This method may alter the signature in a way that breaks signatures, so
it should be done \s-1ONLY\s0 when the signature is being generated, \s-1BEFORE\s0 being
fed to the canonicalization algorithm.
.PP
See also \fIprettify_safe()\fR, which will not break signatures.
.SS "\fIprettify_safe()\fP \- same as \fIprettify()\fP but only touches the b= part"
.IX Subsection "prettify_safe() - same as prettify() but only touches the b= part"
.Vb 1
\&  $signature\->prettify_safe;
.Ve
.PP
This method will not break the signature, but it only affects the b= part
of the signature.
.SS "\fItimestamp()\fP \- get or set the signature timestamp (t=) field"
.IX Subsection "timestamp() - get or set the signature timestamp (t=) field"
Signature timestamp (default is undef, meaning unknown creation time).
This is the time that the signature was created. The value is an unsigned
integer identifying the number of standard Unix seconds\-since\-1970.
.SS "\fIversion()\fP \- get or set the \s-1DKIM\s0 specification version (v=) field"
.IX Subsection "version() - get or set the DKIM specification version (v=) field"
This is the version of the \s-1DKIM\s0 specification that applies to this
signature record.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::DkSignature for DomainKey-Signature headers
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Signature5.16.3pm                0100644 0001750 0001750 00000041156 12566242072 025401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Signature 3"
.TH Mail::DKIM::Signature 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Signature \- represents a DKIM\-Signature header
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fInew()\fP \- create a new signature from parameters"
.IX Subsection "new() - create a new signature from parameters"
.Vb 12
\&  my $signature = Mail::DKIM::Signature\->new(
\&                      [ Algorithm => "rsa\-sha1", ]
\&                      [ Signature => $base64, ]
\&                      [ Method => "relaxed", ]
\&                      [ Domain => "example.org", ]
\&                      [ Identity => \*(Aquser@example.org\*(Aq, ]
\&                      [ Headers => "from:subject:date:message\-id", ]
\&                      [ Query => "dns", ]
\&                      [ Selector => "alpha", ]
\&                      [ Timestamp => time(), ]
\&                      [ Expiration => time() + 86400, ]
\&                  );
.Ve
.SS "\fIparse()\fP \- create a new signature from a DKIM-Signature header"
.IX Subsection "parse() - create a new signature from a DKIM-Signature header"
.Vb 3
\&  my $sig = Mail::DKIM::Signature\->parse(
\&                  "DKIM\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=relaxed"
\&            );
.Ve
.PP
Constructs a signature by parsing the provided DKIM-Signature header
content. You do not have to include the header name (i.e. \*(L"DKIM-Signature:\*(R")
but it is recommended, so the header name can be preserved and returned
the same way in \fIas_string()\fR.
.PP
Note: The input to this constructor is in the same format as the output
of the as_string method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIalgorithm()\fP \- get or set the algorithm (a=) field"
.IX Subsection "algorithm() - get or set the algorithm (a=) field"
The algorithm used to generate the signature. Should be either \*(L"rsa\-sha1\*(R",
an RSA-signed \s-1SHA\-1\s0 digest, or \*(L"rsa\-sha256\*(R", an RSA-signed \s-1SHA\-256\s0 digest.
.PP
See also \fIhash_algorithm()\fR.
.SS "\fIas_string()\fP \- the signature header as a string"
.IX Subsection "as_string() - the signature header as a string"
.Vb 1
\&  print $signature\->as_string . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DKIM\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=relaxed
.Ve
.PP
As shown in the example, the as_string method can be used to generate
the DKIM-Signature that gets prepended to a signed message.
.SS "\fIas_string_without_data()\fP \- signature without the signature data"
.IX Subsection "as_string_without_data() - signature without the signature data"
.Vb 1
\&  print $signature\->as_string_without_data . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DKIM\-Signature: a=rsa\-sha1; b=; c=relaxed
.Ve
.PP
This is similar to the \fIas_string()\fR method, but it always excludes the \*(L"data\*(R"
part. This is used by the \s-1DKIM\s0 canonicalization methods, which require
incorporating this part of the signature into the signed message.
.SS "\fIbody_count()\fP \- get or set the body count (l=) field"
.IX Subsection "body_count() - get or set the body count (l=) field"
.Vb 1
\&  my $i = $signature\->body_count;
.Ve
.PP
Informs the verifier of the number of bytes in the body of the email
included in the cryptographic hash, starting from 0 immediately
following the \s-1CRLF\s0 preceding the body. Also known as the l= tag.
.PP
When creating a signature, this tag may be either omitted, or set after
the selected canonicalization system has received the entire message
body (but before it canonicalizes the DKIM-Signature).
.SS "\fIbody_hash()\fP \- get or set the body hash (bh=) field"
.IX Subsection "body_hash() - get or set the body hash (bh=) field"
.Vb 1
\&  my $bh = $signature\->body_hash;
.Ve
.PP
The hash of the body part of the message. Whitespace is ignored in this
value. This tag is required.
.PP
When accessing this value, whitespace is stripped from the tag for you.
.SS "\fIcanonicalization()\fP \- get or set the canonicalization (c=) field"
.IX Subsection "canonicalization() - get or set the canonicalization (c=) field"
.Vb 1
\&  $signature\->canonicalization("relaxed", "simple");
\&
\&  ($header, $body) = $signature\->canonicalization;
.Ve
.PP
Message canonicalization (default is \*(L"simple/simple\*(R"). This informs the
verifier of the type of canonicalization used to prepare the message for
signing.
.PP
In scalar context, this returns header/body canonicalization as a single
string separated by /. In list context, it returns a two element array,
containing first the header canonicalization, then the body.
.SS "\fIdata()\fP \- get or set the signature data (b=) field"
.IX Subsection "data() - get or set the signature data (b=) field"
.Vb 2
\&  my $base64 = $signature\->data;
\&  $signature\->data($base64);
.Ve
.PP
The signature data. Whitespace is automatically stripped from the
returned value. The data is Base64\-encoded.
.SS "\fIdomain()\fP \- get or set the domain (d=) field"
.IX Subsection "domain() - get or set the domain (d=) field"
.Vb 2
\&  my $d = $signature\->domain;          # gets the domain value
\&  $signature\->domain("example.org");   # sets the domain value
.Ve
.PP
The domain of the signing entity, as specified in the signature.
This is the domain that will be queried for the public key.
.PP
If using an \*(L"internationalized domain name\*(R", the domain name must be
converted to \s-1ASCII\s0 (following section 4.1 of \s-1RFC\s0 3490) before passing
it to this method.
.SS "\fIexpiration()\fP \- get or set the signature expiration (x=) field"
.IX Subsection "expiration() - get or set the signature expiration (x=) field"
Signature expiration (default is undef, meaning no expiration).
The signature expiration, if defined, is an unsigned integer identifying
the standard Unix seconds\-since\-1970 time when the signature will
expire.
.SS "\fIget_public_key()\fP \- fetches the public key referenced by this signature"
.IX Subsection "get_public_key() - fetches the public key referenced by this signature"
.Vb 1
\&  my $pubkey = $signature\->get_public_key;
.Ve
.PP
Public key to fetch is determined by the protocol, selector, and domain
fields.
.PP
This method caches the result of the fetch, so subsequent calls will not
require additional \s-1DNS\s0 queries.
.PP
This method will \f(CW\*(C`die\*(C'\fR if an error occurs.
.SS "\fIget_tag()\fP \- access the raw value of a tag in this signature"
.IX Subsection "get_tag() - access the raw value of a tag in this signature"
.Vb 1
\&  my $raw_identity = $signature\->get_tag("i");
.Ve
.PP
Use this method to access a tag not already supported by Mail::DKIM,
or if you want to bypass decoding of the value by Mail::DKIM.
.PP
For example, the raw i= (identity) tag is encoded in quoted-printable
form. If you use the \fIidentity()\fR method, Mail::DKIM will decode from
quoted-printable before returning the value. But if you use
get_tag(\*(L"i\*(R"), you can access the encoded quoted-printable form of
the value.
.SS "\fIhash_algorithm()\fP \- access the hash algorithm specified in this signature"
.IX Subsection "hash_algorithm() - access the hash algorithm specified in this signature"
.Vb 1
\&  my $hash = $signature\->hash_algorithm;
.Ve
.PP
Determines what hashing algorithm is used as part of the signature's
specified algorithm.
.PP
For algorithm \*(L"rsa\-sha1\*(R", the hash algorithm is \*(L"sha1\*(R". Likewise, for
algorithm \*(L"rsa\-sha256\*(R", the hash algorithm is \*(L"sha256\*(R". If the algorithm
is not recognized, undef is returned.
.SS "\fIheaderlist()\fP \- get or set the signed header fields (h=) field"
.IX Subsection "headerlist() - get or set the signed header fields (h=) field"
.Vb 1
\&  $signature\->headerlist("a:b:c");
\&
\&  my $headerlist = $signature\->headerlist;
\&
\&  my @headers = $signature\->headerlist;
.Ve
.PP
Signed header fields. A colon-separated list of header field names
that identify the header fields presented to the signing algorithm.
.PP
In scalar context, the list of header field names will be returned
as a single string, with the names joined together with colons.
In list context, the header field names will be returned as a list.
.SS "\fIidentity()\fP \- get or set the signing identity (i=) field"
.IX Subsection "identity() - get or set the signing identity (i=) field"
.Vb 1
\&  my $i = $signature\->identity;
.Ve
.PP
Identity of the user or agent on behalf of which this message is signed.
The identity has an optional local part, followed by \*(L"@\*(R", then a domain
name. The domain name should be the same as or a subdomain of the
domain returned by the \f(CW\*(C`domain\*(C'\fR method.
.PP
Ideally, the identity should match the identity listed in the From:
header, or the Sender: header, but this is not required to have a
valid signature. Whether the identity used is \*(L"authorized\*(R" to sign
for the given message is not determined here.
.PP
If using an \*(L"internationalized domain name\*(R", the domain name must be
converted to \s-1ASCII\s0 (following section 4.1 of \s-1RFC\s0 3490) before passing
it to this method.
.PP
Identity values are encoded in the signature in quoted-printable format.
Using this method will translate to/from quoted-printable as necessary.
If you want the raw quoted-printable version of the identity, use
\&\f(CW$signature\fR\->get_tag(\*(L"i\*(R").
.SS "\fIkey()\fP \- get or set the private key object"
.IX Subsection "key() - get or set the private key object"
.Vb 1
\&  my $key = $signature\->key;
\&
\&  $signature\->key(Mail::DKIM::PrivateKey\->load(File => "private.key"));
.Ve
.PP
The private key is used for signing messages.
It is not used for verifying messages.
.PP
The key object can be any object that implements the
\&\fIsign_digest()\fR method.
(Providing your own object can be useful if your actual keys
are stored out-of-process.)
.SS "\fImethod()\fP \- get or set the canonicalization (c=) field"
.IX Subsection "method() - get or set the canonicalization (c=) field"
Message canonicalization (default is \*(L"simple\*(R"). This informs the verifier
of the type of canonicalization used to prepare the message for signing.
.SS "\fIprotocol()\fP \- get or set the query methods (q=) field"
.IX Subsection "protocol() - get or set the query methods (q=) field"
A colon-separated list of query methods used to retrieve the public
key (default is \*(L"dns\*(R"). Each query method is of the form \*(L"type[/options]\*(R",
where the syntax and semantics of the options depends on the type.
.SS "\fIresult()\fP \- get or set the verification result"
.IX Subsection "result() - get or set the verification result"
.Vb 1
\&  my $result = $signature\->result;
\&
\&  $signature\->result("pass");
\&
\&  # to set the result with details
\&  $signature\->result("invalid", "no public key");
.Ve
.SS "\fIresult_detail()\fP \- access the result, plus details if available"
.IX Subsection "result_detail() - access the result, plus details if available"
.Vb 1
\&  my $detail = $signature\->result_detail;
.Ve
.PP
An explanation of possible detail messages can be found in the
documentation for \*(L"\fIresult_detail()\fR\*(R" in Mail::DKIM::Verifier.
.SS "\fIselector()\fP \- get or set the selector (s=) field"
.IX Subsection "selector() - get or set the selector (s=) field"
The selector subdivides the namespace for the \*(L"d=\*(R" (domain) tag.
.ie n .SS "\fIprettify()\fP \- alters the signature to look ""nicer"" as an email header"
.el .SS "\fIprettify()\fP \- alters the signature to look ``nicer'' as an email header"
.IX Subsection "prettify() - alters the signature to look nicer as an email header"
.Vb 1
\&  $signature\->prettify;
.Ve
.PP
This method may alter the signature in a way that breaks signatures, so
it should be done \s-1ONLY\s0 when the signature is being generated, \s-1BEFORE\s0 being
fed to the canonicalization algorithm.
.PP
See also \fIprettify_safe()\fR, which will not break signatures.
.SS "\fIprettify_safe()\fP \- same as \fIprettify()\fP but only touches the b= part"
.IX Subsection "prettify_safe() - same as prettify() but only touches the b= part"
.Vb 1
\&  $signature\->prettify_safe;
.Ve
.PP
This method will not break the signature, but it only affects the b= part
of the signature.
.SS "\fItimestamp()\fP \- get or set the signature timestamp (t=) field"
.IX Subsection "timestamp() - get or set the signature timestamp (t=) field"
Signature timestamp (default is undef, meaning unknown creation time).
This is the time that the signature was created. The value is an unsigned
integer identifying the number of standard Unix seconds\-since\-1970.
.SS "\fIversion()\fP \- get or set the \s-1DKIM\s0 specification version (v=) field"
.IX Subsection "version() - get or set the DKIM specification version (v=) field"
This is the version of the \s-1DKIM\s0 specification that applies to this
signature record.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::DkSignature for DomainKey-Signature headers
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Signature5.18.3pm                0100644 0001750 0001750 00000041477 12566242060 025406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Signature 3"
.TH Mail::DKIM::Signature 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Signature \- represents a DKIM\-Signature header
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "\fInew()\fP \- create a new signature from parameters"
.IX Subsection "new() - create a new signature from parameters"
.Vb 12
\&  my $signature = Mail::DKIM::Signature\->new(
\&                      [ Algorithm => "rsa\-sha1", ]
\&                      [ Signature => $base64, ]
\&                      [ Method => "relaxed", ]
\&                      [ Domain => "example.org", ]
\&                      [ Identity => \*(Aquser@example.org\*(Aq, ]
\&                      [ Headers => "from:subject:date:message\-id", ]
\&                      [ Query => "dns", ]
\&                      [ Selector => "alpha", ]
\&                      [ Timestamp => time(), ]
\&                      [ Expiration => time() + 86400, ]
\&                  );
.Ve
.SS "\fIparse()\fP \- create a new signature from a DKIM-Signature header"
.IX Subsection "parse() - create a new signature from a DKIM-Signature header"
.Vb 3
\&  my $sig = Mail::DKIM::Signature\->parse(
\&                  "DKIM\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=relaxed"
\&            );
.Ve
.PP
Constructs a signature by parsing the provided DKIM-Signature header
content. You do not have to include the header name (i.e. \*(L"DKIM-Signature:\*(R")
but it is recommended, so the header name can be preserved and returned
the same way in \fIas_string()\fR.
.PP
Note: The input to this constructor is in the same format as the output
of the as_string method.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIalgorithm()\fP \- get or set the algorithm (a=) field"
.IX Subsection "algorithm() - get or set the algorithm (a=) field"
The algorithm used to generate the signature. Should be either \*(L"rsa\-sha1\*(R",
an RSA-signed \s-1SHA\-1\s0 digest, or \*(L"rsa\-sha256\*(R", an RSA-signed \s-1SHA\-256\s0 digest.
.PP
See also \fIhash_algorithm()\fR.
.SS "\fIas_string()\fP \- the signature header as a string"
.IX Subsection "as_string() - the signature header as a string"
.Vb 1
\&  print $signature\->as_string . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DKIM\-Signature: a=rsa\-sha1; b=yluiJ7+0=; c=relaxed
.Ve
.PP
As shown in the example, the as_string method can be used to generate
the DKIM-Signature that gets prepended to a signed message.
.SS "\fIas_string_without_data()\fP \- signature without the signature data"
.IX Subsection "as_string_without_data() - signature without the signature data"
.Vb 1
\&  print $signature\->as_string_without_data . "\en";
.Ve
.PP
outputs
.PP
.Vb 1
\&  DKIM\-Signature: a=rsa\-sha1; b=; c=relaxed
.Ve
.PP
This is similar to the \fIas_string()\fR method, but it always excludes the \*(L"data\*(R"
part. This is used by the \s-1DKIM\s0 canonicalization methods, which require
incorporating this part of the signature into the signed message.
.SS "\fIbody_count()\fP \- get or set the body count (l=) field"
.IX Subsection "body_count() - get or set the body count (l=) field"
.Vb 1
\&  my $i = $signature\->body_count;
.Ve
.PP
Informs the verifier of the number of bytes in the body of the email
included in the cryptographic hash, starting from 0 immediately
following the \s-1CRLF\s0 preceding the body. Also known as the l= tag.
.PP
When creating a signature, this tag may be either omitted, or set after
the selected canonicalization system has received the entire message
body (but before it canonicalizes the DKIM-Signature).
.SS "\fIbody_hash()\fP \- get or set the body hash (bh=) field"
.IX Subsection "body_hash() - get or set the body hash (bh=) field"
.Vb 1
\&  my $bh = $signature\->body_hash;
.Ve
.PP
The hash of the body part of the message. Whitespace is ignored in this
value. This tag is required.
.PP
When accessing this value, whitespace is stripped from the tag for you.
.SS "\fIcanonicalization()\fP \- get or set the canonicalization (c=) field"
.IX Subsection "canonicalization() - get or set the canonicalization (c=) field"
.Vb 1
\&  $signature\->canonicalization("relaxed", "simple");
\&
\&  ($header, $body) = $signature\->canonicalization;
.Ve
.PP
Message canonicalization (default is \*(L"simple/simple\*(R"). This informs the
verifier of the type of canonicalization used to prepare the message for
signing.
.PP
In scalar context, this returns header/body canonicalization as a single
string separated by /. In list context, it returns a two element array,
containing first the header canonicalization, then the body.
.SS "\fIdata()\fP \- get or set the signature data (b=) field"
.IX Subsection "data() - get or set the signature data (b=) field"
.Vb 2
\&  my $base64 = $signature\->data;
\&  $signature\->data($base64);
.Ve
.PP
The signature data. Whitespace is automatically stripped from the
returned value. The data is Base64\-encoded.
.SS "\fIdomain()\fP \- get or set the domain (d=) field"
.IX Subsection "domain() - get or set the domain (d=) field"
.Vb 2
\&  my $d = $signature\->domain;          # gets the domain value
\&  $signature\->domain("example.org");   # sets the domain value
.Ve
.PP
The domain of the signing entity, as specified in the signature.
This is the domain that will be queried for the public key.
.PP
If using an \*(L"internationalized domain name\*(R", the domain name must be
converted to \s-1ASCII \s0(following section 4.1 of \s-1RFC 3490\s0) before passing
it to this method.
.SS "\fIexpiration()\fP \- get or set the signature expiration (x=) field"
.IX Subsection "expiration() - get or set the signature expiration (x=) field"
Signature expiration (default is undef, meaning no expiration).
The signature expiration, if defined, is an unsigned integer identifying
the standard Unix seconds\-since\-1970 time when the signature will
expire.
.SS "\fIget_public_key()\fP \- fetches the public key referenced by this signature"
.IX Subsection "get_public_key() - fetches the public key referenced by this signature"
.Vb 1
\&  my $pubkey = $signature\->get_public_key;
.Ve
.PP
Public key to fetch is determined by the protocol, selector, and domain
fields.
.PP
This method caches the result of the fetch, so subsequent calls will not
require additional \s-1DNS\s0 queries.
.PP
This method will \f(CW\*(C`die\*(C'\fR if an error occurs.
.SS "\fIget_tag()\fP \- access the raw value of a tag in this signature"
.IX Subsection "get_tag() - access the raw value of a tag in this signature"
.Vb 1
\&  my $raw_identity = $signature\->get_tag("i");
.Ve
.PP
Use this method to access a tag not already supported by Mail::DKIM,
or if you want to bypass decoding of the value by Mail::DKIM.
.PP
For example, the raw i= (identity) tag is encoded in quoted-printable
form. If you use the \fIidentity()\fR method, Mail::DKIM will decode from
quoted-printable before returning the value. But if you use
get_tag(\*(L"i\*(R"), you can access the encoded quoted-printable form of
the value.
.SS "\fIhash_algorithm()\fP \- access the hash algorithm specified in this signature"
.IX Subsection "hash_algorithm() - access the hash algorithm specified in this signature"
.Vb 1
\&  my $hash = $signature\->hash_algorithm;
.Ve
.PP
Determines what hashing algorithm is used as part of the signature's
specified algorithm.
.PP
For algorithm \*(L"rsa\-sha1\*(R", the hash algorithm is \*(L"sha1\*(R". Likewise, for
algorithm \*(L"rsa\-sha256\*(R", the hash algorithm is \*(L"sha256\*(R". If the algorithm
is not recognized, undef is returned.
.SS "\fIheaderlist()\fP \- get or set the signed header fields (h=) field"
.IX Subsection "headerlist() - get or set the signed header fields (h=) field"
.Vb 1
\&  $signature\->headerlist("a:b:c");
\&
\&  my $headerlist = $signature\->headerlist;
\&
\&  my @headers = $signature\->headerlist;
.Ve
.PP
Signed header fields. A colon-separated list of header field names
that identify the header fields presented to the signing algorithm.
.PP
In scalar context, the list of header field names will be returned
as a single string, with the names joined together with colons.
In list context, the header field names will be returned as a list.
.SS "\fIidentity()\fP \- get or set the signing identity (i=) field"
.IX Subsection "identity() - get or set the signing identity (i=) field"
.Vb 1
\&  my $i = $signature\->identity;
.Ve
.PP
Identity of the user or agent on behalf of which this message is signed.
The identity has an optional local part, followed by \*(L"@\*(R", then a domain
name. The domain name should be the same as or a subdomain of the
domain returned by the \f(CW\*(C`domain\*(C'\fR method.
.PP
Ideally, the identity should match the identity listed in the From:
header, or the Sender: header, but this is not required to have a
valid signature. Whether the identity used is \*(L"authorized\*(R" to sign
for the given message is not determined here.
.PP
If using an \*(L"internationalized domain name\*(R", the domain name must be
converted to \s-1ASCII \s0(following section 4.1 of \s-1RFC 3490\s0) before passing
it to this method.
.PP
Identity values are encoded in the signature in quoted-printable format.
Using this method will translate to/from quoted-printable as necessary.
If you want the raw quoted-printable version of the identity, use
\&\f(CW$signature\fR\->get_tag(\*(L"i\*(R").
.SS "\fIkey()\fP \- get or set the private key object"
.IX Subsection "key() - get or set the private key object"
.Vb 1
\&  my $key = $signature\->key;
\&
\&  $signature\->key(Mail::DKIM::PrivateKey\->load(File => "private.key"));
.Ve
.PP
The private key is used for signing messages.
It is not used for verifying messages.
.PP
The key object can be any object that implements the
\&\fIsign_digest()\fR method.
(Providing your own object can be useful if your actual keys
are stored out-of-process.)
.SS "\fImethod()\fP \- get or set the canonicalization (c=) field"
.IX Subsection "method() - get or set the canonicalization (c=) field"
Message canonicalization (default is \*(L"simple\*(R"). This informs the verifier
of the type of canonicalization used to prepare the message for signing.
.SS "\fIprotocol()\fP \- get or set the query methods (q=) field"
.IX Subsection "protocol() - get or set the query methods (q=) field"
A colon-separated list of query methods used to retrieve the public
key (default is \*(L"dns\*(R"). Each query method is of the form \*(L"type[/options]\*(R",
where the syntax and semantics of the options depends on the type.
.SS "\fIresult()\fP \- get or set the verification result"
.IX Subsection "result() - get or set the verification result"
.Vb 1
\&  my $result = $signature\->result;
\&
\&  $signature\->result("pass");
\&
\&  # to set the result with details
\&  $signature\->result("invalid", "no public key");
.Ve
.SS "\fIresult_detail()\fP \- access the result, plus details if available"
.IX Subsection "result_detail() - access the result, plus details if available"
.Vb 1
\&  my $detail = $signature\->result_detail;
.Ve
.PP
An explanation of possible detail messages can be found in the
documentation for \*(L"\fIresult_detail()\fR\*(R" in Mail::DKIM::Verifier.
.SS "\fIselector()\fP \- get or set the selector (s=) field"
.IX Subsection "selector() - get or set the selector (s=) field"
The selector subdivides the namespace for the \*(L"d=\*(R" (domain) tag.
.ie n .SS "\fIprettify()\fP \- alters the signature to look ""nicer"" as an email header"
.el .SS "\fIprettify()\fP \- alters the signature to look ``nicer'' as an email header"
.IX Subsection "prettify() - alters the signature to look nicer as an email header"
.Vb 1
\&  $signature\->prettify;
.Ve
.PP
This method may alter the signature in a way that breaks signatures, so
it should be done \s-1ONLY\s0 when the signature is being generated, \s-1BEFORE\s0 being
fed to the canonicalization algorithm.
.PP
See also \fIprettify_safe()\fR, which will not break signatures.
.SS "\fIprettify_safe()\fP \- same as \fIprettify()\fP but only touches the b= part"
.IX Subsection "prettify_safe() - same as prettify() but only touches the b= part"
.Vb 1
\&  $signature\->prettify_safe;
.Ve
.PP
This method will not break the signature, but it only affects the b= part
of the signature.
.SS "\fItimestamp()\fP \- get or set the signature timestamp (t=) field"
.IX Subsection "timestamp() - get or set the signature timestamp (t=) field"
Signature timestamp (default is undef, meaning unknown creation time).
This is the time that the signature was created. The value is an unsigned
integer identifying the number of standard Unix seconds\-since\-1970.
.SS "\fIversion()\fP \- get or set the \s-1DKIM\s0 specification version (v=) field"
.IX Subsection "version() - get or set the DKIM specification version (v=) field"
This is the version of the \s-1DKIM\s0 specification that applies to this
signature record.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::DkSignature for DomainKey-Signature headers
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Signer.3pm                       0100644 0001750 0001750 00000035773 12566242060 024362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Signer 3"
.TH Mail::DKIM::Signer 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Signer \- generates a DKIM signature for a message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::DKIM::Signer;
\&  use Mail::DKIM::TextWrap;  #recommended
\&
\&  # create a signer object
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Algorithm => "rsa\-sha1",
\&                  Method => "relaxed",
\&                  Domain => "example.org",
\&                  Selector => "selector1",
\&                  KeyFile => "private.key",
\&             );
\&
\&  # read an email from a file handle
\&  $dkim\->load(*STDIN);
\&
\&  # or read an email and pass it into the signer, one line at a time
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the signature result?
\&  my $signature = $dkim\->signature;
\&  print $signature\->as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is the part of Mail::DKIM responsible for generating
signatures for a given message. You create an object of this class,
specifying the parameters of the signature you wish to create, or
specifying a callback function so that the signature parameters can
be determined later. Next, you feed it the entire message using
\&\*(L"\s-1\fIPRINT\s0()\fR\*(R", completing with \*(L"\s-1\fICLOSE\s0()\fR\*(R". Finally, use the
\&\*(L"\fIsignatures()\fR\*(R" method to access the generated signatures.
.SS "Pretty Signatures"
.IX Subsection "Pretty Signatures"
Mail::DKIM includes a signature-wrapping module (which inserts
linebreaks into the generated signature so that it looks nicer in the
resulting message. To enable this module, simply call
.PP
.Vb 1
\&  use Mail::DKIM::TextWrap;
.Ve
.PP
in your program before generating the signature.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct an object-oriented signer.
.PP
.Vb 8
\&  # create a signer using the default policy
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Algorithm => "rsa\-sha1",
\&                  Method => "relaxed",
\&                  Domain => "example.org",
\&                  Selector => "selector1",
\&                  KeyFile => "private.key",
\&             );
\&
\&  # create a signer using a custom policy
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Policy => $policyfn,
\&             );
.Ve
.PP
The \*(L"default policy\*(R" is to create a \s-1DKIM\s0 signature using the specified
parameters, but only if the message's sender matches the domain.
The following parameters can be passed to this \fInew()\fR method to
influence the resulting signature:
Algorithm, Method, Domain, Selector, KeyFile, Identity, Timestamp.
.PP
If you want different behavior, you can provide a \*(L"signer policy\*(R"
instead. A signer policy is a subroutine or class that determines
signature parameters after the message's headers have been parsed.
See the section \*(L"\s-1SIGNER POLICIES\*(R"\s0 below for more information.
.PP
See Mail::DKIM::SignerPolicy for more information about policy objects.
.PP
In addition to the parameters demonstrated above, the following
are recognized:
.IP "Key" 4
.IX Item "Key"
rather than using \f(CW\*(C`KeyFile\*(C'\fR, use \f(CW\*(C`Key\*(C'\fR to use an already-loaded
Mail::DKIM::PrivateKey object.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1\fIPRINT\s0()\fP"
.IX Subsection "PRINT()"
Feed part of the message to the signer.
.PP
.Vb 1
\&  $dkim\->PRINT("a line of the message\e015\e012");
.Ve
.PP
Feeds content of the message being signed into the signer.
The \s-1API\s0 is designed this way so that the entire message does \s-1NOT\s0 need
to be read into memory at once.
.PP
Please note that although the \s-1\fIPRINT\s0()\fR method expects you to use
SMTP-style line termination characters, you should \s-1NOT\s0 use the
SMTP-style dot-stuffing technique described in \s-1RFC 2821\s0 section 4.5.2.
Nor should you use a <\s-1CR\s0><\s-1LF\s0>.<\s-1CR\s0><\s-1LF\s0> sequence to terminate the
message.
.SS "\s-1\fICLOSE\s0()\fP"
.IX Subsection "CLOSE()"
Call this when finished feeding in the message.
.PP
.Vb 1
\&  $dkim\->CLOSE;
.Ve
.PP
This method finishes the canonicalization process, computes a hash,
and generates a signature.
.SS "\fIadd_signature()\fP"
.IX Subsection "add_signature()"
Used by signer policy to create a new signature.
.PP
.Vb 1
\&  $dkim\->add_signature(new Mail::DKIM::Signature(...));
.Ve
.PP
Signer policies can use this method to specify complete parameters for
the signature to add, including what type of signature. For more information,
see Mail::DKIM::SignerPolicy.
.SS "\fIalgorithm()\fP"
.IX Subsection "algorithm()"
Get or set the selected algorithm.
.PP
.Vb 1
\&  $alg = $dkim\->algorithm;
\&
\&  $dkim\->algorithm("rsa\-sha1");
.Ve
.SS "\fIdomain()\fP"
.IX Subsection "domain()"
Get or set the selected domain.
.PP
.Vb 1
\&  $alg = $dkim\->domain;
\&
\&  $dkim\->domain("example.org");
.Ve
.SS "\fIload()\fP"
.IX Subsection "load()"
Load the entire message from a file handle.
.PP
.Vb 1
\&  $dkim\->load($file_handle);
.Ve
.PP
Reads a complete message from the designated file handle,
feeding it into the signer.  The message must use <\s-1CRLF\s0> line
terminators (same as the \s-1SMTP\s0 protocol).
.SS "\fIheaders()\fP"
.IX Subsection "headers()"
Determine which headers to put in signature.
.PP
.Vb 1
\&  my $headers = $dkim\->headers;
.Ve
.PP
This is a string containing the names of the header fields that
will be signed, separated by colons.
.SS "\fIkey()\fP"
.IX Subsection "key()"
Get or set the private key object.
.PP
.Vb 1
\&  my $key = $dkim\->key;
\&
\&  $dkim\->key(Mail::DKIM::PrivateKey\->load(File => "private.key"));
.Ve
.PP
The key object can be any object that implements the
\&\fIsign_digest()\fR method.
(Providing your own object can be useful if your actual keys
are stored out-of-process.)
.PP
If you use this method to specify a private key,
do not use \*(L"\fIkey_file()\fR\*(R".
.SS "\fIkey_file()\fP"
.IX Subsection "key_file()"
Get or set the filename containing the private key.
.PP
.Vb 1
\&  my $filename = $dkim\->key_file;
\&
\&  $dkim\->key_file("private.key");
.Ve
.PP
If you use this method to specify a private key file,
do not use \*(L"\fIkey()\fR\*(R".
.SS "\fImethod()\fP"
.IX Subsection "method()"
Get or set the selected canonicalization method.
.PP
.Vb 1
\&  $alg = $dkim\->method;
\&
\&  $dkim\->method("relaxed");
.Ve
.SS "\fImessage_originator()\fP"
.IX Subsection "message_originator()"
Access the \*(L"From\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_originator;
.Ve
.PP
Returns the \*(L"originator address\*(R" found in the message, as a
Mail::Address object.
This is typically the (first) name and email address found in the
From: header. If there is no From: header,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_originator\->address;
.Ve
.PP
See also \*(L"\fImessage_sender()\fR\*(R".
.SS "\fImessage_sender()\fP"
.IX Subsection "message_sender()"
Access the \*(L"From\*(R" or \*(L"Sender\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_sender;
.Ve
.PP
Returns the \*(L"sender\*(R" found in the message, as a Mail::Address object.
This is typically the (first) name and email address found in the
Sender: header. If there is no Sender: header, it is the first name and
email address in the From: header. If neither header is present,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_sender\->address;
.Ve
.PP
The \*(L"sender\*(R" is the mailbox of the agent responsible for the actual
transmission of the message. For example, if a secretary were to send a
message for another person, the \*(L"sender\*(R" would be the secretary and
the \*(L"originator\*(R" would be the actual author.
.SS "\fIselector()\fP"
.IX Subsection "selector()"
Get or set the current key selector.
.PP
.Vb 1
\&  $alg = $dkim\->selector;
\&
\&  $dkim\->selector("alpha");
.Ve
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Access the generated signature object.
.PP
.Vb 1
\&  my $signature = $dkim\->signature;
.Ve
.PP
Returns the generated signature. The signature is an object of type
Mail::DKIM::Signature. If multiple signatures were generated, this method
returns the last one.
.PP
The signature (as text) should be \fBprepended\fR to the message to make the
resulting message. At the very least, it should precede any headers
that were signed.
.SS "\fIsignatures()\fP"
.IX Subsection "signatures()"
Access list of generated signature objects.
.PP
.Vb 1
\&  my @signatures = $dkim\->signatures;
.Ve
.PP
Returns all generated signatures, as a list.
.SH "SIGNER POLICIES"
.IX Header "SIGNER POLICIES"
The \fInew()\fR constructor takes an optional Policy argument. This
can be a Perl object or class with an \fIapply()\fR method, or just a simple
subroutine reference. The method/subroutine will be called with the
signer object as an argument. The policy is responsible for checking the
message and specifying signature parameters. The policy must return a
nonzero value to create the signature, otherwise no signature will be
created. E.g.,
.PP
.Vb 2
\&  my $policyfn = sub {
\&      my $dkim = shift;
\&
\&      # specify signature parameters
\&      $dkim\->algorithm("rsa\-sha1");
\&      $dkim\->method("relaxed");
\&      $dkim\->domain("example.org");
\&      $dkim\->selector("mx1");
\&
\&      # return true value to create the signature
\&      return 1;
\&  };
.Ve
.PP
Or the policy object can actually create the signature, using the
add_signature method within the policy object.
If you add a signature, you do not need to return a nonzero value.
This mechanism can be utilized to create multiple signatures,
or to create the older DomainKey-style signatures.
.PP
.Vb 10
\&  my $policyfn = sub {
\&      my $dkim = shift;
\&      $dkim\->add_signature(
\&              new Mail::DKIM::Signature(
\&                      Algorithm => "rsa\-sha1",
\&                      Method => "relaxed",
\&                      Headers => $dkim\->headers,
\&                      Domain => "example.org",
\&                      Selector => "mx1",
\&              ));
\&      $dkim\->add_signature(
\&              new Mail::DKIM::DkSignature(
\&                      Algorithm => "rsa\-sha1",
\&                      Method => "nofws",
\&                      Headers => $dkim\->headers,
\&                      Domain => "example.org",
\&                      Selector => "mx1",
\&              ));
\&      return;
\&  };
.Ve
.PP
If no policy is specified, the default policy is used. The default policy
signs every message using the domain, algorithm, method, and selector
specified in the \fInew()\fR constructor.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::SignerPolicy
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Signer5.16.3pm                   0100644 0001750 0001750 00000035461 12566242072 024671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Signer 3"
.TH Mail::DKIM::Signer 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Signer \- generates a DKIM signature for a message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::DKIM::Signer;
\&  use Mail::DKIM::TextWrap;  #recommended
\&
\&  # create a signer object
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Algorithm => "rsa\-sha1",
\&                  Method => "relaxed",
\&                  Domain => "example.org",
\&                  Selector => "selector1",
\&                  KeyFile => "private.key",
\&             );
\&
\&  # read an email from a file handle
\&  $dkim\->load(*STDIN);
\&
\&  # or read an email and pass it into the signer, one line at a time
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the signature result?
\&  my $signature = $dkim\->signature;
\&  print $signature\->as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is the part of Mail::DKIM responsible for generating
signatures for a given message. You create an object of this class,
specifying the parameters of the signature you wish to create, or
specifying a callback function so that the signature parameters can
be determined later. Next, you feed it the entire message using
\&\*(L"\s-1\fIPRINT\s0()\fR\*(R", completing with \*(L"\s-1\fICLOSE\s0()\fR\*(R". Finally, use the
\&\*(L"\fIsignatures()\fR\*(R" method to access the generated signatures.
.SS "Pretty Signatures"
.IX Subsection "Pretty Signatures"
Mail::DKIM includes a signature-wrapping module (which inserts
linebreaks into the generated signature so that it looks nicer in the
resulting message. To enable this module, simply call
.PP
.Vb 1
\&  use Mail::DKIM::TextWrap;
.Ve
.PP
in your program before generating the signature.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct an object-oriented signer.
.PP
.Vb 8
\&  # create a signer using the default policy
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Algorithm => "rsa\-sha1",
\&                  Method => "relaxed",
\&                  Domain => "example.org",
\&                  Selector => "selector1",
\&                  KeyFile => "private.key",
\&             );
\&
\&  # create a signer using a custom policy
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Policy => $policyfn,
\&             );
.Ve
.PP
The \*(L"default policy\*(R" is to create a \s-1DKIM\s0 signature using the specified
parameters, but only if the message's sender matches the domain.
The following parameters can be passed to this \fInew()\fR method to
influence the resulting signature:
Algorithm, Method, Domain, Selector, KeyFile, Identity, Timestamp.
.PP
If you want different behavior, you can provide a \*(L"signer policy\*(R"
instead. A signer policy is a subroutine or class that determines
signature parameters after the message's headers have been parsed.
See the section \*(L"\s-1SIGNER\s0 \s-1POLICIES\s0\*(R" below for more information.
.PP
See Mail::DKIM::SignerPolicy for more information about policy objects.
.PP
In addition to the parameters demonstrated above, the following
are recognized:
.IP "Key" 4
.IX Item "Key"
rather than using \f(CW\*(C`KeyFile\*(C'\fR, use \f(CW\*(C`Key\*(C'\fR to use an already-loaded
Mail::DKIM::PrivateKey object.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1\fIPRINT\s0()\fP"
.IX Subsection "PRINT()"
Feed part of the message to the signer.
.PP
.Vb 1
\&  $dkim\->PRINT("a line of the message\e015\e012");
.Ve
.PP
Feeds content of the message being signed into the signer.
The \s-1API\s0 is designed this way so that the entire message does \s-1NOT\s0 need
to be read into memory at once.
.PP
Please note that although the \s-1\fIPRINT\s0()\fR method expects you to use
SMTP-style line termination characters, you should \s-1NOT\s0 use the
SMTP-style dot-stuffing technique described in \s-1RFC\s0 2821 section 4.5.2.
Nor should you use a <\s-1CR\s0><\s-1LF\s0>.<\s-1CR\s0><\s-1LF\s0> sequence to terminate the
message.
.SS "\s-1\fICLOSE\s0()\fP"
.IX Subsection "CLOSE()"
Call this when finished feeding in the message.
.PP
.Vb 1
\&  $dkim\->CLOSE;
.Ve
.PP
This method finishes the canonicalization process, computes a hash,
and generates a signature.
.SS "\fIadd_signature()\fP"
.IX Subsection "add_signature()"
Used by signer policy to create a new signature.
.PP
.Vb 1
\&  $dkim\->add_signature(new Mail::DKIM::Signature(...));
.Ve
.PP
Signer policies can use this method to specify complete parameters for
the signature to add, including what type of signature. For more information,
see Mail::DKIM::SignerPolicy.
.SS "\fIalgorithm()\fP"
.IX Subsection "algorithm()"
Get or set the selected algorithm.
.PP
.Vb 1
\&  $alg = $dkim\->algorithm;
\&
\&  $dkim\->algorithm("rsa\-sha1");
.Ve
.SS "\fIdomain()\fP"
.IX Subsection "domain()"
Get or set the selected domain.
.PP
.Vb 1
\&  $alg = $dkim\->domain;
\&
\&  $dkim\->domain("example.org");
.Ve
.SS "\fIload()\fP"
.IX Subsection "load()"
Load the entire message from a file handle.
.PP
.Vb 1
\&  $dkim\->load($file_handle);
.Ve
.PP
Reads a complete message from the designated file handle,
feeding it into the signer.  The message must use <\s-1CRLF\s0> line
terminators (same as the \s-1SMTP\s0 protocol).
.SS "\fIheaders()\fP"
.IX Subsection "headers()"
Determine which headers to put in signature.
.PP
.Vb 1
\&  my $headers = $dkim\->headers;
.Ve
.PP
This is a string containing the names of the header fields that
will be signed, separated by colons.
.SS "\fIkey()\fP"
.IX Subsection "key()"
Get or set the private key object.
.PP
.Vb 1
\&  my $key = $dkim\->key;
\&
\&  $dkim\->key(Mail::DKIM::PrivateKey\->load(File => "private.key"));
.Ve
.PP
The key object can be any object that implements the
\&\fIsign_digest()\fR method.
(Providing your own object can be useful if your actual keys
are stored out-of-process.)
.PP
If you use this method to specify a private key,
do not use \*(L"\fIkey_file()\fR\*(R".
.SS "\fIkey_file()\fP"
.IX Subsection "key_file()"
Get or set the filename containing the private key.
.PP
.Vb 1
\&  my $filename = $dkim\->key_file;
\&
\&  $dkim\->key_file("private.key");
.Ve
.PP
If you use this method to specify a private key file,
do not use \*(L"\fIkey()\fR\*(R".
.SS "\fImethod()\fP"
.IX Subsection "method()"
Get or set the selected canonicalization method.
.PP
.Vb 1
\&  $alg = $dkim\->method;
\&
\&  $dkim\->method("relaxed");
.Ve
.SS "\fImessage_originator()\fP"
.IX Subsection "message_originator()"
Access the \*(L"From\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_originator;
.Ve
.PP
Returns the \*(L"originator address\*(R" found in the message, as a
Mail::Address object.
This is typically the (first) name and email address found in the
From: header. If there is no From: header,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_originator\->address;
.Ve
.PP
See also \*(L"\fImessage_sender()\fR\*(R".
.SS "\fImessage_sender()\fP"
.IX Subsection "message_sender()"
Access the \*(L"From\*(R" or \*(L"Sender\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_sender;
.Ve
.PP
Returns the \*(L"sender\*(R" found in the message, as a Mail::Address object.
This is typically the (first) name and email address found in the
Sender: header. If there is no Sender: header, it is the first name and
email address in the From: header. If neither header is present,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_sender\->address;
.Ve
.PP
The \*(L"sender\*(R" is the mailbox of the agent responsible for the actual
transmission of the message. For example, if a secretary were to send a
message for another person, the \*(L"sender\*(R" would be the secretary and
the \*(L"originator\*(R" would be the actual author.
.SS "\fIselector()\fP"
.IX Subsection "selector()"
Get or set the current key selector.
.PP
.Vb 1
\&  $alg = $dkim\->selector;
\&
\&  $dkim\->selector("alpha");
.Ve
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Access the generated signature object.
.PP
.Vb 1
\&  my $signature = $dkim\->signature;
.Ve
.PP
Returns the generated signature. The signature is an object of type
Mail::DKIM::Signature. If multiple signatures were generated, this method
returns the last one.
.PP
The signature (as text) should be \fBprepended\fR to the message to make the
resulting message. At the very least, it should precede any headers
that were signed.
.SS "\fIsignatures()\fP"
.IX Subsection "signatures()"
Access list of generated signature objects.
.PP
.Vb 1
\&  my @signatures = $dkim\->signatures;
.Ve
.PP
Returns all generated signatures, as a list.
.SH "SIGNER POLICIES"
.IX Header "SIGNER POLICIES"
The \fInew()\fR constructor takes an optional Policy argument. This
can be a Perl object or class with an \fIapply()\fR method, or just a simple
subroutine reference. The method/subroutine will be called with the
signer object as an argument. The policy is responsible for checking the
message and specifying signature parameters. The policy must return a
nonzero value to create the signature, otherwise no signature will be
created. E.g.,
.PP
.Vb 2
\&  my $policyfn = sub {
\&      my $dkim = shift;
\&
\&      # specify signature parameters
\&      $dkim\->algorithm("rsa\-sha1");
\&      $dkim\->method("relaxed");
\&      $dkim\->domain("example.org");
\&      $dkim\->selector("mx1");
\&
\&      # return true value to create the signature
\&      return 1;
\&  };
.Ve
.PP
Or the policy object can actually create the signature, using the
add_signature method within the policy object.
If you add a signature, you do not need to return a nonzero value.
This mechanism can be utilized to create multiple signatures,
or to create the older DomainKey-style signatures.
.PP
.Vb 10
\&  my $policyfn = sub {
\&      my $dkim = shift;
\&      $dkim\->add_signature(
\&              new Mail::DKIM::Signature(
\&                      Algorithm => "rsa\-sha1",
\&                      Method => "relaxed",
\&                      Headers => $dkim\->headers,
\&                      Domain => "example.org",
\&                      Selector => "mx1",
\&              ));
\&      $dkim\->add_signature(
\&              new Mail::DKIM::DkSignature(
\&                      Algorithm => "rsa\-sha1",
\&                      Method => "nofws",
\&                      Headers => $dkim\->headers,
\&                      Domain => "example.org",
\&                      Selector => "mx1",
\&              ));
\&      return;
\&  };
.Ve
.PP
If no policy is specified, the default policy is used. The default policy
signs every message using the domain, algorithm, method, and selector
specified in the \fInew()\fR constructor.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::SignerPolicy
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Signer5.18.3pm                   0100644 0001750 0001750 00000035773 12566242060 024676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Signer 3"
.TH Mail::DKIM::Signer 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Signer \- generates a DKIM signature for a message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::DKIM::Signer;
\&  use Mail::DKIM::TextWrap;  #recommended
\&
\&  # create a signer object
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Algorithm => "rsa\-sha1",
\&                  Method => "relaxed",
\&                  Domain => "example.org",
\&                  Selector => "selector1",
\&                  KeyFile => "private.key",
\&             );
\&
\&  # read an email from a file handle
\&  $dkim\->load(*STDIN);
\&
\&  # or read an email and pass it into the signer, one line at a time
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the signature result?
\&  my $signature = $dkim\->signature;
\&  print $signature\->as_string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is the part of Mail::DKIM responsible for generating
signatures for a given message. You create an object of this class,
specifying the parameters of the signature you wish to create, or
specifying a callback function so that the signature parameters can
be determined later. Next, you feed it the entire message using
\&\*(L"\s-1\fIPRINT\s0()\fR\*(R", completing with \*(L"\s-1\fICLOSE\s0()\fR\*(R". Finally, use the
\&\*(L"\fIsignatures()\fR\*(R" method to access the generated signatures.
.SS "Pretty Signatures"
.IX Subsection "Pretty Signatures"
Mail::DKIM includes a signature-wrapping module (which inserts
linebreaks into the generated signature so that it looks nicer in the
resulting message. To enable this module, simply call
.PP
.Vb 1
\&  use Mail::DKIM::TextWrap;
.Ve
.PP
in your program before generating the signature.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP"
.IX Subsection "new()"
Construct an object-oriented signer.
.PP
.Vb 8
\&  # create a signer using the default policy
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Algorithm => "rsa\-sha1",
\&                  Method => "relaxed",
\&                  Domain => "example.org",
\&                  Selector => "selector1",
\&                  KeyFile => "private.key",
\&             );
\&
\&  # create a signer using a custom policy
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Policy => $policyfn,
\&             );
.Ve
.PP
The \*(L"default policy\*(R" is to create a \s-1DKIM\s0 signature using the specified
parameters, but only if the message's sender matches the domain.
The following parameters can be passed to this \fInew()\fR method to
influence the resulting signature:
Algorithm, Method, Domain, Selector, KeyFile, Identity, Timestamp.
.PP
If you want different behavior, you can provide a \*(L"signer policy\*(R"
instead. A signer policy is a subroutine or class that determines
signature parameters after the message's headers have been parsed.
See the section \*(L"\s-1SIGNER POLICIES\*(R"\s0 below for more information.
.PP
See Mail::DKIM::SignerPolicy for more information about policy objects.
.PP
In addition to the parameters demonstrated above, the following
are recognized:
.IP "Key" 4
.IX Item "Key"
rather than using \f(CW\*(C`KeyFile\*(C'\fR, use \f(CW\*(C`Key\*(C'\fR to use an already-loaded
Mail::DKIM::PrivateKey object.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1\fIPRINT\s0()\fP"
.IX Subsection "PRINT()"
Feed part of the message to the signer.
.PP
.Vb 1
\&  $dkim\->PRINT("a line of the message\e015\e012");
.Ve
.PP
Feeds content of the message being signed into the signer.
The \s-1API\s0 is designed this way so that the entire message does \s-1NOT\s0 need
to be read into memory at once.
.PP
Please note that although the \s-1\fIPRINT\s0()\fR method expects you to use
SMTP-style line termination characters, you should \s-1NOT\s0 use the
SMTP-style dot-stuffing technique described in \s-1RFC 2821\s0 section 4.5.2.
Nor should you use a <\s-1CR\s0><\s-1LF\s0>.<\s-1CR\s0><\s-1LF\s0> sequence to terminate the
message.
.SS "\s-1\fICLOSE\s0()\fP"
.IX Subsection "CLOSE()"
Call this when finished feeding in the message.
.PP
.Vb 1
\&  $dkim\->CLOSE;
.Ve
.PP
This method finishes the canonicalization process, computes a hash,
and generates a signature.
.SS "\fIadd_signature()\fP"
.IX Subsection "add_signature()"
Used by signer policy to create a new signature.
.PP
.Vb 1
\&  $dkim\->add_signature(new Mail::DKIM::Signature(...));
.Ve
.PP
Signer policies can use this method to specify complete parameters for
the signature to add, including what type of signature. For more information,
see Mail::DKIM::SignerPolicy.
.SS "\fIalgorithm()\fP"
.IX Subsection "algorithm()"
Get or set the selected algorithm.
.PP
.Vb 1
\&  $alg = $dkim\->algorithm;
\&
\&  $dkim\->algorithm("rsa\-sha1");
.Ve
.SS "\fIdomain()\fP"
.IX Subsection "domain()"
Get or set the selected domain.
.PP
.Vb 1
\&  $alg = $dkim\->domain;
\&
\&  $dkim\->domain("example.org");
.Ve
.SS "\fIload()\fP"
.IX Subsection "load()"
Load the entire message from a file handle.
.PP
.Vb 1
\&  $dkim\->load($file_handle);
.Ve
.PP
Reads a complete message from the designated file handle,
feeding it into the signer.  The message must use <\s-1CRLF\s0> line
terminators (same as the \s-1SMTP\s0 protocol).
.SS "\fIheaders()\fP"
.IX Subsection "headers()"
Determine which headers to put in signature.
.PP
.Vb 1
\&  my $headers = $dkim\->headers;
.Ve
.PP
This is a string containing the names of the header fields that
will be signed, separated by colons.
.SS "\fIkey()\fP"
.IX Subsection "key()"
Get or set the private key object.
.PP
.Vb 1
\&  my $key = $dkim\->key;
\&
\&  $dkim\->key(Mail::DKIM::PrivateKey\->load(File => "private.key"));
.Ve
.PP
The key object can be any object that implements the
\&\fIsign_digest()\fR method.
(Providing your own object can be useful if your actual keys
are stored out-of-process.)
.PP
If you use this method to specify a private key,
do not use \*(L"\fIkey_file()\fR\*(R".
.SS "\fIkey_file()\fP"
.IX Subsection "key_file()"
Get or set the filename containing the private key.
.PP
.Vb 1
\&  my $filename = $dkim\->key_file;
\&
\&  $dkim\->key_file("private.key");
.Ve
.PP
If you use this method to specify a private key file,
do not use \*(L"\fIkey()\fR\*(R".
.SS "\fImethod()\fP"
.IX Subsection "method()"
Get or set the selected canonicalization method.
.PP
.Vb 1
\&  $alg = $dkim\->method;
\&
\&  $dkim\->method("relaxed");
.Ve
.SS "\fImessage_originator()\fP"
.IX Subsection "message_originator()"
Access the \*(L"From\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_originator;
.Ve
.PP
Returns the \*(L"originator address\*(R" found in the message, as a
Mail::Address object.
This is typically the (first) name and email address found in the
From: header. If there is no From: header,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_originator\->address;
.Ve
.PP
See also \*(L"\fImessage_sender()\fR\*(R".
.SS "\fImessage_sender()\fP"
.IX Subsection "message_sender()"
Access the \*(L"From\*(R" or \*(L"Sender\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_sender;
.Ve
.PP
Returns the \*(L"sender\*(R" found in the message, as a Mail::Address object.
This is typically the (first) name and email address found in the
Sender: header. If there is no Sender: header, it is the first name and
email address in the From: header. If neither header is present,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_sender\->address;
.Ve
.PP
The \*(L"sender\*(R" is the mailbox of the agent responsible for the actual
transmission of the message. For example, if a secretary were to send a
message for another person, the \*(L"sender\*(R" would be the secretary and
the \*(L"originator\*(R" would be the actual author.
.SS "\fIselector()\fP"
.IX Subsection "selector()"
Get or set the current key selector.
.PP
.Vb 1
\&  $alg = $dkim\->selector;
\&
\&  $dkim\->selector("alpha");
.Ve
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Access the generated signature object.
.PP
.Vb 1
\&  my $signature = $dkim\->signature;
.Ve
.PP
Returns the generated signature. The signature is an object of type
Mail::DKIM::Signature. If multiple signatures were generated, this method
returns the last one.
.PP
The signature (as text) should be \fBprepended\fR to the message to make the
resulting message. At the very least, it should precede any headers
that were signed.
.SS "\fIsignatures()\fP"
.IX Subsection "signatures()"
Access list of generated signature objects.
.PP
.Vb 1
\&  my @signatures = $dkim\->signatures;
.Ve
.PP
Returns all generated signatures, as a list.
.SH "SIGNER POLICIES"
.IX Header "SIGNER POLICIES"
The \fInew()\fR constructor takes an optional Policy argument. This
can be a Perl object or class with an \fIapply()\fR method, or just a simple
subroutine reference. The method/subroutine will be called with the
signer object as an argument. The policy is responsible for checking the
message and specifying signature parameters. The policy must return a
nonzero value to create the signature, otherwise no signature will be
created. E.g.,
.PP
.Vb 2
\&  my $policyfn = sub {
\&      my $dkim = shift;
\&
\&      # specify signature parameters
\&      $dkim\->algorithm("rsa\-sha1");
\&      $dkim\->method("relaxed");
\&      $dkim\->domain("example.org");
\&      $dkim\->selector("mx1");
\&
\&      # return true value to create the signature
\&      return 1;
\&  };
.Ve
.PP
Or the policy object can actually create the signature, using the
add_signature method within the policy object.
If you add a signature, you do not need to return a nonzero value.
This mechanism can be utilized to create multiple signatures,
or to create the older DomainKey-style signatures.
.PP
.Vb 10
\&  my $policyfn = sub {
\&      my $dkim = shift;
\&      $dkim\->add_signature(
\&              new Mail::DKIM::Signature(
\&                      Algorithm => "rsa\-sha1",
\&                      Method => "relaxed",
\&                      Headers => $dkim\->headers,
\&                      Domain => "example.org",
\&                      Selector => "mx1",
\&              ));
\&      $dkim\->add_signature(
\&              new Mail::DKIM::DkSignature(
\&                      Algorithm => "rsa\-sha1",
\&                      Method => "nofws",
\&                      Headers => $dkim\->headers,
\&                      Domain => "example.org",
\&                      Selector => "mx1",
\&              ));
\&      return;
\&  };
.Ve
.PP
If no policy is specified, the default policy is used. The default policy
signs every message using the domain, algorithm, method, and selector
specified in the \fInew()\fR constructor.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::DKIM::SignerPolicy
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::SignerPolicy.3pm                 0100644 0001750 0001750 00000015313 12566242060 025526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::SignerPolicy 3"
.TH Mail::DKIM::SignerPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::SignerPolicy \- determines signing parameters for a message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \*(L"signer policy\*(R" is an object, class, or function used by
Mail::DKIM::Signer to determine what signatures to add to the
current message. To take advantage of signer policies, create your
own Perl class that extends the Mail::DKIM::SignerPolicy class.
The only method you need to implement is the \fIapply()\fR method.
.PP
The \fIapply()\fR method takes as a parameter the Mail::DKIM::Signer object.
Using this object, it can determine some properties of the message (e.g.
what the From: address or Sender: address is). Then it sets various
signer properties as desired. The \fIapply()\fR method should
return a nonzero value if the message should be signed. If a false value
is returned, then the message is \*(L"skipped\*(R" (i.e. not signed).
.PP
Here is an example of a policy that always returns the same values:
.PP
.Vb 2
\&  package MySignerPolicy;
\&  use base "Mail::DKIM::SignerPolicy";
\&
\&  sub apply
\&  {
\&      my $self = shift;
\&      my $signer = shift;
\&  
\&      $signer\->algorithm("rsa\-sha1");
\&      $signer\->method("relaxed");
\&      $signer\->domain("example.org");
\&      $signer\->selector("selector1");
\&      $signer\->key_file("private.key");
\&  
\&      return 1;
\&  }
.Ve
.PP
To use this policy, simply specify the name of the class as the Policy
parameter...
.PP
.Vb 3
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Policy => "MySignerPolicy",
\&             );
.Ve
.SH "ADVANCED"
.IX Header "ADVANCED"
You can also have the policy actually build the signature for the Signer
to use. To do this, call the signer's \fIadd_signature()\fR method from within
your \fIapply()\fR callback. E.g.,
.PP
.Vb 4
\&  sub apply
\&  {
\&      my $self = shift;
\&      my $signer = shift;
\&  
\&      $signer\->add_signature(
\&              new Mail::DKIM::Signature(
\&                  Algorithm => $signer\->algorithm,
\&                  Method => $signer\->method,
\&                  Headers => $signer\->headers,
\&                  Domain => $signer\->domain,
\&                  Selector => $signer\->selector,
\&              ));
\&      return;
\&  }
.Ve
.PP
Again, if you do not want any signatures, return zero or undef. If you
use \fIadd_signature()\fR to create a signature, the default signature will
not be created, even if you return nonzero.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::SignerPolicy5.16.3pm             0100644 0001750 0001750 00000014772 12566242072 026053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::SignerPolicy 3"
.TH Mail::DKIM::SignerPolicy 3 "2008-08-25" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::SignerPolicy \- determines signing parameters for a message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \*(L"signer policy\*(R" is an object, class, or function used by
Mail::DKIM::Signer to determine what signatures to add to the
current message. To take advantage of signer policies, create your
own Perl class that extends the Mail::DKIM::SignerPolicy class.
The only method you need to implement is the \fIapply()\fR method.
.PP
The \fIapply()\fR method takes as a parameter the Mail::DKIM::Signer object.
Using this object, it can determine some properties of the message (e.g.
what the From: address or Sender: address is). Then it sets various
signer properties as desired. The \fIapply()\fR method should
return a nonzero value if the message should be signed. If a false value
is returned, then the message is \*(L"skipped\*(R" (i.e. not signed).
.PP
Here is an example of a policy that always returns the same values:
.PP
.Vb 2
\&  package MySignerPolicy;
\&  use base "Mail::DKIM::SignerPolicy";
\&
\&  sub apply
\&  {
\&      my $self = shift;
\&      my $signer = shift;
\&  
\&      $signer\->algorithm("rsa\-sha1");
\&      $signer\->method("relaxed");
\&      $signer\->domain("example.org");
\&      $signer\->selector("selector1");
\&      $signer\->key_file("private.key");
\&  
\&      return 1;
\&  }
.Ve
.PP
To use this policy, simply specify the name of the class as the Policy
parameter...
.PP
.Vb 3
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Policy => "MySignerPolicy",
\&             );
.Ve
.SH "ADVANCED"
.IX Header "ADVANCED"
You can also have the policy actually build the signature for the Signer
to use. To do this, call the signer's \fIadd_signature()\fR method from within
your \fIapply()\fR callback. E.g.,
.PP
.Vb 4
\&  sub apply
\&  {
\&      my $self = shift;
\&      my $signer = shift;
\&  
\&      $signer\->add_signature(
\&              new Mail::DKIM::Signature(
\&                  Algorithm => $signer\->algorithm,
\&                  Method => $signer\->method,
\&                  Headers => $signer\->headers,
\&                  Domain => $signer\->domain,
\&                  Selector => $signer\->selector,
\&              ));
\&      return;
\&  }
.Ve
.PP
Again, if you do not want any signatures, return zero or undef. If you
use \fIadd_signature()\fR to create a signature, the default signature will
not be created, even if you return nonzero.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::SignerPolicy5.18.3pm             0100644 0001750 0001750 00000015313 12566242060 026042  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::SignerPolicy 3"
.TH Mail::DKIM::SignerPolicy 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::SignerPolicy \- determines signing parameters for a message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \*(L"signer policy\*(R" is an object, class, or function used by
Mail::DKIM::Signer to determine what signatures to add to the
current message. To take advantage of signer policies, create your
own Perl class that extends the Mail::DKIM::SignerPolicy class.
The only method you need to implement is the \fIapply()\fR method.
.PP
The \fIapply()\fR method takes as a parameter the Mail::DKIM::Signer object.
Using this object, it can determine some properties of the message (e.g.
what the From: address or Sender: address is). Then it sets various
signer properties as desired. The \fIapply()\fR method should
return a nonzero value if the message should be signed. If a false value
is returned, then the message is \*(L"skipped\*(R" (i.e. not signed).
.PP
Here is an example of a policy that always returns the same values:
.PP
.Vb 2
\&  package MySignerPolicy;
\&  use base "Mail::DKIM::SignerPolicy";
\&
\&  sub apply
\&  {
\&      my $self = shift;
\&      my $signer = shift;
\&  
\&      $signer\->algorithm("rsa\-sha1");
\&      $signer\->method("relaxed");
\&      $signer\->domain("example.org");
\&      $signer\->selector("selector1");
\&      $signer\->key_file("private.key");
\&  
\&      return 1;
\&  }
.Ve
.PP
To use this policy, simply specify the name of the class as the Policy
parameter...
.PP
.Vb 3
\&  my $dkim = Mail::DKIM::Signer\->new(
\&                  Policy => "MySignerPolicy",
\&             );
.Ve
.SH "ADVANCED"
.IX Header "ADVANCED"
You can also have the policy actually build the signature for the Signer
to use. To do this, call the signer's \fIadd_signature()\fR method from within
your \fIapply()\fR callback. E.g.,
.PP
.Vb 4
\&  sub apply
\&  {
\&      my $self = shift;
\&      my $signer = shift;
\&  
\&      $signer\->add_signature(
\&              new Mail::DKIM::Signature(
\&                  Algorithm => $signer\->algorithm,
\&                  Method => $signer\->method,
\&                  Headers => $signer\->headers,
\&                  Domain => $signer\->domain,
\&                  Selector => $signer\->selector,
\&              ));
\&      return;
\&  }
.Ve
.PP
Again, if you do not want any signatures, return zero or undef. If you
use \fIadd_signature()\fR to create a signature, the default signature will
not be created, even if you return nonzero.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::TextWrap.3pm                     0100644 0001750 0001750 00000021267 12566242060 024702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::TextWrap 3"
.TH Mail::DKIM::TextWrap 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::TextWrap \- text wrapping module written for use with DKIM
.SH "SYNOPSIS (FOR MAIL::DKIM USERS)"
.IX Header "SYNOPSIS (FOR MAIL::DKIM USERS)"
.Vb 1
\&  use Mail::DKIM::TextWrap;
.Ve
.PP
Just add the above line to any program that uses Mail::DKIM::Signer
and your signatures will automatically be wrapped to 72 characters.
.SH "SYNOPSIS (FOR OTHER USERS)"
.IX Header "SYNOPSIS (FOR OTHER USERS)"
.Vb 7
\&  my $output = "";
\&  my $tw = Mail::DKIM::TextWrap\->new(
\&                  Margin => 10,
\&                  Output => \e$output,
\&              );
\&  $tw\->add("Mary had a little lamb, whose fleece was white as snow.\en");
\&  $tw\->finish;
\&
\&  print $output;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a general-purpose text-wrapping module that I wrote because
I had some specific needs with Mail::DKIM that none of the
contemporary text-wrapping modules offered.
.PP
Specifically, it offers the ability to change wrapping options
in the middle of a paragraph. For instance, with a \s-1DKIM\s0 signature:
.PP
.Vb 2
\&  DKIM\-Signature: a=rsa; c=simple; h=first:second:third:fourth;
\&          b=Xr2mo2wmb1LZBwmEJElIPezal7wQQkRQ8WZtxpofkNmXTjXf8y2f0
.Ve
.PP
the line-breaks can be inserted next to any of the colons of the h= tag,
or any character of the b= tag. The way I implemented this was to
serialize the signature one element at a time, changing the
text-wrapping options at the start and end of each tag.
.SH "TEXT WRAPPING OPTIONS"
.IX Header "TEXT WRAPPING OPTIONS"
Text wrapping options can be specified when calling \fInew()\fR, or
by simply changing the property as needed. For example, to change
the number of characters allowed per line:
.PP
.Vb 1
\&  $tw\->{Margin} = 20;
.Ve
.IP "Break" 4
.IX Item "Break"
a regular expression matching characters where a line break
can be inserted. Line breaks are inserted \s-1AFTER\s0 a matching substring.
The default is \f(CW\*(C`/\es/\*(C'\fR.
.IP "BreakBefore" 4
.IX Item "BreakBefore"
a regular expression matching characters where a line break
can be inserted. Line breaks are inserted \s-1BEFORE\s0 a matching substring.
Usually, you want to use Break, rather than BreakBefore.
The default is \f(CW\*(C`undef\*(C'\fR.
.IP "Margin" 4
.IX Item "Margin"
specifies how many characters to allow per line.
The default is 72. If no place to line-break is found on a line, the
line will extend beyond this margin.
.IP "Separator" 4
.IX Item "Separator"
the text to insert when a linebreak is needed.
The default is \*(L"\en\*(R". If you want to set a following-line indent
(e.g. all lines but the first begin with four spaces),
use something like \*(L"\en    \*(R".
.IP "Swallow" 4
.IX Item "Swallow"
a regular expression matching characters that can be omitted
when a line break occurs. For example, if you insert a line break
between two words, then you are replacing a \*(L"space\*(R" with the line
break, so you are omitting the space. On the other hand, if you
insert a line break between two parts of a hyphenated word, then
you are breaking at the hyphen, but you still want to display the
hyphen.
The default is \f(CW\*(C`/\es/\*(C'\fR.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP \- create a new text-wrapping object"
.IX Subsection "new() - create a new text-wrapping object"
.Vb 4
\&  my $tw = Mail::DKIM::TextWrap\->new(
\&                      Output => \e$output,
\&                      %wrapping_options,
\&                  );
.Ve
.PP
The text-wrapping object encapsulates the current options and the
current state of the text stream. In addition to specifying text
wrapping options as described in the section above, the following
options are recognized:
.IP "Output" 4
.IX Item "Output"
a scalar reference, or a glob reference, to specify where the
\&\*(L"wrapped\*(R" text gets output to. If not specified, the default of
\&\s-1STDOUT\s0 is used.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd()\fP \- process some text that can be wrapped"
.IX Subsection "add() - process some text that can be wrapped"
.Vb 1
\&  $tw\->add("Mary had a little lamb.\en");
.Ve
.PP
You can \fIadd()\fR all the text at once, or \fIadd()\fR the text in parts by calling
\&\fIadd()\fR multiple times.
.SS "\fIfinish()\fP \- call when no more text is to be added"
.IX Subsection "finish() - call when no more text is to be added"
.Vb 1
\&  $tw\->finish;
.Ve
.PP
Call this when finished adding text, so that any remaining text
in TextWrap's buffers will be output.
.SS "\fIflush()\fP \- output the current partial word, if any"
.IX Subsection "flush() - output the current partial word, if any"
.Vb 1
\&  $tw\->flush;
.Ve
.PP
Call this whenever changing TextWrap's parameters in the middle
of a string of words. It explicitly allows a line-break at the
current position in the string, regardless of whether it matches
the current break pattern.
                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::TextWrap5.16.3pm                 0100644 0001750 0001750 00000020746 12566242072 025220  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::TextWrap 3"
.TH Mail::DKIM::TextWrap 3 "2010-02-28" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::TextWrap \- text wrapping module written for use with DKIM
.SH "SYNOPSIS (FOR MAIL::DKIM USERS)"
.IX Header "SYNOPSIS (FOR MAIL::DKIM USERS)"
.Vb 1
\&  use Mail::DKIM::TextWrap;
.Ve
.PP
Just add the above line to any program that uses Mail::DKIM::Signer
and your signatures will automatically be wrapped to 72 characters.
.SH "SYNOPSIS (FOR OTHER USERS)"
.IX Header "SYNOPSIS (FOR OTHER USERS)"
.Vb 7
\&  my $output = "";
\&  my $tw = Mail::DKIM::TextWrap\->new(
\&                  Margin => 10,
\&                  Output => \e$output,
\&              );
\&  $tw\->add("Mary had a little lamb, whose fleece was white as snow.\en");
\&  $tw\->finish;
\&
\&  print $output;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a general-purpose text-wrapping module that I wrote because
I had some specific needs with Mail::DKIM that none of the
contemporary text-wrapping modules offered.
.PP
Specifically, it offers the ability to change wrapping options
in the middle of a paragraph. For instance, with a \s-1DKIM\s0 signature:
.PP
.Vb 2
\&  DKIM\-Signature: a=rsa; c=simple; h=first:second:third:fourth;
\&          b=Xr2mo2wmb1LZBwmEJElIPezal7wQQkRQ8WZtxpofkNmXTjXf8y2f0
.Ve
.PP
the line-breaks can be inserted next to any of the colons of the h= tag,
or any character of the b= tag. The way I implemented this was to
serialize the signature one element at a time, changing the
text-wrapping options at the start and end of each tag.
.SH "TEXT WRAPPING OPTIONS"
.IX Header "TEXT WRAPPING OPTIONS"
Text wrapping options can be specified when calling \fInew()\fR, or
by simply changing the property as needed. For example, to change
the number of characters allowed per line:
.PP
.Vb 1
\&  $tw\->{Margin} = 20;
.Ve
.IP "Break" 4
.IX Item "Break"
a regular expression matching characters where a line break
can be inserted. Line breaks are inserted \s-1AFTER\s0 a matching substring.
The default is \f(CW\*(C`/\es/\*(C'\fR.
.IP "BreakBefore" 4
.IX Item "BreakBefore"
a regular expression matching characters where a line break
can be inserted. Line breaks are inserted \s-1BEFORE\s0 a matching substring.
Usually, you want to use Break, rather than BreakBefore.
The default is \f(CW\*(C`undef\*(C'\fR.
.IP "Margin" 4
.IX Item "Margin"
specifies how many characters to allow per line.
The default is 72. If no place to line-break is found on a line, the
line will extend beyond this margin.
.IP "Separator" 4
.IX Item "Separator"
the text to insert when a linebreak is needed.
The default is \*(L"\en\*(R". If you want to set a following-line indent
(e.g. all lines but the first begin with four spaces),
use something like \*(L"\en    \*(R".
.IP "Swallow" 4
.IX Item "Swallow"
a regular expression matching characters that can be omitted
when a line break occurs. For example, if you insert a line break
between two words, then you are replacing a \*(L"space\*(R" with the line
break, so you are omitting the space. On the other hand, if you
insert a line break between two parts of a hyphenated word, then
you are breaking at the hyphen, but you still want to display the
hyphen.
The default is \f(CW\*(C`/\es/\*(C'\fR.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP \- create a new text-wrapping object"
.IX Subsection "new() - create a new text-wrapping object"
.Vb 4
\&  my $tw = Mail::DKIM::TextWrap\->new(
\&                      Output => \e$output,
\&                      %wrapping_options,
\&                  );
.Ve
.PP
The text-wrapping object encapsulates the current options and the
current state of the text stream. In addition to specifying text
wrapping options as described in the section above, the following
options are recognized:
.IP "Output" 4
.IX Item "Output"
a scalar reference, or a glob reference, to specify where the
\&\*(L"wrapped\*(R" text gets output to. If not specified, the default of
\&\s-1STDOUT\s0 is used.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd()\fP \- process some text that can be wrapped"
.IX Subsection "add() - process some text that can be wrapped"
.Vb 1
\&  $tw\->add("Mary had a little lamb.\en");
.Ve
.PP
You can \fIadd()\fR all the text at once, or \fIadd()\fR the text in parts by calling
\&\fIadd()\fR multiple times.
.SS "\fIfinish()\fP \- call when no more text is to be added"
.IX Subsection "finish() - call when no more text is to be added"
.Vb 1
\&  $tw\->finish;
.Ve
.PP
Call this when finished adding text, so that any remaining text
in TextWrap's buffers will be output.
.SS "\fIflush()\fP \- output the current partial word, if any"
.IX Subsection "flush() - output the current partial word, if any"
.Vb 1
\&  $tw\->flush;
.Ve
.PP
Call this whenever changing TextWrap's parameters in the middle
of a string of words. It explicitly allows a line-break at the
current position in the string, regardless of whether it matches
the current break pattern.
                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::TextWrap5.18.3pm                 0100644 0001750 0001750 00000021267 12566242060 025216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::TextWrap 3"
.TH Mail::DKIM::TextWrap 3 "2012-11-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::TextWrap \- text wrapping module written for use with DKIM
.SH "SYNOPSIS (FOR MAIL::DKIM USERS)"
.IX Header "SYNOPSIS (FOR MAIL::DKIM USERS)"
.Vb 1
\&  use Mail::DKIM::TextWrap;
.Ve
.PP
Just add the above line to any program that uses Mail::DKIM::Signer
and your signatures will automatically be wrapped to 72 characters.
.SH "SYNOPSIS (FOR OTHER USERS)"
.IX Header "SYNOPSIS (FOR OTHER USERS)"
.Vb 7
\&  my $output = "";
\&  my $tw = Mail::DKIM::TextWrap\->new(
\&                  Margin => 10,
\&                  Output => \e$output,
\&              );
\&  $tw\->add("Mary had a little lamb, whose fleece was white as snow.\en");
\&  $tw\->finish;
\&
\&  print $output;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a general-purpose text-wrapping module that I wrote because
I had some specific needs with Mail::DKIM that none of the
contemporary text-wrapping modules offered.
.PP
Specifically, it offers the ability to change wrapping options
in the middle of a paragraph. For instance, with a \s-1DKIM\s0 signature:
.PP
.Vb 2
\&  DKIM\-Signature: a=rsa; c=simple; h=first:second:third:fourth;
\&          b=Xr2mo2wmb1LZBwmEJElIPezal7wQQkRQ8WZtxpofkNmXTjXf8y2f0
.Ve
.PP
the line-breaks can be inserted next to any of the colons of the h= tag,
or any character of the b= tag. The way I implemented this was to
serialize the signature one element at a time, changing the
text-wrapping options at the start and end of each tag.
.SH "TEXT WRAPPING OPTIONS"
.IX Header "TEXT WRAPPING OPTIONS"
Text wrapping options can be specified when calling \fInew()\fR, or
by simply changing the property as needed. For example, to change
the number of characters allowed per line:
.PP
.Vb 1
\&  $tw\->{Margin} = 20;
.Ve
.IP "Break" 4
.IX Item "Break"
a regular expression matching characters where a line break
can be inserted. Line breaks are inserted \s-1AFTER\s0 a matching substring.
The default is \f(CW\*(C`/\es/\*(C'\fR.
.IP "BreakBefore" 4
.IX Item "BreakBefore"
a regular expression matching characters where a line break
can be inserted. Line breaks are inserted \s-1BEFORE\s0 a matching substring.
Usually, you want to use Break, rather than BreakBefore.
The default is \f(CW\*(C`undef\*(C'\fR.
.IP "Margin" 4
.IX Item "Margin"
specifies how many characters to allow per line.
The default is 72. If no place to line-break is found on a line, the
line will extend beyond this margin.
.IP "Separator" 4
.IX Item "Separator"
the text to insert when a linebreak is needed.
The default is \*(L"\en\*(R". If you want to set a following-line indent
(e.g. all lines but the first begin with four spaces),
use something like \*(L"\en    \*(R".
.IP "Swallow" 4
.IX Item "Swallow"
a regular expression matching characters that can be omitted
when a line break occurs. For example, if you insert a line break
between two words, then you are replacing a \*(L"space\*(R" with the line
break, so you are omitting the space. On the other hand, if you
insert a line break between two parts of a hyphenated word, then
you are breaking at the hyphen, but you still want to display the
hyphen.
The default is \f(CW\*(C`/\es/\*(C'\fR.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP \- create a new text-wrapping object"
.IX Subsection "new() - create a new text-wrapping object"
.Vb 4
\&  my $tw = Mail::DKIM::TextWrap\->new(
\&                      Output => \e$output,
\&                      %wrapping_options,
\&                  );
.Ve
.PP
The text-wrapping object encapsulates the current options and the
current state of the text stream. In addition to specifying text
wrapping options as described in the section above, the following
options are recognized:
.IP "Output" 4
.IX Item "Output"
a scalar reference, or a glob reference, to specify where the
\&\*(L"wrapped\*(R" text gets output to. If not specified, the default of
\&\s-1STDOUT\s0 is used.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIadd()\fP \- process some text that can be wrapped"
.IX Subsection "add() - process some text that can be wrapped"
.Vb 1
\&  $tw\->add("Mary had a little lamb.\en");
.Ve
.PP
You can \fIadd()\fR all the text at once, or \fIadd()\fR the text in parts by calling
\&\fIadd()\fR multiple times.
.SS "\fIfinish()\fP \- call when no more text is to be added"
.IX Subsection "finish() - call when no more text is to be added"
.Vb 1
\&  $tw\->finish;
.Ve
.PP
Call this when finished adding text, so that any remaining text
in TextWrap's buffers will be output.
.SS "\fIflush()\fP \- output the current partial word, if any"
.IX Subsection "flush() - output the current partial word, if any"
.Vb 1
\&  $tw\->flush;
.Ve
.PP
Call this whenever changing TextWrap's parameters in the middle
of a string of words. It explicitly allows a line-break at the
current position in the string, regardless of whether it matches
the current break pattern.
                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Verifier.3pm                     0100644 0001750 0001750 00000041531 12566242060 024673  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Verifier 3"
.TH Mail::DKIM::Verifier 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Verifier \- verifies a DKIM\-signed message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::DKIM::Verifier;
\&
\&  # create a verifier object
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  # read an email from a file handle
\&  $dkim\->load(*STDIN);
\&
\&  # or read an email and pass it into the verifier, incrementally
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the result of the verify?
\&  my $result = $dkim\->result;
\&
\&  # there might be multiple signatures, what is the result per signature?
\&  foreach my $signature ($dkim\->signatures)
\&  {
\&      print "signature identity: " . $signature\->identity . "\en";
\&      print "verify result: " . $signature\->result_detail . "\en";
\&  }
\&
\&  # the alleged author of the email may specify how to handle email
\&  foreach my $policy ($dkim\->policies)
\&  {
\&      die "fraudulent message" if ($policy\->apply($dkim) eq "reject");
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The verifier object allows an email message to be scanned for \s-1DKIM\s0 and
DomainKeys signatures and those signatures to be verified. The verifier
tracks the state of the message as it is read into memory. When the
message has been completely read, the signatures are verified and the
results of the verification can be accessed.
.PP
To use the verifier, first create the verifier object. Then start
\&\*(L"feeding\*(R" it the email message to be verified. When all the _headers_
have been read, the verifier:
.PP
.Vb 4
\& 1. checks whether any DomainKeys/DKIM signatures were found
\& 2. queries for the public keys needed to verify the signatures
\& 3. sets up the appropriate algorithms and canonicalization objects
\& 4. canonicalizes the headers and computes the header hash
.Ve
.PP
Then, when the _body_ of the message has been completely fed into the
verifier, the body hash is computed and the signatures are verified.
.PP
The results of the verification can be checked with \*(L"\fIresult()\fR\*(R"
or \*(L"\fIsignatures()\fR\*(R".
.PP
Messages that do not verify may be checked against the alleged sender's
published signing policy with \*(L"\fIpolicies()\fR\*(R" and
\&\*(L"\fIapply()\fR\*(R" in Mail::DKIM::Policy.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP"
.IX Subsection "new()"
Constructs an object-oriented verifier.
.PP
.Vb 1
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  my $dkim = Mail::DKIM::Verifier\->new(%options);
.Ve
.PP
The only option supported at this time is:
.IP "Debug_Canonicalization" 4
.IX Item "Debug_Canonicalization"
if specified, the canonicalized message for the first signature
is written to the referenced string or file handle.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1\fIPRINT\s0()\fP"
.IX Subsection "PRINT()"
Feeds part of the message to the verifier.
.PP
.Vb 3
\&  $dkim\->PRINT("a line of the message\e015\e012");
\&  $dkim\->PRINT("more of");
\&  $dkim\->PRINT(" the message\e015\e012bye\e015\e012");
.Ve
.PP
Feeds content of the message being verified into the verifier.
The \s-1API\s0 is designed this way so that the entire message does \s-1NOT\s0 need
to be read into memory at once.
.PP
Please note that although the \s-1\fIPRINT\s0()\fR method expects you to use
SMTP-style line termination characters, you should \s-1NOT\s0 use the
SMTP-style dot-stuffing technique described in \s-1RFC 2821\s0 section 4.5.2.
Nor should you use a <\s-1CR\s0><\s-1LF\s0>.<\s-1CR\s0><\s-1LF\s0> sequence to terminate the
message.
.SS "\s-1\fICLOSE\s0()\fP"
.IX Subsection "CLOSE()"
Call this when finished feeding in the message.
.PP
.Vb 1
\&  $dkim\->CLOSE;
.Ve
.PP
This method finishes the canonicalization process, computes a hash,
and verifies the signature.
.SS "\fIfetch_author_domain_policies()\fP"
.IX Subsection "fetch_author_domain_policies()"
Retrieves \s-1ADSP\s0 records from \s-1DNS.\s0
.PP
.Vb 5
\&  my @policies = $dkim\->fetch_author_domain_policies;
\&  foreach my $policy (@policies)
\&  {
\&      my $policy_result = $policy\->apply($dkim);
\&  }
.Ve
.PP
This method will retrieve all applicable
\&\*(L"author-domain-signing-practices\*(R" published in \s-1DNS\s0 for this message.
Author policies are keyed to the email address(es) in the From: header,
i.e. the claimed author of the message.
.PP
This method returns a *list* of policy records, since there is allowed
to be zero or multiple email addresses in the From: header.
.PP
The result of the \fIapply()\fR method is one of: \*(L"accept\*(R", \*(L"reject\*(R", \*(L"neutral\*(R".
.PP
See also: \*(L"\fIpolicies()\fR\*(R".
.SS "\fIfetch_author_policy()\fP"
.IX Subsection "fetch_author_policy()"
Retrieves a signing policy from \s-1DNS.\s0
.PP
.Vb 2
\&  my $policy = $dkim\->fetch_author_policy;
\&  my $policy_result = $policy\->apply($dkim);
.Ve
.PP
This method retrieves the \s-1DKIM\s0 Sender Signing Practices
record as described in Internet Draft draft\-ietf\-dkim\-ssp\-00\-01dc.
This Internet Draft is now obsolete; this method is only kept for
backward-compatibility purposes.
.PP
Please use the \*(L"\fIpolicies()\fR\*(R" method instead.
.SS "\fIfetch_sender_policy()\fP"
.IX Subsection "fetch_sender_policy()"
Retrieves a signing policy from \s-1DNS.\s0
.PP
.Vb 2
\&  my $policy = $dkim\->fetch_sender_policy;
\&  my $policy_result = $policy\->apply($dkim);
.Ve
.PP
The \*(L"sender\*(R" policy is the sender signing policy as described by the
DomainKeys specification, now available in \s-1RFC4870\s0(historical).
I call it the \*(L"sender\*(R" policy because it is keyed to the email address
in the Sender: header, or the From: header if there is no Sender header.
This is the person whom the message claims as the \*(L"transmitter\*(R" of the
message (not necessarily the author).
.PP
If the email being verified has no From or Sender header from which to
get an email address (which violates email standards),
then this method will \f(CW\*(C`die\*(C'\fR.
.PP
The result of the \fIapply()\fR method is one of: \*(L"accept\*(R", \*(L"reject\*(R", \*(L"neutral\*(R".
.PP
See also: \*(L"\fIpolicies()\fR\*(R".
.SS "\fIload()\fP"
.IX Subsection "load()"
Load the entire message from a file handle.
.PP
.Vb 1
\&  $dkim\->load($file_handle);
.Ve
.PP
Reads a complete message from the designated file handle,
feeding it into the verifier. The message must use <\s-1CRLF\s0> line
terminators (same as the \s-1SMTP\s0 protocol).
.SS "\fImessage_originator()\fP"
.IX Subsection "message_originator()"
Access the \*(L"From\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_originator;
.Ve
.PP
Returns the \*(L"originator address\*(R" found in the message, as a
Mail::Address object.
This is typically the (first) name and email address found in the
From: header. If there is no From: header,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_originator\->address;
.Ve
.PP
See also \*(L"\fImessage_sender()\fR\*(R".
.SS "\fImessage_sender()\fP"
.IX Subsection "message_sender()"
Access the \*(L"From\*(R" or \*(L"Sender\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_sender;
.Ve
.PP
Returns the \*(L"sender\*(R" found in the message, as a Mail::Address object.
This is typically the (first) name and email address found in the
Sender: header. If there is no Sender: header, it is the first name and
email address in the From: header. If neither header is present,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_sender\->address;
.Ve
.PP
The \*(L"sender\*(R" is the mailbox of the agent responsible for the actual
transmission of the message. For example, if a secretary were to send a
message for another person, the \*(L"sender\*(R" would be the secretary and
the \*(L"originator\*(R" would be the actual author.
.SS "\fIpolicies()\fP"
.IX Subsection "policies()"
Retrieves applicable signing policies from \s-1DNS.\s0
.PP
.Vb 6
\&  my @policies = $dkim\->policies;
\&  foreach my $policy (@policies)
\&  {
\&      $policy_result = $policy\->apply($dkim);
\&      # $policy_result is one of "accept", "reject", "neutral"
\&  }
.Ve
.PP
This method searches for and returns any signing policies that would
apply to this message. Signing policies are selected based on the
domain that the message *claims* to be from. So, for example, if
a message claims to be from security@bank, and forwarded by
trusted@listserv, when in reality the message came from foe@evilcorp,
this method would check for signing policies for security@bank and
trusted@listserv. The signing policies might tell whether
foe@evilcorp (the real sender) is allowed to send mail claiming
to be from your bank or your listserv.
.PP
I say \*(L"might tell\*(R", because in reality this is still really hard to
specify with any accuracy. In addition, most senders do not publish
useful policies.
.SS "\fIresult()\fP"
.IX Subsection "result()"
Access the result of the verification.
.PP
.Vb 1
\&  my $result = $dkim\->result;
.Ve
.PP
Gives the result of the verification. The following values are possible:
.IP "pass" 4
.IX Item "pass"
Returned if a valid DKIM-Signature header was found, and the signature
contains a correct value for the message.
.IP "fail" 4
.IX Item "fail"
Returned if a valid DKIM-Signature header was found, but the signature
does not contain a correct value for the message.
.IP "invalid" 4
.IX Item "invalid"
Returned if a DKIM-Signature could not be checked because of a problem
in the signature itself or the public key record. I.e. the signature
could not be processed.
.IP "temperror" 4
.IX Item "temperror"
Returned if a DKIM-Signature could not be checked due to some error
which is likely transient in nature, such as a temporary inability
to retrieve a public key. A later attempt may produce a better
result.
.IP "none" 4
.IX Item "none"
Returned if no DKIM-Signature headers (valid or invalid) were found.
.PP
In case of multiple signatures, the \*(L"best\*(R" result will be returned.
Best is defined as \*(L"pass\*(R", followed by \*(L"fail\*(R", \*(L"invalid\*(R", and \*(L"none\*(R".
To examine the results of individual signatures, use the \*(L"\fIsignatures()\fR\*(R"
method to retrieve the signature objects. See
\&\*(L"\fIresult()\fR\*(R" in Mail::DKIM::Signature.
.SS "\fIresult_detail()\fP"
.IX Subsection "result_detail()"
Access the result, plus details if available.
.PP
.Vb 1
\&  my $detail = $dkim\->result_detail;
.Ve
.PP
The detail is constructed by taking the result (e.g. \*(L"pass\*(R", \*(L"fail\*(R",
\&\*(L"invalid\*(R" or \*(L"none\*(R") and appending any details provided by the verification
process in parenthesis.
.PP
The following are possible results from the \fIresult_detail()\fR method:
.PP
.Vb 10
\&  pass
\&  fail (bad RSA signature)
\&  fail (OpenSSL error: ...)
\&  fail (message has been altered)
\&  fail (body has been altered)
\&  invalid (bad identity)
\&  invalid (invalid domain in d tag)
\&  invalid (missing q tag)
\&  invalid (missing d tag)
\&  invalid (missing s tag)
\&  invalid (unsupported version 0.1)
\&  invalid (unsupported algorithm ...)
\&  invalid (unsupported canonicalization ...)
\&  invalid (unsupported query protocol ...)
\&  invalid (signature is expired)
\&  invalid (public key: not available)
\&  invalid (public key: unknown query type ...)
\&  invalid (public key: syntax error)
\&  invalid (public key: unsupported version)
\&  invalid (public key: unsupported key type)
\&  invalid (public key: missing p= tag)
\&  invalid (public key: invalid data)
\&  invalid (public key: does not support email)
\&  invalid (public key: does not support hash algorithm \*(Aqsha1\*(Aq)
\&  invalid (public key: does not support signing subdomains)
\&  invalid (public key: revoked)
\&  invalid (public key: granularity mismatch)
\&  invalid (public key: granularity is empty)
\&  invalid (public key: OpenSSL error: ...)
\&  none
.Ve
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Access the message's \s-1DKIM\s0 signature.
.PP
.Vb 1
\&  my $sig = $dkim\->signature;
.Ve
.PP
Accesses the signature found and verified in this message. The returned
object is of type Mail::DKIM::Signature.
.PP
In case of multiple signatures, the signature with the \*(L"best\*(R" result will
be returned.
Best is defined as \*(L"pass\*(R", followed by \*(L"fail\*(R", \*(L"invalid\*(R", and \*(L"none\*(R".
.SS "\fIsignatures()\fP"
.IX Subsection "signatures()"
Access all of this message's signatures.
.PP
.Vb 1
\&  my @all_signatures = $dkim\->signatures;
.Ve
.PP
Use \f(CW$signature\fR\->result or \f(CW$signature\fR\->result_detail to access
the verification results of each signature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Verifier5.16.3pm                 0100644 0001750 0001750 00000041210 12566242072 025202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Verifier 3"
.TH Mail::DKIM::Verifier 3 "2010-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Verifier \- verifies a DKIM\-signed message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::DKIM::Verifier;
\&
\&  # create a verifier object
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  # read an email from a file handle
\&  $dkim\->load(*STDIN);
\&
\&  # or read an email and pass it into the verifier, incrementally
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the result of the verify?
\&  my $result = $dkim\->result;
\&
\&  # there might be multiple signatures, what is the result per signature?
\&  foreach my $signature ($dkim\->signatures)
\&  {
\&      print "signature identity: " . $signature\->identity . "\en";
\&      print "verify result: " . $signature\->result_detail . "\en";
\&  }
\&
\&  # the alleged author of the email may specify how to handle email
\&  foreach my $policy ($dkim\->policies)
\&  {
\&      die "fraudulent message" if ($policy\->apply($dkim) eq "reject");
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The verifier object allows an email message to be scanned for \s-1DKIM\s0 and
DomainKeys signatures and those signatures to be verified. The verifier
tracks the state of the message as it is read into memory. When the
message has been completely read, the signatures are verified and the
results of the verification can be accessed.
.PP
To use the verifier, first create the verifier object. Then start
\&\*(L"feeding\*(R" it the email message to be verified. When all the _headers_
have been read, the verifier:
.PP
.Vb 4
\& 1. checks whether any DomainKeys/DKIM signatures were found
\& 2. queries for the public keys needed to verify the signatures
\& 3. sets up the appropriate algorithms and canonicalization objects
\& 4. canonicalizes the headers and computes the header hash
.Ve
.PP
Then, when the _body_ of the message has been completely fed into the
verifier, the body hash is computed and the signatures are verified.
.PP
The results of the verification can be checked with \*(L"\fIresult()\fR\*(R"
or \*(L"\fIsignatures()\fR\*(R".
.PP
Messages that do not verify may be checked against the alleged sender's
published signing policy with \*(L"\fIpolicies()\fR\*(R" and
\&\*(L"\fIapply()\fR\*(R" in Mail::DKIM::Policy.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP"
.IX Subsection "new()"
Constructs an object-oriented verifier.
.PP
.Vb 1
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  my $dkim = Mail::DKIM::Verifier\->new(%options);
.Ve
.PP
The only option supported at this time is:
.IP "Debug_Canonicalization" 4
.IX Item "Debug_Canonicalization"
if specified, the canonicalized message for the first signature
is written to the referenced string or file handle.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1\fIPRINT\s0()\fP"
.IX Subsection "PRINT()"
Feeds part of the message to the verifier.
.PP
.Vb 3
\&  $dkim\->PRINT("a line of the message\e015\e012");
\&  $dkim\->PRINT("more of");
\&  $dkim\->PRINT(" the message\e015\e012bye\e015\e012");
.Ve
.PP
Feeds content of the message being verified into the verifier.
The \s-1API\s0 is designed this way so that the entire message does \s-1NOT\s0 need
to be read into memory at once.
.PP
Please note that although the \s-1\fIPRINT\s0()\fR method expects you to use
SMTP-style line termination characters, you should \s-1NOT\s0 use the
SMTP-style dot-stuffing technique described in \s-1RFC\s0 2821 section 4.5.2.
Nor should you use a <\s-1CR\s0><\s-1LF\s0>.<\s-1CR\s0><\s-1LF\s0> sequence to terminate the
message.
.SS "\s-1\fICLOSE\s0()\fP"
.IX Subsection "CLOSE()"
Call this when finished feeding in the message.
.PP
.Vb 1
\&  $dkim\->CLOSE;
.Ve
.PP
This method finishes the canonicalization process, computes a hash,
and verifies the signature.
.SS "\fIfetch_author_domain_policies()\fP"
.IX Subsection "fetch_author_domain_policies()"
Retrieves \s-1ADSP\s0 records from \s-1DNS\s0.
.PP
.Vb 5
\&  my @policies = $dkim\->fetch_author_domain_policies;
\&  foreach my $policy (@policies)
\&  {
\&      my $policy_result = $policy\->apply($dkim);
\&  }
.Ve
.PP
This method will retrieve all applicable
\&\*(L"author-domain-signing-practices\*(R" published in \s-1DNS\s0 for this message.
Author policies are keyed to the email address(es) in the From: header,
i.e. the claimed author of the message.
.PP
This method returns a *list* of policy records, since there is allowed
to be zero or multiple email addresses in the From: header.
.PP
The result of the \fIapply()\fR method is one of: \*(L"accept\*(R", \*(L"reject\*(R", \*(L"neutral\*(R".
.PP
See also: \*(L"\fIpolicies()\fR\*(R".
.SS "\fIfetch_author_policy()\fP"
.IX Subsection "fetch_author_policy()"
Retrieves a signing policy from \s-1DNS\s0.
.PP
.Vb 2
\&  my $policy = $dkim\->fetch_author_policy;
\&  my $policy_result = $policy\->apply($dkim);
.Ve
.PP
This method retrieves the \s-1DKIM\s0 Sender Signing Practices
record as described in Internet Draft draft\-ietf\-dkim\-ssp\-00\-01dc.
This Internet Draft is now obsolete; this method is only kept for
backward-compatibility purposes.
.PP
Please use the \*(L"\fIpolicies()\fR\*(R" method instead.
.SS "\fIfetch_sender_policy()\fP"
.IX Subsection "fetch_sender_policy()"
Retrieves a signing policy from \s-1DNS\s0.
.PP
.Vb 2
\&  my $policy = $dkim\->fetch_sender_policy;
\&  my $policy_result = $policy\->apply($dkim);
.Ve
.PP
The \*(L"sender\*(R" policy is the sender signing policy as described by the
DomainKeys specification, now available in \s-1RFC4870\s0(historical).
I call it the \*(L"sender\*(R" policy because it is keyed to the email address
in the Sender: header, or the From: header if there is no Sender header.
This is the person whom the message claims as the \*(L"transmitter\*(R" of the
message (not necessarily the author).
.PP
If the email being verified has no From or Sender header from which to
get an email address (which violates email standards),
then this method will \f(CW\*(C`die\*(C'\fR.
.PP
The result of the \fIapply()\fR method is one of: \*(L"accept\*(R", \*(L"reject\*(R", \*(L"neutral\*(R".
.PP
See also: \*(L"\fIpolicies()\fR\*(R".
.SS "\fIload()\fP"
.IX Subsection "load()"
Load the entire message from a file handle.
.PP
.Vb 1
\&  $dkim\->load($file_handle);
.Ve
.PP
Reads a complete message from the designated file handle,
feeding it into the verifier. The message must use <\s-1CRLF\s0> line
terminators (same as the \s-1SMTP\s0 protocol).
.SS "\fImessage_originator()\fP"
.IX Subsection "message_originator()"
Access the \*(L"From\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_originator;
.Ve
.PP
Returns the \*(L"originator address\*(R" found in the message, as a
Mail::Address object.
This is typically the (first) name and email address found in the
From: header. If there is no From: header,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_originator\->address;
.Ve
.PP
See also \*(L"\fImessage_sender()\fR\*(R".
.SS "\fImessage_sender()\fP"
.IX Subsection "message_sender()"
Access the \*(L"From\*(R" or \*(L"Sender\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_sender;
.Ve
.PP
Returns the \*(L"sender\*(R" found in the message, as a Mail::Address object.
This is typically the (first) name and email address found in the
Sender: header. If there is no Sender: header, it is the first name and
email address in the From: header. If neither header is present,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_sender\->address;
.Ve
.PP
The \*(L"sender\*(R" is the mailbox of the agent responsible for the actual
transmission of the message. For example, if a secretary were to send a
message for another person, the \*(L"sender\*(R" would be the secretary and
the \*(L"originator\*(R" would be the actual author.
.SS "\fIpolicies()\fP"
.IX Subsection "policies()"
Retrieves applicable signing policies from \s-1DNS\s0.
.PP
.Vb 6
\&  my @policies = $dkim\->policies;
\&  foreach my $policy (@policies)
\&  {
\&      $policy_result = $policy\->apply($dkim);
\&      # $policy_result is one of "accept", "reject", "neutral"
\&  }
.Ve
.PP
This method searches for and returns any signing policies that would
apply to this message. Signing policies are selected based on the
domain that the message *claims* to be from. So, for example, if
a message claims to be from security@bank, and forwarded by
trusted@listserv, when in reality the message came from foe@evilcorp,
this method would check for signing policies for security@bank and
trusted@listserv. The signing policies might tell whether
foe@evilcorp (the real sender) is allowed to send mail claiming
to be from your bank or your listserv.
.PP
I say \*(L"might tell\*(R", because in reality this is still really hard to
specify with any accuracy. In addition, most senders do not publish
useful policies.
.SS "\fIresult()\fP"
.IX Subsection "result()"
Access the result of the verification.
.PP
.Vb 1
\&  my $result = $dkim\->result;
.Ve
.PP
Gives the result of the verification. The following values are possible:
.IP "pass" 4
.IX Item "pass"
Returned if a valid DKIM-Signature header was found, and the signature
contains a correct value for the message.
.IP "fail" 4
.IX Item "fail"
Returned if a valid DKIM-Signature header was found, but the signature
does not contain a correct value for the message.
.IP "invalid" 4
.IX Item "invalid"
Returned if a DKIM-Signature could not be checked because of a problem
in the signature itself or the public key record. I.e. the signature
could not be processed.
.IP "temperror" 4
.IX Item "temperror"
Returned if a DKIM-Signature could not be checked due to some error
which is likely transient in nature, such as a temporary inability
to retrieve a public key. A later attempt may produce a better
result.
.IP "none" 4
.IX Item "none"
Returned if no DKIM-Signature headers (valid or invalid) were found.
.PP
In case of multiple signatures, the \*(L"best\*(R" result will be returned.
Best is defined as \*(L"pass\*(R", followed by \*(L"fail\*(R", \*(L"invalid\*(R", and \*(L"none\*(R".
To examine the results of individual signatures, use the \*(L"\fIsignatures()\fR\*(R"
method to retrieve the signature objects. See
\&\*(L"\fIresult()\fR\*(R" in Mail::DKIM::Signature.
.SS "\fIresult_detail()\fP"
.IX Subsection "result_detail()"
Access the result, plus details if available.
.PP
.Vb 1
\&  my $detail = $dkim\->result_detail;
.Ve
.PP
The detail is constructed by taking the result (e.g. \*(L"pass\*(R", \*(L"fail\*(R",
\&\*(L"invalid\*(R" or \*(L"none\*(R") and appending any details provided by the verification
process in parenthesis.
.PP
The following are possible results from the \fIresult_detail()\fR method:
.PP
.Vb 10
\&  pass
\&  fail (bad RSA signature)
\&  fail (OpenSSL error: ...)
\&  fail (message has been altered)
\&  fail (body has been altered)
\&  invalid (bad identity)
\&  invalid (invalid domain in d tag)
\&  invalid (missing q tag)
\&  invalid (missing d tag)
\&  invalid (missing s tag)
\&  invalid (unsupported version 0.1)
\&  invalid (unsupported algorithm ...)
\&  invalid (unsupported canonicalization ...)
\&  invalid (unsupported query protocol ...)
\&  invalid (signature is expired)
\&  invalid (public key: not available)
\&  invalid (public key: unknown query type ...)
\&  invalid (public key: syntax error)
\&  invalid (public key: unsupported version)
\&  invalid (public key: unsupported key type)
\&  invalid (public key: missing p= tag)
\&  invalid (public key: invalid data)
\&  invalid (public key: does not support email)
\&  invalid (public key: does not support hash algorithm \*(Aqsha1\*(Aq)
\&  invalid (public key: does not support signing subdomains)
\&  invalid (public key: revoked)
\&  invalid (public key: granularity mismatch)
\&  invalid (public key: granularity is empty)
\&  invalid (public key: OpenSSL error: ...)
\&  none
.Ve
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Access the message's \s-1DKIM\s0 signature.
.PP
.Vb 1
\&  my $sig = $dkim\->signature;
.Ve
.PP
Accesses the signature found and verified in this message. The returned
object is of type Mail::DKIM::Signature.
.PP
In case of multiple signatures, the signature with the \*(L"best\*(R" result will
be returned.
Best is defined as \*(L"pass\*(R", followed by \*(L"fail\*(R", \*(L"invalid\*(R", and \*(L"none\*(R".
.SS "\fIsignatures()\fP"
.IX Subsection "signatures()"
Access all of this message's signatures.
.PP
.Vb 1
\&  my @all_signatures = $dkim\->signatures;
.Ve
.PP
Use \f(CW$signature\fR\->result or \f(CW$signature\fR\->result_detail to access
the verification results of each signature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::DKIM::Verifier5.18.3pm                 0100644 0001750 0001750 00000041531 12566242060 025207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::DKIM::Verifier 3"
.TH Mail::DKIM::Verifier 3 "2013-02-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::DKIM::Verifier \- verifies a DKIM\-signed message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::DKIM::Verifier;
\&
\&  # create a verifier object
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  # read an email from a file handle
\&  $dkim\->load(*STDIN);
\&
\&  # or read an email and pass it into the verifier, incrementally
\&  while (<STDIN>)
\&  {
\&      # remove local line terminators
\&      chomp;
\&      s/\e015$//;
\&
\&      # use SMTP line terminators
\&      $dkim\->PRINT("$_\e015\e012");
\&  }
\&  $dkim\->CLOSE;
\&
\&  # what is the result of the verify?
\&  my $result = $dkim\->result;
\&
\&  # there might be multiple signatures, what is the result per signature?
\&  foreach my $signature ($dkim\->signatures)
\&  {
\&      print "signature identity: " . $signature\->identity . "\en";
\&      print "verify result: " . $signature\->result_detail . "\en";
\&  }
\&
\&  # the alleged author of the email may specify how to handle email
\&  foreach my $policy ($dkim\->policies)
\&  {
\&      die "fraudulent message" if ($policy\->apply($dkim) eq "reject");
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The verifier object allows an email message to be scanned for \s-1DKIM\s0 and
DomainKeys signatures and those signatures to be verified. The verifier
tracks the state of the message as it is read into memory. When the
message has been completely read, the signatures are verified and the
results of the verification can be accessed.
.PP
To use the verifier, first create the verifier object. Then start
\&\*(L"feeding\*(R" it the email message to be verified. When all the _headers_
have been read, the verifier:
.PP
.Vb 4
\& 1. checks whether any DomainKeys/DKIM signatures were found
\& 2. queries for the public keys needed to verify the signatures
\& 3. sets up the appropriate algorithms and canonicalization objects
\& 4. canonicalizes the headers and computes the header hash
.Ve
.PP
Then, when the _body_ of the message has been completely fed into the
verifier, the body hash is computed and the signatures are verified.
.PP
The results of the verification can be checked with \*(L"\fIresult()\fR\*(R"
or \*(L"\fIsignatures()\fR\*(R".
.PP
Messages that do not verify may be checked against the alleged sender's
published signing policy with \*(L"\fIpolicies()\fR\*(R" and
\&\*(L"\fIapply()\fR\*(R" in Mail::DKIM::Policy.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "\fInew()\fP"
.IX Subsection "new()"
Constructs an object-oriented verifier.
.PP
.Vb 1
\&  my $dkim = Mail::DKIM::Verifier\->new();
\&
\&  my $dkim = Mail::DKIM::Verifier\->new(%options);
.Ve
.PP
The only option supported at this time is:
.IP "Debug_Canonicalization" 4
.IX Item "Debug_Canonicalization"
if specified, the canonicalized message for the first signature
is written to the referenced string or file handle.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1\fIPRINT\s0()\fP"
.IX Subsection "PRINT()"
Feeds part of the message to the verifier.
.PP
.Vb 3
\&  $dkim\->PRINT("a line of the message\e015\e012");
\&  $dkim\->PRINT("more of");
\&  $dkim\->PRINT(" the message\e015\e012bye\e015\e012");
.Ve
.PP
Feeds content of the message being verified into the verifier.
The \s-1API\s0 is designed this way so that the entire message does \s-1NOT\s0 need
to be read into memory at once.
.PP
Please note that although the \s-1\fIPRINT\s0()\fR method expects you to use
SMTP-style line termination characters, you should \s-1NOT\s0 use the
SMTP-style dot-stuffing technique described in \s-1RFC 2821\s0 section 4.5.2.
Nor should you use a <\s-1CR\s0><\s-1LF\s0>.<\s-1CR\s0><\s-1LF\s0> sequence to terminate the
message.
.SS "\s-1\fICLOSE\s0()\fP"
.IX Subsection "CLOSE()"
Call this when finished feeding in the message.
.PP
.Vb 1
\&  $dkim\->CLOSE;
.Ve
.PP
This method finishes the canonicalization process, computes a hash,
and verifies the signature.
.SS "\fIfetch_author_domain_policies()\fP"
.IX Subsection "fetch_author_domain_policies()"
Retrieves \s-1ADSP\s0 records from \s-1DNS.\s0
.PP
.Vb 5
\&  my @policies = $dkim\->fetch_author_domain_policies;
\&  foreach my $policy (@policies)
\&  {
\&      my $policy_result = $policy\->apply($dkim);
\&  }
.Ve
.PP
This method will retrieve all applicable
\&\*(L"author-domain-signing-practices\*(R" published in \s-1DNS\s0 for this message.
Author policies are keyed to the email address(es) in the From: header,
i.e. the claimed author of the message.
.PP
This method returns a *list* of policy records, since there is allowed
to be zero or multiple email addresses in the From: header.
.PP
The result of the \fIapply()\fR method is one of: \*(L"accept\*(R", \*(L"reject\*(R", \*(L"neutral\*(R".
.PP
See also: \*(L"\fIpolicies()\fR\*(R".
.SS "\fIfetch_author_policy()\fP"
.IX Subsection "fetch_author_policy()"
Retrieves a signing policy from \s-1DNS.\s0
.PP
.Vb 2
\&  my $policy = $dkim\->fetch_author_policy;
\&  my $policy_result = $policy\->apply($dkim);
.Ve
.PP
This method retrieves the \s-1DKIM\s0 Sender Signing Practices
record as described in Internet Draft draft\-ietf\-dkim\-ssp\-00\-01dc.
This Internet Draft is now obsolete; this method is only kept for
backward-compatibility purposes.
.PP
Please use the \*(L"\fIpolicies()\fR\*(R" method instead.
.SS "\fIfetch_sender_policy()\fP"
.IX Subsection "fetch_sender_policy()"
Retrieves a signing policy from \s-1DNS.\s0
.PP
.Vb 2
\&  my $policy = $dkim\->fetch_sender_policy;
\&  my $policy_result = $policy\->apply($dkim);
.Ve
.PP
The \*(L"sender\*(R" policy is the sender signing policy as described by the
DomainKeys specification, now available in \s-1RFC4870\s0(historical).
I call it the \*(L"sender\*(R" policy because it is keyed to the email address
in the Sender: header, or the From: header if there is no Sender header.
This is the person whom the message claims as the \*(L"transmitter\*(R" of the
message (not necessarily the author).
.PP
If the email being verified has no From or Sender header from which to
get an email address (which violates email standards),
then this method will \f(CW\*(C`die\*(C'\fR.
.PP
The result of the \fIapply()\fR method is one of: \*(L"accept\*(R", \*(L"reject\*(R", \*(L"neutral\*(R".
.PP
See also: \*(L"\fIpolicies()\fR\*(R".
.SS "\fIload()\fP"
.IX Subsection "load()"
Load the entire message from a file handle.
.PP
.Vb 1
\&  $dkim\->load($file_handle);
.Ve
.PP
Reads a complete message from the designated file handle,
feeding it into the verifier. The message must use <\s-1CRLF\s0> line
terminators (same as the \s-1SMTP\s0 protocol).
.SS "\fImessage_originator()\fP"
.IX Subsection "message_originator()"
Access the \*(L"From\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_originator;
.Ve
.PP
Returns the \*(L"originator address\*(R" found in the message, as a
Mail::Address object.
This is typically the (first) name and email address found in the
From: header. If there is no From: header,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_originator\->address;
.Ve
.PP
See also \*(L"\fImessage_sender()\fR\*(R".
.SS "\fImessage_sender()\fP"
.IX Subsection "message_sender()"
Access the \*(L"From\*(R" or \*(L"Sender\*(R" header.
.PP
.Vb 1
\&  my $address = $dkim\->message_sender;
.Ve
.PP
Returns the \*(L"sender\*(R" found in the message, as a Mail::Address object.
This is typically the (first) name and email address found in the
Sender: header. If there is no Sender: header, it is the first name and
email address in the From: header. If neither header is present,
then an empty Mail::Address object is returned.
.PP
To get just the email address part, do:
.PP
.Vb 1
\&  my $email = $dkim\->message_sender\->address;
.Ve
.PP
The \*(L"sender\*(R" is the mailbox of the agent responsible for the actual
transmission of the message. For example, if a secretary were to send a
message for another person, the \*(L"sender\*(R" would be the secretary and
the \*(L"originator\*(R" would be the actual author.
.SS "\fIpolicies()\fP"
.IX Subsection "policies()"
Retrieves applicable signing policies from \s-1DNS.\s0
.PP
.Vb 6
\&  my @policies = $dkim\->policies;
\&  foreach my $policy (@policies)
\&  {
\&      $policy_result = $policy\->apply($dkim);
\&      # $policy_result is one of "accept", "reject", "neutral"
\&  }
.Ve
.PP
This method searches for and returns any signing policies that would
apply to this message. Signing policies are selected based on the
domain that the message *claims* to be from. So, for example, if
a message claims to be from security@bank, and forwarded by
trusted@listserv, when in reality the message came from foe@evilcorp,
this method would check for signing policies for security@bank and
trusted@listserv. The signing policies might tell whether
foe@evilcorp (the real sender) is allowed to send mail claiming
to be from your bank or your listserv.
.PP
I say \*(L"might tell\*(R", because in reality this is still really hard to
specify with any accuracy. In addition, most senders do not publish
useful policies.
.SS "\fIresult()\fP"
.IX Subsection "result()"
Access the result of the verification.
.PP
.Vb 1
\&  my $result = $dkim\->result;
.Ve
.PP
Gives the result of the verification. The following values are possible:
.IP "pass" 4
.IX Item "pass"
Returned if a valid DKIM-Signature header was found, and the signature
contains a correct value for the message.
.IP "fail" 4
.IX Item "fail"
Returned if a valid DKIM-Signature header was found, but the signature
does not contain a correct value for the message.
.IP "invalid" 4
.IX Item "invalid"
Returned if a DKIM-Signature could not be checked because of a problem
in the signature itself or the public key record. I.e. the signature
could not be processed.
.IP "temperror" 4
.IX Item "temperror"
Returned if a DKIM-Signature could not be checked due to some error
which is likely transient in nature, such as a temporary inability
to retrieve a public key. A later attempt may produce a better
result.
.IP "none" 4
.IX Item "none"
Returned if no DKIM-Signature headers (valid or invalid) were found.
.PP
In case of multiple signatures, the \*(L"best\*(R" result will be returned.
Best is defined as \*(L"pass\*(R", followed by \*(L"fail\*(R", \*(L"invalid\*(R", and \*(L"none\*(R".
To examine the results of individual signatures, use the \*(L"\fIsignatures()\fR\*(R"
method to retrieve the signature objects. See
\&\*(L"\fIresult()\fR\*(R" in Mail::DKIM::Signature.
.SS "\fIresult_detail()\fP"
.IX Subsection "result_detail()"
Access the result, plus details if available.
.PP
.Vb 1
\&  my $detail = $dkim\->result_detail;
.Ve
.PP
The detail is constructed by taking the result (e.g. \*(L"pass\*(R", \*(L"fail\*(R",
\&\*(L"invalid\*(R" or \*(L"none\*(R") and appending any details provided by the verification
process in parenthesis.
.PP
The following are possible results from the \fIresult_detail()\fR method:
.PP
.Vb 10
\&  pass
\&  fail (bad RSA signature)
\&  fail (OpenSSL error: ...)
\&  fail (message has been altered)
\&  fail (body has been altered)
\&  invalid (bad identity)
\&  invalid (invalid domain in d tag)
\&  invalid (missing q tag)
\&  invalid (missing d tag)
\&  invalid (missing s tag)
\&  invalid (unsupported version 0.1)
\&  invalid (unsupported algorithm ...)
\&  invalid (unsupported canonicalization ...)
\&  invalid (unsupported query protocol ...)
\&  invalid (signature is expired)
\&  invalid (public key: not available)
\&  invalid (public key: unknown query type ...)
\&  invalid (public key: syntax error)
\&  invalid (public key: unsupported version)
\&  invalid (public key: unsupported key type)
\&  invalid (public key: missing p= tag)
\&  invalid (public key: invalid data)
\&  invalid (public key: does not support email)
\&  invalid (public key: does not support hash algorithm \*(Aqsha1\*(Aq)
\&  invalid (public key: does not support signing subdomains)
\&  invalid (public key: revoked)
\&  invalid (public key: granularity mismatch)
\&  invalid (public key: granularity is empty)
\&  invalid (public key: OpenSSL error: ...)
\&  none
.Ve
.SS "\fIsignature()\fP"
.IX Subsection "signature()"
Access the message's \s-1DKIM\s0 signature.
.PP
.Vb 1
\&  my $sig = $dkim\->signature;
.Ve
.PP
Accesses the signature found and verified in this message. The returned
object is of type Mail::DKIM::Signature.
.PP
In case of multiple signatures, the signature with the \*(L"best\*(R" result will
be returned.
Best is defined as \*(L"pass\*(R", followed by \*(L"fail\*(R", \*(L"invalid\*(R", and \*(L"none\*(R".
.SS "\fIsignatures()\fP"
.IX Subsection "signatures()"
Access all of this message's signatures.
.PP
.Vb 1
\&  my @all_signatures = $dkim\->signatures;
.Ve
.PP
Use \f(CW$signature\fR\->result or \f(CW$signature\fR\->result_detail to access
the verification results of each signature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jason Long, <jlong@messiah.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 by Messiah College
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field.3pm                              0100644 0001750 0001750 00000024100 12566241445 023311  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field 3"
.TH Mail::Field 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field \- Base class for manipulation of mail header fields
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\& Mail::Field is extended by
\&   Mail::Field::AddrList
\&   Mail::Field::Date
\&   Mail::Field::Generic
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Field;
\&    
\& my $field = Mail::Field\->new(\*(AqSubject\*(Aq, \*(Aqsome subject text\*(Aq);
\& my $field = Mail::Field\->new(Subject => \*(Aqsome subject text\*(Aq);
\& print $field\->tag,": ",$field\->stringify,"\en";
\&
\& my $field = Mail::Field\->subject(\*(Aqsome subject text\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Field\*(C'\fR creates and manipulates fields in \s-1MIME\s0 headers, collected
within a Mail::Header object.  Different field types have their
own sub-class (extension), defining additional useful accessors to the
field content.
.PP
People are invited to merge their implementation to special fields into
MailTools, to maintain a consistent set of packages and documentation.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
Mail::Field (and it's sub-classes) define several methods which return
new objects. These can all be categorized as constructor.
.IP "Mail::Field\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field->combine(FIELDS)"
Take a \s-1LIST\s0 of \f(CW\*(C`Mail::Field\*(C'\fR objects (which should all be of the same
sub-class) and create a new object in that same class.
.IP "Mail::Field\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field->extract(TAG, HEAD [, INDEX ])"
Takes as arguments the tag name, a \f(CW\*(C`Mail::Head\*(C'\fR object
and optionally an index.
.Sp
If the index argument is given then \f(CW\*(C`extract\*(C'\fR will retrieve the given tag
from the \f(CW\*(C`Mail::Head\*(C'\fR object and create a new \f(CW\*(C`Mail::Field\*(C'\fR based object.
\&\fIundef\fR will be returned in the field does not exist.
.Sp
If the index argument is not given the result depends on the context
in which \f(CW\*(C`extract\*(C'\fR is called. If called in a scalar context the result
will be as if \f(CW\*(C`extract\*(C'\fR was called with an index value of zero. If called
in an array context then all tags will be retrieved and a list of
\&\f(CW\*(C`Mail::Field\*(C'\fR objects will be returned.
.IP "Mail::Field\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field->new(TAG [, STRING | OPTIONS])"
Create an object in the class which defines the field specified by
the \s-1TAG\s0 argument.
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
This constructor is used internally with preprocessed field information.
When called on an existing object, its original content will get
replaced.
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
Parse a field line.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
Change the settings (the content, but then smart) of this field.
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
Returns the field as a string.
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field\->\fBtag\fR()" 4
.IX Item "Mail::Field->tag()"
.PD
Return the tag (in the correct case) for this item.  Well, actually any
casing is \s-1OK,\s0 because the field tags are treated case-insensitive; however
people have some preferences.
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
Without arguments, the field is returned as \fIstringify()\fR does.  Otherwise,
the \s-1STRING\s0 is parsed with \fIparse()\fR to replace the object's content.
.Sp
It is more clear to call either \fIstringify()\fR or \fIparse()\fR directly, because
this method does not add additional processing.
.SH "DETAILS"
.IX Header "DETAILS"
.SS "SUB-CLASS \s-1PACKAGE NAMES\s0"
.IX Subsection "SUB-CLASS PACKAGE NAMES"
All sub-classes should be called Mail::Field::\fIname\fR where \fIname\fR is
derived from the tag using these rules.
.IP "\(bu" 4
Consider a tag as being made up of elements separated by '\-'
.IP "\(bu" 4
Convert all characters to lowercase except the first in each element, which
should be uppercase.
.IP "\(bu" 4
\&\fIname\fR is then created from these elements by using the first
N characters from each element.
.IP "\(bu" 4
N is calculated by using the formula :\-
.Sp
.Vb 1
\&    int((7 + #elements) / #elements)
.Ve
.IP "\(bu" 4
\&\fIname\fR is then limited to a maximum of 8 characters, keeping the first 8
characters.
.PP
For an example of this take a look at the definition of the 
\&\f(CW\*(C`_header_pkg_name()\*(C'\fR subroutine in \f(CW\*(C`Mail::Field\*(C'\fR
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field5.16.3pm                          0100644 0001750 0001750 00000023600 12566241445 023627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field 3"
.TH Mail::Field 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field \- Base class for manipulation of mail header fields
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\& Mail::Field is extended by
\&   Mail::Field::AddrList
\&   Mail::Field::Date
\&   Mail::Field::Generic
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Field;
\&    
\& my $field = Mail::Field\->new(\*(AqSubject\*(Aq, \*(Aqsome subject text\*(Aq);
\& my $field = Mail::Field\->new(Subject => \*(Aqsome subject text\*(Aq);
\& print $field\->tag,": ",$field\->stringify,"\en";
\&
\& my $field = Mail::Field\->subject(\*(Aqsome subject text\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Field\*(C'\fR creates and manipulates fields in \s-1MIME\s0 headers, collected
within a Mail::Header object.  Different field types have their
own sub-class (extension), defining additional useful accessors to the
field content.
.PP
People are invited to merge their implementation to special fields into
MailTools, to maintain a consistent set of packages and documentation.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
Mail::Field (and it's sub-classes) define several methods which return
new objects. These can all be categorized as constructor.
.IP "Mail::Field\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field->combine(FIELDS)"
Take a \s-1LIST\s0 of \f(CW\*(C`Mail::Field\*(C'\fR objects (which should all be of the same
sub-class) and create a new object in that same class.
.IP "Mail::Field\->\fBextract\fR(\s-1TAG\s0, \s-1HEAD\s0 [, \s-1INDEX\s0 ])" 4
.IX Item "Mail::Field->extract(TAG, HEAD [, INDEX ])"
Takes as arguments the tag name, a \f(CW\*(C`Mail::Head\*(C'\fR object
and optionally an index.
.Sp
If the index argument is given then \f(CW\*(C`extract\*(C'\fR will retrieve the given tag
from the \f(CW\*(C`Mail::Head\*(C'\fR object and create a new \f(CW\*(C`Mail::Field\*(C'\fR based object.
\&\fIundef\fR will be returned in the field does not exist.
.Sp
If the index argument is not given the the result depends on the context
in which \f(CW\*(C`extract\*(C'\fR is called. If called in a scalar context the result
will be as if \f(CW\*(C`extract\*(C'\fR was called with an index value of zero. If called
in an array context then all tags will be retrieved and a list of
\&\f(CW\*(C`Mail::Field\*(C'\fR objects will be returned.
.IP "Mail::Field\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field->new(TAG [, STRING | OPTIONS])"
Create an object in the class which defines the field specified by
the \s-1TAG\s0 argument.
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
This constructor is used internally with preprocessed field information.
When called on an existing object, its original content will get
replaced.
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
Parse a field line.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
Change the settings (the content, but then smart) of this field.
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
Returns the field as a string.
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field\->\fBtag\fR()" 4
.IX Item "Mail::Field->tag()"
.PD
Return the tag (in the correct case) for this item.  Well, actually any
casing is \s-1OK\s0, because the field tags are treated case-insentitive; however
people have some preferences.
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
Without arguments, the field is returned as \fIstringify()\fR does.  Otherwise,
the \s-1STRING\s0 is parsed with \fIparse()\fR to replace the object's content.
.Sp
It is more clear to call either \fIstringify()\fR or \fIparse()\fR directly, because
this method does not add additional processing.
.SH "DETAILS"
.IX Header "DETAILS"
.SS "SUB-CLASS \s-1PACKAGE\s0 \s-1NAMES\s0"
.IX Subsection "SUB-CLASS PACKAGE NAMES"
All sub-classes should be called Mail::Field::\fIname\fR where \fIname\fR is
derived from the tag using these rules.
.IP "\(bu" 4
Consider a tag as being made up of elements separated by '\-'
.IP "\(bu" 4
Convert all characters to lowercase except the first in each element, which
should be uppercase.
.IP "\(bu" 4
\&\fIname\fR is then created from these elements by using the first
N characters from each element.
.IP "\(bu" 4
N is calculated by using the formula :\-
.Sp
.Vb 1
\&    int((7 + #elements) / #elements)
.Ve
.IP "\(bu" 4
\&\fIname\fR is then limited to a maximum of 8 characters, keeping the first 8
characters.
.PP
For an example of this take a look at the definition of the 
\&\f(CW\*(C`_header_pkg_name()\*(C'\fR subroutine in \f(CW\*(C`Mail::Field\*(C'\fR
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the mehod called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field5.18.3pm                          0100644 0001750 0001750 00000024100 12566241445 023625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field 3"
.TH Mail::Field 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field \- Base class for manipulation of mail header fields
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\& Mail::Field is extended by
\&   Mail::Field::AddrList
\&   Mail::Field::Date
\&   Mail::Field::Generic
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Field;
\&    
\& my $field = Mail::Field\->new(\*(AqSubject\*(Aq, \*(Aqsome subject text\*(Aq);
\& my $field = Mail::Field\->new(Subject => \*(Aqsome subject text\*(Aq);
\& print $field\->tag,": ",$field\->stringify,"\en";
\&
\& my $field = Mail::Field\->subject(\*(Aqsome subject text\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Field\*(C'\fR creates and manipulates fields in \s-1MIME\s0 headers, collected
within a Mail::Header object.  Different field types have their
own sub-class (extension), defining additional useful accessors to the
field content.
.PP
People are invited to merge their implementation to special fields into
MailTools, to maintain a consistent set of packages and documentation.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
Mail::Field (and it's sub-classes) define several methods which return
new objects. These can all be categorized as constructor.
.IP "Mail::Field\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field->combine(FIELDS)"
Take a \s-1LIST\s0 of \f(CW\*(C`Mail::Field\*(C'\fR objects (which should all be of the same
sub-class) and create a new object in that same class.
.IP "Mail::Field\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field->extract(TAG, HEAD [, INDEX ])"
Takes as arguments the tag name, a \f(CW\*(C`Mail::Head\*(C'\fR object
and optionally an index.
.Sp
If the index argument is given then \f(CW\*(C`extract\*(C'\fR will retrieve the given tag
from the \f(CW\*(C`Mail::Head\*(C'\fR object and create a new \f(CW\*(C`Mail::Field\*(C'\fR based object.
\&\fIundef\fR will be returned in the field does not exist.
.Sp
If the index argument is not given the result depends on the context
in which \f(CW\*(C`extract\*(C'\fR is called. If called in a scalar context the result
will be as if \f(CW\*(C`extract\*(C'\fR was called with an index value of zero. If called
in an array context then all tags will be retrieved and a list of
\&\f(CW\*(C`Mail::Field\*(C'\fR objects will be returned.
.IP "Mail::Field\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field->new(TAG [, STRING | OPTIONS])"
Create an object in the class which defines the field specified by
the \s-1TAG\s0 argument.
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
This constructor is used internally with preprocessed field information.
When called on an existing object, its original content will get
replaced.
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
Parse a field line.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
Change the settings (the content, but then smart) of this field.
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
Returns the field as a string.
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field\->\fBtag\fR()" 4
.IX Item "Mail::Field->tag()"
.PD
Return the tag (in the correct case) for this item.  Well, actually any
casing is \s-1OK,\s0 because the field tags are treated case-insensitive; however
people have some preferences.
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
Without arguments, the field is returned as \fIstringify()\fR does.  Otherwise,
the \s-1STRING\s0 is parsed with \fIparse()\fR to replace the object's content.
.Sp
It is more clear to call either \fIstringify()\fR or \fIparse()\fR directly, because
this method does not add additional processing.
.SH "DETAILS"
.IX Header "DETAILS"
.SS "SUB-CLASS \s-1PACKAGE NAMES\s0"
.IX Subsection "SUB-CLASS PACKAGE NAMES"
All sub-classes should be called Mail::Field::\fIname\fR where \fIname\fR is
derived from the tag using these rules.
.IP "\(bu" 4
Consider a tag as being made up of elements separated by '\-'
.IP "\(bu" 4
Convert all characters to lowercase except the first in each element, which
should be uppercase.
.IP "\(bu" 4
\&\fIname\fR is then created from these elements by using the first
N characters from each element.
.IP "\(bu" 4
N is calculated by using the formula :\-
.Sp
.Vb 1
\&    int((7 + #elements) / #elements)
.Ve
.IP "\(bu" 4
\&\fIname\fR is then limited to a maximum of 8 characters, keeping the first 8
characters.
.PP
For an example of this take a look at the definition of the 
\&\f(CW\*(C`_header_pkg_name()\*(C'\fR subroutine in \f(CW\*(C`Mail::Field\*(C'\fR
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::AddrList.3pm                    0100644 0001750 0001750 00000022516 12566241445 025135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::AddrList 3"
.TH Mail::Field::AddrList 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::AddrList \- object representation of e\-mail address lists
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::AddrList
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::Field::AddrList;
\&
\&  $to   = Mail::Field\->new(\*(AqTo\*(Aq);
\&  $from = Mail::Field\->new(\*(AqFrom\*(Aq, \*(Aqpoe@daimi.aau.dk (Peter Orbaek)\*(Aq);
\&  
\&  $from\->create(\*(Aqfoo@bar.com\*(Aq => \*(AqMr. Foo\*(Aq, poe => \*(AqPeter\*(Aq);
\&  $from\->parse(\*(Aqfoo@bar.com (Mr Foo), Peter Orbaek <poe>\*(Aq);
\&
\&  # make a RFC822 header string
\&  print $from\->stringify(),"\en";
\&
\&  # extract e\-mail addresses and names
\&  @addresses = $from\->addresses(); # strings
\&  @names     = $from\->names();     # strings
\&  @addr      = $from\->addr_list(); # Mail::Address objects (v2.00)
\&
\&  # adjoin a new address to the list
\&  $from\->set_address(\*(Aqfoo@bar.com\*(Aq, \*(AqMr. Foo\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Defines parsing and formatting of address field, for the following
fields: \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`From\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, \f(CW\*(C`Reply\-To\*(C'\fR, and \f(CW\*(C`Sender\*(C'\fR.
.PP
All the normally used features of the address field specification of
\&\s-1RFC2822\s0 are implemented, but some complex (and therefore hardly ever used)
constructs will not be understood.  Use Mail::Message::Field::Full
in MailBox if you need full \s-1RFC\s0 compliance.
.PP
See documentation in the base class.
.SH "METHODS"
.IX Header "METHODS"
See documentation in the base class.
.SS "Constructors"
.IX Subsection "Constructors"
See documentation in the base class.
.IP "Mail::Field::AddrList\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::AddrList->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::AddrList\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field::AddrList->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::AddrList\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::AddrList->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
See documentation in the base class.
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.SS "Accessors"
.IX Subsection "Accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::AddrList\->\fBtag\fR()" 4
.IX Item "Mail::Field::AddrList->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBaddr_list\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddr_list\fR()" 4
.IX Item "$obj->addr_list()"
Returns the collected Mail::Address objects.
.ie n .IP "$obj\->\fBaddresses\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddresses\fR()" 4
.IX Item "$obj->addresses()"
Returns a list if email addresses, found in the field content.
.ie n .IP "$obj\->\fBnames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnames\fR()" 4
.IX Item "$obj->names()"
Returns a list of nicely formatted named, for each of the addresses
found in the content.
.ie n .IP "$obj\->\fBset_address\fR(\s-1EMAIL, NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset_address\fR(\s-1EMAIL, NAME\s0)" 4
.IX Item "$obj->set_address(EMAIL, NAME)"
Add/replace an \s-1EMAIL\s0 address to the field.
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.SH "DETAILS"
.IX Header "DETAILS"
See documentation in the base class.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::AddrList5.16.3pm                0100644 0001750 0001750 00000021547 12566241445 025452  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::AddrList 3"
.TH Mail::Field::AddrList 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::AddrList \- object representation of e\-mail address lists
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::AddrList
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::Field::AddrList;
\&
\&  $to   = Mail::Field\->new(\*(AqTo\*(Aq);
\&  $from = Mail::Field\->new(\*(AqFrom\*(Aq, \*(Aqpoe@daimi.aau.dk (Peter Orbaek)\*(Aq);
\&  
\&  $from\->create(\*(Aqfoo@bar.com\*(Aq => \*(AqMr. Foo\*(Aq, poe => \*(AqPeter\*(Aq);
\&  $from\->parse(\*(Aqfoo@bar.com (Mr Foo), Peter Orbaek <poe>\*(Aq);
\&
\&  # make a RFC822 header string
\&  print $from\->stringify(),"\en";
\&
\&  # extract e\-mail addresses and names
\&  @addresses = $from\->addresses(); # strings
\&  @names     = $from\->names();     # strings
\&  @addr      = $from\->addr_list(); # Mail::Address objects (v2.00)
\&
\&  # adjoin a new address to the list
\&  $from\->set_address(\*(Aqfoo@bar.com\*(Aq, \*(AqMr. Foo\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Defines parsing and formatting of address field, for the following
fields: \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`From\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, \f(CW\*(C`Reply\-To\*(C'\fR, and \f(CW\*(C`Sender\*(C'\fR.
.PP
All the normally used features of the address field specification of
\&\s-1RFC2822\s0 are implemented, but some complex (and therefore hardly ever used)
constructs will not be inderstood.  Use Mail::Message::Field::Full
in MailBox if you need full \s-1RFC\s0 compliance.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Field::AddrList\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::AddrList->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::AddrList\->\fBextract\fR(\s-1TAG\s0, \s-1HEAD\s0 [, \s-1INDEX\s0 ])" 4
.IX Item "Mail::Field::AddrList->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::AddrList\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::AddrList->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::AddrList\->\fBtag\fR()" 4
.IX Item "Mail::Field::AddrList->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBaddr_list\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddr_list\fR()" 4
.IX Item "$obj->addr_list()"
Returns the collected Mail::Address objects.
.ie n .IP "$obj\->\fBaddresses\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddresses\fR()" 4
.IX Item "$obj->addresses()"
Returns a list if email addresses, found in the field content.
.ie n .IP "$obj\->\fBnames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnames\fR()" 4
.IX Item "$obj->names()"
Returns a list of nicely formatted named, for each of the addresses
found in the content.
.ie n .IP "$obj\->\fBset_address\fR(\s-1EMAIL\s0, \s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset_address\fR(\s-1EMAIL\s0, \s-1NAME\s0)" 4
.IX Item "$obj->set_address(EMAIL, NAME)"
Add/replace an \s-1EMAIL\s0 address to the field.
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the mehod called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::AddrList5.18.3pm                0100644 0001750 0001750 00000022516 12566241445 025451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::AddrList 3"
.TH Mail::Field::AddrList 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::AddrList \- object representation of e\-mail address lists
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::AddrList
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mail::Field::AddrList;
\&
\&  $to   = Mail::Field\->new(\*(AqTo\*(Aq);
\&  $from = Mail::Field\->new(\*(AqFrom\*(Aq, \*(Aqpoe@daimi.aau.dk (Peter Orbaek)\*(Aq);
\&  
\&  $from\->create(\*(Aqfoo@bar.com\*(Aq => \*(AqMr. Foo\*(Aq, poe => \*(AqPeter\*(Aq);
\&  $from\->parse(\*(Aqfoo@bar.com (Mr Foo), Peter Orbaek <poe>\*(Aq);
\&
\&  # make a RFC822 header string
\&  print $from\->stringify(),"\en";
\&
\&  # extract e\-mail addresses and names
\&  @addresses = $from\->addresses(); # strings
\&  @names     = $from\->names();     # strings
\&  @addr      = $from\->addr_list(); # Mail::Address objects (v2.00)
\&
\&  # adjoin a new address to the list
\&  $from\->set_address(\*(Aqfoo@bar.com\*(Aq, \*(AqMr. Foo\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Defines parsing and formatting of address field, for the following
fields: \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`From\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, \f(CW\*(C`Reply\-To\*(C'\fR, and \f(CW\*(C`Sender\*(C'\fR.
.PP
All the normally used features of the address field specification of
\&\s-1RFC2822\s0 are implemented, but some complex (and therefore hardly ever used)
constructs will not be understood.  Use Mail::Message::Field::Full
in MailBox if you need full \s-1RFC\s0 compliance.
.PP
See documentation in the base class.
.SH "METHODS"
.IX Header "METHODS"
See documentation in the base class.
.SS "Constructors"
.IX Subsection "Constructors"
See documentation in the base class.
.IP "Mail::Field::AddrList\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::AddrList->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::AddrList\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field::AddrList->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::AddrList\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::AddrList->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
See documentation in the base class.
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.SS "Accessors"
.IX Subsection "Accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::AddrList\->\fBtag\fR()" 4
.IX Item "Mail::Field::AddrList->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBaddr_list\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddr_list\fR()" 4
.IX Item "$obj->addr_list()"
Returns the collected Mail::Address objects.
.ie n .IP "$obj\->\fBaddresses\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddresses\fR()" 4
.IX Item "$obj->addresses()"
Returns a list if email addresses, found in the field content.
.ie n .IP "$obj\->\fBnames\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnames\fR()" 4
.IX Item "$obj->names()"
Returns a list of nicely formatted named, for each of the addresses
found in the content.
.ie n .IP "$obj\->\fBset_address\fR(\s-1EMAIL, NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset_address\fR(\s-1EMAIL, NAME\s0)" 4
.IX Item "$obj->set_address(EMAIL, NAME)"
Add/replace an \s-1EMAIL\s0 address to the field.
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.SH "DETAILS"
.IX Header "DETAILS"
See documentation in the base class.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::Date.3pm                        0100644 0001750 0001750 00000017630 12566241445 024305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::Date 3"
.TH Mail::Field::Date 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::Date \- a date header field
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::Date
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Date \*(Aqtime2iso\*(Aq;
\&  my $field = Mail::Field\->new(Date => time2iso());
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents one \*(L"Date\*(R" header field.
.PP
See documentation in the base class.
.SH "METHODS"
.IX Header "METHODS"
See documentation in the base class.
.SS "Constructors"
.IX Subsection "Constructors"
See documentation in the base class.
.IP "Mail::Field::Date\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::Date->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Date\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field::Date->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Date\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::Date->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
See documentation in the base class.
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.SS "Accessors"
.IX Subsection "Accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
.Vb 3
\& \-Option \-\-Default
\&  Time     undef
\&  TimeStr  undef
.Ve
.RS 4
.IP "Time => \s-1SECONDS\s0" 2
.IX Item "Time => SECONDS"
.PD 0
.IP "TimeStr => \s-1STRING\s0" 2
.IX Item "TimeStr => STRING"
.PD
A string acceptable to Date::Parse.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::Date\->\fBtag\fR()" 4
.IX Item "Mail::Field::Date->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtime\fR([\s-1TIME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtime\fR([\s-1TIME\s0])" 4
.IX Item "$obj->time([TIME])"
Query (or change) the \s-1TIME \s0(as stored in the field) in seconds.
.SH "DETAILS"
.IX Header "DETAILS"
See documentation in the base class.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::Date5.16.3pm                    0100644 0001750 0001750 00000016643 12566241445 024622  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::Date 3"
.TH Mail::Field::Date 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::Date \- a date header field
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::Date
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Date \*(Aqtime2iso\*(Aq;
\&  my $field = Mail::Field\->new(Date => time2iso());
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents one \*(L"Date\*(R" header field.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Field::Date\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::Date->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Date\->\fBextract\fR(\s-1TAG\s0, \s-1HEAD\s0 [, \s-1INDEX\s0 ])" 4
.IX Item "Mail::Field::Date->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Date\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::Date->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
.Vb 3
\& \-Option \-\-Default
\&  Time     undef
\&  TimeStr  undef
.Ve
.RS 4
.IP "Time => \s-1SECONDS\s0" 2
.IX Item "Time => SECONDS"
.PD 0
.IP "TimeStr => \s-1STRING\s0" 2
.IX Item "TimeStr => STRING"
.PD
A string acceptable to Date::Parse.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::Date\->\fBtag\fR()" 4
.IX Item "Mail::Field::Date->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtime\fR([\s-1TIME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtime\fR([\s-1TIME\s0])" 4
.IX Item "$obj->time([TIME])"
Query (or change) the \s-1TIME\s0 (as stored in the field) in seconds.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the mehod called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::Date5.18.3pm                    0100644 0001750 0001750 00000017630 12566241445 024621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::Date 3"
.TH Mail::Field::Date 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::Date \- a date header field
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::Date
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Date \*(Aqtime2iso\*(Aq;
\&  my $field = Mail::Field\->new(Date => time2iso());
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents one \*(L"Date\*(R" header field.
.PP
See documentation in the base class.
.SH "METHODS"
.IX Header "METHODS"
See documentation in the base class.
.SS "Constructors"
.IX Subsection "Constructors"
See documentation in the base class.
.IP "Mail::Field::Date\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::Date->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Date\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field::Date->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Date\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::Date->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
See documentation in the base class.
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.ie n .IP "$obj\->\fBparse\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR()" 4
.IX Item "$obj->parse()"
See "\*(L"Fake\*(R" constructors" in Mail::Field
.SS "Accessors"
.IX Subsection "Accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
.Vb 3
\& \-Option \-\-Default
\&  Time     undef
\&  TimeStr  undef
.Ve
.RS 4
.IP "Time => \s-1SECONDS\s0" 2
.IX Item "Time => SECONDS"
.PD 0
.IP "TimeStr => \s-1STRING\s0" 2
.IX Item "TimeStr => STRING"
.PD
A string acceptable to Date::Parse.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::Date\->\fBtag\fR()" 4
.IX Item "Mail::Field::Date->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtime\fR([\s-1TIME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtime\fR([\s-1TIME\s0])" 4
.IX Item "$obj->time([TIME])"
Query (or change) the \s-1TIME \s0(as stored in the field) in seconds.
.SH "DETAILS"
.IX Header "DETAILS"
See documentation in the base class.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::Generic.3pm                     0100644 0001750 0001750 00000017717 12566241445 025012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::Generic 3"
.TH Mail::Field::Generic 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::Generic \- implementation for inspecific fields
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::Generic
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Mail::Field;
\& my $field = Mail::Field\->new(\*(AqSubject\*(Aq, \*(Aqsome subject text\*(Aq);
\& my $field = Mail::Field\->new(subject => \*(Aqsome subject text\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A generic implementation for header fields without own
implementation. This is fine for fields like \f(CW\*(C`Subject\*(C'\fR, \f(CW\*(C`X\-Mailer\*(C'\fR,
etc., where the field holds only a string of no particular
importance/format.
.PP
See documentation in the base class.
.SH "METHODS"
.IX Header "METHODS"
See documentation in the base class.
.SS "Constructors"
.IX Subsection "Constructors"
See documentation in the base class.
.IP "Mail::Field::Generic\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::Generic->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Generic\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field::Generic->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Generic\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::Generic->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
See documentation in the base class.
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
.Vb 2
\& \-Option\-\-Default
\&  Text    \*(Aq\*(Aq
.Ve
.RS 4
.IP "Text => \s-1STRING\s0" 2
.IX Item "Text => STRING"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBparse\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR([\s-1STRING\s0])" 4
.IX Item "$obj->parse([STRING])"
.PD
Set the new text, which is empty when no \s-1STRING\s0 is provided.
.SS "Accessors"
.IX Subsection "Accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::Generic\->\fBtag\fR()" 4
.IX Item "Mail::Field::Generic->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.SH "DETAILS"
.IX Header "DETAILS"
See documentation in the base class.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::Generic5.16.3pm                 0100644 0001750 0001750 00000016732 12566241445 025320  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::Generic 3"
.TH Mail::Field::Generic 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::Generic \- implementation for inspecific fields
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::Generic
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Mail::Field;
\& my $field = Mail::Field\->new(\*(AqSubject\*(Aq, \*(Aqsome subject text\*(Aq);
\& my $field = Mail::Field\->new(subject => \*(Aqsome subject text\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A generic implementation for header fields without own
implementation. This is fine for fields like \f(CW\*(C`Subject\*(C'\fR, \f(CW\*(C`X\-Mailer\*(C'\fR,
etc., where the field holds only a string of no particular
importance/format.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Field::Generic\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::Generic->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Generic\->\fBextract\fR(\s-1TAG\s0, \s-1HEAD\s0 [, \s-1INDEX\s0 ])" 4
.IX Item "Mail::Field::Generic->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Generic\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::Generic->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
.Vb 2
\& \-Option\-\-Default
\&  Text    \*(Aq\*(Aq
.Ve
.RS 4
.IP "Text => \s-1STRING\s0" 2
.IX Item "Text => STRING"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBparse\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR([\s-1STRING\s0])" 4
.IX Item "$obj->parse([STRING])"
.PD
Set the new text, which is empty when no \s-1STRING\s0 is provided.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::Generic\->\fBtag\fR()" 4
.IX Item "Mail::Field::Generic->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the mehod called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Field::Generic5.18.3pm                 0100644 0001750 0001750 00000017717 12566241445 025326  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Field::Generic 3"
.TH Mail::Field::Generic 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Field::Generic \- implementation for inspecific fields
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Field::Generic
\&   is a Mail::Field
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Mail::Field;
\& my $field = Mail::Field\->new(\*(AqSubject\*(Aq, \*(Aqsome subject text\*(Aq);
\& my $field = Mail::Field\->new(subject => \*(Aqsome subject text\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A generic implementation for header fields without own
implementation. This is fine for fields like \f(CW\*(C`Subject\*(C'\fR, \f(CW\*(C`X\-Mailer\*(C'\fR,
etc., where the field holds only a string of no particular
importance/format.
.PP
See documentation in the base class.
.SH "METHODS"
.IX Header "METHODS"
See documentation in the base class.
.SS "Constructors"
.IX Subsection "Constructors"
See documentation in the base class.
.IP "Mail::Field::Generic\->\fBcombine\fR(\s-1FIELDS\s0)" 4
.IX Item "Mail::Field::Generic->combine(FIELDS)"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Generic\->\fBextract\fR(\s-1TAG, HEAD\s0 [, \s-1INDEX \s0])" 4
.IX Item "Mail::Field::Generic->extract(TAG, HEAD [, INDEX ])"
See \*(L"Constructors\*(R" in Mail::Field
.IP "Mail::Field::Generic\->\fBnew\fR(\s-1TAG\s0 [, \s-1STRING\s0 | \s-1OPTIONS\s0])" 4
.IX Item "Mail::Field::Generic->new(TAG [, STRING | OPTIONS])"
See \*(L"Constructors\*(R" in Mail::Field
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
See documentation in the base class.
.ie n .IP "$obj\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcreate\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->create(OPTIONS)"
.Vb 2
\& \-Option\-\-Default
\&  Text    \*(Aq\*(Aq
.Ve
.RS 4
.IP "Text => \s-1STRING\s0" 2
.IX Item "Text => STRING"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBparse\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBparse\fR([\s-1STRING\s0])" 4
.IX Item "$obj->parse([STRING])"
.PD
Set the new text, which is empty when no \s-1STRING\s0 is provided.
.SS "Accessors"
.IX Subsection "Accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBset\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBset\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->set(OPTIONS)"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBstringify\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstringify\fR()" 4
.IX Item "$obj->stringify()"
See \*(L"Accessors\*(R" in Mail::Field
.ie n .IP "$obj\->\fBtag\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtag\fR()" 4
.IX Item "$obj->tag()"
.PD 0
.IP "Mail::Field::Generic\->\fBtag\fR()" 4
.IX Item "Mail::Field::Generic->tag()"
.PD
See \*(L"Accessors\*(R" in Mail::Field
.SS "Smart accessors"
.IX Subsection "Smart accessors"
See documentation in the base class.
.ie n .IP "$obj\->\fBtext\fR([\s-1STRING\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtext\fR([\s-1STRING\s0])" 4
.IX Item "$obj->text([STRING])"
See \*(L"Smart accessors\*(R" in Mail::Field
.SH "DETAILS"
.IX Header "DETAILS"
See documentation in the base class.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "Error: Undefined subroutine <method> called" 4
.IX Item "Error: Undefined subroutine <method> called"
Mail::Field objects use autoloading to compile new functionality.
Apparently, the method called is not implemented for the specific
class of the field object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Filter.3pm                             0100644 0001750 0001750 00000016721 12566241445 023525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Filter 3"
.TH Mail::Filter 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Filter \- Filter mail through multiple subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Filter;
\&    
\& my $filter = Mail::Filter\->new( \e&filter1, \e&filter2 );
\&    
\& my $mail   = Mail::Internet\->new( [<>] );
\& my $mail   = $filter\->filter($mail);
\&
\& my $folder = Mail::Folder\->new( .... );
\& my $filter\->filter($folder);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Filter\*(C'\fR provides an interface to filtering Email through multiple
subroutines.
.PP
\&\f(CW\*(C`Mail::Filter\*(C'\fR filters mail by calling each filter subroutine in turn. Each
filter subroutine is called with two arguments, the first is the filter
object and the second is the mail or folder object being filtered.
.PP
The result from each filter sub is passed to the next filter as the mail
object. If a filter subroutine returns undef, then \f(CW\*(C`Mail::Filter\*(C'\fR will abort
and return immediately.
.PP
The function returns the result from the last subroutine to operate on the 
mail object.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Filter\->\fBnew\fR([\s-1FILTER\s0 [, ... ]])" 4
.IX Item "Mail::Filter->new([FILTER [, ... ]])"
Create a new \f(CW\*(C`Mail::Filter\*(C'\fR object with the given filter subroutines. Each
filter may be either a code reference or the name of a method to call
on the <Mail::Filter> object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBadd\fR(\s-1FILTER\s0 [, \s-1FILTER ...\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FILTER\s0 [, \s-1FILTER ...\s0])" 4
.IX Item "$obj->add(FILTER [, FILTER ...])"
Add the given filters to the end of the filter list.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBfilter\fR(MAIL-OBJECT | MAIL-FOLDER)" 4
.el .IP "\f(CW$obj\fR\->\fBfilter\fR(MAIL-OBJECT | MAIL-FOLDER)" 4
.IX Item "$obj->filter(MAIL-OBJECT | MAIL-FOLDER)"
If the first argument is a \f(CW\*(C`Mail::Internet\*(C'\fR object, then this object will
be passed through the filter list. If the first argument is a \f(CW\*(C`Mail::Folder\*(C'\fR
object, then each message in turn will be passed through the filter list.
.ie n .IP "$obj\->\fBfolder\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfolder\fR()" 4
.IX Item "$obj->folder()"
While the \f(CW\*(C`filter\*(C'\fR method is called with a \f(CW\*(C`Mail::Folder\*(C'\fR object, these
filter subroutines can call this method to obtain the folder object that is
being processed.
.ie n .IP "$obj\->\fBmsgnum\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmsgnum\fR()" 4
.IX Item "$obj->msgnum()"
If the \f(CW\*(C`filter\*(C'\fR method is called with a \f(CW\*(C`Mail::Folder\*(C'\fR object, then the
filter subroutines may call this method to obtain the message number
of the message that is being processed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Filter5.16.3pm                         0100644 0001750 0001750 00000016400 12566241445 024031  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Filter 3"
.TH Mail::Filter 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Filter \- Filter mail through multiple subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Filter;
\&    
\& my $filter = Mail::Filter\->new( \e&filter1, \e&filter2 );
\&    
\& my $mail   = Mail::Internet\->new( [<>] );
\& my $mail   = $filter\->filter($mail);
\&
\& my $folder = Mail::Folder\->new( .... );
\& my $filter\->filter($folder);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Filter\*(C'\fR provides an interface to filtering Email through multiple
subroutines.
.PP
\&\f(CW\*(C`Mail::Filter\*(C'\fR filters mail by calling each filter subroutine in turn. Each
filter subroutine is called with two arguments, the first is the filter
object and the second is the mail or folder object being filtered.
.PP
The result from each filter sub is passed to the next filter as the mail
object. If a filter subroutine returns undef, then \f(CW\*(C`Mail::Filter\*(C'\fR will abort
and return immediately.
.PP
The function returns the result from the last subroutine to operate on the 
mail object.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Filter\->\fBnew\fR([\s-1FILTER\s0 [, ... ]])" 4
.IX Item "Mail::Filter->new([FILTER [, ... ]])"
Create a new \f(CW\*(C`Mail::Filter\*(C'\fR object with the given filter subroutines. Each
filter may be either a code reference or the name of a method to call
on the <Mail::Filter> object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBadd\fR(\s-1FILTER\s0 [, \s-1FILTER\s0 ...])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FILTER\s0 [, \s-1FILTER\s0 ...])" 4
.IX Item "$obj->add(FILTER [, FILTER ...])"
Add the given filters to the end of the fliter list.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBfilter\fR(MAIL-OBJECT | MAIL-FOLDER)" 4
.el .IP "\f(CW$obj\fR\->\fBfilter\fR(MAIL-OBJECT | MAIL-FOLDER)" 4
.IX Item "$obj->filter(MAIL-OBJECT | MAIL-FOLDER)"
If the first argument is a \f(CW\*(C`Mail::Internet\*(C'\fR object, then this object will
be passed through the filter list. If the first argument is a \f(CW\*(C`Mail::Folder\*(C'\fR
object, then each message in turn will be passed through the filter list.
.ie n .IP "$obj\->\fBfolder\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfolder\fR()" 4
.IX Item "$obj->folder()"
While the \f(CW\*(C`filter\*(C'\fR method is called with a \f(CW\*(C`Mail::Folder\*(C'\fR object, these
filter subroutines can call this method to obtain the folder object that is
being processed.
.ie n .IP "$obj\->\fBmsgnum\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmsgnum\fR()" 4
.IX Item "$obj->msgnum()"
If the \f(CW\*(C`filter\*(C'\fR method is called with a \f(CW\*(C`Mail::Folder\*(C'\fR object, then the
filter subroutines may call this method to obtain the message number
of the message that is being processed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Filter5.18.3pm                         0100644 0001750 0001750 00000016721 12566241445 024041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Filter 3"
.TH Mail::Filter 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Filter \- Filter mail through multiple subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Filter;
\&    
\& my $filter = Mail::Filter\->new( \e&filter1, \e&filter2 );
\&    
\& my $mail   = Mail::Internet\->new( [<>] );
\& my $mail   = $filter\->filter($mail);
\&
\& my $folder = Mail::Folder\->new( .... );
\& my $filter\->filter($folder);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Filter\*(C'\fR provides an interface to filtering Email through multiple
subroutines.
.PP
\&\f(CW\*(C`Mail::Filter\*(C'\fR filters mail by calling each filter subroutine in turn. Each
filter subroutine is called with two arguments, the first is the filter
object and the second is the mail or folder object being filtered.
.PP
The result from each filter sub is passed to the next filter as the mail
object. If a filter subroutine returns undef, then \f(CW\*(C`Mail::Filter\*(C'\fR will abort
and return immediately.
.PP
The function returns the result from the last subroutine to operate on the 
mail object.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Filter\->\fBnew\fR([\s-1FILTER\s0 [, ... ]])" 4
.IX Item "Mail::Filter->new([FILTER [, ... ]])"
Create a new \f(CW\*(C`Mail::Filter\*(C'\fR object with the given filter subroutines. Each
filter may be either a code reference or the name of a method to call
on the <Mail::Filter> object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBadd\fR(\s-1FILTER\s0 [, \s-1FILTER ...\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1FILTER\s0 [, \s-1FILTER ...\s0])" 4
.IX Item "$obj->add(FILTER [, FILTER ...])"
Add the given filters to the end of the filter list.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBfilter\fR(MAIL-OBJECT | MAIL-FOLDER)" 4
.el .IP "\f(CW$obj\fR\->\fBfilter\fR(MAIL-OBJECT | MAIL-FOLDER)" 4
.IX Item "$obj->filter(MAIL-OBJECT | MAIL-FOLDER)"
If the first argument is a \f(CW\*(C`Mail::Internet\*(C'\fR object, then this object will
be passed through the filter list. If the first argument is a \f(CW\*(C`Mail::Folder\*(C'\fR
object, then each message in turn will be passed through the filter list.
.ie n .IP "$obj\->\fBfolder\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfolder\fR()" 4
.IX Item "$obj->folder()"
While the \f(CW\*(C`filter\*(C'\fR method is called with a \f(CW\*(C`Mail::Folder\*(C'\fR object, these
filter subroutines can call this method to obtain the folder object that is
being processed.
.ie n .IP "$obj\->\fBmsgnum\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmsgnum\fR()" 4
.IX Item "$obj->msgnum()"
If the \f(CW\*(C`filter\*(C'\fR method is called with a \f(CW\*(C`Mail::Folder\*(C'\fR object, then the
filter subroutines may call this method to obtain the message number
of the message that is being processed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Header.3pm                             0100644 0001750 0001750 00000035556 12566241445 023477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Header 3"
.TH Mail::Header 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Header \- manipulate MIME headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Header;
\&    
\& my $head = Mail::Header\->new;
\& my $head = Mail::Header\->new( \e*STDIN );
\& my $head = Mail::Header\->new( [<>], Modify => 0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read, write, create, and manipulate \s-1MIME\s0 headers, the leading part
of each modern e\-mail message, but also used in other protocols
like \s-1HTTP. \s0 The fields are kept in Mail::Field objects.
.PP
Be aware that the header fields each have a name part, which shall
be treated case-insensitive, and a content part, which may be folded
over multiple lines.
.PP
Mail::Header does not always follow the RFCs strict enough, does not
help you with character encodings.  It does not use weak references
where it could (because those did not exist when the module was written)
which costs some performance and make the implementation a little more
complicated.  The Mail::Message::Head implementation is much newer
and therefore better.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Create a duplicate of the current object.
.ie n .IP "$obj\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "$obj->new([ARG], [OPTIONS])"
.PD 0
.IP "Mail::Header\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "Mail::Header->new([ARG], [OPTIONS])"
.PD
\&\s-1ARG\s0 may be either a file descriptor (reference to a \s-1GLOB\s0)
or a reference to an array. If given the new object will be
initialized with headers either from the array of read from 
the file descriptor.
.Sp
\&\s-1OPTIONS\s0 is a list of options given in the form of key-value
pairs, just like a hash table. Valid options are
.Sp
.Vb 4
\& \-Option    \-\-Default
\&  FoldLength  79
\&  MailFrom    \*(AqKEEP\*(Aq
\&  Modify      false
.Ve
.RS 4
.IP "FoldLength => \s-1INTEGER\s0" 2
.IX Item "FoldLength => INTEGER"
The default length of line to be used when folding header lines.
See \fIfold_length()\fR.
.IP "MailFrom => '\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0'" 2
.IX Item "MailFrom => 'IGNORE'|'COERCE'|'KEEP'|'ERROR'"
See method \fImail_from()\fR.
.IP "Modify => \s-1BOOLEAN\s0" 2
.IX Item "Modify => BOOLEAN"
If this value is \fItrue\fR then the headers will be re-formatted,
otherwise the format of the header lines will remain unchanged.
.RE
.RS 4
.RE
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
Be warned that the next constructors all require an already created
header object, of which the original content will be destroyed.
.ie n .IP "$obj\->\fBempty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBempty\fR()" 4
.IX Item "$obj->empty()"
Empty an existing \f(CW\*(C`Mail::Header\*(C'\fR object of all lines.
.ie n .IP "$obj\->\fBextract\fR(\s-1ARRAY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(\s-1ARRAY\s0)" 4
.IX Item "$obj->extract(ARRAY)"
Extract a header from the given array into an existing Mail::Header
object. \f(CW\*(C`extract\*(C'\fR \fBwill modify\fR this array.
Returns the object that the method was called on.
.ie n .IP "$obj\->\fBheader\fR([\s-1ARRAY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([\s-1ARRAY\s0])" 4
.IX Item "$obj->header([ARRAY])"
\&\f(CW\*(C`header\*(C'\fR does multiple operations. First it will extract a header from
the \s-1ARRAY,\s0 if given. It will then reformat the header (if reformatting
is permitted), and finally return a reference to an array which
contains the header in a printable form.
.ie n .IP "$obj\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.IX Item "$obj->header_hashref([HASH])"
As \fIheader()\fR, but it will eventually set headers from a hash
reference, and it will return the headers as a hash reference.
.Sp
example:
.Sp
.Vb 3
\& $fields\->{From} = \*(AqTobias Brox <tobix@cpan.org>\*(Aq;
\& $fields\->{To}   = [\*(Aqyou@somewhere\*(Aq, \*(Aqme@localhost\*(Aq];
\& $head\->header_hashref($fields);
.Ve
.ie n .IP "$obj\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->read(FILEHANDLE)"
Read a header from the given file descriptor into an existing Mail::Header
object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([TAG], [LENGTH])"
Set the default fold length for all tags or just one. With no arguments
the default fold length is returned. With two arguments it sets the fold
length for the given tag and returns the previous value. If only \f(CW\*(C`LENGTH\*(C'\fR
is given it sets the default fold length for the current object.
.Sp
In the two argument form \f(CW\*(C`fold_length\*(C'\fR may be called as a static method,
setting default fold lengths for tags that will be used by \fBall\fR
\&\f(CW\*(C`Mail::Header\*(C'\fR objects. See the \f(CW\*(C`fold\*(C'\fR method for
a description on how \f(CW\*(C`Mail::Header\*(C'\fR uses these values.
.ie n .IP "$obj\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.el .IP "\f(CW$obj\fR\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.IX Item "$obj->mail_from('IGNORE'|'COERCE'|'KEEP'|'ERROR')"
This specifies what to do when a \f(CW\`From \*(Aq\fR line is encountered.
Valid values are \f(CW\*(C`IGNORE\*(C'\fR \- ignore and discard the header,
\&\f(CW\*(C`ERROR\*(C'\fR \- invoke an error (call die), \f(CW\*(C`COERCE\*(C'\fR \- rename them as Mail-From
and \f(CW\*(C`KEEP\*(C'\fR \- keep them.
.ie n .IP "$obj\->\fBmodify\fR([\s-1VALUE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodify\fR([\s-1VALUE\s0])" 4
.IX Item "$obj->modify([VALUE])"
If \f(CW\*(C`VALUE\*(C'\fR is \fIfalse\fR then \f(CW\*(C`Mail::Header\*(C'\fR will not do any automatic
reformatting of the headers, other than to ensure that the line
starts with the tags given.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBadd\fR(\s-1TAG, LINE\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1TAG, LINE\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->add(TAG, LINE [, INDEX])"
Add a new line to the header. If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR the tag will be
extracted from the beginning of the given line. If \s-1INDEX\s0 is given,
the new line will be inserted into the header at the given point, otherwise
the new line will be appended to the end of the header.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns the header as a single string.
.ie n .IP "$obj\->\fBcleanup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcleanup\fR()" 4
.IX Item "$obj->cleanup()"
Remove any header line that, other than the tag, only contains whitespace
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG [, WITH])"
Combine all instances of \s-1TAG\s0 into one. The lines will be
joined together \s-1WITH,\s0 or a single space if not given. The new
item will be positioned in the header where the first instance was, all
other instances of \s-1TAG\s0 will be removed.
.ie n .IP "$obj\->\fBcount\fR(\s-1TAG\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR(\s-1TAG\s0)" 4
.IX Item "$obj->count(TAG)"
Returns the number of times the given atg appears in the header
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX \s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX \s0])" 4
.IX Item "$obj->delete(TAG [, INDEX ])"
Delete a tag from the header. If an \s-1INDEX\s0 id is given, then the Nth instance
of the tag will be removed. If no \s-1INDEX\s0 is given, then all instances
of tag will be removed.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
Fold the header. If \s-1LENGTH\s0 is not given, then \f(CW\*(C`Mail::Header\*(C'\fR uses the
following rules to determine what length to fold a line.
.ie n .IP "$obj\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->get(TAG [, INDEX])"
Get the text from a line. If an \s-1INDEX\s0 is given, then the text of the Nth
instance will be returned. If it is not given the return value depends on the
context in which \f(CW\*(C`get\*(C'\fR was called. In an array context a list of all the
text from all the instances of the \s-1TAG\s0 will be returned. In a scalar context
the text for the first instance will be returned.
.Sp
The lines are unfolded, but still terminated with a new-line (see \f(CW\*(C`chomp\*(C'\fR)
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print the header to the given file descriptor, or \f(CW\*(C`STDOUT\*(C'\fR if no
file descriptor is given.
.ie n .IP "$obj\->\fBreplace\fR(\s-1TAG, LINE\s0 [, \s-1INDEX \s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(\s-1TAG, LINE\s0 [, \s-1INDEX \s0])" 4
.IX Item "$obj->replace(TAG, LINE [, INDEX ])"
Replace a line in the header.  If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR the tag will be
extracted from the beginning of the given line. If \s-1INDEX\s0 is given
the new line will replace the Nth instance of that tag, otherwise the
first instance of the tag is replaced. If the tag does not appear in the
header then a new line will be appended to the header.
.ie n .IP "$obj\->\fBtags\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtags\fR()" 4
.IX Item "$obj->tags()"
Returns an array of all the tags that exist in the header. Each tag will
only appear in the list once. The order of the tags is not specified.
.ie n .IP "$obj\->\fBunfold\fR([\s-1TAG\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR([\s-1TAG\s0])" 4
.IX Item "$obj->unfold([TAG])"
Unfold all instances of the given tag so that they do not spread across
multiple lines. If \f(CW\*(C`TAG\*(C'\fR is not given then all lines are unfolded.
.Sp
The unfolding process is wrong but (for compatibility reasons) will
not be repaired: only one blank at the start of the line should be
removed, not all of them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Header5.16.3pm                         0100644 0001750 0001750 00000035300 12566241445 023774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Header 3"
.TH Mail::Header 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Header \- manipulate MIME headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Header;
\&    
\& my $head = Mail::Header\->new;
\& my $head = Mail::Header\->new( \e*STDIN );
\& my $head = Mail::Header\->new( [<>], Modify => 0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read, write, create, and manipulate \s-1MIME\s0 headers, the leading part
of each modern e\-mail message, but also used in other protocols
like \s-1HTTP\s0.  The fields are kept in Mail::Field objects.
.PP
Be aware that the header fields each have a name part, which shall
be treated case-insensitive, and a content part, which may be folded
over multiple lines.
.PP
Mail::Header does not always follow the RFCs strict enough, does not
help you with character encodings.  It does not use weak references
where it could (because those did not exist when the module was written)
which costs some performance and make the implementation a little more
complicated.  The Mail::Message::Head implementation is much newer
and therefore better.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Create a duplicate of the current object.
.ie n .IP "$obj\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "$obj->new([ARG], [OPTIONS])"
.PD 0
.IP "Mail::Header\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "Mail::Header->new([ARG], [OPTIONS])"
.PD
\&\s-1ARG\s0 may be either a file descriptor (reference to a \s-1GLOB\s0)
or a reference to an array. If given the new object will be
initialized with headers either from the array of read from 
the file descriptor.
.Sp
\&\s-1OPTIONS\s0 is a list of options given in the form of key-value
pairs, just like a hash table. Valid options are
.Sp
.Vb 4
\& \-Option    \-\-Default
\&  FoldLength  79
\&  MailFrom    \*(AqKEEP\*(Aq
\&  Modify      true
.Ve
.RS 4
.IP "FoldLength => \s-1INTEGER\s0" 2
.IX Item "FoldLength => INTEGER"
The default length of line to be used when folding header lines.
See \fIfold_length()\fR.
.IP "MailFrom => '\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0'" 2
.IX Item "MailFrom => 'IGNORE'|'COERCE'|'KEEP'|'ERROR'"
See method \fImail_from()\fR.
.IP "Modify => \s-1BOOLEAN\s0" 2
.IX Item "Modify => BOOLEAN"
If this value is \fItrue\fR then the headers will be re-formatted,
otherwise the format of the header lines will remain unchanged.
.RE
.RS 4
.RE
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
Be warned that the next constructors all require an already created
header object, of which the original content will be destroyed.
.ie n .IP "$obj\->\fBempty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBempty\fR()" 4
.IX Item "$obj->empty()"
Empty an existing \f(CW\*(C`Mail::Header\*(C'\fR object of all lines.
.ie n .IP "$obj\->\fBextract\fR(\s-1ARRAY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(\s-1ARRAY\s0)" 4
.IX Item "$obj->extract(ARRAY)"
Extract a header from the given array into an existing Mail::Header
object. \f(CW\*(C`extract\*(C'\fR \fBwill modify\fR this array.
Returns the object that the method was called on.
.ie n .IP "$obj\->\fBheader\fR([\s-1ARRAY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([\s-1ARRAY\s0])" 4
.IX Item "$obj->header([ARRAY])"
\&\f(CW\*(C`header\*(C'\fR does multiple operations. First it will extract a header from
the \s-1ARRAY\s0, if given. It will then reformat the header (if reformatting
is permitted), and finally return a reference to an array which
contains the header in a printable form.
.ie n .IP "$obj\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.IX Item "$obj->header_hashref([HASH])"
As \fIheader()\fR, but it will eventually set headers from a hash
reference, and it will return the headers as a hash reference.
.Sp
example:
.Sp
.Vb 3
\& $fields\->{From} = \*(AqTobias Brox <tobix@cpan.org>\*(Aq;
\& $fields\->{To}   = [\*(Aqyou@somewhere\*(Aq, \*(Aqme@localhost\*(Aq];
\& $head\->header_hashref($fields);
.Ve
.ie n .IP "$obj\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->read(FILEHANDLE)"
Read a header from the given file descriptor into an existing Mail::Header
object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([TAG], [LENGTH])"
Set the default fold length for all tags or just one. With no arguments
the default fold length is returned. With two arguments it sets the fold
length for the given tag and returns the previous value. If only \f(CW\*(C`LENGTH\*(C'\fR
is given it sets the default fold length for the current object.
.Sp
In the two argument form \f(CW\*(C`fold_length\*(C'\fR may be called as a static method,
setting default fold lengths for tags that will be used by \fBall\fR
\&\f(CW\*(C`Mail::Header\*(C'\fR objects. See the \f(CW\*(C`fold\*(C'\fR method for
a description on how \f(CW\*(C`Mail::Header\*(C'\fR uses these values.
.ie n .IP "$obj\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.el .IP "\f(CW$obj\fR\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.IX Item "$obj->mail_from('IGNORE'|'COERCE'|'KEEP'|'ERROR')"
This specifies what to do when a \f(CW\`From \*(Aq\fR line is encountered.
Valid values are \f(CW\*(C`IGNORE\*(C'\fR \- ignore and discard the header,
\&\f(CW\*(C`ERROR\*(C'\fR \- invoke an error (call die), \f(CW\*(C`COERCE\*(C'\fR \- rename them as Mail-From
and \f(CW\*(C`KEEP\*(C'\fR \- keep them.
.ie n .IP "$obj\->\fBmodify\fR([\s-1VALUE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodify\fR([\s-1VALUE\s0])" 4
.IX Item "$obj->modify([VALUE])"
If \f(CW\*(C`VALUE\*(C'\fR is \fIfalse\fR then \f(CW\*(C`Mail::Header\*(C'\fR will not do any automatic
reformatting of the headers, other than to ensure that the line
starts with the tags given.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBadd\fR(\s-1TAG\s0, \s-1LINE\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1TAG\s0, \s-1LINE\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->add(TAG, LINE [, INDEX])"
Add a new line to the header. If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR the the tag will be
extracted from the beginning of the given line. If \s-1INDEX\s0 is given,
the new line will be inserted into the header at the given point, otherwise
the new line will be appended to the end of the header.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns the header as a single string.
.ie n .IP "$obj\->\fBcleanup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcleanup\fR()" 4
.IX Item "$obj->cleanup()"
Remove any header line that, other than the tag, only contains whitespace
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG [, WITH])"
Combine all instances of \s-1TAG\s0 into one. The lines will be
joined together \s-1WITH\s0, or a single space if not given. The new
item will be positioned in the header where the first instance was, all
other instances of \s-1TAG\s0 will be removed.
.ie n .IP "$obj\->\fBcount\fR(\s-1TAG\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR(\s-1TAG\s0)" 4
.IX Item "$obj->count(TAG)"
Returns the number of times the given atg appears in the header
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX\s0 ])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX\s0 ])" 4
.IX Item "$obj->delete(TAG [, INDEX ])"
Delete a tag from the header. If an \s-1INDEX\s0 id is given, then the Nth instance
of the tag will be removed. If no \s-1INDEX\s0 is given, then all instances
of tag will be removed.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
Fold the header. If \s-1LENGTH\s0 is not given, then \f(CW\*(C`Mail::Header\*(C'\fR uses the
following rules to determine what length to fold a line.
.ie n .IP "$obj\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->get(TAG [, INDEX])"
Get the text from a line. If an \s-1INDEX\s0 is given, then the text of the Nth
instance will be returned. If it is not given the return value depends on the
context in which \f(CW\*(C`get\*(C'\fR was called. In an array context a list of all the
text from all the instances of the \s-1TAG\s0 will be returned. In a scalar context
the text for the first instance will be returned.
.Sp
The lines are unfolded, but still terminated with a new-line (see \f(CW\*(C`chomp\*(C'\fR)
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print the header to the given file descriptor, or \f(CW\*(C`STDOUT\*(C'\fR if no
file descriptor is given.
.ie n .IP "$obj\->\fBreplace\fR(\s-1TAG\s0, \s-1LINE\s0 [, \s-1INDEX\s0 ])" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(\s-1TAG\s0, \s-1LINE\s0 [, \s-1INDEX\s0 ])" 4
.IX Item "$obj->replace(TAG, LINE [, INDEX ])"
Replace a line in the header.  If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR the the tag will be
extracted from the beginning of the given line. If \s-1INDEX\s0 is given
the new line will replace the Nth instance of that tag, otherwise the
first instance of the tag is replaced. If the tag does not appear in the
header then a new line will be appended to the header.
.ie n .IP "$obj\->\fBtags\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtags\fR()" 4
.IX Item "$obj->tags()"
Returns an array of all the tags that exist in the header. Each tag will
only appear in the list once. The order of the tags is not specified.
.ie n .IP "$obj\->\fBunfold\fR([\s-1TAG\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR([\s-1TAG\s0])" 4
.IX Item "$obj->unfold([TAG])"
Unfold all instances of the given tag so that they do not spread across
multiple lines. If \f(CW\*(C`TAG\*(C'\fR is not given then all lines are unfolded.
.Sp
The unfolding process is wrong but (for compatibility reasons) will
not be repaired: only one blank at the start of the line should be
removed, not all of them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Header5.18.3pm                         0100644 0001750 0001750 00000035556 12566241445 024013  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Header 3"
.TH Mail::Header 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Header \- manipulate MIME headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Mail::Header;
\&    
\& my $head = Mail::Header\->new;
\& my $head = Mail::Header\->new( \e*STDIN );
\& my $head = Mail::Header\->new( [<>], Modify => 0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Read, write, create, and manipulate \s-1MIME\s0 headers, the leading part
of each modern e\-mail message, but also used in other protocols
like \s-1HTTP. \s0 The fields are kept in Mail::Field objects.
.PP
Be aware that the header fields each have a name part, which shall
be treated case-insensitive, and a content part, which may be folded
over multiple lines.
.PP
Mail::Header does not always follow the RFCs strict enough, does not
help you with character encodings.  It does not use weak references
where it could (because those did not exist when the module was written)
which costs some performance and make the implementation a little more
complicated.  The Mail::Message::Head implementation is much newer
and therefore better.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Create a duplicate of the current object.
.ie n .IP "$obj\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "$obj->new([ARG], [OPTIONS])"
.PD 0
.IP "Mail::Header\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "Mail::Header->new([ARG], [OPTIONS])"
.PD
\&\s-1ARG\s0 may be either a file descriptor (reference to a \s-1GLOB\s0)
or a reference to an array. If given the new object will be
initialized with headers either from the array of read from 
the file descriptor.
.Sp
\&\s-1OPTIONS\s0 is a list of options given in the form of key-value
pairs, just like a hash table. Valid options are
.Sp
.Vb 4
\& \-Option    \-\-Default
\&  FoldLength  79
\&  MailFrom    \*(AqKEEP\*(Aq
\&  Modify      false
.Ve
.RS 4
.IP "FoldLength => \s-1INTEGER\s0" 2
.IX Item "FoldLength => INTEGER"
The default length of line to be used when folding header lines.
See \fIfold_length()\fR.
.IP "MailFrom => '\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0'" 2
.IX Item "MailFrom => 'IGNORE'|'COERCE'|'KEEP'|'ERROR'"
See method \fImail_from()\fR.
.IP "Modify => \s-1BOOLEAN\s0" 2
.IX Item "Modify => BOOLEAN"
If this value is \fItrue\fR then the headers will be re-formatted,
otherwise the format of the header lines will remain unchanged.
.RE
.RS 4
.RE
.ie n .SS """Fake"" constructors"
.el .SS "``Fake'' constructors"
.IX Subsection "Fake constructors"
Be warned that the next constructors all require an already created
header object, of which the original content will be destroyed.
.ie n .IP "$obj\->\fBempty\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBempty\fR()" 4
.IX Item "$obj->empty()"
Empty an existing \f(CW\*(C`Mail::Header\*(C'\fR object of all lines.
.ie n .IP "$obj\->\fBextract\fR(\s-1ARRAY\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(\s-1ARRAY\s0)" 4
.IX Item "$obj->extract(ARRAY)"
Extract a header from the given array into an existing Mail::Header
object. \f(CW\*(C`extract\*(C'\fR \fBwill modify\fR this array.
Returns the object that the method was called on.
.ie n .IP "$obj\->\fBheader\fR([\s-1ARRAY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([\s-1ARRAY\s0])" 4
.IX Item "$obj->header([ARRAY])"
\&\f(CW\*(C`header\*(C'\fR does multiple operations. First it will extract a header from
the \s-1ARRAY,\s0 if given. It will then reformat the header (if reformatting
is permitted), and finally return a reference to an array which
contains the header in a printable form.
.ie n .IP "$obj\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBheader_hashref\fR([\s-1HASH\s0])" 4
.IX Item "$obj->header_hashref([HASH])"
As \fIheader()\fR, but it will eventually set headers from a hash
reference, and it will return the headers as a hash reference.
.Sp
example:
.Sp
.Vb 3
\& $fields\->{From} = \*(AqTobias Brox <tobix@cpan.org>\*(Aq;
\& $fields\->{To}   = [\*(Aqyou@somewhere\*(Aq, \*(Aqme@localhost\*(Aq];
\& $head\->header_hashref($fields);
.Ve
.ie n .IP "$obj\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->read(FILEHANDLE)"
Read a header from the given file descriptor into an existing Mail::Header
object.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([TAG], [LENGTH])"
Set the default fold length for all tags or just one. With no arguments
the default fold length is returned. With two arguments it sets the fold
length for the given tag and returns the previous value. If only \f(CW\*(C`LENGTH\*(C'\fR
is given it sets the default fold length for the current object.
.Sp
In the two argument form \f(CW\*(C`fold_length\*(C'\fR may be called as a static method,
setting default fold lengths for tags that will be used by \fBall\fR
\&\f(CW\*(C`Mail::Header\*(C'\fR objects. See the \f(CW\*(C`fold\*(C'\fR method for
a description on how \f(CW\*(C`Mail::Header\*(C'\fR uses these values.
.ie n .IP "$obj\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.el .IP "\f(CW$obj\fR\->\fBmail_from\fR('\s-1IGNORE\s0'|'\s-1COERCE\s0'|'\s-1KEEP\s0'|'\s-1ERROR\s0')" 4
.IX Item "$obj->mail_from('IGNORE'|'COERCE'|'KEEP'|'ERROR')"
This specifies what to do when a \f(CW\`From \*(Aq\fR line is encountered.
Valid values are \f(CW\*(C`IGNORE\*(C'\fR \- ignore and discard the header,
\&\f(CW\*(C`ERROR\*(C'\fR \- invoke an error (call die), \f(CW\*(C`COERCE\*(C'\fR \- rename them as Mail-From
and \f(CW\*(C`KEEP\*(C'\fR \- keep them.
.ie n .IP "$obj\->\fBmodify\fR([\s-1VALUE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBmodify\fR([\s-1VALUE\s0])" 4
.IX Item "$obj->modify([VALUE])"
If \f(CW\*(C`VALUE\*(C'\fR is \fIfalse\fR then \f(CW\*(C`Mail::Header\*(C'\fR will not do any automatic
reformatting of the headers, other than to ensure that the line
starts with the tags given.
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBadd\fR(\s-1TAG, LINE\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(\s-1TAG, LINE\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->add(TAG, LINE [, INDEX])"
Add a new line to the header. If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR the tag will be
extracted from the beginning of the given line. If \s-1INDEX\s0 is given,
the new line will be inserted into the header at the given point, otherwise
the new line will be appended to the end of the header.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns the header as a single string.
.ie n .IP "$obj\->\fBcleanup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcleanup\fR()" 4
.IX Item "$obj->cleanup()"
Remove any header line that, other than the tag, only contains whitespace
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG\s0 [, \s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG [, WITH])"
Combine all instances of \s-1TAG\s0 into one. The lines will be
joined together \s-1WITH,\s0 or a single space if not given. The new
item will be positioned in the header where the first instance was, all
other instances of \s-1TAG\s0 will be removed.
.ie n .IP "$obj\->\fBcount\fR(\s-1TAG\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR(\s-1TAG\s0)" 4
.IX Item "$obj->count(TAG)"
Returns the number of times the given atg appears in the header
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX \s0])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG\s0 [, \s-1INDEX \s0])" 4
.IX Item "$obj->delete(TAG [, INDEX ])"
Delete a tag from the header. If an \s-1INDEX\s0 id is given, then the Nth instance
of the tag will be removed. If no \s-1INDEX\s0 is given, then all instances
of tag will be removed.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
Fold the header. If \s-1LENGTH\s0 is not given, then \f(CW\*(C`Mail::Header\*(C'\fR uses the
following rules to determine what length to fold a line.
.ie n .IP "$obj\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1TAG\s0 [, \s-1INDEX\s0])" 4
.IX Item "$obj->get(TAG [, INDEX])"
Get the text from a line. If an \s-1INDEX\s0 is given, then the text of the Nth
instance will be returned. If it is not given the return value depends on the
context in which \f(CW\*(C`get\*(C'\fR was called. In an array context a list of all the
text from all the instances of the \s-1TAG\s0 will be returned. In a scalar context
the text for the first instance will be returned.
.Sp
The lines are unfolded, but still terminated with a new-line (see \f(CW\*(C`chomp\*(C'\fR)
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print the header to the given file descriptor, or \f(CW\*(C`STDOUT\*(C'\fR if no
file descriptor is given.
.ie n .IP "$obj\->\fBreplace\fR(\s-1TAG, LINE\s0 [, \s-1INDEX \s0])" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(\s-1TAG, LINE\s0 [, \s-1INDEX \s0])" 4
.IX Item "$obj->replace(TAG, LINE [, INDEX ])"
Replace a line in the header.  If \s-1TAG\s0 is \f(CW\*(C`undef\*(C'\fR the tag will be
extracted from the beginning of the given line. If \s-1INDEX\s0 is given
the new line will replace the Nth instance of that tag, otherwise the
first instance of the tag is replaced. If the tag does not appear in the
header then a new line will be appended to the header.
.ie n .IP "$obj\->\fBtags\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtags\fR()" 4
.IX Item "$obj->tags()"
Returns an array of all the tags that exist in the header. Each tag will
only appear in the list once. The order of the tags is not specified.
.ie n .IP "$obj\->\fBunfold\fR([\s-1TAG\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR([\s-1TAG\s0])" 4
.IX Item "$obj->unfold([TAG])"
Unfold all instances of the given tag so that they do not spread across
multiple lines. If \f(CW\*(C`TAG\*(C'\fR is not given then all lines are unfolded.
.Sp
The unfolding process is wrong but (for compatibility reasons) will
not be repaired: only one blank at the start of the line should be
removed, not all of them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Internet.3pm                           0100644 0001750 0001750 00000044753 12566241445 024076  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Internet 3"
.TH Mail::Internet 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Internet \- manipulate email messages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::Internet;
\&  my $msg = Mail::Internet\->new(\e*STDIN);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package implements reading, creating, manipulating, and writing email
messages.  Sometimes, the implementation tries to be too smart, but in
the general case it works as expected.
.PP
If you start writing a \fBnew application\fR, you should use the Mail::Box
distribution, which has more features and handles messages much better
according to the RFCs.  See <http://perl.overmeer.net/mailbox/>.
You may also chose MIME::Entity, to get at least some multipart
support in your application.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Duplicate the message as a whole.  Both header and body will be
deep-copied: a new Mail::Internet object is returned.
.ie n .IP "$obj\->\fBextract\fR(ARRAY-of-LINES)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(ARRAY-of-LINES)" 4
.IX Item "$obj->extract(ARRAY-of-LINES)"
Extract header and body from an \s-1ARRAY\s0 of message lines.  Requires an
object already created with \fInew()\fR, which contents will get overwritten.
.ie n .IP "$obj\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "$obj->new([ARG], [OPTIONS])"
.PD 0
.IP "Mail::Internet\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "Mail::Internet->new([ARG], [OPTIONS])"
.PD
\&\s-1ARG\s0 is optional and may be either a file descriptor (reference to a \s-1GLOB\s0)
or a reference to an array. If given the new object will be
initialized with headers and body either from the array of read from 
the file descriptor.
.Sp
The \fIMail::Header::new()\fR \s-1OPTIONS \s0\f(CW\*(C`Modify\*(C'\fR, \f(CW\*(C`MailFrom\*(C'\fR and \f(CW\*(C`FoldLength\*(C'\fR
may also be given.
.Sp
.Vb 3
\& \-Option\-\-Default
\&  Body    []
\&  Header  undef
.Ve
.RS 4
.IP "Body => ARRAY-of-LINES" 2
.IX Item "Body => ARRAY-of-LINES"
The value of this option should be a reference to an array which contains
the lines for the body of the message. Each line should be terminated with
\&\f(CW\*(C`\en\*(C'\fR (\s-1LF\s0). If Body is given then \f(CW\*(C`Mail::Internet\*(C'\fR will not attempt to
read the body from \f(CW\*(C`ARG\*(C'\fR (even if it is specified).
.IP "Header => Mail::Header" 2
.IX Item "Header => Mail::Header"
The value of this option should be a Mail::Header object. If given then
\&\f(CW\*(C`Mail::Internet\*(C'\fR will not attempt to read a mail header from \f(CW\*(C`ARG\*(C'\fR, if
it was specified.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->read(FILEHANDLE)"
Read a message from the \s-1FILEHANDLE\s0 into an already existing message
object.  Better use \fInew()\fR with the \s-1FILEHANDLE\s0 as first argument.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBbody\fR([\s-1BODY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR([\s-1BODY\s0])" 4
.IX Item "$obj->body([BODY])"
Returns the body of the message. This is a reference to an array.
Each entry in the array represents a single line in the message.
.Sp
If \fI\s-1BODY\s0\fR is given, it can be a reference to an array or an array, then
the body will be replaced. If a reference is passed, it is used directly
and not copied, so any subsequent changes to the array will change the
contents of the body.
.ie n .IP "$obj\->\fBhead\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhead\fR()" 4
.IX Item "$obj->head()"
Returns the \f(CW\*(C`Mail::Header\*(C'\fR object which holds the headers for the current
message
.SS "Processing the message as a whole"
.IX Subsection "Processing the message as a whole"
.ie n .IP "$obj\->\fBas_mbox_string\fR([\s-1ALREADY_ESCAPED\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBas_mbox_string\fR([\s-1ALREADY_ESCAPED\s0])" 4
.IX Item "$obj->as_mbox_string([ALREADY_ESCAPED])"
Returns the message as a string in mbox format.  \f(CW\*(C`ALREADY_ESCAPED\*(C'\fR, if
given and true, indicates that \fIescape_from()\fR has already been called on
this object.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns the message as a single string.
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print the header, body or whole message to file descriptor \fI\s-1FILEHANDLE\s0\fR.
\&\fI\f(CI$fd\fI\fR should be a reference to a \s-1GLOB.\s0 If \fI\s-1FILEHANDLE\s0\fR is not given the
output will be sent to \s-1STDOUT.\s0
.Sp
example:
.Sp
.Vb 1
\&    $mail\->print( \e*STDOUT );  # Print message to STDOUT
.Ve
.ie n .IP "$obj\->\fBprint_body\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint_body\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print_body([FILEHANDLE])"
Print only the body to the \s-1FILEHANDLE \s0(default \s-1STDOUT\s0).
.ie n .IP "$obj\->\fBprint_header\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint_header\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print_header([FILEHANDLE])"
Print only the header to the \s-1FILEHANDLE \s0(default \s-1STDOUT\s0).
.SS "Processing the header"
.IX Subsection "Processing the header"
Most of these methods are simply wrappers around methods provided
by Mail::Header.
.ie n .IP "$obj\->\fBadd\fR(PAIRS-of-FIELD)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(PAIRS-of-FIELD)" 4
.IX Item "$obj->add(PAIRS-of-FIELD)"
The \s-1PAIRS\s0 are field-name and field-content.  For each \s-1PAIR,
\&\s0\fIMail::Header::add()\fR is called.  All fields are added after
existing fields.  The last addition is returned.
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG,\s0 [\s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG,\s0 [\s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG, [WITH])"
See \fIMail::Header::combine()\fR.
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG,\s0 [TAGs])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG,\s0 [TAGs])" 4
.IX Item "$obj->delete(TAG, [TAGs])"
Delete all fields with the name \s-1TAG.  \s0\fIMail::Header::delete()\fR is doing the
work.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
See \fIMail::Header::fold()\fR.
.ie n .IP "$obj\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([TAG], [LENGTH])"
See \fIMail::Header::fold_length()\fR.
.ie n .IP "$obj\->\fBget\fR(\s-1TAG,\s0 [TAGs])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1TAG,\s0 [TAGs])" 4
.IX Item "$obj->get(TAG, [TAGs])"
In \s-1LIST\s0 context, all fields with the name \s-1TAG\s0 are returned.  In \s-1SCALAR\s0
context, only the first field which matches the earliest \s-1TAG\s0 is returned.
\&\fIMail::Header::get()\fR is called to collect the data.
.ie n .IP "$obj\->\fBheader\fR([ARRAY\-of\-LINES])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([ARRAY\-of\-LINES])" 4
.IX Item "$obj->header([ARRAY-of-LINES])"
See \fIMail::Header::header()\fR.
.ie n .IP "$obj\->\fBreplace\fR(PAIRS-of-FIELD)" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(PAIRS-of-FIELD)" 4
.IX Item "$obj->replace(PAIRS-of-FIELD)"
The \s-1PAIRS\s0 are field-name and field-content.  For each \s-1PAIR,
\&\s0\fIMail::Header::replace()\fR is called with \s-1INDEX 0.\s0 If a \s-1FIELD\s0 is already
in the header, it will be removed first.  Do not specified the same
field-name twice.
.SS "Processing the body"
.IX Subsection "Processing the body"
.ie n .IP "$obj\->\fBremove_sig\fR([\s-1NLINES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBremove_sig\fR([\s-1NLINES\s0])" 4
.IX Item "$obj->remove_sig([NLINES])"
Attempts to remove a users signature from the body of a message. It does this 
by looking for a line equal to \f(CW\*(Aq\-\- \*(Aq\fR within the last \f(CW\*(C`NLINES\*(C'\fR of the
message. If found then that line and all lines after it will be removed. If
\&\f(CW\*(C`NLINES\*(C'\fR is not given a default value of 10 will be used. This would be of
most use in auto-reply scripts.
.ie n .IP "$obj\->\fBsign\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsign\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->sign(OPTIONS)"
Add your signature to the body.  \fIremove_sig()\fR will strip existing
signatures first.
.Sp
.Vb 3
\& \-Option   \-\-Default
\&  File       undef
\&  Signature  []
.Ve
.RS 4
.IP "File => \s-1FILEHANDLE\s0" 2
.IX Item "File => FILEHANDLE"
Take from the \s-1FILEHANDLE\s0 all lines starting from the first \f(CW\*(C`\-\-\*(C'\fR.
.IP "Signature => STRING|ARRAY\-of\-LINES" 2
.IX Item "Signature => STRING|ARRAY-of-LINES"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBtidy_body\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtidy_body\fR()" 4
.IX Item "$obj->tidy_body()"
.PD
Removes all leading and trailing lines from the body that only contain
white spaces.
.SS "High-level functionality"
.IX Subsection "High-level functionality"
.ie n .IP "$obj\->\fBescape_from\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBescape_from\fR()" 4
.IX Item "$obj->escape_from()"
It can cause problems with some applications if a message contains a line
starting with \f(CW\`From \*(Aq\fR, in particular when attempting to split a folder.
This method inserts a leading \f(CW\*(C`\`\*(C'\fR'> on any line that matches the regular
expression \f(CW\*(C`/^\*(C'\fR*From/>
.ie n .IP "$obj\->\fBnntppost\fR([\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnntppost\fR([\s-1OPTIONS\s0])" 4
.IX Item "$obj->nntppost([OPTIONS])"
Post an article via \s-1NNTP. \s0 Requires Net::NNTP to be installed.
.Sp
.Vb 4
\& \-Option\-\-Default
\&  Debug   <false>
\&  Host    <required>
\&  Port    119
.Ve
.RS 4
.IP "Debug => \s-1BOOLEAN\s0" 2
.IX Item "Debug => BOOLEAN"
Debug value to pass to Net::NNTP, see Net::NNTP
.IP "Host => HOSTNAME|Net::NNTP object" 2
.IX Item "Host => HOSTNAME|Net::NNTP object"
Name of \s-1NNTP\s0 server to connect to, or a Net::NNTP object to use.
.IP "Port => \s-1INTEGER\s0" 2
.IX Item "Port => INTEGER"
Port number to connect to on remote host
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->reply(OPTIONS)"
Create a new object with header initialised for a reply to the current 
object. And the body will be a copy of the current message indented.
.Sp
The \f(CW\*(C`.mailhdr\*(C'\fR file in your home directory (if exists) will be read
first, to provide defaults.
.Sp
.Vb 5
\& \-Option  \-\-Default
\&  Exclude   []
\&  Indent    \*(Aq>\*(Aq
\&  Keep      []
\&  ReplyAll  false
.Ve
.RS 4
.IP "Exclude => ARRAY-of-FIELDS" 2
.IX Item "Exclude => ARRAY-of-FIELDS"
Remove the listed \s-1FIELDS\s0 from the produced message.
.IP "Indent => \s-1STRING\s0" 2
.IX Item "Indent => STRING"
Use as indentation string.  The string may contain \f(CW\*(C`%%\*(C'\fR to get a single \f(CW\*(C`%\*(C'\fR,
\&\f(CW%f\fR to get the first from name, \f(CW%F\fR is the first character of \f(CW%f\fR,
\&\f(CW%l\fR is the last name, \f(CW%L\fR its first character, \f(CW%n\fR the whole from
string, and \f(CW%I\fR the first character of each of the names in the from string.
.IP "Keep => ARRAY-of-FIELDS" 2
.IX Item "Keep => ARRAY-of-FIELDS"
Copy the listed \s-1FIELDS\s0 from the original message.
.IP "ReplyAll => \s-1BOOLEAN\s0" 2
.IX Item "ReplyAll => BOOLEAN"
Automatically include all To and Cc addresses of the original mail,
excluding those mentioned in the Bcc list.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBsend\fR([\s-1TYPE,\s0 [\s-1ARGS...\s0]])" 4
.el .IP "\f(CW$obj\fR\->\fBsend\fR([\s-1TYPE,\s0 [\s-1ARGS...\s0]])" 4
.IX Item "$obj->send([TYPE, [ARGS...]])"
Send a Mail::Internet message using Mail::Mailer.  \s-1TYPE\s0 and \s-1ARGS\s0 are
passed on to \fIMail::Mailer::new()\fR.
.ie n .IP "$obj\->\fBsmtpsend\fR([\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBsmtpsend\fR([\s-1OPTIONS\s0])" 4
.IX Item "$obj->smtpsend([OPTIONS])"
Send a Mail::Internet message using direct \s-1SMTP. \s0 to the given
\&\s-1ADDRESSES,\s0 each can be either a string or a reference to a list of email
addresses. If none of \f(CW\*(C`To\*(C'\fR, <Cc> or \f(CW\*(C`Bcc\*(C'\fR are given then the addresses
are extracted from the message being sent.
.Sp
The return value will be a list of email addresses that the message was sent
to. If the message was not sent the list will be empty.
.Sp
Requires Net::SMTP and Net::Domain to be installed.
.Sp
.Vb 9
\& \-Option  \-\-Default
\&  Bcc       undef
\&  Cc        undef
\&  Debug     <false>
\&  Hello     localhost.localdomain
\&  Host      $ENV{SMTPHOSTS}
\&  MailFrom  Mail::Util::mailaddress()
\&  Port      25
\&  To        undef
.Ve
.RS 4
.IP "Bcc => \s-1ADDRESSES\s0" 2
.IX Item "Bcc => ADDRESSES"
.PD 0
.IP "Cc => \s-1ADDRESSES\s0" 2
.IX Item "Cc => ADDRESSES"
.IP "Debug => \s-1BOOLEAN\s0" 2
.IX Item "Debug => BOOLEAN"
.PD
Debug value to pass to Net::SMPT, see <Net::SMTP>
.IP "Hello => \s-1STRING\s0" 2
.IX Item "Hello => STRING"
Send a \s-1HELO \s0(or \s-1EHLO\s0) command to the server with the given name.
.IP "Host => \s-1HOSTNAME\s0" 2
.IX Item "Host => HOSTNAME"
Name of the \s-1SMTP\s0 server to connect to, or a Net::SMTP object to use
.Sp
If \f(CW\*(C`Host\*(C'\fR is not given then the \s-1SMTP\s0 host is found by attempting
connections first to hosts specified in \f(CW$ENV{SMTPHOSTS}\fR, a colon
separated list, then \f(CW\*(C`mailhost\*(C'\fR and \f(CW\*(C`localhost\*(C'\fR.
.IP "MailFrom => \s-1ADDRESS\s0" 2
.IX Item "MailFrom => ADDRESS"
The e\-mail address which is used as sender.  By default,
\&\fIMail::Util::mailaddress()\fR provides the address of the sender.
.IP "Port => \s-1INTEGER\s0" 2
.IX Item "Port => INTEGER"
Port number to connect to on remote host
.IP "To => \s-1ADDRESSES\s0" 2
.IX Item "To => ADDRESSES"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBunescape_from\fR(())" 4
.el .IP "\f(CW$obj\fR\->\fBunescape_from\fR(())" 4
.IX Item "$obj->unescape_from(())"
.PD
Remove the escaping added by \fIescape_from()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Internet5.16.3pm                       0100644 0001750 0001750 00000044431 12566241445 024401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Internet 3"
.TH Mail::Internet 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Internet \- manipulate email messages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::Internet;
\&  my $msg = Mail::Internet\->new(\e*STDIN);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package implements reading, creating, manipulating, and writing email
messages.  Sometimes, the implementation tries to be too smart, but in
the general case it works as expected.
.PP
If you start writing a \fBnew application\fR, you should use the Mail::Box
distribution, which has more features and handles messages much better
according to the RFCs.  See <http://perl.overmeer.net/mailbox/>.
You may also chose MIME::Entity, to get at least some multipart
support in your application.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Duplicate the message as a whole.  Both header and body will be
deep-copied: a new Mail::Internet object is returned.
.ie n .IP "$obj\->\fBextract\fR(ARRAY-of-LINES)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(ARRAY-of-LINES)" 4
.IX Item "$obj->extract(ARRAY-of-LINES)"
Extract header and body from an \s-1ARRAY\s0 of message lines.  Requires an
object already created with \fInew()\fR, which contents will get overwritten.
.ie n .IP "$obj\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "$obj->new([ARG], [OPTIONS])"
.PD 0
.IP "Mail::Internet\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "Mail::Internet->new([ARG], [OPTIONS])"
.PD
\&\s-1ARG\s0 is optional and may be either a file descriptor (reference to a \s-1GLOB\s0)
or a reference to an array. If given the new object will be
initialized with headers and body either from the array of read from 
the file descriptor.
.Sp
The \fIMail::Header::new()\fR \s-1OPTIONS\s0 \f(CW\*(C`Modify\*(C'\fR, \f(CW\*(C`MailFrom\*(C'\fR and \f(CW\*(C`FoldLength\*(C'\fR
may also be given.
.Sp
.Vb 3
\& \-Option\-\-Default
\&  Body    []
\&  Header  undef
.Ve
.RS 4
.IP "Body => ARRAY-of-LINES" 2
.IX Item "Body => ARRAY-of-LINES"
The value of this option should be a reference to an array which contains
the lines for the body of the message. Each line should be terminated with
\&\f(CW\*(C`\en\*(C'\fR (\s-1LF\s0). If Body is given then \f(CW\*(C`Mail::Internet\*(C'\fR will not attempt to
read the body from \f(CW\*(C`ARG\*(C'\fR (even if it is specified).
.IP "Header => Mail::Header" 2
.IX Item "Header => Mail::Header"
The value of this option should be a Mail::Header object. If given then
\&\f(CW\*(C`Mail::Internet\*(C'\fR will not attempt to read a mail header from \f(CW\*(C`ARG\*(C'\fR, if
it was specified.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->read(FILEHANDLE)"
Read a message from the \s-1FILEHANDLE\s0 into an already existing message
object.  Better use \fInew()\fR with the \s-1FILEHANDLE\s0 as first argument.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBbody\fR([\s-1BODY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR([\s-1BODY\s0])" 4
.IX Item "$obj->body([BODY])"
Returns the body of the message. This is a reference to an array.
Each entry in the array represents a single line in the message.
.Sp
If \fI\s-1BODY\s0\fR is given, it can be a reference to an array or an array, then
the body will be replaced. If a reference is passed, it is used directly
and not copied, so any subsequent changes to the array will change the
contents of the body.
.ie n .IP "$obj\->\fBhead\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhead\fR()" 4
.IX Item "$obj->head()"
Returns the \f(CW\*(C`Mail::Header\*(C'\fR object which holds the headers for the current
message
.SS "Processing the message as a whole"
.IX Subsection "Processing the message as a whole"
.ie n .IP "$obj\->\fBas_mbox_string\fR([\s-1ALREADY_ESCAPED\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBas_mbox_string\fR([\s-1ALREADY_ESCAPED\s0])" 4
.IX Item "$obj->as_mbox_string([ALREADY_ESCAPED])"
Returns the message as a string in mbox format.  \f(CW\*(C`ALREADY_ESCAPED\*(C'\fR, if
given and true, indicates that \fIescape_from()\fR has already been called on
this object.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns the message as a single string.
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print the header, body or whole message to file descriptor \fI\s-1FILEHANDLE\s0\fR.
\&\fI\f(CI$fd\fI\fR should be a reference to a \s-1GLOB\s0. If \fI\s-1FILEHANDLE\s0\fR is not given the
output will be sent to \s-1STDOUT\s0.
.Sp
example:
.Sp
.Vb 1
\&    $mail\->print( \e*STDOUT );  # Print message to STDOUT
.Ve
.ie n .IP "$obj\->\fBprint_body\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint_body\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print_body([FILEHANDLE])"
Print only the body to the \s-1FILEHANDLE\s0 (default \s-1STDOUT\s0).
.ie n .IP "$obj\->\fBprint_header\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint_header\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print_header([FILEHANDLE])"
Print only the header to the \s-1FILEHANDLE\s0 (default \s-1STDOUT\s0).
.SS "Processing the header"
.IX Subsection "Processing the header"
Most of these methods are simply wrappers around methods provided
by Mail::Header.
.ie n .IP "$obj\->\fBadd\fR(PAIRS-of-FIELD)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(PAIRS-of-FIELD)" 4
.IX Item "$obj->add(PAIRS-of-FIELD)"
The \s-1PAIRS\s0 are field-name and field-content.  For each \s-1PAIR\s0,
\&\fIMail::Header::add()\fR is called.  All fields are added after
existing fields.  The last addition is returned.
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG\s0, [\s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG\s0, [\s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG, [WITH])"
See \fIMail::Header::combine()\fR.
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG\s0, [TAGs])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG\s0, [TAGs])" 4
.IX Item "$obj->delete(TAG, [TAGs])"
Delete all fields with the name \s-1TAG\s0.  \fIMail::Header::delete()\fR is doing the
work.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
See \fIMail::Header::fold()\fR.
.ie n .IP "$obj\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([TAG], [LENGTH])"
See \fIMail::Header::fold_length()\fR.
.ie n .IP "$obj\->\fBget\fR(\s-1TAG\s0, [TAGs])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1TAG\s0, [TAGs])" 4
.IX Item "$obj->get(TAG, [TAGs])"
In \s-1LIST\s0 context, all fields with the name \s-1TAG\s0 are returned.  In \s-1SCALAR\s0
context, only the first field which matches the earliest \s-1TAG\s0 is returned.
\&\fIMail::Header::get()\fR is called to collect the data.
.ie n .IP "$obj\->\fBheader\fR([ARRAY\-of\-LINES])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([ARRAY\-of\-LINES])" 4
.IX Item "$obj->header([ARRAY-of-LINES])"
See \fIMail::Header::header()\fR.
.ie n .IP "$obj\->\fBreplace\fR(PAIRS-of-FIELD)" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(PAIRS-of-FIELD)" 4
.IX Item "$obj->replace(PAIRS-of-FIELD)"
The \s-1PAIRS\s0 are field-name and field-content.  For each \s-1PAIR\s0,
\&\fIMail::Header::replace()\fR is called with \s-1INDEX\s0 0. If a \s-1FIELD\s0 is already
in the header, it will be removed first.  Do not specified the same
field-name twice.
.SS "Processing the body"
.IX Subsection "Processing the body"
.ie n .IP "$obj\->\fBremove_sig\fR([\s-1NLINES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBremove_sig\fR([\s-1NLINES\s0])" 4
.IX Item "$obj->remove_sig([NLINES])"
Attempts to remove a users signature from the body of a message. It does this 
by looking for a line equal to \f(CW\*(Aq\-\- \*(Aq\fR within the last \f(CW\*(C`NLINES\*(C'\fR of the
message. If found then that line and all lines after it will be removed. If
\&\f(CW\*(C`NLINES\*(C'\fR is not given a default value of 10 will be used. This would be of
most use in auto-reply scripts.
.ie n .IP "$obj\->\fBsign\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsign\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->sign(OPTIONS)"
Add your signature to the body.  \fIremove_sig()\fR will strip existing
signatures first.
.Sp
.Vb 3
\& \-Option   \-\-Default
\&  File       undef
\&  Signature  []
.Ve
.RS 4
.IP "File => \s-1FILEHANDLE\s0" 2
.IX Item "File => FILEHANDLE"
Take from the \s-1FILEHANDLE\s0 all lines starting from the first \f(CW\*(C`\-\-\*(C'\fR.
.IP "Signature => STRING|ARRAY\-of\-LINES" 2
.IX Item "Signature => STRING|ARRAY-of-LINES"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBtidy_body\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtidy_body\fR()" 4
.IX Item "$obj->tidy_body()"
.PD
Removes all leading and trailing lines from the body that only contain
white spaces.
.SS "High-level functionality"
.IX Subsection "High-level functionality"
.ie n .IP "$obj\->\fBescape_from\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBescape_from\fR()" 4
.IX Item "$obj->escape_from()"
It can cause problems with some applications if a message contains a line
starting with \f(CW\`From \*(Aq\fR, in particular when attempting to split a folder.
This method inserts a leading \f(CW\*(C`\`\*(C'\fR'> on anyline that matches the regular
expression \f(CW\*(C`/^\*(C'\fR*From/>
.ie n .IP "$obj\->\fBnntppost\fR([\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnntppost\fR([\s-1OPTIONS\s0])" 4
.IX Item "$obj->nntppost([OPTIONS])"
Post an article via \s-1NNTP\s0.  Requires Net::NNTP to be installed.
.Sp
.Vb 4
\& \-Option\-\-Default
\&  Debug   <false>
\&  Host    <required>
\&  Port    119
.Ve
.RS 4
.IP "Debug => \s-1BOOLEAN\s0" 2
.IX Item "Debug => BOOLEAN"
Debug value to pass to Net::NNTP, see Net::NNTP
.IP "Host => HOSTNAME|Net::NNTP object" 2
.IX Item "Host => HOSTNAME|Net::NNTP object"
Name of \s-1NNTP\s0 server to connect to, or a Net::NNTP object to use.
.IP "Port => \s-1INTEGER\s0" 2
.IX Item "Port => INTEGER"
Port number to connect to on remote host
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->reply(OPTIONS)"
Create a new object with header initialised for a reply to the current 
object. And the body will be a copy of the current message indented.
.Sp
The \f(CW\*(C`.mailhdr\*(C'\fR file in your home directory (if exists) will be read
first, to provide defaults.
.Sp
.Vb 5
\& \-Option  \-\-Default
\&  Exclude   []
\&  Indent    \*(Aq>\*(Aq
\&  Keep      []
\&  ReplyAll  false
.Ve
.RS 4
.IP "Exclude => ARRAY-of-FIELDS" 2
.IX Item "Exclude => ARRAY-of-FIELDS"
Remove the listed \s-1FIELDS\s0 from the produced message.
.IP "Indent => \s-1STRING\s0" 2
.IX Item "Indent => STRING"
Use as indentation string.  The string may contain \f(CW\*(C`%%\*(C'\fR to get a single \f(CW\*(C`%\*(C'\fR,
\&\f(CW%f\fR to get the first from name, \f(CW%F\fR is the first character of \f(CW%f\fR,
\&\f(CW%l\fR is the last name, \f(CW%L\fR its first character, \f(CW%n\fR the whole from
string, and \f(CW%I\fR the first character of each of the names in the from string.
.IP "Keep => ARRAY-of-FIELDS" 2
.IX Item "Keep => ARRAY-of-FIELDS"
Copy the listed \s-1FIELDS\s0 from the original message.
.IP "ReplyAll => \s-1BOOLEAN\s0" 2
.IX Item "ReplyAll => BOOLEAN"
Automatically include all To and Cc addresses of the original mail,
excluding those mentioned in the Bcc list.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBsend\fR([\s-1TYPE\s0, [\s-1ARGS\s0...]])" 4
.el .IP "\f(CW$obj\fR\->\fBsend\fR([\s-1TYPE\s0, [\s-1ARGS\s0...]])" 4
.IX Item "$obj->send([TYPE, [ARGS...]])"
Send a Mail::Internet message using Mail::Mailer.  \s-1TYPE\s0 and \s-1ARGS\s0 are
passed on to \fIMail::Mailer::new()\fR.
.ie n .IP "$obj\->\fBsmtpsend\fR([\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBsmtpsend\fR([\s-1OPTIONS\s0])" 4
.IX Item "$obj->smtpsend([OPTIONS])"
Send a Mail::Internet message using direct \s-1SMTP\s0.  to the given
\&\s-1ADDRESSES\s0, each can be either a string or a reference to a list of email
addresses. If none of \f(CW\*(C`To\*(C'\fR, <Cc> or \f(CW\*(C`Bcc\*(C'\fR are given then the addresses
are extracted from the message being sent.
.Sp
The return value will be a list of email addresses that the message was sent
to. If the message was not sent the list will be empty.
.Sp
Requires Net::SMTP and Net::Domain to be installed.
.Sp
.Vb 9
\& \-Option  \-\-Default
\&  Bcc       undef
\&  Cc        undef
\&  Debug     <false>
\&  Hello     localhost.localdomain
\&  Host      $ENV{SMTPHOSTS}
\&  MailFrom  Mail::Util::mailaddress()
\&  Port      25
\&  To        undef
.Ve
.RS 4
.IP "Bcc => \s-1ADDRESSES\s0" 2
.IX Item "Bcc => ADDRESSES"
.PD 0
.IP "Cc => \s-1ADDRESSES\s0" 2
.IX Item "Cc => ADDRESSES"
.IP "Debug => \s-1BOOLEAN\s0" 2
.IX Item "Debug => BOOLEAN"
.PD
Debug value to pass to Net::SMPT, see <Net::SMTP>
.IP "Hello => \s-1STRING\s0" 2
.IX Item "Hello => STRING"
Send a \s-1HELO\s0 (or \s-1EHLO\s0) command to the server with the given name.
.IP "Host => \s-1HOSTNAME\s0" 2
.IX Item "Host => HOSTNAME"
Name of the \s-1SMTP\s0 server to connect to, or a Net::SMTP object to use
.Sp
If \f(CW\*(C`Host\*(C'\fR is not given then the \s-1SMTP\s0 host is found by attempting
connections first to hosts specified in \f(CW$ENV{SMTPHOSTS}\fR, a colon
separated list, then \f(CW\*(C`mailhost\*(C'\fR and \f(CW\*(C`localhost\*(C'\fR.
.IP "MailFrom => \s-1ADDRESS\s0" 2
.IX Item "MailFrom => ADDRESS"
The e\-mail address which is used as sender.  By default,
\&\fIMail::Util::mailaddress()\fR provides the address of the sender.
.IP "Port => \s-1INTEGER\s0" 2
.IX Item "Port => INTEGER"
Port number to connect to on remote host
.IP "To => \s-1ADDRESSES\s0" 2
.IX Item "To => ADDRESSES"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBunescape_from\fR(())" 4
.el .IP "\f(CW$obj\fR\->\fBunescape_from\fR(())" 4
.IX Item "$obj->unescape_from(())"
.PD
Remove the escaping added by \fIescape_from()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Internet5.18.3pm                       0100644 0001750 0001750 00000044753 12566241445 024412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Internet 3"
.TH Mail::Internet 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Internet \- manipulate email messages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::Internet;
\&  my $msg = Mail::Internet\->new(\e*STDIN);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package implements reading, creating, manipulating, and writing email
messages.  Sometimes, the implementation tries to be too smart, but in
the general case it works as expected.
.PP
If you start writing a \fBnew application\fR, you should use the Mail::Box
distribution, which has more features and handles messages much better
according to the RFCs.  See <http://perl.overmeer.net/mailbox/>.
You may also chose MIME::Entity, to get at least some multipart
support in your application.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdup\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdup\fR()" 4
.IX Item "$obj->dup()"
Duplicate the message as a whole.  Both header and body will be
deep-copied: a new Mail::Internet object is returned.
.ie n .IP "$obj\->\fBextract\fR(ARRAY-of-LINES)" 4
.el .IP "\f(CW$obj\fR\->\fBextract\fR(ARRAY-of-LINES)" 4
.IX Item "$obj->extract(ARRAY-of-LINES)"
Extract header and body from an \s-1ARRAY\s0 of message lines.  Requires an
object already created with \fInew()\fR, which contents will get overwritten.
.ie n .IP "$obj\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "$obj->new([ARG], [OPTIONS])"
.PD 0
.IP "Mail::Internet\->\fBnew\fR([\s-1ARG\s0], [\s-1OPTIONS\s0])" 4
.IX Item "Mail::Internet->new([ARG], [OPTIONS])"
.PD
\&\s-1ARG\s0 is optional and may be either a file descriptor (reference to a \s-1GLOB\s0)
or a reference to an array. If given the new object will be
initialized with headers and body either from the array of read from 
the file descriptor.
.Sp
The \fIMail::Header::new()\fR \s-1OPTIONS \s0\f(CW\*(C`Modify\*(C'\fR, \f(CW\*(C`MailFrom\*(C'\fR and \f(CW\*(C`FoldLength\*(C'\fR
may also be given.
.Sp
.Vb 3
\& \-Option\-\-Default
\&  Body    []
\&  Header  undef
.Ve
.RS 4
.IP "Body => ARRAY-of-LINES" 2
.IX Item "Body => ARRAY-of-LINES"
The value of this option should be a reference to an array which contains
the lines for the body of the message. Each line should be terminated with
\&\f(CW\*(C`\en\*(C'\fR (\s-1LF\s0). If Body is given then \f(CW\*(C`Mail::Internet\*(C'\fR will not attempt to
read the body from \f(CW\*(C`ARG\*(C'\fR (even if it is specified).
.IP "Header => Mail::Header" 2
.IX Item "Header => Mail::Header"
The value of this option should be a Mail::Header object. If given then
\&\f(CW\*(C`Mail::Internet\*(C'\fR will not attempt to read a mail header from \f(CW\*(C`ARG\*(C'\fR, if
it was specified.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBread\fR(\s-1FILEHANDLE\s0)" 4
.IX Item "$obj->read(FILEHANDLE)"
Read a message from the \s-1FILEHANDLE\s0 into an already existing message
object.  Better use \fInew()\fR with the \s-1FILEHANDLE\s0 as first argument.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBbody\fR([\s-1BODY\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR([\s-1BODY\s0])" 4
.IX Item "$obj->body([BODY])"
Returns the body of the message. This is a reference to an array.
Each entry in the array represents a single line in the message.
.Sp
If \fI\s-1BODY\s0\fR is given, it can be a reference to an array or an array, then
the body will be replaced. If a reference is passed, it is used directly
and not copied, so any subsequent changes to the array will change the
contents of the body.
.ie n .IP "$obj\->\fBhead\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBhead\fR()" 4
.IX Item "$obj->head()"
Returns the \f(CW\*(C`Mail::Header\*(C'\fR object which holds the headers for the current
message
.SS "Processing the message as a whole"
.IX Subsection "Processing the message as a whole"
.ie n .IP "$obj\->\fBas_mbox_string\fR([\s-1ALREADY_ESCAPED\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBas_mbox_string\fR([\s-1ALREADY_ESCAPED\s0])" 4
.IX Item "$obj->as_mbox_string([ALREADY_ESCAPED])"
Returns the message as a string in mbox format.  \f(CW\*(C`ALREADY_ESCAPED\*(C'\fR, if
given and true, indicates that \fIescape_from()\fR has already been called on
this object.
.ie n .IP "$obj\->\fBas_string\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBas_string\fR()" 4
.IX Item "$obj->as_string()"
Returns the message as a single string.
.ie n .IP "$obj\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print([FILEHANDLE])"
Print the header, body or whole message to file descriptor \fI\s-1FILEHANDLE\s0\fR.
\&\fI\f(CI$fd\fI\fR should be a reference to a \s-1GLOB.\s0 If \fI\s-1FILEHANDLE\s0\fR is not given the
output will be sent to \s-1STDOUT.\s0
.Sp
example:
.Sp
.Vb 1
\&    $mail\->print( \e*STDOUT );  # Print message to STDOUT
.Ve
.ie n .IP "$obj\->\fBprint_body\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint_body\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print_body([FILEHANDLE])"
Print only the body to the \s-1FILEHANDLE \s0(default \s-1STDOUT\s0).
.ie n .IP "$obj\->\fBprint_header\fR([\s-1FILEHANDLE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBprint_header\fR([\s-1FILEHANDLE\s0])" 4
.IX Item "$obj->print_header([FILEHANDLE])"
Print only the header to the \s-1FILEHANDLE \s0(default \s-1STDOUT\s0).
.SS "Processing the header"
.IX Subsection "Processing the header"
Most of these methods are simply wrappers around methods provided
by Mail::Header.
.ie n .IP "$obj\->\fBadd\fR(PAIRS-of-FIELD)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR(PAIRS-of-FIELD)" 4
.IX Item "$obj->add(PAIRS-of-FIELD)"
The \s-1PAIRS\s0 are field-name and field-content.  For each \s-1PAIR,
\&\s0\fIMail::Header::add()\fR is called.  All fields are added after
existing fields.  The last addition is returned.
.ie n .IP "$obj\->\fBcombine\fR(\s-1TAG,\s0 [\s-1WITH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBcombine\fR(\s-1TAG,\s0 [\s-1WITH\s0])" 4
.IX Item "$obj->combine(TAG, [WITH])"
See \fIMail::Header::combine()\fR.
.ie n .IP "$obj\->\fBdelete\fR(\s-1TAG,\s0 [TAGs])" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR(\s-1TAG,\s0 [TAGs])" 4
.IX Item "$obj->delete(TAG, [TAGs])"
Delete all fields with the name \s-1TAG.  \s0\fIMail::Header::delete()\fR is doing the
work.
.ie n .IP "$obj\->\fBfold\fR([\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR([\s-1LENGTH\s0])" 4
.IX Item "$obj->fold([LENGTH])"
See \fIMail::Header::fold()\fR.
.ie n .IP "$obj\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBfold_length\fR([\s-1TAG\s0], [\s-1LENGTH\s0])" 4
.IX Item "$obj->fold_length([TAG], [LENGTH])"
See \fIMail::Header::fold_length()\fR.
.ie n .IP "$obj\->\fBget\fR(\s-1TAG,\s0 [TAGs])" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR(\s-1TAG,\s0 [TAGs])" 4
.IX Item "$obj->get(TAG, [TAGs])"
In \s-1LIST\s0 context, all fields with the name \s-1TAG\s0 are returned.  In \s-1SCALAR\s0
context, only the first field which matches the earliest \s-1TAG\s0 is returned.
\&\fIMail::Header::get()\fR is called to collect the data.
.ie n .IP "$obj\->\fBheader\fR([ARRAY\-of\-LINES])" 4
.el .IP "\f(CW$obj\fR\->\fBheader\fR([ARRAY\-of\-LINES])" 4
.IX Item "$obj->header([ARRAY-of-LINES])"
See \fIMail::Header::header()\fR.
.ie n .IP "$obj\->\fBreplace\fR(PAIRS-of-FIELD)" 4
.el .IP "\f(CW$obj\fR\->\fBreplace\fR(PAIRS-of-FIELD)" 4
.IX Item "$obj->replace(PAIRS-of-FIELD)"
The \s-1PAIRS\s0 are field-name and field-content.  For each \s-1PAIR,
\&\s0\fIMail::Header::replace()\fR is called with \s-1INDEX 0.\s0 If a \s-1FIELD\s0 is already
in the header, it will be removed first.  Do not specified the same
field-name twice.
.SS "Processing the body"
.IX Subsection "Processing the body"
.ie n .IP "$obj\->\fBremove_sig\fR([\s-1NLINES\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBremove_sig\fR([\s-1NLINES\s0])" 4
.IX Item "$obj->remove_sig([NLINES])"
Attempts to remove a users signature from the body of a message. It does this 
by looking for a line equal to \f(CW\*(Aq\-\- \*(Aq\fR within the last \f(CW\*(C`NLINES\*(C'\fR of the
message. If found then that line and all lines after it will be removed. If
\&\f(CW\*(C`NLINES\*(C'\fR is not given a default value of 10 will be used. This would be of
most use in auto-reply scripts.
.ie n .IP "$obj\->\fBsign\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBsign\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->sign(OPTIONS)"
Add your signature to the body.  \fIremove_sig()\fR will strip existing
signatures first.
.Sp
.Vb 3
\& \-Option   \-\-Default
\&  File       undef
\&  Signature  []
.Ve
.RS 4
.IP "File => \s-1FILEHANDLE\s0" 2
.IX Item "File => FILEHANDLE"
Take from the \s-1FILEHANDLE\s0 all lines starting from the first \f(CW\*(C`\-\-\*(C'\fR.
.IP "Signature => STRING|ARRAY\-of\-LINES" 2
.IX Item "Signature => STRING|ARRAY-of-LINES"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBtidy_body\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtidy_body\fR()" 4
.IX Item "$obj->tidy_body()"
.PD
Removes all leading and trailing lines from the body that only contain
white spaces.
.SS "High-level functionality"
.IX Subsection "High-level functionality"
.ie n .IP "$obj\->\fBescape_from\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBescape_from\fR()" 4
.IX Item "$obj->escape_from()"
It can cause problems with some applications if a message contains a line
starting with \f(CW\`From \*(Aq\fR, in particular when attempting to split a folder.
This method inserts a leading \f(CW\*(C`\`\*(C'\fR'> on any line that matches the regular
expression \f(CW\*(C`/^\*(C'\fR*From/>
.ie n .IP "$obj\->\fBnntppost\fR([\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBnntppost\fR([\s-1OPTIONS\s0])" 4
.IX Item "$obj->nntppost([OPTIONS])"
Post an article via \s-1NNTP. \s0 Requires Net::NNTP to be installed.
.Sp
.Vb 4
\& \-Option\-\-Default
\&  Debug   <false>
\&  Host    <required>
\&  Port    119
.Ve
.RS 4
.IP "Debug => \s-1BOOLEAN\s0" 2
.IX Item "Debug => BOOLEAN"
Debug value to pass to Net::NNTP, see Net::NNTP
.IP "Host => HOSTNAME|Net::NNTP object" 2
.IX Item "Host => HOSTNAME|Net::NNTP object"
Name of \s-1NNTP\s0 server to connect to, or a Net::NNTP object to use.
.IP "Port => \s-1INTEGER\s0" 2
.IX Item "Port => INTEGER"
Port number to connect to on remote host
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreply\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->reply(OPTIONS)"
Create a new object with header initialised for a reply to the current 
object. And the body will be a copy of the current message indented.
.Sp
The \f(CW\*(C`.mailhdr\*(C'\fR file in your home directory (if exists) will be read
first, to provide defaults.
.Sp
.Vb 5
\& \-Option  \-\-Default
\&  Exclude   []
\&  Indent    \*(Aq>\*(Aq
\&  Keep      []
\&  ReplyAll  false
.Ve
.RS 4
.IP "Exclude => ARRAY-of-FIELDS" 2
.IX Item "Exclude => ARRAY-of-FIELDS"
Remove the listed \s-1FIELDS\s0 from the produced message.
.IP "Indent => \s-1STRING\s0" 2
.IX Item "Indent => STRING"
Use as indentation string.  The string may contain \f(CW\*(C`%%\*(C'\fR to get a single \f(CW\*(C`%\*(C'\fR,
\&\f(CW%f\fR to get the first from name, \f(CW%F\fR is the first character of \f(CW%f\fR,
\&\f(CW%l\fR is the last name, \f(CW%L\fR its first character, \f(CW%n\fR the whole from
string, and \f(CW%I\fR the first character of each of the names in the from string.
.IP "Keep => ARRAY-of-FIELDS" 2
.IX Item "Keep => ARRAY-of-FIELDS"
Copy the listed \s-1FIELDS\s0 from the original message.
.IP "ReplyAll => \s-1BOOLEAN\s0" 2
.IX Item "ReplyAll => BOOLEAN"
Automatically include all To and Cc addresses of the original mail,
excluding those mentioned in the Bcc list.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBsend\fR([\s-1TYPE,\s0 [\s-1ARGS...\s0]])" 4
.el .IP "\f(CW$obj\fR\->\fBsend\fR([\s-1TYPE,\s0 [\s-1ARGS...\s0]])" 4
.IX Item "$obj->send([TYPE, [ARGS...]])"
Send a Mail::Internet message using Mail::Mailer.  \s-1TYPE\s0 and \s-1ARGS\s0 are
passed on to \fIMail::Mailer::new()\fR.
.ie n .IP "$obj\->\fBsmtpsend\fR([\s-1OPTIONS\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBsmtpsend\fR([\s-1OPTIONS\s0])" 4
.IX Item "$obj->smtpsend([OPTIONS])"
Send a Mail::Internet message using direct \s-1SMTP. \s0 to the given
\&\s-1ADDRESSES,\s0 each can be either a string or a reference to a list of email
addresses. If none of \f(CW\*(C`To\*(C'\fR, <Cc> or \f(CW\*(C`Bcc\*(C'\fR are given then the addresses
are extracted from the message being sent.
.Sp
The return value will be a list of email addresses that the message was sent
to. If the message was not sent the list will be empty.
.Sp
Requires Net::SMTP and Net::Domain to be installed.
.Sp
.Vb 9
\& \-Option  \-\-Default
\&  Bcc       undef
\&  Cc        undef
\&  Debug     <false>
\&  Hello     localhost.localdomain
\&  Host      $ENV{SMTPHOSTS}
\&  MailFrom  Mail::Util::mailaddress()
\&  Port      25
\&  To        undef
.Ve
.RS 4
.IP "Bcc => \s-1ADDRESSES\s0" 2
.IX Item "Bcc => ADDRESSES"
.PD 0
.IP "Cc => \s-1ADDRESSES\s0" 2
.IX Item "Cc => ADDRESSES"
.IP "Debug => \s-1BOOLEAN\s0" 2
.IX Item "Debug => BOOLEAN"
.PD
Debug value to pass to Net::SMPT, see <Net::SMTP>
.IP "Hello => \s-1STRING\s0" 2
.IX Item "Hello => STRING"
Send a \s-1HELO \s0(or \s-1EHLO\s0) command to the server with the given name.
.IP "Host => \s-1HOSTNAME\s0" 2
.IX Item "Host => HOSTNAME"
Name of the \s-1SMTP\s0 server to connect to, or a Net::SMTP object to use
.Sp
If \f(CW\*(C`Host\*(C'\fR is not given then the \s-1SMTP\s0 host is found by attempting
connections first to hosts specified in \f(CW$ENV{SMTPHOSTS}\fR, a colon
separated list, then \f(CW\*(C`mailhost\*(C'\fR and \f(CW\*(C`localhost\*(C'\fR.
.IP "MailFrom => \s-1ADDRESS\s0" 2
.IX Item "MailFrom => ADDRESS"
The e\-mail address which is used as sender.  By default,
\&\fIMail::Util::mailaddress()\fR provides the address of the sender.
.IP "Port => \s-1INTEGER\s0" 2
.IX Item "Port => INTEGER"
Port number to connect to on remote host
.IP "To => \s-1ADDRESSES\s0" 2
.IX Item "To => ADDRESSES"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBunescape_from\fR(())" 4
.el .IP "\f(CW$obj\fR\->\fBunescape_from\fR(())" 4
.IX Item "$obj->unescape_from(())"
.PD
Remove the escaping added by \fIescape_from()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Mailer.3pm                             0100644 0001750 0001750 00000021517 12566241445 023510  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Mailer 3"
.TH Mail::Mailer 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Mailer \- Simple interface to electronic mailing mechanisms
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Mailer
\&   is a IO::Handle
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::Mailer;
\&  use Mail::Mailer qw(mail);    # specifies default mailer
\&
\&  $mailer = Mail::Mailer\->new;
\&  $mailer = Mail::Mailer\->new($type, @args);
\&
\&  $mailer\->open(\e%headers);
\&  print $mailer $body;
\&  $mailer\->close
\&      or die "couldn\*(Aqt send whole message: $!\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sends mail using any of the built-in methods.  As \s-1TYPE\s0 argument
to \fInew()\fR, you can specify any of
.ie n .IP """sendmail""" 4
.el .IP "\f(CWsendmail\fR" 4
.IX Item "sendmail"
Use the \f(CW\*(C`sendmail\*(C'\fR program to deliver the mail.
.ie n .IP """smtp""" 4
.el .IP "\f(CWsmtp\fR" 4
.IX Item "smtp"
Use the \f(CW\*(C`smtp\*(C'\fR protocol via Net::SMTP to deliver the mail. The server
to use can be specified in \f(CW@args\fR with
.Sp
.Vb 1
\& $mailer = Mail::Mailer\->new(\*(Aqsmtp\*(Aq, Server => $server);
.Ve
.Sp
The smtp mailer does not handle \f(CW\*(C`Cc\*(C'\fR and \f(CW\*(C`Bcc\*(C'\fR lines, neither their
\&\f(CW\*(C`Resent\-*\*(C'\fR fellows. The \f(CW\*(C`Debug\*(C'\fR options enables debugging output
from \f(CW\*(C`Net::SMTP\*(C'\fR.
.Sp
You may also use the \f(CW\*(C`Auth => [ $user, $password ]\*(C'\fR option for \s-1SASL\s0
authentication. To make this work, you have to install the Authen::SASL
distribution yourself: it is not automatically installed.
.ie n .IP """smtps""" 4
.el .IP "\f(CWsmtps\fR" 4
.IX Item "smtps"
Use the smtp over ssl protocol via Net::SMTP::SSL to deliver the mail.
Usage is identical to \f(CW\*(C`smtp\*(C'\fR. You have to install Authen::SASL as
well.
.Sp
.Vb 1
\& $mailer = Mail::Mailer\->new(\*(Aqsmtps\*(Aq, Server => $server);
.Ve
.ie n .IP """qmail""" 4
.el .IP "\f(CWqmail\fR" 4
.IX Item "qmail"
Use qmail's qmail-inject program to deliver the mail.
.ie n .IP """testfile""" 4
.el .IP "\f(CWtestfile\fR" 4
.IX Item "testfile"
Used for debugging, this displays the data to the file named in
\&\f(CW$Mail::Mailer::testfile::config{outfile}\fR which defaults to a file
named \f(CW\*(C`mailer.testfile\*(C'\fR.  No mail is ever sent.
.PP
\&\f(CW\*(C`Mail::Mailer\*(C'\fR will search for executables in the above order. The
default mailer will be the first one found.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Mailer\->\fBnew\fR(\s-1TYPE, ARGS\s0)" 4
.IX Item "Mail::Mailer->new(TYPE, ARGS)"
The \s-1TYPE\s0 is one of the back-end sender implementations, as described in
the \s-1DESCRIPTION\s0 chapter of this manual page.  The \s-1ARGS\s0 are passed to
that back-end.
.ie n .IP "$obj\->\fBopen\fR(\s-1HASH\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopen\fR(\s-1HASH\s0)" 4
.IX Item "$obj->open(HASH)"
The \s-1HASH\s0 consists of key and value pairs, the key being the name of
the header field (eg, \f(CW\*(C`To\*(C'\fR), and the value being the corresponding
contents of the header field.  The value can either be a scalar
(eg, \f(CW\*(C`gnat@frii.com\*(C'\fR) or a reference to an array of scalars
(\f(CW\*(C`eg, [\*(Aqgnat@frii.com\*(Aq, \*(AqTim.Bunce@ig.co.uk\*(Aq]\*(C'\fR).
.SH "DETAILS"
.IX Header "DETAILS"
.SS "\s-1ENVIRONMENT VARIABLES\s0"
.IX Subsection "ENVIRONMENT VARIABLES"
.IP "\s-1PERL_MAILERS\s0" 4
.IX Item "PERL_MAILERS"
Augments/override the build in choice for binary used to send out
our mail messages.
.Sp
Format:
.Sp
.Vb 1
\&    "type1:mailbinary1;mailbinary2;...:type2:mailbinaryX;...:..."
.Ve
.Sp
Example: assume you want you use private sendmail binary instead
of mailx, one could set \f(CW\*(C`PERL_MAILERS\*(C'\fR to:
.Sp
.Vb 1
\&    "mail:/does/not/exists:sendmail:$HOME/test/bin/sendmail"
.Ve
.Sp
On systems which may include \f(CW\*(C`:\*(C'\fR in file names, use \f(CW\*(C`|\*(C'\fR as separator
between type-groups.
.Sp
.Vb 1
\&    "mail:c:/does/not/exists|sendmail:$HOME/test/bin/sendmail"
.Ve
.SS "\s-1BUGS\s0"
.IX Subsection "BUGS"
Mail::Mailer does not help with folding, and does not protect
against various web-script hacker attacks, for instance where
a new-line is inserted in the content of the field.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Mailer5.16.3pm                         0100644 0001750 0001750 00000021214 12566241445 024014  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Mailer 3"
.TH Mail::Mailer 3 "2012-08-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Mailer \- Simple interface to electronic mailing mechanisms
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Mailer
\&   is a IO::Handle
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::Mailer;
\&  use Mail::Mailer qw(mail);    # specifies default mailer
\&
\&  $mailer = Mail::Mailer\->new;
\&  $mailer = Mail::Mailer\->new($type, @args);
\&
\&  $mailer\->open(\e%headers);
\&  print $mailer $body;
\&  $mailer\->close
\&      or die "couldn\*(Aqt send whole message: $!\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sends mail using any of the built-in methods.  As \s-1TYPE\s0 argument
to \fInew()\fR, you can specify any of
.ie n .IP """sendmail""" 4
.el .IP "\f(CWsendmail\fR" 4
.IX Item "sendmail"
Use the \f(CW\*(C`sendmail\*(C'\fR program to deliver the mail.
.ie n .IP """smtp""" 4
.el .IP "\f(CWsmtp\fR" 4
.IX Item "smtp"
Use the \f(CW\*(C`smtp\*(C'\fR protocol via Net::SMTP to deliver the mail. The server
to use can be specified in \f(CW@args\fR with
.Sp
.Vb 1
\& $mailer = Mail::Mailer\->new(\*(Aqsmtp\*(Aq, Server => $server);
.Ve
.Sp
The smtp mailer does not handle \f(CW\*(C`Cc\*(C'\fR and \f(CW\*(C`Bcc\*(C'\fR lines, neither their
\&\f(CW\*(C`Resent\-*\*(C'\fR fellows. The \f(CW\*(C`Debug\*(C'\fR options enables debugging output
from \f(CW\*(C`Net::SMTP\*(C'\fR.
.Sp
You may also use the \f(CW\*(C`Auth => [ $user, $password ]\*(C'\fR option for \s-1SASL\s0
authentication. To make this work, you have to install the Authen::SASL
distribution yourself: it is not automatically installed.
.ie n .IP """smtps""" 4
.el .IP "\f(CWsmtps\fR" 4
.IX Item "smtps"
Use the smtp over ssl protocol via Net::SMTP::SSL to deliver the mail.
Usage is identical to \f(CW\*(C`smtp\*(C'\fR. You have to install Authen::SASL as
well.
.Sp
.Vb 1
\& $mailer = Mail::Mailer\->new(\*(Aqsmtps\*(Aq, Server => $server);
.Ve
.ie n .IP """qmail""" 4
.el .IP "\f(CWqmail\fR" 4
.IX Item "qmail"
Use qmail's qmail-inject program to deliver the mail.
.ie n .IP """testfile""" 4
.el .IP "\f(CWtestfile\fR" 4
.IX Item "testfile"
Used for debugging, this displays the data to the file named in
\&\f(CW$Mail::Mailer::testfile::config{outfile}\fR which defaults to a file
named \f(CW\*(C`mailer.testfile\*(C'\fR.  No mail is ever sent.
.PP
\&\f(CW\*(C`Mail::Mailer\*(C'\fR will search for executables in the above order. The
default mailer will be the first one found.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Mailer\->\fBnew\fR(\s-1TYPE\s0, \s-1ARGS\s0)" 4
.IX Item "Mail::Mailer->new(TYPE, ARGS)"
The \s-1TYPE\s0 is one of the back-end sender implementations, as described in
the \s-1DESCRIPTION\s0 chapter of this manual page.  The \s-1ARGS\s0 are passed to
that back-end.
.ie n .IP "$obj\->\fBopen\fR(\s-1HASH\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopen\fR(\s-1HASH\s0)" 4
.IX Item "$obj->open(HASH)"
The \s-1HASH\s0 consists of key and value pairs, the key being the name of
the header field (eg, \f(CW\*(C`To\*(C'\fR), and the value being the corresponding
contents of the header field.  The value can either be a scalar
(eg, \f(CW\*(C`gnat@frii.com\*(C'\fR) or a reference to an array of scalars
(\f(CW\*(C`eg, [\*(Aqgnat@frii.com\*(Aq, \*(AqTim.Bunce@ig.co.uk\*(Aq]\*(C'\fR).
.SH "DETAILS"
.IX Header "DETAILS"
.SS "\s-1ENVIRONMENT\s0 \s-1VARIABLES\s0"
.IX Subsection "ENVIRONMENT VARIABLES"
.IP "\s-1PERL_MAILERS\s0" 4
.IX Item "PERL_MAILERS"
Augments/override the build in choice for binary used to send out
our mail messages.
.Sp
Format:
.Sp
.Vb 1
\&    "type1:mailbinary1;mailbinary2;...:type2:mailbinaryX;...:..."
.Ve
.Sp
Example: assume you want you use private sendmail binary instead
of mailx, one could set \f(CW\*(C`PERL_MAILERS\*(C'\fR to:
.Sp
.Vb 1
\&    "mail:/does/not/exists:sendmail:$HOME/test/bin/sendmail"
.Ve
.Sp
On systems which may include \f(CW\*(C`:\*(C'\fR in file names, use \f(CW\*(C`|\*(C'\fR as separator
between type-groups.
.Sp
.Vb 1
\&    "mail:c:/does/not/exists|sendmail:$HOME/test/bin/sendmail"
.Ve
.SS "\s-1BUGS\s0"
.IX Subsection "BUGS"
Mail::Mailer does not help with folding, and does not protect
against various web-script hacker attacks, for instance where
a new-line is inserted in the content of the field.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::Mailer5.18.3pm                         0100644 0001750 0001750 00000021517 12566241445 024024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Mailer 3"
.TH Mail::Mailer 3 "2014-01-05" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Mailer \- Simple interface to electronic mailing mechanisms
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Mailer
\&   is a IO::Handle
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Mail::Mailer;
\&  use Mail::Mailer qw(mail);    # specifies default mailer
\&
\&  $mailer = Mail::Mailer\->new;
\&  $mailer = Mail::Mailer\->new($type, @args);
\&
\&  $mailer\->open(\e%headers);
\&  print $mailer $body;
\&  $mailer\->close
\&      or die "couldn\*(Aqt send whole message: $!\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sends mail using any of the built-in methods.  As \s-1TYPE\s0 argument
to \fInew()\fR, you can specify any of
.ie n .IP """sendmail""" 4
.el .IP "\f(CWsendmail\fR" 4
.IX Item "sendmail"
Use the \f(CW\*(C`sendmail\*(C'\fR program to deliver the mail.
.ie n .IP """smtp""" 4
.el .IP "\f(CWsmtp\fR" 4
.IX Item "smtp"
Use the \f(CW\*(C`smtp\*(C'\fR protocol via Net::SMTP to deliver the mail. The server
to use can be specified in \f(CW@args\fR with
.Sp
.Vb 1
\& $mailer = Mail::Mailer\->new(\*(Aqsmtp\*(Aq, Server => $server);
.Ve
.Sp
The smtp mailer does not handle \f(CW\*(C`Cc\*(C'\fR and \f(CW\*(C`Bcc\*(C'\fR lines, neither their
\&\f(CW\*(C`Resent\-*\*(C'\fR fellows. The \f(CW\*(C`Debug\*(C'\fR options enables debugging output
from \f(CW\*(C`Net::SMTP\*(C'\fR.
.Sp
You may also use the \f(CW\*(C`Auth => [ $user, $password ]\*(C'\fR option for \s-1SASL\s0
authentication. To make this work, you have to install the Authen::SASL
distribution yourself: it is not automatically installed.
.ie n .IP """smtps""" 4
.el .IP "\f(CWsmtps\fR" 4
.IX Item "smtps"
Use the smtp over ssl protocol via Net::SMTP::SSL to deliver the mail.
Usage is identical to \f(CW\*(C`smtp\*(C'\fR. You have to install Authen::SASL as
well.
.Sp
.Vb 1
\& $mailer = Mail::Mailer\->new(\*(Aqsmtps\*(Aq, Server => $server);
.Ve
.ie n .IP """qmail""" 4
.el .IP "\f(CWqmail\fR" 4
.IX Item "qmail"
Use qmail's qmail-inject program to deliver the mail.
.ie n .IP """testfile""" 4
.el .IP "\f(CWtestfile\fR" 4
.IX Item "testfile"
Used for debugging, this displays the data to the file named in
\&\f(CW$Mail::Mailer::testfile::config{outfile}\fR which defaults to a file
named \f(CW\*(C`mailer.testfile\*(C'\fR.  No mail is ever sent.
.PP
\&\f(CW\*(C`Mail::Mailer\*(C'\fR will search for executables in the above order. The
default mailer will be the first one found.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "Mail::Mailer\->\fBnew\fR(\s-1TYPE, ARGS\s0)" 4
.IX Item "Mail::Mailer->new(TYPE, ARGS)"
The \s-1TYPE\s0 is one of the back-end sender implementations, as described in
the \s-1DESCRIPTION\s0 chapter of this manual page.  The \s-1ARGS\s0 are passed to
that back-end.
.ie n .IP "$obj\->\fBopen\fR(\s-1HASH\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBopen\fR(\s-1HASH\s0)" 4
.IX Item "$obj->open(HASH)"
The \s-1HASH\s0 consists of key and value pairs, the key being the name of
the header field (eg, \f(CW\*(C`To\*(C'\fR), and the value being the corresponding
contents of the header field.  The value can either be a scalar
(eg, \f(CW\*(C`gnat@frii.com\*(C'\fR) or a reference to an array of scalars
(\f(CW\*(C`eg, [\*(Aqgnat@frii.com\*(Aq, \*(AqTim.Bunce@ig.co.uk\*(Aq]\*(C'\fR).
.SH "DETAILS"
.IX Header "DETAILS"
.SS "\s-1ENVIRONMENT VARIABLES\s0"
.IX Subsection "ENVIRONMENT VARIABLES"
.IP "\s-1PERL_MAILERS\s0" 4
.IX Item "PERL_MAILERS"
Augments/override the build in choice for binary used to send out
our mail messages.
.Sp
Format:
.Sp
.Vb 1
\&    "type1:mailbinary1;mailbinary2;...:type2:mailbinaryX;...:..."
.Ve
.Sp
Example: assume you want you use private sendmail binary instead
of mailx, one could set \f(CW\*(C`PERL_MAILERS\*(C'\fR to:
.Sp
.Vb 1
\&    "mail:/does/not/exists:sendmail:$HOME/test/bin/sendmail"
.Ve
.Sp
On systems which may include \f(CW\*(C`:\*(C'\fR in file names, use \f(CW\*(C`|\*(C'\fR as separator
between type-groups.
.Sp
.Vb 1
\&    "mail:c:/does/not/exists|sendmail:$HOME/test/bin/sendmail"
.Ve
.SS "\s-1BUGS\s0"
.IX Subsection "BUGS"
Mail::Mailer does not help with folding, and does not protect
against various web-script hacker attacks, for instance where
a new-line is inserted in the content of the field.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of the MailTools distribution,
\&\fIhttp://perl.overmeer.net/mailtools/\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
The MailTools bundle was developed by Graham Barr.  Later, Mark
Overmeer took over maintenance without commitment to further development.
.PP
Mail::Cap by Gisle Aas <aas@oslonett.no>.
Mail::Field::AddrList by Peter Orbaek <poe@cit.dk>.
Mail::Mailer and Mail::Send by Tim Bunce <Tim.Bunce@ig.co.uk>.
For other contributors see ChangeLog.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1995\-2000 Graham Barr <gbarr@pobox.com> and
2001\-2007 Mark Overmeer <perl@overmeer.net>.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF.3pm                                0100644 0001750 0001750 00000014037 12566242050 022717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF 3"
.TH Mail::SPF 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF \- An object\-oriented implementation of Sender Policy Framework
.SH "VERSION"
.IX Header "VERSION"
2.009
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $spf_server  = Mail::SPF::Server\->new();
\&
\&    my $request     = Mail::SPF::Request\->new(
\&        versions        => [1, 2],              # optional
\&        scope           => \*(Aqmfrom\*(Aq,             # or \*(Aqhelo\*(Aq, \*(Aqpra\*(Aq
\&        identity        => \*(Aqfred@example.com\*(Aq,
\&        ip_address      => \*(Aq192.168.0.1\*(Aq,
\&        helo_identity   => \*(Aqmta.example.com\*(Aq    # optional,
\&                                                #   for %{h} macro expansion
\&    );
\&
\&    my $result      = $spf_server\->process($request);
\&
\&    print("$result\en");
\&    my $result_code     = $result\->code;        # \*(Aqpass\*(Aq, \*(Aqfail\*(Aq, etc.
\&    my $local_exp       = $result\->local_explanation;
\&    my $authority_exp   = $result\->authority_explanation
\&        if $result\->is_code(\*(Aqfail\*(Aq);
\&    my $spf_header      = $result\->received_spf_header;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF\fR is an object-oriented implementation of Sender Policy Framework
(\s-1SPF\s0).  See <http://www.openspf.org> for more information about \s-1SPF.\s0
.PP
This class collection aims to fully conform to the \s-1SPF\s0 specification (\s-1RFC
4408\s0) so as to serve both as a production quality \s-1SPF\s0 implementation and as a
reference for other developers of \s-1SPF\s0 implementations.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Server, Mail::SPF::Request, Mail::SPF::Result
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "The \s-1SPF\s0 project" 4
.IX Item "The SPF project"
<http://www.openspf.org>
.IP "The SPFv1 specification (\s-1RFC 4408\s0)" 4
.IX Item "The SPFv1 specification (RFC 4408)"
<http://www.openspf.org/Specifications>, <http://tools.ietf.org/html/rfc4408>
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF5.16.3pm                            0100644 0001750 0001750 00000013516 12566242063 023236  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF 3"
.TH Mail::SPF 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF \- An object\-oriented implementation of Sender Policy Framework
.SH "VERSION"
.IX Header "VERSION"
2.008
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $spf_server  = Mail::SPF::Server\->new();
\&
\&    my $request     = Mail::SPF::Request\->new(
\&        versions        => [1, 2],              # optional
\&        scope           => \*(Aqmfrom\*(Aq,             # or \*(Aqhelo\*(Aq, \*(Aqpra\*(Aq
\&        identity        => \*(Aqfred@example.com\*(Aq,
\&        ip_address      => \*(Aq192.168.0.1\*(Aq,
\&        helo_identity   => \*(Aqmta.example.com\*(Aq    # optional,
\&                                                #   for %{h} macro expansion
\&    );
\&
\&    my $result      = $spf_server\->process($request);
\&
\&    print("$result\en");
\&    my $result_code     = $result\->code;        # \*(Aqpass\*(Aq, \*(Aqfail\*(Aq, etc.
\&    my $local_exp       = $result\->local_explanation;
\&    my $authority_exp   = $result\->authority_explanation
\&        if $result\->is_code(\*(Aqfail\*(Aq);
\&    my $spf_header      = $result\->received_spf_header;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF\fR is an object-oriented implementation of Sender Policy Framework
(\s-1SPF\s0).  See <http://www.openspf.net> for more information about \s-1SPF\s0.
.PP
This class collection aims to fully conform to the \s-1SPF\s0 specification (\s-1RFC\s0
4408) so as to serve both as a production quality \s-1SPF\s0 implementation and as a
reference for other developers of \s-1SPF\s0 implementations.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Server, Mail::SPF::Request, Mail::SPF::Result
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "The \s-1SPF\s0 project" 4
.IX Item "The SPF project"
<http://www.openspf.net>
.IP "The SPFv1 specification (\s-1RFC\s0 4408)" 4
.IX Item "The SPFv1 specification (RFC 4408)"
<http://www.openspf.net/Specifications>, <http://tools.ietf.org/html/rfc4408>
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF5.18.3pm                            0100644 0001750 0001750 00000014037 12566242050 023233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF 3"
.TH Mail::SPF 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF \- An object\-oriented implementation of Sender Policy Framework
.SH "VERSION"
.IX Header "VERSION"
2.009
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Mail::SPF;
\&
\&    my $spf_server  = Mail::SPF::Server\->new();
\&
\&    my $request     = Mail::SPF::Request\->new(
\&        versions        => [1, 2],              # optional
\&        scope           => \*(Aqmfrom\*(Aq,             # or \*(Aqhelo\*(Aq, \*(Aqpra\*(Aq
\&        identity        => \*(Aqfred@example.com\*(Aq,
\&        ip_address      => \*(Aq192.168.0.1\*(Aq,
\&        helo_identity   => \*(Aqmta.example.com\*(Aq    # optional,
\&                                                #   for %{h} macro expansion
\&    );
\&
\&    my $result      = $spf_server\->process($request);
\&
\&    print("$result\en");
\&    my $result_code     = $result\->code;        # \*(Aqpass\*(Aq, \*(Aqfail\*(Aq, etc.
\&    my $local_exp       = $result\->local_explanation;
\&    my $authority_exp   = $result\->authority_explanation
\&        if $result\->is_code(\*(Aqfail\*(Aq);
\&    my $spf_header      = $result\->received_spf_header;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF\fR is an object-oriented implementation of Sender Policy Framework
(\s-1SPF\s0).  See <http://www.openspf.org> for more information about \s-1SPF.\s0
.PP
This class collection aims to fully conform to the \s-1SPF\s0 specification (\s-1RFC
4408\s0) so as to serve both as a production quality \s-1SPF\s0 implementation and as a
reference for other developers of \s-1SPF\s0 implementations.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Server, Mail::SPF::Request, Mail::SPF::Result
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "The \s-1SPF\s0 project" 4
.IX Item "The SPF project"
<http://www.openspf.org>
.IP "The SPFv1 specification (\s-1RFC 4408\s0)" 4
.IX Item "The SPFv1 specification (RFC 4408)"
<http://www.openspf.org/Specifications>, <http://tools.ietf.org/html/rfc4408>
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Base.3pm                          0100644 0001750 0001750 00000014033 12566242051 023673  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Base 3"
.TH Mail::SPF::Base 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Base \- Base class for Mail::SPF classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use base \*(AqMail::SPF::Base\*(Aq;
\&
\&    sub new {
\&        my ($class, @options) = @_;
\&        my $self = $class\->SUPER::new(@options);
\&        ...
\&        return $self;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Base\fR is a common base class for all \fBMail::SPF\fR classes.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Base\fR" 4
.IX Item "new(%options): returns Mail::SPF::Base"
Creates a new object of the class on which the constructor was invoked.  The
provided options are stored as key/value pairs in the new object.
.Sp
The \f(CW\*(C`new\*(C'\fR constructor may also be called on an object, in which case the
object is cloned.  Any options provided override those from the old object.
.Sp
There are no common options defined in \fBMail::SPF::Base\fR.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBclass\fR: returns \fIstring\fR" 4
.IX Item "class: returns string"
Returns the class name of the class or object on which it is invoked.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.ie n .IP "\fBmake_accessor($name, \fB$readonly\fB)\fR: returns \fIcode-ref\fR" 4
.el .IP "\fBmake_accessor($name, \f(CB$readonly\fB)\fR: returns \fIcode-ref\fR" 4
.IX Item "make_accessor($name, $readonly): returns code-ref"
Creates an accessor method in the class on which it is invoked.  The accessor
has the given name and accesses the object field of the same name.  If
\&\f(CW$readonly\fR is \fBtrue\fR, the accessor is made read-only.
.SS "Instance methods"
.IX Subsection "Instance methods"
There are no common instance methods defined in \fBMail::SPF::Base\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Base5.16.3pm                      0100644 0001750 0001750 00000013512 12566242063 024211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Base 3"
.TH Mail::SPF::Base 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Base \- Base class for Mail::SPF classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use base \*(AqMail::SPF::Base\*(Aq;
\&
\&    sub new {
\&        my ($class, @options) = @_;
\&        my $self = $class\->SUPER::new(@options);
\&        ...
\&        return $self;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Base\fR is a common base class for all \fBMail::SPF\fR classes.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Base\fR" 4
.IX Item "new(%options): returns Mail::SPF::Base"
Creates a new object of the class on which the constructor was invoked.  The
provided options are stored as key/value pairs in the new object.
.Sp
The \f(CW\*(C`new\*(C'\fR constructor may also be called on an object, in which case the
object is cloned.  Any options provided override those from the old object.
.Sp
There are no common options defined in \fBMail::SPF::Base\fR.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBclass\fR: returns \fIstring\fR" 4
.IX Item "class: returns string"
Returns the class name of the class or object on which it is invoked.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.ie n .IP "\fBmake_accessor($name, \fB$readonly\fB)\fR: returns \fIcode-ref\fR" 4
.el .IP "\fBmake_accessor($name, \f(CB$readonly\fB)\fR: returns \fIcode-ref\fR" 4
.IX Item "make_accessor($name, $readonly): returns code-ref"
Creates an accessor method in the class on which it is invoked.  The accessor
has the given name and accesses the object field of the same name.  If
\&\f(CW$readonly\fR is \fBtrue\fR, the accessor is made read-only.
.SS "Instance methods"
.IX Subsection "Instance methods"
There are no common instance methods defined in \fBMail::SPF::Base\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Base5.18.3pm                      0100644 0001750 0001750 00000014033 12566242051 024207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Base 3"
.TH Mail::SPF::Base 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Base \- Base class for Mail::SPF classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use base \*(AqMail::SPF::Base\*(Aq;
\&
\&    sub new {
\&        my ($class, @options) = @_;
\&        my $self = $class\->SUPER::new(@options);
\&        ...
\&        return $self;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMail::SPF::Base\fR is a common base class for all \fBMail::SPF\fR classes.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Base\fR" 4
.IX Item "new(%options): returns Mail::SPF::Base"
Creates a new object of the class on which the constructor was invoked.  The
provided options are stored as key/value pairs in the new object.
.Sp
The \f(CW\*(C`new\*(C'\fR constructor may also be called on an object, in which case the
object is cloned.  Any options provided override those from the old object.
.Sp
There are no common options defined in \fBMail::SPF::Base\fR.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBclass\fR: returns \fIstring\fR" 4
.IX Item "class: returns string"
Returns the class name of the class or object on which it is invoked.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.ie n .IP "\fBmake_accessor($name, \fB$readonly\fB)\fR: returns \fIcode-ref\fR" 4
.el .IP "\fBmake_accessor($name, \f(CB$readonly\fB)\fR: returns \fIcode-ref\fR" 4
.IX Item "make_accessor($name, $readonly): returns code-ref"
Creates an accessor method in the class on which it is invoked.  The accessor
has the given name and accesses the object field of the same name.  If
\&\f(CW$readonly\fR is \fBtrue\fR, the accessor is made read-only.
.SS "Instance methods"
.IX Subsection "Instance methods"
There are no common instance methods defined in \fBMail::SPF::Base\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::MacroString.3pm                   0100644 0001750 0001750 00000022502 12566242051 025251  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::MacroString 3"
.TH Mail::SPF::MacroString 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::MacroString \- SPF record macro string class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Providing the expansion context early"
.IX Subsection "Providing the expansion context early"
.Vb 1
\&    use Mail::SPF::MacroString;
\&
\&    my $macrostring = Mail::SPF::MacroString\->new(
\&        text    => \*(Aq%{ir}.%{v}._spf.%{d2}\*(Aq,
\&        server  => $server,
\&        request => $request
\&    );
\&
\&    my $expanded = $macrostring\->expand;
.Ve
.SS "Providing the expansion context late"
.IX Subsection "Providing the expansion context late"
.Vb 1
\&    use Mail::SPF::MacroString;
\&
\&    my $macrostring = Mail::SPF::MacroString\->new(
\&        text    => \*(Aq%{ir}.%{v}._spf.%{d2}\*(Aq
\&    );
\&
\&    my $expanded1 = $macrostring\->expand($server, $request1);
\&
\&    $macrostring\->context($server, $request2);
\&    my $expanded2 = $macrostring\->expand;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::MacroString\fR represents a macro string that
can be expanded to a plain string in the context of an \s-1SPF\s0 request.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "new(%options): returns Mail::SPF::MacroString"
Creates a new \s-1SPF\s0 record macro string object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
\&\fIRequired\fR.  The unexpanded text of the new macro string.
.IP "\fBserver\fR" 4
.IX Item "server"
The \fIMail::SPF::Server\fR object that is to be used when expanding the macro
string.  A server object need not be attached statically to the macro string;
it can be specified dynamically when calling the \f(CW\*(C`expand\*(C'\fR method.
.IP "\fBrequest\fR" 4
.IX Item "request"
The \fIMail::SPF::Request\fR object that is to be used when expanding the macro
string.  A request object need not be attached statically to the macro string;
it can be specified dynamically when calling the \f(CW\*(C`expand\*(C'\fR method.
.IP "\fBis_explanation\fR" 4
.IX Item "is_explanation"
A \fIboolean\fR denoting whether the macro string is an explanation string
obtained via an \f(CW\*(C`exp\*(C'\fR modifier.  If \fBtrue\fR, the \f(CW\*(C`c\*(C'\fR, \f(CW\*(C`r\*(C'\fR, and \f(CW\*(C`t\*(C'\fR macros
may appear in the macro string, otherwise they may not, and if they do, a
\&\fIMail::SPF::EInvalidMacro\fR exception will be thrown when the macro string is
expanded.  Defaults to \fBfalse\fR.
.RE
.RS 4
.RE
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR" 4
.IX Item "text: returns string"
Returns the unexpanded text of the macro string.
.ie n .IP "\fBcontext($server, \fB$request\fB)\fR: throws \fIMail::SPF::EOptionRequired\fR" 4
.el .IP "\fBcontext($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::EOptionRequired\fR" 4
.IX Item "context($server, $request): throws Mail::SPF::EOptionRequired"
Attaches the given \fIMail::SPF::Server\fR and \fIMail::SPF::Request\fR objects as
the context for the macro string.
.IP "\fBexpand\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.IX Item "expand: returns string; throws Mail::SPF::EMacroExpansionCtxRequired, Mail::SPF::EInvalidMacroString, Mail::SPF::Result::PermError"
.PD 0
.ie n .IP "\fBexpand($server, \fB$request\fB)\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.el .IP "\fBexpand($server, \f(CB$request\fB)\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.IX Item "expand($server, $request): returns string; throws Mail::SPF::EMacroExpansionCtxRequired, Mail::SPF::EInvalidMacroString, Mail::SPF::Result::PermError"
.PD
Expands the text of the macro string using either the context specified through
an earlier call to the \f(CW\*(C`context()\*(C'\fR method, or the given context, and returns
the resulting string.  See \s-1RFC 4408, 8,\s0 for how macros are expanded.
.IP "\fBis_explanation\fR: returns \fIboolean\fR" 4
.IX Item "is_explanation: returns boolean"
Returns \fBtrue\fR if the macro string is an explanation string obtained via an
\&\f(CW\*(C`exp\*(C'\fR modifier.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`is_explanation\*(C'\fR option.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the expanded text of the macro string if a context is attached to the
object.  Returns the unexpanded text otherwise.  You can simply use a
Mail::SPF::MacroString object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::MacroString object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR
method is used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Server, Mail::SPF::Request
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::MacroString5.16.3pm               0100644 0001750 0001750 00000022161 12566242062 025566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::MacroString 3"
.TH Mail::SPF::MacroString 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::MacroString \- SPF record macro string class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Providing the expansion context early"
.IX Subsection "Providing the expansion context early"
.Vb 1
\&    use Mail::SPF::MacroString;
\&
\&    my $macrostring = Mail::SPF::MacroString\->new(
\&        text    => \*(Aq%{ir}.%{v}._spf.%{d2}\*(Aq,
\&        server  => $server,
\&        request => $request
\&    );
\&
\&    my $expanded = $macrostring\->expand;
.Ve
.SS "Providing the expansion context late"
.IX Subsection "Providing the expansion context late"
.Vb 1
\&    use Mail::SPF::MacroString;
\&
\&    my $macrostring = Mail::SPF::MacroString\->new(
\&        text    => \*(Aq%{ir}.%{v}._spf.%{d2}\*(Aq
\&    );
\&
\&    my $expanded1 = $macrostring\->expand($server, $request1);
\&
\&    $macrostring\->context($server, $request2);
\&    my $expanded2 = $macrostring\->expand;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::MacroString\fR represents a macro string that
can be expanded to a plain string in the context of an \s-1SPF\s0 request.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "new(%options): returns Mail::SPF::MacroString"
Creates a new \s-1SPF\s0 record macro string object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
\&\fIRequired\fR.  The unexpanded text of the new macro string.
.IP "\fBserver\fR" 4
.IX Item "server"
The \fIMail::SPF::Server\fR object that is to be used when expanding the macro
string.  A server object need not be attached statically to the macro string;
it can be specified dynamically when calling the \f(CW\*(C`expand\*(C'\fR method.
.IP "\fBrequest\fR" 4
.IX Item "request"
The \fIMail::SPF::Request\fR object that is to be used when expanding the macro
string.  A request object need not be attached statically to the macro string;
it can be specified dynamically when calling the \f(CW\*(C`expand\*(C'\fR method.
.IP "\fBis_explanation\fR" 4
.IX Item "is_explanation"
A \fIboolean\fR denoting whether the macro string is an explanation string
obtained via an \f(CW\*(C`exp\*(C'\fR modifier.  If \fBtrue\fR, the \f(CW\*(C`c\*(C'\fR, \f(CW\*(C`r\*(C'\fR, and \f(CW\*(C`t\*(C'\fR macros
may appear in the macro string, otherwise they may not, and if they do, a
\&\fIMail::SPF::EInvalidMacro\fR exception will be thrown when the macro string is
expanded.  Defaults to \fBfalse\fR.
.RE
.RS 4
.RE
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR" 4
.IX Item "text: returns string"
Returns the unexpanded text of the macro string.
.ie n .IP "\fBcontext($server, \fB$request\fB)\fR: throws \fIMail::SPF::EOptionRequired\fR" 4
.el .IP "\fBcontext($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::EOptionRequired\fR" 4
.IX Item "context($server, $request): throws Mail::SPF::EOptionRequired"
Attaches the given \fIMail::SPF::Server\fR and \fIMail::SPF::Request\fR objects as
the context for the macro string.
.IP "\fBexpand\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.IX Item "expand: returns string; throws Mail::SPF::EMacroExpansionCtxRequired, Mail::SPF::EInvalidMacroString, Mail::SPF::Result::PermError"
.PD 0
.ie n .IP "\fBexpand($server, \fB$request\fB)\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.el .IP "\fBexpand($server, \f(CB$request\fB)\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.IX Item "expand($server, $request): returns string; throws Mail::SPF::EMacroExpansionCtxRequired, Mail::SPF::EInvalidMacroString, Mail::SPF::Result::PermError"
.PD
Expands the text of the macro string using either the context specified through
an earlier call to the \f(CW\*(C`context()\*(C'\fR method, or the given context, and returns
the resulting string.  See \s-1RFC\s0 4408, 8, for how macros are expanded.
.IP "\fBis_explanation\fR: returns \fIboolean\fR" 4
.IX Item "is_explanation: returns boolean"
Returns \fBtrue\fR if the macro string is an explanation string obtained via an
\&\f(CW\*(C`exp\*(C'\fR modifier.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`is_explanation\*(C'\fR option.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the expanded text of the macro string if a context is attached to the
object.  Returns the unexpanded text otherwise.  You can simply use a
Mail::SPF::MacroString object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\s0\*(R".
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::MacroString object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR
method is used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Server, Mail::SPF::Request
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::MacroString5.18.3pm               0100644 0001750 0001750 00000022502 12566242051 025565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::MacroString 3"
.TH Mail::SPF::MacroString 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::MacroString \- SPF record macro string class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Providing the expansion context early"
.IX Subsection "Providing the expansion context early"
.Vb 1
\&    use Mail::SPF::MacroString;
\&
\&    my $macrostring = Mail::SPF::MacroString\->new(
\&        text    => \*(Aq%{ir}.%{v}._spf.%{d2}\*(Aq,
\&        server  => $server,
\&        request => $request
\&    );
\&
\&    my $expanded = $macrostring\->expand;
.Ve
.SS "Providing the expansion context late"
.IX Subsection "Providing the expansion context late"
.Vb 1
\&    use Mail::SPF::MacroString;
\&
\&    my $macrostring = Mail::SPF::MacroString\->new(
\&        text    => \*(Aq%{ir}.%{v}._spf.%{d2}\*(Aq
\&    );
\&
\&    my $expanded1 = $macrostring\->expand($server, $request1);
\&
\&    $macrostring\->context($server, $request2);
\&    my $expanded2 = $macrostring\->expand;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::MacroString\fR represents a macro string that
can be expanded to a plain string in the context of an \s-1SPF\s0 request.
.SS "Constructor"
.IX Subsection "Constructor"
The following constructor is provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::MacroString\fR" 4
.IX Item "new(%options): returns Mail::SPF::MacroString"
Creates a new \s-1SPF\s0 record macro string object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
\&\fIRequired\fR.  The unexpanded text of the new macro string.
.IP "\fBserver\fR" 4
.IX Item "server"
The \fIMail::SPF::Server\fR object that is to be used when expanding the macro
string.  A server object need not be attached statically to the macro string;
it can be specified dynamically when calling the \f(CW\*(C`expand\*(C'\fR method.
.IP "\fBrequest\fR" 4
.IX Item "request"
The \fIMail::SPF::Request\fR object that is to be used when expanding the macro
string.  A request object need not be attached statically to the macro string;
it can be specified dynamically when calling the \f(CW\*(C`expand\*(C'\fR method.
.IP "\fBis_explanation\fR" 4
.IX Item "is_explanation"
A \fIboolean\fR denoting whether the macro string is an explanation string
obtained via an \f(CW\*(C`exp\*(C'\fR modifier.  If \fBtrue\fR, the \f(CW\*(C`c\*(C'\fR, \f(CW\*(C`r\*(C'\fR, and \f(CW\*(C`t\*(C'\fR macros
may appear in the macro string, otherwise they may not, and if they do, a
\&\fIMail::SPF::EInvalidMacro\fR exception will be thrown when the macro string is
expanded.  Defaults to \fBfalse\fR.
.RE
.RS 4
.RE
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR" 4
.IX Item "text: returns string"
Returns the unexpanded text of the macro string.
.ie n .IP "\fBcontext($server, \fB$request\fB)\fR: throws \fIMail::SPF::EOptionRequired\fR" 4
.el .IP "\fBcontext($server, \f(CB$request\fB)\fR: throws \fIMail::SPF::EOptionRequired\fR" 4
.IX Item "context($server, $request): throws Mail::SPF::EOptionRequired"
Attaches the given \fIMail::SPF::Server\fR and \fIMail::SPF::Request\fR objects as
the context for the macro string.
.IP "\fBexpand\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.IX Item "expand: returns string; throws Mail::SPF::EMacroExpansionCtxRequired, Mail::SPF::EInvalidMacroString, Mail::SPF::Result::PermError"
.PD 0
.ie n .IP "\fBexpand($server, \fB$request\fB)\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.el .IP "\fBexpand($server, \f(CB$request\fB)\fR: returns \fIstring\fR; throws \fIMail::SPF::EMacroExpansionCtxRequired\fR, \fIMail::SPF::EInvalidMacroString\fR, \fIMail::SPF::Result::PermError\fR" 4
.IX Item "expand($server, $request): returns string; throws Mail::SPF::EMacroExpansionCtxRequired, Mail::SPF::EInvalidMacroString, Mail::SPF::Result::PermError"
.PD
Expands the text of the macro string using either the context specified through
an earlier call to the \f(CW\*(C`context()\*(C'\fR method, or the given context, and returns
the resulting string.  See \s-1RFC 4408, 8,\s0 for how macros are expanded.
.IP "\fBis_explanation\fR: returns \fIboolean\fR" 4
.IX Item "is_explanation: returns boolean"
Returns \fBtrue\fR if the macro string is an explanation string obtained via an
\&\f(CW\*(C`exp\*(C'\fR modifier.  See the description of the \*(L"new\*(R" constructor's
\&\f(CW\*(C`is_explanation\*(C'\fR option.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Returns the expanded text of the macro string if a context is attached to the
object.  Returns the unexpanded text otherwise.  You can simply use a
Mail::SPF::MacroString object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::MacroString object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR
method is used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF, Mail::SPF::Record, Mail::SPF::Server, Mail::SPF::Request
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech.3pm                          0100644 0001750 0001750 00000033054 12566242051 023701  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech 3"
.TH Mail::SPF::Mech 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech \- SPF record mechanism base class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech\fR represents a mechanism within an \s-1SPF\s0
record.  Mail::SPF::Mech cannot be instantiated directly.  Create an instance
of a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the mechanism.
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
A single-character \fIstring\fR denoting the qualifier of the mechanism.  Any of
the following may be specified: \fB'+'\fR (\f(CW\*(C`Pass\*(C'\fR), \fB'\-'\fR (\f(CW\*(C`Fail\*(C'\fR),
\&\fB'~'\fR (\f(CW\*(C`SoftFail\*(C'\fR), \fB'?'\fR (\f(CW\*(C`Neutral\*(C'\fR).  See \s-1RFC 4408, 4.6.2\s0 and 2.5, for
their meanings.  Defaults to \fB'+'\fR.
.IP "\fBname\fR" 4
.IX Item "name"
A \fIstring\fR denoting the name of the mechanism.  \fIRequired\fR if a generic
\&\fIMail::SPF::Mech\fR object (as opposed to a specific sub-class) is being
constructed.
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
A \fINetAddr::IP\fR object denoting an optional \s-1IP\s0 address network parameter of
the mechanism.  Can be either an IPv4 or an IPv6 address, with an optional
network prefix length.  IPv4\-mapped IPv6 addresses (e.g. '::ffff:192.168.0.1')
must \fInot\fR be specified directly, but as plain IPv4 addresses.
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
Either a plain \fIstring\fR or a \fIMail::SPF::MacroString\fR object denoting an
optional \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.PD 0
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
A \fIstring\fR denoting an optional IPv4 or IPv6 network prefix length for the
\&\f(CW\*(C`domain_spec\*(C'\fR of the mechanism.  Note that these options do not apply to the
\&\f(CW\*(C`ip_network\*(C'\fR option, which already includes an optional network prefix
length.
.RE
.RS 4
.Sp
Other options may be specified by sub-classes of Mail::SPF::Mech.
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR: returns \fIstring\fR" 4
.IX Item "default_qualifier: returns string"
Returns the default qualifier, i.e. \fB'+'\fR.
.IP "\fBdefault_ipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "default_ipv4_prefix_length: returns integer"
Returns the default IPv4 network prefix length, i.e. \fB32\fR.
.IP "\fBdefault_ipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "default_ipv6_prefix_length: returns integer"
Returns the default IPv6 network prefix length, i.e. \fB128\fR.
.IP "\fBqualifier_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "qualifier_pattern: returns Regexp"
Returns a regular expression that matches any legal mechanism qualifier, i.e. \fB'+'\fR,
\&\fB'\-'\fR, \fB'~'\fR, or \fB'?'\fR.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the name of the mechanism.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mech.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal mechanism name.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the mechanism.  Throws a
\&\fIMail::SPF::ENoUnparsedText\fR exception if the mechanism was created
synthetically instead of being parsed, and no text was provided.
.IP "\fBqualifier\fR: returns \fIstring\fR" 4
.IX Item "qualifier: returns string"
Returns the qualifier of the mechanism.  See the description of the \f(CW\*(C`new\*(C'\fR
constructor's \f(CW\*(C`qualifier\*(C'\fR option.
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
\&\fIAbstract\fR.  Returns the mechanism's parameters formatted as a string.
.Sp
A sub-class of Mail::SPF::Mech does not have to implement this method if it
supports no parameters.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Formats the mechanism's qualifier, name, and parameters as a string and returns
it.  (A qualifier that matches the default of \fB'+'\fR is omitted.)  You can
simply use a Mail::SPF::Mech object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\*(R"\s0.
.ie n .IP "\fBdomain($server, \fB$request\fB)\fR: returns \fIstring\fR" 4
.el .IP "\fBdomain($server, \f(CB$request\fB)\fR: returns \fIstring\fR" 4
.IX Item "domain($server, $request): returns string"
Returns the target domain of the mechanism.  Depending on whether the mechanism
does have an explicit \f(CW\*(C`domain_spec\*(C'\fR parameter, this is either the
macro-expanded \f(CW\*(C`domain_spec\*(C'\fR parameter, or the request's authority domain
(see \*(L"authority_domain\*(R" in Mail::SPF::Request) otherwise.  Both a
\&\fIMail::SPF::Server\fR and a \fIMail::SPF::Request\fR object are required for
resolving the target domain.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match($server, $request): returns boolean; throws Mail::SPF::Result::Error"
\&\fIAbstract\fR.  Checks whether the mechanism matches the parameters of the given
request (see Mail::SPF::Request) and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  In any case, takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mech.
.ie n .IP "\fBmatch_in_domain($server, \fB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch_in_domain($server, \f(CB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match_in_domain($server, $request): returns boolean; throws Mail::SPF::Result::Error"
.PD 0
.ie n .IP "\fBmatch_in_domain($server, \fB$request\fB, \f(BI$domain\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch_in_domain($server, \f(CB$request\fB, \f(CB$domain\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match_in_domain($server, $request, $domain): returns boolean; throws Mail::SPF::Result::Error"
.PD
Checks whether the mechanism's target domain name (that is, any of its \s-1DNS \s0\f(CW\*(C`A\*(C'\fR
or \f(CW\*(C`AAAA\*(C'\fR records) matches the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  If an explicit domain is specified, it is used instead of the
mechanism's target domain.  The mechanism's \s-1IP\s0 network prefix lengths are
respected when matching \s-1DNS\s0 address records against the request's \s-1IP\s0 address.
See \s-1RFC 4408, 5,\s0 for the exact algorithm used.
.Sp
This method exists mainly for the convenience of sub-classes of
Mail::SPF::Mech.
.ie n .IP "\fBexplain($server, \fB$request\fB, \f(BI$result\fB)\fR" 4
.el .IP "\fBexplain($server, \f(CB$request\fB, \f(CB$result\fB)\fR" 4
.IX Item "explain($server, $request, $result)"
Locally generates an explanation for why the mechanism caused the given result,
and stores it in the given request object's state.
.Sp
There is no need to override this method in sub-classes.  See the
\&\*(L"explanation_template\*(R" method.
.ie n .IP "\fBexplanation_template($server, \fB$request\fB, \f(BI$result\fB)\fR: returns \fIstring\fR" 4
.el .IP "\fBexplanation_template($server, \f(CB$request\fB, \f(CB$result\fB)\fR: returns \fIstring\fR" 4
.IX Item "explanation_template($server, $request, $result): returns string"
Returns a macro string template for a locally generated explanation for why the
mechanism caused the given result object.
.Sp
Sub-classes should either define an \f(CW\*(C`explanation_templates_by_result_code\*(C'\fR
hash constant with their own templates, or override this method.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Mech object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method is
used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Mech::All,
Mail::SPF::Mech::IP4,
Mail::SPF::Mech::IP6,
Mail::SPF::Mech::A,
Mail::SPF::Mech::MX,
Mail::SPF::Mech::PTR,
Mail::SPF::Mech::Exists,
Mail::SPF::Mech::Include
.PP
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech5.16.3pm                      0100644 0001750 0001750 00000032533 12566242062 024216  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SPF::Mech 3"
.TH Mail::SPF::Mech 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SPF::Mech \- SPF record mechanism base class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of class \fBMail::SPF::Mech\fR represents a mechanism within an \s-1SPF\s0
record.  Mail::SPF::Mech cannot be instantiated directly.  Create an instance
of a concrete sub-class instead.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructors are provided:
.IP "\fBnew(%options)\fR: returns \fIMail::SPF::Mech\fR" 4
.IX Item "new(%options): returns Mail::SPF::Mech"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record mechanism object.
.Sp
\&\f(CW%options\fR is a list of key/value pairs representing any of the following
options:
.RS 4
.IP "\fBtext\fR" 4
.IX Item "text"
A \fIstring\fR denoting the unparsed text of the mechanism.
.IP "\fBqualifier\fR" 4
.IX Item "qualifier"
A single-character \fIstring\fR denoting the qualifier of the mechanism.  Any of
the following may be specified: \fB'+'\fR (\f(CW\*(C`Pass\*(C'\fR), \fB'\-'\fR (\f(CW\*(C`Fail\*(C'\fR),
\&\fB'~'\fR (\f(CW\*(C`SoftFail\*(C'\fR), \fB'?'\fR (\f(CW\*(C`Neutral\*(C'\fR).  See \s-1RFC\s0 4408, 4.6.2 and 2.5, for
their meanings.  Defaults to \fB'+'\fR.
.IP "\fBname\fR" 4
.IX Item "name"
A \fIstring\fR denoting the name of the mechanism.  \fIRequired\fR if a generic
\&\fIMail::SPF::Mech\fR object (as opposed to a specific sub-class) is being
constructed.
.IP "\fBip_network\fR" 4
.IX Item "ip_network"
A \fINetAddr::IP\fR object denoting an optional \s-1IP\s0 address network parameter of
the mechanism.  Can be either an IPv4 or an IPv6 address, with an optional
network prefix length.  IPv4\-mapped IPv6 addresses (e.g. '::ffff:192.168.0.1')
must \fInot\fR be specified directly, but as plain IPv4 addresses.
.IP "\fBdomain_spec\fR" 4
.IX Item "domain_spec"
Either a plain \fIstring\fR or a \fIMail::SPF::MacroString\fR object denoting an
optional \f(CW\*(C`domain\-spec\*(C'\fR parameter of the mechanism.
.IP "\fBipv4_prefix_length\fR" 4
.IX Item "ipv4_prefix_length"
.PD 0
.IP "\fBipv6_prefix_length\fR" 4
.IX Item "ipv6_prefix_length"
.PD
A \fIstring\fR denoting an optional IPv4 or IPv6 network prefix length for the
\&\f(CW\*(C`domain_spec\*(C'\fR of the mechanism.  Note that these options do not apply to the
\&\f(CW\*(C`ip_network\*(C'\fR option, which already includes an optional network prefix
length.
.RE
.RS 4
.Sp
Other options may be specified by sub-classes of Mail::SPF::Mech.
.RE
.ie n .IP "\fBnew_from_string($text, \fB%options\fB)\fR: returns \fIMail::SPF::Mech\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.el .IP "\fBnew_from_string($text, \f(CB%options\fB)\fR: returns \fIMail::SPF::Mech\fR; throws \fIMail::SPF::ENothingToParse\fR, \fIMail::SPF::EInvalidMech\fR" 4
.IX Item "new_from_string($text, %options): returns Mail::SPF::Mech; throws Mail::SPF::ENothingToParse, Mail::SPF::EInvalidMech"
\&\fIAbstract\fR.  Creates a new \s-1SPF\s0 record mechanism object by parsing the string and
any options given.
.SS "Class methods"
.IX Subsection "Class methods"
The following class methods are provided:
.IP "\fBdefault_qualifier\fR: returns \fIstring\fR" 4
.IX Item "default_qualifier: returns string"
Returns the default qualifier, i.e. \fB'+'\fR.
.IP "\fBdefault_ipv4_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "default_ipv4_prefix_length: returns integer"
Returns the default IPv4 network prefix length, i.e. \fB32\fR.
.IP "\fBdefault_ipv6_prefix_length\fR: returns \fIinteger\fR" 4
.IX Item "default_ipv6_prefix_length: returns integer"
Returns the default IPv6 network prefix length, i.e. \fB128\fR.
.IP "\fBqualifier_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "qualifier_pattern: returns Regexp"
Returns a regular expression that matches any legal mechanism qualifier, i.e. \fB'+'\fR,
\&\fB'\-'\fR, \fB'~'\fR, or \fB'?'\fR.
.IP "\fBname\fR: returns \fIstring\fR" 4
.IX Item "name: returns string"
\&\fIAbstract\fR.  Returns the name of the mechanism.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mech.
.IP "\fBname_pattern\fR: returns \fIRegexp\fR" 4
.IX Item "name_pattern: returns Regexp"
Returns a regular expression that matches any legal mechanism name.
.SS "Instance methods"
.IX Subsection "Instance methods"
The following instance methods are provided:
.IP "\fBtext\fR: returns \fIstring\fR; throws \fIMail::SPF::ENoUnparsedText\fR" 4
.IX Item "text: returns string; throws Mail::SPF::ENoUnparsedText"
Returns the unparsed text of the mechanism.  Throws a
\&\fIMail::SPF::ENoUnparsedText\fR exception if the mechanism was created
synthetically instead of being parsed, and no text was provided.
.IP "\fBqualifier\fR: returns \fIstring\fR" 4
.IX Item "qualifier: returns string"
Returns the qualifier of the mechanism.  See the description of the \f(CW\*(C`new\*(C'\fR
constructor's \f(CW\*(C`qualifier\*(C'\fR option.
.IP "\fBparams\fR: returns \fIstring\fR" 4
.IX Item "params: returns string"
\&\fIAbstract\fR.  Returns the mechanism's parameters formatted as a string.
.Sp
A sub-class of Mail::SPF::Mech does not have to implement this method if it
supports no parameters.
.IP "\fBstringify\fR: returns \fIstring\fR" 4
.IX Item "stringify: returns string"
Formats the mechanism's qualifier, name, and parameters as a string and returns
it.  (A qualifier that matches the default of \fB'+'\fR is omitted.)  You can
simply use a Mail::SPF::Mech object as a string for the same effect, see
\&\*(L"\s-1OVERLOADING\s0\*(R".
.ie n .IP "\fBdomain($server, \fB$request\fB)\fR: returns \fIstring\fR" 4
.el .IP "\fBdomain($server, \f(CB$request\fB)\fR: returns \fIstring\fR" 4
.IX Item "domain($server, $request): returns string"
Returns the target domain of the mechanism.  Depending on whether the mechanism
does have an explicit \f(CW\*(C`domain_spec\*(C'\fR parameter, this is either the
macro-expanded \f(CW\*(C`domain_spec\*(C'\fR parameter, or the request's authority domain
(see \*(L"authority_domain\*(R" in Mail::SPF::Request) otherwise.  Both a
\&\fIMail::SPF::Server\fR and a \fIMail::SPF::Request\fR object are required for
resolving the target domain.
.ie n .IP "\fBmatch($server, \fB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch($server, \f(CB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match($server, $request): returns boolean; throws Mail::SPF::Result::Error"
\&\fIAbstract\fR.  Checks whether the mechanism matches the parameters of the given
request (see Mail::SPF::Request) and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  In any case, takes both a \fIMail::SPF::Server\fR and a
\&\fIMail::SPF::Request\fR object.
.Sp
This method is abstract and must be implemented by sub-classes of
Mail::SPF::Mech.
.ie n .IP "\fBmatch_in_domain($server, \fB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch_in_domain($server, \f(CB$request\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match_in_domain($server, $request): returns boolean; throws Mail::SPF::Result::Error"
.PD 0
.ie n .IP "\fBmatch_in_domain($server, \fB$request\fB, \f(BI$domain\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.el .IP "\fBmatch_in_domain($server, \f(CB$request\fB, \f(CB$domain\fB)\fR: returns \fIboolean\fR; throws \fIMail::SPF::Result::Error\fR" 4
.IX Item "match_in_domain($server, $request, $domain): returns boolean; throws Mail::SPF::Result::Error"
.PD
Checks whether the mechanism's target domain name (that is, any of its \s-1DNS\s0 \f(CW\*(C`A\*(C'\fR
or \f(CW\*(C`AAAA\*(C'\fR records) matches the given request's \s-1IP\s0 address (see
\&\*(L"ip_address\*(R" in Mail::SPF::Request), and returns \fBtrue\fR if it does, or \fBfalse\fR
otherwise.  If an explicit domain is specified, it is used instead of the
mechanism's target domain.  The mechanism's \s-1IP\s0 network prefix lengths are
respected when matching \s-1DNS\s0 address records against the request's \s-1IP\s0 address.
See \s-1RFC\s0 4408, 5, for the exact algorithm used.
.Sp
This method exists mainly for the convenience of sub-classes of
Mail::SPF::Mech.
.ie n .IP "\fBexplain($server, \fB$request\fB, \f(BI$result\fB)\fR" 4
.el .IP "\fBexplain($server, \f(CB$request\fB, \f(CB$result\fB)\fR" 4
.IX Item "explain($server, $request, $result)"
Locally generates an explanation for why the mechanism caused the given result,
and stores it in the given request object's state.
.Sp
There is no need to override this method in sub-classes.  See the
\&\*(L"explanation_template\*(R" method.
.ie n .IP "\fBexplanation_template($server, \fB$request\fB, \f(BI$result\fB)\fR: returns \fIstring\fR" 4
.el .IP "\fBexplanation_template($server, \f(CB$request\fB, \f(CB$result\fB)\fR: returns \fIstring\fR" 4
.IX Item "explanation_template($server, $request, $result): returns string"
Returns a macro string template for a locally generated explanation for why the
mechanism caused the given result object.
.Sp
Sub-classes should either define an \f(CW\*(C`explanation_templates_by_result_code\*(C'\fR
hash constant with their own templates, or override this method.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
If a Mail::SPF::Mech object is used as a \fIstring\fR, the \f(CW\*(C`stringify\*(C'\fR method is
used to convert the object into a string.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mail::SPF::Mech::All,
Mail::SPF::Mech::IP4,
Mail::SPF::Mech::IP6,
Mail::SPF::Mech::A,
Mail::SPF::Mech::MX,
Mail::SPF::Mech::PTR,
Mail::SPF::Mech::Exists,
Mail::SPF::Mech::Include
.PP
Mail::SPF, Mail::SPF::Record, Mail::SPF::Term
.PP
<http://tools.ietf.org/html/rfc4408>
.PP
For availability, support, and license information, see the \s-1README\s0 file
included with Mail::SPF.
.SH "AUTHORS"
.IX Header "AUTHORS"
Julian Mehnle <julian@mehnle.net>, Shevek <cpan@anarres.org>
                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Mail::SPF::Mech5.18.3pm                      0100644 0001750 0001750 00000033054 12566242051 024215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy