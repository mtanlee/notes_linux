hat is supported
 *    by Textension.  Used to determine if Paste item in Edit menu
 *    should be active or inactive. The types of data supported depends
 *    on what data types were specified in the TXNInitTextension
 *    options.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    Boolean: True if data type in Clipboard is supported.  False if
 *    not a supported data type.  If result is True the Paste item in
 *    the menu can be highlighted.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern Boolean 
TXNIsScrapPastable(void)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Selection                                                                                         */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNGetSelection()
 *  
 *  Summary:
 *    Get the absolute offsets of the current selection.  Embedded
 *    graphics, sound, etc. each count as one character.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    oStartOffset:
 *      Absolute beginning of the current selection.
 *    
 *    oEndOffset:
 *      End of current selection.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern void 
TXNGetSelection(
  TXNObject    iTXNObject,
  TXNOffset *  oStartOffset,
  TXNOffset *  oEndOffset)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNShowSelection()
 *  
 *  Summary:
 *    Scroll the current selection into view.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iShowEnd:
 *      If true the end of the selection is scrolled into view. If
 *      false the beginning of selection is scrolled into view.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern void 
TXNShowSelection(
  TXNObject   iTXNObject,
  Boolean     iShowEnd)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNShowOffset()
 *  
 *  Summary:
 *    Scroll the text at a specified offset into view.
 *  
 *  Discussion:
 *    TXNShowOffset can be used to reveal the text at any offset.
 *    TXNShowSelection, in contrast, can only reveal the current
 *    selection.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    inOffset:
 *      The offset which will be scrolled into view.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TXNShowOffset(
  TXNObject   iTXNObject,
  TXNOffset   inOffset)                                       AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;



/*
 *  TXNIsSelectionEmpty()
 *  
 *  Summary:
 *    Call to find out if the current selection is empty. Use this to
 *    determine if Paste, Cut, Copy, Clear should be highlighted in
 *    Edit menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Result:
 *    Boolean: True if current selection is empty (i.e. start offset ==
 *    end offset). False if selection is not empty.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern Boolean 
TXNIsSelectionEmpty(TXNObject iTXNObject)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNSetSelection()
 *  
 *  Summary:
 *    Set the current selection.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iStartOffset:
 *      New beginning.
 *    
 *    iEndOffset:
 *      New end.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSetSelection(
  TXNObject   iTXNObject,
  TXNOffset   iStartOffset,
  TXNOffset   iEndOffset)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Set/Get Type Attributes                                                                           */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNGetContinuousTypeAttributes()
 *  
 *  Summary:
 *    Test the current selection to see if type size, style, color
 *    and/or font are continuous. That is is the current selection made
 *    up of one font, one font size, one Style, and/or one color.  On
 *    return examine the flags to see if the attributes specified were
 *    continuous.  If an attribute is continuous then the dataValue
 *    field in the TXNTypeAttributes can be examined to get the
 *    continous value.  Remember that for color you pass a ptr to an
 *    RGBColor in attr[0].data.dataPtr.
 *  
 *  Discussion:
 *    If examining kTXNATSUIStyleContinuous bit, be sure to call
 *    ATSUDisposeStyle to dispose the style that is returned from MLTE.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    oContinuousFlags:
 *      Bits which can be examined to see if type size, style, color,
 *      and/or font are continuous. Example: if ( 
 *      TXNGetContinuousTypeAttributes( txnObject, &flags, 1, &attr )
 *      == noErr ) { if ( flags & kTXNFontContinuousMask ) ....check a
 *      font name
 *    
 *    iCount:
 *      Count of TXNTypeAttributes records in the ioTypeAttributes
 *      array.
 *    
 *    ioTypeAttributes:
 *      Array of TXNTypeAttributes that indicate the type attributes
 *      the caller is interested in. For example: 1. if you wanted to
 *      know if the current selection was continuous in terms of being
 *      all one same font size you could do something like this.
 *      TXNTypeAttributes       attr[1] = { kTXNQDFontSizeAttribute,
 *      sizeof(Fixed),{ 0 } } on return from the function if size is
 *      continuous (i.e. if the bit 3 of flags is set) then the third
 *      field (attr[0].data.dataValue) will contain the size of the
 *      font as a Fixed value. 2. if you wanted to know if the current
 *      selection was continuous in ATSUI style you could do something
 *      like this. TXNTypeAttributes       attr[1] = { kTXNATSUIStyle,
 *      kTXNATSUIStyleSize, { 0 } } on return from the function if
 *      ATSUI style is continuous, then the third field
 *      (attr[0].data.dataPtr) will contain the ATSUI style.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNGetContinuousTypeAttributes(
  TXNObject             iTXNObject,
  TXNContinuousFlags *  oContinuousFlags,
  ItemCount             iCount,
  TXNTypeAttributes     ioTypeAttributes[])     /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNSetTypeAttributes()
 *  
 *  Summary:
 *    Set the current ranges font information.  Values are passed in
 *    the attributes array. Values <= sizeof(UInt32) are passed by
 *    value. > sizeof(UInt32) are passed as a pointer. That is the
 *    TXNTypeAttributes' 3rd field is a union that servers as either a
 *    32-bit integer where values can be written or a 32-bit pointer a
 *    value.  Functional in NoUserIO mode. When you call
 *    TXNSetTypeAttributes, any attributes that you do not set retain
 *    their previous values.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iAttrCount:
 *      Count of type attributes in the TXNTypeAttributes array.
 *    
 *    iAttributes:
 *      Attributes that caller would like to set.
 *    
 *    iStartOffset:
 *      Start of the range where text attributes should be changed.
 *    
 *    iEndOffset:
 *      End of the range.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSetTypeAttributes(
  TXNObject                 iTXNObject,
  ItemCount                 iAttrCount,
  const TXNTypeAttributes   iAttributes[],
  TXNOffset                 iStartOffset,
  TXNOffset                 iEndOffset)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Set/Get Object Controls                                                                           */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNSetTXNObjectControls()
 *  
 *  Summary:
 *    Sets formatting and privileges attributes (such as justification,
 *    line direction, tab values, and read-only status) that apply to
 *    the entire text object.
 *  
 *  Discussion:
 *    On systems that use Apple Type Services for Unicode Imaging
 *    (ATSUI), the ATSUI line control attribute tags can be passed to
 *    this function in the iControlTag parameter. This is the case for
 *    all the ATSUI tags except kATSULineRotationTag. ATSUI tags are
 *    applied to the entire text object.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The text object that identifies the document for which you want
 *      to set formatting and privileges attributes.
 *    
 *    iClearAll:
 *      A Boolean value. If you set this to true, all formatting and
 *      privileges attributes are reset to their default value. That
 *      is, true clears existing tags and resets each to its default
 *      value.  This can be done even when the object is in NoUserIO
 *      mode.
 *    
 *    iControlCount:
 *      The number of items in the iControlTags array.
 *    
 *    iControlTags:
 *      An array of values that specifies kind of data that is passed
 *      in the iControlData parameter. See “Formatting and Privileges
 *      Settings” for a description of possible values. On systems that
 *      use Apple Type Services for Unicode Imaging (ATSUI), you can
 *      also pass ATSUI attribute tag constants. See the ATSUI
 *      documentation for a description of the ATSUI constants. Can be
 *      NULL if iClearAll is true.
 *    
 *    iControlData:
 *      An array of TXNControlData unions that contain the information
 *      your application wants to set. The value you supply to the
 *      iControlTags parameter specifies how the union of type
 *      TXNControlData is treated. You must make sure that the value
 *      you assign to the iControlData parameter is the appropriate
 *      type implied by the value you passed in the iControlTags
 *      parameter. Can be NULL if iClearAll is true.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSetTXNObjectControls(
  TXNObject              iTXNObject,
  Boolean                iClearAll,
  ItemCount              iControlCount,
  const TXNControlTag    iControlTags[],      /* can be NULL */
  const TXNControlData   iControlData[])      /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNGetTXNObjectControls()
 *  
 *  Summary:
 *    Gets the current formatting and privileges attributes (such as
 *    justification, line direction, tab values, and read-only status)
 *    for a text object.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The text object that identifies the document to be activated.
 *      If NULL then the default value for an MLTE object is returned.
 *    
 *    iControlCount:
 *      The number of items in the iControlTags array.
 *    
 *    iControlTags:
 *      An array of values that specify the kind of formatting
 *      information you want returned in the oControlData array. See
 *      “Formatting and Privileges Settings” for a description of
 *      possible values.
 *    
 *    oControlData:
 *      An array of TXNControlData unions. On return, the array
 *      contains the information that was requested through the
 *      iControlTags array. Your application must allocate the
 *      oControlData array.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNGetTXNObjectControls(
  TXNObject             iTXNObject,          /* can be NULL */
  ItemCount             iControlCount,
  const TXNControlTag   iControlTags[],
  TXNControlData        oControlData[])                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Other Settings                                                                                    */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNSetBackground()
 *  
 *  Summary:
 *    Set the type of background the TXNObject's text, etc. is drawn
 *    onto.  At this point the background can be a color.  Functional
 *    in NoUserIO mode.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iBackgroundInfo:
 *      Struct containing information that describes the background.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSetBackground(
  TXNObject              iTXNObject,
  const TXNBackground *  iBackgroundInfo)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNEchoMode()
 *  
 *  Summary:
 *    Put the TXNObject into echo mode. What that means is that all
 *    characters in the TXNObject have the character 'echoCharacter'
 *    substituted for the actual glyph when drawing occurs.
 *  
 *  Discussion:
 *    Note that the echoCharacter is typed as a UniChar, but this is
 *    done merely to facilitate passing any 2 byte character.  The
 *    encoding parameter actually determines the encoding used to
 *    locate a font and display a character.  Thus if you wanted to
 *    display the diamond found in the Shift-JIS encoding for MacOS you
 *    would pass in 0x86A6 for the character but an encoding that was
 *    built to represent the MacOS Japanese encoding.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iEchoCharacter:
 *      Character to use in substitution.
 *    
 *    iEncoding:
 *      Encoding from which character is drawn.
 *    
 *    iOn:
 *      True if turning EchoMode on.  False if turning it off.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNEchoMode(
  TXNObject      iTXNObject,
  UniChar        iEchoCharacter,
  TextEncoding   iEncoding,
  Boolean        iOn)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Retrieve Run Info                                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNCountRunsInRange()
 *  
 *  Summary:
 *    Given a range specified by the starting and ending offset return
 *    a count of the runs in that range.  Run in this case means
 *    changes in TextSyles or a graphic or sound.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iStartOffset:
 *      Start of range.
 *    
 *    iEndOffset:
 *      End of range.
 *    
 *    oRunCount:
 *      Count of runs in the range
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNCountRunsInRange(
  TXNObject    iTXNObject,
  TXNOffset    iStartOffset,
  TXNOffset    iEndOffset,
  ItemCount *  oRunCount)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  TXNGetIndexedRunInfoFromRange()
 *  
 *  Summary:
 *    Gets information about a run in a range of data.
 *  
 *  Discussion:
 *    You should first call the TXNCountRunsInRange function to get the
 *    count. The TXNTypeAttributes structure must specify the text
 *    attribute in which the application is interested. In other words,
 *    the tag field must be set. If you asked for the kTXNATSUIStyle
 *    info, you are now responsible for disposing the ATSUI style
 *    returned from the attribute array by calling ATSUDisposeStyle.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The text object for the current text area.
 *    
 *    iIndex:
 *      The value that corresponds to the run for which you want to get
 *      information. You call the TXNCountRunsInRange function to get
 *      the number of runs in a range. The iIndex parameter is
 *      zero-based, so its possible values are from 0 to the number of
 *      runs in a range minus 1.
 *    
 *    iStartOffset:
 *      The offset at which you want to start to obtain run information.
 *    
 *    iEndOffset:
 *      The offset at which you want run information to end.
 *    
 *    oRunStartOffset:
 *      On return, a pointer to a value that identifies the start of
 *      run relative to the beginning of the text, not the beginning of
 *      the range you specified in the iStartOffset parameter.
 *    
 *    oRunEndOffset:
 *      On return, a pointer to a value that identifies the end of the
 *      run relative to the beginning of the text, not the beginning of
 *      the range you specified in the iStartOffset parameter.
 *    
 *    oRunDataType:
 *      On return, a pointer to a value that identifies the type of
 *      data in the run. See “Supported Data Types” for a description
 *      of possible values.
 *    
 *    iTypeAttributeCount:
 *      The number of font attributes.
 *    
 *    ioTypeAttributes:
 *      A pointer to a structure of type TXNTypeAttributes. On input,
 *      you specify the attribute (such as size) in the tag field and
 *      the attribute size in the size field. You can pass NULL for the
 *      data field. On return, the data field contains the attribute
 *      data. The data field is a union that serves either as a 32-bit
 *      integer or a 32-bit pointer, depending on the size field.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNGetIndexedRunInfoFromRange(
  TXNObject            iTXNObject,
  ItemCount            iIndex,
  TXNOffset            iStartOffset,
  TXNOffset            iEndOffset,
  TXNOffset *          oRunStartOffset,           /* can be NULL */
  TXNOffset *          oRunEndOffset,             /* can be NULL */
  TXNDataType *        oRunDataType,              /* can be NULL */
  ItemCount            iTypeAttributeCount,
  TXNTypeAttributes *  ioTypeAttributes)          /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Get Data Size                                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNDataSize()
 *  
 *  Summary:
 *    Return the size in bytes of the characters in a given TXNObject.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Result:
 *    The bytes required to hold the characters.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern ByteCount 
TXNDataSize(TXNObject iTXNObject)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Read and Write APIs                                                                           */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/


/*
 *  TXNWriteRangeToCFURL()
 *  
 *  Summary:
 *    Write a range of a TXNObject to a CFURLRef.
 *  
 *  Discussion:
 *    Write a range of a text object to a file or a special file bundle
 *    (directory). It supports different document formats and encodings
 *    which can be specified in the data options dictionary. Clients
 *    can specify additional document attributes when data is written
 *    out using a file format that supports such attributes (ie. RTF
 *    and native MLTE file format). See DocumentAttribute key
 *    definitions for additional information on the attributes
 *    supported.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iStartOffset:
 *      The initial offset in iTXNObject to write out to iFileURL.
 *    
 *    iEndOffset:
 *      The last offset in iTXNObject to write out to iFileURL.
 *    
 *    iDataOptions:
 *      A CFDictionaryRef that specifies options for writing out the
 *      data. See Data Options key documentation for a list of the
 *      options supported. If this parameter is NULL, the data is
 *      written out using MLTE's native format.
 *    
 *    iDocumentAttributes:
 *      Specifies the document attributes to be embedded in the data
 *      stream. This param is only supported when writing out the data
 *      using one of the following formats: RTF and MLTE native format.
 *      Only the key / values defined in Document Attributes are
 *      written out. The content of the dictionary is ignored for any
 *      other format. If the dictionary is NULL, no attributes are
 *      added to the data stream.
 *    
 *    iFileURL:
 *      Should point to an existing file or directory whichever is
 *      correct for file type. On exit, iFileURL will contain a copy of
 *      the data in the given range for the iTXNObject with the format
 *      and encoding specified by iDataOptions.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNWriteRangeToCFURL(
  TXNObject         iTXNObject,
  TXNOffset         iStartOffset,
  TXNOffset         iEndOffset,
  CFDictionaryRef   iDataOptions,              /* can be NULL */
  CFDictionaryRef   iDocumentAttributes,       /* can be NULL */
  CFURLRef          iFileURL)                                 AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/*
 *  TXNReadFromCFURL()
 *  
 *  Summary:
 *    Read data from a CFURLRef into a TXNObject.
 *  
 *  Discussion:
 *    Read in data from a file or or special file bundle (directory)
 *    into a text object. Offset parameters are used to specify whether
 *    the new data is inserted, appended or replaces an existing data
 *    range in the text object. Clients can specify the document format
 *    and encoding of the data using the DataOptions dictionary. This
 *    functions also returns the document attributes present in the
 *    data stream. Document attributes are only supported for the rich
 *    text file formats supported by MLTE: RTF and MLTE native file
 *    format.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject. New data will
 *      be added to this object.
 *    
 *    iStartOffset:
 *      The initial offset in iTXNObject to place the data read in from
 *      iFileURL.
 *    
 *    iEndOffset:
 *      The last offset in iTXNObject to place the data read in from
 *      iFileURL.
 *    
 *    iDataOptions:
 *      A CFDictionaryRef that specifies options for reading in the
 *      data. See Data Options key documentation for a list of the
 *      options supported. If this parameter is NULL, the data is
 *      written out using MLTE's native format.
 *    
 *    iFileURL:
 *      A value of type CFURLRef. The data to be added to the
 *      iTXNObject.
 *    
 *    oDocumentAttributes:
 *      A value of type CFDictionaryRef. It contains the document
 *      attributes for the text object. On exit, this dictionary
 *      contains the document attributes present in the data stream, if
 *      the file format supports them; otherwise it will be NULL. The
 *      native MLTE file format and RTF support embedded document
 *      attributes. See the DocumentAttribute key documentation for a
 *      list of the attributes supported. If this parameter is NULL, no
 *      document attributes are written out. Sample code: If the caller
 *      passes a pointer to a dictionary ref, the API will return a ref
 *      to the dictionary of attributes if there is one (caller must
 *      release dictionary), otherwise the API will set the ref to NULL
 *      in all other cases. CFDictionaryRef oDocumentAttributes = NULL;
 *      status = TXNReadFromCFURL (...., &oDocumentAttributes); if
 *      (oDocumentAttributes != NULL) ::CFRelease(oDocumentAttributes);
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNReadFromCFURL(
  TXNObject          iTXNObject,
  TXNOffset          iStartOffset,
  TXNOffset          iEndOffset,
  CFDictionaryRef    iDataOptions,              /* can be NULL */
  CFURLRef           iFileURL,
  CFDictionaryRef *  oDocumentAttributes)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;




/*
 *  TXNCopyTypeIdentifiersForRange()
 *  
 *  Summary:
 *    Returns an array of univeral type identifiers (UTIs) that can be
 *    used to write out a range of a text object with no information
 *    loss.
 *  
 *  Discussion:
 *    Some file formats support limited embedding of data when writing
 *    out to disk, and use attachments instead, such as RTF. This API
 *    can be used to determine the document format to use with
 *    TXNWriteRangeToCFURL - i.e., whether to use RTF (Rich Text
 *    Format). Note that support for new document formats could be
 *    added in the future.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iStartOffset:
 *      The initial offset in iTXNObject for the range to check.
 *    
 *    iEndOffset:
 *      The last offset in iTXNObject for the range to check.
 *    
 *    oTypeIdentifiersForRange:
 *      A pointer to a CFArrayRef. On exit, the array will contain the
 *      list of universal type identifiers (UTI) that MLTE supports,
 *      and that can be used to write the object out to disk with no
 *      data loss. Each entry in the array is a CFStringRef.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNCopyTypeIdentifiersForRange(
  TXNObject     iTXNObject,
  TXNOffset     iStartOffset,
  TXNOffset     iEndOffset,
  CFArrayRef *  oTypeIdentifiersForRange)                     AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;





/*
 *  TXNGetData()
 *  
 *  Summary:
 *    Copy the data in the range specified by startOffset and endOffset.
 *  
 *  Discussion:
 *    This function should be used in conjunction with TXNNextDataRun. 
 *    The client would call TXNCountRunsInRange to the number of data
 *    runs in a given range.  The client can then walk the runs with
 *    the function TXNGetIndexedRunInfoFromRange. 
 *    TXNGetIndexedRunInfoFromRange lets you examine each runs type and
 *    text attributes. For each data run of interest (i.e. one whose
 *    data the caller wanted to look at) the client would call
 *    TXNGetData. The handle passed to TXNGetData should not be
 *    allocated. TXNGetData takes care of allocating the dataHandle as
 *    necessary.  However, the caller is responsible for disposing the
 *    handle.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iStartOffset:
 *      Absolute offset from which data copy should begin.
 *    
 *    iEndOffset:
 *      Absolute offset at which data copy should end.
 *    
 *    oDataHandle:
 *      If noErr a new handle containing the requested data. The caller
 *      is responsible for disposing the handle.  Note that the handle
 *      is a copy so it can be safely disposed at any time.
 *  
 *  Result:
 *    Memory errors or TXN_IllegalToCrossDataBoundaries if offsets
 *    specify a range that crosses a data type boundary.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNGetData(
  TXNObject   iTXNObject,
  TXNOffset   iStartOffset,
  TXNOffset   iEndOffset,
  Handle *    oDataHandle)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNGetDataEncoded()
 *  
 *  Summary:
 *    Copy the data in the range specified by startOffset and endOffset.
 *  
 *  Discussion:
 *    The handle passed to TXNGetDataEncoded should not be allocated.
 *    TXNGetData takes care of allocating the dataHandle as necessary. 
 *    However, the caller is responsible for disposing the handle.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iStartOffset:
 *      Absolute offset from which data copy should begin.
 *    
 *    iEndOffset:
 *      Absolute offset at which data copy should end.
 *    
 *    oDataHandle:
 *      If noErr a new handle containing the requested data.
 *    
 *    iEncoding:
 *      should be kTXNTextData or kTXNUnicodeTextData.
 *  
 *  Result:
 *    Memory errors or  TXN_IllegalToCrossDataBoundaries if offsets
 *    specify a range that crosses a data type boundary.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNGetDataEncoded(
  TXNObject     iTXNObject,
  TXNOffset     iStartOffset,
  TXNOffset     iEndOffset,
  Handle *      oDataHandle,
  TXNDataType   iEncoding)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  TXNSetData()
 *  
 *  Summary:
 *    Replaces a range of data (text, graphics, and so forth).
 *  
 *  Discussion:
 *    Functional in NoUserIO mode.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The text object that identifies the document in which you want
 *      to replace data.
 *    
 *    iDataType:
 *      The type of the replacement data. See “Supported Data Types”
 *      for a description of possible values.
 *    
 *    iDataPtr:
 *      A pointer to the data that will replace the data that is in the
 *      range specified by the iStartOffset and iEndOffset parameters. 
 *      Can be NULL if the start and end offsets are different.
 *    
 *    iDataSize:
 *      The size of the data to which iDataPtr points.
 *    
 *    iStartOffset:
 *      The beginning of the range of data to replace. You can use the
 *      TXNGetSelection function to get the absolute offsets of the
 *      current selection.
 *    
 *    iEndOffset:
 *      The end of the range to replace. You can use the
 *      TXNGetSelection function to get the absolute offsets of the
 *      current selection. If you want to insert text, the ending and
 *      starting offsets should be the same value.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSetData(
  TXNObject     iTXNObject,
  TXNDataType   iDataType,
  const void *  iDataPtr,           /* can be NULL */
  ByteCount     iDataSize,
  TXNOffset     iStartOffset,
  TXNOffset     iEndOffset)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;





/*
 *  TXNFlattenObjectToCFDataRef()
 *  
 *  Summary:
 *    Flattens a text object so it can be saved to disk or embedded
 *    with other data.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.  Retrieve
 *      flattened data from this text object.
 *    
 *    iTXNDataType:
 *      A value of type TXNDataType that specifies the format in which
 *      the data is written out.
 *    
 *    oDataRef:
 *      A pointer to a structure of type CFDataRef. On return the data
 *      will contain a flattened version of the iTXNObject in the
 *      format specified by iTXNDataType. Clients are responsible to
 *      retain the returned CFDataRef.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNFlattenObjectToCFDataRef(
  TXNObject     iTXNObject,
  TXNDataType   iTXNDataType,
  CFDataRef *   oDataRef)                                     AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;




/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Revert                                                                                            */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNRevert()
 *  
 *  Summary:
 *    Revert  to the last saved version of this document.  If the file
 *    was not previously saved the document is reverted to an empty
 *    document.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Result:
 *    A result code indicating success or failure. (such as File
 *    Manager errors)
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNRevert(TXNObject iTXNObject)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Printing                                                                                          */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNPageSetup()
 *  
 *  Summary:
 *    Display the Page Setup dialog of the current default printer and
 *    react to any changes (i.e. Reformat the text if the page layout
 *    changes.)
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Result:
 *    A result code indicating success or failure. ( such as Print
 *    Manager errors )
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNPageSetup(TXNObject iTXNObject)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNPrint()
 *  
 *  Summary:
 *    Print the document.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Result:
 *    A result code indicating success or failure. ( such as Print
 *    Manager errors )
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNPrint(TXNObject iTXNObject)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Search                                                                                            */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNFind()
 *  
 *  Summary:
 *    Find a piece of text or a graphics object.
 *  
 *  Discussion:
 *    The default matching behavior is pretty simple for Text a basic
 *    binary compare is done.  If the matchOptions say to ignore case
 *    the characters to be searched are duplicated and case
 *    neutralized. This naturally can fail due to lack of memory if
 *    there is a large amount of text.  It also slows things down.  If
 *    MatchOptions say find an entire word that once a match is found
 *    an effort is made to determine if the match is a word.  The
 *    default behavior is to test the character before and after the to
 *    see if it is White space.  If the kTXNUseEncodingWordRulesBit is
 *    set than the Script Manager's FindWord function is called to make
 *    this determination. If the caller is looking for a non-text type
 *    than each non-text type in the document is returned. If more
 *    elaborate ( a regular expression processor or whatever ) is what
 *    you want then that is what the FindProc is for.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iMatchTextDataPtr:
 *      Ptr to a MatchTextRecord which contains the text to match, the
 *      length of that text and the TextEncoding the text is encoded
 *      in.  This must be there if you are looking for Text, but can be
 *      NULL if you are looking for a graphics object.
 *    
 *    iDataType:
 *      The type of data to find.  This can be any of the types defined
 *      in TXNDataType enum (TEXT, PICT, moov, snd ).  However, if
 *      PICT, moov, or snd is passed then the default behavior is to
 *      match on any non-Text object.  If you really want to find a
 *      specific type you can provide a custom find callback or ignore
 *      matches which aren't the precise type you are interested in.
 *    
 *    iMatchOptions:
 *      Options on what to search for.
 *    
 *    iStartSearchOffset:
 *      The offset at which a search should begin. The constant
 *      kTXNStartOffset specifies the start of the objects data.
 *    
 *    iEndSearchOffset:
 *      The offset at which the search should end. The constant
 *      kTXNEndOffset specifies the end of the objects data.
 *    
 *    iFindProc:
 *      A custom callback.  If will be called to match things rather
 *      than the default matching behavior.
 *    
 *    iRefCon:
 *      This can be use for whatever the caller likes.  It is passed to
 *      the FindProc (if a FindProc is provided.
 *    
 *    oStartMatchOffset:
 *      Absolute offset to start of match.  set to 0xFFFFFFFF if not
 *      match.
 *    
 *    oEndMatchOffset:
 *      Absolute offset to end of match.  Set to 0xFFFFFFFF is no match.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNFind(
  TXNObject                   iTXNObject,
  const TXNMatchTextRecord *  iMatchTextDataPtr,        /* can be NULL */
  TXNDataType                 iDataType,
  TXNMatchOptions             iMatchOptions,
  TXNOffset                   iStartSearchOffset,
  TXNOffset                   iEndSearchOffset,
  TXNFindUPP                  iFindProc,
  SRefCon                     iRefCon,
  TXNOffset *                 oStartMatchOffset,
  TXNOffset *                 oEndMatchOffset)                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Static Text Box                                                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNDrawUnicodeTextBox()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIThemeDrawTextBox, CoreText (CTLineDraw,..) or Cocoa
 *    (NSStringDrawing,..)
 *  
 *  Summary:
 *    Draws a Unicode string in the specified rectangle.
 *  
 *  Discussion:
 *    Client is supposed to do an EraseRect if needed. The drawing will
 *    be clipped to the rect unless the client specifies a rotation.
 *    Use kTXNUseVerticalTextMask to display text vertically (no need
 *    to use the kTXNRotateTextMask flag in this case).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iText:
 *      Ptr to a Unicode string (UTF16 chars).
 *    
 *    iLen:
 *      Number of UniChars in iText (this is not the size of iText).
 *    
 *    ioBox:
 *      On input the text box where the text will be displayed. On
 *      return will be updated to reflect the minimum bounding Rect
 *      that will enclose the text (unless kTXNDontUpdateBoxRectMask is
 *      used).
 *    
 *    iStyle:
 *      Style to use to display the text.
 *    
 *    iOptions:
 *      Can be used to specify non-default behavior.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.6
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   in Textension 1.1 and later
 */
extern OSStatus 
TXNDrawUnicodeTextBox(
  const UniChar                  iText[],
  UniCharCount                   iLen,
  Rect *                         ioBox,
  ATSUStyle                      iStyle,         /* can be NULL */
  const TXNTextBoxOptionsData *  iOptions)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6;



/*
 *  TXNDrawCFStringTextBox()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIThemeDrawTextBox, CoreText (CTLineDraw,..) or Cocoa
 *    (NSStringDrawing,..)
 *  
 *  Summary:
 *    Draws a CFString in the specified rectangle.
 *  
 *  Discussion:
 *    Client is supposed to do an EraseRect if needed. The drawing will
 *    be clipped to the rect unless the client specifies a rotation.
 *    Use kTXNUseVerticalTextMask to display text vertically (no need
 *    to use the kTXNRotateTextMask flag in this case).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iText:
 *      A CFStringRef (see CFBase.h and CFString.h).
 *    
 *    ioBox:
 *      On input the text box where the text will be displayed. On
 *      return will be updated to reflect the minimum bounding Rect
 *      that will enclose the text (unless kTXNDontUpdateBoxRectMask is
 *      used).
 *    
 *    iStyle:
 *      Style to use to display the text.
 *    
 *    iOptions:
 *      Can be used to specify non-default behavior.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.6
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNDrawCFStringTextBox(
  CFStringRef                    iText,
  Rect *                         ioBox,
  ATSUStyle                      iStyle,         /* can be NULL */
  const TXNTextBoxOptionsData *  iOptions)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_6;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Get Line Info                                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNGetLineCount()
 *  
 *  Summary:
 *    Get the total number of lines in the TXNObject.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    oLineTotal:
 *      On return the total number of lines in the object.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   in Textension 1.1 and later
 */
extern OSStatus 
TXNGetLineCount(
  TXNObject    iTXNObject,
  ItemCount *  oLineTotal)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  TXNGetLineMetrics()
 *  
 *  Summary:
 *    Get the metrics for the specified line.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iLineNumber:
 *      The line we want the metrics for (0 based).
 *    
 *    oLineWidth:
 *      On return the width of the line (in Fixed format).
 *    
 *    oLineHeight:
 *      On return the height (ascent + descent) of the line (in Fixed
 *      format).
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   in Textension 1.1 and later
 */
extern OSStatus 
TXNGetLineMetrics(
  TXNObject       iTXNObject,
  unsigned long   iLineNumber,
  Fixed *         oLineWidth,
  Fixed *         oLineHeight)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Count Changes                                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNGetChangeCount()
 *  
 *  Summary:
 *    Retrieve number of times document has been changed.
 *  
 *  Discussion:
 *    That is for every committed command (keydown, cut, copy) the
 *    value returned is count of those. This is useful for deciding if 
 *    the Save item in the File menu should be active.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Result:
 *    ItemCount: count of changes.  This is total changes since
 *    document  was created or last saved.  Not count since this
 *    routine was last called or anything like that.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern ItemCount 
TXNGetChangeCount(TXNObject iTXNObject)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  TXNGetCountForActionType()
 *  
 *  Summary:
 *    Retrieves the number of times a given kind of action has
 *    occurred. There are three MLTE defined counts:
 *    kTXNActionCountOfTextChanges, kTXNActionCountOfStyleChanges and
 *    kTXNActionCountOfAllChanges. In addition, this API can retrieve
 *    the number of times a custom action has occurred. See
 *    TXNBeginActionGroup for how to define a custom action group.
 *  
 *  Discussion:
 *    Call TXNClearCountForActionType to reset the counters.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iActionTypeName:
 *      Specifies the kind of action changes to be included when
 *      retrieving the count. The value can be
 *      kTXNActionCountOfTextChanges, kTXNActionCountOfStyleChanges,
 *      kTXNActionCountforAllChanges, or a string passed to
 *      TXNBeginActionGroup
 *    
 *    oCount:
 *      The number of times the iActionGroupName action has occurred.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNGetCountForActionType(
  TXNObject     iTXNObject,
  CFStringRef   iActionTypeName,
  ItemCount *   oCount)                                       AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  TXNClearCountForActionType()
 *  
 *  Summary:
 *    Reset the counter(s) for the specified kind of action(s) to zero.
 *  
 *  Discussion:
 *    Use kTXNActionCountOfAllChanges to reset all counters.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iActionTypeName:
 *      Specifies the kind of action changes for which the counter
 *      should be set to zero. The value can be
 *      kTXNActionCountOfTextChanges, kTXNActionCountOfStyleChanges,
 *      kTXNActionCountforAllChanges or any string used to form an
 *      action group with TXNBeginActionGroup.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNClearCountForActionType(
  TXNObject     iTXNObject,
  CFStringRef   iActionTypeName)                              AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Set/Get Object Bounds                                                                             */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNSetHIRectBounds()
 *  
 *  Summary:
 *    Sets the text object's view, the destination rectangles or both.
 *  
 *  Discussion:
 *    Either of the input rectangle can be NULL. HIRect provides an
 *    uniform interface to the HIView coordinate system.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.  The bounds for
 *      this text object will be set.
 *    
 *    iViewRect:
 *      A pointer to a HIRect data structure that contains the new
 *      coordinates for the view rectangle. Pass NULL if you don’t want
 *      to change the view rectangle.
 *    
 *    iDestinationRect:
 *      A pointer to a HIRect data structure that contains the new
 *      coordinates for the destination rectangle. Pass NULL if you
 *      don’t want to change the destination rectangle.
 *    
 *    iUpdate:
 *      Pass true if you want the location of the text and scrollbars
 *      to be recalculated and redrawn, otherwise pass false.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TXNSetHIRectBounds(
  TXNObject       iTXNObject,
  const HIRect *  iViewRect,
  const HIRect *  iDestinationRect,
  Boolean         iUpdate)                                    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;


/*
 *  TXNGetHIRect()
 *  
 *  Summary:
 *    Gets one of the text object's bounds based on the specified
 *    TXNRectKey
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject. The specified
 *      bounds for this text object will be returned.
 *    
 *    iTXNRectKey:
 *      The value for the type of rectangle you want the function to
 *      return.
 *    
 *    oRectangle:
 *      On return, a pointer to the HIRect data structure that contains
 *      the coordinates for the requested rectangle. If a rect is not
 *      defined, a pointer to an empty rect will be returned. Note that
 *      only scrollbar rectangle may be undefined for the text object.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNGetHIRect(
  TXNObject    iTXNObject,
  TXNRectKey   iTXNRectKey,
  HIRect *     oRectangle)                                    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;




/*
 *  TXNResizeFrame()
 *  
 *  Summary:
 *    Changes the frame's size to match the new width and height.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iWidth:
 *      New width in pixels.
 *    
 *    iHeight:
 *      New height in pixels.
 *    
 *    iTXNFrameID:
 *      Deprecated. Pass 0.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern void 
TXNResizeFrame(
  TXNObject    iTXNObject,
  UInt32       iWidth,
  UInt32       iHeight,
  TXNFrameID   iTXNFrameID)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNSetFrameBounds()
 *  
 *  Summary:
 *    Changes the frame's bounds to match the Rect.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iTop:
 *      Top of the bounds.
 *    
 *    iLeft:
 *      Left of the bounds.
 *    
 *    iBottom:
 *      Bottom of the bounds.
 *    
 *    iRight:
 *      Right of the bounds.
 *    
 *    iTXNFrameID:
 *      Deprecated. Pass 0.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern void 
TXNSetFrameBounds(
  TXNObject    iTXNObject,
  SInt32       iTop,
  SInt32       iLeft,
  SInt32       iBottom,
  SInt32       iRight,
  TXNFrameID   iTXNFrameID)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNGetViewRect()
 *  
 *  Summary:
 *    Get the rectangle describing the current view into the document.
 *    The coordinates of this rectangle will be local to the the window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    oViewRect:
 *      The requested view rectangle.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern void 
TXNGetViewRect(
  TXNObject   iTXNObject,
  Rect *      oViewRect)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;






/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Layout Calculation                                                                                */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNRecalcTextLayout()
 *  
 *  Summary:
 *    Recalculates the text layout based on the new View and
 *    Destination rectangles.
 *  
 *  Discussion:
 *    Call this if you called TXNSetRectBounds with the iUpdate
 *    parameter set to false. It will also recalcuate where the
 *    scrollbars, if any, should be placed. Finally an update event
 *    will be generated so that the TXNObject is redrawn.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TXNRecalcTextLayout(TXNObject iTXNObject)                     AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Scrolling                                                                                         */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNScroll()
 *  
 *  Discussion:
 *    TXNScroll scrolls the text within a view rectangle of the
 *    specified object by the designated number of units.  For example,
 *    you might want to scroll the text in an object in response to
 *    user input in a control other than the standard scrollbars that
 *    MLTE supplies.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iVerticalScrollUnit:
 *      Specifies what units the values in ioVerticalDelta are in.  If
 *      iVerticalScrollUnit is equal to kTXNScrollUnitsInPixels the
 *      value is treated as pixels.  If the value is
 *      kTXNScrollUnitsInLines the value is treated as a count of
 *      lines. Note that using this value is the slowest because each
 *      line must be measured before it scrolls.  Finally if
 *      kTXNScrollUnitsInViewRects the value is treated as the height
 *      of the current viewRect.
 *    
 *    iHorizontalScrollUnit:
 *      Specifies what units the values in iDh are in.  If
 *      iHorizontalScrollUnit is equal to kTXNScrollUnitsInPixels the
 *      value is treated as pixels.  If the value is
 *      kTXNScrollUnitsInLines the value is treated as a count of
 *      lines. Note that using this value for horizontal scrolling
 *      means that 16 pixels will be used to represent a line.  Finally
 *      if kTXNScrollUnitsInViewRects the value is treated as the width
 *      of the current viewRect.
 *    
 *    ioVerticalDelta:
 *      The vertical amount to scroll.  The values in ioVerticalDelta
 *      can be treated as pixels, lines or viewrects.  See the
 *      discussion of the TXNScrollUnit parameters for more information
 *      for this.  On return this will contain the number of pixels
 *      actually scrolled in the vertical direction. A positive value
 *      moves the text down.
 *    
 *    ioHorizontalDelta:
 *      The horizontal amount to scroll. The values in
 *      ioHorizontalDelta can specify a scroll amount that is pixels,
 *      lines or view rects.  Set TXNScrollUnit discussion for more
 *      information. On return this will contain the number of pixels
 *      actually scrolled in the horizontal direction. A positive value
 *      moves the text to the right.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   in Textension not yet available
 */
extern OSStatus 
TXNScroll(
  TXNObject       iTXNObject,
  TXNScrollUnit   iVerticalScrollUnit,
  TXNScrollUnit   iHorizontalScrollUnit,
  long *          ioVerticalDelta,
  long *          ioHorizontalDelta)                          AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;




/*
 *  TXNRegisterScrollInfoProc()
 *  
 *  Discussion:
 *    If your application is drawing and handling its own scrolling
 *    widgets use this function to register a TXNScrollInfoUPP.  If you
 *    register a TXNScrollInfoUPP it will be called every time MLTE
 *    would normally update the values and maximum values of an MLTE
 *    scrollbar. For example when the user types the return key to add
 *    a new line at the end of their text MLTE will calculate a new
 *    maximum value.  If you have registered a TXNScrollInfoUPP it will
 *    be called with this nex maximum value. To turn off the callbacks
 *    call TXNRegisterScrollInfoProc with a value of NULL for the
 *    iTXNScrollInfoUPP.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iTXNScrollInfoUPP:
 *      A universal procedure pointer.
 *    
 *    iRefCon:
 *      A refcon that is passed to the callback.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   in Textension not yet available
 */
extern void 
TXNRegisterScrollInfoProc(
  TXNObject          iTXNObject,
  TXNScrollInfoUPP   iTXNScrollInfoUPP,
  SRefCon            iRefCon)                                 AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;




/*
 *  TXNSetScrollbarState()
 *  
 *  Summary:
 *    Sets the state of the scrollbars
 *  
 *  Discussion:
 *    This replaces TXNActivate, which was confusing to many
 *    developers, since it only activates/inactivates the scrollbar. 
 *    This is useful for activating scrollbar(s) even when the object
 *    does not have focus.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iActiveState:
 *      Boolean: if true, scrollbars will be active even if the object
 *      does not have the keyboard focus.  If false, scrollbars are
 *      synched with active state
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNSetScrollbarState(
  TXNObject           iTXNObject,
  TXNScrollBarState   iActiveState)                           AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;






/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Offset/Point Conversion                                                                           */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNHIPointToOffset()
 *  
 *  Summary:
 *    Gets the coordinates of the point that corresponds to a specified
 *    offset in a text object.
 *  
 *  Discussion:
 *    The coordinates of the point are in the coordinate system of the
 *    window or view owning the text object.  Note that the owner of
 *    the a text object is a view only in the case when the object is
 *    in a HITextView.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject. The text object
 *      for which you want to obtain an offset value.
 *    
 *    iHIPoint:
 *      A pointer to an HIPoint.
 *    
 *    oOffset:
 *      On return, a pointer to the offset that corresponds to the
 *      value of the iHIPoint parameter.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNHIPointToOffset(
  TXNObject        iTXNObject,
  const HIPoint *  iHIPoint,
  TXNOffset *      oOffset)                                   AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;



/*
 *  TXNOffsetToHIPoint()
 *  
 *  Summary:
 *    Gets the coordinates of the point that corresponds to a specified
 *    offset in a text object.
 *  
 *  Discussion:
 *    The coordinates of the point are in the coordinate system of the
 *    window or view owning the text object.  Note that the owner of
 *    the a text object is a view only in the case when the object is
 *    in a HITextView.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject. The text object
 *      for which you want to obtain the coordinates of a point.
 *    
 *    iOffset:
 *      A text offset value.
 *    
 *    oHIPoint:
 *      On return, a pointer to the point that corresponds to the value
 *      of the iOffset parameter.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNOffsetToHIPoint(
  TXNObject   iTXNObject,
  TXNOffset   iOffset,
  HIPoint *   oHIPoint)                                       AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Drag and Drop                                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNDragTracker()
 *  
 *  Summary:
 *    If you ask that Drag handling procs not be installed.  Call this
 *    when your drag tracker is called and you want Textension to take
 *    over.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNNewObject.
 *    
 *    iTXNFrameID:
 *      Deprecated. Pass 0.
 *    
 *    iMessage:
 *      Drag message obtained from Drag Manager.
 *    
 *    iWindow:
 *      WindowRef obtained from Drag Manager.
 *    
 *    iDragReference:
 *      DragReference obtained from Drag Manager.
 *    
 *    iDifferentObjectSameWindow:
 *      Pass true if the drag is still in the same window that it
 *      started in. False if the drag has moved into a different window.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSErr 
TXNDragTracker(
  TXNObject             iTXNObject,
  TXNFrameID            iTXNFrameID,
  DragTrackingMessage   iMessage,
  WindowRef             iWindow,
  DragReference         iDragReference,
  Boolean               iDifferentObjectSameWindow)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  TXNDragReceiver()
 *  
 *  Summary:
 *    If you ask that Drag handling procs not be installed.  Call this
 *    when your drag receiver is called and you want Textension to take
 *    over.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNNewObject.
 *    
 *    iTXNFrameID:
 *      Deprecated. Pass 0.
 *    
 *    iWindow:
 *      WindowRef obtained from Drag Manager.
 *    
 *    iDragReference:
 *      DragReference obtained from Drag Manager.
 *    
 *    iDifferentObjectSameWindow:
 *      Pass true if the drag is still in the same window that it
 *      started in. False if the drag has moved into a different window.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSErr 
TXNDragReceiver(
  TXNObject       iTXNObject,
  TXNFrameID      iTXNFrameID,
  WindowRef       iWindow,
  DragReference   iDragReference,
  Boolean         iDifferentObjectSameWindow)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Command Events and Spell Checking                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

#endif  /* !__LP64__ */


/*
 *  TXNCommandEventSupportOptions
 *  
 *  Discussion:
 *    Use these constants to turn support for specific HICommands in a
 *    given MLTE object.
 */
typedef OptionBits TXNCommandEventSupportOptions;
enum {

  /*
   * Setting this bit enables processing for these HICommands:
   * kHICommandUndo, kHICommandRedo, kHICommandCut, kHICommandCopy,
   * kHICommandPaste, kHICommandClear, kHICommandSelectAll.
   */
  kTXNSupportEditCommandProcessing = 1 << 0,

  /*
   * Setting this bit turns support on for updating the the menu item
   * associated with the above edit commands. What that means is:
   * 
   * 
   * For Undo the undo item will be enabled if there are any undoable
   * actions in MLTE's command stack.  Additionally, if you have
   * installed an action key mapper proc that will be called to get the
   * appropriate string for the undo item. 
   * 
   * For Redo the Redo item is enabled if there are any redoable
   * actions and the action key mapper callback will be called if it is
   * installed. 
   * 
   * For Cut and Clear the item is enabled if a the current selection
   * is not empty.  If the selection is empty this is disabled.
   * 
   * 
   * For Paste the item is enabled if the clipboard is not empty.  It
   * is disabled if the clipboard is empty or contains data that MLTE
   * does not understand. 
   * <BR> For Select All the item is always enabled.
   */
  kTXNSupportEditCommandUpdating = 1 << 1,

  /*
   * Turns on support for spell checking.  The spell checking commands
   * supported are kHICommandShowSpellingPanel,
   * kHICommandCheckSpelling, kHICommandChangeSpelling,
   * kHICommandCheckSpellingAsYouType, kHICommandIgnoreSpelling, and
   * kHICommandLearnWord.
   */
  kTXNSupportSpellCheckCommandProcessing = 1 << 2,

  /*
   * Turns on support for updating the menu item associated with a
   * given spell checking command. 
   * 
   * Show Spelling: This item is always enabled. 
   * 
   * Check Spelling: This item is always enabled. 
   * 
   * Change Spelling:  Typically this is not included in a spelling
   * menu.  If it is included it is enabled if the current selection is
   * a misspelled word.  It is disabled if the current selection is
   * empty or is not a misspelled word. 
   * 
   * Check Spelling as You Type:  This item is always enabled.  It is
   * checked if this feature has been enabled.  By default when you
   * turn on spell checking this is enabled. If this feature has been
   * disabled the item is unchecked. 
   * 
   * Ignore Spelling.  This is a command that usually does not have a
   * corresponding menu item.  If a menu does have this item it is
   * disabled if the current selection is empty or is not a misspelled
   * word.  It is enabled if the current selection is a misspelled
   * word. 
   * 
   * Learn Spelling.  Another command that typically does not have a
   * corresponding menu item.  It behaves exactly like the Ignore
   * spelling command.
   */
  kTXNSupportSpellCheckCommandUpdating = 1 << 3,

  /*
   * Setting this bit to turn on Carbon Font Panel support. Once
   * support is turned on, MLTE handles the following Carbon Events
   * defined in FontPanel.h: • kHICommandShowHideFontPanel and
   * kEventFontPanelClosed to show and hide the Carbon font panel •
   * kEventFontSelection event to update the document after you select
   * a new font, size, style, color, or any features setting from the
   * Typography Panel.
   */
  kTXNSupportFontCommandProcessing = 1 << 4,

  /*
   * Setting this bit to turn on support for updating the selection in
   * Carbon Font Panel when the current selection in MLTE document is
   * changed. When you set this bit, kTXNSupportFontCommandProcessing
   * has to be set also, which means that you only can get this support
   * if Carbon Font Panel support is on.
   */
  kTXNSupportFontCommandUpdating = 1 << 5
};

#if !__LP64__
/*
 *  TXNSetCommandEventSupport()
 *  
 *  Summary:
 *    Turn support for a variety of HICommands on or off in MLTE. See
 *    the documentation for the TXNCommandEventSupportOptions constants
 *    for the set of commands that are supported.
 *  
 *  Discussion:
 *    This function enables support for a variety of commands.  It is
 *    important to know that the handlers are installed immediatedly
 *    when an MLTE object is associated with an HIObject that can serve
 *    as an event target ( via a call to TXNAttachObjectToWindow or
 *    TXNSetEventTarget ). However when the handlers are installed they
 *    are not enabled.  Calling TXNSetCommandEventSupport enables the
 *    commands. Using this approach means that an application can
 *    install handlers on top of these and be sure that enabling or
 *    disabling the MLTE handlers will not change the order of the
 *    handler chain.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The TXNObject.
 *    
 *    iOptions:
 *      Set this to enable/disable command support for selected Edit
 *      commands (kHICommandUndo, kHICommandRedo, kHICommandCut,
 *      kHICommandCopy, kHICommandPaste, kHICommandClear,
 *      kHICommandSelectAll) and/or support for spell checking commands.
 *  
 *  Result:
 *    An OSStatus code.  noErr if the operation was successful.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNSetCommandEventSupport(
  TXNObject                       iTXNObject,
  TXNCommandEventSupportOptions   iOptions)                   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  TXNGetCommandEventSupport()
 *  
 *  Summary:
 *    Returns the command event support that is currently set for an
 *    MLTE object.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The TXNObject.
 *    
 *    oOptions:
 *      A pointer to a TXNCommandEventSupportOptions. Contains the
 *      option settings or return.
 *  
 *  Result:
 *    An OSStatus code.  noErr if the operation was successful.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNGetCommandEventSupport(
  TXNObject                        iTXNObject,
  TXNCommandEventSupportOptions *  oOptions)                  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  TXNSetSpellCheckAsYouType()
 *  
 *  Summary:
 *    Call to turn on spell check as you type.  If spell checking as
 *    not been enabled via a call to TXNSetCommandEventSupport than an
 *    error is returned.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The TXNObject.
 *    
 *    iActivate:
 *      Turns "Spell Check as You Type" on if true.  Turns it off if
 *      false.
 *  
 *  Result:
 *    An OSStatus code.  noErr if the operation was successful.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNSetSpellCheckAsYouType(
  TXNObject   iTXNObject,
  Boolean     iActivate)                                      AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  TXNGetSpellCheckAsYouType()
 *  
 *  Summary:
 *    Call this function to determine if "Spell Check as You Type" is
 *    turned on or off.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The TXNObject.
 *  
 *  Result:
 *    A Boolean.  The value is true if Spell Check As You Type is on
 *    and false if not.  Additionally if Spell Checking is not enabled
 *    for the TXNObject then the result of this function will be false.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
TXNGetSpellCheckAsYouType(TXNObject iTXNObject)               AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;




/*
    Functions for controlling the current event target object.
*/
/*
 *  TXNSetEventTarget()
 *  
 *  Summary:
 *    Specifies a Carbon Event target for MLTE Carbon Event Handlers.
 *  
 *  Discussion:
 *    Call this function when you want to override or set the
 *    TXNObject's Carbon Event Target.  The default target for
 *    TXNObjects that are not contained in an HITextView is the
 *    TXNObject's window.  Note that if the TXNObject already has a
 *    default target when this function is called the handlers will be
 *    removed from the old target before install the new handlers that
 *    are listed below. 
 *    
 *    When this function returns handlers for the following Carbon
 *    Events are installed and are active: 
 *    
 *    For kEventClassTextInput: 
 *     kEventTextInputUpdateActiveInputArea 
 *     kEventTextInputUnicodeForKeyEvent 
 *     kEventTextInputUnicodeText 
 *    kEventTextInputOffsetToPos 
 *    kEventTextInputPosToOffset 
 *    kEventTextInputGetSelectedText 
 *    
 *    For kEventClassTSMDocumentAccess: 
 *     kEventTSMDocumentAccessGetLength 
 *     kEventTSMDocumentAccessGetSelectedRange 
 *     kEventTSMDocumentAccessGetCharactersPtr 
 *     kEventTSMDocumentAccessGetCharactersPtrForLargestBuffer 
 *     kEventTSMDocumentAccessGetCharacters 
 *     kEventTSMDocumentAccessGetFont 
 *     kEventTSMDocumentAccessGetGlyphInfo 
 *     kEventTSMDocumentAccessGetFirstRectForRange 
 *    
 *    For kEventClassFont: 
 *    kEventFontPanelClosed 
 *    kEventFontSelection 
 *    
 *    Additionally these handlers for kEventClassCommand are installed,
 *    but are inactive by default. 
 *    kEventProcessCommand 
 *    kEventCommandUpdateStatus 
 *    
 *    The kEventClassCommand handlers support the following commands:
 *    
 *    kHICommandUndo 
 *    kHICommandRedo 
 *    kHICommandSelectAll 
 *    kHICommandCut 
 *    kHICommandCopy 
 *    kHICommandPaste 
 *    kHICommandClear 
 *    kHICommandShowSpellingPanel 
 *    kHICommandCheckSpelling 
 *    kHICommandChangeSpelling 
 *    kHICommandCheckSpellingAsYouType 
 *    kHICommandIgnoreSpelling 
 *    kHICommandLearnWord 
 *    
 *    Activate command support by calling TXNSetCommandEventSupport
 *    with the correct options.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The TXNObject.
 *    
 *    iEventTarget:
 *      An HIObjectRef.  The HIObject will become the event target for
 *      all of the TXNObject's Carbon Event handlers.
 *  
 *  Result:
 *    An OSStatus code.  noErr if the operation was successful.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNSetEventTarget(
  TXNObject     iTXNObject,
  HIObjectRef   iEventTarget)       /* can be NULL */         AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/*
 *  TXNGetEventTarget()
 *  
 *  Summary:
 *    Requests a TXNObject's current event target.
 *  
 *  Discussion:
 *    This function is used to obtain the HIObjectRef which is the
 *    TXNObject's carbon event target. Callers can use this function to
 *    obtain the target and subsequently install their own handlers.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The TXNObject.
 *    
 *    oEventTarget:
 *      An HIObjectRef pointer.  The current Carbon Event target.
 *  
 *  Result:
 *    An OSStatus code.  noErr if the operation was successful.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNGetEventTarget(
  TXNObject      iTXNObject,
  HIObjectRef *  oEventTarget)                                AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/*
 *  TXNSetContextualMenuSetup()
 *  
 *  Summary:
 *    Provides a callback function that is called before MLTE displays
 *    its contextual menu.
 *  
 *  Discussion:
 *    The menuSetupProc is called immediately before MLTE displays its
 *    contextual menu.  The menu that is passed to the callback will
 *    only contain MLTE specific items.  The client items and handlers
 *    should be installed each time the callback is called.  When the
 *    callback is called MLTE will have selected the word that the user
 *    option-clicked on.  For convenience sake the TXNObject associated
 *    with the callback is passed to the callback as well as the user
 *    data.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The TXNObject.
 *    
 *    iMenuSetupProc:
 *      The callback.
 *    
 *    iUserData:
 *      A pointer to some useful data.
 *  
 *  Result:
 *    OStatus.  noErr is the operation is successful.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNSetContextualMenuSetup(
  TXNObject                   iTXNObject,
  TXNContextualMenuSetupUPP   iMenuSetupProc,
  const void *                iUserData)                      AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Accessibility                                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNGetAccessibilityHIObject()
 *  
 *  Summary:
 *    Return an HIObjectRef used to represent the MLTE object for
 *    accessibility.
 *  
 *  Discussion:
 *    For each MLTE object a view creates, the view needs to call
 *    TXNGetAccessibilityHIObject to get an HIObjectRef that can be
 *    used to represent the MLTE object as an accessible
 *    object.
 *    
 *    After the view gets this HIObjectRef, it must add the HIObjectRef
 *    as a child of itself.  The accessibility engine will then route
 *    events to MLTE accessible objects automatically.
 *    
 *    The view must install Carbon event handlers for
 *    kEventAccessibleGetAllAttributeNames and
 *    kEventAccessibleGetNamedAttribute, using the HIObjectRef as the
 *    target, to provide information for at least the following
 *    required attributes:
 *    
 *    kAXRoleAttribute
 *    kAXRoleDescriptionAttribute
 *    kAXWindowAttribute
 *    kAXTopUIElementAttribute
 *    kAXPositionAttribute
 *    kAXSizeAttribute
 *    
 *    MLTE also installs handlers for
 *    kEventAccessibleGetAllAttributeNames and
 *    kEventAccessibleGetNamedAttribute.  These handlers return
 *    information for the following attributes.  Note that these
 *    handlers will not get called unless the client-installed handlers
 *    return eventNotHandledErr.
 *    
 *    kAXEnabledAttribute
 *    kAXFocusedAttribute
 *    kAXValueAttribute
 *    kAXSelectedTextAttribute
 *    kAXSelectedTextRangeAttribute
 *     kAXNumberOfCharactersAttribute
 *    
 *    kAXLineForIndexParameterizedAttribute
 *     kAXRangeForLineParameterizedAttribute
 *     kAXStringForRangeParameterizedAttribute
 *     kAXRangeForPositionParameterizedAttribute
 *     kAXRangeForIndexParameterizedAttribute
 *     kAXBoundsForRangeParameterizedAttribute
 *     kAXStyleRangeForIndexParameterizedAttribute
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    oHIObjectRef:
 *      An HIObjectRef which represents iTXNObject as an accessible
 *      object.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNGetAccessibilityHIObject(
  TXNObject      iTXNObject,
  HIObjectRef *  oHIObjectRef)                                AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/* **************************************************************************************************** */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*                                  •  DEPRECATED •                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/* **************************************************************************************************** */

/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • DEPRECATED CONSTANTS                                                                              */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */

#if !__LP64__
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/* Deprecated Font Menu support on Mac OS X version 10.5 and later, use Font Panel instead              */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
typedef struct OpaqueTXNFontMenuObject*  TXNFontMenuObject;
#define   kTXNFontMenuRefKey                        CFSTR("FontMenuRef")
#define   kTXNFontMenuObjectKey                     CFSTR("FontMenuObject")

/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/* Deprecated Font / keyboard synchronization support constants on Mac OS X version 10.5 and later      */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
enum {
  kTXNKeyboardSyncStateTag      = 'kbsy'
};

/* kTXNKeyboardSyncStateTag*/
enum {
  kTXNSyncKeyboard              = false,
  kTXNNoSyncKeyboard            = true
};

enum {
  kTXNNoKeyboardSyncBit         = 6
};

enum {
  kTXNNoKeyboardSyncMask        = 1 << kTXNNoKeyboardSyncBit
};

#endif  /* !__LP64__ */


/*
 *  TXTNTag
 *  
 *  Summary:
 *    Deprecated. Use TXNTypeRunAttributes.
 */

typedef FourCharCode                    TXTNTag;

/*
 *  TXNErrors
 *  
 *  Summary:
 *    Deprecated. Use OSStatus.
 */
typedef OSStatus                        TXNErrors;

/*
 *  TXNObjectRefcon
 *  
 *  Summary:
 *    Deprecated. Only used by TXNNewObject API, which has been
 *    deprecated.
 */
typedef void *                          TXNObjectRefcon;

/*
 *  TXNLongRect
 *  
 *  Summary:
 *    Deprecated. Only used by TXNGetRectBounds/TXNSetRectBounds APIs,
 *    which have been deprecated.
 */
struct TXNLongRect {
  SInt32              top;
  SInt32              left;
  SInt32              bottom;
  SInt32              right;
};
typedef struct TXNLongRect              TXNLongRect;

/*
 *  TXNFrameType
 *  
 *  Summary:
 *    Deprecated.  Only used by TXNNewObject API, which has been
 *    deprecated. Only kTXNTextEditStyleFrameType is supported.
 */
typedef UInt32 TXNFrameType;
enum {
  kTXNTextEditStyleFrameType    = 1,
  kTXNPageFrameType             = 2,    /* Not supported*/
  kTXNMultipleFrameType         = 3     /* Not supported*/
};


/*  Deprecated all QD TXNTypeRunAttributes & TXNTypeRunAttributeSizes constants.*/
enum {
  kTXNQDFontNameAttribute       = 'fntn',
  kTXNQDFontFamilyIDAttribute   = 'font',
  kTXNQDFontSizeAttribute       = 'size', /*the corresponding TXNTypeRunAttributeSizes is kTXNFontSizeAttributeSize*/
  kTXNQDFontStyleAttribute      = 'face',
  kTXNQDFontColorAttribute      = 'klor'
};

enum {
  kTXNQDFontNameAttributeSize   = sizeof(Str255),
  kTXNQDFontFamilyIDAttributeSize = sizeof(SInt16),
  kTXNFontSizeAttributeSize     = sizeof(Fixed),
  kTXNQDFontSizeAttributeSize   = sizeof(SInt16),
  kTXNQDFontStyleAttributeSize  = sizeof(Style),
  kTXNQDFontColorAttributeSize  = sizeof(RGBColor)
};

/*
    Deprecated QuickDraw imaging constants.
    On Mac OS X version 10.4 and later, MLTE always uses Quartz imaging.    
*/

enum {
  kTXNUseQDforImagingBit        = 16
};

enum {
  kTXNUseQDforImagingMask       = 1 << kTXNUseQDforImagingBit
};

enum {
  kTXNImageWithQDBit            = 8
};

enum {
  kTXNImageWithQDMask           = 1 << kTXNImageWithQDBit
};


/*
    Deprecated TXNControlTag constant.
    On Mac OS X version 10.4 and later, MLTE never draws the caret when inactive.    
*/

enum {
  kTXNDrawCaretWhenInactiveTag  = 'dcrt' /* Caret will never be drawn when inactive.*/
};

enum {
  kTXNDontDrawCaretWhenInactive = false,
  kTXNDrawCaretWhenInactive     = true
};

enum {
  kTXNDontDrawCaretWhenInactiveBit = 12
};

enum {
  kTXNDontDrawCaretWhenInactiveMask = 1 << kTXNDontDrawCaretWhenInactiveBit
};



/*
    Deprecated TSM constants.
    On Mac OS X, MLTE uses the Text Services Manager.
*/

enum {
  kTXNNoTSMEverBit              = 4
};

enum {
  kTXNNoTSMEverMask             = 1 << kTXNNoTSMEverBit
};


/*
    Deprecated TXNCarbonEventInfo flag constants.
    MLTE does not support AppleEvents on Mac OS X version 10.1 and later.
*/

enum {
  kTXNNoAppleEventHandlersBit   = 0,
  kTXNRestartAppleEventHandlersBit = 1
};

enum {
  kTXNNoAppleEventHandlersMask  = 1 << kTXNNoAppleEventHandlersBit,
  kTXNRestartAppleEventHandlersMask = 1 << kTXNRestartAppleEventHandlersBit
};



/*
 *  TXNActionKey
 *  
 */
typedef UInt32 TXNActionKey;
enum {
  kTXNTypingAction              = 0,
  kTXNCutAction                 = 1,
  kTXNPasteAction               = 2,
  kTXNClearAction               = 3,
  kTXNChangeFontAction          = 4,
  kTXNChangeFontColorAction     = 5,
  kTXNChangeFontSizeAction      = 6,
  kTXNChangeStyleAction         = 7,
  kTXNAlignLeftAction           = 8,
  kTXNAlignCenterAction         = 9,
  kTXNAlignRightAction          = 10,
  kTXNDropAction                = 11,
  kTXNMoveAction                = 12,
  kTXNFontFeatureAction         = 13,
  kTXNFontVariationAction       = 14,

  /*
   * Use if none of the above apply.
   */
  kTXNUndoLastAction            = 1024
};

/* Deprecated on Mac OS X version 10.4 and later, use kTXNActionNameMapperKey instead.*/
#define   kTXNActionKeyMapperKey                    CFSTR("ActionKeyMapper")

/* Deprecated on Mac OS X version 10.4 and later, use TXNActionNameMapperProcPtr instead.*/
typedef CALLBACK_API( CFStringRef , TXNActionKeyMapperProcPtr )(TXNActionKey actionKey, UInt32 commandID);
typedef STACK_UPP_TYPE(TXNActionKeyMapperProcPtr)               TXNActionKeyMapperUPP;
/*
 *  NewTXNActionKeyMapperUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TXNActionKeyMapperUPP
NewTXNActionKeyMapperUPP(TXNActionKeyMapperProcPtr userRoutine) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTXNActionKeyMapperUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTXNActionKeyMapperUPP(TXNActionKeyMapperUPP userUPP)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTXNActionKeyMapperUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern CFStringRef
InvokeTXNActionKeyMapperUPP(
  TXNActionKey           actionKey,
  UInt32                 commandID,
  TXNActionKeyMapperUPP  userUPP)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

#if __MACH__
  #ifdef __cplusplus
    inline TXNActionKeyMapperUPP                                NewTXNActionKeyMapperUPP(TXNActionKeyMapperProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeTXNActionKeyMapperUPP(TXNActionKeyMapperUPP) { }
    inline CFStringRef                                          InvokeTXNActionKeyMapperUPP(TXNActionKey actionKey, UInt32 commandID, TXNActionKeyMapperUPP userUPP) { return (*userUPP)(actionKey, commandID); }
  #else
    #define NewTXNActionKeyMapperUPP(userRoutine)               ((TXNActionKeyMapperUPP)userRoutine)
    #define DisposeTXNActionKeyMapperUPP(userUPP)
    #define InvokeTXNActionKeyMapperUPP(actionKey, commandID, userUPP) (*userUPP)(actionKey, commandID)
  #endif
#endif

/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Count Option Bits                                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  Options for TXNGet/ClearActionChangeCount to decide what type(s) of action count to use.            */

enum {
  kTXNTextInputCountBit         = 0,
  kTXNRunCountBit               = 1
};


/*
 *  TXNCountOptions
 *  
 */
typedef OptionBits TXNCountOptions;
enum {
  kTXNTextInputCountMask        = 1 << kTXNTextInputCountBit,
  kTXNRunCountMask              = 1 << kTXNRunCountBit,
  kTXNAllCountMask              = kTXNTextInputCountMask | kTXNRunCountMask
};


/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • DEPRECATED APIs,  Mac OS X version 10.2 and later                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

#if !__LP64__
/*
 *  TXNSetViewRect()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNSetFrameBounds or TXNSetRectBounds APIs instead.
 *  
 *  Discussion:
 *    Set the rectangle describing the current view into the document.
 *    This will change how much text is viewable.  Not where a line of
 *    text wraps. That is controlled by TXNSetFrameBoundsSize.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iViewRect:
 *      Rect of the view.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.2
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   in Textension 1.3 and later
 */
extern void 
TXNSetViewRect(
  TXNObject     iTXNObject,
  const Rect *  iViewRect)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_2;


/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • DEPRECATED APIs, Mac OS X version 10.3 and later                                                  */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  TXNNewObject()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNCreateObject API instead.
 *  
 *  Discussion:
 *    Allocates a new frame (i.e. new is called to allocate a
 *    TXNObject) and returns a pointer to the object in the newDoc
 *    parameter.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iFileSpec:
 *      If NULL you start with an empty document.  If not NULL, the
 *      file is read to obtain the document contents  after the object
 *      is successfully allocated.
 *    
 *    iWindow:
 *      Required.  The window in which the document is going to be 
 *      displayed.  If a fileSpec is provided during creation, the
 *      filename is going to be used as the window title.  If iWindow
 *      is NULL, TXNAttachObjectToWindow needs to be called after
 *      creation.
 *    
 *    iFrame:
 *      If text-area does not fill the entire window.  This specifies
 *      the area to fill.  Can be NULL. In  which case, the window’s
 *      portRect is used as the frame.
 *    
 *    iFrameOptions:
 *      Specify the options to be supported by this frame.  The
 *      available options are support for cutting and pasting  movies
 *      and sound, handle scrollbars and handle grow box in  the frame.
 *    
 *    iFrameType:
 *      Specify the type of frame to be used.  In MLTE version 1.1 and
 *      earlier, only kTXNTextEditStyleFrameType is supported.
 *    
 *    iFileType:
 *      Specify the primary file type.  If you  use 
 *      kTextensionTextFile files will be saved in a private format
 *      (see xxx).  If you  want saved files to be plain text files you
 *      should specify 'TEXT' here. If you specify 'TEXT' here you can
 *      use the frameOptions parameter to specify  whether the TEXT
 *      files should be saved  with 'MPSR' resources or 'styl'
 *      resources. These are resources which contain style information
 *      for a  file, and they  both have there own limitations.  If you
 *      use 'styl' resources to save style info your documents can have
 *      as many styles as you like however tabs will not be saved.  If
 *      you use 'MPSR' resources only the first style in the document 
 *      will be saved (you as client are expected to apply all style
 *      changes to the entire document).  If you  truly want  rich
 *      documents which can potentially contain graphics and sound you
 *      should specify kTextensionTextFileOutput.  If you want a plain
 *      text editor like SimpleText specify that style information by
 *      saved via ‘styl’ resources. If you want files similar to those
 *      output by CW IDE, BBEdit, and MPW specify that style
 *      information be saved in a ‘MPSR’ resource.
 *    
 *    iPermanentEncoding:
 *      The encoding in which the document should be saved (Unicode,
 *      Text or System default).
 *    
 *    oTXNObject:
 *      Pointer to the opaque datastructure allocated by the function. 
 *      Most of the subsequent functions require that such a pointer be
 *      passed in.
 *    
 *    oTXNFrameID:
 *      Unique ID for the frame.  This value is always set to 0.
 *    
 *    iRefCon:
 *      Caller can set this to any value.  It is retained by the
 *      TXNNewObject which can later be asked to return it.
 *  
 *  Result:
 *    If anything goes wrong the error is returned.  Success must be
 *    complete. That is if everything  works, but there is a failure
 *    reading a specified file the  object is freed.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNNewObject(
  const FSSpec *                 iFileSpec,                /* can be NULL */
  WindowRef                      iWindow,
  const Rect *                   iFrame,                   /* can be NULL */
  TXNFrameOptions                iFrameOptions,
  TXNFrameType                   iFrameType,
  TXNFileType                    iFileType,
  TXNPermanentTextEncodingType   iPermanentEncoding,
  TXNObject *                    oTXNObject,
  TXNFrameID *                   oTXNFrameID,
  TXNObjectRefcon                iRefCon)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;


/*
 *  TXNTerminateTextension()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    No longer needed.
 *  
 *  Discussion:
 *    Close the Textension library.  It is necessary to call this
 *    function so that Textension can correctly close down any TSM
 *    connections and do other clean up.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern void 
TXNTerminateTextension(void)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;




/*
 *  TXNSetDataFromFile()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNSetDataFromCFURLRef API instead.
 *  
 *  Discussion:
 *    Replace the specified range with the contents of the specified
 *    file.  The data fork of the file must be opened by the caller. 
 *    Functional in NoUserIO mode.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iFileRefNum:
 *      File RefNum.
 *    
 *    iFileType:
 *      File type.
 *    
 *    iFileLength:
 *      The length of data in the file that should be considered data. 
 *      This parameter is available to enable callers to embed text
 *      inside their own private data structures.  Note that if the
 *      data is in the Textension(txtn) format this parameter is
 *      ignored since length, etc. information is part of the format.
 *      Further note that if you you just want Textension to read a
 *      file and you are not interested in embedding you can just pass
 *      kTXNEndOffset, and Textension will use the file manager to
 *      determine the files length.
 *    
 *    iStartOffset:
 *      Start position at which to insert the file into the document.
 *    
 *    iEndOffset:
 *      End position of range being replaced by the file.
 *  
 *  Result:
 *    File manager error or noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSetDataFromFile(
  TXNObject   iTXNObject,
  SInt16      iFileRefNum,
  OSType      iFileType,
  ByteCount   iFileLength,
  TXNOffset   iStartOffset,
  TXNOffset   iEndOffset)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNConvertToPublicScrap()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    This is a no-op in OS X.
 *  
 *  Discussion:
 *    Convert the Textension private scrap to the public clipboard. 
 *    This should be called on suspend events and before the
 *    application displays a dialog that might support cut and paste. 
 *    Or more generally, whenever someone other than the Textension
 *    Shared Library needs access to the scrap data. This is a no-op in
 *    OS X.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    Memory Manager errors, Scrap Manager errors, or noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNConvertToPublicScrap(void)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNConvertFromPublicScrap()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    No longer needed.
 *  
 *  Discussion:
 *    Convert the  public clipboard to our private scrap .  This should
 *    be called on resume events and after an application has modified
 *    the scrap. Before doing work we check the validity of the public
 *    scrap (date modification and type). 
 *    
 *    This is no longer needed in Mac OS X version 10.2 and later. 
 *    Calling TXNPaste will automatically handle conversion from public
 *    scrap.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    Memory Manager errors, Scrap Manager errors, or noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNConvertFromPublicScrap(void)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNDraw()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Deprecated.
 *  
 *  Discussion:
 *    Redraw the TXNObject including any scrollbars associated with the
 *    text frame.  Call this function in response to an update event
 *    for a window that contains multiple TXNObjects or some other
 *    graphic element.  The caller is responsible for calling
 *    BeginUpdate/EndUpdate in response to the update event.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iDrawPort:
 *      Can be NULL. If NULL the port is drawn to the port currently
 *      attached to the iTXNObject.  If not NULL drawing goes to the
 *      iDrawPort.  If drawing is done to the iDrawPort selection is
 *      not updated.  This works this way so that it is possible to
 *      Draw a TXNObject to a static port (i.e. print the thing without
 *      reflowing the text to match the paper size which is what
 *      TXNPrint does) and not have a line drawn where the selection
 *      would be.  If you pass an iDrawPort to an active TXNObject
 *      (i.e. editable) the selection will not be updated. In this case
 *      the selection will behave oddly until text is typed which will
 *      serve to realign the selection.  Bottom-line don't pass a port
 *      in unless you want static text (printed or non-editable)
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern void 
TXNDraw(
  TXNObject   iTXNObject,
  GWorldPtr   iDrawPort)        /* can be NULL */             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNAttachObjectToWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNAttachObjectToWindowRef API instead.
 *  
 *  Discussion:
 *    If a TXNObject was initialized with a NULL window pointer use
 *    this function to attach a window to that object.  In version 1.0
 *    of Textension attaching a TXNObject to more than one window is
 *    not supported.  Note that if a CGContextRef was passed to the
 *    TXNObject previously through TXNSetTXNObjectControls, that
 *    CGContextRef will be ignored.  The CGContextRef associated with
 *    the iWindow will be used instead.  You may revert back to the
 *    previous CGContextRef by calling the TXNSetTXNObjectControls API
 *    with the desired CGContextRef again after calling
 *    TXNAttachObjectToWindow.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iWindow:
 *      GWorldPtr that the object should be attached to.
 *    
 *    iIsActualWindow:
 *      Let the library know if the GWorldPtr is actually a WindowRef
 *      or actually a GWorldPtr.  This is important if the client is
 *      taking advantage of the editing packages scrollbar support.
 *  
 *  Result:
 *    paramErrs or noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNAttachObjectToWindow(
  TXNObject   iTXNObject,
  GWorldPtr   iWindow,
  Boolean     iIsActualWindow)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNIsObjectAttachedToWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Deprecated.
 *  
 *  Discussion:
 *    A utility function that allows a caller to check a TXNObject to
 *    see if it is attached to a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *  
 *  Result:
 *    True if object is attached, false if TXNObject is not attached.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern Boolean 
TXNIsObjectAttachedToWindow(TXNObject iTXNObject)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNIsObjectAttachedToSpecificWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Deprecated.
 *  
 *  Discussion:
 *    Determines whether the given object is attached to the given
 *    window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNNewObject.
 *    
 *    iWindow:
 *      The window to check attachment against.
 *    
 *    oAttached:
 *      true if the object is attached to the given window, false
 *      otherwise.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   in Textension 1.2 and later
 */
extern OSStatus 
TXNIsObjectAttachedToSpecificWindow(
  TXNObject   iTXNObject,
  WindowRef   iWindow,
  Boolean *   oAttached)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;




/*
 *  TXNSetRectBounds()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNSetHIRectBounds API instead.
 *  
 *  Discussion:
 *    The View rectangle controls the text you see.  The Destination
 *    rectangle controls how text is laid out.  The Scrollbar is drawn
 *    inside the View rectangle. You only need to pass in pointers for
 *    the rectangles you want to set.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNNewObject.
 *    
 *    iViewRect:
 *      The new view rectangle.  If you do not want to change the view
 *      rectangle pass NULL.
 *    
 *    iDestinationRect:
 *      The new destination rectangle.  Pass NULL if you don't want to
 *      change the destination retangle.
 *    
 *    iUpdate:
 *      If you would like the the text and where the scrollbars are
 *      placed recalculated and redrawn pass true.  If you prefer to
 *      wait on this pass false.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TXNSetRectBounds(
  TXNObject            iTXNObject,
  const Rect *         iViewRect,              /* can be NULL */
  const TXNLongRect *  iDestinationRect,       /* can be NULL */
  Boolean              iUpdate)                               AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;


/*
 *  TXNGetRectBounds()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNGetHIRect API instead.
 *  
 *  Discussion:
 *    Get the values for the current View rectangle, Destination
 *    rectangle and Text rectangle.  You only need to pass in pointers
 *    for the rectangles you're interested in.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNNewObject.
 *    
 *    oViewRect:
 *      The current view rectangle
 *    
 *    oDestinationRect:
 *      The current destination rectangle
 *    
 *    oTextRect:
 *      The smallest rectangle needed to contain the current text. 
 *      This rectangle is calculated by walking the lines of text and
 *      measuring each line.  So this can be expensive.  The width of
 *      this rectangle will be the width of the longest line in the
 *      text.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNGetRectBounds(
  TXNObject      iTXNObject,
  Rect *         oViewRect,              /* can be NULL */
  TXNLongRect *  oDestinationRect,       /* can be NULL */
  TXNLongRect *  oTextRect)              /* can be NULL */    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNActivate()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNSetScrollbarState API instead.
 *  
 *  Discussion:
 *    Make the TXNObject object active in the sense that it can be
 *    scrolled if it has scrollbars. If the TXNScrollBarState parameter
 *    is true than the scrollbars will be active even when the
 *    TXNObject is not focused (i.e. insertion point not active).  See
 *    the equivalent TXNSetScrollbarState. 
 *    
 *    This function should be used if you have multiple TXNObjects in a
 *    window, and you want them all to be scrollable even though only
 *    one at a time can have the keyboard focus.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iTXNFrameID:
 *      TXNFrameID obtained from TXNNewObject.  Deprecated.  Pass 0.
 *    
 *    iActiveState:
 *      Boolean if true Scrollbars active even though TXNObject does
 *      not have the keyboard focus. if false scrollbars are synced
 *      with active state (i.e. a focused object has an active
 *      insertion point or selection and active scrollbars. An
 *      unfocused object has inactive selection (grayed or framed
 *      selection) and inactive scrollbars.  The latter state is the
 *      default and usually the one you use if you have one TXNObject
 *      in a window.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNActivate(
  TXNObject           iTXNObject,
  TXNFrameID          iTXNFrameID,
  TXNScrollBarState   iActiveState)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;




/*
 *  TXNPointToOffset()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNHIPointToOffset API instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iPoint:
 *      A point (in local coordinates).
 *    
 *    oOffset:
 *      Offset corresponding to the point.
 *  
 *  Result:
 *    A result code indicating success or failure. Memory, out of
 *    bounds errors (if the point is out of the ViewRect).
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   in Textension 1.1 and later
 */
extern OSStatus 
TXNPointToOffset(
  TXNObject    iTXNObject,
  Point        iPoint,
  TXNOffset *  oOffset)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*
 *  TXNOffsetToPoint()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNOffsetToHIPoint API instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iOffset:
 *      An offset.
 *    
 *    oPoint:
 *      Point corresponding to the offset.
 *  
 *  Result:
 *    A result code indicating success or failure. Memory, out of
 *    bounds errors.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.3
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   in Textension 1.1 and later
 */
extern OSStatus 
TXNOffsetToPoint(
  TXNObject   iTXNObject,
  TXNOffset   iOffset,
  Point *     oPoint)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_3;



/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • DEPRECATED APIs, Mac OS X version 10.4 and later                                                  */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNCanUndo()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNCanUndoAction API instead.
 *  
 *  Summary:
 *    Use this to determine if the Undo item in Edit menu should be
 *    highlighted or not. Tells you if last command was undoable.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    oTXNActionKey:
 *      The key code that the caller can use to pick a string to
 *      describe the undoable action in the undo item.  Pass in NULL if
 *      the string isn't needed.
 *  
 *  Result:
 *    Boolean: If True the last command is undoable and the undo item
 *    in the menu should be active.  If false last command cannot be
 *    undone and undo should be grayed in the menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern Boolean 
TXNCanUndo(
  TXNObject       iTXNObject,
  TXNActionKey *  oTXNActionKey)       /* can be NULL */      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;



/*
 *  TXNCanRedo()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNCanRedoAction API instead.
 *  
 *  Summary:
 *    Use this to determine if the current item on the undo stack is
 *    redoable.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    oTXNActionKey:
 *      The key code that the caller can use to pick a string to
 *      describe the redoable action in the redo item.  Pass in NULL if
 *      the string isn't needed.
 *  
 *  Result:
 *    If it returns true, then the redo item in the edit menu should be
 *    active.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern Boolean 
TXNCanRedo(
  TXNObject       iTXNObject,
  TXNActionKey *  oTXNActionKey)       /* can be NULL */      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TXNGetActionChangeCount()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNGetCountForActionType API instead.
 *  
 *  Summary:
 *    Retrieves the number of times the specified action(s) have
 *    occurred.
 *  
 *  Discussion:
 *    Explicit call to TXNClearActionChangeCount is needed when the
 *    counter(s) have to be reset.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iOptions:
 *      Specify the the type of action changes to be include when
 *      retrieving the count.  Choose from the TXNOptions.
 *    
 *    oCount:
 *      The number of counts returned by the function.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   in Textension 1.3 and later
 */
extern OSStatus 
TXNGetActionChangeCount(
  TXNObject         iTXNObject,
  TXNCountOptions   iOptions,
  ItemCount *       oCount)                                   AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;



/*
 *  TXNClearActionChangeCount()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNClearCountForActionType API instead.
 *  
 *  Summary:
 *    Reset the specified action counter(s) to zero.
 *  
 *  Discussion:
 *    Use kAllCountMask to reset everything.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iOptions:
 *      Specify the the type of action changes to be included when
 *      resetting the count.  Choose from the TXNOptions.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   in Textension 1.3 and later
 */
extern OSStatus 
TXNClearActionChangeCount(
  TXNObject         iTXNObject,
  TXNCountOptions   iOptions)                                 AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;



/*
 *  TXNSetDataFromCFURLRef()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNReadFromCFURL API instead.
 *  
 *  Summary:
 *    Replaces a range of data with the content of a file.
 *  
 *  Discussion:
 *    Uses URL file name extension to determine the type of the input
 *    file. If the entire content is replaced, calling TXNRevert will
 *    revert to the last saved CFURLRef.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.  Data will be
 *      added to this text object.
 *    
 *    iURL:
 *      The url referring to the file which contains the data you want
 *      to add to the object.
 *    
 *    iStartOffset:
 *      The starting offset at which to insert the file into a
 *      document.. If you want to replace the entire text content then
 *      set the iStartOffset parameter to kTXNStartOffset.
 *    
 *    iEndOffset:
 *      The ending position of the range being replaced by the file. If
 *      you want to replace the entire text content then set the
 *      iEndOffset parameter to kTXNEndOffset.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TXNSetDataFromCFURLRef(
  TXNObject   iTXNObject,
  CFURLRef    iURL,
  TXNOffset   iStartOffset,
  TXNOffset   iEndOffset)                                     AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TXNSave()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TXNWriteRangeToCFURL API instead.
 *  
 *  Summary:
 *    Save the contents of the document as the given type.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iType:
 *      The type of file to create.
 *    
 *    iResType:
 *      When saving file as plain TEXT the type of resource to save
 *      style information. Use kTXNMultipleStylesPerTextDocumentResType
 *      if your document contains multiple styles and you want a
 *      SimpleText like document.  Use
 *      kTXNSingleStylePerTextDocumentResType if the document has a
 *      single style and you would like a BBEdit, MPW, CW type of
 *      document.
 *    
 *    iPermanentEncoding:
 *      The encoding in which the document should be saved (Unicode,
 *      Text or System default).
 *    
 *    iFileSpecification:
 *      The file specification to which the document should be saved.
 *      The file must have been opened by the caller.  The file
 *      specification is remembered by the TXNObject and is used for
 *      any subsequent calls to TXNRevert.
 *    
 *    iDataReference:
 *      The data fork ref num.  This is used to write data to the data
 *      fork of the file. The data is written beginning at the current
 *      mark.
 *    
 *    iResourceReference:
 *      The resource fork ref num.  If the caller has specified that
 *      style information be saved as a resource (MPW or SimpleText)
 *      than this should be a valid reference to an open resource fork.
 *       If the txtn format is being used than this input value is
 *      ignored.
 *  
 *  Result:
 *    The result of writing the file.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSave(
  TXNObject                      iTXNObject,
  TXNFileType                    iType,
  OSType                         iResType,
  TXNPermanentTextEncodingType   iPermanentEncoding,
  const FSSpec *                 iFileSpecification,
  SInt16                         iDataReference,
  SInt16                         iResourceReference)          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • DEPRECATED APIs, Mac OS X version 10.5 and later                                                  */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Font Menu                                                                                         */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  TXNNewFontMenuObject()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use Font Panel instead.
 *  
 *  Summary:
 *    Get a FontMenuObject.  Caller can extract a fontmenu from this
 *    object and pass this object to the active TXNObject to handle
 *    events in the font menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iFontMenuHandle:
 *      An empty menu handle (well the title is there) that the caller
 *      created via NewMenu or GetNewMenu. This menu handle should not
 *      be disposed before the returned TXNFontMenuObject has been
 *      disposed via TXNDisposeFontMenuObject.
 *    
 *    iMenuID:
 *      The MenuID for iFontMenuHandle.
 *    
 *    iStartHierMenuID:
 *      The first MenuID to use if any hierarchical menus need to be
 *      created. TXNNewFontMenuObject uses SetMenuItemHierarchicalID
 *      when creating hierarchial menus.  The iStartHierMenuID must
 *      therefore follow the rules for this function.  On systems less
 *      than system 8.5 the submenuID must be less than 255.  For
 *      systems above system 8.5 the range can be as large as 32767.
 *      However, it is important to remember that TXNNewFontMenuObject
 *      only uses iStartHierMenuID as a starting id when adding
 *      hierarchical menus.  Therefore provide plenty of room to
 *      increment this value. For example, on a system less than 8.5 it
 *      would be good to start at 175.  On systems greater than 8.5 it
 *      is probably a good idea to not use a value higher than 32000.
 *    
 *    oTXNFontMenuObject:
 *      A font menu object.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNNewFontMenuObject(
  MenuRef              iFontMenuHandle,
  SInt16               iMenuID,
  SInt16               iStartHierMenuID,
  TXNFontMenuObject *  oTXNFontMenuObject)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;




/*
 *  TXNGetFontMenuHandle()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use Font Panel instead.
 *  
 *  Summary:
 *    Get the MenuRef from the TXNFontMenuObject.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNFontMenuObject:
 *      A Font Menu Object obtained from TXNNewFontMenuObject.
 *    
 *    oFontMenuHandle:
 *      The returned font menu. Returned value could be NULL.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNGetFontMenuHandle(
  TXNFontMenuObject   iTXNFontMenuObject,
  MenuRef *           oFontMenuHandle)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


#define TXNGetFontMenuRef TXNGetFontMenuHandle

/*
 *  TXNDisposeFontMenuObject()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use Font Panel instead.
 *  
 *  Summary:
 *    Dispose a TXNFontMenuObject and its font menu handle.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNFontMenuObject:
 *      A Font Menu Object obtained from TXNNewFontMenuObject.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNDisposeFontMenuObject(TXNFontMenuObject iTXNFontMenuObject) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;




/*
 *  TXNDoFontMenuSelection()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use Font Panel instead.
 *  
 *  Summary:
 *    Given the menuID and menu item returned by MenuSelect determine
 *    the selected font and change the current selection to be that
 *    Font.  If the input TXNObject is not active a parameter error is
 *    returned.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iTXNFontMenuObject:
 *      A Font Menu Object obtained from TXNNewFontMenuObject.
 *    
 *    iMenuID:
 *      SInt16 the ID of the selected menu.
 *    
 *    iMenuItem:
 *      The item that was selected.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNDoFontMenuSelection(
  TXNObject           iTXNObject,
  TXNFontMenuObject   iTXNFontMenuObject,
  SInt16              iMenuID,
  SInt16              iMenuItem)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;



/*
 *  TXNPrepareFontMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use Font Panel instead.
 *  
 *  Summary:
 *    Prepares a Font menu for display.
 *  
 *  Discussion:
 *    You should call the TXNPrepareFontMenu function just before your
 *    application opens the Font menu for your user. If the text
 *    object’s current selection is a single font, MLTE places a
 *    checkmark next to the menu item for that font.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      The text object that identifies the document with the Font menu
 *      you want to prepare. Pass NULL to display an inactive menu
 *      (dimmed).
 *    
 *    iTXNFontMenuObject:
 *      A Font menu object.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNPrepareFontMenu(
  TXNObject           iTXNObject,               /* can be NULL */
  TXNFontMenuObject   iTXNFontMenuObject)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/
/*  • Font Defaults                                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  TXNSetFontDefaults()   *** DEPRECATED ***
 *  
 *  Summary:
 *    For a given TXNObject specify the font defaults for each script.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    iCount:
 *      Count of FontDescriptions.
 *    
 *    iFontDefaults:
 *      Array of FontDescriptions.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNSetFontDefaults(
  TXNObject                                iTXNObject,
  ItemCount                                iCount,
  const TXNMacOSPreferredFontDescription   iFontDefaults[])   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;




/*
 *  TXNGetFontDefaults()   *** DEPRECATED ***
 *  
 *  Summary:
 *    For a given TXNObject make a copy of the font defaults.
 *  
 *  Discussion:
 *    To determine how many font descriptions need to be in the array
 *    you should call this function with a NULL for the array.  iCount
 *    will return with the number of font defaults currently stored.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    iTXNObject:
 *      Opaque TXNObject obtained from TXNCreateObject.
 *    
 *    ioCount:
 *      Count of FontDescriptions in the array.
 *    
 *    oFontDefaults:
 *      Array of FontDescriptins to be filled out.
 *  
 *  Result:
 *    A result code indicating success or failure.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in Textension 1.0 and later
 */
extern OSStatus 
TXNGetFontDefaults(
  TXNObject                          iTXNObject,
  ItemCount *                        ioCount,
  TXNMacOSPreferredFontDescription   oFontDefaults[])     /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


#endif  /* !__LP64__ */


#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __MACTEXTEDITOR__ */

                                   MacWindows.h                                                                                        0100644 0001750 0001750 00001451716 12566221370 043242  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/MacWindows.h
 
     Contains:   Window Manager Interfaces
 
     Copyright:  © 1997-2008 by Apple Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __MACWINDOWS__
#define __MACWINDOWS__

#ifndef __APPLICATIONSERVICES__
#include <ApplicationServices/ApplicationServices.h>
#endif

#ifndef __APPEARANCE__
#include <HIToolbox/Appearance.h>
#endif

#ifndef __DRAG__
#include <HIToolbox/Drag.h>
#endif

#ifndef __EVENTS__
#include <HIToolbox/Events.h>
#endif

#ifndef __MENUS__
#include <HIToolbox/Menus.h>
#endif

#ifndef __HITOOLBAR__
#include <HIToolbox/HIToolbar.h>
#endif



#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 2)

/*                                                                                          */
/* Current documentation for the Mac OS X Window Manager is available on the web:           */
/*  <http://developer.apple.com/documentation/Carbon/Reference/Window_Manager/index.html>   */
/*                                                                                          */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • HIWindowRef                                                                        */
/*——————————————————————————————————————————————————————————————————————————————————————*/
typedef WindowRef                       HIWindowRef;
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Property Types                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————*/
typedef OSType                          PropertyCreator;
typedef OSType                          PropertyTag;
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Classes                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  WindowClass
 *  
 *  Summary:
 *    The types of windows provided by the Window Manager.
 *  
 *  Discussion:
 *    The class of a window determines several aspects of the window:
 *    its appearance, its initial window attributes, its initial window
 *    group, and its initial modality. All of these except for the
 *    window's appearance may be changed later using other Window
 *    Manager APIs.
 */
typedef UInt32 WindowClass;
enum {

  /*
   * An alert window is used when the application needs the user's
   * attention immediately. On Mac OS 9 and earlier, a visible alert
   * window will prevent the user from switching to any other
   * application. Use kThemeBrushAlertBackgroundActive to draw the
   * background of alert windows. 
   * 
   * Alert windows support compositing mode in Mac OS X 10.5 and later.
   * 
   * 
   * Alert windows are initially placed in the modal window group,
   * given a modality of kWindowModalityAppModal, and given an
   * activation scope of kWindowActivationScopeAll. Available in Mac OS
   * 8.5 and later.
   */
  kAlertWindowClass             = 1,

  /*
   * Similar to kAlertWindowClass, but provides a window that is
   * movable and that allows switching to other applications. Generally
   * you should use this window class rather than kAlertWindowClass.
   * Use kThemeBrushAlertBackgroundActive to draw the background of
   * movable alert windows. 
   * 
   * Movable alert windows support compositing mode in Mac OS X 10.2
   * and later. 
   * 
   * Movable alert windows are initially placed in the modal window
   * group, given a modality of kWindowModalityAppModal, and given an
   * activation scope of kWindowActivationScopeAll. Available in Mac OS
   * 8.5 and later.
   */
  kMovableAlertWindowClass      = 2,

  /*
   * A modal window is used to display a dialog (but not an alert; use
   * kAlertWindowClass for alerts). On Mac OS 9 and earlier, a visible
   * modal window will prevent the user from switching to any other
   * application. Use kThemeBrushDialogBackgroundActive to draw the
   * background of modal windows. 
   * 
   * Modal windows support compositing mode in Mac OS X 10.5 and later.
   * 
   * 
   * Modal windows are initially placed in the modal window group,
   * given a modality of kWindowModalityAppModal, and given an
   * activation scope of kWindowActivationScopeAll. Available in Mac OS
   * 8.5 and later.
   */
  kModalWindowClass             = 3,

  /*
   * Similar to kModalWindowClass, but provides a window that is
   * movable and that allows switching to other applications. Generally
   * you should use this window class rather than kModalWindowClass. If
   * you are using CarbonLib 1.3 or later, or Mac OS X, use
   * kThemeBrushMovableModalBackground to draw the background of
   * movable modal windows; on earlier versions of CarbonLib, or for
   * non-Carbon programming, use kThemeBrushDialogBackgroundActive.
   * 
   * 
   * Movable modal windows support compositing mode in Mac OS X 10.2
   * and later. 
   * 
   * Movable modal windows are initially placed in the modal window
   * group, given a modality of kWindowModalityAppModal, and given an
   * activation scope of kWindowActivationScopeAll. Available in Mac OS
   * 8.5 and later.
   */
  kMovableModalWindowClass      = 4,

  /*
   * A floating window is layered above all application windows except
   * for alert and modal windows. It is commonly used for palette
   * windows, inspectors, and other accessory (non-document) windows.
   * Use kThemeBrushUtilityWindowBackgroundActive or
   * kThemeBrushDocumentWindowBackground to draw the background of
   * floating windows. 
   * 
   * Floating windows support compositing mode in Mac OS X 10.2 and
   * later. 
   * 
   * Floating windows are initially placed in the floating window
   * group, given a modality of kWindowModalityNone, and given an
   * activation scope of kWindowActivationScopeIndependent. Available
   * in Mac OS 8.6 and later.
   */
  kFloatingWindowClass          = 5,

  /*
   * A document window is used for normal application document windows.
   * Use kThemeBrushDocumentWindowBackground or your own custom drawing
   * to draw the background of a document window. 
   * 
   * Document windows support compositing mode in Mac OS X 10.2 and
   * later. 
   * 
   * Document windows are initially placed in the document window
   * group, given a modality of kWindowModalityNone, and given an
   * activation scope of kWindowActivationScopeAll. Available in Mac OS
   * 8.5 and later.
   */
  kDocumentWindowClass          = 6,

  /*
   * A utility window is similar to a floating window, but it floats
   * above the windows of all applications rather than just above the
   * windows of the application that creates it. Use
   * kThemeBrushUtilityWindowBackgroundActive or
   * kThemeBrushDocumentWindowBackground to draw the background of
   * utility windows. 
   * 
   * Utility windows support compositing mode in Mac OS X 10.2 and
   * later. 
   * 
   * Utility windows are initially placed in the utility window group,
   * given a modality of kWindowModalityNone, and given an activation
   * scope of kWindowActivationScopeIndependent. Available in CarbonLib
   * 1.1 and later, and in Mac OS X.
   */
  kUtilityWindowClass           = 8,

  /*
   * A help window is used to display help tags. It has no window
   * frame. Typically you should use the Help Manager to display help
   * tags, rather than creating a help tag window yourself. 
   * 
   * Help windows support compositing mode in Mac OS X 10.3 and later.
   * 
   * 
   * Help windows are initially placed in the help window group, given
   * a modality of kWindowModalityNone, and given an activation scope
   * of kWindowActivationScopeNone. Available in CarbonLib 1.1 and
   * later, and in Mac OS X.
   */
  kHelpWindowClass              = 10,

  /*
   * A sheet window is used to display a dialog that is attached
   * directly to its parent window, rather than being a independent
   * window. A sheet dialog only prevents interaction with its parent
   * window; the user may still interact with other windows in the same
   * application. Use kThemeBrushSheetBackgroundOpaque to draw an
   * opaque background for sheet windows, or
   * kThemeBrushSheetBackgroundTransparent to draw a transparent
   * background (the transparent brush is only available in Mac OS X
   * 10.1 and later). 
   * 
   * Sheet windows support compositing mode in Mac OS X 10.2 and later.
   * 
   * 
   * Sheet windows are initially placed in the document window group,
   * given a modality of kWindowModalityNone, and given an activation
   * scope of kWindowActivationScopeAll. Available in CarbonLib 1.3 and
   * later, and in Mac OS X; in CarbonLib, a sheet window is actually a
   * movable-modal window, which blocks user interaction with all
   * windows of the application.
   */
  kSheetWindowClass             = 11,

  /*
   * A toolbar window is used to display a palette of controls. It is
   * similar to a floating window, and like a floating window is
   * layered above all application windows except for alert and modal
   * windows, but is layered beneath floating windows. Use
   * kThemeBrushToolbarBackground to draw the background of a toolbar
   * window in Mac OS X or later; CarbonLib does not currently support
   * kThemeBrushToolbarBackground. 
   * 
   * Toolbar windows support compositing mode in Mac OS X 10.3 and
   * later. 
   * 
   * Toolbar windows are initially placed in the toolbar window group,
   * given a modality of kWindowModalityNone, and given an activation
   * scope of kWindowActivationScopeNone. Available in CarbonLib 1.1
   * and later, and Mac OS X.
   */
  kToolbarWindowClass           = 12,

  /*
   * A plain window has a single-pixel window frame.
   * kThemeBrushDocumentWindowBackground,
   * kThemeBrushDialogBackgroundActive, and application-specific custom
   * drawing are all commonly used to draw the background of a plain
   * window. 
   * 
   * Plain windows support compositing mode on Mac OS X 10.3 and later.
   * 
   * 
   * Plain windows are initially placed in the document window group,
   * given a modality of kWindowModalityNone, and given an activation
   * scope of kWindowActivationScopeAll. Available in CarbonLib 1.2.5
   * and later, and Mac OS X.
   */
  kPlainWindowClass             = 13,

  /*
   * An overlay window is a completely transparent window positioned
   * above all other windows. Overlay windows are intended as a
   * replacement for the pre-Carbon practice of drawing directly into
   * the window manager port; by creating a full-screen overlay window
   * and drawing into it, you can draw over any window in any
   * application without disturbing the contents of the windows
   * underneath your drawing. 
   * 
   * Overlay windows have a default handler for kEventWindowPaint that
   * uses CGContextClearRect to clear the overlay window's alpha
   * channel to zero. This ensures the initial transparency of the
   * window. You can install your own kEventWindowPaint handler to do
   * your own drawing; typically, you would call through to the default
   * handler with CallNextEventHandler first, and then use
   * QDBeginCGContext to create your own context for drawing. You can
   * use either QuickDraw or CoreGraphics to draw into an overlay
   * window, but you must use CoreGraphics to draw if you need any of
   * your drawing to be non-opaque, since QuickDraw always sets the
   * alpha channel of any pixels that it touches to 1.0. 
   * 
   * Overlay windows support compositing mode on Mac OS X 10.3 and
   * later. You should draw into a compositing overlay window by adding
   * a standard or custom HIView and implementing the kEventControlDraw
   * event for your view; do not use kEventWindowPaint. 
   * 
   * You can also use the standard window event handler together with
   * regular controls in an overlay window. When using the standard
   * window event handler, you will probably want your
   * kEventWindowPaint handler to return eventNotHandledErr (after
   * calling the default handler with CallNextEventHandler first) so
   * that after the Paint handler returns, the Window Manager will send
   * a kEventWindowDrawContent event which the standard window event
   * handler can respond to by drawing the controls in the window.
   * 
   * 
   * Overlay windows are initially placed in the overlay window group,
   * given a modality of kWindowModalityNone, and given an activation
   * scope of kWindowActivationScopeNone. Available in Mac OS X.
   */
  kOverlayWindowClass           = 14,

  /*
   * A sheet alert window is similar to a sheet window, but is intended
   * to display an alert rather than a dialog. On Mac OS X, the
   * appearance of a sheet window and a sheet alert window is currently
   * identical, but in CarbonLib a sheet alert window has a different
   * appearance from a sheet window. Use
   * kThemeBrushSheetBackgroundOpaque to draw an opaque background for
   * sheet alert windows, or kThemeBrushSheetBackgroundTransparent to
   * draw a transparent background (the transparent brush is only
   * available in Mac OS X 10.1 and later). 
   * 
   * Sheet alert windows support compositing mode in Mac OS X 10.2 and
   * later. 
   * 
   * Sheet alert windows are initially placed in the document window
   * group, given a modality of kWindowModalityNone, and given an
   * activation scope of kWindowActivationScopeAll. Available in
   * CarbonLib 1.3 and later, and in Mac OS X 10.1 and later; in
   * CarbonLib, a sheet alert window is actually a movable alert
   * window, which blocks user interaction with all windows of the
   * application.
   */
  kSheetAlertWindowClass        = 15,

  /*
   * A alternate plain window is similar to a plain window but has a
   * solid black shadow on its right and bottom sides. It is rarely
   * used in modern Mac OS applications.
   * kThemeBrushDocumentWindowBackground,
   * kThemeBrushDialogBackgroundActive, and application-specific custom
   * drawing are all commonly used to draw the background of an
   * alternate plain window. 
   * 
   * Alternate plain windows support compositing mode in Mac OS X 10.5
   * and later. 
   * 
   * Alternate plain windows are initially placed in the document
   * window group, given a modality of kWindowModalityNone, and given
   * an activation scope of kWindowActivationScopeAll. Available in
   * CarbonLib 1.3 and later, and Mac OS X 10.1 and later.
   */
  kAltPlainWindowClass          = 16,

  /*
   * A simple window is the simplest possible window; it has no window
   * frame and its entire content is drawn by the application. Use any
   * theme brush or your own custom drawing to draw the background of a
   * simple window. 
   * 
   * Simple windows support compositing mode in Mac OS X 10.3 and
   * later. 
   * 
   * Simple windows are initially placed in the document window group,
   * given a modality of kWindowModalityNone, and given an activation
   * scope of kWindowActivationScopeAll. Available in CarbonLib 1.5 and
   * later, and Mac OS X 10.1 and later.
   */
  kSimpleWindowClass            = 18,

  /*
   * A drawer window is used when implementing a drawer user interface,
   * in which the drawer window slides out from underneath a document
   * window. Use kThemeBrushDrawerBackground or
   * kThemeBrushDocumentWindowBackground to draw the background of
   * drawer windows. 
   * 
   * Drawer windows must always use compositing mode. 
   * 
   * Drawer windows are initially placed in the document window group,
   * given a modality of kWindowModalityNone, and given an activation
   * scope of kWindowActivationScopeAll. Drawer windows must always be
   * created using the Compositing window attribute. Available in Mac
   * OS X 10.2 or later.
   */
  kDrawerWindowClass            = 20,

  /*
   * Not an actual window class, but a meta-constant that is used with
   * GetFrontWindowOfClass, FindWindowOfClass, and GetNextWindowOfClass
   * to indicate that there should be no restriction on the class of
   * the returned window. Also used with GetWindowGroupOfClass to get
   * the root window group.
   */
  kAllWindowClasses             = (UInt32)0xFFFFFFFF
};


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Attributes                                                                  */
/*——————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  Summary:
 *    Window attribute bits.
 */
enum {

  /*
   * This window has a close box. Available for windows of
   * kDocumentWindowClass, kFloatingWindowClass, and
   * kUtilityWindowClass; in Mac OS X 10.5 and later, also available
   * for windows of kMovableModalWindowClass.
   */
  kHIWindowBitCloseBox          = 1,

  /*
   * This window has a zoom box. Available for windows of
   * kDocumentWindowClass, kFloatingWindowClass, and
   * kUtilityWindowClass; in Mac OS X 10.5 and later, also available
   * for windows of kMovableModalWindowClass. Note that when this
   * attribute is set on a window, both the
   * kWindowHorizontalZoomAttribute and kWindowVerticalZoomAttribute
   * bits are set automatically.
   */
  kHIWindowBitZoomBox           = 2,

  /*
   * This window has a collapse box. Available for windows of
   * kDocumentWindowClass, kFloatingWindowClass, and
   * kUtilityWindowClass. For Floating and Utility window classes on
   * Mac OS X, this attribute must be added to the window using
   * ChangeWindowAttributes after the window is created; it may not be
   * added to the window at creation time.
   */
  kHIWindowBitCollapseBox       = 4,

  /*
   * This window can be resized. Available for windows of
   * kDocumentWindowClass, kMovableModalWindowClass,
   * kFloatingWindowClass, kUtilityWindowClass, and kSheetWindowClass.
   */
  kHIWindowBitResizable         = 5,

  /*
   * This window has a vertical titlebar on the side of the window.
   * Available for windows of kFloatingWindowClass and
   * kUtilityWindowClass.
   */
  kHIWindowBitSideTitlebar      = 6,

  /*
   * This window has a toolbar button. Available for windows of
   * kDocumentWindowClass on Mac OS X.
   */
  kHIWindowBitToolbarButton     = 7,

  /*
   * This window draws its window title and toolbar using a unified
   * appearance that has no separator between the two areas. A window
   * may not have both kHIWindowBitUnifiedTitleAndToolbar and
   * kHIWindowBitTextured. If a window already has the Textured
   * attribute, attempting to set the Unified attribute will cause
   * ChangeWindowAttributes to return an error, and vice versa. This
   * constant was not added to this header file until Mac OS X 10.5,
   * but it is actually available at runtime on Mac OS X 10.4 and later
   * for windows of kDocumentWindowClass. However, on Mac OS X 10.5 and
   * later, kHIWindowBitUnifiedTitleAndToolbar no longer has any
   * effect, since all windows with toolbars now have a unified look.
   */
  kHIWindowBitUnifiedTitleAndToolbar = 8,

  /*
   * This window uses the Textured appearance. Available for document
   * windows on Mac OS X 10.2 and later, and for floating windows on
   * Mac OS X 10.3 and later. Drawers can also be textured, but
   * dynamically adjust their appearance based on their parent window's
   * appearance; it is not necessary to specify this attribute for a
   * textured drawer.
   */
  kHIWindowBitTextured          = 9,

  /*
   * For Document, Floating, and Utility windows, this attribute allows
   * you to hide the title bar of a window. Available in Mac OS X 10.4
   * and later.
   */
  kHIWindowBitNoTitleBar        = 10,

  /*
   * Indicates that a textured window should have square corners. By
   * default, a textured window has round corners. When this attribute
   * is set on a window, the window frame view automatically makes the
   * grow box view opaque, and when this attribute is cleared, the
   * window frame view automatically makes the grow box view
   * transparent. You can change the grow box view transparency after
   * modifying this attribute with HIGrowBoxViewSetTransparent.
   * Relevant only for textured windows; ignored in non-textured
   * windows. Available in Mac OS X 10.5 and later for window classes
   * that support the textured appearance.
   */
  kHIWindowBitTexturedSquareCorners = 11,

  /*
   * Indicates that no border should be drawn between the toolbar and
   * window content. Relevant only in textured windows. Ignored in
   * non-textured windows.  Available in Mac OS X 10.4 and later for
   * window classes that support the textured appearance.
   */
  kHIWindowBitNoTexturedContentSeparator = 12,

  /*
   * Indicates that this window will have rounded bottom corners. By
   * default, a window has squared corners, and the assertion of this
   * bit turns on rounded bottom corners for the window if the window
   * has a bottom bar (set with HIWindowSetContentBorderThickness). If
   * the window does not have a bottom bar, this bit is ignored. If the
   * window has the kHIWindowBitTextured attribute set, the
   * kHIWindowBitRoundBottomBarCorners attribute will be ignored, as
   * that type of window defaults to rounded corners and controls the
   * squareness with the kHIWindowBitTexturedSquareCorners attribute.
   */
  kHIWindowBitRoundBottomBarCorners = 13,

  /*
   * This window does not participate in window cycling invoked by
   * cmd-~ or the "Focus on Window" hotkey defined in the Keyboards
   * preference pane. Available for all windows on Mac OS X 10.2 and
   * later.
   */
  kHIWindowBitDoesNotCycle      = 16,

  /*
   * This window receives no update events. Available for all windows.
   */
  kHIWindowBitNoUpdates         = 17,

  /*
   * This window receives no activate events. Available for all windows.
   */
  kHIWindowBitNoActivates       = 18,

  /*
   * This window receives mouse events even for areas of the window
   * that are transparent (have an alpha channel component of zero).
   * Available for windows of kOverlayWindowClass on Mac OS X 10.0 and
   * 10.1, and available for all windows on Mac OS X 10.2 and later.
   */
  kHIWindowBitOpaqueForEvents   = 19,

  /*
   * This window uses composited drawing. This means that the entire
   * window is comprised of HIViews, and can be treated thusly. This
   * attribute must be specified at window creation, and cannot be
   * changed later with ChangeWindowAttributes. Available on Mac OS X
   * 10.2 and later.
   */
  kHIWindowBitCompositing       = 20,

  /*
   * This window's backing store can be scaled as necessary for high
   * resolution drawing. This attribute is only consulted/respected if
   * the app's Info.plist includes NSHighResolutionCapable with a value
   * of true. This attribute can only be used when
   * kHIWindowBitCompositing is also enabled for the window. When this
   * attribute is enabled, you may not draw with QuickDraw in the
   * window. You may only specify this attribute at window creation
   * time. Available for all windows in 10.7.4 and later.
   */
  kHIWindowBitHighResolutionCapable = 21,

  /*
   * This window has no shadow. Available for all windows on Mac OS X.
   * This attribute is automatically given to windows of
   * kOverlayWindowClass.
   */
  kHIWindowBitNoShadow          = 22,

  /*
   * This window can be made visible prior to user login. By default,
   * in Mac OS X 10.5 and later no windows can be visible before a user
   * logs into the system; this protects the user against certain types
   * of malicious use of insecure applications. However, some software,
   * such as input methods or other accessibility software, may need to
   * deliberately make windows available prior to user login. Such
   * software should add this window attribute to its windows.
   * Available for all windows in Mac OS X 10.5 and later.
   */
  kHIWindowBitCanBeVisibleWithoutLogin = 23,

  /*
   * This window is marked so that the window server will drag the
   * window automatically. Your application should not call DragWindow
   * for this window, else it would confuse the heck out of the drag
   * (it would fight with the window server for control). This
   * attribute is ignored (async drag is not used) if your window is
   * grouped with other windows in a window group that has the
   * kWindowGroupAttrMoveTogether attribute. Available for all windows
   * on Mac OS X 10.3 and later.
   */
  kHIWindowBitAsyncDrag         = 24,

  /*
   * This window is automatically hidden on suspend and shown on
   * resume. Available for all windows. This attribute is automatically
   * given to windows of kFloatingWindowClass, kHelpWindowClass, and
   * kToolbarWindowClass.
   */
  kHIWindowBitHideOnSuspend     = 25,

  /*
   * This window has the standard Carbon window event handler
   * installed. Available for all windows.
   */
  kHIWindowBitStandardHandler   = 26,

  /*
   * This window is automatically hidden during fullscreen mode (when
   * the menubar is invisible) and shown afterwards. Available for all
   * windows. This attribute is automatically given to windows of
   * kUtilityWindowClass.
   */
  kHIWindowBitHideOnFullScreen  = 27,

  /*
   * This window is added to the standard Window menu. Available for
   * windows of kDocumentWindowClass. This attribute is automatically
   * given to windows of kDocumentWindowClass.
   */
  kHIWindowBitInWindowMenu      = 28,

  /*
   * This window supports live resizing. Available for all windows on
   * Mac OS X.
   */
  kHIWindowBitLiveResize        = 29,

  /*
   * This window never receives mouse events, even in areas that are
   * opaque. Instead, clicks on the window will be passed through to
   * windows beneath it. Available for all windows on Mac OS X 10.2 and
   * later.
   */
  kHIWindowBitIgnoreClicks      = 30,

  /*
   * This window will not be repositioned by the default
   * kEventWindowConstrain handler in response to changes in monitor
   * size, Dock position, and so on. Available for all windows on Mac
   * OS X 10.1 and later, and CarbonLib 1.6 and later.
   */
  kHIWindowBitNoConstrain       = 32,

  /*
   * Indicates that this window does not hide when the application is
   * hidden. Available for all windows in Mac OS X 10.5 and later. This
   * attribute is automatically given to windows of kUtilityWindowClass.
   */
  kHIWindowBitDoesNotHide       = 33,

  /*
   * Indicates that this window automatically installs Drag Manager
   * callbacks to detect drag actions, and automatically sends HIView
   * drag Carbon events. Setting this attribute is equivalent to
   * calling the SetAutomaticControlDragTrackingEnabledForWindow API
   * (and calling that API will now set this attribute). Available for
   * all windows in Mac OS X 10.5 and later.
   */
  kHIWindowBitAutoViewDragTracking = 34,

  /*
   * Indicates that this window automatically updates its ColorSync
   * profile to the profile of the display containing the greatest area
   * of the window. After the profile is set,
   * kEventWindowColorSpaceChanged is sent to the window. The standard
   * window handler's response is to repaint the entire window.
   * Available for all windows in Mac OS X 10.6 and later. This
   * attribute is automatically given to all compositing windows.
   */
  kHIWindowBitAutoCalibration   = 36,

  /*
   * Indicates that this window can become fullscreen, and causes the
   * enter fullscreen title bar button to be added to the window's
   * title bar. Including this bit on a window causes HIToolbox to add
   * appropriate Enter/Exit Full Screen menu items to the app's menus,
   * which HIToolbox will update appropriately. Only supported for
   * windows of kDocumentWindowClass. Available in Mac OS X 10.7 and
   * later.
   */
  kHIWindowBitFullScreenPrimary = 45,

  /*
   * Indicates that this window can coexist on a fullscreen space with
   * a fullscreen window of another application, but is not capable of
   * becoming fullscreen itself.
   * This window attribute is used in conjunction with the
   * kHIWindowCanJoinAllSpaces Availability option to allow the window
   * to move across FullScreen workspaces. For applications that are
   * BackgroundOnly or UIElements, this is the default behavior when
   * kHIWindowCanJoinAllSpaces is also set. For other applications,
   * kHIWindowBitFullScreenAuxiliary must be specified, and is
   * supported for window classes including kUtilityWindowClass, and
   * kFloatingWindowClass with a WindowActivationScope of
   * kWindowActivationScopeIndependent or kWindowActivationScopeNone.
   * Available in Mac OS X 10.7 and later.
   */
  kHIWindowBitFullScreenAuxiliary = 46
};


/*
 *  Summary:
 *    Window attributes as bitmasks. In Mac OS X 10.5 and later,
 *    kHIWindowBit constants are preferred.
 *  
 *  Discussion:
 *    Note that the kWindowApplicationScaledAttribute constant provided
 *    in Mac OS X 10.4 has been removed in Mac OS X 10.5 and later.
 *    Application-scaled mode was never fully implemented and all
 *    support for it has been removed from HIToolbox in Mac OS X 10.5.
 */
enum {

  /*
   * A constant with value zero; the lack of any attributes.
   */
  kWindowNoAttributes           = 0,

  /*
   * See kHIWindowBitCloseBox.
   */
  kWindowCloseBoxAttribute      = (1 << (kHIWindowBitCloseBox - 1)),

  /*
   * See kHIWindowBitZoomBox.
   */
  kWindowHorizontalZoomAttribute = (1 << (kHIWindowBitZoomBox - 1)),

  /*
   * See kHIWindowBitZoomBox.
   */
  kWindowVerticalZoomAttribute  = (1 << kHIWindowBitZoomBox),

  /*
   * See kHIWindowBitZoomBox.
   */
  kWindowFullZoomAttribute      = (kWindowVerticalZoomAttribute | kWindowHorizontalZoomAttribute),

  /*
   * See kHIWindowBitCollapseBox.
   */
  kWindowCollapseBoxAttribute   = (1 << (kHIWindowBitCollapseBox - 1)),

  /*
   * See kHIWindowBitResizable.
   */
  kWindowResizableAttribute     = (1 << (kHIWindowBitResizable - 1)),

  /*
   * See kHIWindowBitSideTitlebar.
   */
  kWindowSideTitlebarAttribute  = (1 << (kHIWindowBitSideTitlebar - 1)),

  /*
   * See kHIWindowBitToolbarButton.
   */
  kWindowToolbarButtonAttribute = (1 << (kHIWindowBitToolbarButton - 1)),

  /*
   * See kHIWindowBitUnifiedTitleAndToolbar.
   */
  kWindowUnifiedTitleAndToolbarAttribute = (1 << (kHIWindowBitUnifiedTitleAndToolbar - 1)),

  /*
   * See kHIWindowBitTextured.
   */
  kWindowMetalAttribute         = (1 << (kHIWindowBitTextured - 1)),

  /*
   * See kHIWindowBitNoTitleBar.
   */
  kWindowNoTitleBarAttribute    = (1 << (kHIWindowBitNoTitleBar - 1)),

  /*
   * See kHIWindowBitTexturedSquareCorners.
   */
  kWindowTexturedSquareCornersAttribute = (1 << (kHIWindowBitTexturedSquareCorners - 1)),

  /*
   * See kHIWindowBitNoTexturedContentSeparator.
   */
  kWindowMetalNoContentSeparatorAttribute = (1 << (kHIWindowBitNoTexturedContentSeparator - 1)),
  kWindowHasRoundBottomBarCornersAttribute = (1 << (kHIWindowBitRoundBottomBarCorners - 1)),

  /*
   * See kHIWindowBitDoesNotCycle.
   */
  kWindowDoesNotCycleAttribute  = (1 << (kHIWindowBitDoesNotCycle - 1)),

  /*
   * See kHIWindowBitNoUpdates.
   */
  kWindowNoUpdatesAttribute     = (1 << (kHIWindowBitNoUpdates - 1)),

  /*
   * See kHIWindowBitNoActivates.
   */
  kWindowNoActivatesAttribute   = (1 << (kHIWindowBitNoActivates - 1)),

  /*
   * See kHIWindowBitOpaqueForEvents.
   */
  kWindowOpaqueForEventsAttribute = (1 << (kHIWindowBitOpaqueForEvents - 1)),

  /*
   * See kHIWindowBitCompositing.
   */
  kWindowCompositingAttribute   = (1 << (kHIWindowBitCompositing - 1)),

  /*
   * See kHIWindowBitNoShadow.
   */
  kWindowNoShadowAttribute      = (1 << (kHIWindowBitNoShadow - 1)),

  /*
   * See kHIWindowBitCanBeVisibleWithoutLogin.
   */
  kWindowCanBeVisibleWithoutLoginAttribute = (1 << (kHIWindowBitCanBeVisibleWithoutLogin - 1)),

  /*
   * See kHIWindowBitHideOnSuspend.
   */
  kWindowHideOnSuspendAttribute = (1 << (kHIWindowBitHideOnSuspend - 1)),

  /*
   * See kHIWindowBitAsyncDrag.
   */
  kWindowAsyncDragAttribute     = (1 << (kHIWindowBitAsyncDrag - 1)),

  /*
   * See kHIWindowBitStandardHandler.
   */
  kWindowStandardHandlerAttribute = (1 << (kHIWindowBitStandardHandler - 1)),

  /*
   * See kHIWindowBitHideOnFullScreen.
   */
  kWindowHideOnFullScreenAttribute = (1 << (kHIWindowBitHideOnFullScreen - 1)),

  /*
   * See kHIWindowBitInWindowMenu.
   */
  kWindowInWindowMenuAttribute  = (1 << (kHIWindowBitInWindowMenu - 1)),

  /*
   * See kHIWindowBitLiveResize.
   */
  kWindowLiveResizeAttribute    = (1 << (kHIWindowBitLiveResize - 1)),

  /*
   * See kHIWindowBitIgnoreClicks.
   */
  kWindowIgnoreClicksAttribute  = (1 << (kHIWindowBitIgnoreClicks - 1)),

  /*
   * See kHIWindowBitHighResolutionCapable.
   */
  kWindowHighResolutionCapableAttribute = (1 << (kHIWindowBitHighResolutionCapable - 1)),

  /*
   * The minimum set of window attributes commonly used by document
   * windows.
   */
  kWindowStandardDocumentAttributes = (kWindowCloseBoxAttribute | kWindowFullZoomAttribute | kWindowCollapseBoxAttribute | kWindowResizableAttribute),

  /*
   * The minimum set of window attributes commonly used by floating
   * windows.
   */
  kWindowStandardFloatingAttributes = (kWindowCloseBoxAttribute | kWindowCollapseBoxAttribute)
};


enum
{
  /*
   * See kHIWindowBitNoConstrain.
   */
  kWindowNoConstrainAttribute              = 0x80000000 // force unsigned by specifying the constant explicitly
};
typedef OptionBits                      WindowAttributes;

/*
 *  Summary:
 *    DEPRECATED Window attribute bits.
 */
enum {

  /*
   * DEPRECATED name and functionality. Replaced conceptually by
   * kHIWindowBitHighResolutionCapable.
   */
  kHIWindowBitFrameworkScaled   = kHIWindowBitHighResolutionCapable
};


/*
 *  Summary:
 *    DEPRECATED Window attribute bitmasks.
 */
enum {

  /*
   * DEPRECATED name and functionality. Replaced conceptually by
   * kWindowHighResolutionCapableAttribute.
   */
  kWindowFrameworkScaledAttribute = kWindowHighResolutionCapableAttribute
};


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Definition Type                                                             */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  kWindowDefProcType            = 'WDEF'
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Mac OS 7.5 Window Definition Resource IDs                                          */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  kStandardWindowDefinition     = 0,    /* for document windows and dialogs*/
  kRoundWindowDefinition        = 1,    /* old Desk Accessory-style window*/
  kFloatingWindowDefinition     = 124   /* for floating windows*/
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Variant Codes                                                                      */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
                                        /* for use with kStandardWindowDefinition */
  kDocumentWindowVariantCode    = 0,
  kModalDialogVariantCode       = 1,
  kPlainDialogVariantCode       = 2,
  kShadowDialogVariantCode      = 3,
  kMovableModalDialogVariantCode = 5,
  kAlertVariantCode             = 7,
  kMovableAlertVariantCode      = 9,    /* for use with kFloatingWindowDefinition */
  kSideFloaterVariantCode       = 8
};


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • DefProc IDs                                                                        */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
                                        /* classic ids */
  documentProc                  = 0,
  dBoxProc                      = 1,
  plainDBox                     = 2,
  altDBoxProc                   = 3,
  noGrowDocProc                 = 4,
  movableDBoxProc               = 5,
  zoomDocProc                   = 8,
  zoomNoGrow                    = 12,   /* floating window defproc ids */
  floatProc                     = 1985,
  floatGrowProc                 = 1987,
  floatZoomProc                 = 1989,
  floatZoomGrowProc             = 1991,
  floatSideProc                 = 1993,
  floatSideGrowProc             = 1995,
  floatSideZoomProc             = 1997,
  floatSideZoomGrowProc         = 1999
};

enum {
                                        /* Resource IDs for theme-savvy window defprocs */
  kWindowDocumentDefProcResID   = 64,
  kWindowDialogDefProcResID     = 65,
  kWindowUtilityDefProcResID    = 66,
  kWindowUtilitySideTitleDefProcResID = 67,
  kWindowSheetDefProcResID      = 68,
  kWindowSimpleDefProcResID     = 69,
  kWindowSheetAlertDefProcResID = 70
};

enum {
                                        /* Proc IDs for theme-savvy windows */
  kWindowDocumentProc           = 1024,
  kWindowGrowDocumentProc       = 1025,
  kWindowVertZoomDocumentProc   = 1026,
  kWindowVertZoomGrowDocumentProc = 1027,
  kWindowHorizZoomDocumentProc  = 1028,
  kWindowHorizZoomGrowDocumentProc = 1029,
  kWindowFullZoomDocumentProc   = 1030,
  kWindowFullZoomGrowDocumentProc = 1031
};


enum {
                                        /* Proc IDs for theme-savvy dialogs */
  kWindowPlainDialogProc        = 1040,
  kWindowShadowDialogProc       = 1041,
  kWindowModalDialogProc        = 1042,
  kWindowMovableModalDialogProc = 1043,
  kWindowAlertProc              = 1044,
  kWindowMovableAlertProc       = 1045
};


enum {
                                        /* procIDs available from Mac OS 8.1 (Appearance 1.0.1) forward */
  kWindowMovableModalGrowProc   = 1046
};


enum {
                                        /* Proc IDs for top title bar theme-savvy floating windows */
  kWindowFloatProc              = 1057,
  kWindowFloatGrowProc          = 1059,
  kWindowFloatVertZoomProc      = 1061,
  kWindowFloatVertZoomGrowProc  = 1063,
  kWindowFloatHorizZoomProc     = 1065,
  kWindowFloatHorizZoomGrowProc = 1067,
  kWindowFloatFullZoomProc      = 1069,
  kWindowFloatFullZoomGrowProc  = 1071
};


enum {
                                        /* Proc IDs for side title bar theme-savvy floating windows */
  kWindowFloatSideProc          = 1073,
  kWindowFloatSideGrowProc      = 1075,
  kWindowFloatSideVertZoomProc  = 1077,
  kWindowFloatSideVertZoomGrowProc = 1079,
  kWindowFloatSideHorizZoomProc = 1081,
  kWindowFloatSideHorizZoomGrowProc = 1083,
  kWindowFloatSideFullZoomProc  = 1085,
  kWindowFloatSideFullZoomGrowProc = 1087
};


enum {
                                        /* Proc IDs for sheet windows */
  kWindowSheetProc              = 1088, /* available in Mac OS X and CarbonLib 1.3 */
  kWindowSheetAlertProc         = 1120  /* available in Mac OS X 10.1 and CarbonLib 1.3 */
};



/*
 *  Discussion:
 *    Window defproc IDs for simple windows
 */
enum {
                                        /* Proc IDs for simple windows */

  /*
   * A window that has no structure region; the content covers the
   * entire window.
   */
  kWindowSimpleProc             = 1104,

  /*
   * A window that has a 1-pixel black frame as its structure.
   */
  kWindowSimpleFrameProc        = 1105
};


/*
 *  Discussion:
 *    More window defproc IDs.
 */
enum {

  /*
   * Window defproc ID for overlay-class windows.
   */
  kWindowOverlayProc            = 1136
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • System 7 Window Positioning Constants                                              */
/*                                                                                      */
/* Passed into StandardAlert and used in ‘WIND’, ‘DLOG’, and ‘ALRT’ templates           */
/* StandardAlert uses zero to specify the default position. Other calls use zero to     */
/* specify “no position”.  Do not pass these constants to RepositionWindow.  Do not     */
/* store these constants in the BasicWindowDescription of a ‘wind’ resource.            */
/*——————————————————————————————————————————————————————————————————————————————————————*/

enum {
  kWindowNoPosition             = 0x0000,
  kWindowDefaultPosition        = 0x0000, /* used by StandardAlert*/
  kWindowCenterMainScreen       = 0x280A,
  kWindowAlertPositionMainScreen = 0x300A,
  kWindowStaggerMainScreen      = 0x380A,
  kWindowCenterParentWindow     = 0xA80A,
  kWindowAlertPositionParentWindow = 0xB00A,
  kWindowStaggerParentWindow    = 0xB80A,
  kWindowCenterParentWindowScreen = 0x680A,
  kWindowAlertPositionParentWindowScreen = 0x700A,
  kWindowStaggerParentWindowScreen = 0x780A
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Positioning Methods                                                         */
/*                                                                                      */
/* Positioning methods passed to RepositionWindow.                                      */
/* Do not use them in WIND, ALRT, DLOG templates.                                       */
/* Do not confuse these constants with the constants above                              */
/*——————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  WindowPositionMethod
 *  
 *  Summary:
 *    Positioning methods usable with RepositionWindow.
 *  
 *  Discussion:
 *    These constants are for use solely with the RepositionWindow API.
 *    They should not be used in 'WIND', 'ALRT', or 'DLOG' resources.
 */
typedef UInt32 WindowPositionMethod;
enum {

  /*
   * Centers the window on the main screen.
   */
  kWindowCenterOnMainScreen     = 1,

  /*
   * Centers the window on its parent window. The parent window must be
   * different from the positioned window.
   */
  kWindowCenterOnParentWindow   = 2,

  /*
   * Centers the window on the screen containing the largest portion of
   * its parent window. On Mac OS X 10.3 and later, the parent window
   * may be the same as the positioned window. On CarbonLib and earlier
   * versions of Mac OS X, the parent window must be different from the
   * positioned window.
   */
  kWindowCenterOnParentWindowScreen = 3,

  /*
   * Cascades the window on the main screen.
   */
  kWindowCascadeOnMainScreen    = 4,

  /*
   * Cascades the window on its parent window. The parent window must
   * be different from the positioned window.
   */
  kWindowCascadeOnParentWindow  = 5,

  /*
   * Cascades the window on the screen containing the largest portion
   * of its parent window. On Mac OS X 10.3 and later, the parent
   * window may be the same as the positioned window. On CarbonLib and
   * earlier versions of Mac OS X, the parent window must be different
   * from the positioned window.
   */
  kWindowCascadeOnParentWindowScreen = 6,

  /*
   * Cascades the window on the screen containing the largest portion
   * of its parent window, starting below and to the right of its
   * parent window. The parent window must be different from the
   * positioned window. Available in Mac OS X 10.2 and CarbonLib 1.6
   * and later.
   */
  kWindowCascadeStartAtParentWindowScreen = 10,

  /*
   * Puts the window into the alert position on the main screen.
   */
  kWindowAlertPositionOnMainScreen = 7,

  /*
   * Puts the window into the alert position on its parent window. The
   * parent window must be different from the positioned window.
   */
  kWindowAlertPositionOnParentWindow = 8,

  /*
   * Puts the window into the alert position on the screen containing
   * the largest portion of its parent window. On Mac OS X 10.3 and
   * later, the parent window may be the same as the positioned window.
   * On CarbonLib and earlier versions of Mac OS X, the parent window
   * must be different from the positioned window.
   */
  kWindowAlertPositionOnParentWindowScreen = 9
};


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • GetWindowRegion Types                                                              */
/*——————————————————————————————————————————————————————————————————————————————————————*/
typedef UInt16                          WindowRegionCode;
enum {
                                        /* Region values to pass into GetWindowRegion & GetWindowBounds. All regions are reported in global coordinates. */
  kWindowTitleBarRgn            = 0,
  kWindowTitleTextRgn           = 1,
  kWindowCloseBoxRgn            = 2,
  kWindowZoomBoxRgn             = 3,
  kWindowDragRgn                = 5,
  kWindowGrowRgn                = 6,
  kWindowCollapseBoxRgn         = 7,
  kWindowTitleProxyIconRgn      = 8,    /* Mac OS 8.5 forward*/
  kWindowStructureRgn           = 32,
  kWindowContentRgn             = 33,   /* Content area of the window; empty when the window is collapsed*/
  kWindowUpdateRgn              = 34,   /* Carbon forward*/
  kWindowOpaqueRgn              = 35,   /* Mac OS X: Area of window considered to be opaque. Only valid for windows with alpha channels.*/
  kWindowGlobalPortRgn          = 40,   /* Carbon forward - bounds of the window’s port in global coordinates; not affected by CollapseWindow*/
  kWindowToolbarButtonRgn       = 41    /* Mac OS X Tiger: the toolbar button area*/
};


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Standard Window Kinds                                                              */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  dialogKind                    = 2,
  userKind                      = 8,
  kDialogWindowKind             = 2,
  kApplicationWindowKind        = 8
};


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • FindWindow Result Codes                                                            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
typedef SInt16 WindowPartCode;
enum {
  inDesk                        = 0,
  inNoWindow                    = 0,
  inMenuBar                     = 1,
  inSysWindow                   = 2,
  inContent                     = 3,
  inDrag                        = 4,
  inGrow                        = 5,
  inGoAway                      = 6,
  inZoomIn                      = 7,
  inZoomOut                     = 8,
  inCollapseBox                 = 11,   /* Mac OS 8.0 forward*/
  inProxyIcon                   = 12,   /* Mac OS 8.5 forward*/
  inToolbarButton               = 13,   /* Mac OS X forward*/
  inStructure                   = 15    /* Mac OS X 10.1 forward*/
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Definition Hit Test Result Codes                                            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
typedef SInt16 WindowDefPartCode;
enum {
  wNoHit                        = 0,
  wInContent                    = 1,
  wInDrag                       = 2,
  wInGrow                       = 3,
  wInGoAway                     = 4,
  wInZoomIn                     = 5,
  wInZoomOut                    = 6,
  wInCollapseBox                = 9,    /* Mac OS 8.0 forward*/
  wInProxyIcon                  = 10,   /* Mac OS 8.5 forward*/
  wInToolbarButton              = 11,   /* Mac OS X forward*/
  wInStructure                  = 13    /* Mac OS X 10.1 forward*/
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Feature Bits                                                                */
/*——————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  Summary:
 *    Window feature bits
 *  
 *  Discussion:
 *    These feature bits are supplied by window definition functions in
 *    response to the kWindowMsgGetFeatures message or the
 *    kEventWindowInit Carbon event. A window's feature bits can also
 *    be modified dynamically using the HIWindowChangeFeatures API;
 *    typically, feature bits are only modified by a window definition
 *    or window frame view.
 */
enum {

  /*
   * Indicates whether the window is resizable. Available on Mac OS 8.0
   * and later. Not supported on Mac OS X; replaced by
   * kWindowResizableAttribute.
   */
  kWindowCanGrow                = (1 << 0),

  /*
   * Indicates whether the window can zoom. Available on Mac OS 8.0 and
   * later. Not supported on Mac OS X; replaced by
   * kWindowHorizontal/Vertical/FullZoomAttribute.
   */
  kWindowCanZoom                = (1 << 1),

  /*
   * Indicates whether the window can be minimized. Available on Mac OS
   * 8.0 and later. Not supported on Mac OS X; replaced by
   * kWindowCollapseBoxAttribute.
   */
  kWindowCanCollapse            = (1 << 2),

  /*
   * Indicates whether the window is application-modal. Available on
   * Mac OS 8.0 and later.
   */
  kWindowIsModal                = (1 << 3),

  /*
   * Indicates that the window definition supports the
   * kWindowMsgGetRegion message. Available on Mac OS 8.0 and later.
   * Not supported on Mac OS X. All window definitions that implement
   * the kWindowMsgGetFeatures message automatically get this feature
   * bit on Mac OS X.
   */
  kWindowCanGetWindowRegion     = (1 << 4),

  /*
   * Indicates whether the window is an alert. Available on Mac OS 8.0
   * and later.
   */
  kWindowIsAlert                = (1 << 5),

  /*
   * Indicates whether the window has a title bar. Available on Mac OS
   * 8.0 and later. This feature is required for async dragging to be
   * enabled for a window.
   */
  kWindowHasTitleBar            = (1 << 6),

  /*
   * Indicates that the window definition supports the
   * kWindowMsgDragHilite message. Available on Mac OS 8.5 and later.
   */
  kWindowSupportsDragHilite     = (1 << 7),

  /*
   * Indicates that the window definition supports the
   * kWindowMsgModified message. Available on Mac OS 8.5 and later.
   */
  kWindowSupportsModifiedBit    = (1 << 8),

  /*
   * Indicates that the window definition supports the
   * kWindowMsgDrawInCurrentPort message. Available on Mac OS 8.5 and
   * later. Not supported on Mac OS X.
   */
  kWindowCanDrawInCurrentPort   = (1 << 9),

  /*
   * Indicates that the window definition supports the
   * kWindowMsgSetupProxyDragImage message. Available on Mac OS 8.5 and
   * later.
   */
  kWindowCanSetupProxyDragImage = (1 << 10),

  /*
   * Indicates that the window definition supports the
   * kWindowMsgMeasureTitle message. Available on Mac OS 8.5 and later.
   */
  kWindowCanMeasureTitle        = (1 << 11),

  /*
   * Indicates that the window definition wants to receive a
   * kWindowMsgCleanUp message for each existing window when a process
   * is terminated. Available on Mac OS 8.5 and later. Not supported on
   * Mac OS X.
   */
  kWindowWantsDisposeAtProcessDeath = (1 << 12),

  /*
   * Indicates that the window definition supports the
   * kWindowMsgGetGrowImageRegion message. Available on Mac OS X 10.0
   * and later.
   */
  kWindowSupportsGetGrowImageRegion = (1 << 13),

  /*
   * Indicates that the window is entirely opaque. If this feature bit
   * is set, the window will use less memory because no alpha channel
   * information will be stored for the window's pixels. If this
   * feature bit is not set, the Window Manager will send a
   * kEventWindowGetRegion Carbon event to the window with the
   * kWindowOpaqueRgn constant to get a region that describes the
   * opaque area of the window. Available on Mac OS X 10.1 and later.
   */
  kWindowIsOpaque               = (1 << 14),

  /*
   * Indicates that the window definition does not require that the
   * current port be the classic Window Manager port. Not supported on
   * Mac OS X.
   */
  kWindowDefSupportsColorGrafPort = 0x40000002
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Region Dragging Constants                                                         */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  kMouseUpOutOfSlop             = (int)0x80008000
};


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Class Ordering                                                              */
/*                                                                                      */
/*  Special cases for the “behind” parameter in window creation calls.                  */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#define kFirstWindowOfClass             ((WindowRef)(-1))
#define kLastWindowOfClass              ((WindowRef)0)

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Zoom Information Handle                                                            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
struct WStateData {
  Rect                userState;              /*user zoom state*/
  Rect                stdState;               /*standard zoom state*/
};
typedef struct WStateData               WStateData;
typedef WStateData *                    WStateDataPtr;
typedef WStateDataPtr *                 WStateDataHandle;
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window definition function                                                         */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#if __LP64__
typedef void *                          WindowDefUPP;
#else

/*
 *  WindowDefProcPtr
 *  
 *  Summary:
 *    Callback function for a custom window definition.
 */
typedef CALLBACK_API( long , WindowDefProcPtr )(short varCode, WindowRef window, short message, long param);
typedef STACK_UPP_TYPE(WindowDefProcPtr)                        WindowDefUPP;
/*
 *  NewWindowDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern WindowDefUPP
NewWindowDefUPP(WindowDefProcPtr userRoutine)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  DisposeWindowDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeWindowDefUPP(WindowDefUPP userUPP)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  InvokeWindowDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern long
InvokeWindowDefUPP(
  short         varCode,
  WindowRef     window,
  short         message,
  long          param,
  WindowDefUPP  userUPP)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

#if __MACH__
  #ifdef __cplusplus
    inline WindowDefUPP                                         NewWindowDefUPP(WindowDefProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeWindowDefUPP(WindowDefUPP) { }
    inline long                                                 InvokeWindowDefUPP(short varCode, WindowRef window, short message, long param, WindowDefUPP userUPP) { return (*userUPP)(varCode, window, message, param); }
  #else
    #define NewWindowDefUPP(userRoutine)                        ((WindowDefUPP)userRoutine)
    #define DisposeWindowDefUPP(userUPP)
    #define InvokeWindowDefUPP(varCode, window, message, param, userUPP) (*userUPP)(varCode, window, message, param)
  #endif
#endif

#endif  /* __LP64__ */

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Definition Spec.  Used in Carbon to specify the code that defines a window. */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  kWindowDefProcPtr             = 0,    /* raw proc-ptr based access*/
  kWindowDefObjectClass         = 1,    /* event-based definition using a ToolboxObjectClassRef (Carbon 1.1 or later)*/
  kWindowDefProcID              = 2,    /* explicit proc ID; overrides the window class default proc ID*/
  kWindowDefHIView              = 3     /* this window uses an HIView as its frame, not a WDEF*/
};

typedef UInt32                          WindowDefType;
struct WindowDefSpec {
  WindowDefType       defType;
  union {
    WindowDefUPP        defProc;
    void *              classRef;             /* ToolboxObjectClassRef*/
    short               procID;
    void *              rootView;             /* HIViewRef*/
  }                       u;
};
typedef struct WindowDefSpec            WindowDefSpec;
typedef WindowDefSpec *                 WindowDefSpecPtr;
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Creation & Persistence                                                      */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
    About Window Manager Coordinate Spaces
    
    All Window Manager API that takes a size, position, or rectangle for input, and does not take an
    HICoordinateSpace parameter, expects that its input parameters are given in the 72DPIGlobal coordinate
    space. Likewise, any API that returns a rect or region and that does not take an HICoordinateSpace
    parameter will provide its output in the 72DPIGlobal coordinate space.
    
    We expect that most developers will want to work primarily in the 72DPIGlobal space. Doing so makes
    your code independent of the current user interface scale factor, and eases source compatibility with
    earlier versions of Mac OS X that do not support resolution independence. However, there are also certain
    cases where your application must express your window's bounds in pixel coordinates; primarily when you
    need to position your windows so they exactly align with each other or with some other fixed location,
    such as the edge of the display. For these cases, you should use the ScreenPixel coordinate space.
    
    Note that non-integral pixel coordinates are not available in Mac OS X. If you specify non-integral
    coordinates (in either 72DPIGlobal or ScreenPixel coordinate spaces), they will be rounded to the nearest
    integral value in ScreenPixel space when the window is actually positioned or sized.
*/
#if !__LP64__
/*
 *  HIWindowCreate()
 *  
 *  Summary:
 *    Creates a new window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inClass:
 *      The window class.
 *    
 *    inAttributes:
 *      A zero-terminated array of attribute bit constants, such as
 *      kHIWindowBitCloseBox. Each array entry specifies an attribute
 *      of the window to set. You may pass NULL if you do not wish to
 *      set any attributes.
 *    
 *    inDefSpec:
 *      Contains a custom window proc ID or root view for the window.
 *      May be NULL if you don't need to customize the window.
 *    
 *    inSpace:
 *      The coordinate space of the inBounds parameter. This parameter
 *      must be either kHICoordSpaceScreenPixels or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    inBounds:
 *      The window content bounds, in the coordinate space specified by
 *      the inSpace parameter. ••• consider changing this to structure
 *      bounds?
 *    
 *    outWindow:
 *      On exit, contains the new window.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowCreate(
  WindowClass            inClass,
  const int *            inAttributes,
  const WindowDefSpec *  inDefSpec,
  HICoordinateSpace      inSpace,
  const HIRect *         inBounds,
  WindowRef *            outWindow)                           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
   Routines available from Mac OS 8.5 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/

/*
 *  CreateNewWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
CreateNewWindow(
  WindowClass        windowClass,
  WindowAttributes   attributes,
  const Rect *       contentBounds,
  WindowRef *        outWindow)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DisposeWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
DisposeWindow(WindowRef window)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Custom Windows                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* Routines available from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward*/

/*
 *  CreateCustomWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CreateCustomWindow(
  const WindowDefSpec *  def,
  WindowClass            windowClass,
  WindowAttributes       attributes,
  const Rect *           contentBounds,
  WindowRef *            outWindow)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ReshapeCustomWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ReshapeCustomWindow(WindowRef window)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RegisterWindowDefinition()
 *  
 *  Summary:
 *    Registers or unregisters a binding between a resource ID and a
 *    window definition function.
 *  
 *  Discussion:
 *    In the Mac OS 8.x Window Manager, a 'WIND' resource can contain
 *    an embedded WDEF procID that is used by the Window Manager as the
 *    resource ID of an 'WDEF' resource to lay out and draw the window.
 *    The 'WDEF' resource is loaded by the Window Manager when you load
 *    the menu with GetNewWindow. Since WDEFs can no longer be packaged
 *    as code resources on Carbon, the procID can no longer refer
 *    directly to a WDEF resource. However, using
 *    RegisterWindowDefinition you can instead specify a
 *    UniversalProcPtr pointing to code in your application code
 *    fragment. 
 *    
 *    RegisterWindowDefinition is available when linking to CarbonLib
 *    1.1 forward. 
 *    
 *    RegisterWindowDefinition is not available in 64-bit mode because
 *    WDEFs and ToolboxObjects are not supported in 64-bit mode.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inResID:
 *      A WDEF proc ID, as used in a 'WIND' resource.
 *    
 *    inDefSpec:
 *      Specifies the WindowDefUPP or ToolboxObjectClassRef that should
 *      be used for windows with the given WDEF proc ID. Passing NULL
 *      allows you to unregister the window definition that had been
 *      associated with the given WDEF proc ID.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
RegisterWindowDefinition(
  SInt16                 inResID,
  const WindowDefSpec *  inDefSpec)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window part tracking                                                               */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  GetWindowWidgetHilite()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowWidgetHilite(
  WindowRef            inWindow,
  WindowDefPartCode *  outHilite)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Metainformation Accessors                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  IsValidWindowClass()
 *  
 *  Summary:
 *    Indicates whether a window class is supported by the Window
 *    Manager.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inClass:
 *      The window class.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsValidWindowClass(WindowClass inClass)                       AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;


/*
 *  HIWindowTestAttribute()
 *  
 *  Summary:
 *    Determines whether a window possesses a specified attribute.
 *  
 *  Discussion:
 *    HIWindowTestAttribute takes an attribute bit constant, such as
 *    kHIWindowBitCloseBox. You must not use the older attribute
 *    bitmask constants, such as kWindowCloseBoxAttribute, with this
 *    API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose attributes to test.
 *    
 *    inAttr:
 *      The attribute bit constant to test.
 *  
 *  Result:
 *    True if the window possesses the specified attribute, or false if
 *    not.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIWindowTestAttribute(
  WindowRef   inWindow,
  int         inAttr)                                         AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowChangeAttributes()
 *  
 *  Summary:
 *    Changes the attributes of a window.
 *  
 *  Discussion:
 *    HIWindowChangeAttributes takes two arrays of attribute bit
 *    constants, such as kHIWindowBitCloseBox. You must not use the
 *    older attribute bitmask constants, such as
 *    kWindowCloseBoxAttribute, with this API. The first array
 *    specifies the attributes to set, and the second specifies the
 *    attributes to clear. For example, you might call this API as
 *    follows: 
 *    
 *    int setAttr[] = { kHIWindowBitCloseBox, kHIWindowBitZoomBox, 0
 *    };
 *    int clearAttr[] = { kHIWindowBitNoTitleBar, 0 };
 *     HIWindowChangeAttributes( window, setAttr, clearAttr );
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose attributes to change.
 *    
 *    inAttrToSet:
 *      A zero-terminated array of attribute bit constants, such as
 *      kHIWindowBitCloseBox. Each array entry specifies an attribute
 *      of the window to set. You may pass NULL if you do not wish to
 *      set any attributes.
 *    
 *    inAttrToClear:
 *      A zero-terminated array of attribute bit constants, such as
 *      kHIWindowBitCloseBox. Each array entry specifies an attribute
 *      of the window to clear. You may pass NULL if you do not wish to
 *      clear any attributes.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowChangeAttributes(
  WindowRef    inWindow,
  const int *  inAttrToSet,         /* can be NULL */
  const int *  inAttrToClear)       /* can be NULL */         AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowIsAttributeAvailable()
 *  
 *  Summary:
 *    Determines if a window attribute is valid for a specified window
 *    class.
 *  
 *  Discussion:
 *    This API is useful because some window classes support different
 *    attributes on different platforms (for example, floating windows
 *    can have collapse boxes on 9, but not on X), and the Window
 *    Manager will return an error if you attempt to create a window
 *    with attributes that aren't supported for the requested window
 *    class. You can use this API to remove attributes that are not
 *    supported by the current platform before calling CreateNewWindow.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inClass:
 *      The window class.
 *    
 *    inAttr:
 *      The window attribute bit. You must use an attribute bit
 *      constant, such as kHIWindowBitCloseBox. You must not use the
 *      older attribute bitmask constants, such as
 *      kWindowCloseBoxAttribute.
 *  
 *  Result:
 *    True if the attribute is available for windows of the specifed
 *    class, or false if not.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIWindowIsAttributeAvailable(
  WindowClass   inClass,
  int           inAttr)                                       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  GetAvailableWindowAttributes()
 *  
 *  Summary:
 *    Returns the window attributes that are valid for a window class.
 *  
 *  Discussion:
 *    This API is useful because some window classes support different
 *    attributes on different platforms (for example, floating windows
 *    can have collapse boxes on 9, but not on X), and the Window
 *    Manager will return an error if you attempt to create a window
 *    with attributes that aren't supported for the requested window
 *    class. You can use this API to remove attributes that are not
 *    supported by the current platform before calling CreateNewWindow.
 *    
 *    
 *    In Mac OS X 10.5 and later, windows may have more than 32 bits of
 *    attributes. GetAvailableWindowAttributes can only return the low
 *    32 bits of window attributes; therefore, we recommend that you
 *    use HIWindowIsAttributeAvailable instead of
 *    GetAvailableWindowAttributes.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inClass:
 *      The window class.
 *  
 *  Result:
 *    The window attributes that are supported for the specified window
 *    class.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowAttributes 
GetAvailableWindowAttributes(WindowClass inClass)             AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;


/*
 *  GetWindowClass()
 *  
 *  Summary:
 *    Returns the class of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose class to retrieve.
 *    
 *    outClass:
 *      On exit, contains the window's class.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowClass(
  WindowRef      window,
  WindowClass *  outClass)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowAttributes()
 *  
 *  Summary:
 *    Returns the attributes of a window.
 *  
 *  Discussion:
 *    In Mac OS X 10.5 and later, windows may have more than 32 bits of
 *    attributes. GetWindowAttributes can only return the low 32 bits
 *    of window attributes; therefore, we recommend that you use
 *    HIWindowTestAttribute instead of GetWindowAttributes.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose attributes to retrieve.
 *    
 *    outAttributes:
 *      On exit, contains the window's attributes.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowAttributes(
  WindowRef           window,
  WindowAttributes *  outAttributes)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ChangeWindowAttributes()
 *  
 *  Summary:
 *    Sets and clears window attributes.
 *  
 *  Discussion:
 *    In Mac OS X 10.5 and later, windows may have more than 32 bits of
 *    attributes. ChangeWindowAttributes can only set or clear the low
 *    32 bits of window attributes; therefore, we recommend that you
 *    use HIWindowChangeAttributes instead of ChangeWindowAttributes.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose attributes to modify.
 *    
 *    setTheseAttributes:
 *      The attributes to set.
 *    
 *    clearTheseAttributes:
 *      The attributes to clear.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ChangeWindowAttributes(
  WindowRef          window,
  WindowAttributes   setTheseAttributes,
  WindowAttributes   clearTheseAttributes)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowChangeClass()
 *  
 *  Summary:
 *    Changes the window look and feel of an existing window on the fly.
 *  
 *  Discussion:
 *    HIWindowChangeClass changes the class of a window. Unlike
 *    SetWindowClass, this call effectively changes the look and
 *    behavior of the window all at once. Because SetWindowClass
 *    already existed and had certain behaviour, we could not change it
 *    to behave the way HIWindowChangeClass does. 
 *    
 *    This function can convert a window between kDocumentWindowClass,
 *    kFloatingWindowClass, kUtilityWindowClass, and
 *    kMovableModalWindowClass only. It cannot change a document window
 *    into a plain window, for example. 
 *    
 *    The attributes of the window are adjusted to contain only those
 *    that are allowed for the new class. It is the caller’s
 *    responsibility to adjust them further after HIWindowChangeClass
 *    returns, if necessary.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose class to change.
 *    
 *    inWindowClass:
 *      The new window class.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowChangeClass(
  WindowRef     inWindow,
  WindowClass   inWindowClass)                                AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;


#endif  /* !__LP64__ */

#if !__LP64__
/*
 *  HIWindowGetCGWindowID()
 *  
 *  Summary:
 *    Returns the CoreGraphics window ID assigned by the window server
 *    when a window was created.
 *  
 *  Discussion:
 *    The window ID is not generally useful with other Carbon API, but
 *    may be usable with other Mac OS X APIs that require window IDs,
 *    such as OpenGL. You may convert a window ID back to a WindowRef
 *    using the HIWindowFromCGWindowID API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose window ID to return.
 *  
 *  Result:
 *    The window's window ID, or zero if the window is invalid.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CGWindowID 
HIWindowGetCGWindowID(WindowRef inWindow)                     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowFromCGWindowID()
 *  
 *  Summary:
 *    Returns the window in the current process with a specified
 *    CGWindowID, if any.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindowID:
 *      A CoreGraphics window ID, as returned by HIWindowGetCGWindowID
 *      or CGWindowListCopyWindowInfo.
 *  
 *  Result:
 *    The WindowRef with the specified window ID, or NULL if no such
 *    window is found. A valid window ID for a window in another
 *    process will cause a NULL return value, since WindowRefs cannot
 *    be used across processes.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
HIWindowFromCGWindowID(CGWindowID inWindowID)                 AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Window Flushing                                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIWindowFlush()
 *  
 *  Summary:
 *    Flushes any dirty areas a window might have.
 *  
 *  Discussion:
 *    This routine allows you to manually flush dirty areas of a window
 *    to the screen. If called on a composited window, it will also
 *    cause invalid views in the window to be rendered. This API is
 *    preferred over calling QDFlushPortBuffer.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to flush.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowFlush(WindowRef inWindow)                             AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Window Backing Store Location                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Window backing buffer location constants are used with the
 *    HIWindowGet/SetBackingLocation APIs.
 */
enum {

  /*
   * The window server determines where to locate the window's backing
   * buffer.
   */
  kHIWindowBackingLocationDefault = 0,

  /*
   * The window's backing buffer is stored in video memory. In this
   * case, only Quartz may be used to draw into the window. Use of
   * QuickDraw or direct access will force the window's buffer back
   * into main memory.
   */
  kHIWindowBackingLocationVideoMemory = 1,

  /*
   * The window's backing buffer is stored in main memory. In this
   * case, Quartz, QuickDraw, and direct access are all allowed for
   * drawing into the window.
   */
  kHIWindowBackingLocationMainMemory = 2
};

typedef UInt32                          HIWindowBackingLocation;
#if !__LP64__
/*
 *  HIWindowSetBackingLocation()
 *  
 *  Summary:
 *    Sets the preferred location for a window's backing buffer.
 *  
 *  Discussion:
 *    In Mac OS X 10.5, the Quartz drawing API supports
 *    hardware-accelerated drawing to a window. In order to enable
 *    hardware acceleration, a window's buffer must be stored in video
 *    memory, rather than in main memory. By default, the location of a
 *    window's buffer is managed automatically by the Window Server.
 *    Your application can use this API to explicitly control a
 *    window's buffer location. You might, for example, need to ensure
 *    that the buffer is kept in main memory if you are drawing
 *    directly into the buffer without using Quartz. You might
 *    explicitly force a window's buffer into video memory if, after
 *    comparing performance with and without hardware acceleration, you
 *    find that acceleration is always a performance advantage for your
 *    application. 
 *    
 *    You may change the backing buffer location of a window at any
 *    time, regardless of whether the window is already visible or has
 *    been drawn to. However, changing the buffer location of a visible
 *    window requires a potentially significant amount of memory
 *    traffic between main and video memory, so it is best to set a
 *    window's buffer location once before showing the window, and not
 *    change it again. 
 *    
 *    The Window Server automatically moves a window's backing buffer
 *    into main memory if the buffer is accessed directly. This occurs
 *    if you draw into a window using QuickDraw, or if you acquire a
 *    pointer to the window buffer using the LockPortBits API. For best
 *    performance, if you know that you will be accessing a window's
 *    buffer using either QuickDraw or direct access, you should force
 *    the window's buffer into main memory before showing the window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose backing buffer location to set.
 *    
 *    inLocation:
 *      The window's new backing buffer location. You may pass
 *      kHIWindowBackingLocationDefault to allow the Window Server to
 *      determine the buffer location automatically.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetBackingLocation(
  WindowRef                 inWindow,
  HIWindowBackingLocation   inLocation)                       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowGetBackingLocation()
 *  
 *  Summary:
 *    Retrieves the preferred location of a window's backing buffer,
 *    and its potential location based on hardware and software
 *    configuration.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose backing buffer location to retrieve.
 *    
 *    outPreferredLocation:
 *      On exit, contains the preferred location for the window's
 *      backing buffer. A newly created window's preferred location is
 *      kHIWindowBackingLocationDefault. If HIWindowSetBackingLocation
 *      has been called on a window, this parameter returns the value
 *      that was set. You may pass NULL if you don't need this
 *      information.
 *  
 *  Result:
 *    The potential location of the window's backing buffer based on
 *    hardware and software configuration. This value indicates whether
 *    the WindowServer is capable of storing the window's buffer in
 *    video or main memory. The determination is based on details of
 *    the current hardware and software configuration, such as whether
 *    the GPU can be used by the WindowServer to store window buffers
 *    and whether the QuartzGL feature is currently enabled for the
 *    entire system or the current application. The return value will
 *    always be either kHIWindowBackingLocationVideoMemory or
 *    kHIWindowBackingLocationMainMemory; it will never be
 *    kHIWindowBackingLocationDefault. Your application can use the
 *    return value to determine if the current system configuration is
 *    fast enough to support your desired level of drawing; if, after
 *    performance measurements, you determine that your software
 *    requires video-memory storage of window buffers for acceptable
 *    performance, you might alert the user if this function returns
 *    kHIWindowBackingLocationMainMemory. 
 *    
 *    Note that the return value does not indicate the current location
 *    of the window's backing buffer, only its potential location. The
 *    current location can change from one moment to the next. Your
 *    application generally only needs to know the capability for
 *    storing the backing buffer in video memory, not the actual
 *    current location.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern HIWindowBackingLocation 
HIWindowGetBackingLocation(
  WindowRef                  inWindow,
  HIWindowBackingLocation *  outPreferredLocation)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Window Buffer Visibility To Other Processes                                       */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Window sharing constants are used with the
 *    HIWindowGet/SetSharingType APIs.
 */
enum {

  /*
   * Window contents may not be read by another process.
   */
  kHIWindowSharingNone          = 0,

  /*
   * Window contents may be read but not modified by another process.
   */
  kHIWindowSharingReadOnly      = 1,

  /*
   * Window contents may be read or modified by another process.
   */
  kHIWindowSharingReadWrite     = 2
};

typedef UInt32                          HIWindowSharingType;
#if !__LP64__
/*
 *  HIWindowSetSharingType()
 *  
 *  Summary:
 *    Sets the visibility to other processes of a window's backing
 *    buffer contents.
 *  
 *  Discussion:
 *    In Mac OS X 10.5, a window's backing buffer may be retrieved
 *    using the CGWindowListCreateImage and
 *    CGWindowListCreateImageFromArray APIs. Some windows may have
 *    content that should not be accessible via these APIs, due to
 *    security concerns. Your application can use this API to control
 *    how visible a window's backing buffer should be to other
 *    processes. 
 *    
 *    Note that it is also possible to read the entire contents of a
 *    display using OpenGL; setting a window's sharing type with this
 *    API does not prevent OpenGL from being able to read the window's
 *    content. For example, the built-in screen-sharing software in Mac
 *    OS X Mac OS X 10.5 uses OpenGL and a window's content will still
 *    be visible via screen-sharing even if its sharing type has been
 *    set to None. 
 *    
 *    A window's default sharing state on creation is
 *    kHIWindowSharingReadOnly.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose backing buffer visibility to set.
 *    
 *    inType:
 *      The window's new backing buffer visibility.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetSharingType(
  WindowRef             inWindow,
  HIWindowSharingType   inType)                               AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowGetSharingType()
 *  
 *  Summary:
 *    Retrieves the visibility to other processes of a window's backing
 *    buffer contents.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose backing buffer visibility to retrieve.
 *  
 *  Result:
 *    The window's backing buffer visibility.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern HIWindowSharingType 
HIWindowGetSharingType(WindowRef inWindow)                    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Window Modality                                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */


/*
 *  WindowModality
 *  
 */
typedef UInt32 WindowModality;
enum {

  /*
   * A window does not prevent interaction with any other window in the
   * system.
   */
  kWindowModalityNone           = 0,

  /*
   * A window prevents interaction with all other windows in the
   * system. Only available in CarbonLib. Mapped to
   * kWindowModalityAppModal in Mac OS X.
   */
  kWindowModalitySystemModal    = 1,

  /*
   * A window prevents interaction with other windows in the same
   * process.
   */
  kWindowModalityAppModal       = 2,

  /*
   * A window prevents interaction with a single other window.
   */
  kWindowModalityWindowModal    = 3
};


#if !__LP64__
/*
 *  SetWindowModality()
 *  
 *  Summary:
 *    Sets the modality of a window.
 *  
 *  Discussion:
 *    The modality of a window is used by the Carbon event manager to
 *    automatically determine appropriate event handling.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose modality to set.
 *    
 *    inModalKind:
 *      The new modality for the window.
 *    
 *    inUnavailableWindow:
 *      If the window is becoming window-modal, this parameter
 *      specifies the window to which the inWindow parameter is modal.
 *      The unavailableWindow will not be available while inWindow is
 *      in window-modal state.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowModality(
  WindowRef        inWindow,
  WindowModality   inModalKind,
  WindowRef        inUnavailableWindow)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowModality()
 *  
 *  Summary:
 *    Retrieves the modality of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose modality to retrieve.
 *    
 *    outModalKind:
 *      On exit, contains the modality of the window.
 *    
 *    outUnavailableWindow:
 *      On exit, if the window is window-modal, contains the target
 *      window of the specified window's modality.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowModality(
  WindowRef         inWindow,
  WindowModality *  outModalKind,
  WindowRef *       outUnavailableWindow)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowIsDocumentModalTarget()
 *  
 *  Summary:
 *    Determines if a window is currently the target window of another
 *    document modal window, such as a sheet.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window in question.
 *    
 *    outOwner:
 *      If inWindow is the target of a document modal window, outOwner
 *      is set to the document modal window on exit. If this function
 *      does not return true, outOwner is undefined. You may pass NULL
 *      if you don't want the owner's window ref.
 *  
 *  Result:
 *    A boolean result. A true result indicates that inWindow is
 *    currently the target of a document modal window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIWindowIsDocumentModalTarget(
  WindowRef    inWindow,
  WindowRef *  outOwner)       /* can be NULL */              AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Floating Windows                                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
   Routines available from Mac OS 8.6 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/

/*
 *  ShowFloatingWindows()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
ShowFloatingWindows(void)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HideFloatingWindows()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
HideFloatingWindows(void)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  AreFloatingWindowsVisible()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern Boolean 
AreFloatingWindowsVisible(void)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Groups                                                                      */
/*                                                                                      */
/* The Window Group API allows the creation and management of groups of windows,        */
/* allowing control of the z-order, activation, and positioning of the windows.         */
/* Internally to the Window Manager, each of the standard window tiers (document,       */
/* toolbar, floating, modal, utility, help, and overlay) is implemented as a window     */
/* group; you can access the window group for a class with GetWindowGroupOfClass.       */
/* You can create your own window groups, if you would like your windows to float,      */
/* for example, above the floating window layer but below the modal layer. It is        */
/* also possible to create more complex hierarchical arrangements of window groups.     */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */

typedef struct OpaqueWindowGroupRef*    WindowGroupRef;
/* may be passed as the "behindWindow" parameter to NewCWindow and SendBehind*/
#define kFirstWindowOfGroup             ((WindowRef)(-1))
#define kLastWindowOfGroup              ((WindowRef)NULL)
/* may be passed as the "behindGroup" parameter to SendWindowGroupBehind*/
#define kFirstWindowGroup               ((WindowGroupRef)(-1))
#define kLastWindowGroup                ((WindowGroupRef)NULL)

/*
 *  WindowGroupAttributes
 *  
 *  Summary:
 *    These are attributes that may be applied to a window group.
 */
typedef UInt32 WindowGroupAttributes;
enum {

  /*
   * Makes the group behave somewhat as a layer of windows that move
   * together. When any window in the group is brought to the front of
   * the group, the entire group will also be brought to the front of
   * the containing group's child hierarchy.
   */
  kWindowGroupAttrSelectAsLayer = 1 << 0,

  /*
   * The positions of the contents of this group with respect to each
   * other cannot be changed. When one item moves, all other items are
   * moved simultaneously. Note that when one window in the group is
   * moved, the bounds of the other windows in the group may be updated
   * asynchronously.
   */
  kWindowGroupAttrMoveTogether  = 1 << 1,

  /*
   * The z-order of the contents of this group with respect to each
   * other cannot be changed. When one item changes z-order, all other
   * items are moved simultaneously. For purposes of z-ordering, the
   * group and all its subgroups are effectively treated as if they
   * were a single window in the parent group of this group.
   */
  kWindowGroupAttrLayerTogether = 1 << 2,

  /*
   * The active state of the windows in this group is shared. The
   * windows in the group are activated or deactivated according to the
   * activation scope of the group, but when any window in the group
   * changes activation, all other windows change to match.
   */
  kWindowGroupAttrSharedActivation = 1 << 3,

  /*
   * When any window in this group is collapsed, all other windows in
   * this group are hidden. All subgroups of this group are also
   * examined for the HideOnCollapse attribute, and any windows of any
   * subgroup with this attribute are also hidden. All windows will be
   * shown again when the collapsed window is expanded.
   */
  kWindowGroupAttrHideOnCollapse = 1 << 4,

  /*
   * This window group's window level should be left unchanged. If this
   * attribute is not specified, this window group's window level will
   * be promoted to a value equal to the level of the next FixedLevel
   * window group beneath it in the window group hierarchy.
   */
  kWindowGroupAttrFixedLevel    = 1 << 5
};


/*
 *  WindowActivationScope
 *  
 *  Discussion:
 *    Every window has a WindowActivationScope. It defines how windows
 *    are activated by the Window Manager with respect to other windows
 *    in the window’s group and in the current process.
 */
typedef UInt32 WindowActivationScope;
enum {

  /*
   * Windows with this scope are never activated by the Window Manager.
   * This should be used when the window’s visual state does not change
   * based on activation (for example, tooltip windows), or when the
   * client wishes to manually control all activation. The window owner
   * is free to explicitly activate or deactivate windows using the
   * ActivateWindow API.
   */
  kWindowActivationScopeNone    = 0,

  /*
   * Windows with this scope are always active if visible. Windows with
   * this scope are unaffected by the activation state of other
   * windows. This activation scope is automatically used by floating
   * windows.
   */
  kWindowActivationScopeIndependent = 1,

  /*
   * Windows with this scope are activated relative to other windows
   * with the same scope in the current process. Only one window with
   * this scope can be active in the entire process. This activation
   * scope is automatically used by document and dialog windows.
   */
  kWindowActivationScopeAll     = 2
};


/*
 *  Summary:
 *    These are constants that can be used for the inNextGroup
 *    parameter to GetWindowGroupSibling.
 */
enum {

  /*
   * Indicates that GetWindowGroupSibling should return the next deeper
   * sibling group in the z-order.
   */
  kNextWindowGroup              = true,

  /*
   * Indicates that GetWindowGroupSibling should return the next higher
   * sibling group in the z-order.
   */
  kPreviousWindowGroup          = false
};


/*
 *  WindowGroupContentOptions
 *  
 *  Discussion:
 *    Window group contents options are used to control what group
 *    content is counted or returned by the CountWindowGroupContents
 *    and GetWindowGroupContents APIs.
 */
typedef UInt32 WindowGroupContentOptions;
enum {

  /*
   * Indicates that Count/GetWindowGroupContents should return the
   * windows in a group. If this option is not set, these APIs return
   * the groups in a group.
   */
  kWindowGroupContentsReturnWindows = 1 << 0,

  /*
   * Indicates that Count/GetWindowGroupContents should include the
   * contents of groups contained by the specified group. If this
   * option is not set, these APIs only return information about the
   * specified group’s contents.
   */
  kWindowGroupContentsRecurse   = 1 << 1,

  /*
   * Indicates that Count/GetWindowGroupContents should only include
   * visible windows. Only valid when kWindowGroupContentsReturnWindows
   * is specified.
   */
  kWindowGroupContentsVisible   = 1 << 2
};


/*----------------------------------------------------------------------------------*/
/*  • Group creation, destruction, and refcounting                                  */
/*----------------------------------------------------------------------------------*/
#if !__LP64__
/*
 *  CreateWindowGroup()
 *  
 *  Summary:
 *    Creates a new window group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inAttributes:
 *      Attributes for the new window group.
 *    
 *    outGroup:
 *      On exit, contains the new window group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CreateWindowGroup(
  WindowGroupAttributes   inAttributes,
  WindowGroupRef *        outGroup)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RetainWindowGroup()
 *  
 *  Summary:
 *    Increments the refcount of a window group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose refcount to increment.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
RetainWindowGroup(WindowGroupRef inGroup)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ReleaseWindowGroup()
 *  
 *  Summary:
 *    Releases a refcount on a window group. If the refcount goes to
 *    zero, the group is destroyed, and a refcount is released from all
 *    contained objects.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose refcount to decrement.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ReleaseWindowGroup(WindowGroupRef inGroup)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGroupRetainCount()
 *  
 *  Summary:
 *    Returns the refcount of a window group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose refcount to return.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern ItemCount 
GetWindowGroupRetainCount(WindowGroupRef inGroup)             AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;


/*
 *  GetWindowGroupOfClass()
 *  
 *  Summary:
 *    Gets the window group in which windows of a given class are
 *    placed.
 *  
 *  Discussion:
 *    The Window Manager uses window groups internally to manage the
 *    ordering of windows of different classes. In some cases, multiple
 *    classes are placed within the same group; for example, windows
 *    from all of the modal and alert window classes are placed into
 *    the same modal window group. The refcount of the group returned
 *    by this API is not incremented, and the caller does not need to
 *    release the reference.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    windowClass:
 *      The class whose window group to retrieve. You may pass
 *      kAllWindowClasses to retrieve the root window group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowGroupRef 
GetWindowGroupOfClass(WindowClass windowClass)                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*----------------------------------------------------------------------------------*/
/*  • Group name, attributes, and level                                             */
/*----------------------------------------------------------------------------------*/
/*
 *  SetWindowGroupName()
 *  
 *  Summary:
 *    Sets the name of a window group.
 *  
 *  Discussion:
 *    The name of a window group is never displayed to the user.
 *    However, it is displayed by debugging functions such as
 *    DebugPrintWindowGroup. This can be very useful when debugging the
 *    structure of your window groups.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose name to set.
 *    
 *    inName:
 *      The name of the group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowGroupName(
  WindowGroupRef   inGroup,
  CFStringRef      inName)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CopyWindowGroupName()
 *  
 *  Summary:
 *    Returns a copy of the name of a window group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose name to retrieve.
 *    
 *    outName:
 *      On exit, contains the name of the group. It is the caller's
 *      responsibility to release the name.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CopyWindowGroupName(
  WindowGroupRef   inGroup,
  CFStringRef *    outName)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGroupAttributes()
 *  
 *  Summary:
 *    Retrieves the attributes of a window group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose attributes to retrieve.
 *    
 *    outAttributes:
 *      On exit, the group’s attributes.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowGroupAttributes(
  WindowGroupRef           inGroup,
  WindowGroupAttributes *  outAttributes)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ChangeWindowGroupAttributes()
 *  
 *  Summary:
 *    Changes the attributes of a window group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose attributes to change.
 *    
 *    setTheseAttributes:
 *      The attributes to set.
 *    
 *    clearTheseAttributes:
 *      The attributes to clear.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ChangeWindowGroupAttributes(
  WindowGroupRef          inGroup,
  WindowGroupAttributes   setTheseAttributes,
  WindowGroupAttributes   clearTheseAttributes)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowGroupLevel()
 *  
 *  Summary:
 *    Sets the CoreGraphics window group level of windows in a group.
 *    
 *    PLEASE NOTE: Apple does not recommend using this API for most
 *    window-ordering purposes. Rather than explicitly setting the
 *    level of a window group, it is preferable to position the group
 *    in the window group hierarchy so that it is between two standard
 *    groups that bracket the desired window level. Doing so will cause
 *    your group to automatically adopt the window level of the
 *    standard group beneath it. Your code will be more compatible with
 *    future versions of Mac OS X if you avoid setting the window level
 *    of your groups explicitly. 
 *    
 *    The most common case where it is appropriate to explicitly set a
 *    window level for your group is when your group's windows need to
 *    be positioned above or below all windows in the standard window
 *    groups. In these cases, you should position your group in the
 *    group hierarchy above or below all standard groups, and then set
 *    the window group level explicitly, if necessary.
 *  
 *  Discussion:
 *    CoreGraphics windows (used to implement all windows in Carbon and
 *    Cocoa applications on Mac OS X) are divided into layers specified
 *    by a window level. Standard window levels are listed in
 *    <CoreGraphics/CGWindowLevel.h>. By default, a new window group
 *    has a window level of kCGNormalWindowLevel. 
 *    
 *    When a window is placed into a window group, its window level is
 *    determined by the window level of its "base group". This is the
 *    containing group that is a child of the root group. For example,
 *    if group A is a child of the root group, and group B is a child
 *    of group A, and window C is in group B, then window C's base
 *    group is group A, and group A's window level determines the level
 *    of window C. 
 *    
 *    SetWindowGroupLevel only allows changing the window level of
 *    groups that are children of the root group. It returns paramErr
 *    for other groups, since a group that is not a child of the root
 *    group is not a base group and changing its level has no effect.
 *    
 *    
 *    Changing the level of a group also changes the level of all
 *    windows currently contained by the group. 
 *    
 *    In Mac OS X 10.4 and later, SetWindowGroupLevel will set all
 *    three window levels associated with a window group: the Active,
 *    Inactive, and Promoted levels. It will then immediately determine
 *    if the Active level needs to be promoted to a larger value, and
 *    if so, set the Promoted level to that value.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The window group whose level to change.
 *    
 *    inLevel:
 *      The new level for the windows in this group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowGroupLevel(
  WindowGroupRef   inGroup,
  SInt32           inLevel)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGroupLevel()
 *  
 *  Summary:
 *    Gets the CoreGraphics window group level of windows in a group.
 *  
 *  Discussion:
 *    In Mac OS X 10.4 and later, GetWindowGroupLevel will return
 *    either the Promoted window level or the Inactive window level,
 *    depending on whether the application is active or inactive.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The window group whose level to return.
 *    
 *    outLevel:
 *      On exit, contains the window level of the windows in this group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowGroupLevel(
  WindowGroupRef   inGroup,
  SInt32 *         outLevel)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Parameters to GetWindowGroupLevelOfType and
 *    SetWindowGroupLevelOfType
 */
enum {

  /*
   * The window level that is nominally used for windows in the group
   * when the application is active. However, if a group with a higher
   * window level is positioned below group in the window group
   * hierarchy, this group's active level will be promoted to match the
   * level of the group in front of it. You can determine the actual
   * window level in use for a group using the
   * kWindowGroupLevelPromoted constant.
   */
  kWindowGroupLevelActive       = 1,

  /*
   * The window level that is used for windows in the group when the
   * application is inactive.
   */
  kWindowGroupLevelInactive     = 2,

  /*
   * The window level that is actually used for windows in the group
   * when the application is active. This level will either be the same
   * as the Active window level, or will be a larger value to match the
   * level of a group below this group. 
   * 
   * We do not recommend setting the Promoted window level explicitly,
   * because the promoted level is reset by the Window Manager whenever
   * the window group hierarchy structure changes, and therefore any
   * changes that you may make to the promoted level can be
   * overwritten. In general you should only use this API to set the
   * Active and Inactive window levels.
   */
  kWindowGroupLevelPromoted     = 3
};

#if !__LP64__
/*
 *  SetWindowGroupLevelOfType()
 *  
 *  Summary:
 *    Sets a CoreGraphics window group level of a window group.
 *    
 *    
 *    PLEASE NOTE: Apple does not recommend using this API for most
 *    window-ordering purposes. Rather than explicitly setting the
 *    level of a window group, it is preferable to position the group
 *    in the window group hierarchy so that it is between two standard
 *    groups that bracket the desired window level. Doing so will cause
 *    your group to automatically adopt the window level of the
 *    standard group beneath it. Your code will be more compatible with
 *    future versions of Mac OS X if you avoid setting the window level
 *    of your groups explicitly. 
 *    
 *    The most common case where it is appropriate to explicitly set a
 *    window level for your group is when your group's windows need to
 *    be positioned above or below all windows in the standard window
 *    groups. In these cases, you should position your group in the
 *    group hierarchy above or below all standard groups, and then set
 *    the window group level explicitly, if necessary.
 *  
 *  Discussion:
 *    See the SetWindowGroupLevel API for a general discussion of
 *    window levels and window groups. 
 *    
 *    In Mac OS X 10.4 and later, a window group may have multiple
 *    window levels associated with it; one level for when the
 *    application is active, and another for when the application is
 *    inactive. The Window Manager automatically switches each group's
 *    level as the application becomes active or inactive. This API can
 *    be used to set each level associated with a group. 
 *    
 *    This API can also be used to set the promoted window level that
 *    is actually used for windows in the group; however, we do not
 *    recommend this usage, because the promoted window level is reset
 *    by the Window Manager whenever the window group hierarchy
 *    structure changes, and therefore any changes that you may make to
 *    the promoted level can be overwritten. In general you should only
 *    use this API to set the Active and Inactive window levels.
 *    
 *    
 *    When setting the Active level of a group with the FixedLevel
 *    window group attribute, this API will automatically also set the
 *    Promoted level to the same value, and also update the Promoted
 *    level of any non-FixedLevel groups above the group being modified.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The window group whose level to change.
 *    
 *    inLevelType:
 *      The level type to change (one of kWindowGroupLevelActive,
 *      kWindowGroupLevelInactive, or kWindowGroupLevelPromoted).
 *    
 *    inLevel:
 *      The new level for the windows in this group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowGroupLevelOfType(
  WindowGroupRef   inGroup,
  UInt32           inLevelType,
  CGWindowLevel    inLevel)                                   AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  GetWindowGroupLevelOfType()
 *  
 *  Summary:
 *    Gets a CoreGraphics window level of a window group.
 *  
 *  Discussion:
 *    See the SetWindowGroupLevel API for a general discussion of
 *    window levels and window groups. 
 *    
 *    In Mac OS X 10.4 and later, a window group may have multiple
 *    window levels associated with it; one level for when the
 *    application is active, and another for when the application is
 *    inactive. The Window Manager automatically switches each group's
 *    level as the application becomes active or inactive. The
 *    GetWindowGroupLevelOfType API can be used to get each level
 *    associated with a group, including the promoted window level that
 *    is actually in use for windows in the group while the application
 *    is active.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The window group whose level to retrieve.
 *    
 *    inLevelType:
 *      The level type to retrieve (one of kWindowGroupLevelActive,
 *      kWindowGroupLevelInactive, or kWindowGroupLevelPromoted).
 *    
 *    outLevel:
 *      On exit, the level for the windows in this group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowGroupLevelOfType(
  WindowGroupRef   inGroup,
  UInt32           inLevelType,
  CGWindowLevel *  outLevel)                                  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/*----------------------------------------------------------------------------------*/
/*  • Group z-ordering                                                              */
/*----------------------------------------------------------------------------------*/
/*
 *  SendWindowGroupBehind()
 *  
 *  Summary:
 *    Changes the z-order of a group, if the group does not have the
 *    kWindowGroupAttributeLayerTogether attribute set.
 *  
 *  Discussion:
 *    SendWindowGroupBehind currently requires that the group being
 *    moved and the behindGroup have the same parent group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose z-order to change.
 *    
 *    behindGroup:
 *      The group behind which to position the specified group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SendWindowGroupBehind(
  WindowGroupRef   inGroup,
  WindowGroupRef   behindGroup)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*----------------------------------------------------------------------------------*/
/*  • Group containment hierarchy manipulation                                      */
/*----------------------------------------------------------------------------------*/
/*
 *  GetWindowGroup()
 *  
 *  Summary:
 *    Gets the window group that contains a window.
 *  
 *  Discussion:
 *    The refcount of the group returned by this API is not
 *    incremented, and the caller does not need to release the
 *    reference.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose containing group to retrieve.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowGroupRef 
GetWindowGroup(WindowRef inWindow)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowGroup()
 *  
 *  Summary:
 *    Sets the window group that contains a window.
 *  
 *  Discussion:
 *    The window’s z-order relative to windows in the current process
 *    may also be changed by this API. If the new window group is
 *    z-ordered above the window’s current group, the window will be
 *    placed at the end of the new group. If the new window group is
 *    z-ordered below the window’s current group, the window will be
 *    placed at the top of the new group. You may not place a window
 *    directly into the root group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose group to change.
 *    
 *    inNewGroup:
 *      The new containing group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowGroup(
  WindowRef        inWindow,
  WindowGroupRef   inNewGroup)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsWindowContainedInGroup()
 *  
 *  Summary:
 *    Indicates whether a window is contained within a group or any of
 *    its subgroups.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose containment to examine.
 *    
 *    inGroup:
 *      The group that might contain the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsWindowContainedInGroup(
  WindowRef        inWindow,
  WindowGroupRef   inGroup)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGroupParent()
 *  
 *  Summary:
 *    Gets the window group that contains a group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose containing group to retrieve.
 *    
 *    outGroup:
 *      On exit, the containing window group of the group. The group’s
 *      refcount is not incremented by this API, and the caller does
 *      not need to release the reference.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowGroupRef 
GetWindowGroupParent(WindowGroupRef inGroup)                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowGroupParent()
 *  
 *  Summary:
 *    Sets the window group that contains a group.
 *  
 *  Discussion:
 *    SetWindowGroupParent currently requires that the group have no
 *    windows in it.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose containing group to change.
 *    
 *    inNewGroup:
 *      The new containing group.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowGroupParent(
  WindowGroupRef   inGroup,
  WindowGroupRef   inNewGroup)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGroupSibling()
 *  
 *  Summary:
 *    Returns the next or previous group of a window group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose sibling to return.
 *    
 *    inNextGroup:
 *      True to return the next sibling, false to return the previous
 *      sibling.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowGroupRef 
GetWindowGroupSibling(
  WindowGroupRef   inGroup,
  Boolean          inNextGroup)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGroupOwner()
 *  
 *  Summary:
 *    Returns the window that owns a window group, or NULL if none.
 *  
 *  Discussion:
 *    A window may own one or more window groups. The windows in an
 *    owned window group will always be z-ordered above the owner
 *    window. Whenever the owner window changes z-order, the windows in
 *    the groups owned by the window will be moved also.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose owner to retrieve.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
GetWindowGroupOwner(WindowGroupRef inGroup)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowGroupOwner()
 *  
 *  Summary:
 *    Sets the window that owns a window group.
 *  
 *  Discussion:
 *    The group and the window must have the same parent group.
 *    SetWindowGroupOwner currently requires that the group have no
 *    windows in it.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose owner to set.
 *    
 *    inWindow:
 *      The group's new owner.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowGroupOwner(
  WindowGroupRef   inGroup,
  WindowRef        inWindow)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*----------------------------------------------------------------------------------*/
/*  • Inspection of group contents                                                  */
/*----------------------------------------------------------------------------------*/

/*
 *  CountWindowGroupContents()
 *  
 *  Summary:
 *    Counts the windows or groups contained in a group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose contents to count.
 *    
 *    inOptions:
 *      Specifies how to count the group’s contents.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern ItemCount 
CountWindowGroupContents(
  WindowGroupRef              inGroup,
  WindowGroupContentOptions   inOptions)                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGroupContents()
 *  
 *  Summary:
 *    Retrieves the windows or groups contained in a group.
 *  
 *  Discussion:
 *    The windows or groups returned by this API will be placed into
 *    the output buffer in z-order, from highest to lowest.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group whose contents to retrieve.
 *    
 *    inOptions:
 *      Specifies which content to retrieve.
 *    
 *    inAllowedItems:
 *      The number of items that will fit in the output buffer.
 *    
 *    outNumItems:
 *      On exit, the number of items that were returned. May be NULL.
 *    
 *    outItems:
 *      On entry, points to enough memory to hold inAllowedSize
 *      WindowRefs or WindowGroupRefs. On exit, contains *outNumItems
 *      WindowRefs or WindowGroupRefs.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowGroupContents(
  WindowGroupRef              inGroup,
  WindowGroupContentOptions   inOptions,
  ItemCount                   inAllowedItems,
  ItemCount *                 outNumItems,          /* can be NULL */
  void **                     outItems)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetIndexedWindow()
 *  
 *  Summary:
 *    Retrieves a specified window from a group.
 *  
 *  Discussion:
 *    GetIndexedWindow is provided as an easier way to get a particular
 *    window from a group than using GetWindowGroupContents. If you
 *    only need to retrieve, say, the last window in a group, it is
 *    easier and more efficient to use GetIndexedWindow. If you need to
 *    retrieve all the windows in a group, it is more efficient to use
 *    GetWindowGroupContents.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inGroup:
 *      The group containing the window to retrieve.
 *    
 *    inIndex:
 *      The index of the window. This parameter may range from 1 to
 *      CountWindowGroupContents( inGroup,
 *      kWindowGroupContentsReturnWindows | inOptions );
 *    
 *    inOptions:
 *      Indicates how to locate the specified window.
 *      kWindowGroupContentsReturnWindows is implied by this API and
 *      does not need to be explicitly specified.
 *    
 *    outWindow:
 *      On exit, the window at the specified index.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetIndexedWindow(
  WindowGroupRef              inGroup,
  ItemCount                   inIndex,
  WindowGroupContentOptions   inOptions,
  WindowRef *                 outWindow)                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowIndex()
 *  
 *  Summary:
 *    Retrieves the z-order index of a window inside a group.
 *  
 *  Discussion:
 *    The z-order index of a window is its relative position in z-order
 *    inside a group. The index ranges from 1 to the number of windows
 *    in the group.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose z-order index to retrieve.
 *    
 *    inStartGroup:
 *      The group on which to base the z-order index. This should be
 *      either the containing group of the window, or NULL. If NULL,
 *      this API returns the z-order index of the window across the
 *      entire process.
 *    
 *    inOptions:
 *      Indicates how to enumerate the specified window.
 *      kWindowGroupContentsReturnWindows is implied by this API and
 *      does not need to be explicitly specified.
 *    
 *    outIndex:
 *      On exit, contains the window’s z-order index.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowIndex(
  WindowRef                   inWindow,
  WindowGroupRef              inStartGroup,
  WindowGroupContentOptions   inOptions,
  ItemCount *                 outIndex)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*----------------------------------------------------------------------------------*/
/*  • Window activation                                                             */
/*----------------------------------------------------------------------------------*/
/*
 *  ActiveNonFloatingWindow()
 *  
 *  Summary:
 *    Returns the window, among all windows with activation scope of
 *    kWindowActivationScopeAll, that is considered active.
 *  
 *  Discussion:
 *    The Mac OS 8.5 Window Manager introduced the
 *    FrontNonFloatingWindow API, which was designed to return the
 *    window that should be considered active by the application. With
 *    the advent of window groups, it is now possible to have a window
 *    that looks active (is highlighted, and accepts keyboard input)
 *    but to have other non-floating windows grouped above the active
 *    window. The ActiveNonFloatingWindow API returns the active window
 *    regardless of where it is positioned in the z-order. Most code
 *    that currently uses FrontNonFloatingWindow or
 *    GetFrontWindowOfClass(kDocumentWindowClass) to get the active
 *    window should use ActiveNonFloatingWindow instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
ActiveNonFloatingWindow(void)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsWindowActive()
 *  
 *  Summary:
 *    Indicates whether a window is active.
 *  
 *  Discussion:
 *    Whether a window is considered active is determined by its
 *    activation scope, hiliting, and z-order. For windows that have an
 *    activation scope of kWindowActivationScopeAll, a window is active
 *    if it is the window returned by the ActiveNonFloatingWindow API,
 *    or if it is in the same window group as the window returned by
 *    that API and the window group has the
 *    kWindowGroupAttrSharedActivation attribute. For windows that have
 *    some other activation scope, the window is active if its window
 *    frame is hilited and the window is the frontmost window in its
 *    window group. 
 *    
 *    The IsWindowActive API does not indicate whether the window has
 *    keyboard focus. To get the window with keyboard focus, use
 *    GetUserFocusWindow().
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose active state to retrieve.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsWindowActive(WindowRef inWindow)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ActivateWindow()
 *  
 *  Summary:
 *    Activates or deactivates a window.
 *  
 *  Discussion:
 *    Window activation consists of two steps: hiliting the window
 *    frame and sending an activate event to the window. ActivateWindow
 *    handles both of these steps and also updates internal Window
 *    Manager state. If you just need to hilite the window frame, you
 *    may use HiliteWindow. If you need to send an activate event, you
 *    should always use ActivateWindow rather than creating and sending
 *    the event yourself.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to activate or deactivate.
 *    
 *    inActivate:
 *      Whether to activate or deactivate the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ActivateWindow(
  WindowRef   inWindow,
  Boolean     inActivate)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowActivationScope()
 *  
 *  Summary:
 *    Retrieves a window’s activation scope.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose activation scope to retrieve.
 *    
 *    outScope:
 *      On exit, the window’s activation scope.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowActivationScope(
  WindowRef                inWindow,
  WindowActivationScope *  outScope)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowActivationScope()
 *  
 *  Summary:
 *    Sets a window’s activation scope.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose activation scope to set.
 *    
 *    inScope:
 *      The new activation scope.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowActivationScope(
  WindowRef               inWindow,
  WindowActivationScope   inScope)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*--------------------------------------------------------------------------------------*/
/*  • Window Focus                                                                      */
/*                                                                                      */
/* The 'user focus' is where keyboard input goes. We also use the term 'key' applied    */
/* to windows to mean this. The user focus window is normally the active non-floating   */
/* window or dialog. It is possible to make a floater get the focus, however, by calling*/
/* SetUserFocusWindow. After that call, the event model will automatically route key    */
/* input to the active keyboard focus of that window, if any. Passing kUserFocusAuto    */
/* into the window parameter tells the toolbox to pick what it considers to be the best */
/* candidate for focus. You should call this to restore focus, rather than getting the  */
/* focus, setting it to a special window, and then restoring to the saved focus. There  */
/* are cases, however, when you might want to restore to an explicit window, but the    */
/* typical usage should just be to restore to the kUserFocusAuto focus.                 */
/*                                                                                      */
/* Keep in mind that setting the focus will only last until you restore focus, or the   */
/* user starts clicking in other windows. When that happens, the toolbox will auto-     */
/* redirect the user focus to a newly selected window.                                  */
/*--------------------------------------------------------------------------------------*/
/* pick the most appropriate window for focus*/
#endif  /* !__LP64__ */

#define kUserFocusAuto                  ((WindowRef)(-1))
#if !__LP64__
/*
 *  SetUserFocusWindow()
 *  
 *  Summary:
 *    Sets the window that receives keyboard input.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window that should receive user input. You may also pass
 *      kUserFocusAuto to cause the toolbox to pick a default window
 *      for user focus (typically, this will be the active window).
 *      
 *      
 *      If the focus changes to a new window, the
 *      kEventWindowFocusAcquired Carbon event will be sent to the
 *      newly focused window, and the kEventWindowFocusRelinquish
 *      Carbon event will be sent to the previously focused window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetUserFocusWindow(WindowRef inWindow)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetUserFocusWindow()
 *  
 *  Summary:
 *    Returns the window that receives keyboard input.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    The window that is currently receiving keyboard input.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
GetUserFocusWindow(void)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowShowsFocus()
 *  
 *  Summary:
 *    Returns whether a window's content should show focus indicators,
 *    such as focus rings.
 *  
 *  Discussion:
 *    This API returns true if the window is either the modeless focus
 *    or the effective focus.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose status to return.
 *  
 *  Result:
 *    Whether this window's content should show focus indicators.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIWindowShowsFocus(WindowRef inWindow)                        AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;



/*--------------------------------------------------------------------------------------*/
/*  • Default/Cancel buttons                                                            */
/*                                                                                      */
/* In our quest to eliminate the need for dialogs when using the new event model, we    */
/* have added the following routines which add dialog-like button control to normal     */
/* windows. With these routines, you can set the default and cancel buttons for a       */
/* window; these work just like the corresponding concepts in dialogs, and when         */
/* present, the standard toolbox handlers will handle keyboard input mapping to these   */
/* buttons. This means that pressing return or enter will 'press' the default button    */
/* and escape or command-period will 'press' the cancel button.                         */
/*--------------------------------------------------------------------------------------*/

/*
 *  SetWindowDefaultButton()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowDefaultButton(
  WindowRef    inWindow,
  ControlRef   inControl)       /* can be NULL */             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowCancelButton()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowCancelButton(
  WindowRef    inWindow,
  ControlRef   inControl)       /* can be NULL */             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowDefaultButton()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowDefaultButton(
  WindowRef     inWindow,
  ControlRef *  outControl)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowCancelButton()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowCancelButton(
  WindowRef     inWindow,
  ControlRef *  outControl)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*----------------------------------------------------------------------------------*/
/*  • ThemeBrush and ThemeTextColor support                                         */
/*----------------------------------------------------------------------------------*/
/*
 *  SetThemeWindowBackground()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSStatus 
SetThemeWindowBackground(
  WindowRef    inWindow,
  ThemeBrush   inBrush,
  Boolean      inUpdate)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowGetThemeBackground()
 *  
 *  Summary:
 *    Gets the the window theme background brush.
 *  
 *  Discussion:
 *    Gets the the window theme background brush which may have been
 *    previously set by SetThemeWindowBackground.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window from which to get the brush.
 *    
 *    outThemeBrush:
 *      On return, inWindow's background brush.
 *  
 *  Result:
 *    An operating system result code. If no brush is found
 *    themeNoAppropriateBrushErr will be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetThemeBackground(
  WindowRef     inWindow,
  ThemeBrush *  outThemeBrush)                                AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  SetThemeTextColorForWindow()
 *  
 *  Summary:
 *    Sets a text color which contrasts with a theme brush.
 *  
 *  Discussion:
 *    SetThemeTextColorForWindow sets a text color in the specified
 *    window's port that contrasts with the theme brush associated with
 *    the specified window, and also matches the inActive parameter.
 *    Only a subset of the theme brushes have theme text colors:
 *    currently (as of Mac OS 9 and Mac OS X 10.5), the Alert, Dialog,
 *    ModelessDialog, and Notification brushes have corresponding text
 *    colors. For any other brush, SetThemeTextColorForWindow returns
 *    themeNoAppropriateBrushErr and does not modify the text color.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose text color to change.
 *    
 *    inActive:
 *      Whether the text color should indicate an active or inactive
 *      state.
 *    
 *    inDepth:
 *      The bit depth of the window's port.
 *    
 *    inColorDev:
 *      Whether the window's port is color or black&white.
 *  
 *  Result:
 *    An operating system result code, including
 *    themeNoAppropriateBrushErr if the specified theme brush does not
 *    have a corresponding theme text color.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.1 and later
 */
extern OSStatus 
SetThemeTextColorForWindow(
  WindowRef   inWindow,
  Boolean     inActive,
  SInt16      inDepth,
  Boolean     inColorDev)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Background Image                                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
   Routines available from Mac OS 8.5 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/
/*
 *  SetWindowContentColor()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowContentColor(
  WindowRef         window,
  const RGBColor *  color)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowContentColor()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowContentColor(
  WindowRef   window,
  RGBColor *  color)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/* Routines available from Mac OS 8.5 forward*/
/*
 *  GetWindowContentPattern()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowContentPattern(
  WindowRef      window,
  PixPatHandle   outPixPat)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowContentPattern()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowContentPattern(
  WindowRef      window,
  PixPatHandle   pixPat)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Colorspace and Depth                                                               */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIWindowSetColorSpace()
 *  
 *  Summary:
 *    Sets the colorspace used for window content that is drawn by the
 *    application with no other specified colorspace.
 *  
 *  Discussion:
 *    Typically this API should be used immediately after a window is
 *    created, before the window is made visible. If the window
 *    colorspace is changed while the window is visible, the window
 *    will be redrawn. 
 *    
 *    Note that setting a colorspace on a window with the
 *    kHIWindowBitAutoCalibration attribute prevents the window from
 *    receiving automatic color space updates. Clearing the colorspace
 *    by passing NULL restores the kHIWindowBitAutoCalibration
 *    functionality.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose colorspace to change.
 *    
 *    inColorSpace:
 *      The window's new colorspace. The colorspace will be retained or
 *      copied by the window. Pass NULL to clear any previously-set
 *      colorspace.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.6 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetColorSpace(
  WindowRef         inWindow,
  CGColorSpaceRef   inColorSpace)       /* can be NULL */     AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;


/*
 *  HIWindowCopyColorSpace()
 *  
 *  Summary:
 *    Retrieves the colorspace for a window.
 *  
 *  Discussion:
 *    If this API is called before a color space has been explicitly
 *    assigned to a window, the window's default colorspace is returned.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose colorspace to retrieve.
 *  
 *  Result:
 *    The window's colorspace, or NULL if an error occurs. The
 *    colorspace has been retained and should be released by the caller
 *    when the caller is done with it.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.6 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CGColorSpaceRef 
HIWindowCopyColorSpace(WindowRef inWindow)                    AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Window backing store depth types.
 */
enum {

  /*
   * The window is invalid or its backing store pixel size is unknown.
   */
  kHIWindowDepthInvalid         = 0,

  /*
   * The window's backing store pixel size should be 32 bits.
   */
  kHIWindowDepth32Bit           = 1,

  /*
   * The window's backing store pixel size should be 64 bits.
   */
  kHIWindowDepth64Bit           = 2,

  /*
   * The window's backing store pixel size should be the size of a
   * float.
   */
  kHIWindowDepthFloat           = 3
};

typedef UInt32                          HIWindowDepth;
#if !__LP64__
/*
 *  HIWindowSetDepth()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    This API is not actually functional in Mac OS X 10.6 or Mac OS X
 *    10.7 and should not be used. Applications that need to control
 *    the backing store depth of their windows should use NSWindows and
 *    the [NSWindow setDepthLimit:] API.
 *  
 *  Summary:
 *    Sets the depth of a window's backing store.
 *  
 *  Discussion:
 *    Typically this API should be used immediately after a window is
 *    created, before the window is made visible. If the window depth
 *    is changed while the window is visible, the window will be
 *    redrawn.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose backing store depth to change.
 *    
 *    inDepth:
 *      The new window depth type. This must be one of
 *      kHIWindowDepth32Bit, 64Bit, or Float.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.6 and later in Carbon.framework [32-bit only] but deprecated in 10.7
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetDepth(
  WindowRef       inWindow,
  HIWindowDepth   inDepth)                                    AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7;


/*
 *  HIWindowGetDepth()
 *  
 *  Summary:
 *    Returns the current depth of the backing store of a window.
 *  
 *  Discussion:
 *    This API returns an HIWindowDepth value corresponding to the
 *    actual depth of the backing store. It will return one of
 *    kHIWindowDepth32Bit, 64Bit, or Float.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose backing store depth to return.
 *  
 *  Result:
 *    The window's backing store depth type (one of
 *    kHIWindowDepth32Bit, 64Bit, or Float), or kHIWindowDepthInvalid
 *    if an error occurs.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.6 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern HIWindowDepth 
HIWindowGetDepth(WindowRef inWindow)                          AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Scrolling Routines                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */

typedef UInt32 ScrollWindowOptions;
enum {
  kScrollWindowNoOptions        = 0,
  kScrollWindowInvalidate       = (1 << 0), /* add the exposed area to the window’s update region*/
  kScrollWindowEraseToPortBackground = (1 << 1) /* erase the exposed area using the background color/pattern of the window’s grafport*/
};


/* Routines available from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward*/

#if !__LP64__
/*
 *  ScrollWindowRect()
 *  
 *  Summary:
 *    Moves a rectangular portion of a window by a specified horizontal
 *    and vertical amount.
 *  
 *  Discussion:
 *    This API is only recommended for non-composited windows. For a
 *    composited window, use HIViewScrollRect or simply invalidate the
 *    view and redraw it at its scrolled position.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ScrollWindowRect(
  WindowRef             inWindow,
  const Rect *          inScrollRect,
  SInt16                inHPixels,
  SInt16                inVPixels,
  ScrollWindowOptions   inOptions,
  RgnHandle             outExposedRgn)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ScrollWindowRegion()
 *  
 *  Summary:
 *    Moves a non-rectangular portion of a window by a specified
 *    horizontal and vertical amount.
 *  
 *  Discussion:
 *    This API is only recommended for non-composited windows. For a
 *    composited window, use HIViewScrollRect or simply invalidate the
 *    view and redraw it at its scrolled position.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ScrollWindowRegion(
  WindowRef             inWindow,
  RgnHandle             inScrollRgn,
  SInt16                inHPixels,
  SInt16                inVPixels,
  ScrollWindowOptions   inOptions,
  RgnHandle             outExposedRgn)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window List                                                                        */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Options for the HIWindowFindAtLocation API.
 */
enum {

  /*
   * Requests that HIWindowFindAtLocation ignore windows of other
   * processes which might obscure your process's windows. That is, if
   * a window in your process is at the specified point, it will be
   * passed back even if some other process's window obscures it.
   */
  kHIWindowIgnoreObscuringWindows = 1 << 0
};

#if !__LP64__
/*
 *  HIWindowFindAtLocation()
 *  
 *  Summary:
 *    Finds a window in the current process at a specified location.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inLocation:
 *      The global location. This may be specified in either screen
 *      pixel coordinates or virtual 72DPI coordinates, depending on
 *      the inSpace parameter.
 *    
 *    inSpace:
 *      The coordinate space in which the location is expressed. This
 *      must be kHICoordSpaceScreenPixel or kHICoordSpace72DPIGlobal.
 *    
 *    inStartWindow:
 *      The window at which to start the search, inclusive. Pass
 *      kFirstWindowOfClass (-1) to start the search at the beginning
 *      of the window list. Passing NULL will cause the search to start
 *      at the end of the window list, and therefore no window will be
 *      found.
 *    
 *    inOptions:
 *      Flags allowing you to request optional behavior for this API.
 *      If you want the default behavior, pass zero.
 *    
 *    outWindow:
 *      On exit, contains the window in the current process at the
 *      specified location, if any.
 *    
 *    outWindowPart:
 *      On exit, identifies the window part that was hit. You may pass
 *      NULL if you don't need this information.
 *    
 *    outWindowLocation:
 *      On exit, contains the specified location transformed into
 *      window-relative coordinates. This location will take into
 *      account any window transform or magnification.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowFindAtLocation(
  const HIPoint *     inLocation,
  HICoordinateSpace   inSpace,
  WindowRef           inStartWindow,           /* can be NULL */
  OptionBits          inOptions,
  WindowRef *         outWindow,
  WindowPartCode *    outWindowPart,           /* can be NULL */
  HIPoint *           outWindowLocation)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  [Mac]FindWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacFindWindow FindWindow
#endif
extern WindowPartCode 
MacFindWindow(
  Point        thePoint,
  WindowRef *  window)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  BringToFront()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
BringToFront(WindowRef window)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SendBehind()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SendBehind(
  WindowRef   window,
  WindowRef   behindWindow)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SelectWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SelectWindow(WindowRef window)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
   Routines available from Mac OS 8.6 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/

/*
 *  FrontNonFloatingWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern WindowRef 
FrontNonFloatingWindow(void)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/* Routines available from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward*/

/*
 *  GetNextWindowOfClass()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
GetNextWindowOfClass(
  WindowRef     inWindow,
  WindowClass   inWindowClass,
  Boolean       mustBeVisible)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetFrontWindowOfClass()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
GetFrontWindowOfClass(
  WindowClass   inWindowClass,
  Boolean       mustBeVisible)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  FindWindowOfClass()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
FindWindowOfClass(
  const Point *     where,
  WindowClass       inWindowClass,
  WindowRef *       outWindow,
  WindowPartCode *  outWindowPart)       /* can be NULL */    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Options for the CreateStandardWindowMenu API.
 */
enum {

  /*
   * Requests the standard window menu include a Rotate Windows menu
   * item. Available in Mac OS X 10.2.
   */
  kWindowMenuIncludeRotate      = 1 << 0
};


/*
 *  Summary:
 *    Constants for use with Get/SetMenuItemProperty to access property
 *    data of items in the standard window menu. These constants are
 *    supported on Mac OS X 10.5 and later.
 */
enum {

  /*
   * The property creator for accessing standard window menu item
   * properties.
   */
  kHIWindowMenuCreator          = 'wind',

  /*
   * The property tag for accessing standard window menu item
   * properties that hold WindowRefs. Menu items with the
   * kHICommandSelectWindow command ID will have a property with this
   * tag that contains the WindowRef to be activated when that item is
   * selected. Available in Mac OS X 10.5 and later.
   */
  kHIWindowMenuWindowTag        = 'wind'
};

#if !__LP64__
/*
 *  CreateStandardWindowMenu()
 *  
 *  Discussion:
 *    Creates a standard Window menu for your application. You can call
 *    this to create a window menu for your application. Once you have
 *    the menu, you need to insert it in your menu bar (typically at
 *    the end of your menu list) with a call to InsertMenu. To register
 *    a window to be tracked by this menu, you either create your
 *    window with CreateNewWindow, passing the
 *    kWindowInWindowMenuAttribute, or you can use
 *    ChangeWindowAttributes after the window is created. The Toolbox
 *    takes care of acting on the standard items such as zoom and
 *    minimize, as well as bringing selected windows to the front. All
 *    you need to do is install it and register your windows and the
 *    Toolbox does the rest.
 *    
 *    You may also add your own menu items to the standard window menu.
 *    To do this, we recommend that you use the
 *    GetIndMenuItemWithCommandID API to locate one of the standard
 *    menu items in the menu which is immediately above or below the
 *    location where you wish to insert your items. Then insert your
 *    items relative to the position of the standard menu item. Do not
 *    attempt to search the menu items yourself without calling
 *    GetIndMenuItemWithCommandID; in Mac OS X 10.2,
 *    CreateStandardWindowMenu returns an initially empty menu which is
 *    populated later when the menu is displayed or when
 *    GetIndMenuItemWithCommandID is called, so you will find no items
 *    in the menu unless you first call GetIndMenuItemWithCommandID.
 *    
 *    There is a known bug in all versions of CarbonLib which causes
 *    the Zoom, Collapse, and Uncollapse menu items in the standard
 *    window menu to be non-functional for windows created by the
 *    Dialog Manager. To work around this bug, you can install your own
 *    event handlers on the dialog window for kEventWindowZoom,
 *    kEventWindowCollapse, and kEventWindowExpand, and handle the
 *    event by calling the appropriate Window Manager API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inOptions:
 *      Requests optional behavior of the standard window menu. Mac OS
 *      X 10.2 supports the kWindowMenuIncludeRotate option; in earlier
 *      versions of Mac OS X, and in CarbonLib, you must pass zero for
 *      this parameter.
 *    
 *    outMenu:
 *      Receives a new menu reference which contains the standard
 *      window menu items and commands.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CreateStandardWindowMenu(
  OptionBits   inOptions,
  MenuRef *    outMenu)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowAlternateTitle()
 *  
 *  Discussion:
 *    This API sets an alternate title for a window. The alternate
 *    title overrides what is displayed in the Window menu. If you do
 *    not set an alternate title, the normal window title is used. You
 *    would normally use this if the window title was not expressive
 *    enough to be used in the Window menu (or similar text-only
 *    situation).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to set the alternate title.
 *    
 *    inTitle:
 *      The alternate title for the window. Passing NULL for this
 *      parameter will remove any alternate title that might be present.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowAlternateTitle(
  WindowRef     inWindow,
  CFStringRef   inTitle)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CopyWindowAlternateTitle()
 *  
 *  Discussion:
 *    This API gets the alternate title for a window. See the
 *    discussion of SetWindowAlternateTitle for more info.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to get the alternate title from.
 *    
 *    outTitle:
 *      Receives the alternate title for the window. If the window does
 *      not have an alternate title, NULL will be returned in outTitle.
 *  
 *  Result:
 *    An operating system status code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CopyWindowAlternateTitle(
  WindowRef      inWindow,
  CFStringRef *  outTitle)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Misc Low-Level stuff                                                               */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
   Routines available from Mac OS 8.5 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/
/*
 *  IsValidWindowPtr()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern Boolean 
IsValidWindowPtr(WindowRef possibleWindow)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#define IsValidWindowRef IsValidWindowPtr

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Various & Sundry Window Accessors                                                  */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HiliteWindow()
 *  
 *  Summary:
 *    Hilites or unhilites a window's frame.
 *  
 *  Discussion:
 *    Hiliting a window's frame is not the same as activating the
 *    window. A window's hilited state determines whether the window
 *    draws its titlebar and associated widgets as if they were the
 *    frontmost window of its window group, whereas a window's active
 *    state determines whether the window really is the frontmost
 *    window of its window group. Activating or deactivating a window
 *    automatically adjusts a window's hilited state to match.
 *    
 *    In general, only very old compatibility code would ever need or
 *    want to manually modify a window's hilited state via the
 *    HiliteWindow API. Modern clients can typically avoid this API
 *    entirely.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose frame you wish to hilite/unhilite.
 *    
 *    fHilite:
 *      Whether to hilite or unhilite the window's frame.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
HiliteWindow(
  WindowRef   window,
  Boolean     fHilite)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWRefCon()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetWRefCon(
  WindowRef   window,
  SRefCon     data)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWRefCon()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern SRefCon 
GetWRefCon(WindowRef window)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/* Routines available from Mac OS 8.0 (Appearance 1.0) forward*/
/*
 *  GetWindowFeatures()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSStatus 
GetWindowFeatures(
  WindowRef   window,
  UInt32 *    outFeatures)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowCopyShape()
 *  
 *  Summary:
 *    Retrieves a shape describing a specified region of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose shape to return.
 *    
 *    inRegion:
 *      The window region whose shape to return.
 *    
 *    inSpace:
 *      The coordinate space in which the shape should be returned.
 *      This must be kHICoordSpaceWindow, kHICoordSpaceScreenPixel, or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    outShape:
 *      On exit, contains a shape describing the specified window
 *      region. If the region is not supported, this parameter is not
 *      modified.
 *  
 *  Result:
 *    An operating system result code. errWindowRegionCodeInvalid is
 *    returned if the window does not support the specified window
 *    region.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowCopyShape(
  WindowRef           inWindow,
  WindowRegionCode    inRegion,
  HICoordinateSpace   inSpace,
  HIShapeRef *        outShape)                               AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  GetWindowRegion()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIWindowCopyShape instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSStatus 
GetWindowRegion(
  WindowRef          window,
  WindowRegionCode   inRegionCode,
  RgnHandle          ioWinRgn)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetWindowStructureWidths()
 *  
 *  Summary:
 *    Returns the width of the structure region on each edge of a
 *    window.
 *  
 *  Discussion:
 *    The structure widths are the difference between the content
 *    region and the structure region on each edge of a window. For
 *    example, if the left edge of the structure region is at x=100,
 *    and the left edge of the content region is at x=110, then the
 *    structure width for the left side of the window is 10 pixels.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window for which to get structure widths.
 *    
 *    outRect:
 *      On exit, contains the width of the structure region on each
 *      side of the window; the left field of the rectangle contains
 *      the structure width on the left side of the window, the top
 *      field contains the width on the top side, and so on.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowStructureWidths(
  WindowRef   inWindow,
  Rect *      outRect)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  HIWindowChangeFeatures()
 *  
 *  Summary:
 *    Changes the window features on the fly.
 *  
 *  Discussion:
 *    HIWindowChangeFeatures changes the features of a window. This
 *    should only be used by custom window definitions or window frame
 *    views.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to modify.
 *    
 *    inSetThese:
 *      The feature bits to set.
 *    
 *    inClearThese:
 *      The feature bits to clear.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowChangeFeatures(
  WindowRef   inWindow,
  UInt64      inSetThese,
  UInt64      inClearThese)                                   AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Update Events                                                                      */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  BeginUpdate()
 *  
 *  Summary:
 *    Modifies a window's GrafPort state before redrawing the invalid
 *    portion of a non-compositing window.
 *  
 *  Discussion:
 *    BeginUpdate copies the window's update region into the window's
 *    GrafPort's visible region, and then clears the update region. By
 *    setting the visible region to match the update region,
 *    BeginUpdate ensures that any subsequent drawing will be clipped
 *    to the update region. 
 *    
 *    This API should not be used on a compositing window. Composited
 *    windows are drawn automatically by the HIView Manager by sending
 *    kEventControlDraw events to the views contained in the window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window to update.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
BeginUpdate(WindowRef window)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  EndUpdate()
 *  
 *  Summary:
 *    Restores the original state of a window's GrafPort after a
 *    non-compositing window has been updated.
 *  
 *  Discussion:
 *    EndUpdate restores the original visible region of a window's
 *    GrafPort. 
 *    
 *    This API should not be used on a compositing window. Composited
 *    windows are drawn automatically by the HIView Manager by sending
 *    kEventControlDraw events to the views contained in the window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window that was updated.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
EndUpdate(WindowRef window)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
   Routines available from Mac OS 8.5 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/

/*
 *  InvalWindowRgn()
 *  
 *  Summary:
 *    Invalidates a portion of a non-compositing window.
 *  
 *  Discussion:
 *    This API should not be used on a compositing window. To
 *    invalidate a portion of a compositing window, use
 *    HIViewSetNeedsDisplay or one of its variant APIs.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window to invalidate.
 *    
 *    region:
 *      The region to invalidate, in local coordinates of the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
InvalWindowRgn(
  WindowRef   window,
  RgnHandle   region)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  InvalWindowRect()
 *  
 *  Summary:
 *    Invalidates a portion of a non-compositing window.
 *  
 *  Discussion:
 *    This API should not be used on a compositing window. To
 *    invalidate a portion of a compositing window, use
 *    HIViewSetNeedsDisplay or one of its variant APIs.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window to invalidate.
 *    
 *    bounds:
 *      The rect to invalidate, in local coordinates of the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
InvalWindowRect(
  WindowRef     window,
  const Rect *  bounds)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ValidWindowRgn()
 *  
 *  Summary:
 *    Validates a portion of a non-compositing window.
 *  
 *  Discussion:
 *    This API should not be used on a compositing window. To validate
 *    a portion of a compositing window, use HIViewSetNeedsDisplay or
 *    one of its variant APIs.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window to validate.
 *    
 *    region:
 *      The region to validate, in local coordinates of the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
ValidWindowRgn(
  WindowRef   window,
  RgnHandle   region)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ValidWindowRect()
 *  
 *  Summary:
 *    Validates a portion of a non-compositing window.
 *  
 *  Discussion:
 *    This API should not be used on a compositing window. To validate
 *    a portion of a compositing window, use HIViewSetNeedsDisplay or
 *    one of its variant APIs.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window to validate.
 *    
 *    bounds:
 *      The rect to validate, in local coordinates of the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
ValidWindowRect(
  WindowRef     window,
  const Rect *  bounds)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Titles                                                                      */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  SetWindowTitleWithCFString()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowTitleWithCFString(
  WindowRef     inWindow,
  CFStringRef   inString)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CopyWindowTitleAsCFString()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CopyWindowTitleAsCFString(
  WindowRef      inWindow,
  CFStringRef *  outString)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Proxies                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIWindowSetProxyFSRef()
 *  
 *  Summary:
 *    Set the proxy icon for a window using an FSRef to an existing
 *    file system object (volume, folder, or file).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to set.
 *    
 *    inRef:
 *      The file system object that the window represents. The window's
 *      proxy icon is determined by asking Icon Services for the icon
 *      of this object.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetProxyFSRef(
  WindowRef      window,
  const FSRef *  inRef)                                       AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  HIWindowGetProxyFSRef()
 *  
 *  Summary:
 *    Returns the FSRef used to determine the proxy icon for a window.
 *  
 *  Discussion:
 *    This API will return noErr and a valid FSRef if the window's
 *    proxy icon has been specified using the FSRef, FSSpec or alias
 *    SetWindowProxy APIs. If the window has no proxy icon, or if the
 *    icon was specified with SetWindowProxyCreatorAndType or
 *    SetWindowProxyIcon, then an error will be returned.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window containing the proxy icon to return.
 *    
 *    outRef:
 *      On exit, contains the FSRef to the window's proxy icon.
 *  
 *  Result:
 *    noErr if the window's proxy icon FSRef has been returned;
 *    errWindowDoesNotHaveProxy if the window does not have a proxy
 *    icon, or if the proxy icon was specified by
 *    SetWindowProxyCreatorAndType or SetWindowProxyIcon. Other
 *    operating system error codes may also be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetProxyFSRef(
  WindowRef   window,
  FSRef *     outRef)                                         AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  SetWindowProxyAlias()
 *  
 *  Summary:
 *    Sets the proxy icon for a window using an AliasHandle to an
 *    existing file system object (volume, folder, or file).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose proxy icon to set.
 *    
 *    inAlias:
 *      The file system object that the window represents. The window’s
 *      proxy icon is determined by asking Icon Services for the icon
 *      of this object. The Window Manager copies the alias data; the
 *      caller may dispose of the alias after SetWindowProxyAlias
 *      returns.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowProxyAlias(
  WindowRef     inWindow,
  AliasHandle   inAlias)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowProxyAlias()
 *  
 *  Summary:
 *    Returns the alias used to determine the proxy icon for a window.
 *  
 *  Discussion:
 *    This API will return noErr and a valid alias if the window’s
 *    proxy icon has been specified using the SetWindowProxyFSSpec or
 *    SetWindowProxyAlias APIs. If the window has no proxy icon, or if
 *    the icon was specified with another SetWindowProxy API, then an
 *    error will be returned.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon alias to return.
 *    
 *    alias:
 *      On exit, contains the window’s proxy icon alias.
 *  
 *  Result:
 *    noErr if the window’s proxy icon alias has been returned;
 *    errWindowDoesNotHaveProxy if the window does not have a proxy
 *    icon, or if the proxy icon was specified by IconRef or
 *    type/creator rather than by FSSpec or alias. Other operating
 *    system error codes may also be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowProxyAlias(
  WindowRef      window,
  AliasHandle *  alias)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowProxyCreatorAndType()
 *  
 *  Summary:
 *    Sets the proxy icon for a window using a file type and creator.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to set.
 *    
 *    fileCreator:
 *      The creator code for the file system object that the window
 *      represents. The window’s proxy icon is determined by asking
 *      Icon Services for the icon corresponding to the specified
 *      creator code and file type, on the specified volume.
 *    
 *    fileType:
 *      The file type for the file system object that the window
 *      represents.
 *    
 *    vRefNum:
 *      The volume reference number for the volume containing the file
 *      system object that the window represents. You may pass
 *      kOnSystemDisk for this parameter if you don't know which volume
 *      will hold the file system object.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowProxyCreatorAndType(
  WindowRef   window,
  OSType      fileCreator,
  OSType      fileType,
  SInt16      vRefNum)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowProxyIcon()
 *  
 *  Summary:
 *    Returns the proxy icon of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to return.
 *    
 *    outIcon:
 *      On exit, contains the window’s proxy icon.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowProxyIcon(
  WindowRef   window,
  IconRef *   outIcon)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowProxyIcon()
 *  
 *  Summary:
 *    Sets a window’s proxy icon.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to set.
 *    
 *    icon:
 *      The proxy icon. The Window Manager retains the IconRef; the
 *      caller may release the IconRef after SetWindowProxyIcon returns.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowProxyIcon(
  WindowRef   window,
  IconRef     icon)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RemoveWindowProxy()
 *  
 *  Summary:
 *    Removes a window’s proxy icon.
 *  
 *  Discussion:
 *    When removing the proxy icon, the Window Manager also releases
 *    the alias or IconRef, if any, that was used to specify the proxy
 *    icon.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to remove.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
RemoveWindowProxy(WindowRef window)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  BeginWindowProxyDrag()
 *  
 *  Summary:
 *    Creates a new drag reference that can be used to drag a window’s
 *    proxy icon.
 *  
 *  Discussion:
 *    This API is used by applications that need to add their own drag
 *    flavors to the drag reference used for a proxy icon drag. Such an
 *    application would call BeginWindowProxyDrag to create the drag
 *    reference, add its own flavors, call
 *    TrackWindowProxyFromExistingDrag to track the proxy icon drag,
 *    and then EndWindowProxyDrag to release the drag
 *    reference.
 *    
 *    An application which does not need to add its own drag flavors to
 *    the drag reference can simply call TrackWindowProxyDrag.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to drag.
 *    
 *    outNewDrag:
 *      On exit, contains the drag reference for the proxy icon.
 *    
 *    outDragOutlineRgn:
 *      On entry, should be a valid RgnHandle; on exit, the region has
 *      been updated with an outline of the proxy icon drag image. This
 *      region should be passed to TrackWindowProxyFromExistingDrag;
 *      the application may modify it first. On Mac OS X 10.5 and
 *      later, you may pass NULL if you don't need the outline region.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
BeginWindowProxyDrag(
  WindowRef   window,
  DragRef *   outNewDrag,
  RgnHandle   outDragOutlineRgn)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  EndWindowProxyDrag()
 *  
 *  Summary:
 *    Releases a drag reference created by BeginWindowProxyDrag.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon drag reference to release.
 *    
 *    theDrag:
 *      The drag reference to release.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
EndWindowProxyDrag(
  WindowRef   window,
  DragRef     theDrag)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowTrackProxyDrag()
 *  
 *  Summary:
 *    Tracks the drag of a window proxy icon.
 *  
 *  Discussion:
 *    This API is used by applications that need to manage the dragging
 *    of the proxy icon in their windows. Applications that use the
 *    standard window event hander and that do not need to customize
 *    the proxy icon drag process may rely on the standard handler to
 *    call this API.
 *    
 *    An application may choose whether to allow the Window Manager to
 *    create the drag reference and populate it with drag flavors, or
 *    to create the drag reference itself and adds its own drag
 *    flavors. In the first case, an application should pass NULL for
 *    the drag reference parameter to this API.In the second case, an
 *    application should call BeginWindowProxyDrag to create the drag
 *    reference, add its own flavors, call HIWindowTrackProxyDrag to
 *    track the proxy icon drag, and then EndWindowProxyDrag to release
 *    the drag reference.
 *    
 *    If you pass a non-NULL drag reference, this routine will not
 *    display an outline region for the drag; you are thus expected to
 *    set up a drag image via SetDragImageWithCGImage or a similar API.
 *    Also, in the non- NULL drag reference case, you should not set
 *    the kDragRegionAndImage drag image flag.
 *    
 *    A proxy icon may only be dragged if the window represented by the
 *    proxy icon is not modifed (as indicated by the IsWindowModified
 *    API). This restriction is imposed because a proxy icon is a
 *    representation of a physical file system object, and dragging the
 *    proxy icon may result in the Finder making a copy of the file
 *    system object. If the window is modified, then it contains user
 *    data that has not yet been saved to disk; making a copy of the
 *    file system object would result in a stale copy that did not
 *    contain the user’s current data.
 *    
 *    By default, all newly created windows are considered to be dirty.
 *    The application must call SetWindowModified( window, false )
 *    before the proxy icon will be draggable.
 *    
 *    In Mac OS X 10.3 and later, the proxy icon is also draggable in
 *    dirty windows if the proxy icon was provided using the
 *    SetWindowProxyIcon or SetWindowProxyCreatorAndType APIs. Dragging
 *    is allowed in this case because the window does not represent an
 *    actual file system object, and therefore there is no risk of user
 *    data loss.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose proxy icon to drag.
 *    
 *    inEvent:
 *      The event that resulted in starting a drag. This will most
 *      commonly be kEventControlTrack, but any event with
 *      kEventParamMouseLocation and kEventParamKeyModifiers parameters
 *      is all that is required.
 *    
 *    inDrag:
 *      The proxy icon drag reference. This parameter may be NULL if
 *      you want the Window Manager to create and populate the drag
 *      reference itself. The Window Manager will add its own drag
 *      flavors to the drag even when the client passes a pre-created
 *      drag reference.
 *  
 *  Result:
 *    errUserWantsToDragWindow if the user’s mouse movements indicated
 *    that the user actually wants to drag the window instead of the
 *    proxy icon (in this case the application should call DragWindow);
 *    windowWrongStateErr if the window was modified and therefore the
 *    proxy icon could not be dragged; noErr if the drag succeeded;
 *    userCanceledErr if the user canceled the drag. Other operating
 *    system result codes may also be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowTrackProxyDrag(
  WindowRef   inWindow,
  EventRef    inEvent,
  DragRef     inDrag)         /* can be NULL */               AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TrackWindowProxyFromExistingDrag()
 *  
 *  Summary:
 *    Tracks the drag of a window proxy icon.
 *  
 *  Discussion:
 *    This API is used by applications that need to add their own drag
 *    flavors to the drag reference used for a proxy icon drag. Such an
 *    application would call BeginWindowProxyDrag to create the drag
 *    reference, add its own flavors, call
 *    TrackWindowProxyFromExistingDrag to track the proxy icon drag,
 *    and then EndWindowProxyDrag to release the drag
 *    reference.
 *    
 *    An application which does not need to add its own drag flavors to
 *    the drag reference can simply call TrackWindowProxyDrag.
 *    
 *    A proxy icon may only be dragged if the window represented by the
 *    proxy icon is not modifed (as indicated by the IsWindowModified
 *    API). This restriction is imposed because a proxy icon is a
 *    representation of a physical file system object, and dragging the
 *    proxy icon may result in the Finder making a copy of the file
 *    system object. If the window is modified, then it contains user
 *    data that has not yet been saved to disk; making a copy of the
 *    file system object would result in a stale copy that did not
 *    contain the user’s current data.
 *    
 *    By default, all newly created windows are considered to be dirty.
 *    The application must call SetWindowModified( window, false )
 *    before the proxy icon will be draggable.
 *    
 *    In Mac OS X 10.3 and later, the proxy icon is also draggable in
 *    dirty windows if the proxy icon was provided using the
 *    SetWindowProxyIcon or SetWindowProxyCreatorAndType APIs. Dragging
 *    is allowed in this case because the window does not represent an
 *    actual file system object, and therefore there is no risk of user
 *    data loss.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to drag.
 *    
 *    startPt:
 *      The point in global coordinates where the drag originated. This
 *      is generally the location of the mouse click in the proxy icon.
 *    
 *    drag:
 *      The proxy icon drag reference.
 *    
 *    inDragOutlineRgn:
 *      The outline of the proxy icon drag image, as returned by
 *      BeginWindowProxyDrag. You may pass NULL on Mac OS X 10.5 and
 *      later.
 *  
 *  Result:
 *    errUserWantsToDragWindow if the user’s mouse movements indicated
 *    that the user actually wants to drag the window instead of the
 *    proxy icon (in this case the application should call DragWindow);
 *    windowWrongStateErr if the window was modified and therefore the
 *    proxy icon could not be dragged; noErr if the drag succeeded;
 *    userCanceledErr if the user canceled the drag. Other operating
 *    system result codes may also be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
TrackWindowProxyFromExistingDrag(
  WindowRef   window,
  Point       startPt,
  DragRef     drag,
  RgnHandle   inDragOutlineRgn)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  TrackWindowProxyDrag()
 *  
 *  Summary:
 *    Tracks the drag of a window proxy icon.
 *  
 *  Discussion:
 *    A proxy icon may only be dragged if the window represented by the
 *    proxy icon is not modifed (as indicated by the IsWindowModified
 *    API). This restriction is imposed because a proxy icon is a
 *    representation of a physical file system object, and dragging the
 *    proxy icon may result in the Finder making a copy of the file
 *    system object. If the window is modified, then it contains user
 *    data that has not yet been saved to disk; making a copy of the
 *    file system object would result in a stale copy that did not
 *    contain the user’s current data.
 *    
 *    By default, all newly created windows are considered to be
 *    modified. The application must call SetWindowModified( window,
 *    false ) before the proxy icon will be draggable.
 *    
 *    In Mac OS X 10.3 and later, the proxy icon is also draggable in
 *    dirty windows if the proxy icon was provided using the
 *    SetWindowProxyIcon or SetWindowProxyCreatorAndType APIs. Dragging
 *    is allowed in this case because the window does not represent an
 *    actual file system object, and therefore there is no risk of user
 *    data loss.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to drag.
 *    
 *    startPt:
 *      The point in global coordinates where the drag originated. This
 *      is generally the location of the mouse click in the proxy icon.
 *  
 *  Result:
 *    errUserWantsToDragWindow if the user’s mouse movements indicated
 *    that the user actually wants to drag the window instead of the
 *    proxy icon (in this case the application should call DragWindow);
 *    windowWrongStateErr if the window was modified and therefore the
 *    proxy icon could not be dragged; noErr if the drag succeeded;
 *    userCanceledErr if the user canceled the drag. Other operating
 *    system result codes may also be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
TrackWindowProxyDrag(
  WindowRef   window,
  Point       startPt)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsWindowModified()
 *  
 *  Summary:
 *    Returns whether the window is considered to have unsaved content.
 *  
 *  Discussion:
 *    By default, all newly created windows are considered to be
 *    modified. The application must call SetWindowModified( window,
 *    false ) to mark the window as unmodified. Until the window is
 *    marked as unmodified, the proxy icon will not be draggable.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose modified state to return.
 *  
 *  Result:
 *    true if the window has unsaved changes, or false if not.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern Boolean 
IsWindowModified(WindowRef window)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowModified()
 *  
 *  Summary:
 *    Sets whether the window is considered to have unsaved content.
 *  
 *  Discussion:
 *    By default, all newly created windows are considered to be
 *    modified. The application must call SetWindowModified( window,
 *    false ) to mark the window as unmodified. Until the window is
 *    marked as unmodified, the proxy icon will not be draggable.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose modified state to return.
 *    
 *    modified:
 *      Whether the window has unsaved changes.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowModified(
  WindowRef   window,
  Boolean     modified)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsWindowPathSelectEvent()
 *  
 *  Summary:
 *    Indicates whether a Carbon event describing a click on a window’s
 *    title should cause a path selection menu to be displayed.
 *  
 *  Discussion:
 *    Windows that have a proxy icon provided using an FSSpec or alias
 *    can support a path selection menu, which displays the file system
 *    path to the object, one menu item per directory. Making a
 *    selection from this item will automatically open the
 *    corresponding object in the Finder.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window on which the click occurred.
 *    
 *    inEvent:
 *      The event. In CarbonLib and in Mac OS X 10.2 and earlier,
 *      IsWindowPathSelectEvent only returned true for
 *      kEventClassMouse/ kEventMouseDown events. In Mac OS X 10.3 and
 *      later, IsWindowPathSelectEvent returns true for any event that
 *      has suitable kEventParamMouseLocation and
 *      kEventParamKeyModifiers parameters.
 *  
 *  Result:
 *    true if the click should cause a path selection menu to be
 *    displayed, or false if not. If this API returns true, the
 *    application should call the WindowPathSelect API.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsWindowPathSelectEvent(
  WindowRef   window,
  EventRef    inEvent)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  WindowPathSelect()
 *  
 *  Summary:
 *    Displays a path selection menu for a window that has a proxy icon.
 *  
 *  Discussion:
 *    If the application passes NULL for the menu parameter, and the
 *    user selects an item from the path selection menu, the Window
 *    Manager will automatically request the Finder to display that
 *    item, and in CarbonLib 1.3.1 and later and Mac OS X, will also
 *    make the Finder be the active application.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window for which to display the path selection menu.
 *    
 *    menu:
 *      The menu to display. If you pass NULL, the Window Manager
 *      automatically creates a suitable menu based on the window’s
 *      proxy icon.
 *    
 *    outMenuResult:
 *      On exit, the menu ID and menu item index of the selected item;
 *      the menu ID is in the high 16 bits of the result, and the menu
 *      item index is in the low 16 bits.
 *  
 *  Result:
 *    noErr if the user selected an item from the menu; userCanceledErr
 *    if the user closed the menu without making a selection. Other
 *    operating system result codes may be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
WindowPathSelect(
  WindowRef   window,
  MenuRef     menu,                /* can be NULL */
  SInt32 *    outMenuResult)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • HiliteWindowFrameForDrag                                                          */
/*                                                                                      */
/*  If you call ShowDragHilite and HideDragHilite, you don’t need to use this routine.  */
/*  If you implement custom drag hiliting, you should call HiliteWindowFrameForDrag     */
/*  when the drag is tracking inside a window with drag-hilited content.                */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* Routines available from Mac OS 8.5 forward*/

/*
 *  HiliteWindowFrameForDrag()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
HiliteWindowFrameForDrag(
  WindowRef   window,
  Boolean     hilited)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Transitions                                                                 */
/*                                                                                      */
/*  TransitionWindow displays a window with accompanying animation and sound.           */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */


/*
 *  WindowTransitionEffect
 *  
 *  Summary:
 *    Visual effects that are provided by TransitionWindow
 */
typedef UInt32 WindowTransitionEffect;
enum {

  /*
   * Finder-like zoom rectangles. Use with TransitionWindow and Show or
   * Hide transition actions. In Mac OS X 10.7 and later, this effect
   * can also be used with the Resize transition action to show the
   * standard animation effect for zooming a window to a new size. The
   * combination of the Zoom effect and the Resize action is only
   * recommended for use with compositing windows.
   */
  kWindowZoomTransitionEffect   = 1,

  /*
   * Zoom in/out from parent. Use with TransitionWindowAndParent and
   * Show or Hide transition actions. Available in Mac OS X, and in
   * CarbonLib 1.5 and later.
   */
  kWindowSheetTransitionEffect  = 2,

  /*
   * Slide the window into its new position. Use with TransitionWindow
   * and Move or Resize transition actions. Available in Mac OS X, and
   * in CarbonLib 1.5 and later.
   */
  kWindowSlideTransitionEffect  = 3,

  /*
   * Fade the window into or out of visibility. Use with the Show or
   * Hide transition actions. Available in Mac OS X 10.3 and later.
   */
  kWindowFadeTransitionEffect   = 4,

  /*
   * Use the Genie effect that the Dock uses to minimize or maximize a
   * window to show or hide the window. Use with the Show or Hide
   * transition actions. Available in Mac OS X 10.3 and later.
   */
  kWindowGenieTransitionEffect  = 5
};


/*
 *  WindowTransitionAction
 *  
 *  Summary:
 *    Modifications to window state that are provided by
 *    TransitionWindow
 */
typedef UInt32 WindowTransitionAction;
enum {

  /*
   * Shows the window. Use with the Zoom, Sheet, Fade, or Genie
   * transition effects. For the Zoom, Sheet, and Genie effects, the
   * inRect parameter is the global coordinates from which to start the
   * animation; inRect may be NULL for the Zoom and Sheet effects, and
   * in that case, the animation begins at the center of the window.
   * The Genie effect requires a non-NULL inRect parameter. The Fade
   * effect does not use the inRect parameter.
   */
  kWindowShowTransitionAction   = 1,

  /*
   * Hides the window. Use with the Zoom, Sheet, Fade, or Genie
   * transition effects. For the Zoom, Sheet, and Genie effects, the
   * inRect parameter is the global coordinates at which to end the
   * animation; inRect may be NULL for the Zoom and Sheet effects, and
   * in that case, the animation ends at the center of the window. The
   * Genie effect requires a non-NULL inRect parameter. The Fade effect
   * does not use the inRect parameter.
   */
  kWindowHideTransitionAction   = 2,

  /*
   * Moves the window. Use with the Slide transition effect. The inRect
   * parameter is the global coordinates of the window's new structure
   * bounds; inRect must be non-NULL. Available in Mac OS X, and in
   * CarbonLib 1.5 and later.
   */
  kWindowMoveTransitionAction   = 3,

  /*
   * Resizes the window. Use with the Slide transition effect. In Mac
   * OS X 10.7 and later, the Zoom transition effect is also supported
   * with this action, for use by applications that respond to a zoom
   * box click by resizing the window programmatically without calling
   * the ZoomWindow or ZoomWindowIdeal APIs. The inRect parameter is
   * the global coordinates of the window's new structure bounds;
   * inRect must be non-NULL. Available in Mac OS X, and in CarbonLib
   * 1.5 and later.
   */
  kWindowResizeTransitionAction = 4
};

#if !__LP64__
/*
 *  TransitionWindow()
 *  
 *  Summary:
 *    Shows, hides, moves, or resizes a window with appropriate
 *    animation and sound.
 *  
 *  Discussion:
 *    In Mac OS X 10.3 and later, this API sends
 *    kEventWindowTransitionStarted and kEventWindowTransitionCompleted
 *    Carbon events to the transitioning window at the start and end of
 *    the transition.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window on which to act.
 *    
 *    inEffect:
 *      The type of visual effect to use. TransitionWindow supports the
 *      Zoom, Slide, Fade, and Genie transition effects. The Slide
 *      effect is supported on Mac OS X and in CarbonLib 1.5 and later.
 *      The Fade and Genie effects are supported on Mac OS X 10.3 and
 *      later.
 *    
 *    inAction:
 *      The action to take on the window. TransitionWindow supports the
 *      Show, Hide, Move, and Resize actions. The Move and Resize
 *      actions are supported on Mac OS X and in CarbonLib 1.5 and
 *      later.
 *    
 *    inRect:
 *      A screen rect in global coordinates. The interpretation of the
 *      rect is dependent on the transition action; see the
 *      documentation for each action for details. May be NULL for some
 *      transition actions.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
TransitionWindow(
  WindowRef                inWindow,
  WindowTransitionEffect   inEffect,
  WindowTransitionAction   inAction,
  const Rect *             inRect)         /* can be NULL */  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  TransitionWindowAndParent()
 *  
 *  Summary:
 *    Shows or hides a window, potentially also moving a second window,
 *    with appropriate animation and sound.
 *  
 *  Discussion:
 *    In Mac OS X 10.3 and later, this API sends
 *    kEventWindowTransitionStarted and kEventWindowTransitionCompleted
 *    Carbon events to the transitioning window at the start and end of
 *    the transition.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window on which to act.
 *    
 *    inParentWindow:
 *      The window to which the primary window is related. For the
 *      Sheet effect, this parameter must specify a valid WindowRef; it
 *      should be NULL for other effects.
 *    
 *    inEffect:
 *      The type of visual effect to use. TransitionWindowAndParent is
 *      most commonly used to perform the Sheet transition effect, but
 *      also supports the Zoom, Slide, Fade, and Genie effects.
 *    
 *    inAction:
 *      The action to take on the window. TransitionWindowAndParent
 *      supports the Show, Hide, Move, and Resize actions.
 *    
 *    inRect:
 *      A screen rect in global coordinates. The interpretation of the
 *      rect is dependent on the transition action; see the
 *      documentation for each action for details. May be NULL for some
 *      transition actions.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TransitionWindowAndParent(
  WindowRef                inWindow,
  WindowRef                inParentWindow,
  WindowTransitionEffect   inEffect,
  WindowTransitionAction   inAction,
  const Rect *             inRect)               /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  TransitionWindowOptions
 *  
 *  Summary:
 *    Extensible parameter block for the TransitionWindowWithOptions
 *    API.
 */
struct TransitionWindowOptions {

  /*
   * The structure version. You must put 0 in this field.
   */
  UInt32              version;

  /*
   * The duration of the fade, in seconds. For use with the Sheet,
   * Slide, Fade, and Genie transition effects; ignored for other
   * effects. You may pass 0 to use the default duration. The effect is
   * not guaranteed to last precisely this long, but should be a close
   * approximation.
   */
  EventTime           duration;

  /*
   * For use with kWindowSheetTransitionEffect. This is the parent
   * window of the sheet.
   */
  WindowRef           window;

  /*
   * This value will be sent as the kEventParamUserData parameter for
   * the kEventWindowTransitionStarted and
   * kEventWindowTransitionCompleted events.
   */
  void *              userData;
};
typedef struct TransitionWindowOptions  TransitionWindowOptions;
#if !__LP64__
/*
 *  TransitionWindowWithOptions()
 *  
 *  Summary:
 *    Transitions a window from one state to another with appropriate
 *    animation and sound.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window that should be transitioned.
 *    
 *    inEffect:
 *      The type of visual effect to use.
 *    
 *    inAction:
 *      The action to take on the window.
 *    
 *    inBounds:
 *      A screen rect in global coordinates. The interpretation of the
 *      rect is dependent on the transition action; see the
 *      documentation for each action for details. May be NULL for some
 *      transition actions.
 *    
 *    inAsync:
 *      Whether the transition should run synchronously or
 *      asynchronously. If inAsync is true, TransitionWindow will
 *      return immediately, and the transition will run using an event
 *      loop timer. You must run your event loop for the transition to
 *      occur. If inAsync is false, TransitionWindow will block until
 *      the transition is completed. In either case, the
 *      kEventWindowTransitionStarted and
 *      kEventWindowTransitionCompleted Carbon events will be sent to
 *      the transitioning window at the start and end of the transition.
 *    
 *    inOptions:
 *      Extra options that are required for some transitions. This
 *      parameter may be NULL if the specific transition effect does
 *      not require extra information.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TransitionWindowWithOptions(
  WindowRef                        inWindow,
  WindowTransitionEffect           inEffect,
  WindowTransitionAction           inAction,
  const HIRect *                   inBounds,        /* can be NULL */
  Boolean                          inAsync,
  const TransitionWindowOptions *  inOptions)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Positioning                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————*/

/*
 *  [Mac]MoveWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacMoveWindow MoveWindow
#endif
extern void 
MacMoveWindow(
  WindowRef   window,
  short       hGlobal,
  short       vGlobal,
  Boolean     front)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SizeWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SizeWindow(
  WindowRef   window,
  short       w,
  short       h,
  Boolean     fUpdate)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ResizeWindow()
 *  
 *  Summary:
 *    Handles all user interaction while a window is being resized.
 *  
 *  Discussion:
 *    The ResizeWindow function moves either an outline of the window's
 *    edges (on Mac OS 9.x and earlier) or the actual window (on Mac OS
 *    X) around the screen, following the user’s cursor movements, and
 *    handles all user interaction until the mouse button is released.
 *    Unlike the GrowWindow API, there is no need to follow this call
 *    with a call to the function SizeWindow, because once the mouse
 *    button is released, ResizeWindow resizes the window if the user
 *    has changed the window size. Once the resizing is complete,
 *    ResizeWindow draws the window in the new size. Your application
 *    should call the ResizeWindow function instead of the earlier
 *    Window Manager APIs SizeWindow and GrowWindow. Some windows may
 *    allow themselves to be resized from any corner or edge, not just
 *    the bottom right, and as a result, when the user resizes the
 *    window, the window may move on the screen and not merely change
 *    size. ResizeWindow informs your application of the new window
 *    bounds, so that your application can respond to any changes in
 *    the window’s position.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to be resized.
 *    
 *    inStartPoint:
 *      The point, in global coordinates, at which the original
 *      mouse-down occurred.
 *    
 *    inSizeConstraints:
 *      The limits on the vertical and horizontal measurements of the
 *      content rectangle, in pixels. Although this parameter is typed
 *      as a Rect, the four numbers in the structure represent limits,
 *      not screen coordinates. The top, left, bottom, and right fields
 *      of the structure specify the minimum vertical measurement
 *      (top), the minimum horizontal measurement (left), the maximum
 *      vertical measurement (bottom), and the maximum horizontal
 *      measurement (right). The minimum dimensions should be large
 *      enough to allow a manageable rectangle; 64 pixels on a side is
 *      typical. The maximum dimensions can be no greater than 32,767.
 *      You can pass NULL to allow the user to resize the window to any
 *      size that is contained onscreen.
 *    
 *    outNewContentRect:
 *      On exit, the structure contains the new dimensions of the
 *      window’s content region, in global coordinates. On Mac OS 9.x
 *      and earlier, you must pass a non-NULL value in this parameter;
 *      in Carbon, you may pass NULL if you do not need the window’s
 *      new dimensions.
 *  
 *  Result:
 *    Returns true if the window changed size, or false if not.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern Boolean 
ResizeWindow(
  WindowRef     inWindow,
  Point         inStartPoint,
  const Rect *  inSizeConstraints,       /* can be NULL */
  Rect *        outNewContentRect)       /* can be NULL */    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  DragWindow()
 *  
 *  Summary:
 *    Allows the user to drag a window to a different position.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window to drag.
 *    
 *    startPt:
 *      The point in global coordinates where the mouse was clicked on
 *      the window.
 *    
 *    boundsRect:
 *      A rect in global coordinates outside of which the window cannot
 *      move. May be NULL in CarbonLib and Mac OS X, to indicate that
 *      there are no restrictions on window movement. This parameter is
 *      ignored by CarbonLib and Mac OS X 10.0 through 10.2; it is
 *      obeyed in Mac OS X 10.3 and later.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
DragWindow(
  WindowRef     window,
  Point         startPt,
  const Rect *  boundsRect)       /* can be NULL */           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ZoomWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
ZoomWindow(
  WindowRef        window,
  WindowPartCode   partCode,
  Boolean          front)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Collapsing/Expanding                                                        */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* Routines available from Mac OS 8.0 (Appearance 1.0) forward*/
/*
 *  IsWindowCollapsable()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern Boolean 
IsWindowCollapsable(WindowRef window)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsWindowCollapsed()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern Boolean 
IsWindowCollapsed(WindowRef window)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CollapseWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSStatus 
CollapseWindow(
  WindowRef   window,
  Boolean     collapse)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CollapseAllWindows()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSStatus 
CollapseAllWindows(Boolean collapse)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowCreateCollapsedDockTileContext()
 *  
 *  Summary:
 *    Creates a CGContextRef that can be used to draw into a collapsed
 *    window's Dock tile.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The collapsed window.
 *    
 *    outContext:
 *      On exit, returns a CGContextRef for drawing into the window's
 *      Dock tile. You should use
 *      HIWindowReleaseCollapsedDockTileContext to release this
 *      context. To ensure that drawing to the context appears
 *      onscreen, make sure to call CGContextFlush before releasing the
 *      context.
 *    
 *    outContextSize:
 *      On exit, returns the size of the context in which the
 *      application should draw.
 *  
 *  Result:
 *    An operating system result code. windowWrongStateErr is returned
 *    if the window is not collapsed.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowCreateCollapsedDockTileContext(
  WindowRef       inWindow,
  CGContextRef *  outContext,
  HISize *        outContextSize)                             AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowReleaseCollapsedDockTileContext()
 *  
 *  Discussion:
 *    Releases a CGContextRef and other state created by the
 *    HIWindowCreateCollapsedDockTileContext API. You MUST call this
 *    instead of CFRelease/CGContextRelease directly, or you may leak
 *    system resources.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The collapsed window for which you created the CGContextRef.
 *    
 *    inContext:
 *      The context to release. The context is invalid after this call
 *      and should no longer be used. To ensure that drawing to the
 *      context appears onscreen, make sure to call CGContextFlush
 *      before releasing the context.
 *  
 *  Result:
 *    An operating system result code. windowWrongStateErr is returned
 *    if the window is not collapsed.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowReleaseCollapsedDockTileContext(
  WindowRef      inWindow,
  CGContextRef   inContext)                                   AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  CreateQDContextForCollapsedWindowDockTile()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIWindowCreateCollapsedDockTileContext instead.
 *  
 *  Discussion:
 *    Creates and returns a CGrafPtr for a collapsed window's tile in
 *    the dock. You can use this port to draw into your window's dock
 *    tile with Quickdraw. You MUST call
 *    ReleaseQDContextForCollapsedWindowDockTile and NOT DisposePort
 *    when using this API, as it maintains more state than just the
 *    port. If you call DisposePort, you may leak system resources.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to create the dock tile port for. If this window is
 *      not collapsed, an error is returned.
 *    
 *    outContext:
 *      The Quickdraw port for you to use to draw into. If you wish to
 *      use CoreGraphics (Quartz) drawing, call CreateCGContextForPort
 *      with this port to obtain a CGContext.
 *  
 *  Result:
 *    An operating system result code. windowWrongStateErr is returned
 *    if the window is not collapsed.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CreateQDContextForCollapsedWindowDockTile(
  WindowRef   inWindow,
  CGrafPtr *  outContext)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  ReleaseQDContextForCollapsedWindowDockTile()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIWindowReleaseCollapsedDockTileContext instead.
 *  
 *  Discussion:
 *    Releases a port and other state created by the
 *    CreateQDContextForCollapsedWindowDockTile API. You MUST call this
 *    instead of DisposePort directly, or you may leak system resources.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window you created the port for. If this window is not
 *      collapsed, an error is returned.
 *    
 *    inContext:
 *      The Quickdraw context to dispose.
 *  
 *  Result:
 *    An operating system result code. windowWrongStateErr is returned
 *    if the window is not collapsed.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ReleaseQDContextForCollapsedWindowDockTile(
  WindowRef   inWindow,
  CGrafPtr    inContext)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  UpdateCollapsedWindowDockTile()
 *  
 *  Discussion:
 *    Automatically updates the image of a particular window in the
 *    dock to the current contents of the window. Use this for periodic
 *    updates, etc. Do not use this for animation purposes, if you want
 *    animation, use the above create/release drawing context APIs.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to update the dock tile for. If this window is not
 *      collapsed, an error is returned.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
UpdateCollapsedWindowDockTile(WindowRef inWindow)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowDockTileMenu()
 *  
 *  Summary:
 *    Sets the menu that is displayed by a window's dock tile.
 *  
 *  Discussion:
 *    When a window's dock tile menu is right-clicked or
 *    control-clicked, the Dock will always automatically display a
 *    menu containing a Close menu item that closes the window. If the
 *    application wants to add other additional menu items, it can use
 *    the SetWindowDockTileMenu API to provide those items. The items
 *    in the specified menu will be combined with the standard items
 *    provided by the Dock.
 *    
 *    Before the menu is actually displayed, it will receive
 *    kEventMenuPopulate, kEventMenuOpening, and kEventMenuEnableItems
 *    Carbon events, so any event handlers for these events may update
 *    the menu appropriately for the current state of the
 *    application.
 *    
 *    The application should set a command ID for each menu item in the
 *    dock tile menu, and when that item is chosen, a
 *    kEventCommandProcess Carbon event containing the item's command
 *    ID will be sent to the window's event target (and from there to
 *    the application, if the window does not handle the
 *    event).
 *    
 *    This API increments the refcount of the specified menu.
 *    
 *    The toolbox provides a default handler for the
 *    kEventWindowGetDockTileMenu event that returns the menu specified
 *    by the SetWindowDockTileMenu API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window for which to set the dock tile menu.
 *    
 *    inMenu:
 *      The menu to display, or NULL to remove the current dock tile
 *      menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowDockTileMenu(
  WindowRef   inWindow,
  MenuRef     inMenu)         /* can be NULL */               AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  GetWindowDockTileMenu()
 *  
 *  Summary:
 *    Returns the menu that is displayed by a window's dock tile.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    The application's dock tile menu, or NULL if none.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern MenuRef 
GetWindowDockTileMenu(WindowRef inWindow)                     AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  HIWindowGetBounds()
 *  
 *  Summary:
 *    Retrieves the bounds of a specified region of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose bounds to return.
 *    
 *    inRegion:
 *      The window region whose bounds to return.
 *    
 *    inSpace:
 *      The coordinate space in which the bounds should be returned.
 *      This must be kHICoordSpaceWindow, kHICoordSpaceScreenPixel, or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    outBounds:
 *      On exit, contains the bounds of the specified window region. If
 *      the region is not supported, this parameter is not modified.
 *  
 *  Result:
 *    An operating system result code. errWindowRegionCodeInvalid is
 *    returned if the window does not support the specified window
 *    region.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetBounds(
  WindowRef           inWindow,
  WindowRegionCode    inRegion,
  HICoordinateSpace   inSpace,
  HIRect *            outBounds)                              AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowSetBounds()
 *  
 *  Summary:
 *    Sets the bounds of a window based on either the structure or
 *    content region of the window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose bounds to set.
 *    
 *    inRegion:
 *      The window region on which to base the window's new bounds.
 *      This parameter must be either kWindowStructureRgn or
 *      kWindowContentRgn.
 *    
 *    inSpace:
 *      The coordinate space in which the bounds are expressed. This
 *      must be kHICoordSpaceWindow, kHICoordSpaceScreenPixel, or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    inBounds:
 *      The new bounds of the specified window region. If the
 *      coordinate space is kHICoordSpaceWindow, then the origin of the
 *      bounds is a window-relative value. Therefore, you can use the
 *      Window coordinate space to resize a window without first
 *      getting its current bounds by setting the origin to (0,0), or
 *      you can offset a window from its current position by setting
 *      the origin to the offset amount and the size to the window's
 *      current size.
 *  
 *  Result:
 *    An operating system result code. errWindowRegionCodeInvalid is
 *    returned if the inRegion parameter is any value other than
 *    kWindowStructureRgn or kWindowContentRgn.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetBounds(
  WindowRef           inWindow,
  WindowRegionCode    inRegion,
  HICoordinateSpace   inSpace,
  const HIRect *      inBounds)                               AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
   Routines available from Mac OS 8.5 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/

/*
 *  GetWindowBounds()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowBounds(
  WindowRef          window,
  WindowRegionCode   regionCode,
  Rect *             globalBounds)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowResizeLimits()
 *  
 *  Summary:
 *    Sets the minimum and maximum content sizes for a window.
 *  
 *  Discussion:
 *    The minimum and maximum sizes are obeyed by ResizeWindow and
 *    GrowWindow. The default Carbon event handler installed for all
 *    windows will return these sizes in response to
 *    kEventWindowGetMinimumSize and kEventWindowGetMaximumSize events.
 *    When a window is first created, its minimum and maximum sizes are
 *    set to reasonable values (which may change from one system
 *    release to the next).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose minimum and maximum sizes to set.
 *    
 *    inMinLimits:
 *      The new minimum size for the content region of the window. Pass
 *      NULL if you don't want to set a minimum size.
 *    
 *    inMaxLimits:
 *      The new maximum size for the content region of the window. Pass
 *      NULL if you don't want to set a maximum size.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowResizeLimits(
  WindowRef       inWindow,
  const HISize *  inMinLimits,       /* can be NULL */
  const HISize *  inMaxLimits)       /* can be NULL */        AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  GetWindowResizeLimits()
 *  
 *  Summary:
 *    Returns the minimum and maximum content sizes for a window.
 *  
 *  Discussion:
 *    GetWindowResizeLimits returns the minimum and maximum sizes that
 *    were set by SetWindowResizeLimits. Note that it does not send
 *    kEventWindowGetMinimumSize or kEventWindowGetMaximumSize Carbon
 *    events to get these sizes; it simply retrieves the sizes from the
 *    WindowRef. It is entirely possible (and quite likely) that a
 *    given window will have event handlers for the
 *    kEventWindowGetMinimum/MaximumSize events that will modify or
 *    override the sizes in the WindowRef; therefore, to accurately
 *    determine the desired minimum and maximum sizes, you should send
 *    kEventWindowGetMinimum/MaximumSize Carbon events rather than
 *    using this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose minimum and maximum sizes to retrieve.
 *    
 *    outMinLimits:
 *      On exit, contains the minimum size of the window's content
 *      region. Pass NULL if you don't want this information.
 *    
 *    outMaxLimits:
 *      On exit, contains the maximum size of the window's content
 *      region. Pass NULL if you don't want this information.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowResizeLimits(
  WindowRef   inWindow,
  HISize *    outMinLimits,       /* can be NULL */
  HISize *    outMaxLimits)       /* can be NULL */           AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
   Routines available from Mac OS 8.5 forward,
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0.2 forward
*/

/*
 *  SetWindowBounds()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowBounds(
  WindowRef          window,
  WindowRegionCode   regionCode,
  const Rect *       globalBounds)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RepositionWindow()
 *  
 *  Summary:
 *    Positions a window according in one of the standard window
 *    locations.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window to position.
 *    
 *    parentWindow:
 *      For some positioning methods, the new location for the
 *      positioned window will be calculated based on the parent
 *      window’s position. On Mac OS X 10.3 and later, some positioning
 *      methods allow this parameter to be the same as the window
 *      parameter; CarbonLib and earlier versions of Mac OS X require
 *      that it be different from the window parameter. See the
 *      WindowPositionMethod documentation for details on which methods
 *      allow the parent to be the same as the positioned window.
 *    
 *    method:
 *      The window positioning method. This should be one of the
 *      WindowPositionMethod constants.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
RepositionWindow(
  WindowRef              window,
  WindowRef              parentWindow,
  WindowPositionMethod   method)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  MoveWindowStructure()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
MoveWindowStructure(
  WindowRef   window,
  short       hGlobal,
  short       vGlobal)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
   Routines available from Mac OS 8.5 forward,
   or from Mac OS 8.6 forward when linking to CarbonLib 1.1 forward
*/

/* Routines available from Mac OS 8.5 forward*/

/*
 *  HIWindowIsInStandardState()
 *  
 *  Summary:
 *    Determines whether a window is currently zoomed in to the user
 *    state or zoomed out to the standard state.
 *  
 *  Discussion:
 *    HIWindowIsInStandardState compares the window’s current
 *    dimensions to those given by the inIdealSize parameter to
 *    determine if the window is currently in its standard (zoomed-out)
 *    state. Your application may use HIWindowIsInStandardState to
 *    decide whether a user’s click of the zoom box is a request to
 *    zoom in to the user state or out to the standard state. Your
 *    application may also use HIWindowIsInStandardState to determine
 *    the size and position of the standard state that the Window
 *    Manager would calculate for a window, given a specified ideal
 *    size; this value is returned in the outIdealStandardState
 *    parameter.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window for which to determine the zoom state.
 *    
 *    inIdealSize:
 *      The ideal width and height of the window’s content region,
 *      regardless of the actual screen device dimensions. If you set
 *      idealSize to NULL, HIWindowIsInStandardState examines the
 *      dimensions stored in the stdState field of the WStateData
 *      structure attached to the window.
 *    
 *    inSpace:
 *      The coordinate space in which the ideal size is expressed and
 *      in which the standard state bounds should be returned. This
 *      must be kHICoordSpaceScreenPixel or kHICoordSpace72DPIGlobal.
 *    
 *    outIdealStandardState:
 *      On exit, contains the global coordinates for the content region
 *      of the window in its standard state, based on the data supplied
 *      in the inIdealSize parameter. The coordinates are in either
 *      screen pixels or 72DPI virtual coordinates. You may pass NULL
 *      if you do not need this information.
 *  
 *  Result:
 *    Returns true if the window is currently in its standard
 *    (zoomed-out) state, or false if the window is a non-zoomed-out
 *    state.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIWindowIsInStandardState(
  WindowRef           inWindow,
  const HISize *      inIdealSize,                 /* can be NULL */
  HICoordinateSpace   inSpace,
  HIRect *            outIdealStandardState)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  IsWindowInStandardState()
 *  
 *  Summary:
 *    Determines whether a window is currently zoomed in to the user
 *    state or zoomed out to the standard state.
 *  
 *  Discussion:
 *    IsWindowInStandardState compares the window’s current dimensions
 *    to those given by the inIdealSize parameter to determine if the
 *    window is currently in its standard (zoomed-out) state. Your
 *    application may use IsWindowInStandardState to decide whether a
 *    user’s click of the zoom box is a request to zoom in to the user
 *    state or out to the standard state. Your application may also use
 *    IsWindowInStandardState to determine the size and position of the
 *    standard state that the Window Manager would calculate for a
 *    window, given a specified ideal size; this value is returned in
 *    the outIdealStandardState parameter.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window for which to determine the zoom state.
 *    
 *    inIdealSize:
 *      The ideal width and height of the window’s content region,
 *      regardless of the actual screen device dimensions. If you set
 *      idealSize to NULL, IsWindowInStandardState examines the
 *      dimensions stored in the stdState field of the WStateData
 *      structure attached to the window.
 *    
 *    outIdealStandardState:
 *      On exit, contains the global coordinates for the content region
 *      of the window in its standard state, based on the data supplied
 *      in the inIdealSize parameter. You may pass NULL if you do not
 *      need this information.
 *  
 *  Result:
 *    Returns true if the window is currently in its standard
 *    (zoomed-out) state, or false if the window is a non-zoomed-out
 *    state.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern Boolean 
IsWindowInStandardState(
  WindowRef      inWindow,
  const Point *  inIdealSize,                 /* can be NULL */
  Rect *         outIdealStandardState)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ZoomWindowIdeal()
 *  
 *  Summary:
 *    Zooms a window in accordance with human interface guidelines.
 *  
 *  Discussion:
 *    Applications should use the ZoomWindowIdeal API instead of the
 *    older ZoomWindow API. When your application calls
 *    ZoomWindowIdeal, it automatically conforms to the human interface
 *    guidelines for determining a window’s standard state: the window
 *    is moved as little as possible when switching between user and
 *    standard states, the window is zoomed to the screen that contains
 *    the largest portion of the window, and the window is positioned
 *    in its zoomed-out size to avoid the Dock on Mac OS X. 
 *    
 *    The ZoomWindowIdeal API calculates a window’s ideal standard
 *    state and updates a window’s ideal user state independently of
 *    the WStateData structure. Previously, the window definition
 *    function was responsible for updating the user state, but because
 *    it relies upon the WStateData structure, the window definition
 *    function is unaware of the ideal standard state and can no longer
 *    track the window’s zoom state reliably. The Window Manager
 *    provides the GetWindowIdealUserState and SetWindowIdealUserState
 *    APIs to access a window's current ideal user state, previously
 *    recorded by ZoomWindowIdeal. 
 *    
 *    In Mac OS X 10.7 and later, the ZoomWindowIdeal API automatically
 *    uses an animation to resize the window to its new size, if the
 *    window uses composited mode.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to be zoomed.
 *    
 *    inPartCode:
 *      The direction of the zoom, either inZoomIn or inZoomOut. The
 *      value passed in this parameter should generally be determined
 *      by calling IsWindowInStandardState; if IsWindowInStandardState
 *      returns true, pass inZoomIn, otherwise pass inZoomOut.
 *    
 *    ioIdealSize:
 *      When you specify inZoomIn in the inPartCode parameter, this
 *      parameter is unused on entry; you pass a pointer to a Point
 *      structure, but do not fill the structure with data. On exit,
 *      the Point contains the new height and width of the window’s
 *      content region, and ZoomWindowIdeal restores the previous ideal
 *      user state. When you specify inZoomOut in the inPartCode
 *      parameter, you pass the ideal height and width of the window’s
 *      content region in the Point structure. On return, the Point
 *      contains the new height and width of the window’s content
 *      region; ZoomWindowIdeal saves the current user state of the
 *      window and zooms the window to its ideal size for the standard
 *      state. 
 *      
 *      Prior to Mac OS X Mac OS X 10.4, the ZoomWindowIdeal API
 *      malfunctioned if passed an idealSize that was large enough to
 *      cause 16-bit integer overflow when added to the window's
 *      current position. Therefore, when specifying the ideal size
 *      parameter, you should generally not use values that are close
 *      to 32767. It is better to limit your ideal size to, say, 16K.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
ZoomWindowIdeal(
  WindowRef        inWindow,
  WindowPartCode   inPartCode,
  Point *          ioIdealSize)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowGetIdealUserState()
 *  
 *  Summary:
 *    Returns the bounds of a window’s content region in its user
 *    (zoomed-in) state.
 *  
 *  Discussion:
 *    The HIWindowGetIdealUserState API returns the window’s user state
 *    most recently recorded by ZoomWindowIdeal.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose ideal user state you wish to retrieve.
 *    
 *    inSpace:
 *      The coordinate space in which the user state bounds should be
 *      returned. This must be kHICoordSpaceScreenPixel or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    outUserState:
 *      On exit, contains the global coordinates of the window’s
 *      content region when zoomed in, in either screen pixels or 72DPI
 *      virtual coordinates. HIWindowGetIdealUserState automatically
 *      returns the window’s current content bounds if the window has
 *      not yet been zoomed.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetIdealUserState(
  WindowRef           inWindow,
  HICoordinateSpace   inSpace,
  HIRect *            outUserState)                           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowSetIdealUserState()
 *  
 *  Summary:
 *    Sets the bounds of a window’s content region in its user
 *    (zoomed-in) state.
 *  
 *  Discussion:
 *    The window’s ideal user state is used by the ZoomWindowIdeal API
 *    when zooming in. The ideal user state is ignored by the
 *    ZoomWindow API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose ideal user state to set.
 *    
 *    inSpace:
 *      The coordinate space in which the user state bounds are
 *      expressed. This must be kHICoordSpaceScreenPixel or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    inUserState:
 *      The global coordinates of the window’s content region in its
 *      ideal user state, in either screen pixels or 72DPI virtual
 *      coordinates.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetIdealUserState(
  WindowRef           inWindow,
  HICoordinateSpace   inSpace,
  const HIRect *      inUserState)                            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  GetWindowIdealUserState()
 *  
 *  Summary:
 *    Returns the bounds of a window’s content region in its user
 *    (zoomed-in) state.
 *  
 *  Discussion:
 *    Traditionally, the user (zoomed-in) state of a window has been
 *    stored in the WStateData structure attached to a window. This
 *    field is updated by the window definition when the user clicks on
 *    the zoom box and the window definition determines that the window
 *    is currently not zoomed out. When determining whether the window
 *    is zoomed out, however, the window definition can only look at
 *    the standard state stored in the WStateData field. With the
 *    introduction of the ZoomWindowIdeal API, there is a new basis for
 *    determining whether a window is zoomed out: the window’s ideal
 *    size. The window definition does not have access to the window’s
 *    ideal size, and therefore cannot accurately determine whether a
 *    window that is zoomed with ZoomWindowIdeal is in its user state
 *    or standard state; therefore, the user state that the window
 *    definition stores in the WStateData is also unreliable. The
 *    ZoomWindowIdeal API therefore stores the window’s user state
 *    before zooming out in a new location, which is accessed using the
 *    GetWindowIdealUserState API. The GetWindowIdealUserState API
 *    returns the window’s user state most recently recorded by
 *    ZoomWindowIdeal.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose ideal user state you wish to retrieve.
 *    
 *    outUserState:
 *      On exit, contains the global coordinates of the window’s
 *      content region when zoomed in. On Mac OS X 10.1 and earlier,
 *      and CarbonLib 1.5 and earlier, the window’s ideal user state is
 *      an empty rect with coordinates (0,0,0,0) if the window has
 *      never been zoomed out; you should check for an empty rect and
 *      use GetWindowBounds with the kWindowContentRgn selector to
 *      determine the window’s current content region. On later
 *      versions of Mac OS X and CarbonLib, GetWindowIdealUserState
 *      automatically returns the window’s current content bounds if
 *      the window has not yet been zoomed.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowIdealUserState(
  WindowRef   inWindow,
  Rect *      outUserState)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowIdealUserState()
 *  
 *  Summary:
 *    Sets the bounds of a window’s content region in its user
 *    (zoomed-in) state.
 *  
 *  Discussion:
 *    The window’s ideal user state is used by the ZoomWindowIdeal API
 *    when zooming in. The ideal user state is ignored by the
 *    ZoomWindow API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose ideal user state to set.
 *    
 *    inUserState:
 *      The global coordinates of the window’s content region in its
 *      ideal user state.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowIdealUserState(
  WindowRef     inWindow,
  const Rect *  inUserState)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowGreatestAreaDevice()
 *  
 *  Summary:
 *    Returns the graphics device with the greatest area of
 *    intersection with a specified window region.
 *  
 *  Discussion:
 *    HIWindowGetGreatestAreaDisplay is recommended for use instead of
 *    this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to compare against.
 *    
 *    inRegion:
 *      The window region to compare against.
 *    
 *    outGreatestDevice:
 *      On exit, the graphics device with the greatest intersection.
 *      May be NULL.
 *    
 *    outGreatestDeviceRect:
 *      On exit, the bounds of the graphics device with the greatest
 *      intersection. May be NULL. If the device with the greatest
 *      intersection also contains the menu bar, the device rect will
 *      exclude the menu bar area.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowGreatestAreaDevice(
  WindowRef          inWindow,
  WindowRegionCode   inRegion,
  GDHandle *         outGreatestDevice,           /* can be NULL */
  Rect *             outGreatestDeviceRect)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowGetGreatestAreaDisplay()
 *  
 *  Summary:
 *    Returns the display with the greatest area of intersection with a
 *    specified window region.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to compare against.
 *    
 *    inRegion:
 *      The window region to compare against.
 *    
 *    inSpace:
 *      The coordinate space in which the display bounds should be
 *      returned. This must be either kHICoordSpaceScreenPixel or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    outGreatestDisplay:
 *      On exit, the display with the greatest intersection. May be
 *      NULL if you don't need this information.
 *    
 *    outGreatestDisplayRect:
 *      On exit, the bounds of the display with the greatest
 *      intersection. May be NULL if you don't need this information.
 *      If the device with the greatest intersection also contains the
 *      menu bar, the display rect will exclude the menu bar area. This
 *      rectangle is returned in the specified coordinate space.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetGreatestAreaDisplay(
  WindowRef            inWindow,
  WindowRegionCode     inRegion,
  HICoordinateSpace    inSpace,
  CGDirectDisplayID *  outGreatestDisplay,           /* can be NULL */
  HIRect *             outGreatestDisplayRect)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  WindowConstrainOptions
 *  
 */
typedef UInt32 WindowConstrainOptions;
enum {

  /*
   * The window may be resized if necessary to make it fit onscreen.
   */
  kWindowConstrainMayResize     = (1 << 0),

  /*
   * The window will be moved even if it doesn't fit entirely onscreen.
   */
  kWindowConstrainMoveRegardlessOfFit = (1 << 1),

  /*
   * Allow partial intersection of the specified window region with the
   * screen, instead of requiring total intersection.
   */
  kWindowConstrainAllowPartial  = (1 << 2),

  /*
   * Only calculate the new window bounds; don't actually move the
   * window.
   */
  kWindowConstrainCalcOnly      = (1 << 3),

  /*
   * Use TransitionWindow with kWindowSlideTransitionEffect to move
   * windows onscreen. Available in Mac OS X 10.2.
   */
  kWindowConstrainUseTransitionWindow = (1 << 4),

  /*
   * Requests that the window be moved the minimum amount necessary to
   * be onscreen. This option applies if a partial fit is not allowed
   * (kWindowConstrainAllowPartial is not specified) or a partial fit
   * is allowed, but the window is not even partially visible. In
   * either case, the window will be moved just enough to be slightly
   * onscreen. You may customize the minimum amount that is required to
   * be visible by passing the desired dimensions in the inMinimumSize
   * parameter to HIWindowConstrain.
   */
  kWindowConstrainMoveMinimum   = (1 << 6),

  /*
   * Requests that when determining the bounds of the window region to
   * be constrained, rather than getting the current bounds of the
   * specified region, the Window Manager should use the bounds
   * provided in the ioBounds parameter to HIWindowConstrain. This
   * allows your application to constrain a window to a hypothetical
   * location; for example, if you plan to move your window such that
   * its content rect is at a certain location, and you want to know in
   * advance before moving the window whether the window would be
   * offscreen at that location, you can use this option.
   */
  kWindowConstrainUseSpecifiedBounds = (1 << 8),

  /*
   * The most common options: don't resize the window, move the window
   * regardless of fit to the screen, require total intersection of the
   * specified window region with the screen, and do actually move the
   * window.
   */
  kWindowConstrainStandardOptions = kWindowConstrainMoveRegardlessOfFit
};

#if !__LP64__
/*
 *  HIWindowConstrain()
 *  
 *  Summary:
 *    Moves and resizes a window to be within a specified bounding
 *    rectangle.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to constrain.
 *    
 *    inRegionCode:
 *      The window region to constrain.
 *    
 *    inOptions:
 *      Flags controlling how the window is constrained.
 *    
 *    inSpace:
 *      The coordinate space in which the inScreenBounds,
 *      inMinimumSize, and ioBounds parameters are expressed. This
 *      parameter must be either kHICoordSpaceScreenPixels or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    inScreenBounds:
 *      A rectangle, in either screen pixel coordinates or 72DPI
 *      virtual coordinates, within which to constrain the window. You
 *      may pass NULL if you don't need to specify a screen bounds. If
 *      NULL, the window is constrained to the screen that has the
 *      greatest intersection with the specified window region.
 *    
 *    inMinimumSize:
 *      A minimum size, in either screen pixel dimensions or 72DPI
 *      virtual dimensions, that should be kept within the specified
 *      screen bounds. This parameter is ignored if the
 *      kWindowConstrainMoveMinimum option is not set. Even if that
 *      option is set, you may still pass NULL if you don't need to
 *      customize the minimum dimensions. If NULL, the minimum size is
 *      currently seven 72DPI units in both x and y dimensions, but
 *      these values may change in different versions of Mac OS X.
 *    
 *    ioBounds:
 *      On entry, if the inOptions parameter contains
 *      kWindowConstrainUseSpecifiedBounds, then this parameter should
 *      be a bounding rect of the specified window region, in either
 *      screen pixel coordinates or 72DPI global coordinates. The
 *      bounding rect does not have to match the actual current bounds
 *      of the specified region; it may be a hypothetical bounds that
 *      you would like to constrain without actually moving the window
 *      to that location. 
 *      
 *      On exit, contains the new structure bounds of the window, in
 *      either screen pixel coordinates or 72DPI virtual coordinates.
 *      You may pass NULL if you don't need the window bounds returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowConstrain(
  WindowRef                inWindow,
  WindowRegionCode         inRegionCode,
  WindowConstrainOptions   inOptions,
  HICoordinateSpace        inSpace,
  const HIRect *           inScreenBounds,       /* can be NULL */
  const HISize *           inMinimumSize,        /* can be NULL */
  HIRect *                 ioBounds)             /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  ConstrainWindowToScreen()
 *  
 *  Summary:
 *    Moves and resizes a window so that it's contained entirely on a
 *    single screen.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindowRef:
 *      The window to constrain.
 *    
 *    inRegionCode:
 *      The window region to constrain.
 *    
 *    inOptions:
 *      Flags controlling how the window is constrained.
 *    
 *    inScreenRect:
 *      A rectangle, in global coordinates, in which to constrain the
 *      window. May be NULL. If NULL, the window is constrained to the
 *      screen with the greatest intersection with the specified window
 *      region.
 *    
 *    outStructure:
 *      On exit, contains the new structure bounds of the window, in
 *      global coordinates. May be NULL.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ConstrainWindowToScreen(
  WindowRef                inWindowRef,
  WindowRegionCode         inRegionCode,
  WindowConstrainOptions   inOptions,
  const Rect *             inScreenRect,       /* can be NULL */
  Rect *                   outStructure)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetAvailableWindowPositioningBounds()
 *  
 *  Summary:
 *    Returns the available window positioning bounds on the given
 *    screen (i.e., the screen rect minus the MenuBar and Dock if
 *    located on that screen).
 *  
 *  Discussion:
 *    HIWindowGetAvailablePositioningBounds is recommended for use
 *    instead of this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDevice:
 *      The device for which to find the available bounds. May be NULL
 *      to request the bounds of the main device.
 *    
 *    outAvailableRect:
 *      On exit, contains the available bounds for the given device.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetAvailableWindowPositioningBounds(
  GDHandle   inDevice,
  Rect *     outAvailableRect)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  GetAvailableWindowPositioningRegion()
 *  
 *  Summary:
 *    Returns the available window positioning region on the given
 *    screen (i.e., the screen rect minus the MenuBar and Dock if
 *    located on that screen).
 *  
 *  Discussion:
 *    GetAvailableWindowPositionRegion differs from
 *    GetAvailableWindowPositioningBounds in that the Bounds API
 *    removes the entire area that may theoretically be covered by the
 *    Dock, even if the the Dock does not currently reach from edge to
 *    edge of the device on which it is positioned. The Region API
 *    includes the area at the sides of the Dock that is not covered by
 *    the Dock in the available region. 
 *    
 *    HIWindowCopyAvailablePositioningShape is recommended for use
 *    instead of this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDevice:
 *      The device for which to find the available bounds. May be NULL
 *      to request the bounds of the main device.
 *    
 *    ioRgn:
 *      On entry, contains a preallocated RgnHandle. On exit, the
 *      RgnHandle has been modified to contain the available region for
 *      the given device.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetAvailableWindowPositioningRegion(
  GDHandle    inDevice,
  RgnHandle   ioRgn)                                          AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  HIWindowGetAvailablePositioningBounds()
 *  
 *  Summary:
 *    Returns the available window positioning bounds on the given
 *    display (the display bounds minus the menu bar and Dock if
 *    located on that display).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDisplay:
 *      The display for which to find the available bounds. May be
 *      kCGNullDirectDisplay to request the bounds of the main display.
 *    
 *    inSpace:
 *      The coordinate space in which the positioning bounds should be
 *      returned. This must be either kHICoordSpaceScreenPixel or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    outAvailableRect:
 *      On exit, contains the available bounds for the given display.
 *      This rectangle is returned in the specified coordinate space.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetAvailablePositioningBounds(
  CGDirectDisplayID   inDisplay,
  HICoordinateSpace   inSpace,
  HIRect *            outAvailableRect)                       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowCopyAvailablePositioningShape()
 *  
 *  Summary:
 *    Returns the available window positioning bounds on the given
 *    display (the display bounds minus the menu bar and Dock if
 *    located on that display).
 *  
 *  Discussion:
 *    HIWindowCopyAvailablePositioningShape differs from
 *    HIWindowGetAvailablePositioningBounds in that the Bounds API
 *    removes the entire area that may theoretically be covered by the
 *    Dock, even if the the Dock does not currently reach from edge to
 *    edge of the device on which it is positioned. The Shape API
 *    includes the area at the sides of the Dock that is not covered by
 *    the Dock in the available shape.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDisplay:
 *      The display for which to find the available shape. May be
 *      kCGNullDirectDisplay to request the shape of the main display.
 *    
 *    inSpace:
 *      The coordinate space in which the positioning shape should be
 *      returned. This must be either kHICoordSpaceScreenPixel or
 *      kHICoordSpace72DPIGlobal.
 *    
 *    outShape:
 *      On exit, contains the available shape for the given display.
 *      This shape is returned in the specified coordinate space.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowCopyAvailablePositioningShape(
  CGDirectDisplayID   inDisplay,
  HICoordinateSpace   inSpace,
  HIShapeRef *        outShape)                               AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Visibility                                                                  */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HideWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
HideWindow(WindowRef window)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  [Mac]ShowWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacShowWindow ShowWindow
#endif
extern void 
MacShowWindow(WindowRef window)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ShowHide()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
ShowHide(
  WindowRef   window,
  Boolean     showFlag)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  [Mac]IsWindowVisible()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
#if TARGET_OS_MAC
    #define MacIsWindowVisible IsWindowVisible
#endif
extern Boolean 
MacIsWindowVisible(WindowRef window)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIWindowIsOnActiveSpace()
 *  
 *  Summary:
 *    Returns whether a window is attached to the currently active
 *    space.
 *  
 *  Discussion:
 *    For visible windows, this API indicates whether the window is
 *    currently visible on the active space; for invisible windows, it
 *    indicates whether the window would be visible on the active space
 *    if it were visible at this moment. The window's visible state
 *    still controls whether the window is actually visible or not.
 *    
 *    
 *    Windows that have availability attributes of either
 *    kHIWindowCanJoinAllSpaces or kHIWindowMoveToActiveSpace will
 *    always return true from this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to examine.
 *  
 *  Result:
 *    True if the window is attached to the current space or to all
 *    spaces, or false if the window is attached solely to some other
 *    space.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.6 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIWindowIsOnActiveSpace(WindowRef inWindow)                   AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;


/*
  ——————————————————————————————————————————————————————————————————————————————————————
    • Latent window visibility
  ——————————————————————————————————————————————————————————————————————————————————————
*/

#endif  /* !__LP64__ */


/*
 *  WindowLatentVisibility
 *  
 *  Summary:
 *    Reasons why a window is currently invisible when ordinarily it
 *    would be visible.
 */
typedef UInt32 WindowLatentVisibility;
enum {

  /*
   * Window is a floater and floating windows are hidden
   */
  kWindowLatentVisibleFloater   = 1 << 0,

  /*
   * Window has HideOnSuspend and we are suspended
   */
  kWindowLatentVisibleSuspend   = 1 << 1,

  /*
   * Window has HideOnFullScreen and we are full-screen
   */
  kWindowLatentVisibleFullScreen = 1 << 2,

  /*
   * Window's process is hidden
   */
  kWindowLatentVisibleAppHidden = 1 << 3,

  /*
   * Window is in an owned group and the owner was collapsed
   */
  kWindowLatentVisibleCollapsedOwner = 1 << 4,

  /*
   * Window is in a HideOnCollapse group and another window in the
   * group was collapsed
   */
  kWindowLatentVisibleCollapsedGroup = 1 << 5
};

#if !__LP64__
/*
 *  IsWindowLatentVisible()
 *  
 *  Summary:
 *    Indicates whether a window is visible onscreen and also whether
 *    it is latently visible but not currently onscreen.
 *  
 *  Discussion:
 *    All windows are either onscreen or offscreen. A window that is
 *    offscreen may still be latently visible; this occurs, for
 *    example, when a floating window is hidden as an application is
 *    suspended. The floating window is not visible onscreen, but it is
 *    latently visible and is only hidden due to the suspended state of
 *    the application; when the application becomes active again, the
 *    floating window will be placed back onscreen.
 *    IsWindowLatentVisible may be used to determine both the window's
 *    onscreen/offscreen status and its latent visibility (if the
 *    window is offscreen).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose visibility to return.
 *    
 *    outLatentVisible:
 *      If the window is onscreen, the latent visibility is zero. If
 *      the window is offscreen, this parameter is used to return the
 *      latent visibility flags of the window. If any of the flags are
 *      set, then the window is latently visible.
 *  
 *  Result:
 *    Indicates whether the window is currently onscreen.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsWindowLatentVisible(
  WindowRef                 inWindow,
  WindowLatentVisibility *  outLatentVisible)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;



/*
  ——————————————————————————————————————————————————————————————————————————————————————
    • Window Availability for Exposé
  ——————————————————————————————————————————————————————————————————————————————————————
*/

#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Window availability options for Exposé and Spaces.
 *  
 *  Discussion:
 *    These options are used with the HIWindowGet/ChangeAvailability
 *    APIs to override the default behavior of a window in Exposé and
 *    Spaces. Most applications should not override the default
 *    behavior; these options should only be used in special cases. By
 *    default, newly created windows of class kDocumentWindowClass are
 *    given an availability of zero (meaning that they are available
 *    during Exposé, and are only visible in the Space in which they
 *    were created), and windows from all other window classes are
 *    given an availability of kHIWindowExposeHidden.
 */
enum {

  /*
   * This window is hidden during Exposé’s “All windows” and
   * “Application windows” modes, and during the Spaces overview mode.
   * It moves to the current space automatically after a space switch,
   * and does not trigger a space switch when dragged to a space
   * boundary. If this bit is not set, the window is visible during
   * Exposé and Spaces.
   */
  kHIWindowBehaviorTransient    = 1 << 0,

  /*
   * This window is visible during Exposé’s “All windows” and
   * “Application windows” modes, and does not move. It remains in its
   * original position and, when clicked in "Show desktop" mode,
   * receives the mouse event.
   */
  kHIWindowBehaviorStationary   = 1 << 1,

  /*
   * This window is visible in all window sets managed by Spaces. If
   * this bit is not set, the window is only visible in the Space where
   * it was created. This bit and the kHIWindowMoveToActiveSpace bit
   * should not both be set.
   */
  kHIWindowCanJoinAllSpaces     = 1 << 8,

  /*
   * When made visible, this window is always shown in the current
   * Space, rather than the space in which it was last visible. When
   * activated, this window moves to the active space, rather than
   * forcing a switch to the Space on which it was previously located.
   * This option is typically used with modeless dialog windows such as
   * the Quick Search window in BBEdit. This bit and the
   * kHIWindowCanJoinAllSpaces bit should not both be set.
   */
  kHIWindowMoveToActiveSpace    = 1 << 9,

  /*
   * The original name for the constant kHIWindowBehaviorTransient.
   * Please do not use this name.
   */
  kHIWindowExposeHidden         = kHIWindowBehaviorTransient,

  /*
   * The original name for the constant kHIWindowCanJoinAllSpaces.
   * Please do not use this name.
   */
  kHIWindowVisibleInAllSpaces   = kHIWindowCanJoinAllSpaces
};


typedef OptionBits                      HIWindowAvailability;
#if !__LP64__
/*
 *  HIWindowGetAvailability()
 *  
 *  Summary:
 *    Returns the availability of a window during Exposé.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose availability to return.
 *    
 *    outAvailability:
 *      On exit, contains the window availability.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetAvailability(
  WindowRef               inWindow,
  HIWindowAvailability *  outAvailability)                    AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*
 *  HIWindowChangeAvailability()
 *  
 *  Summary:
 *    Alters the availability of a window during Exposé.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose availability to change.
 *    
 *    inSetAvailability:
 *      The availability bits to set.
 *    
 *    inClearAvailability:
 *      The availability bits to clear.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowChangeAvailability(
  WindowRef              inWindow,
  HIWindowAvailability   inSetAvailability,
  HIWindowAvailability   inClearAvailability)                 AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
    • Sheets
    
    Sheets are a new user interface object in Mac OS X. A sheet is a modal alert or dialog,
    but unlike a traditional alert or dialog window (which is visually separate from the
    frontmost document window), a sheet appears to be attached to its parent window; it
    moves and z-orders simultaneously with its parent. Furthermore, sheets on Mac OS X
    use a new type of modality called window modality. A traditional alert or dialog is
    app-modal; it prevents user interaction with all other windows in the current application.
    A sheet is window-modal; it only prevents user interaction with its parent window, and
    events continue to flow to other windows in the application.
    
    • Sheet Event Handling
    
    Implementing a sheet window in your application generally requires some modifications
    to your event-handling code. A traditional app-modal window is implemented using a modal
    event loop; your application starts a new event loop (either by processing events itself,
    or by calling ModalDialog), which does not return back to your application's main event
    loop until the app-modal window has closed.
    
    Starting a new event loop doesn't work with sheets, because typically the modal event loop
    will only handle events destined for the sheet, and not events for other windows, but
    a sheet only blocks events for its parent window, and your application must still handle
    events for the rest of its windows as normal. Therefore, you will usually not use a modal
    event loop to handle events in a sheet. Rather, you will show the sheet window, and then
    return directly back to your main event loop. The Carbon Event Manager automatically 
    prevents events from reaching the sheet's parent window; events in your application's
    other windows are still returned to you via WaitNextEvent or your application's Carbon
    event handlers, where you can process them as normal.
    
    You have several choices for handling events in the sheet itself. A sheet is, at the most
    basic level, simply another window in your application, and you can use any of the standard
    event-handling APIs to receive events in the sheet. For example, you can:
    
        -   receive events in the sheet via WaitNextEvent, and handle them directly in your
            main event loop
            
        -   create the sheet using Dialog Manager APIs, and use IsDialogEvent and DialogSelect
            to handle events in the sheet
            
        -   install Carbon event handlers on the sheet, and respond to events in your handlers
    
    Which approach you choose is up to you.
    
    • Sheets in CarbonLib
    
    The sheet window class, sheet WDEF procIDs, and ShowSheetWindow, HideSheetWindow, and
    GetSheetWindowParent APIs are implemented in CarbonLib starting with version 1.3. However,
    since Mac OS 8 and 9 do not traditionally support a window-modal user interface, sheet
    windows are displayed as app-modal windows by CarbonLib. From your application's perspective,
    event handling for a sheet in CarbonLib is the same as event handling for a sheet on X;
    ShowSheetWindow still returns immediately, and your application should still return back
    to its main event loop and be prepared to handle events in other windows. On CarbonLib,
    your application will simply never receive any user input in any of your other windows;
    since the sheet has application modality, the Carbon Event Manager will discard events
    in any windows other than the sheet.
    
    • Creating a Sheet
    
    A sheet is just a normal window with a special window class: kSheetWindowClass or
    kSheetAlertWindowClass. As such, it can be created in any of the ways you might create
    a window: NewWindow, NewCWindow, CreateNewWindow, GetNewWindow, GetNewCWindow, 
    CreateWindowFromCollection, CreateWindowFromResource, CreateWindowFromNib, NewDialog,
    NewColorDialog, NewFeaturesDialog, or GetNewDialog.
    
    The Window Manager defines two window classes and two WDEF procIDs for sheets:
        
        -   kSheetWindowClass and kSheetAlertWindowClass
        -   kWindowSheetProc and kWindowSheetAlertProc
        
    The window classes may be used with CreateNewWindow, CreateWindowFromCollection, and
    CreateWindowFromResource; the WDEF procIDs may be used with NewWindow, NewCWindow, NewDialog,
    NewColorDialog, NewFeaturesDialog, and in 'WDEF' and 'DLOG' resources.
    
    Mac OS X 10.0 only supports kSheetWindowClass and kWindowSheetProc;
    it does not support kSheetAlertWindowClass or kWindowSheetAlertProc. The latter window
    class and procID were added in CarbonLib 1.3 and Mac OS X 10.1. A new window class and
    procID were necessary for CarbonLib support because
    sheets can be used for both alerts ("Do you want to save changes before closing this
    window?") and dialogs (a Navigation Services PutFile dialog). On Mac OS X, sheet windows
    have the same appearance when used for either an alert or a dialog, but on Mac OS 8 and 9,
    alert windows have a different appearance from dialog windows. Two separate window classes
    are necessary for CarbonLib to know whether to display a sheet using a movable alert or a
    movable dialog window. Therefore, it is recommended that you use kSheetAlertWindowClass when
    creating a sheet window that will be used to display an alert, although this is not required.
    
    • Displaying a Sheet
    
    A sheet is made visible by calling the ShowSheetWindow API. This API shows the sheet,
    using whatever visual effects are appropriate for the platform, and then returns immediately.
    On Mac OS X, it creates a window group and places the sheet and its parent window into the
    group; it also marks the sheet as window-modal. On CarbonLib, it marks the sheet as app-modal
    but does not create a window group.
    
    On Mac OS X, before the sheet window is actually made visible, ShowSheetWindow sends a 
    kEventWindowDrawContent event to the sheet window, asking it to draw its content into the
    window's offscreen buffer. The sheet must handle this event, or its content area will be
    blank after the sheet becomes visible.
    
    In some cases, this handler is automatically provided for you:
    
        -   If you create your sheet window using the Dialog Manager, the Dialog Manager
            automatically installs a handler for this event that calls DrawDialog, so you
            don't need to install the handler yourself.
            
        -   If you install the standard Carbon window event handler on your sheet window
            (using kWindowStandardHandlerAttribute or InstallStandardEventHandler), the
            standard handler automatically handles this event and calls DrawControls.
            
    Typically, your event handling code (whether it uses WaitNextEvent, the Dialog Manager,
    or Carbon event handlers) will receive and respond to events in the sheet until the
    user does something that should cause the sheet to close. This might be clicking in an
    OK or Cancel button, for example. At that time, your event handling code must call either
    HideSheetWindow or DetachSheetWindow. The sheet window will hide, but will not be destroyed,
    so you can use it again later if you want.
    
    • Closing a sheet
    
    A sheet is normally hidden by calling the HideSheetWindow API. HideSheetWindow provides the
    visual effects of zooming the sheet back into the parent window's title bar and moving the
    parent window back to its original position. In Mac OS X 10.3 and later, the DetachSheetWindow
    API is also available. DetachSheetWindow ungroups the sheet from its parent, releases the
    retain count acquired by ShowSheetWindow on the parent window, and removes all event handlers
    installed by ShowSheetWindow, but does not hide the sheet window; an application would typically
    call DetachSheetWindow and then HideWindow to hide the sheet window without the sheet closing
    animation. This may be useful if, for example, the sheet were being used to ask if changes to
    a modified document should be saved; if the user chooses "Don’t Save", then the application
    could use DetachSheetWindow and then hide both the sheet and the document immediately, so that
    the document closes as quickly as possible without taking time for the closing animation.
    The Navigation Services Save Changes dialog does this automatically.
    
    You _must_ call either HideSheetWindow or DetachSheetWindow before destroying a sheet that has
    been shown with ShowSheetWindow. You may not simply dispose of a sheet window without first using
    Hide or DetachSheetWindow; doing so will leave an extra refcount on the parent window, and will
    leave the parent window still embedded in the sheet window group.
    
    • Sheet Transparency
    
    Sheets should be transparent so that the user can see some of the document content behind
    the sheet and remember the context in which the sheet was displayed. In Mac OS X 10.1, 
    a sheet is made transparent by using the kThemeBrushSheetBackgroundTransparent constant for
    the sheet window’s theme background brush. In Mac OS X 10.2 and later, sheets are only
    transparent if this brush is used and if the sheet window uses compositing mode (enabled by
    setting the kWindowCompositingAttribute window attribute when the sheet window is created).
*/
/*
 *  ShowSheetWindow()
 *  
 *  Summary:
 *    Shows a sheet window using appropriate visual effects.
 *  
 *  Discussion:
 *    ShowSheetWindow is implemented in both CarbonLib 1.3 and Mac OS
 *    X. Since Mac OS 9 does not use a window-modal user interface for
 *    alerts and dialogs, ShowSheetWindow in CarbonLib does not bind
 *    the sheet to the parent window in the same way that it does on
 *    Mac OS X; instead, it shows the sheet like a standard
 *    movable-modal dialog window. Sheet windows must use the window
 *    classes kSheetWindowClass or kSheetAlertWindowClass to get the
 *    right appearance on both platforms. 
 *    
 *    Note that ShowSheetWindow will increment the retain count of the
 *    parent window. The retain count is decremented by HideSheetWindow
 *    and DetachSheetWindow. You must call one of those APIs before
 *    destroying the sheet window. 
 *    
 *    On Mac OS X, ShowSheetWindow sets the modality of the sheet
 *    window to kWindowModalityWindowModal.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inSheet:
 *      The sheet window to show.
 *    
 *    inParentWindow:
 *      The sheet's parent window.
 *  
 *  Result:
 *    An operating system result code. ShowSheetWindow checks for the
 *    following error conditions, and returns paramErr if any occur:
 *    the sheet window must have a window class of kSheetWindowClass or
 *    kSheetAlertWindowClass; the sheet and parent windows must not be
 *    the same window; the sheet must not have a parent window already;
 *    and the parent window must not already be the target of a sheet.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ShowSheetWindow(
  WindowRef   inSheet,
  WindowRef   inParentWindow)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HideSheetWindow()
 *  
 *  Summary:
 *    Hides a sheet window using appropriate visual effects.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inSheet:
 *      The sheet window to hide.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HideSheetWindow(WindowRef inSheet)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DetachSheetWindow()
 *  
 *  Summary:
 *    Detaches a sheet window from its parent window without affecting
 *    the visibility or position of the sheet or its parent.
 *  
 *  Discussion:
 *    This API may be useful if you want to hide a sheet window without
 *    an animation effect. To do that, use DetachSheetWindow to detach
 *    the sheet from the parent, and then use HideWindow to hide the
 *    sheet, or DisposeWindow to destroy the sheet.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inSheet:
 *      The sheet to detach.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
DetachSheetWindow(WindowRef inSheet)                          AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;


/*
 *  GetSheetWindowParent()
 *  
 *  Summary:
 *    Returns the parent window of a sheet.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inSheet:
 *      The sheet window whose parent to retrieve.
 *    
 *    outParentWindow:
 *      On exit, contains the parent window of the sheet.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetSheetWindowParent(
  WindowRef    inSheet,
  WindowRef *  outParentWindow)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
    • Drawers
    
    Drawers are supported in Carbon by Mac OS X 10.2 and later. To create and use a drawer:
    
        -   Create a window using kDrawerWindowClass. You must also use compositing mode with
            drawers; this mode is enabled by passing kWindowCompositingAttribute to CreateNewWindow.
            
        -   Either install the standard window event handler on the drawer window, or use
            your own Carbon event or WaitNextEvent code to handle user interaction with the
            drawer. If you do not use the standard window event handler, you should call
            ResizeWindow in response to clicks on the grow region of the drawer if you want
            the drawer to be resizable.
            
        -   Set the drawer's parent window with the SetDrawerParent function. The parent is
            the window on which the drawer will open.
            
        -   Optionally, install a Carbon event handler on the drawer or the drawer's parent
            window for the kEventWindowDrawerOpening/Opened/Closing/Closed events, to be notified
            when the drawer has started or finished opening or closing.
        
        -   Optionally, set the drawer's preferred edge on the parent window with the
            SetDrawerPreferredEdge function. If you do not set a preferred edge, the drawer
            opens on the parent's left side on a left-to-right system, or on the parent's right
            side on a right-to-left system.
            
        -   Optionally, set the drawer's offsets with the SetDrawerOffsets function. The offsets
            control the amount of inset between the edge of the parent's content area and the edge
            of the drawer's structure. If you do not set any offsets, the drawer's edges are flush
            with the edges of the parent's content.
            
        -   Optionally, set the drawer's minimum and maximum sizes with the SetWindowResizeLimits
            function. Or, install a Carbon event handler on the drawer to handle the kEventWindow-
            GetMinimumSize and kEventWindowGetMaximumSize events. The drawer's minimum and maximum
            sizes control how small or large it will resize together with the parent. If you do not
            set resize limits, the drawer will be capable of resizing to default small and large
            limits.
        
        -   Call ToggleDrawer to open or close the drawer, or use OpenDrawer or CloseDrawer if
            you require more control over how the drawer opens or closes.
*/
#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Indicates the parent window edge on which a drawer will be shown.
 */
enum {

  /*
   * This constant is typically used with the OpenDrawer API; it
   * indicates that the drawer should be opened on whatever edge of the
   * parent window has previously been set as the drawer's preferred
   * edge.
   */
  kWindowEdgeDefault            = 0,

  /*
   * The drawer should open on the top edge of the parent window.
   */
  kWindowEdgeTop                = 1 << 0,

  /*
   * The drawer should open on the left edge of the parent window.
   */
  kWindowEdgeLeft               = 1 << 1,

  /*
   * The drawer should open on the bottom edge of the parent window.
   */
  kWindowEdgeBottom             = 1 << 2,

  /*
   * The drawer should open on the right edge of the parent window.
   */
  kWindowEdgeRight              = 1 << 3
};


/*
 *  Summary:
 *    Indicates the current state of a drawer window.
 */
enum {

  /*
   * The drawer is opening, but is not yet fully open.
   */
  kWindowDrawerOpening          = 1,

  /*
   * The drawer is fully open.
   */
  kWindowDrawerOpen             = 2,

  /*
   * The drawer is closing, but is not yet fully closed.
   */
  kWindowDrawerClosing          = 3,

  /*
   * The drawer is fully closed.
   */
  kWindowDrawerClosed           = 4
};

typedef UInt32                          WindowDrawerState;

#if !__LP64__
/*
 *  GetDrawerPreferredEdge()
 *  
 *  Summary:
 *    Returns the preferred parent window edge of a drawer.
 *  
 *  Discussion:
 *    Drawers start out with a preferred parent window edge of
 *    kWindowEdgeDefault. On left-to-right systems, the default edge is
 *    the left edge of the parent window; on right-to-left systems, the
 *    default edge is the right edge. You can set the preferred edge
 *    with SetDrawerPreferredEdge. If there's not enough room on the
 *    preferred edge, the drawer will automatically switch to the
 *    opposite edge.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose preferred edge to retrieve.
 *  
 *  Result:
 *    The preferred edge of the drawer window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OptionBits 
GetDrawerPreferredEdge(WindowRef inDrawerWindow)              AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  SetDrawerPreferredEdge()
 *  
 *  Summary:
 *    Sets the preferred parent window edge of a drawer.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose preferred edge to set.
 *    
 *    inEdge:
 *      The preferred edge of the drawer window. Note that although the
 *      WindowEdge enumeration has values appropriate for a bitfield,
 *      the current implementation does not support receiving more than
 *      one edge bit in this parameter. You can also pass
 *      kWindowEdgeDefault to allow the Window Manager to pick an edge.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetDrawerPreferredEdge(
  WindowRef    inDrawerWindow,
  OptionBits   inEdge)                                        AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  GetDrawerCurrentEdge()
 *  
 *  Summary:
 *    Returns the current parent window edge on which a drawer is
 *    displayed.
 *  
 *  Discussion:
 *    If the drawer window is currently visible, this API returns the
 *    parent window edge on which the drawer is displayed. If the
 *    drawer is not visible, this API determines on which edge of the
 *    parent window the drawer should be displayed, given the current
 *    size of the drawer, position of the parent, and preferred edge
 *    for the drawer.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose current edge to retrieve.
 *  
 *  Result:
 *    The current edge of the drawer window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OptionBits 
GetDrawerCurrentEdge(WindowRef inDrawerWindow)                AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  GetDrawerState()
 *  
 *  Summary:
 *    Returns the current state of a drawer: opening, open, closing, or
 *    closed.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose state to retrieve.
 *  
 *  Result:
 *    The current state of the drawer window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowDrawerState 
GetDrawerState(WindowRef inDrawerWindow)                      AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  GetDrawerParent()
 *  
 *  Summary:
 *    Returns the parent window of a drawer.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose parent window to retrieve.
 *  
 *  Result:
 *    The drawer's parent window, or NULL if the drawer has no assigned
 *    parent.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
GetDrawerParent(WindowRef inDrawerWindow)                     AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  SetDrawerParent()
 *  
 *  Summary:
 *    Sets the parent window of a drawer.
 *  
 *  Discussion:
 *    In Mac OS X 10.4 and 10.5, this API incorrectly increments the
 *    refcount of the drawer window, and you must either destroy the
 *    drawer parent window or use SetDrawerParent( drawer, NULL ) on
 *    the drawer window before destroying the drawer. This extra step
 *    is not required in Mac OS X 10.2, 10.3, or 10.6 and later; in
 *    those versions you may simply release the drawer window when
 *    you're done with it and it will be automatically removed from the
 *    parent.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose parent window to set.
 *    
 *    inParent:
 *      The drawer's new parent window, or NULL if the drawer should
 *      have no parent.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetDrawerParent(
  WindowRef   inDrawerWindow,
  WindowRef   inParent)                                       AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  kWindowOffsetUnchanged
 *  
 *  Discussion:
 *    Pass this value to SetDrawerOffsets to indicate that an existing
 *    offset should not be changed.
 */
#define kWindowOffsetUnchanged          ((float)(-1.0))
#if !__LP64__
/*
 *  SetDrawerOffsets()
 *  
 *  Summary:
 *    Sets the offsets from the beginning and end of the parent window
 *    to the beginning and end of the drawer window.
 *  
 *  Discussion:
 *    The drawer offsets control the positioning of the drawer relative
 *    to its parent window. When a drawer is first created, its offsets
 *    are zero. When a drawer is positioned, it is initially given a
 *    height or width equal to the height or width of the content area
 *    of the parent to which it is attached. If a drawer is opening on
 *    the left side of its parent, for example, the drawer's height
 *    will be the height of the parent's content area. In this case,
 *    the top side of the drawer window is called the leading edge of
 *    the drawer, and the bottom side of the drawer window is called
 *    the trailing edge of the drawer. The drawer's size is then
 *    adjusted by the leading and trailing offsets. The leading edge of
 *    the drawer is moved inward by an amount equal to the leading
 *    offset, and the trailing edge is moved inward by an amount equal
 *    to the trailing offset. For example, if the leading and trailing
 *    offsets are five and fifteen, then the top edge of a left-opening
 *    drawer will be five pixels inside the top edge of the parent
 *    window's content area, and the bottom edge of the drawer will be
 *    fifteen pixels inside the bottom edge of the parent's content
 *    area.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose offsets to change.
 *    
 *    inLeadingOffset:
 *      The new leading offset, in pixels. Pass kWindowOffsetUnchanged
 *      if you don't want to change the leading offset.
 *    
 *    inTrailingOffset:
 *      The new trailing offset, in pixels. Pass kWindowOffsetUnchanged
 *      if you don't want to change the trailing offset.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetDrawerOffsets(
  WindowRef   inDrawerWindow,
  CGFloat     inLeadingOffset,
  CGFloat     inTrailingOffset)                               AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  GetDrawerOffsets()
 *  
 *  Summary:
 *    Returns the offsets from the beginning and end of the parent
 *    window to the beginning and end of the drawer window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window whose offsets to retrieve.
 *    
 *    outLeadingOffset:
 *      On exit, contains the drawer's leading offset. Pass NULL if you
 *      don't need this information returned.
 *    
 *    outTrailingOffset:
 *      On exit, contains the drawer's trailing offset. Pass NULL if
 *      you don't need this information returned.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetDrawerOffsets(
  WindowRef   inDrawerWindow,
  CGFloat *   outLeadingOffset,        /* can be NULL */
  CGFloat *   outTrailingOffset)       /* can be NULL */      AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  ToggleDrawer()
 *  
 *  Summary:
 *    Toggles a drawer from open to closed, or vice versa.
 *  
 *  Discussion:
 *    ToggleDrawer opens the drawer if it is closed, opening, or
 *    closing. If the drawer is open, it closes the drawer.
 *    
 *    ToggleDrawer attempts to open the drawer on its preferred edge,
 *    but if there is not enough room on that edge, it will try the
 *    opposite edge instead. If there is insufficient room on either
 *    edge, the drawer will open on the preferred edge but may extend
 *    offscreen, under the Dock, or under the menubar.
 *    
 *    The opening or closing of the drawer is performed asynchronously;
 *    ToggleDrawer installs an event loop timer that opens or closes
 *    the drawer after ToggleDrawer returns to the caller. Therefore,
 *    the caller must be running its event loop for the drawer to open
 *    or close. To open or close the drawer synchronously, use the
 *    OpenDrawer or CloseDrawer APIs.
 *    
 *    ToggleDrawer retains the drawer window while the drawer is
 *    opening or closing, and releases it when the drawer is fully
 *    opened or closed.
 *    
 *    ToggleDrawer sends the kEventWindowDrawerOpening,
 *    kEventWindowDrawerOpened, kEventWindowDrawerClosing, and
 *    kEventWindowDrawerClosed events as the drawer opens or closes.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window to open or close.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ToggleDrawer(WindowRef inDrawerWindow)                        AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  OpenDrawer()
 *  
 *  Summary:
 *    Opens a drawer on a specified parent window edge.
 *  
 *  Discussion:
 *    OpenDrawer may open the drawer either synchronously or
 *    asynchronously, depending on the value of the inAsync parameter.
 *    If inAsync is true, OpenDrawer installs an event loop timer that
 *    opens the drawer after OpenDrawer returns to the caller;
 *    therefore, the caller must be running its event loop for the
 *    drawer to open. If inAsync is false, OpenDrawer opens the drawer
 *    completely before returning to the caller.
 *    
 *    OpenDrawer retains the drawer window while the drawer is opening,
 *    and releases it when the drawer is fully open.
 *    
 *    OpenDrawer sends the kEventWindowDrawerOpening event to the
 *    drawer, the drawer's parent, and the application before opening
 *    the drawer. If an event handler for this event returns
 *    userCanceledErr, OpenDrawer will return immediately without
 *    opening the drawer. OpenDrawer sends the kEventWindowDrawerOpened
 *    event to the drawer, the drawer's parent, and the application
 *    after the drawer has finished opening.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window to open.
 *    
 *    inEdge:
 *      The parent window edge on which to open the drawer. Pass
 *      kWindowEdgeDefault to use the drawer's preferred edge. If there
 *      is not enough room on the preferred edge, OpenDrawer will try
 *      the opposite edge instead. If there is insufficient room on
 *      either edge, the drawer will open on the preferred edge but may
 *      extend offscreen, under the Dock, or under the menubar.
 *    
 *    inAsync:
 *      Whether to open the drawer synchronously (the drawer is
 *      entirely opened before the function call returns) or
 *      asynchronously (the drawer opens using an event loop timer
 *      after the function call returns).
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
OpenDrawer(
  WindowRef    inDrawerWindow,
  OptionBits   inEdge,
  Boolean      inAsync)                                       AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  CloseDrawer()
 *  
 *  Summary:
 *    Closes a drawer.
 *  
 *  Discussion:
 *    CloseDrawer may close the drawer either synchronously or
 *    asynchronously, depending on the value of the inAsync parameter.
 *    If inAsync is true, CloseDrawer installs an event loop timer that
 *    closes the drawer after CloseDrawer returns to the caller;
 *    therefore, the caller must be running its event loop for the
 *    drawer to close. If inAsync is false, CloseDrawer closes the
 *    drawer completely before returning to the caller.
 *    
 *    CloseDrawer retains the drawer window while the drawer is
 *    closing, and releases it when the drawer is fully closed.
 *    
 *    CloseDrawer sends the kEventWindowDrawerClosing event to the
 *    drawer, the drawer's parent, and the application before closing
 *    the drawer. If an event handler for this event returns
 *    userCanceledErr, CloseDrawer will return immediately without
 *    closing the drawer. CloseDrawer sends the
 *    kEventWindowDrawerClosed event to the drawer, the drawer's
 *    parent, and the application after the drawer has finished closing.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDrawerWindow:
 *      The drawer window to close.
 *    
 *    inAsync:
 *      Whether to close the drawer synchronously (the drawer is
 *      entirely closed before the function call returns) or
 *      asynchronously (the drawer closes using an event loop timer
 *      after the function call returns).
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CloseDrawer(
  WindowRef   inDrawerWindow,
  Boolean     inAsync)                                        AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  HIWindowCopyDrawers()
 *  
 *  Summary:
 *    Returns an array of the drawers that are attached to a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose drawers to return.
 *    
 *    outDrawers:
 *      On exit, an array containing WindowRefs. Each array entry is a
 *      drawer attached to the specified window. The array will be
 *      valid, but empty, if the window has no drawers.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowCopyDrawers(
  WindowRef     inWindow,
  CFArrayRef *  outDrawers)                                   AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Disabling Screen Redraw                                                            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  DisableScreenUpdates()
 *  
 *  Summary:
 *    Temporarily disables redraw of the screen after changes to window
 *    geometry or window contents.
 *  
 *  Discussion:
 *    It is appropriate to disable updates if you are moving or
 *    resizing multiple windows and you want all of the geometry
 *    changes to appear onscreen simulataneously. In most other cases,
 *    you should strive to avoid disabling screen updates. The window
 *    server will automatically re-enable updates (and print a message
 *    to the Console log) if you leave updates disabled for a
 *    sufficiently long period of time, currently about 1 second.
 *    
 *    
 *    The window server records the number of calls to
 *    DisableScreenUpdates and does not re-enable updates until a
 *    matching number of calls to EnableScreenUpdates have been made.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    An operating system result code. In practice, this API always
 *    returns noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
DisableScreenUpdates(void)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  EnableScreenUpdates()
 *  
 *  Summary:
 *    Re-enables redraw of the screen after changes to window geometry
 *    or window contents.
 *  
 *  Discussion:
 *    Screen redraw is not actually enabled until the number of calls
 *    to EnableScreenUpdates matches the number of calls to
 *    DisableScreenUpdates.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    An operating system result code. In practice, this API always
 *    returns noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
EnableScreenUpdates(void)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Toolbars                                                                    */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  SetWindowToolbar()
 *  
 *  Discussion:
 *    Sets the toolbar for a window. If any other toolbar is currently
 *    bound to the window, it is released. This API does NOT add the
 *    toolbar button to the window, your application must set the
 *    attribute itself.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to add the toolbar to.
 *    
 *    inToolbar:
 *      The toolbar to add.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowToolbar(
  WindowRef      inWindow,
  HIToolbarRef   inToolbar)                                   AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  GetWindowToolbar()
 *  
 *  Discussion:
 *    Gets the toolbar of a window, if any.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to add the toolbar to.
 *    
 *    outToolbar:
 *      The toolbar. You do not own the toolbar reference returned by
 *      this function. Do not release it! It is possible for the
 *      toolbar returned to be NULL, indicating there is no toolbar
 *      associated with this window. ••• NOTE: May need to change the
 *      release strategy here.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowToolbar(
  WindowRef       inWindow,
  HIToolbarRef *  outToolbar)                                 AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  ShowHideWindowToolbar()
 *  
 *  Discussion:
 *    Shows or hides a window's toolbar. Optionally, you can ask for
 *    the transition to be animated or not. Typically, you would not
 *    need to call this other than to set up your window accordingly.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to show or hide the toolbar for.
 *    
 *    inShow:
 *      Pass true to show the toolbar, false to hide it.
 *    
 *    inAnimate:
 *      Pass true to animate the transition, false to do it quickly and
 *      without fanfare.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ShowHideWindowToolbar(
  WindowRef   inWindow,
  Boolean     inShow,
  Boolean     inAnimate)                                      AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  IsWindowToolbarVisible()
 *  
 *  Discussion:
 *    Returns whether the toolbar (if any) attached to a window is
 *    visible. If the window has no toolbar, false is returned.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window test the toolbar visiblity for.
 *  
 *  Result:
 *    A boolean result indicating whether the toolbar is visible (true)
 *    or not (false).
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsWindowToolbarVisible(WindowRef inWindow)                    AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
    About Custom Toolbar Views
    
    A window with a custom toolbar view does not have an HIToolbarRef. No API that takes an HIToolbarRef will work.
    
    When a custom toolbar view is provided for a window, the Window Manager will:
        - set the view's HIViewID to kHIViewWindowToolbarID
        - embed the toolbar view in the root view of the window
        - make the toolbar view invisible
        
    These aspects of the standard toolbar support also work with custom toolbar views:
        - unmodified clicks on the toolbar button to show and hide the toolbar
        - ShowHideWindowToolbar and IsWindowToolbarVisible
        - kHICommandShow/HideToolbar and kHICommandToggleToolbar
        
    These aspects of the standard toolbar support do _not_ work with custom toolbar views:
        - option-click on toolbar button to toggle all windows with the same toolbar
        - command-click and command-shift-click on toolbar button to change display mode and size
        - command-option click on toolbar button to display config sheet
        
    A custom toolbar view must handle these events:
        - kEventControlGetOptimalBounds
        - kEventControlSetData with kHIToolbarViewDrawBackgroundTag
        - kEventControlDraw and draw, or not, as requested by the background tag
        
    A custom toolbar view may optionally handle:
        - kEventWindowAttributesChanged to be notified when window style changes
        - kHICommandCustomizeToolbar to present its own toolbar customization dialog
        - kHICommandToggleAllToolbars to implement multi-window toggling
        - kHICommandCycleToolbarModeSmaller/Larger to change display mode and size
        
    A custom toolbar view may need to make itself taller or shorter while the view is visible. To ensure
    correct window redraw when this happens, the window frame view must be involved or notified of the
    change in toolbar size. The correct way to do this depends on the Mac OS X version:
    
        - for Mac OS X 10.4.x, the toolbar view should use this code:
        
            WindowRef window = HIViewGetWindow( view );
            DisableScreenUpdates();
            ShowHideWindowToolbar( window, false, false );
            HIViewSetFrame( view, &newBounds );
            ShowHideWindowToolbar( window, true, false );
            EnableScreenUpdates();
        
        - for Mac OS X 10.5 and later, the toolbar view may either use the above code or may instead
          send a kEventControlOptimalBoundsChanged event to itself. The window frame view will observe
          this event and resize the toolbar view automatically. Note that in this case, the view should
          not resize itself; instead, it should be prepared to receive a kEventControlGetOptimalBounds
          event and return its new optimal size in response.
*/
#endif  /* !__LP64__ */


/*
 */
enum {

  /*
   * A SetControlData tag that is used by the standard window frame
   * view to inform the toolbar view whether the view should draw its
   * background or leave its background transparent. The data for this
   * tag is a Boolean. If the data value is true, the toolbar view
   * should draw its background as it desires. If the data value is
   * false, the toolbar view should leave its background transparent so
   * that the window's root view can show through the toolbar view.
   * Currently, the toolbar view will be asked to leave its background
   * transparent for windows with the textured or unified appearance.
   */
  kHIToolbarViewDrawBackgroundTag = 'back'
};

#if !__LP64__
/*
 *  HIWindowSetToolbarView()
 *  
 *  Summary:
 *    Sets a custom toolbar view for a window.
 *  
 *  Discussion:
 *    This API is provided for use by applications that cannot use the
 *    HIToolbarRef API. For best compatibility with future versions of
 *    Mac OS X, we highly recommend that you use the HIToolbar API if
 *    possible. However, if HIToolbar is not sufficient for your needs,
 *    you can provide a custom toolbar view that will be placed at the
 *    standard location inside the window frame. You are responsible
 *    for defining the appearance and behavior of the view. You cannot
 *    use this API to customize the view that is associated with an
 *    HIToolbarRef; a window with an HIToolbarRef uses a standard
 *    HIToolbox-provided view that cannot be customized. When using a
 *    custom toolbar view, no API that takes an HIToolbarRef will work
 *    with that window. 
 *    
 *    The HIWIndowSetToolbarView API is available in Mac OS X 10.4.9
 *    and later.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose toolbar view to set.
 *    
 *    inView:
 *      The custom toolbar view for the window. You may pass NULL to
 *      remove the custom view from the window. Setting a custom view
 *      will also remove any HIToolbarRef that is associated with the
 *      window. 
 *      
 *      After a custom toolbar view has been set, the window owns the
 *      view and will release it automatically when the window is
 *      destroyed, or when a different custom view or standard
 *      HIToolbar is set for the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetToolbarView(
  WindowRef   inWindow,
  HIViewRef   inView)         /* can be NULL */               AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Transparency                                                                */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  SetWindowAlpha()
 *  
 *  Discussion:
 *    Alters the overall alpha of a window, making the entire window
 *    (including window frame) either more or less transparent. The
 *    alpha is expressed as a floating point value from 0.0 (completely
 *    transparent) to 1.0 (completely opaque).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose alpha to modify.
 *    
 *    inAlpha:
 *      The new alpha value.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowAlpha(
  WindowRef   inWindow,
  CGFloat     inAlpha)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  GetWindowAlpha()
 *  
 *  Discussion:
 *    Returns the current overall alpha value for a window. The alpha
 *    is expressed as a floating point value from 0.0 (completely
 *    transparent) to 1.0 (completely opaque).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose alpha to return.
 *    
 *    outAlpha:
 *      On exit, contains the window's current alpha value.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowAlpha(
  WindowRef   inWindow,
  CGFloat *   outAlpha)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Shadows                                                                     */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIWindowInvalidateShadow()
 *  
 *  Summary:
 *    This API causes a window's shadow to be recalculated.
 *  
 *  Discussion:
 *    HIWindowInvalidateShadow is not typically used by applications.
 *    However, it may be useful for applications with customized window
 *    frames that change shape dynamically; in this case, after the
 *    application has drawn the new window shape, the window shadow
 *    must be recalculated to follow the new window shape. 
 *    
 *    This API causes the window shadow to be immediately recalculated
 *    and redrawn based on the current contents of the window's back
 *    buffer. For best performance and visual appearance, you should
 *    follow these steps when invalidating a window shadow: disable
 *    updates with DisableScreenUpdates, draw, flush, invalidate the
 *    shadow, and enable updates. For a compositing window, after
 *    invalidating any views that should be redrawn, you will need to
 *    explicitly draw and flush using HIWindowFlush, rather than
 *    waiting for the event loop to draw and flush the window, because
 *    you cannot disable updates or invalidate the window shadow if
 *    drawing is done via the event loop.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowInvalidateShadow(WindowRef inWindow)                  AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Scaling for Resolution Independence                                         */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIWindowGetBackingScaleFactor()
 *  
 *  Summary:
 *    Returns the scale factor representing the number of backing store
 *    pixels corresponding to each linear unit in window space on this
 *    WindowRef.
 *  
 *  Discussion:
 *    This is generally only necessary when building a bitmap context
 *    or image whose resolution needs to match that of a particular
 *    WindowRef. Note that a WindowRef's backing scale factor can
 *    change over time, such as when the window moves from one display
 *    to another, or when a display's resolution changes, so clients
 *    should not cache the value returned by this function.
 *    HIWindowGetBackingScaleFactor is only available on Mac OS X
 *    Version 10.7.3 and later.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The WindowRef whose backing scale factor to provide.
 *  
 *  Result:
 *    The backing scale factor of the window.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.7 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.7 and later
 *    Non-Carbon CFM:   not available
 */
extern CGFloat 
HIWindowGetBackingScaleFactor(WindowRef inWindow)             AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  HIWindowScaleMode
 *  
 *  Discussion:
 *    A window's scale mode indicates in which resolution-independent
 *    scale mode it is operating.
 */
typedef UInt32 HIWindowScaleMode;
enum {

  /*
   * The window is not scaled at all because the display scale factor
   * is 1.0.
   */
  kHIWindowScaleModeUnscaled    = 0,

  /*
   * The window's backing store is being magnified by the window server
   * because the display scale factor != 1.0, and because the window
   * was created without kWindowFrameworkScaledAttribute.
   */
  kHIWindowScaleModeMagnified   = 1,

  /*
   * The window's context has been scaled to match the display scale
   * factor because the display scale factor != 1.0 and because the
   * window was created with kWindowFrameworkScaledAttribute.
   */
  kHIWindowScaleModeFrameworkScaled = 2
};

#if !__LP64__
/*
 *  HIWindowGetScaleMode()   *** DEPRECATED ***
 *  
 *  Discussion:
 *    This function is deprecated and should not be used by
 *    applications targeting Mac OS X 10.7 or later. Please use an
 *    appropriate AppKit API instead. Clients desiring high resolution
 *    windows should switch to use NSWindows instead of Carbon
 *    WindowRefs.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The WindowRef whose scale mode to provide.
 *    
 *    outMode:
 *      On exit, this is always kHIWindowScaleModeUnscaled.
 *    
 *    outScaleFactor:
 *      On exit, this is always 1.0.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.4 and later in Carbon.framework [32-bit only] but deprecated in 10.7
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.4 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowGetScaleMode(
  WindowRef            inWindow,
  HIWindowScaleMode *  outMode,
  CGFloat *            outScaleFactor)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_7;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window FullScreen Transition                                                       */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIWindowToggleFullScreen()
 *  
 *  Summary:
 *    Causes a window to enter or exit fullscreen.
 *  
 *  Discussion:
 *    If the window is not already fullscreen and the window is capable
 *    of becoming fullscreen -- see kHIWindowBitFullScreenPrimary --
 *    the window will enter fullscreen. Otherwise, if the window is
 *    already fullscreen, the window will exit fullscreen.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose fullscreen state to toggle.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.7 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowToggleFullScreen(WindowRef inWindow)                  AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;


/*
 *  HIWindowIsFullScreen()
 *  
 *  Summary:
 *    Returns whether the window is fullscreen.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose fullscreen state to query.
 *  
 *  Result:
 *    A Boolean indicating whether the window is fullscreen: True means
 *    fullscreen, and false means not fullscreen.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.7 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIWindowIsFullScreen(WindowRef inWindow)                      AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Content Border                                                              */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */


/*
 *  HIContentBorderMetrics
 *  
 *  Summary:
 *    Describes the border of the content area of the window that will
 *    contain the window frame gradient.
 */
struct HIContentBorderMetrics {

  /*
   * Height of the top of the content border area.
   */
  CGFloat             top;

  /*
   * Width of the left of the content border area.
   */
  CGFloat             left;

  /*
   * Height of the bottom of the content border area.
   */
  CGFloat             bottom;

  /*
   * Width of the right of the content border area.
   */
  CGFloat             right;
};
typedef struct HIContentBorderMetrics   HIContentBorderMetrics;
#if !__LP64__
/*
 *  HIWindowSetContentBorderThickness()
 *  
 *  Summary:
 *    Sets the thickness of the window border that extends into the
 *    content area of the window.
 *  
 *  Discussion:
 *    In Mac OS X 10.5, windows can have a gradient on the top and
 *    bottom section of the window which have the appearance and
 *    behavior of being part of the window frame. The window frame
 *    gradient is drawn or extended into this border and the window is
 *    draggable from this area. Functionally, the area actually extends
 *    into the content of the window where the client can embed
 *    controls or print status messages a la iTunes. This can be set on
 *    all non-floating windows.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose content border thickness is being set.
 *    
 *    inBorderThickness:
 *      A pointer to a structure that indicates how much of the content
 *      area is used for the frame gradient drawing. Currently only the
 *      top and bottom fields are allowed. If any value other than 0 is
 *      used for the left or right fields, this function will return
 *      paramErr.
 *  
 *  Result:
 *    An operating system result code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIWindowSetContentBorderThickness(
  HIWindowRef                     inWindow,
  const HIContentBorderMetrics *  inBorderThickness)          AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIWindowGetContentBorderThickness()
 *  
 *  Summary:
 *    Retrieves the border thickness of the content area of the window.
 *  
 *  Discussion:
 *    In Mac OS X 10.5, windows can have a gradient on the top and
 *    bottom section of the window which have the appearance and
 *    behavior of being part of the window frame. This is actually the
 *    border of the content area of the window, and this API returns
 *    the metrics of this content border.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window to be queried.
 *  
 *  Result:
 *    A structure describing the metrics of the content view that is
 *    drawn with the window frame appearance.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern HIContentBorderMetrics 
HIWindowGetContentBorderThickness(HIWindowRef inWindow)       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Properties                                                                  */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
   Routines available from Mac OS 8.5 forward
   or from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward
*/

/*
 *  GetWindowProperty()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowProperty(
  WindowRef         window,
  PropertyCreator   propertyCreator,
  PropertyTag       propertyTag,
  ByteCount         bufferSize,
  ByteCount *       actualSize,            /* can be NULL */
  void *            propertyBuffer)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowPropertySize()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowPropertySize(
  WindowRef         window,
  PropertyCreator   creator,
  PropertyTag       tag,
  ByteCount *       size)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetWindowProperty()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowProperty(
  WindowRef         window,
  PropertyCreator   propertyCreator,
  PropertyTag       propertyTag,
  ByteCount         propertySize,
  const void *      propertyBuffer)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RemoveWindowProperty()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
RemoveWindowProperty(
  WindowRef         window,
  PropertyCreator   propertyCreator,
  PropertyTag       propertyTag)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/* Routines available from Mac OS 8.1 forward when linking to CarbonLib 1.0 forward*/

#endif  /* !__LP64__ */

enum {
  kWindowPropertyPersistent     = 0x00000001 /* whether this property is preserved when the system causes your application to be quit and relaunched */
};

#if !__LP64__
/*
 *  GetWindowPropertyAttributes()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetWindowPropertyAttributes(
  WindowRef     window,
  OSType        propertyCreator,
  OSType        propertyTag,
  OptionBits *  attributes)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ChangeWindowPropertyAttributes()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ChangeWindowPropertyAttributes(
  WindowRef    window,
  OSType       propertyCreator,
  OSType       propertyTag,
  OptionBits   attributesToSet,
  OptionBits   attributesToClear)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Utilities                                                                          */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  PinRect()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern long 
PinRect(
  const Rect *  theRect,
  Point         thePt)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Part Tracking                                                               */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  TrackBox()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern Boolean 
TrackBox(
  WindowRef        window,
  Point            thePt,
  WindowPartCode   partCode)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  TrackGoAway()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern Boolean 
TrackGoAway(
  WindowRef   window,
  Point       thePt)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Accessors                                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  GetWindowGoAwayFlag()
 *  
 *  Discussion:
 *    use GetWindowAttributes in Carbon
 *  
 *  Availability:
 *    Mac OS X:         not available [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */


/*
 *  GetWindowSpareFlag()
 *  
 *  Discussion:
 *    use GetWindowAttributes in Carbon
 *  
 *  Availability:
 *    Mac OS X:         not available [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */


/*
 *  GetWindowList()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0.2 and later
 */
extern WindowRef 
GetWindowList(void)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  GetWindowPort()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern CGrafPtr 
GetWindowPort(WindowRef window)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetWindowStructurePort()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern CGrafPtr 
GetWindowStructurePort(WindowRef inWindow)                    AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER;



/*
 *  GetWindowKind()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern short 
GetWindowKind(WindowRef window)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsWindowHilited()
 *  
 *  Summary:
 *    Indicates whether a window's frame is hilited.
 *  
 *  Discussion:
 *    See HiliteWindow for a disucssion on the meaning of a window's
 *    hilited state.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose hilited state you wish to retrieve.
 *  
 *  Result:
 *    A Boolean indicating whether the window's frame is hilited.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern Boolean 
IsWindowHilited(WindowRef window)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  IsWindowUpdatePending()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern Boolean 
IsWindowUpdatePending(WindowRef window)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  [Mac]GetNextWindow()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0.2 and later or as macro/inline
 */
#if TARGET_OS_MAC
    #define MacGetNextWindow GetNextWindow
#endif
extern WindowRef 
MacGetNextWindow(WindowRef window)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetPreviousWindow()
 *  
 *  Summary:
 *    Returns the window above a given window in the window list.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window above this window is returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.6 and later
 *    Non-Carbon CFM:   not available
 */
extern WindowRef 
GetPreviousWindow(WindowRef inWindow)                         AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;



/*
 *  GetWindowStandardState()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern Rect * 
GetWindowStandardState(
  WindowRef   window,
  Rect *      rect)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  GetWindowUserState()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern Rect * 
GetWindowUserState(
  WindowRef   window,
  Rect *      rect)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  SetWindowKind()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern void 
SetWindowKind(
  WindowRef   window,
  short       kind)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  SetWindowStandardState()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern void 
SetWindowStandardState(
  WindowRef     window,
  const Rect *  rect)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  SetWindowUserState()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern void 
SetWindowUserState(
  WindowRef     window,
  const Rect *  rect)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  SetPortWindowPort()
 *  
 *  Discussion:
 *    set the current QuickDraw port to the port associated with the
 *    window
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern void 
SetPortWindowPort(WindowRef window)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;




/*
 *  GetWindowPortBounds()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern Rect * 
GetWindowPortBounds(
  WindowRef   window,
  Rect *      bounds)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  GetWindowFromPort()
 *  
 *  Discussion:
 *    Needed to ‘cast up’ to a WindowRef from a GrafPtr
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later or as macro/inline
 */
extern WindowRef 
GetWindowFromPort(CGrafPtr port)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/* old accessors*/

#endif  /* !__LP64__ */

/*
 *  GetWindowDataHandle()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */



/*
 *  SetWindowDataHandle()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */



/*
 *  GetWindowZoomFlag()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */



/*
 *  GetWindowStructureRgn()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */



/*
 *  GetWindowContentRgn()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */



/*
 *  GetWindowUpdateRgn()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */



/*
 *  GetWindowTitleWidth()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */



/*--------------------------------------------------------------------------------------*/
/*  • DEPRECATED                                                                        */
/*                                                                                      */
/*  All functions below this point are either deprecated (they continue to function     */
/*  but are not the most modern nor most efficient solution to a problem), or they are  */
/*  completely unavailable on Mac OS X.                                                 */
/*--------------------------------------------------------------------------------------*/
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Definition Messages                                                         */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  kWindowMsgDraw                = 0,
  kWindowMsgHitTest             = 1,
  kWindowMsgCalculateShape      = 2,
  kWindowMsgInitialize          = 3,
  kWindowMsgCleanUp             = 4,
  kWindowMsgDrawGrowOutline     = 5,
  kWindowMsgDrawGrowBox         = 6
};

/* Messages available from Mac OS 8.0 forward*/
enum {
  kWindowMsgGetFeatures         = 7,
  kWindowMsgGetRegion           = 8
};

/* Messages available from Mac OS 8.5 forward*/
enum {
  kWindowMsgDragHilite          = 9,    /* parameter boolean indicating on or off*/
  kWindowMsgModified            = 10,   /* parameter boolean indicating saved (false) or modified (true)*/
  kWindowMsgDrawInCurrentPort   = 11,   /* same as kWindowMsgDraw, but must draw in current port*/
  kWindowMsgSetupProxyDragImage = 12,   /* parameter pointer to SetupWindowProxyDragImageRec*/
  kWindowMsgStateChanged        = 13,   /* something about the window's state has changed*/
  kWindowMsgMeasureTitle        = 14    /* measure and return the ideal title width*/
};

/* Messages only available in Carbon*/
enum {
  kWindowMsgGetGrowImageRegion  = 19    /* get region to xor during grow/resize. parameter pointer to GetGrowImageRegionRec.*/
};

/* old names*/
enum {
  wDraw                         = kWindowMsgDraw,
  wHit                          = kWindowMsgHitTest,
  wCalcRgns                     = kWindowMsgCalculateShape,
  wNew                          = kWindowMsgInitialize,
  wDispose                      = kWindowMsgCleanUp,
  wGrow                         = kWindowMsgDrawGrowOutline,
  wDrawGIcon                    = kWindowMsgDrawGrowBox
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • State-changed Flags for kWindowMsgStateChanged                                     */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  kWindowStateTitleChanged      = (1 << 0)
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • WDEF Message Types                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
   SetupWindowProxyDragImageRec - setup the proxy icon drag image
   Both regions are allocated and disposed by the Window Manager.
   The GWorld is disposed of by the Window Manager, but the WDEF must allocate
   it.  See Technote on Drag Manager 1.1 additions for more information and sample code for
   setting up drag images.
*/

struct SetupWindowProxyDragImageRec {
  GWorldPtr           imageGWorld;            /* locked GWorld containing the drag image - output - can be NULL*/
  RgnHandle           imageRgn;               /* image clip region, contains the portion of the image which gets blitted to screen - preallocated output - if imageGWorld is NULL, this is ignored*/
  RgnHandle           outlineRgn;             /* the outline region used on shallow monitors - preallocated output - must always be non-empty*/
};
typedef struct SetupWindowProxyDragImageRec SetupWindowProxyDragImageRec;
/* MeasureWindowTitleRec - a pointer to this is passed in WDEF param for kWindowMsgMeasureTitle*/
struct MeasureWindowTitleRec {
                                              /* output parameters (filled in by the WDEF)*/
  SInt16              fullTitleWidth;         /* text + proxy icon width*/
  SInt16              titleTextWidth;         /* text width*/

                                              /* input parameters*/
  Boolean             isUnicodeTitle;
  Boolean             unused;                 /* future use*/
};
typedef struct MeasureWindowTitleRec    MeasureWindowTitleRec;
typedef MeasureWindowTitleRec *         MeasureWindowTitleRecPtr;
/*
   GetGrowImageRegionRec - generate a region to be xored during GrowWindow and ResizeWindow.
   This is passed along with a kWindowMsgGetGrowImageRegion message. On input, the growRect
   parameter is the window's new bounds in global coordinates. The growImageRegion parameter
   will be allocated and disposed automatically; the window definition should alter the 
   region appropriately.
*/
struct GetGrowImageRegionRec {
  Rect                growRect;
  RgnHandle           growImageRegion;
};
typedef struct GetGrowImageRegionRec    GetGrowImageRegionRec;
/* GetWindowRegionRec - a pointer to this is passed in WDEF param for kWindowMsgGetRegion*/
struct GetWindowRegionRec {
  RgnHandle           winRgn;
  WindowRegionCode    regionCode;
};
typedef struct GetWindowRegionRec       GetWindowRegionRec;
typedef GetWindowRegionRec *            GetWindowRegionPtr;
typedef GetWindowRegionRec *            GetWindowRegionRecPtr;
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Desktop Pattern Resource ID                                                        */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  deskPatID                     = 16
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Color Part Codes                                                            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
enum {
  wContentColor                 = 0,
  wFrameColor                   = 1,
  wTextColor                    = 2,
  wHiliteColor                  = 3,
  wTitleBarColor                = 4
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Window Color Table                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————*/
struct WinCTab {
  long                wCSeed;                 /* reserved */
  short               wCReserved;             /* reserved */
  short               ctSize;                 /* usually 4 for windows */
  ColorSpec           ctTable[5];
};
typedef struct WinCTab                  WinCTab;
typedef WinCTab *                       WCTabPtr;
typedef WCTabPtr *                      WCTabHandle;
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • WindowRecords                                                                      */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • AuxWinHandle                                                                       */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • BasicWindowDescription                                                            */
/*                                                                                      */
/*  Contains statically-sized basic attributes of the window, for storage in a          */
/*  collection item.                                                                    */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* constants for the version field*/
enum {
  kWindowDefinitionVersionOne   = 1,
  kWindowDefinitionVersionTwo   = 2
};

/* constants for the stateflags bit field */
enum {
  kWindowIsCollapsedState       = (1 << 0L)
};

struct BasicWindowDescription {
  UInt32              descriptionSize;        /* sizeof(BasicWindowDescription)*/

  Rect                windowContentRect;      /* location on screen*/
  Rect                windowZoomRect;         /* location on screen when zoomed out*/
  URefCon             windowRefCon;           /* the refcon - __avoid saving stale pointers here__  */
  UInt32              windowStateFlags;       /* window state bit flags*/
  WindowPositionMethod  windowPositionMethod; /* method last used by RepositionWindow to position the window (if any)*/

  UInt32              windowDefinitionVersion;
  union {
    struct {
      SInt16              windowDefProc;      /* defProc and variant*/
      Boolean             windowHasCloseBox;
    }                       versionOne;

    struct {
      WindowClass         windowClass;        /* the class*/
      WindowAttributes    windowAttributes;   /* the attributes*/
    }                       versionTwo;

  }                       windowDefinition;
};
typedef struct BasicWindowDescription   BasicWindowDescription;
/*  the window manager stores the default collection items using these IDs*/
enum {
  kStoredWindowSystemTag        = 'appl', /* Only Apple collection items will be of this tag*/
  kStoredBasicWindowDescriptionID = 'sbas', /* BasicWindowDescription*/
  kStoredWindowPascalTitleID    = 's255', /* pascal title string*/
  kStoredWindowTitleCFStringID  = 'cfst' /* CFString title string*/
};


/*
 *  DeskHookProcPtr
 *  
 *  Summary:
 *    Callback function that handles mouse clicks on the desktop.
 */
typedef CALLBACK_API( void , DeskHookProcPtr )(Boolean mouseClick, EventRecord *theEvent);

/*
 *  WindowPaintProcPtr
 *  
 *  Summary:
 *    Callback function that paints a window's content area.
 */
typedef CALLBACK_API( OSStatus , WindowPaintProcPtr )(GDHandle device, GrafPtr qdContext, WindowRef window, RgnHandle inClientPaintRgn, RgnHandle outSystemPaintRgn, void *refCon);
typedef STACK_UPP_TYPE(DeskHookProcPtr)                         DeskHookUPP;
typedef STACK_UPP_TYPE(WindowPaintProcPtr)                      WindowPaintUPP;
/*
 *  NewDeskHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  NewWindowPaintUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern WindowPaintUPP
NewWindowPaintUPP(WindowPaintProcPtr userRoutine)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  DisposeDeskHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  DisposeWindowPaintUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeWindowPaintUPP(WindowPaintUPP userUPP)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  InvokeDeskHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  InvokeWindowPaintUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern OSStatus
InvokeWindowPaintUPP(
  GDHandle        device,
  GrafPtr         qdContext,
  WindowRef       window,
  RgnHandle       inClientPaintRgn,
  RgnHandle       outSystemPaintRgn,
  void *          refCon,
  WindowPaintUPP  userUPP)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

#if __MACH__
  #ifdef __cplusplus
    inline WindowPaintUPP                                       NewWindowPaintUPP(WindowPaintProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeWindowPaintUPP(WindowPaintUPP) { }
    inline OSStatus                                             InvokeWindowPaintUPP(GDHandle device, GrafPtr qdContext, WindowRef window, RgnHandle inClientPaintRgn, RgnHandle outSystemPaintRgn, void * refCon, WindowPaintUPP userUPP) { return (*userUPP)(device, qdContext, window, inClientPaintRgn, outSystemPaintRgn, refCon); }
  #else
    #define NewWindowPaintUPP(userRoutine)                      ((WindowPaintUPP)userRoutine)
    #define DisposeWindowPaintUPP(userUPP)
    #define InvokeWindowPaintUPP(device, qdContext, window, inClientPaintRgn, outSystemPaintRgn, refCon, userUPP) (*userUPP)(device, qdContext, window, inClientPaintRgn, outSystemPaintRgn, refCon)
  #endif
#endif

#if !__LP64__
/*
 *  NewWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CreateNewWindow instead of NewWindow.
 *  
 *  Summary:
 *    Creates a new window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern WindowRef 
NewWindow(
  void *             wStorage,
  const Rect *       boundsRect,
  ConstStr255Param   title,
  Boolean            visible,
  short              theProc,
  WindowRef          behind,
  Boolean            goAwayFlag,
  SRefCon            refCon)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  NewCWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CreateNewWindow instead of NewCWindow.
 *  
 *  Summary:
 *    Creates a new window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern WindowRef 
NewCWindow(
  void *             wStorage,
  const Rect *       boundsRect,
  ConstStr255Param   title,
  Boolean            visible,
  short              procID,
  WindowRef          behind,
  Boolean            goAwayFlag,
  SRefCon            refCon)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetNewCWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use nib files and CreateWindowFromNib instead of GetNewCWindow.
 *  
 *  Summary:
 *    Loads a window from a 'WIND' resource.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern WindowRef 
GetNewCWindow(
  short       windowID,
  void *      wStorage,
  WindowRef   behind)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetNewWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use nib files and CreateWindowFromNib instead of GetNewWindow.
 *  
 *  Summary:
 *    Loads a window from a 'WIND' resource.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern WindowRef 
GetNewWindow(
  short       windowID,
  void *      wStorage,
  WindowRef   behind)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  CreateWindowFromResource()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use nib files and CreateWindowFromNib instead of
 *    CreateWindowFromResource.
 *  
 *  Summary:
 *    Loads a window from a 'wind' resource.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
CreateWindowFromResource(
  SInt16       resID,
  WindowRef *  outWindow)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  StoreWindowIntoCollection()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIArchiveEncodeCFType to encode a window to an archive
 *    instead of StoreWindowIntoCollection.
 *  
 *  Summary:
 *    Stores a description of a window into a Collection Manager
 *    collection.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
StoreWindowIntoCollection(
  WindowRef    window,
  Collection   collection)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  CreateWindowFromCollection()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIArchiveCopyDecodedCFType to decode a window from an archive
 *    instead of CreateWindowFromCollection.
 *  
 *  Summary:
 *    Creates a window from a window description stored in a Collection
 *    Manager collection.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
CreateWindowFromCollection(
  Collection   collection,
  WindowRef *  outWindow)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetWindowOwnerCount()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    In Mac OS X 10.2 and later, use CFGetRetainCount instead of
 *    GetWindowOwnerCount.
 *  
 *  Summary:
 *    Returns the retain count of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowOwnerCount(
  WindowRef    window,
  ItemCount *  outCount)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  CloneWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    On Mac OS X 10.2 and later, use CFRetain instead of CloneWindow.
 *  
 *  Summary:
 *    Increments the retain count of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
CloneWindow(WindowRef window)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetWindowRetainCount()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    In Mac OS X 10.2 and later, use CFGetRetainCount instead of
 *    GetWindowRetainCount.
 *  
 *  Summary:
 *    Returns the retain count of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern ItemCount 
GetWindowRetainCount(WindowRef inWindow)                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  RetainWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    On Mac OS X 10.2 and later, use CFRetain instead of RetainWindow.
 *  
 *  Summary:
 *    Increments the retain count of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
RetainWindow(WindowRef inWindow)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  ReleaseWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    On Mac OS X 10.2 and later, use CFRelease instead of
 *    ReleaseWindow.
 *  
 *  Summary:
 *    Decrements the retain count of a window, and destroys the window
 *    if the retain count falls to zero.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ReleaseWindow(WindowRef inWindow)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetWVariant()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use GetWindowAttributes to determine aspects of a window's
 *    appearance or behavior.
 *  
 *  Summary:
 *    Retrieves the window variant code for a window.
 *  
 *  Discussion:
 *    The window variant code is the low four bits of a window's
 *    procID. This API is no longer recommended for use.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern short 
GetWVariant(WindowRef window)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetWindowClass()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIWindowChangeClass or SetWindowGroup or
 *    ChangeWindowAttributes (or all three) instead of SetWindowClass.
 *  
 *  Summary:
 *    Changes the window class of a window.
 *  
 *  Discussion:
 *    SetWindowClass changes the class of a window. It also changes the
 *    window's z-order so that it is grouped with other windows of the
 *    same class. It does not change the visual appearance of the
 *    window. In CarbonLib, SetWindowClass may not be used to change a
 *    non-utility window to have utility window class, or to make a
 *    utility window have non-utility class. SetWindowClass is
 *    available from CarbonLib 1.1 forward.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inWindow:
 *      The window whose class to change.
 *    
 *    inWindowClass:
 *      The new window class.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetWindowClass(
  WindowRef     inWindow,
  WindowClass   inWindowClass)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


#endif  /* !__LP64__ */

enum {
  kWindowPaintProcOptionsNone   = 0
};


typedef OptionBits                      WindowPaintProcOptions;
#if !__LP64__
/*
 *  InstallWindowContentPaintProc()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use an event handler for kEventControlDraw on a window's content
 *    view instead of installing a window content paint proc.
 *  
 *  Summary:
 *    Installs a callback function that is used by non-compositing
 *    windows to erase the window background.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 9.0 and later
 */
extern OSStatus 
InstallWindowContentPaintProc(
  WindowRef                window,
  WindowPaintUPP           paintProc,
  WindowPaintProcOptions   options,
  void *                   refCon)          /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  ClipAbove()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Do not use this function on Mac OS X; it does nothing.
 *  
 *  Summary:
 *    Sets the clip region of the Window Manager port to be the desktop
 *    minus the structure regions of the windows in front of the
 *    specified window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
ClipAbove(WindowRef window)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  PaintOne()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Applications never need to call PaintOne. Use InvalWindowRect,
 *    InvalWindowRgn, or HIViewSetNeedsDisplay to invalidate a portion
 *    of a window.
 *  
 *  Summary:
 *    Repaints a portion of a window's structure and content.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
PaintOne(
  WindowRef   window,             /* can be NULL */
  RgnHandle   clobberedRgn)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  PaintBehind()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Applications never need to call PaintBehind. Use InvalWindowRect,
 *    InvalWindowRgn, or HIViewSetNeedsDisplay to invalidate a portion
 *    of a window.
 *  
 *  Summary:
 *    Repaints the windows that intersect with a specified region.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
PaintBehind(
  WindowRef   startWindow,        /* can be NULL */
  RgnHandle   clobberedRgn)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  CalcVis()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The visible region of a window on Mac OS X is managed by the
 *    window server. Applications never need to call this function.
 *  
 *  Summary:
 *    Recalculates the visible region of a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
CalcVis(WindowRef window)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  CalcVisBehind()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The visible region of a window on Mac OS X is managed by the
 *    window server. Applications never need to call this function.
 *  
 *  Summary:
 *    Recalculates the visible region of windows that intersect with a
 *    specified region.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
CalcVisBehind(
  WindowRef   startWindow,        /* can be NULL */
  RgnHandle   clobberedRgn)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  CheckUpdate()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use AcquireFirstMatchingEventInQueue instead of CheckUpdate.
 *  
 *  Summary:
 *    Searches the event queue for the next available update event.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern Boolean 
CheckUpdate(EventRecord * theEvent)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  FrontWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use ActiveNonFloatingWindow, FrontNonFloatingWindow, or
 *    GetFrontWindowOfClass instead of FrontWindow.
 *  
 *  Summary:
 *    Returns the frontmost visible window in the window list.
 *  
 *  Discussion:
 *    The frontmost visible window is not necessarily a document or
 *    dialog window, or even a window created by your application. For
 *    example, it may be a menu window, a Text Services Manager
 *    bottom-line input window, a help tag, or a floating window. If
 *    your code needs the frontmost document or dialog window, use the
 *    ActiveNonFloatingWindow or FrontNonFloatingWindow APIs instead of
 *    FrontWindow. For compatibility with existing applications,
 *    FrontWindow ignores all windows of class kMenuBarWindowClass and
 *    instead returns the frontmost visible window behind the menubar.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Result:
 *    The frontmost visible window, or NULL if no windows are visible.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern WindowRef 
FrontWindow(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetWindowPic()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use an HIImageView placed in the window instead of SetWindowPic.
 *  
 *  Summary:
 *    Causes a picture to be drawn in a window's content area.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetWindowPic(
  WindowRef   window,
  PicHandle   pic)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetWindowPic()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    If using an HIImageView to draw a window's content, ask the image
 *    view for its image instead of calling GetWindowPic.
 *  
 *  Summary:
 *    Retrieves the picture being drawn in a window's content area.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern PicHandle 
GetWindowPic(WindowRef window)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetWindowProxyFSSpec()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIWindowSetProxyFSRef instead of SetWindowProxyFSSpec.
 *  
 *  Summary:
 *    Set the proxy icon for a window using an FSSpec to an existing
 *    file system object (volume, folder, or file).
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon to set.
 *    
 *    inFile:
 *      The file system object that the window represents. The window’s
 *      proxy icon is determined by asking Icon Services for the icon
 *      of this object.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
SetWindowProxyFSSpec(
  WindowRef       window,
  const FSSpec *  inFile)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetWindowProxyFSSpec()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use HIWindowGetProxyFSRef instead of GetWindowProxyFSSpec.
 *  
 *  Summary:
 *    Returns the FSSpec used to determine the proxy icon for a window.
 *  
 *  Discussion:
 *    This API will return noErr and a valid FSSpec if the window’s
 *    proxy icon has been specified using the SetWindowProxyFSSpec or
 *    SetWindowProxyAlias APIs. If the window has no proxy icon, or if
 *    the icon was specified with another SetWindowProxy API, then an
 *    error will be returned.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window whose proxy icon FSSpec to return.
 *    
 *    outFile:
 *      On exit, contains the window’s proxy icon FSSpec.
 *  
 *  Result:
 *    noErr if the window’s proxy icon FSSpec has been returned;
 *    errWindowDoesNotHaveProxy if the window does not have a proxy
 *    icon, or if the proxy icon was specified by IconRef or
 *    type/creator rather than by FSSpec or alias. Other operating
 *    system error codes may also be returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern OSStatus 
GetWindowProxyFSSpec(
  WindowRef   window,
  FSSpec *    outFile)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  IsWindowPathSelectClick()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use IsWindowPathSelectEvent instead of IsWindowPathSelectClick.
 *  
 *  Summary:
 *    Indicates whether an EventRecord describing a click on a window’s
 *    title should cause a path selection menu to be displayed.
 *  
 *  Discussion:
 *    Windows that have a proxy icon provided using an FSSpec or alias
 *    can support a path selection menu, which displays the file system
 *    path to the object, one menu item per directory. Making a
 *    selection from this item will automatically open the
 *    corresponding object in the Finder.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    window:
 *      The window on which the click occurred.
 *    
 *    event:
 *      The event. IsWindowPathSelectClick will only return true for
 *      mouseDown events.
 *  
 *  Result:
 *    true if the click should cause a path selection menu to be
 *    displayed, or false if not. If this API returns true, the
 *    application should call the WindowPathSelect API.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in WindowsLib 8.5 and later
 */
extern Boolean 
IsWindowPathSelectClick(
  WindowRef            window,
  const EventRecord *  event)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetWTitle()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use SetWindowTitleWithCFString instead of SetWTitle.
 *  
 *  Summary:
 *    Sets the title of a window using a Pascal string.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetWTitle(
  WindowRef          window,
  ConstStr255Param   title)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetWTitle()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CopyWindowTitleAsCFString instead of GetWTitle.
 *  
 *  Summary:
 *    Retrieves the title of a window as a Pascal string.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
GetWTitle(
  WindowRef   window,
  Str255      title)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  DrawGrowIcon()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    DrawGrowIcon is deprecated from Mac OS 8.0 forward. Theme-savvy
 *    window defprocs automatically draw the grow box in the window
 *    frame.
 *  
 *  Summary:
 *    Draws the grow icon in a window.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
DrawGrowIcon(WindowRef window)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GrowWindow()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use ResizeWindow instead of GrowWindow.
 *  
 *  Summary:
 *    Tracks the mouse while the user resizes a window, and returns the
 *    new width and height.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern long 
GrowWindow(
  WindowRef     window,
  Point         startPt,
  const Rect *  bBox)          /* can be NULL */              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetGrayRgn()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    To determine the area in which a window may be positioned, use
 *    HIWindowCopyAvailablePositioningShape.
 *  
 *  Summary:
 *    Returns a region that covers the desktop area of all active
 *    displays.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern RgnHandle 
GetGrayRgn(void)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  DragGrayRgn()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use a overlay window or other custom drawing instead of
 *    DragGrayRgn.
 *  
 *  Summary:
 *    Tracks the mouse as the user drags a gray outline of a region.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern long 
DragGrayRgn(
  RgnHandle        theRgn,
  Point            startPt,
  const Rect *     limitRect,
  const Rect *     slopRect,
  short            axis,
  DragGrayRgnUPP   actionProc)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  DragTheRgn()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use a overlay window or other custom drawing instead of
 *    DragTheRgn.
 *  
 *  Summary:
 *    Tracks the mouse as the user drags the outline of a region. The
 *    outline is drawn using the pattern specified in the DragPattern
 *    low-memory global.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern long 
DragTheRgn(
  RgnHandle        theRgn,
  Point            startPt,
  const Rect *     limitRect,
  const Rect *     slopRect,
  short            axis,
  DragGrayRgnUPP   actionProc)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*——————————————————————————————————————————————————————————————————————————————————————————————————*/
/* Obsolete symbolic names                                                                          */
/*——————————————————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */

enum {
  kWindowGroupAttrSelectable    = kWindowGroupAttrSelectAsLayer,
  kWindowGroupAttrPositionFixed = kWindowGroupAttrMoveTogether,
  kWindowGroupAttrZOrderFixed   = kWindowGroupAttrLayerTogether
};










#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __MACWINDOWS__ */

                                                  MacWindows.r                                                                                        0100644 0001750 0001750 00000026074 12566221370 043246  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       MacWindows.r
 
     Contains:   Window Manager Interfaces
 
     Copyright:  © 1997-2008 by Apple Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/

#ifndef __MACWINDOWS_R__
#define __MACWINDOWS_R__

#ifndef __CORESERVICES_R__
#include <CoreServices/CoreServices.r>
#endif

#define kAlertWindowClass 				1
#define kMovableAlertWindowClass 		2
#define kModalWindowClass 				3
#define kMovableModalWindowClass 		4
#define kFloatingWindowClass 			5
#define kDocumentWindowClass 			6
#define kUtilityWindowClass 			8
#define kHelpWindowClass 				10
#define kSheetWindowClass 				11
#define kToolbarWindowClass 			12
#define kPlainWindowClass 				13
#define kOverlayWindowClass 			14
#define kSheetAlertWindowClass 			15
#define kAltPlainWindowClass 			16
#define kSimpleWindowClass 				18
#define kDrawerWindowClass 				20
#define kAllWindowClasses 				0xFFFFFFFF

#define kWindowNoAttributes 			0
#define kWindowCloseBoxAttribute 		0x01
#define kWindowHorizontalZoomAttribute 	0x02
#define kWindowVerticalZoomAttribute 	0x04
#define kWindowFullZoomAttribute 		0x06
#define kWindowCollapseBoxAttribute 	0x08
#define kWindowResizableAttribute 		0x10
#define kWindowSideTitlebarAttribute 	0x20
#define kWindowToolbarButtonAttribute 	0x40
#define kWindowUnifiedTitleAndToolbarAttribute  0x80
#define kWindowMetalAttribute 			0x0100
#define kWindowNoTitleBarAttribute 		0x0200
#define kWindowTexturedSquareCornersAttribute  0x0400
#define kWindowMetalNoContentSeparatorAttribute  0x0800
#define kWindowHasRoundBottomBarCornersAttribute  0x1000
#define kWindowDoesNotCycleAttribute 	0x8000
#define kWindowNoUpdatesAttribute 		0x00010000
#define kWindowNoActivatesAttribute 	0x00020000
#define kWindowOpaqueForEventsAttribute  0x00040000
#define kWindowCompositingAttribute 	0x00080000
#define kWindowNoShadowAttribute 		0x00200000
#define kWindowCanBeVisibleWithoutLoginAttribute  0x00400000
#define kWindowHideOnSuspendAttribute 	0x01000000
#define kWindowAsyncDragAttribute 		0x00800000
#define kWindowStandardHandlerAttribute  0x02000000
#define kWindowHideOnFullScreenAttribute  0x04000000
#define kWindowInWindowMenuAttribute 	0x08000000
#define kWindowLiveResizeAttribute 		0x10000000
#define kWindowIgnoreClicksAttribute 	0x20000000
#define kWindowHighResolutionCapableAttribute  0x00100000
#define kWindowStandardDocumentAttributes  0x1F
#define kWindowStandardFloatingAttributes  0x09

#define kWindowFrameworkScaledAttribute  0x00100000
#define kWindowDefProcType 				'WDEF'
#define kStandardWindowDefinition 		0					/*  for document windows and dialogs */
#define kRoundWindowDefinition 			1					/*  old Desk Accessory-style window */
#define kFloatingWindowDefinition 		124					/*  for floating windows */

															/*  for use with kStandardWindowDefinition  */
#define kDocumentWindowVariantCode 		0
#define kModalDialogVariantCode 		1
#define kPlainDialogVariantCode 		2
#define kShadowDialogVariantCode 		3
#define kMovableModalDialogVariantCode 	5
#define kAlertVariantCode 				7
#define kMovableAlertVariantCode 		9					/*  for use with kFloatingWindowDefinition  */
#define kSideFloaterVariantCode 		8

															/*  Resource IDs for theme-savvy window defprocs  */
#define kWindowDocumentDefProcResID 	64
#define kWindowDialogDefProcResID 		65
#define kWindowUtilityDefProcResID 		66
#define kWindowUtilitySideTitleDefProcResID  67
#define kWindowSheetDefProcResID 		68
#define kWindowSimpleDefProcResID 		69
#define kWindowSheetAlertDefProcResID 	70

															/*  Proc IDs for theme-savvy windows  */
#define kWindowDocumentProc 			1024
#define kWindowGrowDocumentProc 		1025
#define kWindowVertZoomDocumentProc 	1026
#define kWindowVertZoomGrowDocumentProc  1027
#define kWindowHorizZoomDocumentProc 	1028
#define kWindowHorizZoomGrowDocumentProc  1029
#define kWindowFullZoomDocumentProc 	1030
#define kWindowFullZoomGrowDocumentProc  1031

															/*  Proc IDs for theme-savvy dialogs  */
#define kWindowPlainDialogProc 			1040
#define kWindowShadowDialogProc 		1041
#define kWindowModalDialogProc 			1042
#define kWindowMovableModalDialogProc 	1043
#define kWindowAlertProc 				1044
#define kWindowMovableAlertProc 		1045

															/*  procIDs available from Mac OS 8.1 (Appearance 1.0.1) forward  */
#define kWindowMovableModalGrowProc 	1046
															/*  Proc IDs for top title bar theme-savvy floating windows  */
#define kWindowFloatProc 				1057
#define kWindowFloatGrowProc 			1059
#define kWindowFloatVertZoomProc 		1061
#define kWindowFloatVertZoomGrowProc 	1063
#define kWindowFloatHorizZoomProc 		1065
#define kWindowFloatHorizZoomGrowProc 	1067
#define kWindowFloatFullZoomProc 		1069
#define kWindowFloatFullZoomGrowProc 	1071

															/*  Proc IDs for side title bar theme-savvy floating windows  */
#define kWindowFloatSideProc 			1073
#define kWindowFloatSideGrowProc 		1075
#define kWindowFloatSideVertZoomProc 	1077
#define kWindowFloatSideVertZoomGrowProc  1079
#define kWindowFloatSideHorizZoomProc 	1081
#define kWindowFloatSideHorizZoomGrowProc  1083
#define kWindowFloatSideFullZoomProc 	1085
#define kWindowFloatSideFullZoomGrowProc  1087

															/*  Proc IDs for sheet windows  */
#define kWindowSheetProc 				1088				/*  available in Mac OS X and CarbonLib 1.3  */
#define kWindowSheetAlertProc 			1120				/*  available in Mac OS X 10.1 and CarbonLib 1.3  */

															/*  Proc IDs for simple windows  */
#define kWindowSimpleProc 				1104
#define kWindowSimpleFrameProc 			1105

#define kWindowOverlayProc 				1136
#define kWindowNoPosition 				0x0000
#define kWindowDefaultPosition 			0x0000				/*  used by StandardAlert */
#define kWindowCenterMainScreen 		0x280A
#define kWindowAlertPositionMainScreen 	0x300A
#define kWindowStaggerMainScreen 		0x380A
#define kWindowCenterParentWindow 		0xA80A
#define kWindowAlertPositionParentWindow  0xB00A
#define kWindowStaggerParentWindow 		0xB80A
#define kWindowCenterParentWindowScreen  0x680A
#define kWindowAlertPositionParentWindowScreen  0x700A
#define kWindowStaggerParentWindowScreen  0x780A

#define kWindowCenterOnMainScreen 		1
#define kWindowCenterOnParentWindow 	2
#define kWindowCenterOnParentWindowScreen  3
#define kWindowCascadeOnMainScreen 		4
#define kWindowCascadeOnParentWindow 	5
#define kWindowCascadeOnParentWindowScreen  6
#define kWindowCascadeStartAtParentWindowScreen  10
#define kWindowAlertPositionOnMainScreen  7
#define kWindowAlertPositionOnParentWindow  8
#define kWindowAlertPositionOnParentWindowScreen  9

#define kWindowDefinitionVersionOne 	1
#define kWindowDefinitionVersionTwo 	2

#define kWindowIsCollapsedState 		0x01
#define kStoredWindowSystemTag 			'appl'				/*  Only Apple collection items will be of this tag */
#define kStoredBasicWindowDescriptionID  'sbas'				/*  BasicWindowDescription */
#define kStoredWindowPascalTitleID 		's255'				/*  pascal title string */
#define kStoredWindowTitleCFStringID 	'cfst'				/*  CFString title string */



/*--------------------------wind • Extensible Window Resource Format------------------*/
/* The extensible window resource format is a flattened collection containing items    */
/* stored by StoreWindowIntoCollection, plus possible application-specific items.     */

type 'wind' as 'flac';


/*--------------------------wctb • Window Color Lookup Table--------------------------*/
/*
   wctb_RezTemplateVersion:
       0 - original 
      1 - more color parts and implicit header    <-- default
*/
#ifndef wctb_RezTemplateVersion
 #ifdef oldTemp                          /* grandfather in use of “oldTemp” */
      #define wctb_RezTemplateVersion 0
  #else
      #define wctb_RezTemplateVersion 1
  #endif
#endif


type 'wctb' {
#if wctb_RezTemplateVersion == 0
            unsigned hex longint;                                   /* ctSeed               */
         integer;                                                /* ctFlags              */
#elif wctb_RezTemplateVersion == 1
          unsigned hex longint = 0;                               /* ctSeed               */
         integer = 0;                                            /* ctFlags              */
#endif
          integer = $$Countof(ColorSpec) - 1;                     /* ctSize               */
         wide array ColorSpec {
                 integer     wContentColor,                      /* value                */
                             wFrameColor,
                               wTextColor,
                                wHiliteColor,
                              wTitleBarColor,
                                wHiliteLight,
                              wHiliteDark,
                               wTitleBarLight,
                                wTitleBarDark,
                             wDialogLight,
                              wDialogDark,
                               wTingeLight,
                               wTingeDark;
                    unsigned integer;                               /* RGB: red             */
                 unsigned integer;                               /*      green           */
                 unsigned integer;                               /*      blue            */
         };
 };


/*----------------------------WIND • Window Template------------------------------------*/
/*
 WIND_RezTemplateVersion:
       0 - original 
      1 - additional positioning info at end  <-- default 
*/
#ifndef WIND_RezTemplateVersion
    #define WIND_RezTemplateVersion 1
#endif


type 'WIND' {
     rect;                                                   /* boundsRect           */
     integer         documentProc,                           /* procID               */
                     dBoxProc,
                      plainDBox,
                     altDBoxProc,
                       noGrowDocProc,
                     movableDBoxProc,
                       zoomDocProc = 8,
                       zoomNoGrow = 12;
       byte            invisible, visible;                     /* visible              */
     fill byte;
     byte            noGoAway, goAway;                       /* goAway               */
     fill byte;
     unsigned hex longint;                                   /* refCon               */
     pstring         Untitled = "Untitled";              /* title                */
     
#if WIND_RezTemplateVersion == 1
  /*  The following are window positioning options used from Mac OS 7.0 forward */
       align word;
        unsigned integer                noAutoCenter = 0x0000,
                                     centerMainScreen = 0x280a,
                                     alertPositionMainScreen = 0x300a,
                                      staggerMainScreen = 0x380a,
                                        centerParentWindow = 0xa80a,
                                       alertPositionParentWindow = 0xb00a,
                                        staggerParentWindow = 0xb80a,
                                      centerParentWindowScreen = 0x680a,
                                     alertPositionParentWindowScreen = 0x700a,
                                      staggerParentWindowScreen = 0x780a;
#endif
};


#endif /* __MACWINDOWS_R__ */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Menus.h                                                                                             0100644 0001750 0001750 00000756222 12566221370 042255  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/Menus.h
 
     Contains:   Menu Manager Interfaces.
 
     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved.
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __MENUS__
#define __MENUS__

#ifndef __APPLICATIONSERVICES__
#include <ApplicationServices/ApplicationServices.h>
#endif

#ifndef __APPEARANCE__
#include <HIToolbox/Appearance.h>
#endif

#ifndef __CARBONEVENTSCORE__
#include <HIToolbox/CarbonEventsCore.h>
#endif

#ifndef __EVENTS__
#include <HIToolbox/Events.h>
#endif

#ifndef __HIOBJECT__
#include <HIToolbox/HIObject.h>
#endif



#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 2)


/*
 *  Menu Manager
 */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Constants                                                                    */
/*——————————————————————————————————————————————————————————————————————————————————————*/

/*
 */
enum {

  /*
   * Proc ID for a normal text menu. This constant is not typically
   * used.
   */
  textMenuProc                  = 0,

  /*
   * This value may be passed to InsertMenuItem, InsertMenuItemText,
   * and InsertMenuItemTextWithCFString to indicate that the new item
   * should be inserted at the end of the menu. Note that you can also
   * just call AppendMenu[ItemText][WithCFString].
   */
  kHIMenuAppendItem             = 0x0000FFFF
};

enum {
  noMark                        = 0     /* mark symbol for SetItemMark; other mark symbols are defined in Fonts.h */
};

/* Constants for use with MacOS 8.0 (Appearance 1.0) and later*/
enum {
  kMenuStdMenuProc              = 63,
  kMenuStdMenuBarProc           = 63
};

/* For use with Get/SetMenuItemModifiers*/
enum {
  kMenuNoModifiers              = 0,    /* Mask for no modifiers*/
  kMenuShiftModifier            = (1 << 0), /* Mask for shift key modifier*/
  kMenuOptionModifier           = (1 << 1), /* Mask for option key modifier*/
  kMenuControlModifier          = (1 << 2), /* Mask for control key modifier*/
  kMenuNoCommandModifier        = (1 << 3) /* Mask for no command key modifier*/
};

/* For use with Get/SetMenuItemIconHandle*/
enum {
  kMenuNoIcon                   = 0,    /* No icon*/
  kMenuIconType                 = 1,    /* Type for ICON*/
  kMenuShrinkIconType           = 2,    /* Type for ICON plotted 16 x 16*/
  kMenuSmallIconType            = 3,    /* Type for SICN*/
  kMenuColorIconType            = 4,    /* Type for cicn*/
  kMenuIconSuiteType            = 5,    /* Type for Icon Suite*/
  kMenuIconRefType              = 6,    /* Type for Icon Ref*/
  kMenuCGImageRefType           = 7,    /* Type for a CGImageRef (Mac OS X only)*/
  kMenuSystemIconSelectorType   = 8,    /* Type for an OSType identifying an IconRef registered with Icon Services under kSystemIconsCreator (Mac OS X 10.1 and later only)*/
  kMenuIconResourceType         = 9     /* Type for a CFStringRef with the full name of a .icns resource in the main bundle of the process (Mac OS X 10.1 and later only)*/
};

/* For use with Get/SetMenuItemKeyGlyph*/
enum {
  kMenuNullGlyph                = 0x00, /* Null (always glyph 1)*/
  kMenuTabRightGlyph            = 0x02, /* Tab to the right key (for left-to-right script systems)*/
  kMenuTabLeftGlyph             = 0x03, /* Tab to the left key (for right-to-left script systems)*/
  kMenuEnterGlyph               = 0x04, /* Enter key*/
  kMenuShiftGlyph               = 0x05, /* Shift key*/
  kMenuControlGlyph             = 0x06, /* Control key*/
  kMenuOptionGlyph              = 0x07, /* Option key*/
  kMenuSpaceGlyph               = 0x09, /* Space (always glyph 3) key*/
  kMenuDeleteRightGlyph         = 0x0A, /* Delete to the right key (for right-to-left script systems)*/
  kMenuReturnGlyph              = 0x0B, /* Return key (for left-to-right script systems)*/
  kMenuReturnR2LGlyph           = 0x0C, /* Return key (for right-to-left script systems)*/
  kMenuNonmarkingReturnGlyph    = 0x0D, /* Nonmarking return key*/
  kMenuPencilGlyph              = 0x0F, /* Pencil key*/
  kMenuDownwardArrowDashedGlyph = 0x10, /* Downward dashed arrow key*/
  kMenuCommandGlyph             = 0x11, /* Command key*/
  kMenuCheckmarkGlyph           = 0x12, /* Checkmark key*/
  kMenuDiamondGlyph             = 0x13, /* Diamond key*/
  kMenuAppleLogoFilledGlyph     = 0x14, /* Apple logo key (filled)*/
  kMenuParagraphKoreanGlyph     = 0x15, /* Unassigned (paragraph in Korean)*/
  kMenuDeleteLeftGlyph          = 0x17, /* Delete to the left key (for left-to-right script systems)*/
  kMenuLeftArrowDashedGlyph     = 0x18, /* Leftward dashed arrow key*/
  kMenuUpArrowDashedGlyph       = 0x19, /* Upward dashed arrow key*/
  kMenuRightArrowDashedGlyph    = 0x1A, /* Rightward dashed arrow key*/
  kMenuEscapeGlyph              = 0x1B, /* Escape key*/
  kMenuClearGlyph               = 0x1C, /* Clear key*/
  kMenuLeftDoubleQuotesJapaneseGlyph = 0x1D, /* Unassigned (left double quotes in Japanese)*/
  kMenuRightDoubleQuotesJapaneseGlyph = 0x1E, /* Unassigned (right double quotes in Japanese)*/
  kMenuTrademarkJapaneseGlyph   = 0x1F, /* Unassigned (trademark in Japanese)*/
  kMenuBlankGlyph               = 0x61, /* Blank key*/
  kMenuPageUpGlyph              = 0x62, /* Page up key*/
  kMenuCapsLockGlyph            = 0x63, /* Caps lock key*/
  kMenuLeftArrowGlyph           = 0x64, /* Left arrow key*/
  kMenuRightArrowGlyph          = 0x65, /* Right arrow key*/
  kMenuNorthwestArrowGlyph      = 0x66, /* Northwest arrow key*/
  kMenuHelpGlyph                = 0x67, /* Help key*/
  kMenuUpArrowGlyph             = 0x68, /* Up arrow key*/
  kMenuSoutheastArrowGlyph      = 0x69, /* Southeast arrow key*/
  kMenuDownArrowGlyph           = 0x6A, /* Down arrow key*/
  kMenuPageDownGlyph            = 0x6B, /* Page down key*/
  kMenuAppleLogoOutlineGlyph    = 0x6C, /* Apple logo key (outline)*/
  kMenuContextualMenuGlyph      = 0x6D, /* Contextual menu key*/
  kMenuPowerGlyph               = 0x6E, /* Power key*/
  kMenuF1Glyph                  = 0x6F, /* F1 key*/
  kMenuF2Glyph                  = 0x70, /* F2 key*/
  kMenuF3Glyph                  = 0x71, /* F3 key*/
  kMenuF4Glyph                  = 0x72, /* F4 key*/
  kMenuF5Glyph                  = 0x73, /* F5 key*/
  kMenuF6Glyph                  = 0x74, /* F6 key*/
  kMenuF7Glyph                  = 0x75, /* F7 key*/
  kMenuF8Glyph                  = 0x76, /* F8 key*/
  kMenuF9Glyph                  = 0x77, /* F9 key*/
  kMenuF10Glyph                 = 0x78, /* F10 key*/
  kMenuF11Glyph                 = 0x79, /* F11 key*/
  kMenuF12Glyph                 = 0x7A, /* F12 key*/
  kMenuF13Glyph                 = 0x87, /* F13 key*/
  kMenuF14Glyph                 = 0x88, /* F14 key*/
  kMenuF15Glyph                 = 0x89, /* F15 key*/
  kMenuControlISOGlyph          = 0x8A, /* Control key (ISO standard)*/
  kMenuEjectGlyph               = 0x8C, /* Eject key (available on Mac OS X 10.2 and later)*/
  kMenuEisuGlyph                = 0x8D, /* Japanese eisu key (available in Mac OS X 10.4 and later)*/
  kMenuKanaGlyph                = 0x8E, /* Japanese kana key (available in Mac OS X 10.4 and later)*/
  kMenuF16Glyph                 = 0x8F, /* F16 key (available in SnowLeopard and later)*/
  kMenuF17Glyph                 = 0x90, /* F17 key (available in SnowLeopard and later)*/
  kMenuF18Glyph                 = 0x91, /* F18 key (available in SnowLeopard and later)*/
  kMenuF19Glyph                 = 0x92  /* F19 key (available in SnowLeopard and later)*/
};


/*
 *  MenuAttributes
 *  
 *  Summary:
 *    Menu attributes control behavior of the entire menu. They are
 *    used with the Get/ChangeMenuAttributes APIs.
 */
typedef UInt32 MenuAttributes;
enum {

  /*
   * No column space is allocated for the mark character when this menu
   * is drawn.
   */
  kMenuAttrExcludesMarkColumn   = (1 << 0),

  /*
   * The menu title is automatically disabled when all items are
   * disabled.
   */
  kMenuAttrAutoDisable          = (1 << 2),

  /*
   * The pencil glyph from the Keyboard font (kMenuPencilGlyph) is used
   * to draw the Control modifier key in menu keyboard equivalents.
   * This appearance is typically used only by Japanese input method
   * menus.
   */
  kMenuAttrUsePencilGlyph       = (1 << 3),

  /*
   * The menu title is not drawn in the menubar, even when the menu is
   * inserted in the menubar. Useful for adding command keys that don't
   * correspond to a visible menu item; menu items with the desired
   * command keys can be added to the menu and inserted in the menubar
   * without making the menu visible. This attribute is available in
   * Mac OS X 10.2 and later.
   */
  kMenuAttrHidden               = (1 << 4),

  /*
   * If menu item separators are present at the beginning or end of the
   * menu, or if multiple contiguous separators are present, the extra
   * separator items are marked as hidden to avoid extra blank space in
   * the menu. The menu is examined for extra separators whenever the
   * menu size is recalculated. This attribute is available in Mac OS X
   * 10.3 and later.
   */
  kMenuAttrCondenseSeparators   = (1 << 5),

  /*
   * Disables automatic caching of the menu image by the Menu Manager.
   * Automatic caching is provided for all menus that use an HIView to
   * draw their content. Setting this attribute will prevent the Menu
   * Manager from caching the menu image; instead, the menu will be
   * drawn using the standard HIView drawing mechanism each time that
   * it is displayed. This attribute is available in Mac OS X 10.3 and
   * later.
   */
  kMenuAttrDoNotCacheImage      = (1 << 6),

  /*
   * Disables substitution of command keys from the
   * NSUserKeyEquivalents dictionary. By default, all menu items are
   * checked for a match in the dictionary. Note that this attribute,
   * to be effective, should be added at the time that the menu is
   * created; once the menu has been searched for user command keys
   * (which occurs in CalcMenuSize, in GetItemCmd and
   * GetMenuItemCommandKey, and before command key matching), the
   * original command keys are replaced by the user command keys and
   * cannot be retrieved. For this reason, it is also not useful to
   * clear this attribute; the original command keys cannot be
   * restored. This attribute is available in Mac OS X 10.3 and later.
   */
  kMenuAttrDoNotUseUserCommandKeys = (1 << 7)
};



/*
 *  MenuItemAttributes
 *  
 *  Summary:
 *    Menu item attributes control behavior of individual menu items.
 *    They are used with the Get/ChangeMenuItemAttributes APIs.
 */
typedef UInt32 MenuItemAttributes;
enum {

  /*
   * This item is disabled.
   */
  kMenuItemAttrDisabled         = (1 << 0),

  /*
   * This item's icon is disabled.
   */
  kMenuItemAttrIconDisabled     = (1 << 1),

  /*
   * Allows the parent item of a submenu to be selectable.
   */
  kMenuItemAttrSubmenuParentChoosable = (1 << 2),

  /*
   * This item changes dynamically based on modifier key state.
   */
  kMenuItemAttrDynamic          = (1 << 3),

  /*
   * This item is not part of the same dynamic group as the previous
   * item.
   */
  kMenuItemAttrNotPreviousAlternate = (1 << 4),

  /*
   * This item is not drawn when the menu is displayed. It is also not
   * included in command key matching, unless the item also has either
   * the Dynamic or IncludeInCmdKeyMatching attributes.
   */
  kMenuItemAttrHidden           = (1 << 5),

  /*
   * This item is a separator; the text of the item is ignored.
   */
  kMenuItemAttrSeparator        = (1 << 6),

  /*
   * This item is a menu section header; it is disabled and
   * unselectable.
   */
  kMenuItemAttrSectionHeader    = (1 << 7),

  /*
   * Metacharacters in the text of this item (such as the dash) are
   * ignored.
   */
  kMenuItemAttrIgnoreMeta       = (1 << 8),

  /*
   * This item is recognized by IsMenuKeyEvent when it is passed an
   * auto-repeat keyboard event.
   */
  kMenuItemAttrAutoRepeat       = (1 << 9),

  /*
   * When MenuEvent and IsMenuKeyEvent compare this item's keyboard
   * equivalent against a keyboard event, they use the item's virtual
   * keycode equivalent rather than its character code equivalent.
   */
  kMenuItemAttrUseVirtualKey    = (1 << 10),

  /*
   * This item is drawn in a customized fashion by the application.
   * Causes custom menu item drawing Carbon events to be sent. This
   * attribute is available in CarbonLib 1.4 and Mac OS X 10.1, and
   * later.
   */
  kMenuItemAttrCustomDraw       = (1 << 11),

  /*
   * This item is examined during command key matching by MenuKey,
   * MenuEvent, and IsMenuKeyEvent. Normally, visible menu items are
   * included in command key matching, but hidden menu items are
   * excluded (unless the item also has the Dynamic menu item
   * attribute). The IncludeInCmdKeyMatching attribute can be used to
   * force a hidden, non-dynamic menu item to be included in command
   * key matching when it normally wouldn't. This attribute is
   * available in CarbonLib 1.6 and Mac OS X 10.2 and later.
   */
  kMenuItemAttrIncludeInCmdKeyMatching = (1 << 12),

  /*
   * This item is automatically disabled if, when
   * kEventCommandUpdateStatus is sent for this item, no handler is
   * installed or all handlers return eventNotHandledErr. A return
   * value from any handler of any value other than eventNotHandledErr
   * will prevent automatic disabling. This attribute is useful for
   * applications that use kEventCommandUpdateStatus events for all
   * menu item enabling; previously, an application would need to
   * install UpdateStatus handlers on its application target to disable
   * all items in the application that were unnecessary when no
   * document windows were open. By setting this attribute, all menu
   * items will be disabled automatically unless specifically enabled
   * by an UpdateStatus handler on a window, control, or application
   * target. This attribute is available in Mac OS X 10.3 and later.
   */
  kMenuItemAttrAutoDisable      = (1 << 13),

  /*
   * During command key matching, the Menu Manager uses a cache of the
   * available command keys to locate the menu item that matches an
   * event. Before returning this item, the Menu Manager sends a
   * kEventMenuEnableItems event to the menu containing the item, and a
   * kEventCommandUpdateStatus event to each item in the menu, so that
   * the item can be properly enabled or disabled. For some
   * applications, updating the item status for each item in the menu
   * is quite expensive, and also unnecessary since only a single item
   * actually needs to be updated. Setting this attribute indicates to
   * the Menu Manager that it only needs to send a
   * kEventCommandUpdateStatus event to this menu item before returning
   * it from command key matching; kEventMenuEnableItems will not be
   * sent to the menu, and no other menu item will receive
   * kEventCommandUpdateStatus. This attribute is available in Mac OS X
   * 10.3 and later.
   */
  kMenuItemAttrUpdateSingleItem = (1 << 14)
};


/*
 *  MenuTrackingMode
 *  
 *  Summary:
 *    A menu tracking mode constant is part of the
 *    kEventMenuBeginTracking and kEventMenuChangeTrackingMode Carbon
 *    events. It indicates whether menus are being tracked using the
 *    mouse or keyboard.
 */
typedef UInt32 MenuTrackingMode;
enum {

  /*
   * Menus are being tracked using the mouse.
   */
  kMenuTrackingModeMouse        = 1,

  /*
   * Menus are being tracked using the keyboard.
   */
  kMenuTrackingModeKeyboard     = 2
};


/*
 *  MenuEventOptions
 *  
 *  Summary:
 *    Menu event options control how the menus are searched for an item
 *    matching a particular keyboard event. They are used with the
 *    IsMenuKeyEvent API.
 */
typedef UInt32 MenuEventOptions;
enum {

  /*
   * Disabled items are examined for a match.
   */
  kMenuEventIncludeDisabledItems = 0x0001,

  /*
   * Don't hilite the menu title if a match is found.
   */
  kMenuEventQueryOnly           = 0x0002,

  /*
   * Don't look for a match in submenus of the starting menu.
   */
  kMenuEventDontCheckSubmenus   = 0x0004
};

/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Types                                                                        */
/*——————————————————————————————————————————————————————————————————————————————————————*/
typedef SInt16                          MenuID;
typedef UInt16                          MenuItemIndex;
typedef OSType                          MenuCommand;
typedef struct OpaqueMenuRef*           MenuRef;
/* MenuHandle is old name for MenuRef*/
typedef MenuRef                         MenuHandle;

/*
   A MenuBarHandle is a handle to a MenuBarHeader. An instance of this structure is returned
   by the GetMenuBar and GetNewMBar APIs. It is typedef'd to a plain Handle to retain
   source compatibility with previous versions of this header file.
*/
typedef Handle                          MenuBarHandle;

/*
 *  MenuBarHeader
 *  
 *  Summary:
 *    This structure is contained in a MenuBarHandle. It contains a
 *    list of the non-hierarchical menus that have been inserted into
 *    the menubar.
 *  
 *  Discussion:
 *    The MenuBarHandle is a dynamically sized object which cannot be
 *    directly expressed as a C or Pascal structure. First is the
 *    MenuBarHeader structure, followed by a dynamically sized array of
 *    MenuBarMenus, one for each menu. This array is followed by the
 *    HMenuBarHeader, followed by another dynamically sized array of
 *    HMenuBarMenus, one for each hierarchical menu.
 */
struct MenuBarHeader {

  /*
   * Offset in bytes from the start of the header to the last menu in
   * the array of MenuBarMenus.
   */
  UInt16              lastMenu;

  /*
   * Global coordinate of the right edge of the rightmost menu; unused
   * in a MenuBarHandle returned by GetMenuBar or GetNewMBar.
   */
  SInt16              lastRight;

  /*
   * The MBDF resource ID; unused in a MenuBarHandle returned by
   * GetMenuBar or GetNewMBar.
   */
  SInt16              mbResID;
};
typedef struct MenuBarHeader            MenuBarHeader;

/*
 *  HMenuBarHeader
 *  
 *  Summary:
 *    This structure is contained in a MenuBarHandle. It contains a
 *    list of the hierarchical menus that have been inserted into the
 *    menubar with InsertMenu( menu, -1 ).
 *  
 *  Discussion:
 *    The hierarchical portion of the menubar follows the
 *    non-hierarchical portion in a menubar handle. The hierarchical
 *    portion begins with the HMenuBarHeader structure, followed by a
 *    dynamically sized array of HMenuBarMenus.
 */
struct HMenuBarHeader {

  /*
   * Offset in bytes from the start of the header to the last menu in
   * the array of HMenuBarMenus.
   */
  UInt16              lastHMenu;

  /*
   * Saved bits behind the hilited menu title; unused in a
   * MenuBarHandle returned by GetMenuBar or GetNewMBar.
   */
  PixMapHandle        menuTitleBits;
};
typedef struct HMenuBarHeader           HMenuBarHeader;

/*
 *  MenuBarMenu
 *  
 *  Summary:
 *    This structure contains a single menu in the menubar. It is an
 *    element in an array in the MenuBarHeader data strucuture.
 */
struct MenuBarMenu {

  /*
   * A menu in the menubar.
   */
  MenuRef             menu;

  /*
   * The global coordinate of the left edge of the menu title; unused
   * in a MenuBarHandle returned by GetMenuBar or GetNewMBar.
   */
  SInt16              menuLeft;
};
typedef struct MenuBarMenu              MenuBarMenu;

/*
 *  HMenuBarMenu
 *  
 *  Summary:
 *    This structure contains a single hierarchical menu in the
 *    menubar. It is an element in an array in the HMenuBarHeader data
 *    strucuture.
 */
struct HMenuBarMenu {

  /*
   * An hierarchical menu in the menubar.
   */
  MenuRef             menu;

  /*
   * This field is currently unused.
   */
  SInt16              reserved;
};
typedef struct HMenuBarMenu             HMenuBarMenu;
#if TARGET_OS_WIN32
/* QuickTime 3.0 */
struct MenuAccessKeyRec {
  short               count;
  long                flags;
  unsigned char       keys[1];
};
typedef struct MenuAccessKeyRec         MenuAccessKeyRec;
typedef MenuAccessKeyRec *              MenuAccessKeyPtr;
typedef MenuAccessKeyPtr *              MenuAccessKeyHandle;
/*
 *  SetMenuItemHotKey()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */


#endif  /* TARGET_OS_WIN32 */


/*
 *  MenuTrackingData
 *  
 *  Summary:
 *    The MenuTrackingData structure contains information about a menu
 *    currently being displayed. It is used with the
 *    GetMenuTrackingData API.
 */
struct MenuTrackingData {
  MenuRef             menu;
  MenuItemIndex       itemSelected;
  MenuItemIndex       itemUnderMouse;
  Rect                itemRect;
  SInt32              virtualMenuTop;
  SInt32              virtualMenuBottom;
};
typedef struct MenuTrackingData         MenuTrackingData;
typedef MenuTrackingData *              MenuTrackingDataPtr;

/*
 *  Summary:
 *    A MenuItemDataFlags value indicates which fields of a
 *    MenuItemDataRec structure should be used by the
 *    Copy/SetMenuItemData APIs. All MenuItemDataFlags may be used when
 *    getting or setting the contents of a menu item; some may also be
 *    used when getting or setting information about the menu itself,
 *    if the item index given to Copy/SetMenuItemData is 0.
 */
enum {

  /*
   * Set or return the Str255 text of a menu using the
   * MenuItemDataRec.text field. If getting the text, the text field
   * must be initialized with a pointer to a Str255 variable before
   * calling CopyMenuItemData. If both kMenuItemDataText and
   * kMenuItemCFString are set on entry to CopyMenuItemData, the API
   * will determine whether the menu text was most recently set using a
   * Str255 or CFString, and return only that text format; the flags
   * value for the other format will be cleared. Valid for both menu
   * items and the menu title (if item number is 0). 
   * 
   * Note that this option is not supported in the 64-bit HIToolbox API.
   */
  kMenuItemDataText             = (1 << 0),

  /*
   * Set or return the mark character of a menu item using the
   * MenuItemDataRec.mark field. Valid only for menu items.
   */
  kMenuItemDataMark             = (1 << 1),

  /*
   * Set or return the command key of a menu item using the
   * MenuItemDataRec.cmdKey field. Valid only for menu items.
   */
  kMenuItemDataCmdKey           = (1 << 2),

  /*
   * Set or return the command key glyph of a menu item using the
   * MenuItemDataRec.cmdKeyGlyph field. Valid only for menu items.
   */
  kMenuItemDataCmdKeyGlyph      = (1 << 3),

  /*
   * Set or return the command key modifiers of a menu item using the
   * MenuItemDataRec.cmdKeyModifiers field. Valid only for menu items.
   */
  kMenuItemDataCmdKeyModifiers  = (1 << 4),

  /*
   * Set or return the QuickDraw text style of a menu item using the
   * MenuItemDataRec.style field. Valid only for menu items.
   */
  kMenuItemDataStyle            = (1 << 5),

  /*
   * Set or return the enable state of a menu using the
   * MenuItemDataRec.enabled field. Valid for both menu items and the
   * menu itself (if item number is 0).
   */
  kMenuItemDataEnabled          = (1 << 6),

  /*
   * Set or return the enable state of a menu item icon using the
   * MenuItemDataRec.iconEnabled field. Valid only for menu items.
   */
  kMenuItemDataIconEnabled      = (1 << 7),

  /*
   * Set or return the icon resource ID of a menu item using the
   * MenuItemDataRec.iconID field. Valid only for menu items. 
   * 
   * Note that this option is not supported in the 64-bit HIToolbox API.
   */
  kMenuItemDataIconID           = (1 << 8),

  /*
   * Set or return the icon handle of a menu item using the
   * MenuItemDataRec.iconType and MenuItemDataRec.iconHandle fields.
   * Both fields must be initialized if setting the icon handle; both
   * fields will be returned when getting the handle. The iconType
   * field should contain one of the constants kMenuIconType,
   * kMenuShrinkIconType, kMenuSmallIconType, kMenuColorIconType,
   * kMenuIconSuiteType, kMenuIconRefType, kMenuCGImageRefType,
   * kMenuSystemIconSelectorType, or kMenuIconResourceType. An icon
   * handle may be a handle to an ICON resource, a SICN resource, a
   * cicn resource, an IconSuite, an IconRef, a CGImageRef, an OSType,
   * or a CFStringRef. Valid only for menu items. When used with
   * CopyMenuItemData, the caller does not need to release the returned
   * icon handle.
   */
  kMenuItemDataIconHandle       = (1 << 9),

  /*
   * Set or return the command ID of a menu item using the
   * MenuItemDataRec.cmdID field. Valid only for menu items.
   */
  kMenuItemDataCommandID        = (1 << 10),

  /*
   * Set or return the text encoding of a menu item using the
   * MenuItemDataRec.encoding field. Valid only for menu items.
   * 
   * 
   * Note that this option is not supported in the 64-bit HIToolbox API.
   */
  kMenuItemDataTextEncoding     = (1 << 11),

  /*
   * Set or return the menu ID of a item's submenu using the
   * MenuItemDataRec.submenuID field. Valid only for menu items.
   */
  kMenuItemDataSubmenuID        = (1 << 12),

  /*
   * Set or return the menu handle of an item's submenu using the
   * MenuItemDataRec.submenuHandle field. Valid only for menu items.
   * When used with CopyMenuItemData, the caller does not need to
   * release the returned MenuRef.
   */
  kMenuItemDataSubmenuHandle    = (1 << 13),

  /*
   * Set or return the QuickDraw font ID of a menu item using the
   * MenuItemDataRec.fontID field. Valid only for menu items.
   */
  kMenuItemDataFontID           = (1 << 14),

  /*
   * Set or return the refcon of a menu using the
   * MenuItemDataRec.refcon field. Valid for both menu items and the
   * menu itself (if item number is 0).
   */
  kMenuItemDataRefcon           = (1 << 15),

  /*
   * Set or return the attributes of a menu using the
   * MenuItemDataRec.attr field. Valid for both menu items, in which
   * case the attr field should contain values from the
   * MenuItemAttributes enumeration, and for the menu itself (if item
   * number is 0), in which case the attr field should contain values
   * from the MenuAttributes enumeration.
   */
  kMenuItemDataAttributes       = (1 << 16),

  /*
   * Set or return the CFString text of a menu using the
   * MenuItemDataRec.cfText field. If setting the CFString text, the
   * Menu Manager increments the refcount of the text; the caller may
   * safely release the text after setting it. If getting the CFString
   * text, the caller receives a copy of the text owned by the Menu
   * Manager; modifications on the text by the caller will have no
   * effect on the text of the menu, and the caller should release the
   * text when finished with it. If both kMenuItemDataText and
   * kMenuItemCFString are set on entry to CopyMenuItemData, the API
   * will determine whether the menu text was most recently set using a
   * Str255 or CFString, and return only that text format; the flags
   * value for the other format will be cleared. Valid for both menu
   * items and the menu title (if item number is 0). When used with
   * CopyMenuItemData, the caller must release the returned CFStringRef.
   */
  kMenuItemDataCFString         = (1 << 17),

  /*
   * Set or return the properties of a menu using the
   * MenuItemDataRec.properties field. If setting the properties, the
   * properties field should contain a collection with the new
   * properties; existing menu properties with the same collection
   * creator and tag will be replaced by the new properties. If getting
   * the properties, the properties field should either be set to NULL
   * or to a valid Collection. If NULL, a new collection is allocated
   * by the CopyMenuItemData and returned in the properties field. If
   * not NULL, the entire contents of the collection are replaced by
   * the properties of the menu. Valid for both menu items and the menu
   * itself (if item number is 0).
   */
  kMenuItemDataProperties       = (1 << 18),

  /*
   * Set or return the item indent level of a menu item using the
   * MenuItemDataRec.indent field. Valid only for menu items.
   */
  kMenuItemDataIndent           = (1 << 19),

  /*
   * Set or return the virtual key code keyboard equivalent of a menu
   * item using the MenuItemDataRec.cmdVirtualKey field. Valid only for
   * menu items. On output, only valid if the item has the
   * kMenuItemAttrUseVirtualKeyCode attribute. Available in Mac OS X
   * and CarbonLib 1.1 and later.
   */
  kMenuItemDataCmdVirtualKey    = (1 << 20),

  /*
   * Set or return the attributed text of a menu item using the
   * MenuItemDataRec.attributedText field. If setting the attributed
   * text, the Menu Manager increments the refcount of the text; the
   * caller may safely release the text after setting it. If getting
   * the attributed text, the caller receives a copy of the text owned
   * by the Menu Manager; modifications on the text by the caller will
   * have no effect on the text of the menu, and the caller should
   * release the text when finished with it. Valid only for menu items.
   * Available in Mac OS X 10.5 and later.
   */
  kMenuItemDataAttributedText   = (1 << 21),

  /*
   * Set or return the CTFontRef of a menu using the
   * MenuItemDataRec.font field. If setting the font, the Menu Manager
   * increments the refcount of the font; the caller may safely release
   * the font after setting it. If getting the font, the caller
   * receives a retained instance of the font owned by the Menu
   * Manager; the caller should release the font when finished with it.
   * Valid for both menu items and the menu title (if item number is
   * 0). Available in Mac OS X 10.5 and later.
   */
  kMenuItemDataFont             = (1 << 22),
  kMenuItemDataAllDataVersionOne = 0x000FFFFF,
  kMenuItemDataAllDataVersionTwo = kMenuItemDataAllDataVersionOne | kMenuItemDataCmdVirtualKey,
  kMenuItemDataAllDataVersionThree = kMenuItemDataAllDataVersionTwo | kMenuItemDataAttributedText | kMenuItemDataFont
};

typedef UInt64                          MenuItemDataFlags;

/*
 *  MenuItemDataRec
 *  
 *  Summary:
 *    The MenuItemDataRec structure is used to get and change aspects
 *    of a menu item. It is used with the Copy/SetMenuItemData APIs.
 *  
 *  Discussion:
 *    When using this structure with Copy/SetMenuItemData, the caller
 *    must first set the whichData field to a combination of
 *    MenuItemDataFlags indicating which specific data should be
 *    retrieved or set. Some fields also require initialization before
 *    calling CopyMenuItemData; see the individual MenuItemDataFlags
 *    documentation for details. When used with CopyMenuItemData, the
 *    whichData field will be updated on exit to indicate which data
 *    fields have actually been returned. If the caller requests data
 *    that does not exist for that menu or menu item, the corresponding
 *    bit in the whichData field will be cleared, and the field in the
 *    MenuItemDataRec for that data will be set to zero.
 */
struct MenuItemDataRec {
  MenuItemDataFlags   whichData;
  StringPtr           text;
  UniChar             mark;
  UniChar             cmdKey;
  UInt32              cmdKeyGlyph;
  UInt32              cmdKeyModifiers;
  Style               style;
  Boolean             enabled;
  Boolean             iconEnabled;
  UInt8               filler1;
  SInt32              iconID;
  UInt32              iconType;
  Handle              iconHandle;
  MenuCommand         cmdID;
  TextEncoding        encoding;
  MenuID              submenuID;
  MenuRef             submenuHandle;
  SInt32              fontID;
  URefCon             refcon;
  OptionBits          attr;
  CFStringRef         cfText;
  Collection          properties;
  UInt32              indent;
  UInt16              cmdVirtualKey;
  CFAttributedStringRef  attributedText;
  CTFontRef           font;
};
typedef struct MenuItemDataRec          MenuItemDataRec;
typedef MenuItemDataRec *               MenuItemDataPtr;
typedef UInt32                          MenuItemID;

/*
 *  MenuDefType
 *  
 *  Summary:
 *    Types of custom menu definitions.
 */
enum {

  /*
   * A custom menu definition using a function pointer based on the
   * pre-Carbon MDEF model. This type of custom menu definition is not
   * supported by 64-bit HIToolbox.
   */
  kMenuDefProcPtr               = 0,

  /*
   * A custom menu definition using an HIView subclass. Available in
   * Mac OS X 10.3 and later.
   */
  kMenuDefClassID               = 1
};

typedef UInt32                          MenuDefType;
#if __LP64__
typedef void *                          MenuDefUPP;
#else

/*
 *  MenuDefProcPtr
 *  
 *  Summary:
 *    Callback function for a custom menu definition.
 */
typedef CALLBACK_API( void , MenuDefProcPtr )(short message, MenuRef theMenu, Rect *menuRect, Point hitPt, short *whichItem);
typedef STACK_UPP_TYPE(MenuDefProcPtr)                          MenuDefUPP;
/*
 *  NewMenuDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern MenuDefUPP
NewMenuDefUPP(MenuDefProcPtr userRoutine)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  DisposeMenuDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeMenuDefUPP(MenuDefUPP userUPP)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  InvokeMenuDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeMenuDefUPP(
  short       message,
  MenuRef     theMenu,
  Rect *      menuRect,
  Point       hitPt,
  short *     whichItem,
  MenuDefUPP  userUPP)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

#if __MACH__
  #ifdef __cplusplus
    inline MenuDefUPP                                           NewMenuDefUPP(MenuDefProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeMenuDefUPP(MenuDefUPP) { }
    inline void                                                 InvokeMenuDefUPP(short message, MenuRef theMenu, Rect * menuRect, Point hitPt, short * whichItem, MenuDefUPP userUPP) { (*userUPP)(message, theMenu, menuRect, hitPt, whichItem); }
  #else
    #define NewMenuDefUPP(userRoutine)                          ((MenuDefUPP)userRoutine)
    #define DisposeMenuDefUPP(userUPP)
    #define InvokeMenuDefUPP(message, theMenu, menuRect, hitPt, whichItem, userUPP) (*userUPP)(message, theMenu, menuRect, hitPt, whichItem)
  #endif
#endif

#endif  /* __LP64__ */


/*
 *  MenuDefSpec
 *  
 *  Summary:
 *    Specifies a custom menu definition.
 */
struct MenuDefSpec {

  /*
   * The type of menu definition: either kMenuDefProcPtr or
   * kMenuDefClassID. kMenuDefClassID may only be used in Mac OS X 10.3
   * and later. On 64-bit HIToolbox, kMenuDefProcPtr is not supported.
   */
  MenuDefType         defType;
  union {
    MenuDefUPP          defProc;
    struct {
      CFStringRef         classID;
      EventRef            initEvent;
    }                       view;
  }                       u;
};
typedef struct MenuDefSpec              MenuDefSpec;
typedef MenuDefSpec *                   MenuDefSpecPtr;
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Manipulation                                                                 */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#if !__LP64__
/*
 *  [Mac]GetMenu()
 *  
 *  Summary:
 *    Creates a menu using the contents of a 'MENU' resource.
 *  
 *  Discussion:
 *    Apple recommends that you use Interface Builder to design your
 *    menus and other user interface components. Interface Builder
 *    stores its output in nib files rather then Resource Manager
 *    resources. Use the CreateMenuFromNib API to load a menu from a
 *    nib file.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    resourceID:
 *      The resource ID of the 'MENU' resource.
 *  
 *  Result:
 *    The newly created MenuRef. In CarbonLib and Mac OS X, a new menu
 *    will be created by each call to the GetMenu API; this is a change
 *    from the classic Mac OS API, in which GetMenu would return an
 *    existing menu if the menu had previously been created from the
 *    same resource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacGetMenu GetMenu
#endif
extern MenuRef 
MacGetMenu(short resourceID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DisposeMenu()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
DisposeMenu(MenuRef theMenu)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuID()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern MenuID 
GetMenuID(MenuRef menu)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuWidth()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern SInt16 
GetMenuWidth(MenuRef menu)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuHeight()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern SInt16 
GetMenuHeight(MenuRef menu)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuDefinition()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuDefinition(
  MenuRef          menu,
  MenuDefSpecPtr   outDefSpec)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuID()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern void 
SetMenuID(
  MenuRef   menu,
  MenuID    menuID)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuWidth()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern void 
SetMenuWidth(
  MenuRef   menu,
  SInt16    width)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuHeight()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern void 
SetMenuHeight(
  MenuRef   menu,
  SInt16    height)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuDefinition()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuDefinition(
  MenuRef              menu,
  const MenuDefSpec *  defSpec)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CalcMenuSize()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
CalcMenuSize(MenuRef theMenu)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CountMenuItems()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.3 and later
 */
extern UInt16 
CountMenuItems(MenuRef theMenu)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/* Routines available in Mac OS 8.5 and later, and on Mac OS 8.1 and later using CarbonLib 1.1 and later*/

/*
 *  GetMenuFont()
 *  
 *  Summary:
 *    Retrieves the QuickDraw font ID and size used to draw the items
 *    in a menu.
 *  
 *  Discussion:
 *    This API will be deprecated in the next major release of Mac OS
 *    X. Use HIMenuCopyFont instead of GetMenuFont.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu whose font to retrieve.
 *    
 *    outFontID:
 *      On exit, contains the menu's default font, or zero if the font
 *      has not been customized.
 *    
 *    outFontSize:
 *      On exit, contains the menu's default font size, or zero if the
 *      font size has not been customized.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
GetMenuFont(
  MenuRef   menu,
  SInt16 *  outFontID,
  UInt16 *  outFontSize)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuFont()
 *  
 *  Summary:
 *    Sets the QuickDraw font ID and size used to draw the items in a
 *    menu.
 *  
 *  Discussion:
 *    This API will be deprecated in the next major release of Mac OS
 *    X. Use HIMenuSetFont instead of SetMenuFont.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu whose font to set.
 *    
 *    inFontID:
 *      The menu's default font, or zero to use the standard font for
 *      menu items.
 *    
 *    inFontSize:
 *      The menu's default font size, or zero to use the standard font
 *      size for menu items.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
SetMenuFont(
  MenuRef   menu,
  SInt16    inFontID,
  UInt16    inFontSize)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuExcludesMarkColumn()
 *  
 *  Summary:
 *    Returns whether the layout of a menu includes or excludes space
 *    for menu item marks.
 *  
 *  Discussion:
 *    Apple recommends that you use the GetMenuAttributes API and check
 *    for the kMenuAttrExcludesMarkColumn attribute instead of using
 *    this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu to examine.
 *  
 *  Result:
 *    True if the menu layout does not include space for menu item
 *    marks, or false if it does include space for marks.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern Boolean 
GetMenuExcludesMarkColumn(MenuRef menu)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuExcludesMarkColumn()
 *  
 *  Summary:
 *    Sets whether the layout of a menu includes or excludes space for
 *    menu item marks.
 *  
 *  Discussion:
 *    Apple recommends that you use the ChangeMenuAttributes API with
 *    the kMenuAttrExcludesMarkColumn attribute instead of using this
 *    API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu to modify.
 *    
 *    excludesMark:
 *      True if the menu layout should not include space for menu item
 *      marks, or false if it should include space for marks.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
SetMenuExcludesMarkColumn(
  MenuRef   menu,
  Boolean   excludesMark)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RegisterMenuDefinition()
 *  
 *  Summary:
 *    Registers or unregisters a binding between a resource ID and a
 *    menu definition function.
 *  
 *  Discussion:
 *    In the classic Mac OS Menu Manager, a 'MENU' resource can contain
 *    an embedded MDEF procID that is used by the Menu Manager as the
 *    resource ID of an 'MDEF' resource to measure and draw the menu.
 *    The 'MDEF' resource is loaded by the Menu Manager when you load
 *    the menu with GetMenu. Since MDEFs can no longer be packaged as
 *    code resources on Carbon, the procID can no longer refer directly
 *    to an MDEF resource. However, using RegisterMenuDefinition you
 *    can instead specify a UniversalProcPtr pointing to code in your
 *    application code fragment.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inResID:
 *      An MDEF proc ID, as used in a 'MENU' resource.
 *    
 *    inDefSpec:
 *      Specifies the MenuDefUPP that should be used for menus with the
 *      given MDEF proc ID. Passing NULL allows you to unregister the
 *      menu definition that had been associated with the given MDEF
 *      proc ID.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
RegisterMenuDefinition(
  SInt16           inResID,
  MenuDefSpecPtr   inDefSpec)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CreateNewMenu()
 *  
 *  Summary:
 *    Creates a new, untitled, empty menu.
 *  
 *  Discussion:
 *    CreateNewMenu is preferred over NewMenu because it allows you to
 *    specify the menu's attributes and it does not require you to
 *    specify a Str255-based menu title. To set the menu title, you can
 *    use either SetMenuTitle or SetMenuTitleWithCFString.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenuID:
 *      The menu ID to use for the new menu. Zero is a valid menu ID in
 *      Carbon.
 *    
 *    inMenuAttributes:
 *      The menu attributes to use for the new menu.
 *    
 *    outMenuRef:
 *      On exit, contains the new menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CreateNewMenu(
  MenuID           inMenuID,
  MenuAttributes   inMenuAttributes,
  MenuRef *        outMenuRef)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CreateCustomMenu()
 *  
 *  Summary:
 *    Creates a new, untitled, empty menu using a custom menu
 *    definition function.
 *  
 *  Discussion:
 *    Similar to CreateNewMenu, but also allows you to specify a custom
 *    menu definition function.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inDefSpec:
 *      Specifies a custom menu definition function. defSpec->defType
 *      must be kMenuDefProcPtr or, on Mac OS X 10.3 and later,
 *      kMenuDefClassID.
 *    
 *    inMenuID:
 *      The menu ID to use for the new menu.
 *    
 *    inMenuAttributes:
 *      The menu attributes to use for the new menu.
 *    
 *    outMenuRef:
 *      On exit, contains the new menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CreateCustomMenu(
  const MenuDefSpec *  inDefSpec,
  MenuID               inMenuID,
  MenuAttributes       inMenuAttributes,
  MenuRef *            outMenuRef)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsValidMenu()
 *  
 *  Summary:
 *    Determines if a menu is valid.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu to check for validity.
 *  
 *  Result:
 *    Indicates whether the menu is valid.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsValidMenu(MenuRef inMenu)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DuplicateMenu()
 *  
 *  Summary:
 *    Creates a new menu that is a copy of another menu.
 *  
 *  Discussion:
 *    Unlike RetainMenu, DuplicateMenu creates an entirely new menu
 *    that is an exact copy of the original menu. The MDEF for the new
 *    menu will receive an init message after the menu has been fully
 *    created.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inSourceMenu:
 *      The menu to duplicate.
 *    
 *    outMenu:
 *      On exit, a copy of the source menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
DuplicateMenu(
  MenuRef    inSourceMenu,
  MenuRef *  outMenu)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CopyMenuTitleAsCFString()
 *  
 *  Summary:
 *    Returns a CFString containing the title of a menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose title to return.
 *    
 *    outString:
 *      On exit, a CFString containing the menu's title. This string
 *      must be released by the caller.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CopyMenuTitleAsCFString(
  MenuRef        inMenu,
  CFStringRef *  outString)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuTitleWithCFString()
 *  
 *  Summary:
 *    Sets the title of a menu to the text contained in a CFString.
 *  
 *  Discussion:
 *    The Menu Manager will either make its own copy or just increment
 *    the refcount of the CFString before returning from
 *    SetMenuTitleWithCFString, depending on whether the string is
 *    mutable or immutable. If the string is mutable, modifying the
 *    string after calling SetMenuTitleWithCFString will have no effect
 *    on the menu's actual title. The caller may release the string
 *    after calling SetMenuTitleWithCFString.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose title to set.
 *    
 *    inString:
 *      The string containing the new menu title text.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuTitleWithCFString(
  MenuRef       inMenu,
  CFStringRef   inString)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuTitleIcon()
 *  
 *  Summary:
 *    Sets the title of a menu to be an icon.
 *  
 *  Discussion:
 *    The Menu Manager takes ownership of the supplied icon after this
 *    call. When a menu with an title icon is disposed, the Menu
 *    Manager will dispose the icon also; the Menu Manager will also
 *    dispose of the current title icon when a new text or icon title
 *    is supplied for a menu. If an IconRef or CGImageRef is specified,
 *    the Menu Manager will increment its refcount, so you may freely
 *    release your reference to the icon or image without invalidating
 *    the Menu Manager's copy. The menubar will be invalidated by this
 *    call, and redrawn at the next opportunity.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose title to set.
 *    
 *    inType:
 *      The type of icon being used to specify the icon title; use
 *      kMenuNoIcon to remove the icon from the menu title. In Mac OS X
 *      10.2 and earlier, the supported types are kMenuIconSuiteType
 *      and kMenuIconRefType; Mac OS X 10.3 also supports
 *      kMenuCGImageRefType.
 *    
 *    inIcon:
 *      The icon; must be NULL if inType is kMenuNoIcon. The supported
 *      icon formats are IconSuiteRef, IconRef, and in Mac OS X 10.3
 *      and later, CGImageRef.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuTitleIcon(
  MenuRef   inMenu,
  UInt32    inType,
  void *    inIcon)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuTitleIcon()
 *  
 *  Summary:
 *    Retrieves the icon, if any, being used as the title of a menu.
 *  
 *  Discussion:
 *    This API does not increment a refcount on the returned icon. The
 *    caller should not release the icon.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose icon title to retrieve.
 *    
 *    outType:
 *      On exit, contains the type of icon being used as the title of
 *      the menu. Contains kMenuNoIcon if the menu does not have an
 *      icon title.
 *    
 *    outIcon:
 *      On exit, contains the IconSuiteRef, IconRef, or CGImageRef
 *      being used as the title of the menu, or NULL if the menu does
 *      not have an icon title. May be NULL.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuTitleIcon(
  MenuRef   inMenu,
  UInt32 *  outType,       /* can be NULL */
  void **   outIcon)       /* can be NULL */                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  InvalidateMenuSize()
 *  
 *  Summary:
 *    Invalidates the menu size so that it will be recalculated when
 *    next displayed.
 *  
 *  Discussion:
 *    The pre-Carbon technique for invalidating the menu size was to
 *    set the width and height to -1. Although this technique still
 *    works, for best compatibility it's preferable to use the
 *    InvalidateMenuSize API so that the Menu Manager has explicit
 *    notification that the menu is invalid.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose size to invalidate.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
InvalidateMenuSize(MenuRef inMenu)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsMenuSizeInvalid()
 *  
 *  Summary:
 *    Determines if a menu's size is invalid and should be recalculated.
 *  
 *  Discussion:
 *    The pre-Carbon technique for determining if a menu's size is
 *    invalid was to check if the width or height was -1. This
 *    technique is not always reliable on Carbon due to implementation
 *    changes in the Menu Manager. You should now use IsMenuSizeInvalid
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose size to examine.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsMenuSizeInvalid(MenuRef inMenu)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIMenuGetContentView()
 *  
 *  Summary:
 *    Returns the HIViewRef that will be used to draw menu content for
 *    this menu, if any.
 *  
 *  Discussion:
 *    If the content view has not yet been created, the Menu Manager
 *    will create the content view using the view class ID and
 *    initialization event associated with the menu. Note that the menu
 *    content view is not the same as the window content view; the menu
 *    content view is embedded inside the window content view. If the
 *    menu uses an MDEF instead of an HIView to draw its content, noErr
 *    is returned but the output HIViewRef is set to NULL.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu.
 *    
 *    inMenuType:
 *      The type of menu for which the menu content view should be
 *      returned. The same MenuRef may have multiple content views,
 *      depending on the menu type being displayed.
 *    
 *    outView:
 *      On exit, contains the view. May be set to NULL if the menu does
 *      not use an HIView to draw its content. The caller should not
 *      release this view.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuGetContentView(
  MenuRef         inMenu,
  ThemeMenuType   inMenuType,
  HIViewRef *     outView)                                    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;


/*
 *  HIMenuSetFont()
 *  
 *  Summary:
 *    Sets the font to be used to draw a menu or a menu item.
 *  
 *  Discussion:
 *    Pass zero for the inItem parameter to set the default font for
 *    all of the items in a menu. Pass a non-zero value for the inItem
 *    parameter to set a font for a specific item; this overrides the
 *    default font for the menu. If a font is set for an entire menu,
 *    it will also apply to all submenus of the menu. Setting a font
 *    for a specific item does not cause that font to apply to the
 *    item's submenu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose font to set.
 *    
 *    inItem:
 *      The item whose font to set, or zero to customze the font for
 *      the entire menu.
 *    
 *    inFont:
 *      The font to use for the specified menu or item. May be NULL to
 *      remove the menu or item's current custom font. The font will be
 *      retained by the Menu Manager and released when the menu or item
 *      is destroyed, or when the font for the menu or item is changed
 *      to a different value.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuSetFont(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  CTFontRef       inFont)       /* can be NULL */             AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIMenuCopyFont()
 *  
 *  Summary:
 *    Retrieves the custom font that is used to draw a menu or a menu
 *    item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose font to retrieve.
 *    
 *    inItem:
 *      The item whose font to retrieve, or zero to retrieve the font
 *      for the entire menu.
 *    
 *    outFont:
 *      On exit, contains the font used for the specified menu or item.
 *      If the menu or item does not have a custom font, the resulting
 *      CTFontRef is set to NULL. The caller must release the
 *      CTFontRef, if it is non-NULL.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuCopyFont(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  CTFontRef *     outFont)                                    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Item Insertion                                                               */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  DeleteMenuItem()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
DeleteMenuItem(
  MenuRef         theMenu,
  MenuItemIndex   item)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  CopyMenuItems()
 *  
 *  Summary:
 *    Copies menu items from one menu to another.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inSourceMenu:
 *      The menu from which to copy items.
 *    
 *    inFirstItem:
 *      The first item to copy.
 *    
 *    inNumItems:
 *      The number of items to copy.
 *    
 *    inDestMenu:
 *      The menu to which to copy items.
 *    
 *    inInsertAfter:
 *      The menu item in the destination menu after which to insert the
 *      copied items. Pass 0 to insert the items at the beginning of
 *      the menu. This value of this parameter must not exceed the
 *      number of items in the destination menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CopyMenuItems(
  MenuRef         inSourceMenu,
  MenuItemIndex   inFirstItem,
  ItemCount       inNumItems,
  MenuRef         inDestMenu,
  MenuItemIndex   inInsertAfter)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DeleteMenuItems()
 *  
 *  Summary:
 *    Deletes multiple menu items.
 *  
 *  Discussion:
 *    This API is more efficient than calling DeleteMenuItem multiple
 *    times.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu from which to delete items.
 *    
 *    inFirstItem:
 *      The first item to delete.
 *    
 *    inNumItems:
 *      The number of items to delete.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
DeleteMenuItems(
  MenuRef         inMenu,
  MenuItemIndex   inFirstItem,
  ItemCount       inNumItems)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  AppendMenuItemTextWithCFString()
 *  
 *  Summary:
 *    Appends a new menu item with text from a CFString.
 *  
 *  Discussion:
 *    The Menu Manager will either make its own copy or just increment
 *    the refcount of the CFString before returning from
 *    AppendMenuItemWithTextCFString, depending on whether the string
 *    is mutable or immutable. If the string is mutable, modifying the
 *    string after calling AppendMenuItemTextWithCFString will have no
 *    effect on the menu item's actual text. The caller may release the
 *    string after calling AppendMenuItemTextWithCFString.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu to which to append the new item.
 *    
 *    inString:
 *      The text of the new item.
 *    
 *    inAttributes:
 *      The attributes of the new item.
 *    
 *    inCommandID:
 *      The command ID of the new item.
 *    
 *    outNewItem:
 *      On exit, the index of the new item. May be NULL if the caller
 *      does not need this information.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
AppendMenuItemTextWithCFString(
  MenuRef              inMenu,
  CFStringRef          inString,
  MenuItemAttributes   inAttributes,
  MenuCommand          inCommandID,
  MenuItemIndex *      outNewItem)         /* can be NULL */  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  InsertMenuItemTextWithCFString()
 *  
 *  Summary:
 *    Inserts a new menu item with text from a CFString.
 *  
 *  Discussion:
 *    The Menu Manager will either make its own copy or just increment
 *    the refcount of the CFString before returning from
 *    InsertMenuItemWithCFString, depending on whether the string is
 *    mutable or immutable. If the string is mutable, modifying the
 *    string after calling InsertMenuItemWithCFString will have no
 *    effect on the menu item's actual text. The caller may release the
 *    string after calling InsertMenuItemWithCFString.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to insert the new item.
 *    
 *    inString:
 *      The text of the new item.
 *    
 *    inAfterItem:
 *      The item after which to insert the new item. Pass 0 to insert
 *      the item at the beginning of the menu. If inAfterItem is
 *      greater than the number of items in the menu, the item is
 *      inserted at the end of the menu.
 *    
 *    inAttributes:
 *      The attributes of the new item.
 *    
 *    inCommandID:
 *      The command ID of the new item.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
InsertMenuItemTextWithCFString(
  MenuRef              inMenu,
  CFStringRef          inString,
  MenuItemIndex        inAfterItem,
  MenuItemAttributes   inAttributes,
  MenuCommand          inCommandID)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Events                                                                       */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIMenuSetSelection()
 *  
 *  Summary:
 *    Sets the selected item in a menu.
 *  
 *  Discussion:
 *    The HIMenuSetSelection API may be called either before opening a
 *    menu, or while a menu is open. If called before opening a menu,
 *    when the menu is next opened, the specified item will be
 *    selected; this case only works for menus that use an HIView to
 *    display menu content, and does not work for MDEF-based menus. If
 *    called while a menu is open, the menu's selection will be changed
 *    to the specified item. Note that changing the selection of an
 *    open menu is not standard UI and may be confusing to the user;
 *    also, changing the selected item does not currently affect the
 *    state of hierarchical submenus of the previously selected or
 *    newly selected item, so Apple recommends that you do not change
 *    the selected state of an item with a hierarchical submenu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose selected item to set.
 *    
 *    inMenuType:
 *      The type of menu for which to set the selected item. Ignored
 *      unless the menu is already open; use GetMenuType to determine
 *      the menu's current type.
 *    
 *    inItem:
 *      The menu item that should be selected.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuSetSelection(
  MenuRef         inMenu,
  ThemeMenuType   inMenuType,
  MenuItemIndex   inItem)                                     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  MenuSelect()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern SInt32 
MenuSelect(Point startPt)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  PopUpMenuSelect()
 *  
 *  Summary:
 *    Displays a pop-up menu at a specified location.
 *  
 *  Discussion:
 *    In Mac OS 9 and earlier, PopUpMenuSelect requires that the menu
 *    be inserted into the menubar using InsertMenu( menuRef,
 *    kInsertHierarchicalMenu ). CarbonLib 1.1 and later, and Mac OS X,
 *    do not have this requirement; a menu can be displayed by
 *    PopUpMenuSelect even if it is not inserted in the menubar.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu to display.
 *    
 *    top:
 *      The vertical position, in global coordinates, of the top left
 *      corner of the selected item when the menu is opened.
 *    
 *    left:
 *      The horizontal position, in global coordinates, of the top left
 *      corner of the selected item when the menu is opened.
 *    
 *    popUpItem:
 *      The item that should be positioned at the global point
 *      specified by the top and left parameters. May be zero, in which
 *      case item one is positioned at the specified global point.
 *  
 *  Result:
 *    A 32-bit value whose high 16-bit word is the menu ID and whose
 *    low 16-bit word is the index of the menu item that was selected,
 *    or zero if no item was selected.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern SInt32 
PopUpMenuSelect(
  MenuRef         menu,
  short           top,
  short           left,
  MenuItemIndex   popUpItem)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  MenuChoice()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern SInt32 
MenuChoice(void)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  MenuEvent()
 *  
 *  Summary:
 *    Determines whether an event should result in the selection of a
 *    menu item.
 *  
 *  Discussion:
 *    Apple recommends that you use the IsMenuKeyEvent API rather than
 *    this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inEvent:
 *      The event to examine. Typically, this is a keyboard event.
 *  
 *  Result:
 *    If the keyboard event corresponds to a menu item's keyboard
 *    equivalent, then the result is a 32-bit value whose high 16-bit
 *    word is the menu ID and whose low 16-bit word is the index of the
 *    menu item that was found. Zero is returned if no item matched the
 *    event.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern UInt32 
MenuEvent(const EventRecord * inEvent)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsMenuKeyEvent()
 *  
 *  Summary:
 *    Determines if an event corresponds to a menu command key.
 *  
 *  Discussion:
 *    By default, IsMenuKeyEvent searches the menus in the current menu
 *    bar and hilites the menu title of the menu containing the
 *    selected item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inStartMenu:
 *      IsMenuKeyEvent searches for matching menu items in this menu
 *      and all of its submenus. May be NULL to search the current menu
 *      bar contents.
 *    
 *    inEvent:
 *      The event to match against. Non-keyboard events are ignored.
 *    
 *    inOptions:
 *      Options controlling how to search. Pass kNilOptions for the
 *      default behavior.
 *    
 *    outMenu:
 *      On exit, the menu containing the matching item. May be NULL.
 *    
 *    outMenuItem:
 *      On exit, the menu item that matched. May be NULL.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsMenuKeyEvent(
  MenuRef            inStartMenu,
  EventRef           inEvent,
  MenuEventOptions   inOptions,
  MenuRef *          outMenu,           /* can be NULL */
  MenuItemIndex *    outMenuItem)       /* can be NULL */     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  InvalidateMenuEnabling()
 *  
 *  Summary:
 *    Causes the menu enable state to be recalculated at the next
 *    convenient opportunity.
 *  
 *  Discussion:
 *    It is common for state changes in an application (for example,
 *    selection of text) to cause a change in the enabling of items in
 *    the application's menu (for example, the Copy menu item might
 *    become enabled). In a Carbon-event-savvy application, menu items
 *    are enabled or disabled in response to an
 *    kEventCommandUpdateStatus event; however, this event is normally
 *    only sent before a command key press or a click in the menubar.
 *    You can request an explicit recalculation of a menu's enable
 *    state with the InvalidateMenuEnabling API. The Carbon Event
 *    Manager will automatically invalidate the enable state of all
 *    top-level menus when a user event is dispatched, the user focus
 *    changes, or the active window changes, so in many cases you will
 *    not need to explicitly invalidate the menu enabling state.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      A menu to re-enable, or NULL if all menus in the root menu
 *      should be re-enabled.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
InvalidateMenuEnabling(MenuRef inMenu)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#endif  /* !__LP64__ */


/*
 *  Summary:
 *    Menu dismissal causation constants
 */
enum {

  /*
   * The menu was dismissed by the selection of a menu item.
   */
  kHIMenuDismissedBySelection   = 1,

  /*
   * The menu was dismissed because the user canceled menu tracking.
   */
  kHIMenuDismissedByUserCancel  = 2,

  /*
   * The menu was dismissed by a mouse-down somewhere that did not
   * result in menu item selection.
   */
  kHIMenuDismissedByMouseDown   = 3,

  /*
   * The menu was dismissed by a mouse-up.
   */
  kHIMenuDismissedByMouseUp     = 4,

  /*
   * The menu was dismissed by a keyboard event.
   */
  kHIMenuDismissedByKeyEvent    = 5,

  /*
   * The menu was dismissed because the current application was no
   * longer frontmost.
   */
  kHIMenuDismissedByAppSwitch   = 6,

  /*
   * The menu was dismissed because menu tracking mode timed out.
   */
  kHIMenuDismissedByTimeout     = 7,

  /*
   * The menu was dismissed by the CancelMenuTracking API.
   */
  kHIMenuDismissedByCancelMenuTracking = 8,

  /*
   * The menu was dismissed because the active window changed.
   */
  kHIMenuDismissedByActivationChange = 9,

  /*
   * The menu was dismissed bcause the user focus window changed, or
   * because keyboard focus was removed from the current process.
   */
  kHIMenuDismissedByFocusChange = 10
};

#if !__LP64__
/*
 *  CancelMenuTracking()
 *  
 *  Summary:
 *    Cancels a menu tracking session.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inRootMenu:
 *      The root menu of the menu tracking session that should be
 *      dismissed. For menubar tracking, use the result of AcquireRoot
 *      menu; for popup menu tracking, use the menu that was passed to
 *      PopUpMenuSelect.
 *    
 *    inImmediate:
 *      Whether the open menus should disappear immediately or fade out.
 *    
 *    inDismissalReason:
 *      Why the menu is being dismissed; this value will be added to
 *      the kEventMenuEndTracking event. On Mac OS X 10.5 and later,
 *      you may pass zero to indicate that
 *      kHIMenuDismissedByCancelMenuTracking should be passed to the
 *      EndTracking event.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.3 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.3 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CancelMenuTracking(
  MenuRef   inRootMenu,
  Boolean   inImmediate,
  UInt32    inDismissalReason)                                AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Bar                                                                          */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  GetMBarHeight()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern short 
GetMBarHeight(void)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  [Mac]DrawMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacDrawMenuBar DrawMenuBar
#endif
extern void 
MacDrawMenuBar(void)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  InvalMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
InvalMenuBar(void)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsMenuBarInvalid()
 *  
 *  Summary:
 *    Determines if the menubar is invalid and should be redrawn.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    rootMenu:
 *      The root menu for the menubar to be examined. Pass NULL to
 *      check the state of the current menubar.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsMenuBarInvalid(MenuRef rootMenu)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HiliteMenu()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
HiliteMenu(MenuID menuID)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetNewMBar()
 *  
 *  Summary:
 *    Creates multiple menus using the contents of a 'MBAR' resource.
 *  
 *  Discussion:
 *    Apple recommends that you use Interface Builder to design your
 *    menus and other user interface components. Interface Builder
 *    stores its output in nib files rather then Resource Manager
 *    resources. Use the CreateMenuBarFromNib API to load a menu from a
 *    nib file.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menuBarID:
 *      The resource ID of the 'MBAR' resource.
 *  
 *  Result:
 *    The newly created menubar handle. Use SetMenuBar to place the
 *    contents of the menubar handle into the menubar. You must release
 *    the menubar handle with DisposeMenuBar when you are done with it.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern MenuBarHandle 
GetNewMBar(short menuBarID)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern MenuBarHandle 
GetMenuBar(void)                                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetMenuBar(MenuBarHandle mbar)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DuplicateMenuBar()
 *  
 *  Summary:
 *    Duplicates a menubar handle.
 *  
 *  Discussion:
 *    This API should be used in Carbon applications when duplicating a
 *    handle returned from GetMenuBar or GetNewMBar. You should not use
 *    Memory Manager APIs (HandToHand, NewHandle, etc) to duplicate
 *    such a handle. This is necessary in Carbon so that the refcounts
 *    of the menus in the menubar handle can be incremented when the
 *    handle is duplicated.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMbar:
 *      The menubar handle to duplicate.
 *    
 *    outMbar:
 *      On exit, contains the new menubar handle.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
DuplicateMenuBar(
  MenuBarHandle    inMbar,
  MenuBarHandle *  outMbar)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DisposeMenuBar()
 *  
 *  Summary:
 *    Releases a menubar handle.
 *  
 *  Discussion:
 *    This API should be used in Carbon applications when releasing a
 *    handle returned from GetMenuBar or GetNewMBar. You should not use
 *    DisposeHandle to release such a handle. This is necessary in
 *    Carbon so that the refcounts of the menus in the menubar handle
 *    can be decremented when the handle is released.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMbar:
 *      The menubar handle to release.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
DisposeMenuBar(MenuBarHandle inMbar)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuHandle()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern MenuRef 
GetMenuHandle(MenuID menuID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#define GetMenuRef GetMenuHandle
/*
 *  [Mac]InsertMenu()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacInsertMenu InsertMenu
#endif
extern void 
MacInsertMenu(
  MenuRef   theMenu,
  MenuID    beforeID)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  [Mac]DeleteMenu()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacDeleteMenu DeleteMenu
#endif
extern void 
MacDeleteMenu(MenuID menuID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ClearMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
ClearMenuBar(void)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  FlashMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
FlashMenuBar(MenuID menuID)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsMenuBarVisible()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern Boolean 
IsMenuBarVisible(void)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ShowMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern void 
ShowMenuBar(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HideMenuBar()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern void 
HideMenuBar(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  AcquireRootMenu()
 *  
 *  Summary:
 *    Get the menu whose contents are displayed in the menubar.
 *  
 *  Discussion:
 *    The refcount of the root menu is incremented by this API. The
 *    caller should release a refcount with ReleaseMenu when it’s done
 *    with the menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern MenuRef 
AcquireRootMenu(void)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetRootMenu()
 *  
 *  Summary:
 *    Sets the menu whose contents are displayed in the menubar.
 *  
 *  Discussion:
 *    The refcount of the root menu is incremented by this API. The
 *    caller may release the menu after calling SetRootMenu.
 *    
 *    A root menu should contain one menu item for each top-level menu
 *    that should be displayed in the menubar. Each menu item should
 *    have a submenu that was installed with
 *    SetMenuItemHierarchicalMenu.
 *    
 *    SetRootMenu also sets the contents of the hierarchical portion of
 *    the menulist (the set of menus that were inserted with
 *    InsertMenu( menu, kInsertHierarchicalMenu). If a menu that was
 *    returned by AcquireRootMenu is passed to SetRootMenu, the
 *    hierarchical menulist is changed to include the menus that were
 *    in the hierarchical menulist when AcquireRootMenu was called. If
 *    a newly created menu is passed to SetRootMenu, the hierarchical
 *    menulist is cleared and has no menus in it.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The new root menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetRootMenu(MenuRef inMenu)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Item Accessors                                                               */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  [Mac]CheckMenuItem()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.3 and later
 */
#if TARGET_OS_MAC
    #define MacCheckMenuItem CheckMenuItem
#endif
extern void 
MacCheckMenuItem(
  MenuRef         theMenu,
  MenuItemIndex   item,
  Boolean         checked)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetItemMark()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetItemMark(
  MenuRef         theMenu,
  MenuItemIndex   item,
  CharParameter   markChar)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetItemMark()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
GetItemMark(
  MenuRef          theMenu,
  MenuItemIndex    item,
  CharParameter *  markChar)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetItemCmd()
 *  
 *  Summary:
 *    Sets a menu item's keyboard equivalent to a specified character
 *    in the application's text encoding.
 *  
 *  Discussion:
 *    Apple recommends that you use the SetMenuItemCommandKey API
 *    instead of this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu whose item to modify.
 *    
 *    item:
 *      The item whose keyboard equivalent to set.
 *    
 *    cmdChar:
 *      A character in the application's text encoding, or zero to
 *      remove the item's keyboard equivalent.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetItemCmd(
  MenuRef         theMenu,
  MenuItemIndex   item,
  CharParameter   cmdChar)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetItemCmd()
 *  
 *  Summary:
 *    Returns a menu item's keyboard equivalent in the application's
 *    text encoding.
 *  
 *  Discussion:
 *    Apple recommends that you use the GetMenuItemCommandKey API
 *    instead of this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu whose item to query.
 *    
 *    item:
 *      The item whose keyboard equivalent to return.
 *    
 *    cmdChar:
 *      On exit, contains the menu item's keyboard equivalent, or zero
 *      if the item has no keyboard equivalent.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
GetItemCmd(
  MenuRef          theMenu,
  MenuItemIndex    item,
  CharParameter *  cmdChar)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetItemStyle()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetItemStyle(
  MenuRef          theMenu,
  MenuItemIndex    item,
  StyleParameter   chStyle)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetItemStyle()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
GetItemStyle(
  MenuRef         theMenu,
  MenuItemIndex   item,
  Style *         chStyle)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemCommandID()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemCommandID(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  MenuCommand     inCommandID)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemCommandID()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemCommandID(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  MenuCommand *   outCommandID)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemModifiers()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemModifiers(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  UInt8           inModifiers)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemModifiers()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemModifiers(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  UInt8 *         outModifiers)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemIconHandle()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemIconHandle(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  UInt8           inIconType,
  Handle          inIconHandle)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemIconHandle()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemIconHandle(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  UInt8 *         outIconType,
  Handle *        outIconHandle)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemFontID()
 *  
 *  Summary:
 *    Sets the QuickDraw font ID used to draw a menu item.
 *  
 *  Discussion:
 *    The font ID specified with this API overrides the font ID
 *    specified with the SetMenuFont API. 
 *    
 *    This API will be deprecated in the next major release of Mac OS
 *    X. Use HIMenuSetFont instead of SetMenuItemFontID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item whose font to set.
 *    
 *    inItem:
 *      The menu item whose font to set.
 *    
 *    inFontID:
 *      The menu item's font, or zero to use the standard font for menu
 *      items.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemFontID(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  SInt16          inFontID)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemFontID()
 *  
 *  Summary:
 *    Retrieves the QuickDraw font ID used to draw a menu item.
 *  
 *  Discussion:
 *    This API will be deprecated in the next major release of Mac OS
 *    X. Use HIMenuCopyFont instead of GetMenuItemFontID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item whose font to retrieve.
 *    
 *    inItem:
 *      The menu item whose font to retrieve.
 *    
 *    outFontID:
 *      On exit, contains the menu item's font, or zero if the font has
 *      not been customized.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemFontID(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  SInt16 *        outFontID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemRefCon()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemRefCon(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  URefCon         inRefCon)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemRefCon()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemRefCon(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  URefCon *       outRefCon)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemKeyGlyph()
 *  
 *  Summary:
 *    Sets the command key glyph code for a menu item.
 *  
 *  Discussion:
 *    A menu item's command key may be customized using a key glyph
 *    code; these codes are the kMenu*Glyph constants documented in
 *    Menus.h. In classic Mac OS, a glyph code is only used for
 *    display; it does not affect command key matching. In Carbon, a
 *    menu item's glyph code is used for command key matching if the
 *    menu item does not have a command key character or virtual
 *    keycode assigned to it. 
 *    
 *    In CarbonLib 1.2 and Mac OS X 10.0 and later, the Menu Manager
 *    will automatically draw the appropriate glyph for a menu item
 *    that has a virtual keycode command key assigned to it; it is not
 *    necessary to set both the virtual keycode and the glyph for an
 *    item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu to change.
 *    
 *    inItem:
 *      The menu item to change.
 *    
 *    inGlyph:
 *      The new glyph code for the item, or zero to remove the item's
 *      glyph code.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemKeyGlyph(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  SInt16          inGlyph)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemKeyGlyph()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemKeyGlyph(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  SInt16 *        outGlyph)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/* Routines available in Mac OS 8.5 and later (supporting enabling/disabling of > 31 items)*/

/*
 *  [Mac]EnableMenuItem()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
#if TARGET_OS_MAC
    #define MacEnableMenuItem EnableMenuItem
#endif
extern void 
MacEnableMenuItem(
  MenuRef         theMenu,
  MenuItemIndex   item)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DisableMenuItem()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern void 
DisableMenuItem(
  MenuRef         theMenu,
  MenuItemIndex   item)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsMenuItemEnabled()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern Boolean 
IsMenuItemEnabled(
  MenuRef         menu,
  MenuItemIndex   item)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  EnableMenuItemIcon()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern void 
EnableMenuItemIcon(
  MenuRef         theMenu,
  MenuItemIndex   item)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DisableMenuItemIcon()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern void 
DisableMenuItemIcon(
  MenuRef         theMenu,
  MenuItemIndex   item)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsMenuItemIconEnabled()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern Boolean 
IsMenuItemIconEnabled(
  MenuRef         menu,
  MenuItemIndex   item)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemHierarchicalMenu()
 *  
 *  Summary:
 *    Attaches a submenu to a menu item.
 *  
 *  Discussion:
 *    Using SetMenuItemHierarchicalMenu, it is possible to directly
 *    specify the submenu for a menu item without specifying its menu
 *    ID. It is not necessary to insert the submenu into the
 *    hierarchical portion of the menubar, and it is not necessary for
 *    the submenu to have a unique menu ID; it is recommended that you
 *    use 0 as the menu ID for the submenu, and identify selections
 *    from the menu by command ID. The Menu Manager will increment the
 *    refcount of the submenu that you specify, and the submenu's
 *    refcount will be decremented automatically when the parent menu
 *    item is deleted or the parent menu is disposed.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The parent menu.
 *    
 *    inItem:
 *      The parent item.
 *    
 *    inHierMenu:
 *      The submenu. You may pass NULL to remove any existing submenu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuItemHierarchicalMenu(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  MenuRef         inHierMenu)       /* can be NULL */         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemHierarchicalMenu()
 *  
 *  Summary:
 *    Returns the submenu attached to a menu item.
 *  
 *  Discussion:
 *    GetMenuItemHierarchicalMenu will return the submenu attached to a
 *    menu item regardless of how the submenu was specified. If the
 *    submenu was specified by menu ID (using SetItemCmd or
 *    SetMenuItemHierarchicalID), GetMenuItemHierarchicalMenu will
 *    return the currently installed menu with that ID, if any. The
 *    only case where GetMenuItemHierarchicalMenu will fail to return
 *    the item's submenu is when the submenu is specified by menu ID,
 *    but the submenu is not currently inserted in the menu bar.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The parent menu.
 *    
 *    inItem:
 *      The parent item.
 *    
 *    outHierMenu:
 *      On exit, the item's submenu, or NULL if it does not have one.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuItemHierarchicalMenu(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  MenuRef *       outHierMenu)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIMenuCopyParents()
 *  
 *  Summary:
 *    Returns the parent menus of a menu.
 *  
 *  Discussion:
 *    A menu may be a submenu of one or more other menus; for example,
 *    a Spelling menu might be a submenu of both an Edit menu contained
 *    in the menubar, and a contextual menu displayed when the user
 *    clicks in a document. HIMenuCopyParents returns an array of
 *    MenuRefs that are the parent menus of the specified menu. If the
 *    menu has only a single parent, the array will have only that
 *    single parent menu in it.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose parent menus to return.
 *    
 *    outParents:
 *      On exit, contains an array of MenuRefs that are parents of the
 *      specified menu. If the menu does not have any parents, the
 *      array on exit will be NULL. If not NULL, the caller is
 *      responsible for releasing the array.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuCopyParents(
  MenuRef       inMenu,
  CFArrayRef *  outParents)                                   AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  CopyMenuItemTextAsCFString()
 *  
 *  Summary:
 *    Returns a CFString containing the text of a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item.
 *    
 *    inItem:
 *      The item whose text to return.
 *    
 *    outString:
 *      On exit, a CFString containing the item's text. This string
 *      must be released by the caller.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CopyMenuItemTextAsCFString(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  CFStringRef *   outString)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemTextWithCFString()
 *  
 *  Summary:
 *    Sets the text of a menu item to the text contained in a CFString.
 *  
 *  Discussion:
 *    The Menu Manager will either make its own copy or just increment
 *    the refcount of the CFString before returning from
 *    SetMenuItemTextWithCFString, depending on whether the string is
 *    mutable or immutable. If the string is mutable, modifying the
 *    string after calling SetMenuItemTextWithCFString will have no
 *    effect on the menu item's actual text. The caller may release the
 *    string after calling SetMenuItemTextWithCFString.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item.
 *    
 *    inItem:
 *      The item whose text to set.
 *    
 *    inString:
 *      The string containing the new menu item text.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuItemTextWithCFString(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  CFStringRef     inString)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  HIMenuSetAttributedItemText()
 *  
 *  Summary:
 *    Sets the attributed text of a menu item.
 *  
 *  Discussion:
 *    A menu item may have two strings attached to it: a regular
 *    CFString and an attributed CFString. The regular string is
 *    modified by the SetMenuItemTextAsCFString API, and the attributed
 *    string is modified using this API. If an attributed string is
 *    provided, it will be used when measuring and drawing the menu
 *    item text. However, the regular string (if provided) is always
 *    used for type-selection; this allows the attributed string to
 *    contain extra characters that should be ignored during
 *    type-selection.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the specified item.
 *    
 *    inItem:
 *      The menu item whose attributed text to set.
 *    
 *    inText:
 *      The new attributed text for the menu item. May be NULL if the
 *      item no longer need attributed text.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuSetAttributedItemText(
  MenuRef                 inMenu,
  MenuItemIndex           inItem,
  CFAttributedStringRef   inText)       /* can be NULL */     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIMenuCopyAttributedItemText()
 *  
 *  Summary:
 *    Retrieves the attributed text of a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the specified item.
 *    
 *    inItem:
 *      The menu item whose attributed text to retrieve.
 *    
 *    outText:
 *      On exit, contains the item's attributed text, or NULL if the
 *      item has no attributed text.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuCopyAttributedItemText(
  MenuRef                  inMenu,
  MenuItemIndex            inItem,
  CFAttributedStringRef *  outText)                           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  GetMenuItemIndent()
 *  
 *  Summary:
 *    Gets the indent level of a menu item.
 *  
 *  Discussion:
 *    The indent level of an item is an amount of extra space added to
 *    the left of the item's icon or checkmark. The level is simply a
 *    number, starting at zero, which the Menu Manager multiplies by a
 *    constant to get the indent in pixels. The default indent level is
 *    zero.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item.
 *    
 *    inItem:
 *      The item whose indent to retrieve.
 *    
 *    outIndent:
 *      On exit, the indent level of the item.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuItemIndent(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  UInt32 *        outIndent)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemIndent()
 *  
 *  Summary:
 *    Sets the indent level of a menu item.
 *  
 *  Discussion:
 *    The indent level of an item is an amount of extra space added to
 *    the left of the item's icon or checkmark. The level is simply a
 *    number, starting at zero, which the Menu Manager multiplies by a
 *    constant to get the indent in pixels. The default indent level is
 *    zero.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item.
 *    
 *    inItem:
 *      The item whose indent to set.
 *    
 *    inIndent:
 *      The new indent level of the item.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuItemIndent(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  UInt32          inIndent)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemCommandKey()
 *  
 *  Summary:
 *    Gets the keyboard equivalent of a menu item.
 *  
 *  Discussion:
 *    A menu item's keyboard equivalent may be either a character code
 *    or a virtual keycode. An item's character code and virtual
 *    keycode are stored separately and may contain different values,
 *    but only one is used by the Menu Manager at any given time. When
 *    requesting a menu item's virtual keycode equivalent, you should
 *    first check that the item is using a virtual keycode by testing
 *    the kMenuItemAttrUseVirtualKey attribute for that item. If this
 *    attribute is not set, the item's virtual keycode is ignored by
 *    the Menu Manager. Note that zero is a valid virtual keycode, so
 *    you cannot test the returned keycode against zero to determine if
 *    the item is using a virtual keycode equivalent. You must test the
 *    kMenuItemAttrUseVirtualKey attribute.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item.
 *    
 *    inItem:
 *      The item whose keyboard equivalent to retrieve.
 *    
 *    inGetVirtualKey:
 *      Indicates whether to retrieve the item's character code or
 *      virtual keycode equivalent.
 *    
 *    outKey:
 *      On exit, the keyboard equivalent of the item.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuItemCommandKey(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  Boolean         inGetVirtualKey,
  UInt16 *        outKey)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemCommandKey()
 *  
 *  Summary:
 *    Sets the keyboard equivalent of a menu item.
 *  
 *  Discussion:
 *    A menu item's keyboard equivalent may be either a character code
 *    or a virtual keycode. The character code is always used to draw
 *    the item's keyboard equivalent in the menu, but either a char
 *    code or a virtual key code may be used for keyboard equivalent
 *    matching by MenuEvent and IsMenuKeyEvent, depending on whether
 *    the kMenuItemAttrUseVirtualKey item attribute is set. If
 *    SetMenuItemCommandKey is used to set the virtual keycode
 *    equivalent for a menu item, it also automatically sets the
 *    kMenuItemAttrUseVirtualKey item attribute. To make the menu item
 *    stop using the virtual keycode equivalent and use the character
 *    code equivalent instead, use ChangeMenuItemAttributes to clear
 *    the kMenuItemAttrUseVirtualKey item attribute.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu containing the item.
 *    
 *    inItem:
 *      The item whose keyboard equivalent to set.
 *    
 *    inSetVirtualKey:
 *      Indicates whether to set the item's character code or virtual
 *      keycode equivalent. If setting a character code, the character
 *      is assumed to be in the application's text encoding.
 *    
 *    inKey:
 *      The item's new character code or virtual keycode equivalent.
 *      Note that the character code is not a Unicode value; rather,
 *      the character code is assumed to be expressed in the
 *      application's text encoding. In Mac OS X 10.3 and later, the
 *      Menu Manager also supports the following metavalues when
 *      inSetVirtualKey is false. When receiving one of these values,
 *      the Menu Manager automatically sets the item's keyboard
 *      equivalent glyph code to an appropriate value using
 *      SetMenuItemKeyGlyph. 
 *      
 *      NSF1FunctionKey..NSF15FunctionKey 
 *      NSHomeFunctionKey 
 *      kEnterCharCode 
 *      kEndCharCode 
 *      NSEndFunctionKey 
 *      kHelpCharCode 
 *      NSHelpFunctionKey 
 *      kBackspaceCharCode 
 *      kTabCharCode 
 *      kLineFeedCharCode 
 *      kReturnCharCode 
 *      kPageUpCharCode 
 *      NSPageUpFunctionKey 
 *      kPageDownCharCode 
 *      NSPageDownFunctionKey 
 *      NSBackTabCharacter 
 *      kEscapeCharCode 
 *      NSClearDisplayFunctionKey 
 *      kLeftArrowCharCode 
 *      NSLeftArrowFunctionKey 
 *      kRightArrowCharCode 
 *      NSRightArrowFunctionKey 
 *      kUpArrowCharCode 
 *      NSUpArrowFunctionKey 
 *      kDownArrowCharCode 
 *      NSDownArrowFunctionKey 
 *      kDeleteCharCode 
 *      
 *      In Mac OS X 10.4 and later, the Menu Manager also supports
 *      these values: 
 *      
 *      0x2190..0x2193 (left, up, right, and down-arrow)
 *       kSpaceCharCode 
 *      
 *      In Mac OS X 10.6 and later, the Menu Manager also supports
 *      these values: 
 *      NSF16FunctionKey..NSF19FunctionKey, NSDeleteFunctionKey
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuItemCommandKey(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  Boolean         inSetVirtualKey,
  UInt16          inKey)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Menu item views                                                                    */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  HIMenuSetItemViewClass()
 *  
 *  Summary:
 *    Sets the HIObject class ID and initialization event that will be
 *    used to create a custom HIView for a menu item.
 *  
 *  Discussion:
 *    When a menu item has a custom HIObject class ID associated with
 *    it, the standard menu view automatically creates an HIView using
 *    that class ID as necessary and inserts the view as a subview of
 *    the standard menu view. The item view is send a
 *    kEventControlGetOptimalBounds event to request that it calculate
 *    its size, and if this size is larger than the size that the item
 *    would normally have, it is used instead. The view's frame is
 *    automatically positioned to match the frame of the item. 
 *    
 *    An item view should be an ordinary subclass of HIView. The item
 *    view is responsible for entirely replacing the standard menu item
 *    content; the standard content will not be drawn. When created, an
 *    item view's kEventHIObjectInitialize event will have two extra
 *    parameters, kEventParamMenuRef and kEventParamMenuItemIndex, if
 *    the view is intended for use in a menu. Note that a view should
 *    not cache the item index from the Init event, because the item
 *    index can change over time if menu items are inserted or deleted;
 *    instead, a view can determine its current menu item index at any
 *    time (except during Construct or Init handlers) by calling
 *    HIMenuItemViewGetEnclosingMenuItem. 
 *    
 *    This API may only be called on menus that are implemented using
 *    an HIView. paramErr will be returned if an MDEF-based menu is
 *    provided.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu for which to set the item view class.
 *    
 *    inItem:
 *      The menu item for which to set the item view class.
 *    
 *    inClassID:
 *      The class ID of the menu item's custom view. May be NULL to
 *      clear the item's custom view class ID; however, any item view
 *      that had already been created for the item will remain embedded
 *      in the menu content view and will be used to measure and draw
 *      the item.
 *    
 *    inInitEvent:
 *      The initialization event of the menu item's custom view. May be
 *      NULL.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuSetItemViewClass(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  CFStringRef     inClassID,         /* can be NULL */
  EventRef        inInitEvent)       /* can be NULL */        AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIMenuCopyItemViewClass()
 *  
 *  Summary:
 *    Returns the HIObject class ID and initialization event that are
 *    used to create a custom HIView for a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu for which to retrieve the item view class.
 *    
 *    inItem:
 *      The menu item for which to retrieve the item view class.
 *    
 *    outClassID:
 *      On exit, contains the item's custom view class ID, or NULL if
 *      none. The caller should release this string.
 *    
 *    outInitEvent:
 *      On exit, contains the item's custom view initialization event,
 *      or NULL if none. The caller should release this event.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuCopyItemViewClass(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  CFStringRef *   outClassID,
  EventRef *      outInitEvent)       /* can be NULL */       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIMenuGetItemView()
 *  
 *  Summary:
 *    Returns the HIViewRef that will be used to draw a menu item, if
 *    any.
 *  
 *  Discussion:
 *    If the item view has not yet been created, the Menu Manager will
 *    create the item view using the view class ID and initialization
 *    event specified by the HIMenuSetItemViewClass API. If the menu
 *    item does not have a custom view associated with it, noErr is
 *    returned but outView is set to NULL. 
 *    
 *    This API may only be called on menus that are implemented using
 *    an HIView. paramErr will be returned if an MDEF-based menu is
 *    provided.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu.
 *    
 *    inItem:
 *      The menu item.
 *    
 *    inMenuType:
 *    
 *    outView:
 *      On exit, contains the view. May be set to NULL if the item does
 *      not have a custom item view. The caller should not release this
 *      view.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuGetItemView(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  ThemeMenuType   inMenuType,
  HIViewRef *     outView)                                    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIMenuItemViewGetEnclosingMenuItem()
 *  
 *  Summary:
 *    Locates the menu item that contains a menu item view or one of
 *    its subviews.
 *  
 *  Discussion:
 *    A custom HIView may behave differently depending on whether it's
 *    embedded in a menu or a regular window. This API will tell the
 *    view whether it's contained in a menu or a window. Note that this
 *    API will always return false if called from a view's
 *    kEventHIObjectConstruct or kEventHIObjectInitialize event
 *    handler, even if the view is being created for use in a menu; at
 *    Construct and Init time, the Menu Manager has not yet created the
 *    binding between the view and the item. A view can check for
 *    kEventParamMenuRef and kEventParamMenuItemIndex parameters in its
 *    kEventHIObjectInitialize handler to determine at Init time
 *    whether the view is being placed into a menu. 
 *    
 *    This API may be passed a menu item view or any subview of the
 *    item view. If passed a subview, it will search upwards through
 *    the view hierarchy to look for an item view.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inItemView:
 *      The item view.
 *    
 *    outMenu:
 *      On exit, contains the menu in which the view is embedded. May
 *      be NULL if you don't need the menu.
 *    
 *    outItem:
 *      On exit, contains the menu item that the view is implementing.
 *      May be NULL if you don't need the item. Note that the item
 *      index that is returned may change over time if menu items are
 *      inserted or deleted; generally, a view should not cache the
 *      item index, but should call this API each time that it needs to
 *      know its current item.
 *  
 *  Result:
 *    true if the view is embedded in a menu, or false if not.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
HIMenuItemViewGetEnclosingMenuItem(
  HIViewRef        inItemView,
  MenuRef *        outMenu,          /* can be NULL */
  MenuItemIndex *  outItem)          /* can be NULL */        AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  HIMenuItemViewCancelMenuTracking()
 *  
 *  Summary:
 *    Cancels menu tracking for the menu containing an item view.
 *  
 *  Discussion:
 *    In order to call the CancelMenuTracking API, you must know the
 *    menu that is the root for the menu tracking session. This root
 *    menu is often not available to a custom menu item view. This API
 *    allows a menu item view to cancel tracking without knowing the
 *    root menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inItemView:
 *      The item view.
 *    
 *    inImmediate:
 *      Whether the open menus should disappear immediately or fade out.
 *    
 *    inDismissalReason:
 *      Why the menu is being dismissed; this value will be added to
 *      the kEventMenuEndTracking event. If zero,
 *      kHIMenuDismissedByCancelMenuTracking is added to the
 *      EndTracking event.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
HIMenuItemViewCancelMenuTracking(
  HIViewRef   inItemView,
  Boolean     inImmediate,
  UInt32      inDismissalReason)                              AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/* • Properties  (Mac OS 8.5 and later)                                                 */
/*                                                                                      */
/* With the following property APIs, you can attach any piece of data you'd like to a   */
/* menu or menu item. Passing zero for the item number parameter indicates you'd like   */
/* to attach the data to the menu itself, and not to any specific menu item.            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */

enum {
  kMenuPropertyPersistent       = 0x00000001 /* whether this property gets saved when archiving the menu; however, ignored in Mac OS X 10.4*/
};

#if !__LP64__
/*
 *  GetMenuItemProperty()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
GetMenuItemProperty(
  MenuRef         menu,
  MenuItemIndex   item,
  OSType          propertyCreator,
  OSType          propertyTag,
  ByteCount       bufferSize,
  ByteCount *     actualSize,
  void *          propertyBuffer)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemPropertySize()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
GetMenuItemPropertySize(
  MenuRef         menu,
  MenuItemIndex   item,
  OSType          propertyCreator,
  OSType          propertyTag,
  ByteCount *     size)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemProperty()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
SetMenuItemProperty(
  MenuRef         menu,
  MenuItemIndex   item,
  OSType          propertyCreator,
  OSType          propertyTag,
  ByteCount       propertySize,
  const void *    propertyData)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RemoveMenuItemProperty()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
RemoveMenuItemProperty(
  MenuRef         menu,
  MenuItemIndex   item,
  OSType          propertyCreator,
  OSType          propertyTag)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemPropertyAttributes()
 *  
 *  Summary:
 *    Gets the attributes of a menu item property.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu.
 *    
 *    item:
 *      The menu item.
 *    
 *    propertyCreator:
 *      The creator code of the property.
 *    
 *    propertyTag:
 *      The property tag.
 *    
 *    attributes:
 *      On exit, contains the attributes of the property.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuItemPropertyAttributes(
  MenuRef         menu,
  MenuItemIndex   item,
  OSType          propertyCreator,
  OSType          propertyTag,
  OptionBits *    attributes)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ChangeMenuItemPropertyAttributes()
 *  
 *  Summary:
 *    Changes the attributes of a menu item property.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu.
 *    
 *    item:
 *      The menu item.
 *    
 *    propertyCreator:
 *      The creator code of the property.
 *    
 *    propertyTag:
 *      The property tag.
 *    
 *    attributesToSet:
 *      The attributes to add to the menu item property.
 *    
 *    attributesToClear:
 *      The attributes to remove from the menu item property.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ChangeMenuItemPropertyAttributes(
  MenuRef         menu,
  MenuItemIndex   item,
  OSType          propertyCreator,
  OSType          propertyTag,
  OptionBits      attributesToSet,
  OptionBits      attributesToClear)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Attributes (Carbon and later)                                                     */
/*                                                                                      */
/*  Each menu and menu item has attribute flags.                                        */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  GetMenuAttributes()
 *  
 *  Summary:
 *    Gets the attributes of a menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu.
 *    
 *    outAttributes:
 *      On exit, contains the attributes of the menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuAttributes(
  MenuRef           menu,
  MenuAttributes *  outAttributes)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ChangeMenuAttributes()
 *  
 *  Summary:
 *    Changes the attributes of a menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu.
 *    
 *    setTheseAttributes:
 *      The attributes to add to the menu.
 *    
 *    clearTheseAttributes:
 *      The attributes to remove from the menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ChangeMenuAttributes(
  MenuRef          menu,
  MenuAttributes   setTheseAttributes,
  MenuAttributes   clearTheseAttributes)                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuItemAttributes()
 *  
 *  Summary:
 *    Gets the attributes of a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu.
 *    
 *    item:
 *      The menu item.
 *    
 *    outAttributes:
 *      On exit, contains the attributes of the menu item.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuItemAttributes(
  MenuRef               menu,
  MenuItemIndex         item,
  MenuItemAttributes *  outAttributes)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ChangeMenuItemAttributes()
 *  
 *  Summary:
 *    Changes the attributes of a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu.
 *    
 *    item:
 *      The menu item.
 *    
 *    setTheseAttributes:
 *      The attributes to add to the menu item.
 *    
 *    clearTheseAttributes:
 *      The attributes to remove from the menu item.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ChangeMenuItemAttributes(
  MenuRef              menu,
  MenuItemIndex        item,
  MenuItemAttributes   setTheseAttributes,
  MenuItemAttributes   clearTheseAttributes)                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Mass menu item enabling and disabling (Carbon and later)                          */
/*                                                                                      */
/*  Useful when rewriting code that modifies the enableFlags field directly.            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  DisableAllMenuItems()
 *  
 *  Summary:
 *    Disables all items in a menu.
 *  
 *  Discussion:
 *    This API is equivalent to pre-Carbon code that masked the
 *    enableFlags field of the MenuInfo with 0x01. It disables all
 *    items (including items past item 31) but does not affect the
 *    state of the menu title.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu whose items to disable.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
DisableAllMenuItems(MenuRef theMenu)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  EnableAllMenuItems()
 *  
 *  Summary:
 *    Enables all items in a menu.
 *  
 *  Discussion:
 *    This API is equivalent to pre-Carbon code that or'd the
 *    enableFlags field of the MenuInfo with 0xFFFFFFFE. It enables all
 *    items (including items past item 31) but does not affect the
 *    state of the menu title.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu whose items to enable.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
EnableAllMenuItems(MenuRef theMenu)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  MenuHasEnabledItems()
 *  
 *  Summary:
 *    Determines if any items in a menu are enabled.
 *  
 *  Discussion:
 *    This API is equivalent to pre-Carbon code that compared the
 *    enableFlags field of the MenuInfo with 0. It checks the enable
 *    state of all items to see if any are enabled, but ignores the
 *    state of the menu title. It will return true even if the menu
 *    title is disabled.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu whose items to examine.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
MenuHasEnabledItems(MenuRef theMenu)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu tracking status (Carbon and later)                                           */
/*                                                                                      */
/*  Get info about the selected menu item during menu tracking. Replaces direct access  */
/*  to low-mem globals that previously held this info.                                  */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */

/*
 *  GetMenuTrackingData()
 *  
 *  Summary:
 *    Gets information about the menu currently selected by the user.
 *  
 *  Discussion:
 *    This API replaces direct access to the low-memory globals
 *    TopMenuItem, AtMenuBottom, MenuDisable, and mbSaveLoc. It is only
 *    valid to call this API while menu tracking is occurring. This API
 *    will most commonly be used by custom MDEFs.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu about which to get tracking information. May be NULL
 *      to get information about the menu that the user is currently
 *      selecting. If the menu is not currently open, menuNotFoundErr
 *      is returned.
 *    
 *    outData:
 *      On exit, contains tracking data about the menu. On CarbonLib,
 *      the itemRect field is not supported and is always set to an
 *      empty rect.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuTrackingData(
  MenuRef             theMenu,
  MenuTrackingData *  outData)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#if !__LP64__
/*
 *  GetMenuType()
 *  
 *  Summary:
 *    Gets the display type (pulldown, hierarchical, or popup) of a
 *    menu.
 *  
 *  Discussion:
 *    This API may only be called when the menu is displayed. If the
 *    menu is not currently open, an error is returned. The display
 *    type of a menu may vary from one menu tracking session to
 *    another; for example, the same menu might be displayed as a
 *    pulldown menu and as a popup menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu whose type to get.
 *    
 *    outType:
 *      On exit, the type of the menu. The returned value will be one
 *      of the ThemeMenuType constants: kThemeMenuTypePullDown, PopUp,
 *      or Hierarchical. The kThemeMenuTypeInactive bit will never be
 *      set.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuType(
  MenuRef   theMenu,
  UInt16 *  outType)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Universal command ID access (Carbon and later)                                    */
/*                                                                                      */
/*  These APIs allow you to operate on menu items strictly by command ID, with no       */
/*  knowledge of a menu item's index.                                                   */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  CountMenuItemsWithCommandID()
 *  
 *  Summary:
 *    Counts the menu items with a specified command ID.
 *  
 *  Discussion:
 *    In CarbonLib 1.0.x and 1.1, this API always returns zero or one;
 *    it stops after finding the first menu item with the specified
 *    command ID. In CarbonLib 1.2 and Mac OS X 10.0 and later, it
 *    counts all menu items with the specified command ID. In Mac OS X
 *    10.0 and CarbonLib 1.0 through 1.4, this API only searches
 *    top-level menus (menus visible in the menubar) and submenus of
 *    top-level menus. It does not search hierarchical menus that are
 *    inserted in the menubar but are not submenus of a top-level menus
 *    (for example, it does not search menus that are inserted for use
 *    in a popup menu control). In Mac OS X 10.1 and CarbonLib 1.5 and
 *    later, this API also searches inserted hierarchical menus.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for items with the
 *      specified command ID. Pass NULL to hegin searching with the
 *      root menu. The search will descend into all submenus of this
 *      menu.
 *    
 *    inCommandID:
 *      The command ID for which to search.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern ItemCount 
CountMenuItemsWithCommandID(
  MenuRef       inMenu,
  MenuCommand   inCommandID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetIndMenuItemWithCommandID()
 *  
 *  Summary:
 *    Finds a menu item with a specified command ID.
 *  
 *  Discussion:
 *    This API searches the specified menu and its submenus for the
 *    n'th menu item with the specified command ID. In CarbonLib 1.0.x
 *    and 1.1, only the first menu item is returned. In CarbonLib 1.2
 *    and Mac OS X 10.0 and later, this API iterates over all menu
 *    items with the specified command ID. In Mac OS X 10.0 and
 *    CarbonLib 1.0 through 1.4, this API only searches top-level menus
 *    (menus visible in the menubar) and submenus of top-level menus.
 *    It does not search hierarchical menus that are inserted in the
 *    menubar but are not submenus of a top-level menus (for example,
 *    it does not search menus that are inserted for use in a popup
 *    menu control). In Mac OS X 10.1 and CarbonLib 1.5 and later, this
 *    API also searches inserted hierarchical menus.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for items with the
 *      specified command ID. Pass NULL to hegin searching with the
 *      root menu. The search will descend into all submenus of this
 *      menu.
 *    
 *    inCommandID:
 *      The command ID for which to search.
 *    
 *    inItemIndex:
 *      The 1-based index of the menu item to retrieve. In CarbonLib
 *      1.0.x and 1.1, this parameter must be 1. In CarbonLib 1.2 and
 *      Mac OS X 10.0, this parameter may vary from 1 to the number of
 *      menu items with the specified command ID.
 *    
 *    outMenu:
 *      On exit, the menu containing the menu item with the specified
 *      command ID.
 *    
 *    outIndex:
 *      On exit, the item index of the menu item with the specified
 *      command ID.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetIndMenuItemWithCommandID(
  MenuRef          inMenu,
  MenuCommand      inCommandID,
  UInt32           inItemIndex,
  MenuRef *        outMenu,           /* can be NULL */
  MenuItemIndex *  outIndex)          /* can be NULL */       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  EnableMenuCommand()
 *  
 *  Summary:
 *    Enables the menu item with a specified command ID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item to be enabled. If more than one
 *      item has this command ID, only the first will be enabled.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
EnableMenuCommand(
  MenuRef       inMenu,
  MenuCommand   inCommandID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DisableMenuCommand()
 *  
 *  Summary:
 *    Disables the menu item with a specified command ID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item to be disabled. If more than
 *      one item has this command ID, only the first will be disabled.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
DisableMenuCommand(
  MenuRef       inMenu,
  MenuCommand   inCommandID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsMenuCommandEnabled()
 *  
 *  Summary:
 *    Determines if the menu item with a specified command ID is
 *    enabled.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item to examine. If more than one
 *      item has this command ID, only the first will be examined.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsMenuCommandEnabled(
  MenuRef       inMenu,
  MenuCommand   inCommandID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuCommandMark()
 *  
 *  Summary:
 *    Locates the menu item with a specified command ID and sets its
 *    mark character.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item to be modified. If more than
 *      one item has this command ID, only the first will be modified.
 *    
 *    inMark:
 *      The new mark character. Although the type of this parameter is
 *      UniChar, currently only the low byte of this character will be
 *      used as the mark character, and it is interpreted using the
 *      application’s text encoding.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuCommandMark(
  MenuRef       inMenu,
  MenuCommand   inCommandID,
  UniChar       inMark)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuCommandMark()
 *  
 *  Summary:
 *    Locates the menu item with a specified command ID and returns its
 *    mark character.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item to be examined. If more than
 *      one item has this command ID, only the first will be examined.
 *    
 *    outMark:
 *      On exit, the menu item's mark character.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuCommandMark(
  MenuRef       inMenu,
  MenuCommand   inCommandID,
  UniChar *     outMark)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuCommandProperty()
 *  
 *  Summary:
 *    Retrives property data for a menu item with a specified command
 *    ID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item containing the property. If
 *      more than one item has this command ID, only the first will be
 *      used.
 *    
 *    inPropertyCreator:
 *      The property creator.
 *    
 *    inPropertyTag:
 *      The property tag.
 *    
 *    inBufferSize:
 *      The size of the output buffer, in bytes.
 *    
 *    outActualSize:
 *      On exit, contains the actual size of the property data. May be
 *      NULL if you do not need this information.
 *    
 *    inPropertyBuffer:
 *      The address of a buffer in which to place the property data.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuCommandProperty(
  MenuRef       inMenu,
  MenuCommand   inCommandID,
  OSType        inPropertyCreator,
  OSType        inPropertyTag,
  ByteCount     inBufferSize,
  ByteCount *   outActualSize,           /* can be NULL */
  void *        inPropertyBuffer)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetMenuCommandPropertySize()
 *  
 *  Summary:
 *    Retrives the size of property data for a menu item with a
 *    specified command ID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item containing the property. If
 *      more than one item has this command ID, only the first will be
 *      used.
 *    
 *    inPropertyCreator:
 *      The property creator.
 *    
 *    inPropertyTag:
 *      The property tag.
 *    
 *    outSize:
 *      On exit, contains the size of the property data.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetMenuCommandPropertySize(
  MenuRef       inMenu,
  MenuCommand   inCommandID,
  OSType        inPropertyCreator,
  OSType        inPropertyTag,
  ByteCount *   outSize)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuCommandProperty()
 *  
 *  Summary:
 *    Sets property data for a menu item with a specified command ID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item that will receive the property.
 *      If more than one item has this command ID, only the first will
 *      be modified.
 *    
 *    inPropertyCreator:
 *      The property creator.
 *    
 *    inPropertyTag:
 *      The property tag.
 *    
 *    inPropertySize:
 *      The size of the property data, in bytes.
 *    
 *    inPropertyData:
 *      The address of the property data.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuCommandProperty(
  MenuRef       inMenu,
  MenuCommand   inCommandID,
  OSType        inPropertyCreator,
  OSType        inPropertyTag,
  ByteCount     inPropertySize,
  const void *  inPropertyData)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  RemoveMenuCommandProperty()
 *  
 *  Summary:
 *    Removes a property from a menu item with a specified command ID.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu in which to begin searching for the item. Pass NULL to
 *      begin searching with the root menu. The search will descend
 *      into all submenus of this menu.
 *    
 *    inCommandID:
 *      The command ID of the menu item from which the property will be
 *      removed. If more than one item has this command ID, only the
 *      first will be modified.
 *    
 *    inPropertyCreator:
 *      The property creator.
 *    
 *    inPropertyTag:
 *      The property tag.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
RemoveMenuCommandProperty(
  MenuRef       inMenu,
  MenuCommand   inCommandID,
  OSType        inPropertyCreator,
  OSType        inPropertyTag)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*
 *  CopyMenuItemData()
 *  
 *  Summary:
 *    Returns multiple attributes of a menu item at once.
 *  
 *  Discussion:
 *    This function is used to retrieve many attributes of a menu item
 *    simultaneously; for example, it might be used by a menu
 *    definition function that needs to know how to draw a menu item.
 *    It is more efficient to use this function than to use the
 *    accessor functions for the individual attributes of the menu.
 *    This function returns a copy of the data in the menu, so any data
 *    in the MenuItemDataRec that is dynamically allocated (for
 *    example, the CFString item text) should be released by the caller.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu from which to copy data. If inIsCommandID is true, you
 *      may pass NULL for this parameter to search for an item in the
 *      root menu; if inIsCommandID is false, this parameter must be a
 *      valid MenuRef.
 *    
 *    inItem:
 *      The item or command ID from which to copy data.
 *    
 *    inIsCommandID:
 *      Indicates whether inItem is a MenuItemIndex or MenuCommand. If
 *      inIsCommandID is true, the inItem parameter is interpreted as a
 *      menu command ID, and data is copied from the first item in the
 *      menu with that command ID. If inIsCommandID is false, the
 *      inItem parameter is interpreted as a menu item index, and data
 *      is copied for that item in the specified menu.
 *    
 *    ioData:
 *      Data is copied from the item and placed here. On entry, the
 *      whichData field of this structure should be initialized to
 *      indicate which data the caller would like returned. Individual
 *      fields of the MenuItemDataRec structure may require
 *      pre-initialization also; see the individual MenuItemDataFlags
 *      documentation for details.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CopyMenuItemData(
  MenuRef           inMenu,              /* can be NULL */
  MenuItemID        inItem,
  Boolean           inIsCommandID,
  MenuItemDataPtr   ioData)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetMenuItemData()
 *  
 *  Summary:
 *    Sets multiple attributes of a menu item at once.
 *  
 *  Discussion:
 *    This function is used to set many attributes of a menu item
 *    simultaneously. It is more efficient to use this function than to
 *    use the accessor functions for the individual attributes of the
 *    menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu to modify.
 *    
 *    inItem:
 *      The item or command ID to modify.
 *    
 *    inIsCommandID:
 *      Indicates whether inItem is a MenuItemIndex or MenuCommand. If
 *      inIsCommandID is true, the inItem parameter is interpreted as a
 *      menu command ID, and the first item in the menu with that
 *      command ID. is modified. If inIsCommandID is false, the inItem
 *      parameter is interpreted as a menu item index, and the item
 *      with that index in the specified menu is modified.
 *    
 *    inData:
 *      The data to set. The caller should set the whichData field of
 *      this structure to indicate which data should be set. Only the
 *      fields of the structure corresponding to the non-zero whichData
 *      flags must be initialized; other fields are ignored.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetMenuItemData(
  MenuRef                  inMenu,
  MenuItemID               inItem,
  Boolean                  inIsCommandID,
  const MenuItemDataRec *  inData)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Dynamic menu item support (available in CarbonLib 1.1 and Mac OS X)               */
/*                                                                                      */
/*  Dynamic menu item support allows a menu item to be redrawn while the menu is open   */
/*  and visible to the user. Carbon contains automatic support for dynamic items based  */
/*  on keyboard modifier state. If you need to implement your own variable item state   */
/*  based on other system state, you can use these APIs to implement it.                */
/*                                                                                      */
/*  To use the built-in support for dynamic items, you should create a menu containing  */
/*  several contiguous items with the same command key but different text and modifier  */
/*  keys. For example, you might have:                                                  */
/*                                                                                      */
/*      Close       cmd-W                                                               */
/*      Close All   cmd-option-W                                                        */
/*                                                                                      */
/*  The Menu Manager automatically determines a dynamic menu group using the base       */
/*  command key of a dynamic menu item ('W' in this case). Only a single item from      */
/*  a dynamic group is visible at any time; the other items are hidden. The Menu        */
/*  Manager uses the current keyboard modifiers to determine which item is visible.     */
/*  It is also possible to have a dynamic menu item group that does not have command    */
/*  keys, but only modifiers; for example, in the Finder's View menu, the Clean Up      */
/*  and Clean Up Selection items have no command key, but are a dynamic menu item       */
/*  group that changes visibility based on the Option modifier key.                     */
/*                                                                                      */
/*  In this example, in your MENU resource, you would create the Close and Close All    */
/*  items and give them each the letter 'W' as the command key; using an associated     */
/*  xmnu resource, you would specify kMenuOptionModifier as the modifier for the        */
/*  Close All item. You can do the same thing using InterfacerBuilder and nib-based     */
/*  menus.                                                                              */
/*                                                                                      */
/*  After loading your menu from the resource, you must set the kMenuItemAttrDynamic    */
/*  flag for each dynamic item. In this example, you would use:                         */
/*                                                                                      */
/*      ChangeMenuItemAttributes( menu, kCloseItem, kMenuItemAttrDynamic, 0 );          */
/*      ChangeMenuItemAttributes( menu, kCloseAllItem, kMenuItemAttrDynamic, 0 );       */
/*                                                                                      */
/*  The Menu Manager will now automatically display the correct item depending on       */
/*  whether the Option key is pressed. The result from MenuSelect will be the item      */
/*  number of the item that was visible when the menu closed.                           */
/*                                                                                      */
/*  Note that:                                                                          */
/*                                                                                      */
/*      - If you use InterfacerBuilder, you can set the kMenuItemAttrDynamic attribute  */
/*        directly in the menu object in the nib, using the Inspector window for the    */
/*        menu. You don't need to add the attribute after creating the menu.            */
/*                                                                                      */
/*      - If your application requires Mac OS X 10.2 or CarbonLib 1.6 or later, you     */
/*        can also use a version-one-format 'xmnu' resource, which allows settting      */
/*        the menu item attributes in the 'xmnu'. Using a version one resource, you     */
/*        can include the kMenuItemAttrDynamic attribute in the resource rather than    */
/*        adding it after creating the menu.                                            */
/*                                                                                      */
/*  If the Menu Manager's built-in support is not sufficient, you can also change the   */
/*  attributes of an item yourself and use the UpdateInvalidMenuItems API to cause      */
/*  the menu to redraw. Changes to a menu item (changing text, command key, style,      */
/*  etc.) that occur while the menu is open will cause the menu item to be invalidated, */
/*  but not redrawn. If you need to invalidate the item explicitly yourself, perhaps    */
/*  because you have a custom MDEF that depends on state not accessed using Menu        */
/*  Manager APIs, you can use the InvalidateMenuItems API. UpdateInvalidMenuItems will  */
/*  scan the menu for invalid items and redraw each, clearing its invalid flag          */
/*  afterwards.                                                                         */
/*                                                                                      */
/*  If you need to change menu contents based on modifier key state without using the   */
/*  built-in support in the Menu Manager, we recommend that you install a Carbon event  */
/*  handler on your menu for the [kEventClassKeyboard, kEventRawKeyModifiersChanged]    */
/*  event. Modifier key events are passed to the currently open menu before being sent  */
/*  to the user focus target.                                                           */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  IsMenuItemInvalid()
 *  
 *  Summary:
 *    Determines if a menu item is invalid and should be redrawn.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose item to examine.
 *    
 *    inItem:
 *      The item to examine.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsMenuItemInvalid(
  MenuRef         inMenu,
  MenuItemIndex   inItem)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  InvalidateMenuItems()
 *  
 *  Summary:
 *    Invalidates a group of menu items so that they will be redrawn
 *    when UpdateInvalidMenuItems is next called.
 *  
 *  Discussion:
 *    Menu items are automatically invalidated when their contents are
 *    changed using Menu Manager APIs while the menu is open. However,
 *    you might need to use this API if you have a custom MDEF that
 *    draws using state not contained in the menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose items to invalidate.
 *    
 *    inFirstItem:
 *      The first item to invalidate.
 *    
 *    inNumItems:
 *      The number of items to invalidate.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
InvalidateMenuItems(
  MenuRef         inMenu,
  MenuItemIndex   inFirstItem,
  ItemCount       inNumItems)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  UpdateInvalidMenuItems()
 *  
 *  Summary:
 *    Redraws the invalid items of an open menu.
 *  
 *  Discussion:
 *    It is not necessary to use UpdateInvalidMenuItems if you are
 *    using Carbon's built-in support for dynamic items based on
 *    modifier key state. However, if you are modifying items
 *    dynamically using your own implementation, you should call
 *    UpdateInvalidMenuItems after completing your modifications for a
 *    single menu. It will redraw any items that have been marked as
 *    invalid, and clear the invalid flag for those items.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu to update.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
UpdateInvalidMenuItems(MenuRef inMenu)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Standard font menu (Carbon and later)                                             */
/*                                                                                      */
/*  These APIs allow you to create and use the standard font menu.                      */
/*——————————————————————————————————————————————————————————————————————————————————————*/
#endif  /* !__LP64__ */

enum {
  kHierarchicalFontMenuOption   = 0x00000001
};

#if !__LP64__
/*
 *  CreateStandardFontMenu()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CreateStandardFontMenu(
  MenuRef         menu,
  MenuItemIndex   afterItem,
  MenuID          firstHierMenuID,
  OptionBits      options,
  ItemCount *     outHierMenuCount)       /* can be NULL */   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  UpdateStandardFontMenu()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
UpdateStandardFontMenu(
  MenuRef      menu,
  ItemCount *  outHierMenuCount)       /* can be NULL */      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetFontFamilyFromMenuSelection()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetFontFamilyFromMenuSelection(
  MenuRef         menu,
  MenuItemIndex   item,
  FMFontFamily *  outFontFamily,
  FMFontStyle *   outStyle)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Contextual Menu routines and constants                                            */
/*  available with Conxtextual Menu extension 1.0 and later                             */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* Gestalt Selector for classic 68K apps only. */
/* CFM apps should weak link and check the symbols. */
#endif  /* !__LP64__ */

enum {
  gestaltContextualMenuAttr     = 'cmnu',
  gestaltContextualMenuUnusedBit = 0,
  gestaltContextualMenuTrapAvailable = 1,
  gestaltContextualMenuHasAttributeAndModifierKeys = 2, /* Contextual Menu Manager supports keyContextualMenuAttributes and keyContextualMenuModifiers */
  gestaltContextualMenuHasUnicodeSupport = 3 /* Contextual Menu Manager supports typeUnicodeText and typeCFStringRef */
};


/*
 *  Summary:
 *    Values indicating what kind of help the application supports
 */
enum {

  /*
   * The application does not support any help. The Menu Manager will
   * put an appropriate help string into the contextual menu and
   * disable the Help item.
   */
  kCMHelpItemNoHelp             = 0,

  /*
   * The application supports Apple Guide help. The Menu Manager will
   * put the name of the main Guide file into the contextual menu and
   * enable the Help item.
   */
  kCMHelpItemAppleGuide         = 1,

  /*
   * The application supports some other form of help. In this case,
   * the application must also pass a valid string into the
   * inHelpItemString parameter of ContextualMenuSelect. This string
   * will be the text of the Help item in the contextual menu, and the
   * Help item will be enabled.
   */
  kCMHelpItemOtherHelp          = 2,

  /*
   * The application does not support any help. The Menu Manager will
   * remove the Help item from the contextual menu. This constant is
   * available in Mac OS X and CarbonLib 1.6, and later; however, in
   * CarbonLib it is translated to kCMHelpItemNoHelp, and the Help item
   * is only disabled, not removed.
   */
  kCMHelpItemRemoveHelp         = 3
};


/*
 *  Summary:
 *    Values indicating what was chosen from a contextual menu
 */
enum {

  /*
   * The user did not choose an item from the contextual menu and the
   * application should do no further processing of the event.
   */
  kCMNothingSelected            = 0,

  /*
   * The user chose one of the application's items from the menu. The
   * application can examine the outMenuID and outMenuItem parameters
   * of ContextualMenuSelect to see what the menu selection was, and it
   * should then handle the selection appropriately.
   */
  kCMMenuItemSelected           = 1,

  /*
   * The user chose the Help item from the menu. The application should
   * open an Apple Guide database to a section appropriate for the
   * selection. If the application supports some other form of help, it
   * should be presented instead.
   */
  kCMShowHelpSelected           = 3
};



/*
 *  Summary:
 *    AERecord keywords used by the ExamineContext method of a
 *    Contextual Menu plugin to specify menu item contents.
 */
enum {

  /*
   * Specifies the text of an item in a contextual menu. Data for this
   * parameter can be in one of several formats. In Mac OS 7/8/9.x and
   * Mac OS X 10.0 and 10.1, typeChar and typeIntlText are supported.
   * In Mac OS X 10.2 and later, typeStyledText, typeAEText,
   * typeUnicodeText, and typeCFStringRef are also supported. If you
   * provide data as typeCFStringRef, the Contextual Menu Manager will
   * automatically release the CFStringRef once the menu has been
   * displayed. If you need the CFStringRef to have a longer timetime,
   * your plugin should retain the CFStringRef before inserting it into
   * the AERecord.
   */
  keyContextualMenuName         = 'pnam',

  /*
   * Specifies the command ID of an item in a contextual menu. Data for
   * this parameter should be typeSInt32.
   */
  keyContextualMenuCommandID    = 'cmcd',

  /*
   * Specifies a contextual menu item with a submenu. Typically used
   * with AEPutKeyDesc to add an entire AEDesc containing the submenu
   * as the data for the parameter.
   */
  keyContextualMenuSubmenu      = 'cmsb',

  /*
   * Specifies the menu item attributes of an item in a contextual
   * menu. Data for this parameter should be typeSInt32. Available in
   * Mac OS X 10.2 and later.
   */
  keyContextualMenuAttributes   = 'cmat',

  /*
   * Specifies the modifier keys of an item in a contextual menu (see
   * kMenuShiftModifier, kMenuControlModifier, etc.) Data for this
   * parameter should be typeSInt32. Using this parameter together with
   * the keyContextualMenuAttributes parameter, it is possible to
   * create a contextual menu with dynamic items which change according
   * to the modifier keys pressed by the user. Available in Mac OS X
   * 10.2 and later.
   */
  keyContextualMenuModifiers    = 'cmmd'
};

#if !__LP64__
/*
 *  IsShowContextualMenuClick()
 *  
 *  Summary:
 *    Determines whether a particular EventRecord could invoke a
 *    contextual menu.
 *  
 *  Discussion:
 *    Applications should call IsShowContextualMenuClick when they
 *    receive non-null events. If IsShowContextualMenuClick returns
 *    true, your application should generate its own menu and Apple
 *    Event descriptor (AEDesc), and then call ContextualMenuSelect to
 *    display and track the contextual menu, and then handle the user's
 *    choice. 
 *    
 *    Apple recommends that you use the IsShowContextualMenuEvent API
 *    instead of this API. If you use the standard window Carbon event
 *    handler on your windows, you can also use a
 *    kEventControlContextualMenuClick event handler to be notified
 *    when a contextual menu click has occured; in this case, you do
 *    not need to call this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inEvent:
 *      The event to examine.
 *  
 *  Result:
 *    Returns true if the application should display a contextual menu,
 *    false if not.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in ContextualMenu 1.0 and later
 */
extern Boolean 
IsShowContextualMenuClick(const EventRecord * inEvent)        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  IsShowContextualMenuEvent()
 *  
 *  Summary:
 *    Determines whether a particular EventRef could invoke a
 *    contextual menu.
 *  
 *  Discussion:
 *    This API is similar to IsShowContextualMenuClick, but takes a
 *    Carbon EventRef as its parameter instead of an EventRecord.
 *    
 *    
 *    In Mac OS X 10.3 and earlier, this API always returned false if
 *    the event kind was not kEventMouseDown,
 *    kEventWindowClickContentRgn, kEventWindowClickStructureRgn, or
 *    kEventWindowHandleContentClick. In Mac OS X 10.4 and later, this
 *    API no longer requires a specific event kind; it only requires
 *    that the event contain kEventParamMouseButton and
 *    kEventParamKeyModifiers parameters. 
 *    
 *    If you use the standard window Carbon event handler on your
 *    windows, you can also use a kEventControlContextualMenuClick
 *    event handler to be notified when a contextual menu click has
 *    occured; in this case, you do not need to call this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inEvent:
 *      The event to examine.
 *  
 *  Result:
 *    Returns true if the application should display a contextual menu,
 *    false if not.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern Boolean 
IsShowContextualMenuEvent(EventRef inEvent)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ContextualMenuSelect()
 *  
 *  Summary:
 *    Displays a contextual menu.
 *  
 *  Discussion:
 *    If IsShowContextualMenuClick returns true, you should call the
 *    ContextualMenuSelect API after generating your own menu and
 *    preparing an Apple Event descriptor (AEDesc) that describes the
 *    item for which your application is displaying a contextual menu.
 *    This descriptor may contain an object specifier or raw data and
 *    will be passed to all contextual menu plug-ins. 
 *    
 *    The system will add other items before displaying the contextual
 *    menu, and it will remove those items before returning, leaving
 *    the menu in its original state. 
 *    
 *    After all the system commands are added, the contextual menu is
 *    displayed and tracked. If the user selects one of the system
 *    items, it is handled by the system and the call returns as though
 *    the user didn't select anything from the menu. If the user
 *    selects any other item (or no item at all), the Menu Manager
 *    passes back appropriate values in the parameters
 *    outUserSelectionType, outMenuID, and outMenuItem. 
 *    
 *    Your application should provide visual feedback indicating the
 *    item that was clicked upon. For example, a click on an icon
 *    should highlight the icon, while a click on editable text should
 *    not eliminate the current selection. 
 *    
 *    If the outUserSelectionType parameter contains
 *    kCMMenuItemSelected, you should look at the outMenuID and
 *    outMenuItem parameters to determine what menu item the user chose
 *    and handle it appropriately. If the user selected
 *    kCMHelpItemSelected, you should open the proper Apple Guide
 *    sequence or other form of custom help. 
 *    
 *    There is a bug in ContextualMenuSelect in versions of Mac OS X
 *    prior to Mac OS X 10.4 that causes the value returned in the
 *    outUserSelectionType parameter to be set to kCMShowHelpSelected
 *    instead of kCMMenuItemSelected if the menu has a menu ID of zero
 *    and item three is selected. To avoid this problem on all versions
 *    of Mac OS X, simply use a non-zero menu ID. Note that when a new
 *    menu is created in InterfaceBuilder, its ID is automatically set
 *    to zero.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      A menu containing application commands to display. The caller
 *      creates this menu based on the current context, the mouse
 *      location, and the current selection (if it was the target of
 *      the mouse). If you pass nil, only system commands will be
 *      displayed. The menu should be added to the menu list as a
 *      pop-up menu (using the InsertMenu function).
 *    
 *    inGlobalLocation:
 *      The location (in global coordinates) of the mouse near which
 *      the menu is to be displayed.
 *    
 *    inReserved:
 *      Reserved for future use. Pass false for this parameter.
 *    
 *    inHelpType:
 *      An identifier specifying the type of help to be provided by the
 *      application; see kCMHelpItem constants.
 *    
 *    inHelpItemString:
 *      A string containing the text to be displayed for the help menu
 *      item. This string is unused unless you also pass the constant
 *      kCMHelpItemOtherHelp in the inHelpType parameter.
 *    
 *    inSelection:
 *      An object specifier for the current selection. This allows he
 *      system to examine the selection and add special system commands
 *      accordingly. Passing a value of nil indicates that no selection
 *      should be examined, and most likely, no special system actions
 *      will be included.
 *    
 *    outUserSelectionType:
 *      On exit, the value indicates what the user selected from the
 *      contextual menu; see kCMNothingSelected, kCMMenuItemSelected,
 *      and kCMShowHelpSelected.
 *    
 *    outMenuID:
 *      On exit, if outUserSelectionType is set to kCMMenuItemSelected,
 *      the value is set to the menu ID of the chosen item.
 *    
 *    outMenuItem:
 *      On exit, if outUserSelectionType is set to kCMMenuItemSelected,
 *      the value is set to the menu item chosen.
 *  
 *  Result:
 *    An OSStatus result code. ContextualMenuSelect returns the result
 *    code userCanceledErr and sets outUserSelectionType to
 *    kCMNothingSelected to indicate that the user did not select
 *    anything from the contextual menu and no further processing is
 *    needed.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in ContextualMenu 1.0 and later
 */
extern OSStatus 
ContextualMenuSelect(
  MenuRef            inMenu,
  Point              inGlobalLocation,
  Boolean            inReserved,
  UInt32             inHelpType,
  ConstStr255Param   inHelpItemString,           /* can be NULL */
  const AEDesc *     inSelection,                /* can be NULL */
  UInt32 *           outUserSelectionType,
  MenuID *           outMenuID,
  MenuItemIndex *    outMenuItem)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#endif  /* !__LP64__ */

/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  Contextual Menu Plugin Interface                                                    */
/*                                                                                      */
/*  For Mac OS X 10.1, we support a new type of Contextual Menu Plugin: the CFPlugIn    */
/*  based plugin.  Each plugin must be in a CFPlugIn in the Contextual Menu Items       */
/*  folder in one of these paths:                                                       */
/*      /System/Library/Contextual Menu Items/                                          */
/*      /Library/Contextual Menu Items/                                                 */
/*      ~/Library/Contextual Menu Items/                                                */
/*                                                                                      */
/*  It must export the following functions using the following interface or a C++       */
/*  interface inheriting from IUnknown and including similar functions.                 */
/*——————————————————————————————————————————————————————————————————————————————————————*/

/* The Contextual Menu Manager will only load CFPlugIns of type kContextualMenuTypeID */
#define kContextualMenuTypeID ( CFUUIDGetConstantUUIDWithBytes( NULL, \
  0x2F, 0x65, 0x22, 0xE9, 0x3E, 0x66, 0x11, 0xD5, \
  0x80, 0xA7, 0x00, 0x30, 0x65, 0xB3, 0x00, 0xBC ) )
 /* 2F6522E9-3E66-11D5-80A7-003065B300BC */

/* Contextual Menu Plugins must implement this Contexual Menu Plugin Interface */
#define kContextualMenuInterfaceID    ( CFUUIDGetConstantUUIDWithBytes( NULL, \
  0x32, 0x99, 0x7B, 0x62, 0x3E, 0x66, 0x11, 0xD5, \
  0xBE, 0xAB, 0x00, 0x30, 0x65, 0xB3, 0x00, 0xBC ) )
 /* 32997B62-3E66-11D5-BEAB-003065B300BC */

#define CM_IUNKNOWN_C_GUTS \
   void *_reserved; \
 SInt32 (*QueryInterface)(void *thisPointer, CFUUIDBytes iid, void ** ppv); \
   UInt32 (*AddRef)(void *thisPointer); \
 UInt32 (*Release)(void *thisPointer)

/* The function table for the interface */
struct ContextualMenuInterfaceStruct
{
    CM_IUNKNOWN_C_GUTS;
    OSStatus ( *ExamineContext )(
          void*               thisInstance,
          const AEDesc*       inContext,
         AEDescList*         outCommandPairs );
 OSStatus ( *HandleSelection )(
         void*               thisInstance,
          AEDesc*             inContext,
         SInt32              inCommandID );
 void ( *PostMenuCleanup )(
         void*               thisInstance );
};
typedef struct ContextualMenuInterfaceStruct ContextualMenuInterfaceStruct;

/*
 *  CMPluginExamineContext()
 *  
 *  Availability:
 *    Implemented by client
 */
extern OSStatus 
CMPluginExamineContext(
  void *          thisInstance,
  const AEDesc *  inContext,
  AEDescList *    outCommandPairs);


/*
 *  CMPluginHandleSelection()
 *  
 *  Availability:
 *    Implemented by client
 */
extern OSStatus 
CMPluginHandleSelection(
  void *    thisInstance,
  AEDesc *  inContext,
  SInt32    inCommandID);


/*
 *  CMPluginPostMenuCleanup()
 *  
 *  Availability:
 *    Implemented by client
 */
extern void 
CMPluginPostMenuCleanup(void * thisInstance);



/* previously in LowMem.h.  This functions return the menu ID of the hilited menu */
#if !__LP64__
/*
 *  LMGetTheMenu()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern MenuID 
LMGetTheMenu(void)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



/*--------------------------------------------------------------------------------------*/
/*  • DEPRECATED                                                                        */
/*                                                                                      */
/*  All functions below this point are either deprecated (they continue to function     */
/*  but are not the most modern nor most efficient solution to a problem), or they are  */
/*  completely unavailable on Mac OS X.                                                 */
/*--------------------------------------------------------------------------------------*/
/*
    A Short Course on Menu Definition Functions
    
    A menu definition function is used to implement a custom visual appearance for a menu.
    Menu definition functions are still supported in Carbon, but the messages sent to a
    menu definition function in Carbon are different than for a non-Carbon application.
    
    In general, Apple recommends using the system menu definition whenever possible.
    Menu definition functions will continue to be supported, but it is not easy to write
    a correct menu definition, especially one that attempts to imitate the standard system
    menu appearance. If you require special features in your menu that the system menu
    definition does not support, please mail <toolbox@apple.com> and describe your requirements;
    we would much rather enhance the system menu definition than have you write a custom one.
    The use of menu definition functions is deprecated in Mac OS X; in Mac OS X 10.3 and
    later, Apple recommends that you use a custom HIView to draw menu content.
    
    Menu definition functions before Carbon used the following messages:
    
        kMenuDrawMsg
        kMenuChooseMsg
        kMenuSizeMsg
        kMenuPopUpMsg
        kMenuDrawItemMsg
        kMenuCalcItemMsg
        kMenuThemeSavvyMsg
        
    kMenuChooseMsg and kMenuDrawItemMsg are not supported in Carbon and are not sent to
    Carbon menu definitions. In Carbon, kMenuChooseMsg is replaced by kMenuFindItemMsg and
    kMenuHiliteItemMsg. Menu definition functions in Carbon use the following messages:
    
        kMenuInitMsg
        kMenuDisposeMsg
        kMenuFindItemMsg
        kMenuHiliteItemMsg
        kMenuDrawItemsMsg
        kMenuDrawMsg
        kMenuSizeMsg
        kMenuPopUpMsg
        kMenuCalcItemMsg
        kMenuThemeSavvyMsg
        
    The rest of this documentation will focus on Carbon menu definitions only.
    
    Menu Definition Messages
    
        Carbon menu definition functions should support the following messages:
        
        kMenuInitMsg
            
            menuRect        unused
            hitPt           unused
            whichItem       OSErr*
        
            Sent when a menu is created. This message gives the menu definition an opportunity
            to initialize its own state. If the menu definition encounters an error while
            initializing, it should set *whichItem to a non-zero error code; this will cause the
            Menu Manager to destroy the menu and return an error back from the API that was used
            to create the menu.
        
        kMenuDisposeMsg
            
            menuRect        unused
            hitPt           unused
            whichItem       unused
            
            Sent when a menu is destroyed. This message gives the menu definition an opportunity
            to destroy its own data.
            
        kMenuFindItemMsg
            
            menuRect        menu bounds
            hitPt           point to hit-test
            whichItem       MDEFFindItemData*
            
            Sent when the Menu Manager is displaying a menu and needs to know what item is under
            the mouse. The whichItem parameter is actually a pointer to a MenuTrackingData structure.
            On entry, the menu, virtualMenuTop, and virtualMenuBottom fields of this structure are
            valid. The menu definition should determine which item containst the given point, if any,
            and fill in the itemUnderMouse, itemSelected, and itemRect fields. If an item is found,
            the menu definition should always fill in the itemUnderMouse and itemRect fields. The
            menu definition should only fill in the itemSelected field if the item is available for
            selection; if it is unavailable (because it is disabled, or for some other reason), the
            menu definition should set the itemSelected field to zero.
            
            The values placed in the itemUnderMouse and itemSelected fields should be less than or
            equal to the number of items returned by CountMenuItems on this menu. The values placed
            in these two fields should be identical if both are non-zero. itemUnderMouse should always
            be non-zero if the mouse is actually over an item.
            
            The menu definition should not hilite the found item during this message. The Menu 
            Manager will send a separate kMenuHiliteItemMsg to request hiliting of the item.
            
            If the menu definition supports scrolling, it should scroll the menu during this message,
            and update the virtualMenuTop and virtualMenuBottom fields of the MenuTrackingData to
            indicate the menu's new scrolled position.
            
            If the menu definition uses QuickDraw to draw while scrolling, it should draw into the
            current port.
    
            If the menu definition uses CoreGraphics to draw while scrolling, it should use the
            CGContextRef passed in the context field of the MDEFHiliteItemData structure.
            
            Menu definitions must use the ScrollMenuImage API, if available, to scroll the menu contents.
            This API is available in CarbonLib 1.5 and later, and in Mac OS X 10.1 and later. ScrollMenuImage
            properly supports scrolling the alpha channel in the menu's image data. Use of QuickDraw's
            ScrollRect API to scroll the menu contents will result in the alpha channel being set to 0xFF
            (opaque) and the menu will no longer be transparent.
            
            The menu definition should not modify the menu field of the MenuTrackingData.
            
        kMenuHiliteItemMsg
        
            menuRect        menu bounds
            hitPt           unused
            whichItem       MDEFHiliteItemData*
            
            Sent when the Menu Manager is displaying a menu and needs to hilite a newly selected
            item. The whichItem parameter is actually a pointer to a MDEFHiliteItemData structure.
            The menu definition should unhilite the item in the previousItem field, if non-zero,
            and hilite the item in the newItem field.
            
            Menu definitions should use the EraseMenuBackground API to erase the old menu contents
            before unhiliting a menu item, if the menu definition is using the Appearance Manager's
            menu drawing APIs. This is necessary because the background of a menu is transparent on
            Aqua, and if the old hilite is not erased first, it will show through the new unhilited
            menu background.
            
            If the menu definition uses QuickDraw to draw, it should draw into the current port.
    
            If the menu definition uses CoreGraphics to draw, it should use the CGContextRef passed
            in the context field of the MDEFHiliteItemData structure.
            
        kMenuDrawItemsMsg
        
            menuRect        menu bounds
            hitPt           unused
            whichItem       MDEFDrawItemsData*
            
            Sent when the Menu Manager is displaying a menu and needs to redraw a portion of the
            menu. This message is used by the dynamic menu item support code in the Menu Manager;
            for example, if items five and six in a menu are a dynamic group, the Menu Manager will
            send a DrawItems message when the group's modifier key is pressed or released to redraw
            the appropriate item, but no other items in the menu.
            
            The whichItem parameter for this message is actually a pointer to a MDEFDrawItemsData
            structure. The menu definition should redraw the items starting with firstItem and
            ending with lastItem, inclusive.
            
            If the menu definition uses QuickDraw to draw, it should draw into the current port.
    
            If the menu definition uses CoreGraphics to draw, it should use the CGContextRef passed
            in the context field of the MDEFDrawItemsData structure.
            
        kMenuDrawMsg
            
            menuRect        menu bounds
            hitPt           unused
            whichItem       MDEFDrawData*
            
            Sent when the Menu Manager is displaying a menu and needs to redraw the entire menu.
            The whichItem parameter is actually a pointer to a MenuTrackingData structure. On entry,
            the menu field of this structure is valid. The menu definition should draw the menu and,
            if it supports scrolling, should also fill in the virtualMenuTop and virtualMenuBottom
            fields of the structure to indicate the menu's initial unscrolled position; typically, 
            virtualMenuTop would be set to the same value as the top coordinate of the menu rect,
            and virtualMenuBottom would be set to virtualMenuTop plus the virtual height of the menu.
            
            If the menu definition uses QuickDraw to draw, it should draw into the current port.
    
            If the menu definition uses CoreGraphics to draw, it should use the CGContextRef passed
            in the context field of the MDEFDrawData structure.
            
        kMenuSizeMsg
        
            menuRect        unused
            hitPt           maximum width and height of the menu
            whichItem       unused
            
            Sent when the Menu Manager needs to determine the size of a menu. The menu definition
            should calculate the width and height of the menu and store the sizes into the menu with
            SetMenuWidth and SetMenuHeight.
            
            If the gestaltMenuMgrSendsMenuBoundsToDefProc bit is set in the Menu Manager's Gestalt
            value, then the hitPt parameter to this message is the maximum width (hitPt.h) and height
            (hitPt.v) of the menu. The menu definition should ensure that the width and height that it
            places in the menu do not exceed these values. If the gestalt bit is not set, the menu
            definition should just use the main GDevice's width and height as constraints on the menu's
            width and height.
            
        kMenuPopUpMsg
        
            menuRect        on entry, constraints on the menu's position; on exit, menu bounds
            hitPt           requested menu location, with swapped coordinates
            whichItem       on entry, requested initial selection; on exit, virtual menu top
            
            Sent when the Menu Manager is about to display a popup menu. The menu definition should
            calculate the appropriate menu bounds to contain the menu based on the requested menu
            location and selected item. It should write the menuBounds into the rect given by the
            menuRect parameter.
            
            If the gestaltMenuMgrSendsMenuBoundsToDefProc bit is set in the Menu Manager's Gestalt
            value, then the menuRect parameter on entry to this message contains a constraint rect,
            in global coordinates, outside of which the popup menu should not be positioned. The menu
            definition should take this constraint rect into account as it calculates the menu bounds.
            If the gestalt bit is not set, the menu definition should use the bounds of the GDevice
            containing the menu's top left corner as a constraint on the menu's position.
            
            The hitPt parameter is a requested location for the top left corner of the menu. The
            coordinates of this parameter are swapped from their normal order; the h field of the
            hitPt parameter contains the vertical coordinate, and the v field of hitPt contains
            the horizontal coordinate.
            
            On entry, the whichItem parameter points at a menu item index which is requested to be
            the initial selection when the menu is displayed. After calculating the menu's bounds,
            the menu definition should write the menu's virtual top coordinate into the location
            pointed at by the whichItem parameter. If displaying the menu at the requested location
            does not require scrolling, the virtual top will be the same as the menu bounds top;
            if the menu must scroll to fit in the requested location, the virtual top may be different.
            
        kMenuCalcItemMsg
        
            menuRect        on exit, item bounds
            hitPt           unused
            whichItem       the item whose rect to calculate
            
            Sent when the Menu Manager needs to know the bounds of a menu item. The menu definition
            should calculate the size of the item specified by the whichItem parameter, and store 
            the bounds in the rect specified by the menuRect parameter.
            
            Some sample menu definition code provided by Apple has previously shown an implementation
            of this message that always sets the top left corner of the item bounds to (0,0), regardless
            of the item's actual position in the menu. For best future compatibility, menu definitions
            should begin storing an item bounds that gives the item's actual position in the menu based
            on the menu's current virtual top. For example, if the virtual menu top starts at 20, then
            the menu definition would calculate an item bounds for the first item that starts at (0,20),
            an item bounds for the second item that starts at (0,40), and so on. The menu definition
            should call GetMenuTrackingData to get the menu's current virtual position, and use zero
            for the menu top if GetMenuTrackingData returns an error.
            
        kMenuThemeSavvyMsg
        
            menuRect        unused
            hitPt           unused
            whichItem       on exit, indicates theme-savvyness of the menu definition
            
            Sent by the Menu Manager to determine whether the MDEF uses the Appearance Manager 
            menu-drawing functions to draw its menu. If it does, the menu definition should return
            kThemeSavvyMenuResponse in the location pointed to by whichItem. If the menu definition
            draws its own custom content without using the Appearance Manager menu-drawing functions,
            it should ignore this message.
    
    Low-memory Global Replacements
    
        Pre-Carbon menu definitions needed to use several low-memory globals to communicate with the
        Menu Manager. These globals have all been replaced or made obsolete in Carbon, as follows:
        
        MenuDisable
            
            MenuDisable is now set automatically by the Menu Manager using the value returned in the
            itemUnderMouse field of the MenuTrackingData structure passed to kMenuFindItemMsg.
            
        TopMenuItem
        AtMenuBottom
        
            TopMenuItem and AtMenuBottom are now set automatically by the Menu Manager using the
            values returned in the virtualMenuTop and virtualMenuBottom fields of the MenuTrackingData
            structure passed to kMenuDrawMsg and kMenuFindItemMsg.
            
        mbSaveLoc
    
            This undocumented low-memory global was used by pre-Carbon menu definitions to store
            the bounding rect of the currently selected item and to avoid drawing glitches while
            the menu definition was scrolling the contents of a menu that had submenus. The Menu
            Manager now automatically sets the selected item bounds using the value returned in
            the itemRect field of the MenuTrackingData structure passed to kMenuFindItemMsg. In
            order to correctly support scrolling of menus with submenus, a menu definition should
            verify, before scrolling the menu contents, that no submenus of the scrolling menu are
            currently visible. A menu definition can use GetMenuTrackingData to verify this condition,
            as follows:
            
                Boolean SafeToScroll( MenuRef menuBeingScrolled )
                {
                    MenuTrackingData lastMenuData;
                    return GetMenuTrackingData( NULL, &lastMenuData ) == noErr
                           && lastMenuData.menu == menuBeingScrolled;
                }
            
            If SafeToScroll returns false, the menu definition should not scroll the menu.
*/
#endif  /* !__LP64__ */

enum {
                                        /* menu defProc messages */
  kMenuDrawMsg                  = 0,
  kMenuSizeMsg                  = 2,
  kMenuPopUpMsg                 = 3,    /* position the popup menu rect appropriately */
  kMenuCalcItemMsg              = 5,
  kMenuThemeSavvyMsg            = 7,    /* is your MDEF theme-savvy?  If so, return kThemeSavvyMenuResponse in the whichItem parameter*/
  kMenuInitMsg                  = 8,    /* Return an error code in *whichItem to indicate success or failure. Only supported in Carbon. */
  kMenuDisposeMsg               = 9,    /* The menu is being destroyed. Only supported in Carbon.*/
  kMenuFindItemMsg              = 10,   /* Determine which item is under the mouse. Only supported in Carbon.*/
  kMenuHiliteItemMsg            = 11,   /* Hilite the specified item. Only supported in Carbon.*/
  kMenuDrawItemsMsg             = 12,   /* Draw a range of items. Only supported in Carbon.*/
  mDrawMsg                      = kMenuDrawMsg, /* obsolete constant name*/
  mSizeMsg                      = kMenuSizeMsg, /* obsolete constant name*/
  mPopUpMsg                     = kMenuPopUpMsg, /* obsolete constant name*/
  mCalcItemMsg                  = kMenuCalcItemMsg /* obsolete constant name*/
};

#if CALL_NOT_IN_CARBON
/*
   Carbon MDEFs must replace mChooseMsg with the new messages kMenuFindItemMsg and kMenuHiliteItemMsg. 
   mDrawItemMsg was used by the popup menu control before 8.5, but is no longer used. 
*/
enum {
  mChooseMsg                    = 1,
  mDrawItemMsg                  = 4,
  kMenuChooseMsg                = mChooseMsg,
  kMenuDrawItemMsg              = mDrawItemMsg
};

#endif  /* CALL_NOT_IN_CARBON */

enum {
  kThemeSavvyMenuResponse       = 0x7473 /* should be returned in *whichItem when handling kMenuThemeSavvyMsg*/
};


/*
 *  MDEFHiliteItemData
 *  
 *  Summary:
 *    The MDEFHiliteItemData structure contains information about which
 *    menu items should be hilited and unhilited as the user moves
 *    through the menus. It is used by menu definition functions, which
 *    receive a pointer to an MDEFHiliteItemData structure as the
 *    whichItem parameter during kMenuHiliteItemMsg.
 */
struct MDEFHiliteItemData {

  /*
   * The item that was previously selected. It should be redrawn in an
   * unhilited state. May be zero if no item was previously selected.
   */
  MenuItemIndex       previousItem;

  /*
   * The item that is now selected. It should be redrawn in a hilited
   * state. May be zero if no item is now selected.
   */
  MenuItemIndex       newItem;

  /*
   * A CoreGraphics context that the MDEF should draw into. The Menu
   * Manager will flush the context after the MDEF has returned.
   */
  void *              context;
};
typedef struct MDEFHiliteItemData       MDEFHiliteItemData;
typedef MDEFHiliteItemData *            MDEFHiliteItemDataPtr;
typedef MDEFHiliteItemData              HiliteMenuItemData;
typedef MDEFHiliteItemDataPtr           HiliteMenuItemDataPtr;

/*
 *  MDEFDrawData
 *  
 *  Summary:
 *    The MDEFDrawData structure contains information needed to draw a
 *    menu. It is used by menu definition functions, which receive a
 *    pointer to an MDEFDrawData structure as the whichItem parameter
 *    during kMenuDrawMsg.
 */
struct MDEFDrawData {

  /*
   * Information about the menu being drawn. The MDEF should fill in
   * the virtualMenuTop and virtualMenuBottom fields of this structure
   * while drawing the menu.
   */
  MenuTrackingData    trackingData;

  /*
   * A CoreGraphics context that the MDEF should draw into. The Menu
   * Manager will flush the context after the MDEF has returned.
   */
  void *              context;
};
typedef struct MDEFDrawData             MDEFDrawData;
typedef MDEFDrawData *                  MDEFDrawDataPtr;

/*
 *  MDEFFindItemData
 *  
 *  Summary:
 *    The MDEFFindItemData structure contains information needed to
 *    determine which item is currently selected by the user. It is
 *    used by menu definition functions, which receive a pointer to an
 *    MDEFDrawData structure as the whichItem parameter during
 *    kMenuFindItemMsg.
 */
struct MDEFFindItemData {

  /*
   * Information about the menu being drawn. The MDEF should fill in
   * the itemSelected, itemUnderMouse, and itemRect fields of this
   * structure after determining which item is at the specified point.
   */
  MenuTrackingData    trackingData;

  /*
   * A CoreGraphics context that the MDEF should draw into if it needs
   * to scroll the menu during the FindItem message. The Menu Manager
   * will flush the context after the MDEF has returned.
   */
  void *              context;
};
typedef struct MDEFFindItemData         MDEFFindItemData;
typedef MDEFFindItemData *              MDEFFindItemDataPtr;

/*
 *  MDEFDrawItemsData
 *  
 *  Summary:
 *    The MDEFDrawItemsData structure contains information about which
 *    menu items to redraw. It is used by menu definition functions,
 *    which receive a pointer to an MDEFDrawItemsData structure as the
 *    whichItem parameter during kMenuDrawItemsMsg.
 */
struct MDEFDrawItemsData {

  /*
   * The first item to draw.
   */
  MenuItemIndex       firstItem;

  /*
   * The last item to draw.
   */
  MenuItemIndex       lastItem;

  /*
   * Information about the menu's tracking state. The virtualMenuTop
   * and virtualMenuBottom fields in this structure will be the most
   * useful in handling the DrawItems message.
   */
  MenuTrackingData *  trackingData;

  /*
   * A CoreGraphics context that the MDEF should draw into. The Menu
   * Manager will flush the context after the MDEF returns.
   */
  void *              context;
};
typedef struct MDEFDrawItemsData        MDEFDrawItemsData;
typedef MDEFDrawItemsData *             MDEFDrawItemsDataPtr;
/* obsolete menu color table constants*/
enum {
  mctAllItems                   = -98,  /*search for all Items for the given ID*/
  mctLastIDIndic                = -99   /*last color table entry has this in ID field*/
};

struct MCEntry {
  MenuID              mctID;                  /*menu ID.  ID = 0 is the menu bar*/
  short               mctItem;                /*menu Item. Item = 0 is a title*/
  RGBColor            mctRGB1;                /*usage depends on ID and Item*/
  RGBColor            mctRGB2;                /*usage depends on ID and Item*/
  RGBColor            mctRGB3;                /*usage depends on ID and Item*/
  RGBColor            mctRGB4;                /*usage depends on ID and Item*/
  short               mctReserved;            /*reserved for internal use*/
};
typedef struct MCEntry                  MCEntry;
typedef MCEntry *                       MCEntryPtr;
typedef MCEntry                         MCTable[1];
typedef MCEntry *                       MCTablePtr;
typedef MCTablePtr *                    MCTableHandle;
struct MenuCRsrc {
  short               numEntries;             /*number of entries*/
  MCTable             mcEntryRecs;            /*ARRAY [1..numEntries] of MCEntry*/
};
typedef struct MenuCRsrc                MenuCRsrc;
typedef MenuCRsrc *                     MenuCRsrcPtr;
typedef MenuCRsrcPtr *                  MenuCRsrcHandle;

/*
 */
enum {

  /*
   * Menu item command ID to indicate a hierarchical menu; the item
   * icon ID is the hierarchical menu ID. This constant is deprecated.
   * Use SetMenuItemHierarchicalID or SetMenuItemHierarchicalMenu
   * instead of using this constant.
   */
  hMenuCmd                      = 27,

  /*
   * A menu ID used with InsertMenu to insert a menu into the
   * hierarchical portion of the menubar. Rather than inserting menus
   * into the hierarchical portion of the menubar, we recommend that
   * your application use SetMenuItemHierarchicalMenu to directly
   * specify the submenu's MenuRef.
   */
  kInsertHierarchicalMenu       = -1,

  /*
   * The old name for kInsertHierarchicalMenu. This constant is
   * deprecated.
   */
  hierMenu                      = -1
};

#if !__LP64__
/*
 *  NewMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CreateNewMenu instead of NewMenu.
 *  
 *  Summary:
 *    Creates a new menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern MenuRef 
NewMenu(
  MenuID             menuID,
  ConstStr255Param   menuTitle)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetMenuTitle()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CopyMenuTitleAsCFString instead of GetMenuTitle.
 *  
 *  Summary:
 *    Retrieves the title of a menu as a Pascal string.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern StringPtr 
GetMenuTitle(
  MenuRef   menu,
  Str255    title)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetMenuTitle()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use SetMenuTitleWithCFString instead of SetMenuTitle.
 *  
 *  Summary:
 *    Sets the title of a menu to a Pascal string.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0 and later
 */
extern OSStatus 
SetMenuTitle(
  MenuRef            menu,
  ConstStr255Param   title)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  [Mac]AppendMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use AppendMenuItemTextWithCFString instead of AppendMenu. Note
 *    that unlike AppendMenu, AppendMenuItemTextWithCFString does not
 *    interpret metacharacters in the text.
 *  
 *  Summary:
 *    Appends a new menu item to a menu, using a Pascal string for the
 *    item's text.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacAppendMenu AppendMenu
#endif
extern void 
MacAppendMenu(
  MenuRef            menu,
  ConstStr255Param   data)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  [Mac]InsertMenuItem()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use InsertMenuItemTextWithCFString instead of InsertMenuItem.
 *    Note that unlike InsertMenuItem InsertMenuItemTextWithCFString
 *    does not interpret metacharacters in the text.
 *  
 *  Summary:
 *    Inserts a new menu item into a menu, using a Pascal string for
 *    the item text.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    theMenu:
 *      The menu into which to insert the item.
 *    
 *    itemString:
 *      The text of the new item. This string is parsed for the
 *      meta-characters documented in the Menu Manager chapter of
 *      Inside Macintosh.
 *    
 *    afterItem:
 *      The menu item after which to insert the item. Pass 0 to insert
 *      the item at the beginning of the menu. If afterItem is greater
 *      than the number of items in the menu, the item is inserted at
 *      the end of the menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
#if TARGET_OS_MAC
    #define MacInsertMenuItem InsertMenuItem
#endif
extern void 
MacInsertMenuItem(
  MenuRef            theMenu,
  ConstStr255Param   itemString,
  MenuItemIndex      afterItem)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  AppendMenuItemText()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use AppendMenuItemTextWithCFString instead of AppendMenuItemText.
 *  
 *  Summary:
 *    Appends a menu item using a Pascal string for the item's text,
 *    without interpreting metacharacters in the text.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
AppendMenuItemText(
  MenuRef            menu,
  ConstStr255Param   inString)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  InsertMenuItemText()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use InsertMenuItemTextWithCFString instead of InsertMenuItemText.
 *  
 *  Summary:
 *    Inserts a new menu item into a menu, using a Str255 for the item
 *    text.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    menu:
 *      The menu into which to insert the item.
 *    
 *    inString:
 *      The text of the new item. This string is not parsed for the
 *      meta-characters documented in the Menu Manager chapter of
 *      Inside Macintosh; the new item's text becomes exactly the
 *      specified text.
 *    
 *    afterItem:
 *      The menu item after which to insert the item. Pass 0 to insert
 *      the item at the beginning of the menu. If afterItem is greater
 *      than the number of items in the menu, the item is inserted at
 *      the end of the menu.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in MenusLib 8.5 and later
 */
extern OSStatus 
InsertMenuItemText(
  MenuRef            menu,
  ConstStr255Param   inString,
  MenuItemIndex      afterItem)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetMenuItemText()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use SetMenuItemTextWithCFString instead of SetMenuItemText.
 *  
 *  Summary:
 *    Sets the text of a menu item using a Pascal string.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetMenuItemText(
  MenuRef            theMenu,
  MenuItemIndex      item,
  ConstStr255Param   itemString)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetMenuItemText()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CopyMenuItemTextAsCFString instead of GetMenuItemText.
 *  
 *  Summary:
 *    Retrieves the text of a menu item as a Pascal string.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
GetMenuItemText(
  MenuRef         theMenu,
  MenuItemIndex   item,
  Str255          itemString)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetMenuItemTextEncoding()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use SetMenuItemTextWithCFString instead of setting an item's text
 *    as a Str255.
 *  
 *  Summary:
 *    Sets the text encoding that should be used to interpret a menu
 *    item's Pascal string-based text.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemTextEncoding(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  TextEncoding    inScriptID)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetMenuItemTextEncoding()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CopyMenuItemTextAsCFString instead of retrieving a menu
 *    item's text as a Str255.
 *  
 *  Summary:
 *    Retrieves the text encoding that should be used to interpret a
 *    menu item's Pascal string-based text.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemTextEncoding(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  TextEncoding *  outScriptID)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetItemIcon()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use SetMenuItemIconHandle instead of SetItemIcon.
 *  
 *  Summary:
 *    Sets the resource ID of an icon resource to be displayed in a
 *    menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetItemIcon(
  MenuRef         theMenu,
  MenuItemIndex   item,
  short           iconIndex)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetItemIcon()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use GetMenuItemIconHandle instead of GetItemIcon.
 *  
 *  Summary:
 *    Retrieves the resource ID of an icon resource to be displayed in
 *    a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
GetItemIcon(
  MenuRef         theMenu,
  MenuItemIndex   item,
  short *         iconIndex)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetMenuItemHierarchicalID()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use SetMenuItemHierarchicalMenu instead of
 *    SetMenuItemHierarchicalID.
 *  
 *  Summary:
 *    Sets the menu ID of the submenu of a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
SetMenuItemHierarchicalID(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  MenuID          inHierID)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetMenuItemHierarchicalID()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use GetMenuItemHierarchicalMenu instead of
 *    GetMenuItemHierarchicalID.
 *  
 *  Summary:
 *    Retrieves the menu ID of the submenu of a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in AppearanceLib 1.0 and later
 */
extern OSErr 
GetMenuItemHierarchicalID(
  MenuRef         inMenu,
  MenuItemIndex   inItem,
  MenuID *        outHierID)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetMenuRetainCount()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    In Mac OS X 10.2 and later, use CFGetRetainCount instead of
 *    GetMenuRetainCount.
 *  
 *  Summary:
 *    Returns the retain count of a menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose retain count to return.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern ItemCount 
GetMenuRetainCount(MenuRef inMenu)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  RetainMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    In Mac OS X 10.2 and later, use CFRetain instead of RetainMenu.
 *  
 *  Summary:
 *    Increments the retain count of a menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose retain count to increment.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
RetainMenu(MenuRef inMenu)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  ReleaseMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    In Mac OS X 10.2 and later, use CFRelease instead of ReleaseMenu.
 *  
 *  Summary:
 *    Decrements the retain count of a menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose retain count to decrement. If the retain count
 *      falls to zero, the menu is destroyed.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.1 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ReleaseMenu(MenuRef inMenu)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  InsertResMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The most comment use for this API has been to create a font menu
 *    containing the names of 'FOND' resources. For this purpose, use
 *    CreateStandardFontMenu, or use a font panel window instead of a
 *    menu.
 *  
 *  Summary:
 *    Inserts menu items containing the names of resources of a
 *    specified resource type.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
InsertResMenu(
  MenuRef         theMenu,
  ResType         theType,
  MenuItemIndex   afterItem)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  AppendResMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The most comment use for this API has been to create a font menu
 *    containing the names of 'FOND' resources. For this purpose, use
 *    CreateStandardFontMenu, or use a font panel window instead of a
 *    menu.
 *  
 *  Summary:
 *    Appends menu items containing the names of resources of a
 *    specified resource type.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
AppendResMenu(
  MenuRef   theMenu,
  ResType   theType)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  InsertFontResMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use CreateStandardFontMenu or a font panel window instead of
 *    InsertFontResMenu.
 *  
 *  Summary:
 *    Inserts menu items containing the names of font resources.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
InsertFontResMenu(
  MenuRef         theMenu,
  MenuItemIndex   afterItem,
  short           scriptFilter)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  InsertIntlResMenu()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The most comment use for this API has been to create a font menu
 *    containing the names of 'FOND' resources. For this purpose, use
 *    CreateStandardFontMenu, or use a font panel window instead of a
 *    menu.
 *  
 *  Summary:
 *    Inserts menu items containing the names of resources of a
 *    specified resource type.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
InsertIntlResMenu(
  MenuRef         theMenu,
  ResType         theType,
  MenuItemIndex   afterItem,
  short           scriptFilter)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  MenuKey()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use MenuEvent, IsMenuKeyEvent, or a kEventCommandProcess Carbon
 *    event handler instead of MenuKey.
 *  
 *  Summary:
 *    Determines if a character matches a menu item command key.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern SInt32 
MenuKey(CharParameter ch)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetMenuFlashCount()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    This function has no effect on Mac OS X.
 *  
 *  Summary:
 *    Sets the number of times that a selected menu item will blink.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.3 and later
 */
extern void 
SetMenuFlashCount(short count)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  InitContextualMenus()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    On Mac OS X, it is not necessary to call InitContextualMenus.
 *  
 *  Summary:
 *    Adds the current process to the system registry of contextual
 *    menu clients.
 *  
 *  Discussion:
 *    On Mac OS 8.x and 9.x, your program should call the
 *    InitContextualMenus function early in your startup code to
 *    register your application as a contextual menu client. If you do
 *    not register your program, some system-level functions may
 *    respond as though your program does not use contextual menus. Not
 *    registering your program may also cause
 *    ProcessIsContextualMenuClient to return an incorrect value.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in ContextualMenu 1.0 and later
 */
extern OSStatus 
InitContextualMenus(void)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  ProcessIsContextualMenuClient()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    There is no reason for an application to call this API.
 *  
 *  Summary:
 *    Determines whether the specified process is a contextual menu
 *    client.
 *  
 *  Discussion:
 *    On Mac OS 9, this API consults a global table of all processes
 *    that have registered with the Contextual Menu Manager by calling
 *    InitContextualMenus. On Mac OS X, this API ignores the inPSN
 *    parameter and always returns whether the current process is
 *    registered with the Contextual Menu Manager.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inPSN:
 *      The process to examine.
 *  
 *  Result:
 *    Whether the specified process (or, on Mac OS X, the current
 *    process) is registered with the Contextual Menu Manager.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in ContextualMenu 1.0 and later
 */
extern Boolean 
ProcessIsContextualMenuClient(ProcessSerialNumber * inPSN)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • Menu Item Color Tables                                                            */
/*                                                                                      */
/*  Menu color manipulation is considered deprecated with the advent of the Appearance  */
/*  Manager.  Avoid using these routines if possible                                    */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  DeleteMCEntries()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Mac OS X does not support menu color tables; this API has no
 *    effect.
 *  
 *  Summary:
 *    Removes color table entries for a menu.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
DeleteMCEntries(
  MenuID   menuID,
  short    menuItem)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetMCInfo()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Mac OS X does not support menu color tables; this API has no
 *    effect.
 *  
 *  Summary:
 *    Retrieves color table entries for the current process.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern MCTableHandle 
GetMCInfo(void)                                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetMCInfo()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Mac OS X does not support menu color tables; this API has no
 *    effect.
 *  
 *  Summary:
 *    Sets color table info for the current process.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetMCInfo(MCTableHandle menuCTbl)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  DisposeMCInfo()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Mac OS X does not support menu color tables; this API has no
 *    effect.
 *  
 *  Summary:
 *    Releases the memory used by a menu color table.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
DisposeMCInfo(MCTableHandle menuCTbl)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetMCEntry()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Mac OS X does not support menu color tables; this API has no
 *    effect.
 *  
 *  Summary:
 *    Returns a pointer to the menu color table entry for a menu item.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern MCEntryPtr 
GetMCEntry(
  MenuID   menuID,
  short    menuItem)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetMCEntries()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Mac OS X does not support menu color tables; this API has no
 *    effect.
 *  
 *  Summary:
 *    Sets entries in the menu color table for the current process.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
SetMCEntries(
  short        numEntries,
  MCTablePtr   menuCEntries)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*——————————————————————————————————————————————————————————————————————————————————————*/
/*  • MDEF support                                                                      */
/*——————————————————————————————————————————————————————————————————————————————————————*/
/*
 *  EraseMenuBackground()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    In Mac OS X 10.3 and later, use a custom HIView instead of a menu
 *    definition function to customize the appearance of a menu.
 *  
 *  Summary:
 *    Erases a portion of a menu background in preparation for further
 *    drawing.
 *  
 *  Discussion:
 *    It is necessary to erase the menu background before calling
 *    DrawThemeMenuBackground because some themes (such as Aqua on Mac
 *    OS X) draw the menu background using the alpha channel, and if
 *    the area underneath the menu background is not erased, portions
 *    of the old image will show through the menu background.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose background to erase.
 *    
 *    inEraseRect:
 *      The bounds of the area to erase, in local coordinates to the
 *      current port.
 *    
 *    inContext:
 *      The CG context to erase. If NULL, EraseMenuBackground will
 *      create a context based on the current port.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
EraseMenuBackground(
  MenuRef        inMenu,
  const Rect *   inEraseRect,
  CGContextRef   inContext)         /* can be NULL */         AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  ScrollMenuImage()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    In Mac OS X 10.3 and later, use a custom HIView instead of a menu
 *    definition function to customize the appearance of a menu.
 *  
 *  Summary:
 *    Scrolls a portion of the menu image.
 *  
 *  Discussion:
 *    Menus on Mac OS X use an alpha channel, and QuickDraw does not
 *    support alpha channels. Therefore, scrolling a menu image with
 *    ScrollRect or other QuickDraw APIs does not work correctly; it
 *    results in the destruction of the alpha channel data. The
 *    ScrollMenuImage API uses CoreGraphics to move the menu image,
 *    preserving the alpha channel.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Parameters:
 *    
 *    inMenu:
 *      The menu whose image to scroll.
 *    
 *    inScrollRect:
 *      The bounds of the rect to scroll.
 *    
 *    inHScroll:
 *      The distance to scroll horizontally.
 *    
 *    inVScroll:
 *      The distance to scroll vertically.
 *    
 *    inContext:
 *      The CG context to erase. If NULL, ScrollMenuImage will create a
 *      context based on the current port.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ScrollMenuImage(
  MenuRef        inMenu,
  const Rect *   inScrollRect,
  int            inHScroll,
  int            inVScroll,
  CGContextRef   inContext)          /* can be NULL */        AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


#endif  /* !__LP64__ */

typedef CALLBACK_API( long , MenuBarDefProcPtr )(short selector, short message, short parameter1, long parameter2);
typedef CALLBACK_API( void , MenuHookProcPtr )(void);
typedef CALLBACK_API( short , MBarHookProcPtr )(Rect * menuRect);
typedef STACK_UPP_TYPE(MenuBarDefProcPtr)                       MenuBarDefUPP;
typedef STACK_UPP_TYPE(MenuHookProcPtr)                         MenuHookUPP;
typedef STACK_UPP_TYPE(MBarHookProcPtr)                         MBarHookUPP;
/*
 *  NewMenuBarDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  NewMenuHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  NewMBarHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  DisposeMenuBarDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  DisposeMenuHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  DisposeMBarHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  InvokeMenuBarDefUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  InvokeMenuHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  InvokeMBarHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

#if OLDROUTINENAMES && !__LP64__
#define AddResMenu(theMenu, theType) AppendResMenu(theMenu, theType)
#define InsMenuItem(theMenu, itemString, afterItem) InsertMenuItem(theMenu, itemString, afterItem)
#define DelMenuItem( theMenu, item ) DeleteMenuItem( theMenu, item )
#if TARGET_OS_MAC
#define SetItem MacSetItem
#define GetItem MacGetItem
#endif
#define MacSetItem(theMenu, item, itemString) SetMenuItemText(theMenu, item, itemString)
#define MacGetItem(theMenu, item, itemString) GetMenuItemText(theMenu, item, itemString)
#define GetMHandle(menuID) GetMenuHandle(menuID)
#define DelMCEntries(menuID, menuItem) DeleteMCEntries(menuID, menuItem)
#define DispMCInfo(menuCTbl) DisposeMCInfo(menuCTbl)
#endif  /* OLDROUTINENAMES && !__LP64__ */



#if TARGET_OS_WIN32
#endif  /* TARGET_OS_WIN32 */


#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __MENUS__ */

                                                                                                                                                                                                                                                                                                                                                                              Menus.r                                                                                             0100644 0001750 0001750 00000032176 12566221370 042262  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       Menus.r
 
     Contains:   Menu Manager Interfaces.
 
     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved.
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/

#ifndef __MENUS_R__
#define __MENUS_R__

#ifndef __CORESERVICES_R__
#include <CoreServices/CoreServices.r>
#endif

#define kMenuStdMenuProc 				63
#define kMenuStdMenuBarProc 			63

#define kMenuNoModifiers 				0					/*  Mask for no modifiers */
#define kMenuShiftModifier 				0x01				/*  Mask for shift key modifier */
#define kMenuOptionModifier 			0x02				/*  Mask for option key modifier */
#define kMenuControlModifier 			0x04				/*  Mask for control key modifier */
#define kMenuNoCommandModifier 			0x08				/*  Mask for no command key modifier */

#define kMenuNoIcon 					0					/*  No icon */
#define kMenuIconType 					1					/*  Type for ICON */
#define kMenuShrinkIconType 			2					/*  Type for ICON plotted 16 x 16 */
#define kMenuSmallIconType 				3					/*  Type for SICN */
#define kMenuColorIconType 				4					/*  Type for cicn */
#define kMenuIconSuiteType 				5					/*  Type for Icon Suite */
#define kMenuIconRefType 				6					/*  Type for Icon Ref */
#define kMenuCGImageRefType 			7					/*  Type for a CGImageRef (Mac OS X only) */
#define kMenuSystemIconSelectorType 	8					/*  Type for an OSType identifying an IconRef registered with Icon Services under kSystemIconsCreator (Mac OS X 10.1 and later only) */
#define kMenuIconResourceType 			9					/*  Type for a CFStringRef with the full name of a .icns resource in the main bundle of the process (Mac OS X 10.1 and later only) */

#define kMenuNullGlyph 					0x00				/*  Null (always glyph 1) */
#define kMenuTabRightGlyph 				0x02				/*  Tab to the right key (for left-to-right script systems) */
#define kMenuTabLeftGlyph 				0x03				/*  Tab to the left key (for right-to-left script systems) */
#define kMenuEnterGlyph 				0x04				/*  Enter key */
#define kMenuShiftGlyph 				0x05				/*  Shift key */
#define kMenuControlGlyph 				0x06				/*  Control key */
#define kMenuOptionGlyph 				0x07				/*  Option key */
#define kMenuSpaceGlyph 				0x09				/*  Space (always glyph 3) key */
#define kMenuDeleteRightGlyph 			0x0A				/*  Delete to the right key (for right-to-left script systems) */
#define kMenuReturnGlyph 				0x0B				/*  Return key (for left-to-right script systems) */
#define kMenuReturnR2LGlyph 			0x0C				/*  Return key (for right-to-left script systems) */
#define kMenuNonmarkingReturnGlyph 		0x0D				/*  Nonmarking return key */
#define kMenuPencilGlyph 				0x0F				/*  Pencil key */
#define kMenuDownwardArrowDashedGlyph 	0x10				/*  Downward dashed arrow key */
#define kMenuCommandGlyph 				0x11				/*  Command key */
#define kMenuCheckmarkGlyph 			0x12				/*  Checkmark key */
#define kMenuDiamondGlyph 				0x13				/*  Diamond key */
#define kMenuAppleLogoFilledGlyph 		0x14				/*  Apple logo key (filled) */
#define kMenuParagraphKoreanGlyph 		0x15				/*  Unassigned (paragraph in Korean) */
#define kMenuDeleteLeftGlyph 			0x17				/*  Delete to the left key (for left-to-right script systems) */
#define kMenuLeftArrowDashedGlyph 		0x18				/*  Leftward dashed arrow key */
#define kMenuUpArrowDashedGlyph 		0x19				/*  Upward dashed arrow key */
#define kMenuRightArrowDashedGlyph 		0x1A				/*  Rightward dashed arrow key */
#define kMenuEscapeGlyph 				0x1B				/*  Escape key */
#define kMenuClearGlyph 				0x1C				/*  Clear key */
#define kMenuLeftDoubleQuotesJapaneseGlyph  0x1D			/*  Unassigned (left double quotes in Japanese) */
#define kMenuRightDoubleQuotesJapaneseGlyph  0x1E			/*  Unassigned (right double quotes in Japanese) */
#define kMenuTrademarkJapaneseGlyph 	0x1F				/*  Unassigned (trademark in Japanese) */
#define kMenuBlankGlyph 				0x61				/*  Blank key */
#define kMenuPageUpGlyph 				0x62				/*  Page up key */
#define kMenuCapsLockGlyph 				0x63				/*  Caps lock key */
#define kMenuLeftArrowGlyph 			0x64				/*  Left arrow key */
#define kMenuRightArrowGlyph 			0x65				/*  Right arrow key */
#define kMenuNorthwestArrowGlyph 		0x66				/*  Northwest arrow key */
#define kMenuHelpGlyph 					0x67				/*  Help key */
#define kMenuUpArrowGlyph 				0x68				/*  Up arrow key */
#define kMenuSoutheastArrowGlyph 		0x69				/*  Southeast arrow key */
#define kMenuDownArrowGlyph 			0x6A				/*  Down arrow key */
#define kMenuPageDownGlyph 				0x6B				/*  Page down key */
#define kMenuAppleLogoOutlineGlyph 		0x6C				/*  Apple logo key (outline) */
#define kMenuContextualMenuGlyph 		0x6D				/*  Contextual menu key */
#define kMenuPowerGlyph 				0x6E				/*  Power key */
#define kMenuF1Glyph 					0x6F				/*  F1 key */
#define kMenuF2Glyph 					0x70				/*  F2 key */
#define kMenuF3Glyph 					0x71				/*  F3 key */
#define kMenuF4Glyph 					0x72				/*  F4 key */
#define kMenuF5Glyph 					0x73				/*  F5 key */
#define kMenuF6Glyph 					0x74				/*  F6 key */
#define kMenuF7Glyph 					0x75				/*  F7 key */
#define kMenuF8Glyph 					0x76				/*  F8 key */
#define kMenuF9Glyph 					0x77				/*  F9 key */
#define kMenuF10Glyph 					0x78				/*  F10 key */
#define kMenuF11Glyph 					0x79				/*  F11 key */
#define kMenuF12Glyph 					0x7A				/*  F12 key */
#define kMenuF13Glyph 					0x87				/*  F13 key */
#define kMenuF14Glyph 					0x88				/*  F14 key */
#define kMenuF15Glyph 					0x89				/*  F15 key */
#define kMenuControlISOGlyph 			0x8A				/*  Control key (ISO standard) */
#define kMenuEjectGlyph 				0x8C				/*  Eject key (available on Mac OS X 10.2 and later) */
#define kMenuEisuGlyph 					0x8D				/*  Japanese eisu key (available in Mac OS X 10.4 and later) */
#define kMenuKanaGlyph 					0x8E				/*  Japanese kana key (available in Mac OS X 10.4 and later) */
#define kMenuF16Glyph 					0x8F				/*  F16 key (available in SnowLeopard and later) */
#define kMenuF17Glyph 					0x90				/*  F17 key (available in SnowLeopard and later) */
#define kMenuF18Glyph 					0x91				/*  F18 key (available in SnowLeopard and later) */
#define kMenuF19Glyph 					0x92				/*  F19 key (available in SnowLeopard and later) */

#define kMenuAttrExcludesMarkColumn 	0x01
#define kMenuAttrAutoDisable 			0x04
#define kMenuAttrUsePencilGlyph 		0x08
#define kMenuAttrHidden 				0x10
#define kMenuAttrCondenseSeparators 	0x20
#define kMenuAttrDoNotCacheImage 		0x40
#define kMenuAttrDoNotUseUserCommandKeys  0x80

#define kMenuItemAttrDisabled 			0x01
#define kMenuItemAttrIconDisabled 		0x02
#define kMenuItemAttrSubmenuParentChoosable  0x04
#define kMenuItemAttrDynamic 			0x08
#define kMenuItemAttrNotPreviousAlternate  0x10
#define kMenuItemAttrHidden 			0x20
#define kMenuItemAttrSeparator 			0x40
#define kMenuItemAttrSectionHeader 		0x80
#define kMenuItemAttrIgnoreMeta 		0x0100
#define kMenuItemAttrAutoRepeat 		0x0200
#define kMenuItemAttrUseVirtualKey 		0x0400
#define kMenuItemAttrCustomDraw 		0x0800
#define kMenuItemAttrIncludeInCmdKeyMatching  0x1000
#define kMenuItemAttrAutoDisable 		0x2000
#define kMenuItemAttrUpdateSingleItem 	0x4000

#define gestaltContextualMenuAttr 		'cmnu'
#define gestaltContextualMenuUnusedBit 	0
#define gestaltContextualMenuTrapAvailable  1
#define gestaltContextualMenuHasAttributeAndModifierKeys  2	/*  Contextual Menu Manager supports keyContextualMenuAttributes and keyContextualMenuModifiers  */
#define gestaltContextualMenuHasUnicodeSupport  3			/*  Contextual Menu Manager supports typeUnicodeText and typeCFStringRef  */

#define kCMHelpItemNoHelp 				0
#define kCMHelpItemAppleGuide 			1
#define kCMHelpItemOtherHelp 			2
#define kCMHelpItemRemoveHelp 			3

#define kCMNothingSelected 				0
#define kCMMenuItemSelected 			1
#define kCMShowHelpSelected 			3


/*----------------------------MENU • Menu-----------------------------------------------*/
type 'MENU' {
      integer;                                                /* Menu ID              */
     fill word[2];
      integer         textMenuProc = 0;                       /* ID of menu def proc  */
     fill word;
     unsigned hex bitstring[31]
                     allEnabled = 0x7FFFFFFF;                /* Enable flags         */
     boolean         disabled, enabled;                      /* Menu enable          */
     pstring         apple = "\0x14";                        /* Menu Title           */
     wide array {
               pstring;                                        /* Item title           */
             byte            noIcon;                         /* Icon number          */
             char            noKey = "\0x00",                /* Key equivalent or    */
                             hierarchicalMenu = "\0x1B";     /* hierarchical menu    */
             char            noMark = "\0x00",               /* Marking char or id   */
                             check = "\0x12";                /* of hierarchical menu */
             fill bit;
              unsigned bitstring[7]
                              plain;                          /* Style                */
     };
     byte = 0;
};

/*----------------------------MBAR • Menu Bar-------------------------------------------*/
type 'MBAR' {
      integer = $$CountOf(MenuArray);                         /* Number of menus      */
     wide array MenuArray{
              integer;                                        /* Menu resource ID     */
     };
};

/*----------------------------mctb • Menu Color Lookup Table----------------------------*/
type 'mctb' {
      integer = $$CountOf(MCTBArray);                         /* Color table count    */
     wide array MCTBArray {
         integer             mctbLast = -99;                 /* Menu resource ID     */
         integer;                                            /* Menu Item            */
         wide array [4] {
                   unsigned integer;                           /* RGB: red             */
                 unsigned integer;                           /*      green           */
                 unsigned integer;                           /*      blue            */
         };
         fill word;                                          /* Reserved word        */
     };
};


/*-------------------------------xmnu • Extended menu resource---------------------------*/
type 'xmnu'
{
 switch
 {
      case versionZero:
          key integer = 0;    /* version */

         integer = $$Countof(ItemExtensions);
           array ItemExtensions
           {
              switch
             {
                  case skipItem:
                     key integer=0;
                     
                   case dataItem:
                     key integer=1;
                     unsigned longint;                       /* Command ID */
                       unsigned hex byte;                      /* modifiers */
                        fill byte;                              /* icon type placeholder */
                        fill long;                              /* icon handle placeholder */
                      unsigned longint sysScript=-1,          /* text encoding */
                                         currScript=-2;         /*  (use currScript for default)*/
                     unsigned longint;                       /* refCon */
                       unsigned longint;                       /* refCon2 */
                      unsigned integer noHierID=0;            /* hierarchical menu ID */
                     unsigned integer sysFont=0;             /* font ID */
                      integer naturalGlyph=0;                 /* keyboard glyph */
               };
         };

        case versionOne:
           key integer = 1;    /* version */

         integer = $$Countof(ItemExtensions);
           array ItemExtensions
           {
              switch
             {
                  case skipItem:
                     key integer=0;
                     
                   case dataItem:
                     key integer=1;
                     unsigned longint;                       /* Command ID */
                       unsigned hex byte;                      /* modifiers */
                        unsigned hex byte noVKey=0;             /* virtual keycode for command key */
                      unsigned hex longint noAttributes=0;    /* MenuItemAttributes */
                       unsigned longint sysScript=-1,          /* text encoding */
                                         currScript=-2;         /*  (use currScript for default)*/
                     unsigned longint;                       /* refCon */
                       unsigned longint noIndent=0;            /* indent */
                       unsigned integer noHierID=0;            /* hierarchical menu ID */
                     unsigned integer sysFont=0;             /* font ID */
                      integer naturalGlyph=0;                 /* keyboard glyph */
               };
         };
 };
};

#if TARGET_OS_WIN32

/*----------------------------MENA • Menu Accessory Key---------------------------------*/
type 'MENA' {
      integer = $$CountOf(MenuArray);                         /* Number of keys       */
     longint;                                                /* flags                */
     wide array MenuArray{
              char;                                           /* key                  */
     };
};

#endif  /* TARGET_OS_WIN32 */


#endif /* __MENUS_R__ */

                                                                                                                                                                                                                                                                                                                                                                                                  Notification.h                                                                                      0100644 0001750 0001750 00000010155 12566221370 043600  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/Notification.h
 
     Contains:   Notification Manager interfaces
 
     Copyright:  © 1989-2008 by Apple Computer, Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __NOTIFICATION__
#define __NOTIFICATION__

#ifndef __CORESERVICES__
#include <CoreServices/CoreServices.h>
#endif


#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 2)

typedef struct NMRec                    NMRec;
typedef NMRec *                         NMRecPtr;
typedef CALLBACK_API( void , NMProcPtr )(NMRecPtr nmReqPtr);
typedef STACK_UPP_TYPE(NMProcPtr)                               NMUPP;
struct NMRec {
  QElemPtr            qLink;                  /* next queue entry*/
  short               qType;                  /* queue type -- ORD(nmType) = 8*/
  short               nmFlags;                /* reserved*/
  SRefCon             nmPrivate;              /* reserved*/
  short               nmReserved;             /* reserved*/
  short               nmMark;                 /* item to mark in Apple menu*/
  Handle              nmIcon;                 /* handle to small icon*/
  Handle              nmSound;                /* handle to sound record*/
  StringPtr           nmStr;                  /* string to appear in alert*/
  NMUPP               nmResp;                 /* pointer to response routine*/
  SRefCon             nmRefCon;               /* for application use*/
};

/*
 *  NewNMUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern NMUPP
NewNMUPP(NMProcPtr userRoutine)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*
 *  DisposeNMUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeNMUPP(NMUPP userUPP)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

/*
 *  InvokeNMUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeNMUPP(
  NMRecPtr  nmReqPtr,
  NMUPP     userUPP)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;

#if __MACH__
  #ifdef __cplusplus
    inline NMUPP                                                NewNMUPP(NMProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeNMUPP(NMUPP) { }
    inline void                                                 InvokeNMUPP(NMRecPtr nmReqPtr, NMUPP userUPP) { (*userUPP)(nmReqPtr); }
  #else
    #define NewNMUPP(userRoutine)                               ((NMUPP)userRoutine)
    #define DisposeNMUPP(userUPP)
    #define InvokeNMUPP(nmReqPtr, userUPP)                      (*userUPP)(nmReqPtr)
  #endif
#endif

#if !__LP64__
/*
 *  NMInstall()
 *  
 *  Mac OS X threading:
 *    Thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
NMInstall(NMRecPtr nmReqPtr)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  NMRemove()
 *  
 *  Mac OS X threading:
 *    Thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
NMRemove(NMRecPtr nmReqPtr)                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;



#endif  /* !__LP64__ */


#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __NOTIFICATION__ */

                                                                                                                                                                                                                                                                                                                                                                                                                   Scrap.h                                                                                             0100644 0001750 0001750 00000054650 12566221370 042232  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/Scrap.h
 
     Contains:   Scrap Manager Interfaces.
 
     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __SCRAP__
#define __SCRAP__

#ifndef __CORESERVICES__
#include <CoreServices/CoreServices.h>
#endif


#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 2)

/*
    ________________________________________________________________
    UNIVERSAL SCRAP MANAGER INTERFACES
    ________________________________________________________________
    The following interfaces are available when compiling for BOTH
    Carbon AND Mac OS 8.
    ________________________________________________________________
*/
/*
    While we're in here mucking about, we defined a new type to
    to put some confusion to rest. The old calls, as well as the
    new calls, use the new type. Existing clients should be
    blissfully ignorant.
*/

typedef FourCharCode                    ScrapFlavorType;
enum {
  kScrapFlavorTypePicture       = 'PICT', /* contents of a PicHandle*/
  kScrapFlavorTypeText          = 'TEXT', /* stream of characters*/
  kScrapFlavorTypeTextStyle     = 'styl', /* see TEGetStyleScrapHandle*/
  kScrapFlavorTypeMovie         = 'moov', /* reference to a movie*/
  kScrapFlavorTypeSound         = 'snd ', /* see SndRecord and SndPlay*/
  kScrapFlavorTypeUnicode       = 'utxt', /* stream of UTF16 characters (internal representation)*/
  kScrapFlavorTypeUTF16External = 'ut16', /* stream of UTF16 characters (external representation)*/
  kScrapFlavorTypeUnicodeStyle  = 'ustl' /* ATSUI defines; Textension uses*/
};

/*
    If you are a Carbon client and you need to run on Mac OS 8,
    you may still need to load and unload the scrap. Under Mac OS
    X, the scrap is held by the pasteboard server instead of in a
    handle in your app's heap, so LoadScrap and UnloadScrap do
    nothing when called under Mac OS X.
*/

#if !__LP64__
/*
 *  LoadScrap()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    LoadScrap does nothing on Mac OS X.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSStatus 
LoadScrap(void)                                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  UnloadScrap()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    UnloadScrap does nothing on Mac OS X.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSStatus 
UnloadScrap(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    ________________________________________________________________
    CARBON SCRAP MANAGER INTERFACES
    ________________________________________________________________
    The following interfaces are available only when compiling for
    Carbon.
    ________________________________________________________________
*/

/*
    When promising a scrap flavor, it's OK if you
    don't yet know how big the flavor data will be.
    In this case, just pass kScrapFlavorSizeUnknown
    for the flavor data size.
*/

#endif  /* !__LP64__ */

enum {
  kScrapFlavorSizeUnknown       = -1
};

/*
    kScrapReservedFlavorType is a flavor type which is reserved
    for use by Scrap Manager. If you pass it to Scrap Manager,
    it will be rejected.
*/

enum {
  kScrapReservedFlavorType      = 'srft'
};

/*
    We've added scrap flavor flags ala Drag Manager.

    kScrapFlavorMaskNone means you want none of the flags.

    kScrapFlavorSenderOnlyMask means only the process which
    put the flavor on the scrap can see it. If some other
    process put a flavor with this flag on the scrap,
    your process will never see the flavor, so there's
    no point in testing for this flag.

    kScrapFlavorTranslated means the flavor was translated
    from some other flavor in the scrap by Translation Manager.
    Most callers should not care about this bit.
*/
enum {
  kScrapFlavorMaskNone          = 0x00000000,
  kScrapFlavorMaskSenderOnly    = 0x00000001,
  kScrapFlavorMaskTranslated    = 0x00000002
};

typedef UInt32                          ScrapFlavorFlags;
/*
    ScrapFlavorInfo describes a single flavor within
    a scrap.
*/
struct ScrapFlavorInfo {
  ScrapFlavorType     flavorType;
  ScrapFlavorFlags    flavorFlags;
};
typedef struct ScrapFlavorInfo          ScrapFlavorInfo;
typedef struct OpaqueScrapRef*          ScrapRef;
/*
    kScrapRefNone is guaranteed to be an invalid ScrapRef.  This 
    is convenient when initializing application variables.
*/
#define kScrapRefNone                   ((ScrapRef)NULL)
/*
    Defined Apple scrap names for GetScrapByName
    kScrapClipboardScrap    traditional clipboard scrap
    kScrapFindScrap         compatible with Cocoa's global find scrap
*/
#define kScrapClipboardScrap            CFSTR("com.apple.scrap.clipboard")
#define kScrapFindScrap                 CFSTR("com.apple.scrap.find")

/*  Enumerated options to be passed to GetScrapByName*/

enum {
  kScrapGetNamedScrap           = 0,    /* get current named scrap without bumping*/
  kScrapClearNamedScrap         = (1L << 0) /* acquire the named scrap, bumping and clearing*/
};

/*
    GetScrapByName allows access to an indefinite number of public or private
    scraps.  The constant kScrapClipboardScrap refers to the "current" scrap
    we've all come to know and love.  kScrapFindScrap allows Carbon apps to
    interact seamlessly with Cocoa's global find scrap.  Note that calling:

        GetScrapByName( kScrapClipboardScrap, kScrapGetNamedScrap, &scrap );

    is an exact match to the call:
    
        GetCurrentScrap( &scrap );

    Additionally, a call to:

        GetScrapByName( kScrapClipboardScrap, kScrapClearNamedScrap, &scrap );

    is a replacement for the sequence:
    
        ClearCurrentScrap();
        GetCurrentScrap( &scrap );

    You can use this API to generate your own private scraps to use as a high
    level interprocess communication between your main and helper apps.  The Java
    naming convention is suggested for your scraps ( ie. com.joeco.scrap.secret ).
    
    CarbonLib does not support arbitrary named scraps; when calling this API on
    CarbonLib, kScrapClipboardScrap is the only supported value for the name parameter.
*/
#if !__LP64__
/*
 *  GetScrapByName()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardCreate instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetScrapByName(
  CFStringRef   name,
  OptionBits    options,
  ScrapRef *    scrap)                                        AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    GetCurrentScrap obtains a reference to the current scrap.
    The ScrapRef obtained via GetCurrentScrap will become
    invalid and unusable after the scrap is cleared.
*/

/*
 *  GetCurrentScrap()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardCreate instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetCurrentScrap(ScrapRef * scrap)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    GetScrapFlavorFlags tells you [a] whether the scrap contains
    data for a particular flavor and [b] some things about that
    flavor if it exists. This call never blocks, and is useful
    for deciding whether to enable the Paste item in your Edit
    menu, among other things.
*/

/*
 *  GetScrapFlavorFlags()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardGetItemFlavorFlags
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetScrapFlavorFlags(
  ScrapRef            scrap,
  ScrapFlavorType     flavorType,
  ScrapFlavorFlags *  flavorFlags)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    GetScrapFlavorSize gets the size of the data of the specified
    flavor. This function blocks until the specified flavor
    data is available. GetScrapFlavorSize is intended as a prelude
    to allocating memory and calling GetScrapFlavorData.
*/

/*
 *  GetScrapFlavorSize()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardCopyItemFlavorData
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetScrapFlavorSize(
  ScrapRef          scrap,
  ScrapFlavorType   flavorType,
  Size *            byteCount)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    GetScrapFlavorData gets the data from the specified flavor in the
    specified scrap. This function blocks until the specified flavor
    data is available. Specify the maximum size your buffer can contain;
    on output, this function produces the number of bytes that were
    available (even if this is more than you requested).
*/

/*
 *  GetScrapFlavorData()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardCopyItemFlavorData
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetScrapFlavorData(
  ScrapRef          scrap,
  ScrapFlavorType   flavorType,
  Size *            byteCount,
  void *            destination)                              AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    ClearCurrentScrap clears the current scrap. Call this
    first when the user requests a Copy or Cut operation --
    even if you maintain a private scrap! You should not wait
    until receiving a suspend event to call ClearCurrentScrap. Call
    it immediately after the user requests a Copy or Cut operation.
    You don't need to put any data on the scrap immediately (although
    it's perfectly fine to do so). You DO need to call GetCurrentScrap
    after ClearCurrentScrap so you'll have a valid ScrapRef to pass
    to other functions.
*/

/*
 *  ClearCurrentScrap()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardClear instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ClearCurrentScrap(void)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
        ClearScrap will clear the scrap passed in and return the bumped
        ScrapRef value. ClearScrap behaves similarly to GetScrapByName
        when called with the kScrapClearNamedScrap option with the
        benefit of not requiring a name in the event one is not available.
        
        CarbonLib does not support arbitrary named scraps; when calling this
        API on CarbonLib, only clearing the current scrap is supported.
*/
/*
 *  ClearScrap()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardClear instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.1 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.5 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
ClearScrap(ScrapRef * inOutScrap)                             AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;



/*
        PutScrapFlavor is a lot like PutScrap, with two differences:
        we added a ScrapRef parameter at the beginning and you can
        "promise" various aspects of a flavor. If you pass a NIL
        data pointer, this is a promise that in the future you
        will provide data for this flavor. Provide the data
        through a subsequent call to PutScrapFlavor, either later
        in the same code flow or during a scrap promise keeper proc.
        If you know how big the data is, you can pass the size as
        well, and this may allow subsequent callers of GetScrapFlavorInfo
        to avoid blocking. If you don't know the size, pass -1.
        If you pass a 0 size, you are telling Scrap Manager not to
        expect any data for this flavor. In this case, the flavor
        data pointer is ignored. NOTE: the last time you can provide
        scrap flavor data is when your scrap promise keeper gets
        called. It is NOT possible to call PutScrapFlavor while
        handling a suspend event; suspend events under Carbon
        simply don't work the way they do under Mac OS 8.

        The method for setting Scrap Manager promises differs from that for Drag Manger promises.
        This chart describes the method for setting scrap promises via PutScrapFlavor().
    
        dataPtr         dataSize                                result
     pointer value  actual data size    The data of size dataSize pointed to by dataPtr is added to the scrap.
           0        actual data size    A promise for data of size dataSize is placed on the scrap.
           0               -1           A promise for data of an undetermined size is placed on the scrap.
        ignored             0           A flavor with no data expected is placed on the scrap.  This is not a promise.
*/
/*
 *  PutScrapFlavor()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardPutItemFlavor
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
PutScrapFlavor(
  ScrapRef           scrap,
  ScrapFlavorType    flavorType,
  ScrapFlavorFlags   flavorFlags,
  Size               flavorSize,
  const void *       flavorData)        /* can be NULL */     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    ScrapPromiseKeeper is a function you write which is called by
    Scrap Manager as needed to keep your earlier promise of a
    particular scrap flavor. When your function is called, deliver
    the requested data by calling PutScrapFlavor.
*/

#endif  /* !__LP64__ */

typedef CALLBACK_API( OSStatus , ScrapPromiseKeeperProcPtr )(ScrapRef scrap, ScrapFlavorType flavorType, void *userData);
typedef STACK_UPP_TYPE(ScrapPromiseKeeperProcPtr)               ScrapPromiseKeeperUPP;
/*
 *  NewScrapPromiseKeeperUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern ScrapPromiseKeeperUPP
NewScrapPromiseKeeperUPP(ScrapPromiseKeeperProcPtr userRoutine) AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  DisposeScrapPromiseKeeperUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeScrapPromiseKeeperUPP(ScrapPromiseKeeperUPP userUPP)   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

/*
 *  InvokeScrapPromiseKeeperUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern OSStatus
InvokeScrapPromiseKeeperUPP(
  ScrapRef               scrap,
  ScrapFlavorType        flavorType,
  void *                 userData,
  ScrapPromiseKeeperUPP  userUPP)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;

#if __MACH__
  #ifdef __cplusplus
    inline ScrapPromiseKeeperUPP                                NewScrapPromiseKeeperUPP(ScrapPromiseKeeperProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeScrapPromiseKeeperUPP(ScrapPromiseKeeperUPP) { }
    inline OSStatus                                             InvokeScrapPromiseKeeperUPP(ScrapRef scrap, ScrapFlavorType flavorType, void * userData, ScrapPromiseKeeperUPP userUPP) { return (*userUPP)(scrap, flavorType, userData); }
  #else
    #define NewScrapPromiseKeeperUPP(userRoutine)               ((ScrapPromiseKeeperUPP)userRoutine)
    #define DisposeScrapPromiseKeeperUPP(userUPP)
    #define InvokeScrapPromiseKeeperUPP(scrap, flavorType, userData, userUPP) (*userUPP)(scrap, flavorType, userData)
  #endif
#endif

/*
    SetScrapPromiseKeeper associates a ScrapPromiseKeeper with a
    scrap. You can remove a ScrapPromiseKeeper from a scrap by
    passing a NIL ScrapPromiseKeeper to SetScrapPromiseKeeper.
    Pass whatever you like in the last parameter; its value will
    be passed to your ScrapPromiseKeeper, which can do whatever
    it likes with the value. You might choose to pass a pointer
    or handle to some private scrap data which the
    ScrapPromiseKeeper could use in fabricating one or more
    promised flavors.
*/
#if !__LP64__
/*
 *  SetScrapPromiseKeeper()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardSetPromiseKeeper
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SetScrapPromiseKeeper(
  ScrapRef                scrap,
  ScrapPromiseKeeperUPP   upp,
  const void *            userData)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    GetScrapFlavorCount produces the number of
    items which can be obtained by GetScrapFlavorInfoList.
*/

/*
 *  GetScrapFlavorCount()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardCopyItemFlavors
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetScrapFlavorCount(
  ScrapRef   scrap,
  UInt32 *   infoCount)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
    GetScrapFlavorInfoList fills a list (array)
    of items which each describe the corresponding
    flavor in the scrap. It fills no more array
    elements as are specified. On exit, it produces
    the count of elements it filled (which may be
    smaller than the count requested). Yes, YOU
    must provide the memory for the array.
*/

/*
 *  GetScrapFlavorInfoList()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardCopyItemFlavors
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
GetScrapFlavorInfoList(
  ScrapRef          scrap,
  UInt32 *          infoCount,
  ScrapFlavorInfo   info[])                                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;



/*
    CallInScrapPromises forces all promises to be kept.
    If your application promises at least one flavor
    AND it does NOT adopt the new event model, you
    should call this function when your application
    is about to quit. If your app promises no flavors,
    there is no need to call this function, and if
    your app adopts the new event model, this function
    will be called automagically for you. It doesn't
    hurt to call this function more than once, though
    promise keepers may be asked to keep promises
    they already tried and failed.
*/

/*
 *  CallInScrapPromises()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    The Scrap Manager is deprecated. Use PasteboardResolvePromises
 *    instead.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
CallInScrapPromises(void)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


#endif  /* !__LP64__ */


#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __SCRAP__ */

                                                                                        TSMTE.h                                                                                             0100644 0001750 0001750 00000023450 12566221370 042050  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/TSMTE.h
 
     Contains:   Text Services Manager for TextEdit Interfaces. All TextEdit functions as well all functions in
 
     Copyright:  © 1991-2008 by Apple Computer, Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
/*****************************************************************************************************************
    
    All Textedit functions as well all functions in this file are deprecated for Mac OS 10.4. The Multilingual Text 
    Engine (MLTE) API is recommended instead. MLTE support for inline input is built-in so there is no need for an 
    API parallel to TSMTE on Mac OS X. Please see MacTextEditor.h file for a description of the MLTE API.

******************************************************************************************************************/
#ifndef __TSMTE__
#define __TSMTE__

#ifndef __TEXTEDIT__
#include <HIToolbox/TextEdit.h>
#endif

#ifndef __DIALOGS__
#include <HIToolbox/Dialogs.h>
#endif

#ifndef __TEXTSERVICES__
#include <HIToolbox/TextServices.h>
#endif

#include <ApplicationServices/ApplicationServices.h>
#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 2)

/* signature, interface types*/
enum {
  kTSMTESignature               = 'tmTE',
  kTSMTEInterfaceType           = kTSMTEDocumentInterfaceType
};

/*
    In Carbon, since DialogRef is opaque, the TSMDialogRecord is removed.
    Only one kind of TSMTE dialog remains, with extended data managed by TSMTE.
    Use kTSMTESignature for the dialog refCon, and use the accessors below,
    i.e. GetTSMTEDialogTSMTERecHandle, to get at the old TSMDialogRecord info.
*/
#if CALL_NOT_IN_CARBON
enum {
  kTSMTEDialog                  = 'tmDI'
};

#endif  /* CALL_NOT_IN_CARBON */

/* update flag for TSMTERec*/
enum {
  kTSMTEAutoScroll              = 1
};


/* callback procedure definitions*/

typedef CALLBACK_API( void , TSMTEPreUpdateProcPtr )(TEHandle textH, long refCon);
typedef CALLBACK_API( void , TSMTEPostUpdateProcPtr )(TEHandle textH, long fixLen, long inputAreaStart, long inputAreaEnd, long pinStart, long pinEnd, long refCon);
typedef STACK_UPP_TYPE(TSMTEPreUpdateProcPtr)                   TSMTEPreUpdateUPP;
typedef STACK_UPP_TYPE(TSMTEPostUpdateProcPtr)                  TSMTEPostUpdateUPP;
/* data types*/
struct TSMTERec {
  TEHandle            textH;
  TSMTEPreUpdateUPP   preUpdateProc;
  TSMTEPostUpdateUPP  postUpdateProc;
  long                updateFlag;
  long                refCon;
};
typedef struct TSMTERec                 TSMTERec;
typedef TSMTERec *                      TSMTERecPtr;
typedef TSMTERecPtr *                   TSMTERecHandle;
/*
 *  NewTSMTEPreUpdateUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TSMTEPreUpdateUPP
NewTSMTEPreUpdateUPP(TSMTEPreUpdateProcPtr userRoutine)       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewTSMTEPostUpdateUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TSMTEPostUpdateUPP
NewTSMTEPostUpdateUPP(TSMTEPostUpdateProcPtr userRoutine)     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTSMTEPreUpdateUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTSMTEPreUpdateUPP(TSMTEPreUpdateUPP userUPP)           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTSMTEPostUpdateUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTSMTEPostUpdateUPP(TSMTEPostUpdateUPP userUPP)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTSMTEPreUpdateUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeTSMTEPreUpdateUPP(
  TEHandle           textH,
  long               refCon,
  TSMTEPreUpdateUPP  userUPP)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTSMTEPostUpdateUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeTSMTEPostUpdateUPP(
  TEHandle            textH,
  long                fixLen,
  long                inputAreaStart,
  long                inputAreaEnd,
  long                pinStart,
  long                pinEnd,
  long                refCon,
  TSMTEPostUpdateUPP  userUPP)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

#if __MACH__
  #ifdef __cplusplus
    inline TSMTEPreUpdateUPP                                    NewTSMTEPreUpdateUPP(TSMTEPreUpdateProcPtr userRoutine) { return userRoutine; }
    inline TSMTEPostUpdateUPP                                   NewTSMTEPostUpdateUPP(TSMTEPostUpdateProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeTSMTEPreUpdateUPP(TSMTEPreUpdateUPP) { }
    inline void                                                 DisposeTSMTEPostUpdateUPP(TSMTEPostUpdateUPP) { }
    inline void                                                 InvokeTSMTEPreUpdateUPP(TEHandle textH, long refCon, TSMTEPreUpdateUPP userUPP) { (*userUPP)(textH, refCon); }
    inline void                                                 InvokeTSMTEPostUpdateUPP(TEHandle textH, long fixLen, long inputAreaStart, long inputAreaEnd, long pinStart, long pinEnd, long refCon, TSMTEPostUpdateUPP userUPP) { (*userUPP)(textH, fixLen, inputAreaStart, inputAreaEnd, pinStart, pinEnd, refCon); }
  #else
    #define NewTSMTEPreUpdateUPP(userRoutine)                   ((TSMTEPreUpdateUPP)userRoutine)
    #define NewTSMTEPostUpdateUPP(userRoutine)                  ((TSMTEPostUpdateUPP)userRoutine)
    #define DisposeTSMTEPreUpdateUPP(userUPP)
    #define DisposeTSMTEPostUpdateUPP(userUPP)
    #define InvokeTSMTEPreUpdateUPP(textH, refCon, userUPP)     (*userUPP)(textH, refCon)
    #define InvokeTSMTEPostUpdateUPP(textH, fixLen, inputAreaStart, inputAreaEnd, pinStart, pinEnd, refCon, userUPP) (*userUPP)(textH, fixLen, inputAreaStart, inputAreaEnd, pinStart, pinEnd, refCon)
  #endif
#endif

#if !__LP64__
/*
 *  IsTSMTEDialog()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0.2 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0.2 and later
 */
extern Boolean 
IsTSMTEDialog(DialogRef dialog)                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/* Getters */
/*
 *  GetTSMTEDialogDocumentID()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0.2 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0.2 and later
 */
extern TSMDocumentID 
GetTSMTEDialogDocumentID(DialogRef dialog)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  GetTSMTEDialogTSMTERecHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0.2 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0.2 and later
 */
extern TSMTERecHandle 
GetTSMTEDialogTSMTERecHandle(DialogRef dialog)                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/* Setters */
/*
 *  SetTSMTEDialogDocumentID()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0.2 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0.2 and later
 */
extern void 
SetTSMTEDialogDocumentID(
  DialogRef       dialog,
  TSMDocumentID   documentID)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  SetTSMTEDialogTSMTERecHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0.2 and later
 *    Non-Carbon CFM:   in CarbonAccessors.o 1.0.2 and later
 */
extern void 
SetTSMTEDialogTSMTERecHandle(
  DialogRef        dialog,
  TSMTERecHandle   tsmteRecHandle)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


#endif  /* !__LP64__ */


#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __TSMTE__ */

                                                                                                                                                                                                                        TextEdit.h                                                                                          0100644 0001750 0001750 00000230466 12566221370 042715  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/TextEdit.h
 
     Contains:   TextEdit Interfaces.
 
     Copyright:  © 1985-2008 by Apple Computer, Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
/************************************************************************************************
    All functions in this file are deprecated for Mac OS 10.4. The Multilingual Text Engine (MLTE) 
    API is recommended instead. Although there is no one-to-one correspondence between the two API, 
    MLTE should be used instead of TE since it provides support for Unicode text. MLTE uses ATSUI 
    for text layout and Quartz for text rendering. Please see MacTextEditor.h for a description of
    the MLTE API. 
**************************************************************************************************/

#ifndef __TEXTEDIT__
#define __TEXTEDIT__

#ifndef __APPLICATIONSERVICES__
#include <ApplicationServices/ApplicationServices.h>
#endif


#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 2)

typedef struct TERec                    TERec;
typedef TERec *                         TEPtr;
typedef TEPtr *                         TEHandle;
typedef CALLBACK_API( void , HighHookProcPtr )(const Rect *r, TEPtr pTE);
typedef CALLBACK_API( Boolean , EOLHookProcPtr )(char theChar, TEPtr pTE, TEHandle hTE);
typedef CALLBACK_API( void , CaretHookProcPtr )(const Rect *r, TEPtr pTE);
typedef CALLBACK_API( unsigned short , WidthHookProcPtr )(unsigned short textLen, unsigned short textOffset, void *textBufferPtr, TEPtr pTE, TEHandle hTE);
typedef CALLBACK_API( unsigned short , TextWidthHookProcPtr )(unsigned short textLen, unsigned short textOffset, void *textBufferPtr, TEPtr pTE, TEHandle hTE);
typedef CALLBACK_API( unsigned short , NWidthHookProcPtr )(unsigned short styleRunLen, unsigned short styleRunOffset, short slop, short direction, void *textBufferPtr, short *lineStart, TEPtr pTE, TEHandle hTE);
typedef CALLBACK_API( void , DrawHookProcPtr )(unsigned short textOffset, unsigned short drawLen, void *textBufferPtr, TEPtr pTE, TEHandle hTE);
typedef CALLBACK_API( Boolean , HitTestHookProcPtr )(unsigned short styleRunLen, unsigned short styleRunOffset, unsigned short slop, void *textBufferPtr, TEPtr pTE, TEHandle hTE, unsigned short *pixelWidth, unsigned short *charOffset, Boolean *pixelInChar);
typedef CALLBACK_API( void , TEFindWordProcPtr )(unsigned short currentPos, short caller, TEPtr pTE, TEHandle hTE, unsigned short *wordStart, unsigned short *wordEnd);
typedef CALLBACK_API( void , TERecalcProcPtr )(TEPtr pTE, unsigned short changeLength, unsigned short *lineStart, unsigned short *firstChar, unsigned short *lastChar);
typedef CALLBACK_API( void , TEDoTextProcPtr )(TEPtr pTE, unsigned short firstChar, unsigned short lastChar, short selector, GrafPtr *currentGrafPort, short *charPosition);
typedef CALLBACK_API( Boolean , TEClickLoopProcPtr )(TEPtr pTE);
typedef CALLBACK_API( Boolean , WordBreakProcPtr )(Ptr text, short charPos);
/* 
    Important note about TEClickLoopProcPtr and WordBreakProcPtr

    At one point these were defined as returning the function result in the 
    condition code Z-bit.  This was correct, in that it was what the 68K
    implementation of TextEdit actually tested.  But, MixedMode had a different 
    idea of what returning a boolean in the Z-bit meant.  MixedMode was setting
    the Z-bit the complement of what was wanted.  
    
    Therefore, these ProcPtrs have been changed (back) to return the result in
    register D0.  It turns out that for register based routines, 
    MixedMode sets the Z-bit of the 68K emulator based on the contents 
    of the return result register.  Thus we can get the Z-bit set correctly.  
    
    But, when TextEdit is recoded in PowerPC, if it calls a 68K ClickLoop
    or WordBreak routine, register D0 had better have the result (in addition
    to the Z-bit). Therefore all 68K apps should make sure their ClickLoop or
    WordBreak routines set register D0 at the end.
*/

/* 
    There is no function to get/set the low-mem for FindWordHook at 0x07F8.
    This is because it is not a low-mem ProcPtr. That address is the entry
    in the OS TrapTable for trap 0xA0FE.  You can use Get/SetTrapAddress to 
    acccess it. 
*/

/*
    The following ProcPtrs cannot be written in or called from a high-level 
    language without the help of mixed mode or assembly glue because they 
    use the following parameter-passing conventions:

    typedef pascal void (*HighHookProcPtr)(const Rect *r, TEPtr pTE);
    typedef pascal void (*CaretHookProcPtr)(const Rect *r, TEPtr pTE);

        In:
            =>  r                       on stack
            =>  pTE                     A3.L
        Out:
            none

    typedef pascal Boolean (*EOLHookProcPtr)(char theChar, TEPtr pTE, TEHandle hTE);

        In:
            =>  theChar                 D0.B
            =>  pTE                     A3.L
            =>  hTE                     A4.L
        Out:
            <=  Boolean                 Z bit of the CCR

    typedef pascal unsigned short (*WidthHookProcPtr)(unsigned short textLen,
     unsigned short textOffset, void *textBufferPtr, TEPtr pTE, TEHandle hTE);
    typedef pascal unsigned short (*TextWidthHookProcPtr)(unsigned short textLen,
     unsigned short textOffset, void *textBufferPtr, TEPtr pTE, TEHandle hTE);

        In:
            =>  textLen                 D0.W
            =>  textOffset              D1.W
            =>  textBufferPtr           A0.L
            =>  pTE                     A3.L
            =>  hTE                     A4.L
        Out:
            <=  unsigned short          D1.W

    typedef pascal unsigned short (*NWidthHookProcPtr)(unsigned short styleRunLen,
     unsigned short styleRunOffset, short slop, short direction, void *textBufferPtr, 
     short *lineStart, TEPtr pTE, TEHandle hTE);

        In:
            =>  styleRunLen             D0.W
            =>  styleRunOffset          D1.W
            =>  slop                    D2.W (low)
            =>  direction               D2.W (high)
            =>  textBufferPtr           A0.L
            =>  lineStart               A2.L
            =>  pTE                     A3.L
            =>  hTE                     A4.L
        Out:
            <=  unsigned short          D1.W

    typedef pascal void (*DrawHookProcPtr)(unsigned short textOffset, unsigned short drawLen,
     void *textBufferPtr, TEPtr pTE, TEHandle hTE);

        In:
            =>  textOffset              D0.W
            =>  drawLen                 D1.W
            =>  textBufferPtr           A0.L
            =>  pTE                     A3.L
            =>  hTE                     A4.L
        Out:
            none

    typedef pascal Boolean (*HitTestHookProcPtr)(unsigned short styleRunLen,
     unsigned short styleRunOffset, unsigned short slop, void *textBufferPtr,
     TEPtr pTE, TEHandle hTE, unsigned short *pixelWidth, unsigned short *charOffset, 
     Boolean *pixelInChar);

        In:
            =>  styleRunLen             D0.W
            =>  styleRunOffset          D1.W
            =>  slop                    D2.W
            =>  textBufferPtr           A0.L
            =>  pTE                     A3.L
            =>  hTE                     A4.L
        Out:
            <=  pixelWidth              D0.W (low)
            <=  Boolean                 D0.W (high)
            <=  charOffset              D1.W
            <=  pixelInChar             D2.W

    typedef pascal void (*TEFindWordProcPtr)(unsigned short currentPos, short caller, 
     TEPtr pTE, TEHandle hTE, unsigned short *wordStart, unsigned short *wordEnd);

        In:
            =>  currentPos              D0.W
            =>  caller                  D2.W
            =>  pTE                     A3.L
            =>  hTE                     A4.L
        Out:
            <=  wordStart               D0.W
            <=  wordEnd                 D1.W

    typedef pascal void (*TERecalcProcPtr)(TEPtr pTE, unsigned short changeLength,
     unsigned short *lineStart, unsigned short *firstChar, unsigned short *lastChar);

        In:
            =>  pTE                     A3.L
            =>  changeLength            D7.W
        Out:
            <=  lineStart               D2.W
            <=  firstChar               D3.W
            <=  lastChar                D4.W

    typedef pascal void (*TEDoTextProcPtr)(TEPtr pTE, unsigned short firstChar, unsigned short lastChar,
                        short selector, GrafPtr *currentGrafPort, short *charPosition);

        In:
            =>  pTE                     A3.L
            =>  firstChar               D3.W
            =>  lastChar                D4.W
            =>  selector                D7.W
        Out:
            <=  currentGrafPort         A0.L
            <=  charPosition            D0.W
            
*/
typedef STACK_UPP_TYPE(HighHookProcPtr)                         HighHookUPP;
typedef STACK_UPP_TYPE(EOLHookProcPtr)                          EOLHookUPP;
typedef STACK_UPP_TYPE(CaretHookProcPtr)                        CaretHookUPP;
typedef STACK_UPP_TYPE(WidthHookProcPtr)                        WidthHookUPP;
typedef STACK_UPP_TYPE(TextWidthHookProcPtr)                    TextWidthHookUPP;
typedef STACK_UPP_TYPE(NWidthHookProcPtr)                       NWidthHookUPP;
typedef STACK_UPP_TYPE(DrawHookProcPtr)                         DrawHookUPP;
typedef STACK_UPP_TYPE(HitTestHookProcPtr)                      HitTestHookUPP;
typedef STACK_UPP_TYPE(TEFindWordProcPtr)                       TEFindWordUPP;
typedef STACK_UPP_TYPE(TERecalcProcPtr)                         TERecalcUPP;
typedef STACK_UPP_TYPE(TEDoTextProcPtr)                         TEDoTextUPP;
typedef STACK_UPP_TYPE(TEClickLoopProcPtr)                      TEClickLoopUPP;
typedef STACK_UPP_TYPE(WordBreakProcPtr)                        WordBreakUPP;
struct TERec {
  Rect                destRect;
  Rect                viewRect;
  Rect                selRect;
  short               lineHeight;
  short               fontAscent;
  Point               selPoint;
  short               selStart;
  short               selEnd;
  short               active;
  WordBreakUPP        wordBreak;              /* NOTE: This field is ignored on non-Roman systems and on Carbon (see IM-Text 2-60) */
  TEClickLoopUPP      clickLoop;
  long                clickTime;
  short               clickLoc;
  long                caretTime;
  short               caretState;
  short               just;
  short               teLength;
  Handle              hText;
  long                hDispatchRec;           /* added to replace recalBack & recalLines.  it's a handle anyway */
  short               clikStuff;
  short               crOnly;
  short               txFont;
  StyleField          txFace;                 /*StyleField occupies 16-bits, but only first 8-bits are used*/
  short               txMode;
  short               txSize;
  GrafPtr             inPort;
  HighHookUPP         highHook;
  CaretHookUPP        caretHook;
  short               nLines;
  short               lineStarts[16001];
};

enum {
                                        /* Justification (word alignment) styles */
  teJustLeft                    = 0,
  teJustCenter                  = 1,
  teJustRight                   = -1,
  teForceLeft                   = -2,   /* new names for the Justification (word alignment) styles */
  teFlushDefault                = 0,    /*flush according to the line direction */
  teCenter                      = 1,    /*center justify (word alignment) */
  teFlushRight                  = -1,   /*flush right for all scripts */
  teFlushLeft                   = -2    /*flush left for all scripts */
};

enum {
                                        /* Set/Replace style modes */
  fontBit                       = 0,    /*set font*/
  faceBit                       = 1,    /*set face*/
  sizeBit                       = 2,    /*set size*/
  clrBit                        = 3,    /*set color*/
  addSizeBit                    = 4,    /*add size mode*/
  toggleBit                     = 5     /*set faces in toggle mode*/
};

enum {
                                        /* TESetStyle/TEContinuousStyle modes */
  doFont                        = 1,    /* set font (family) number*/
  doFace                        = 2,    /*set character style*/
  doSize                        = 4,    /*set type size*/
  doColor                       = 8,    /*set color*/
  doAll                         = 15,   /*set all attributes*/
  addSize                       = 16,   /*adjust type size*/
  doToggle                      = 32    /*toggle mode for TESetStyle*/
};

enum {
                                        /* offsets into TEDispatchRec */
  EOLHook                       = 0,    /*[UniversalProcPtr] TEEOLHook*/
  DRAWHook                      = 4,    /*[UniversalProcPtr] TEWidthHook*/
  WIDTHHook                     = 8,    /*[UniversalProcPtr] TEDrawHook*/
  HITTESTHook                   = 12,   /*[UniversalProcPtr] TEHitTestHook*/
  nWIDTHHook                    = 24,   /*[UniversalProcPtr] nTEWidthHook*/
  TextWidthHook                 = 28    /*[UniversalProcPtr] TETextWidthHook*/
};

enum {
                                        /* selectors for TECustomHook */
  intEOLHook                    = 0,    /*TEIntHook value*/
  intDrawHook                   = 1,    /*TEIntHook value*/
  intWidthHook                  = 2,    /*TEIntHook value*/
  intHitTestHook                = 3,    /*TEIntHook value*/
  intNWidthHook                 = 6,    /*TEIntHook value for new version of WidthHook*/
  intTextWidthHook              = 7,    /*TEIntHook value for new TextWidthHook*/
  intInlineInputTSMTEPreUpdateHook = 8, /*TEIntHook value for TSMTEPreUpdateProcPtr callback*/
  intInlineInputTSMTEPostUpdateHook = 9 /*TEIntHook value for TSMTEPostUpdateProcPtr callback*/
};

enum {
                                        /* feature or bit definitions for TEFeatureFlag */
  teFAutoScroll                 = 0,    /*00000001b*/
  teFTextBuffering              = 1,    /*00000010b*/
  teFOutlineHilite              = 2,    /*00000100b*/
  teFInlineInput                = 3,    /*00001000b */
  teFUseWhiteBackground         = 4,    /*00010000b */
  teFUseInlineInput             = 5,    /*00100000b */
  teFInlineInputAutoScroll      = 6     /*01000000b */
};

enum {
                                        /* feature or bit definitions for TEFeatureFlag -- Carbon only                */
                                        /* To avoid having to call TEIdle in Carbon apps, automatic idling can be activated   */
                                        /* via the following feature flag, but you must ensure that the destRect and/or     */
                                        /* GrafPort's origin be setup properly for drawing in a given TERec when       */
                                        /* the timer fires.    When this feature flag is set, TEIdle is a noop.          */
                                        /* Activate this feature flag before calling TEActivate.                 */
  teFIdleWithEventLoopTimer     = 7     /*10000000b */
};

enum {
                                        /* action for the new "bit (un)set" interface, TEFeatureFlag */
  teBitClear                    = 0,
  teBitSet                      = 1,    /*set the selector bit*/
  teBitTest                     = -1    /*no change; just return the current setting*/
};

enum {
                                        /*constants for identifying the routine that called FindWord */
  teWordSelect                  = 4,    /*clickExpand to select word*/
  teWordDrag                    = 8,    /*clickExpand to drag new word*/
  teFromFind                    = 12,   /*FindLine called it ($0C)*/
  teFromRecal                   = 16    /*RecalLines called it ($10)      obsolete */
};

enum {
                                        /*constants for identifying TEDoText selectors */
  teFind                        = 0,    /*TEDoText called for searching*/
  teHighlight                   = 1,    /*TEDoText called for highlighting*/
  teDraw                        = -1,   /*TEDoText called for drawing text*/
  teCaret                       = -2    /*TEDoText called for drawing the caret*/
};


typedef char                            Chars[32001];
typedef char *                          CharsPtr;
typedef CharsPtr *                      CharsHandle;
struct StyleRun {
  short               startChar;              /*starting character position*/
  short               styleIndex;             /*index in style table*/
};
typedef struct StyleRun                 StyleRun;
struct STElement {
  short               stCount;                /*number of runs in this style*/
  short               stHeight;               /*line height*/
  short               stAscent;               /*font ascent*/
  short               stFont;                 /*font (family) number*/
  StyleField          stFace;                 /*StyleField occupies 16-bits, but only first 8-bits are used */
  short               stSize;                 /*size in points*/
  RGBColor            stColor;                /*absolute (RGB) color*/
};
typedef struct STElement                STElement;
typedef STElement                       TEStyleTable[1777];
typedef STElement *                     STPtr;
typedef STPtr *                         STHandle;
struct LHElement {
  short               lhHeight;               /*maximum height in line*/
  short               lhAscent;               /*maximum ascent in line*/
};
typedef struct LHElement                LHElement;
typedef LHElement                       LHTable[8001];
typedef LHElement *                     LHPtr;
typedef LHPtr *                         LHHandle;
struct ScrpSTElement {
  SInt32              scrpStartChar;          /*starting character position*/
  SInt16              scrpHeight;
  SInt16              scrpAscent;
  SInt16              scrpFont;
  StyleField          scrpFace;               /*Only first 8-bits are used*/
  SInt16              scrpSize;
  RGBColor            scrpColor;
};
typedef struct ScrpSTElement            ScrpSTElement;
/* ARRAY [0..1600] OF ScrpSTElement */
typedef ScrpSTElement                   ScrpSTTable[1601];
struct StScrpRec {
  short               scrpNStyles;            /*number of styles in scrap*/
  ScrpSTTable         scrpStyleTab;           /*table of styles for scrap*/
};
typedef struct StScrpRec                StScrpRec;
typedef StScrpRec *                     StScrpPtr;
typedef StScrpPtr *                     StScrpHandle;
struct NullStRec {
  long                teReserved;             /*reserved for future expansion*/
  StScrpHandle        nullScrap;              /*handle to scrap style table*/
};
typedef struct NullStRec                NullStRec;
typedef NullStRec *                     NullStPtr;
typedef NullStPtr *                     NullStHandle;
struct TEStyleRec {
  short               nRuns;                  /*number of style runs*/
  short               nStyles;                /*size of style table*/
  STHandle            styleTab;               /*handle to style table*/
  LHHandle            lhTab;                  /*handle to line-height table*/
  long                teRefCon;               /*reserved for application use*/
  NullStHandle        nullStyle;              /*Handle to style set at null selection*/
  StyleRun            runs[8001];             /*ARRAY [0..8000] OF StyleRun*/
};
typedef struct TEStyleRec               TEStyleRec;
typedef TEStyleRec *                    TEStylePtr;
typedef TEStylePtr *                    TEStyleHandle;
struct TextStyle {
  short               tsFont;                 /*font (family) number*/
  StyleField          tsFace;                 /*StyleField occupies 16-bits, but only first 8-bits are used*/
  short               tsSize;                 /*size in point*/
  RGBColor            tsColor;                /*absolute (RGB) color*/
};
typedef struct TextStyle                TextStyle;
typedef TextStyle *                     TextStylePtr;
typedef TextStylePtr *                  TextStyleHandle;
typedef short                           TEIntHook;
/*
 *  NewHighHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern HighHookUPP
NewHighHookUPP(HighHookProcPtr userRoutine)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewEOLHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern EOLHookUPP
NewEOLHookUPP(EOLHookProcPtr userRoutine)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewCaretHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern CaretHookUPP
NewCaretHookUPP(CaretHookProcPtr userRoutine)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern WidthHookUPP
NewWidthHookUPP(WidthHookProcPtr userRoutine)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewTextWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TextWidthHookUPP
NewTextWidthHookUPP(TextWidthHookProcPtr userRoutine)         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewNWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern NWidthHookUPP
NewNWidthHookUPP(NWidthHookProcPtr userRoutine)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewDrawHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern DrawHookUPP
NewDrawHookUPP(DrawHookProcPtr userRoutine)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewHitTestHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern HitTestHookUPP
NewHitTestHookUPP(HitTestHookProcPtr userRoutine)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewTEFindWordUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TEFindWordUPP
NewTEFindWordUPP(TEFindWordProcPtr userRoutine)               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewTERecalcUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TERecalcUPP
NewTERecalcUPP(TERecalcProcPtr userRoutine)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewTEDoTextUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TEDoTextUPP
NewTEDoTextUPP(TEDoTextProcPtr userRoutine)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewTEClickLoopUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern TEClickLoopUPP
NewTEClickLoopUPP(TEClickLoopProcPtr userRoutine)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  NewWordBreakUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  DisposeHighHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeHighHookUPP(HighHookUPP userUPP)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeEOLHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeEOLHookUPP(EOLHookUPP userUPP)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeCaretHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeCaretHookUPP(CaretHookUPP userUPP)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeWidthHookUPP(WidthHookUPP userUPP)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTextWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTextWidthHookUPP(TextWidthHookUPP userUPP)             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeNWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeNWidthHookUPP(NWidthHookUPP userUPP)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeDrawHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeDrawHookUPP(DrawHookUPP userUPP)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeHitTestHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeHitTestHookUPP(HitTestHookUPP userUPP)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTEFindWordUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTEFindWordUPP(TEFindWordUPP userUPP)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTERecalcUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTERecalcUPP(TERecalcUPP userUPP)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTEDoTextUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTEDoTextUPP(TEDoTextUPP userUPP)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeTEClickLoopUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
DisposeTEClickLoopUPP(TEClickLoopUPP userUPP)                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  DisposeWordBreakUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

/*
 *  InvokeHighHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeHighHookUPP(
  const Rect *  r,
  TEPtr         pTE,
  HighHookUPP   userUPP)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeEOLHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern Boolean
InvokeEOLHookUPP(
  char        theChar,
  TEPtr       pTE,
  TEHandle    hTE,
  EOLHookUPP  userUPP)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeCaretHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeCaretHookUPP(
  const Rect *  r,
  TEPtr         pTE,
  CaretHookUPP  userUPP)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern unsigned short
InvokeWidthHookUPP(
  unsigned short  textLen,
  unsigned short  textOffset,
  void *          textBufferPtr,
  TEPtr           pTE,
  TEHandle        hTE,
  WidthHookUPP    userUPP)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTextWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern unsigned short
InvokeTextWidthHookUPP(
  unsigned short    textLen,
  unsigned short    textOffset,
  void *            textBufferPtr,
  TEPtr             pTE,
  TEHandle          hTE,
  TextWidthHookUPP  userUPP)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeNWidthHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern unsigned short
InvokeNWidthHookUPP(
  unsigned short  styleRunLen,
  unsigned short  styleRunOffset,
  short           slop,
  short           direction,
  void *          textBufferPtr,
  short *         lineStart,
  TEPtr           pTE,
  TEHandle        hTE,
  NWidthHookUPP   userUPP)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeDrawHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeDrawHookUPP(
  unsigned short  textOffset,
  unsigned short  drawLen,
  void *          textBufferPtr,
  TEPtr           pTE,
  TEHandle        hTE,
  DrawHookUPP     userUPP)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeHitTestHookUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern Boolean
InvokeHitTestHookUPP(
  unsigned short    styleRunLen,
  unsigned short    styleRunOffset,
  unsigned short    slop,
  void *            textBufferPtr,
  TEPtr             pTE,
  TEHandle          hTE,
  unsigned short *  pixelWidth,
  unsigned short *  charOffset,
  Boolean *         pixelInChar,
  HitTestHookUPP    userUPP)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTEFindWordUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeTEFindWordUPP(
  unsigned short    currentPos,
  short             caller,
  TEPtr             pTE,
  TEHandle          hTE,
  unsigned short *  wordStart,
  unsigned short *  wordEnd,
  TEFindWordUPP     userUPP)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTERecalcUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeTERecalcUPP(
  TEPtr             pTE,
  unsigned short    changeLength,
  unsigned short *  lineStart,
  unsigned short *  firstChar,
  unsigned short *  lastChar,
  TERecalcUPP       userUPP)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTEDoTextUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern void
InvokeTEDoTextUPP(
  TEPtr           pTE,
  unsigned short  firstChar,
  unsigned short  lastChar,
  short           selector,
  GrafPtr *       currentGrafPort,
  short *         charPosition,
  TEDoTextUPP     userUPP)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeTEClickLoopUPP()
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   available as macro/inline
 */
extern Boolean
InvokeTEClickLoopUPP(
  TEPtr           pTE,
  TEClickLoopUPP  userUPP)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;

/*
 *  InvokeWordBreakUPP()
 *  
 *  Availability:
 *    Mac OS X:         not available
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   available as macro/inline
 */

#if __MACH__
  #ifdef __cplusplus
    inline HighHookUPP                                          NewHighHookUPP(HighHookProcPtr userRoutine) { return userRoutine; }
    inline EOLHookUPP                                           NewEOLHookUPP(EOLHookProcPtr userRoutine) { return userRoutine; }
    inline CaretHookUPP                                         NewCaretHookUPP(CaretHookProcPtr userRoutine) { return userRoutine; }
    inline WidthHookUPP                                         NewWidthHookUPP(WidthHookProcPtr userRoutine) { return userRoutine; }
    inline TextWidthHookUPP                                     NewTextWidthHookUPP(TextWidthHookProcPtr userRoutine) { return userRoutine; }
    inline NWidthHookUPP                                        NewNWidthHookUPP(NWidthHookProcPtr userRoutine) { return userRoutine; }
    inline DrawHookUPP                                          NewDrawHookUPP(DrawHookProcPtr userRoutine) { return userRoutine; }
    inline HitTestHookUPP                                       NewHitTestHookUPP(HitTestHookProcPtr userRoutine) { return userRoutine; }
    inline TEFindWordUPP                                        NewTEFindWordUPP(TEFindWordProcPtr userRoutine) { return userRoutine; }
    inline TERecalcUPP                                          NewTERecalcUPP(TERecalcProcPtr userRoutine) { return userRoutine; }
    inline TEDoTextUPP                                          NewTEDoTextUPP(TEDoTextProcPtr userRoutine) { return userRoutine; }
    inline TEClickLoopUPP                                       NewTEClickLoopUPP(TEClickLoopProcPtr userRoutine) { return userRoutine; }
    inline void                                                 DisposeHighHookUPP(HighHookUPP) { }
    inline void                                                 DisposeEOLHookUPP(EOLHookUPP) { }
    inline void                                                 DisposeCaretHookUPP(CaretHookUPP) { }
    inline void                                                 DisposeWidthHookUPP(WidthHookUPP) { }
    inline void                                                 DisposeTextWidthHookUPP(TextWidthHookUPP) { }
    inline void                                                 DisposeNWidthHookUPP(NWidthHookUPP) { }
    inline void                                                 DisposeDrawHookUPP(DrawHookUPP) { }
    inline void                                                 DisposeHitTestHookUPP(HitTestHookUPP) { }
    inline void                                                 DisposeTEFindWordUPP(TEFindWordUPP) { }
    inline void                                                 DisposeTERecalcUPP(TERecalcUPP) { }
    inline void                                                 DisposeTEDoTextUPP(TEDoTextUPP) { }
    inline void                                                 DisposeTEClickLoopUPP(TEClickLoopUPP) { }
    inline void                                                 InvokeHighHookUPP(const Rect * r, TEPtr pTE, HighHookUPP userUPP) { (*userUPP)(r, pTE); }
    inline Boolean                                              InvokeEOLHookUPP(char theChar, TEPtr pTE, TEHandle hTE, EOLHookUPP userUPP) { return (*userUPP)(theChar, pTE, hTE); }
    inline void                                                 InvokeCaretHookUPP(const Rect * r, TEPtr pTE, CaretHookUPP userUPP) { (*userUPP)(r, pTE); }
    inline unsigned short                                       InvokeWidthHookUPP(unsigned short textLen, unsigned short textOffset, void * textBufferPtr, TEPtr pTE, TEHandle hTE, WidthHookUPP userUPP) { return (*userUPP)(textLen, textOffset, textBufferPtr, pTE, hTE); }
    inline unsigned short                                       InvokeTextWidthHookUPP(unsigned short textLen, unsigned short textOffset, void * textBufferPtr, TEPtr pTE, TEHandle hTE, TextWidthHookUPP userUPP) { return (*userUPP)(textLen, textOffset, textBufferPtr, pTE, hTE); }
    inline unsigned short                                       InvokeNWidthHookUPP(unsigned short styleRunLen, unsigned short styleRunOffset, short slop, short direction, void * textBufferPtr, short * lineStart, TEPtr pTE, TEHandle hTE, NWidthHookUPP userUPP) { return (*userUPP)(styleRunLen, styleRunOffset, slop, direction, textBufferPtr, lineStart, pTE, hTE); }
    inline void                                                 InvokeDrawHookUPP(unsigned short textOffset, unsigned short drawLen, void * textBufferPtr, TEPtr pTE, TEHandle hTE, DrawHookUPP userUPP) { (*userUPP)(textOffset, drawLen, textBufferPtr, pTE, hTE); }
    inline Boolean                                              InvokeHitTestHookUPP(unsigned short styleRunLen, unsigned short styleRunOffset, unsigned short slop, void * textBufferPtr, TEPtr pTE, TEHandle hTE, unsigned short * pixelWidth, unsigned short * charOffset, Boolean * pixelInChar, HitTestHookUPP userUPP) { return (*userUPP)(styleRunLen, styleRunOffset, slop, textBufferPtr, pTE, hTE, pixelWidth, charOffset, pixelInChar); }
    inline void                                                 InvokeTEFindWordUPP(unsigned short currentPos, short caller, TEPtr pTE, TEHandle hTE, unsigned short * wordStart, unsigned short * wordEnd, TEFindWordUPP userUPP) { (*userUPP)(currentPos, caller, pTE, hTE, wordStart, wordEnd); }
    inline void                                                 InvokeTERecalcUPP(TEPtr pTE, unsigned short changeLength, unsigned short * lineStart, unsigned short * firstChar, unsigned short * lastChar, TERecalcUPP userUPP) { (*userUPP)(pTE, changeLength, lineStart, firstChar, lastChar); }
    inline void                                                 InvokeTEDoTextUPP(TEPtr pTE, unsigned short firstChar, unsigned short lastChar, short selector, GrafPtr * currentGrafPort, short * charPosition, TEDoTextUPP userUPP) { (*userUPP)(pTE, firstChar, lastChar, selector, currentGrafPort, charPosition); }
    inline Boolean                                              InvokeTEClickLoopUPP(TEPtr pTE, TEClickLoopUPP userUPP) { return (*userUPP)(pTE); }
  #else
    #define NewHighHookUPP(userRoutine)                         ((HighHookUPP)userRoutine)
    #define NewEOLHookUPP(userRoutine)                          ((EOLHookUPP)userRoutine)
    #define NewCaretHookUPP(userRoutine)                        ((CaretHookUPP)userRoutine)
    #define NewWidthHookUPP(userRoutine)                        ((WidthHookUPP)userRoutine)
    #define NewTextWidthHookUPP(userRoutine)                    ((TextWidthHookUPP)userRoutine)
    #define NewNWidthHookUPP(userRoutine)                       ((NWidthHookUPP)userRoutine)
    #define NewDrawHookUPP(userRoutine)                         ((DrawHookUPP)userRoutine)
    #define NewHitTestHookUPP(userRoutine)                      ((HitTestHookUPP)userRoutine)
    #define NewTEFindWordUPP(userRoutine)                       ((TEFindWordUPP)userRoutine)
    #define NewTERecalcUPP(userRoutine)                         ((TERecalcUPP)userRoutine)
    #define NewTEDoTextUPP(userRoutine)                         ((TEDoTextUPP)userRoutine)
    #define NewTEClickLoopUPP(userRoutine)                      ((TEClickLoopUPP)userRoutine)
    #define DisposeHighHookUPP(userUPP)
    #define DisposeEOLHookUPP(userUPP)
    #define DisposeCaretHookUPP(userUPP)
    #define DisposeWidthHookUPP(userUPP)
    #define DisposeTextWidthHookUPP(userUPP)
    #define DisposeNWidthHookUPP(userUPP)
    #define DisposeDrawHookUPP(userUPP)
    #define DisposeHitTestHookUPP(userUPP)
    #define DisposeTEFindWordUPP(userUPP)
    #define DisposeTERecalcUPP(userUPP)
    #define DisposeTEDoTextUPP(userUPP)
    #define DisposeTEClickLoopUPP(userUPP)
    #define InvokeHighHookUPP(r, pTE, userUPP)                  (*userUPP)(r, pTE)
    #define InvokeEOLHookUPP(theChar, pTE, hTE, userUPP)        (*userUPP)(theChar, pTE, hTE)
    #define InvokeCaretHookUPP(r, pTE, userUPP)                 (*userUPP)(r, pTE)
    #define InvokeWidthHookUPP(textLen, textOffset, textBufferPtr, pTE, hTE, userUPP) (*userUPP)(textLen, textOffset, textBufferPtr, pTE, hTE)
    #define InvokeTextWidthHookUPP(textLen, textOffset, textBufferPtr, pTE, hTE, userUPP) (*userUPP)(textLen, textOffset, textBufferPtr, pTE, hTE)
    #define InvokeNWidthHookUPP(styleRunLen, styleRunOffset, slop, direction, textBufferPtr, lineStart, pTE, hTE, userUPP) (*userUPP)(styleRunLen, styleRunOffset, slop, direction, textBufferPtr, lineStart, pTE, hTE)
    #define InvokeDrawHookUPP(textOffset, drawLen, textBufferPtr, pTE, hTE, userUPP) (*userUPP)(textOffset, drawLen, textBufferPtr, pTE, hTE)
    #define InvokeHitTestHookUPP(styleRunLen, styleRunOffset, slop, textBufferPtr, pTE, hTE, pixelWidth, charOffset, pixelInChar, userUPP) (*userUPP)(styleRunLen, styleRunOffset, slop, textBufferPtr, pTE, hTE, pixelWidth, charOffset, pixelInChar)
    #define InvokeTEFindWordUPP(currentPos, caller, pTE, hTE, wordStart, wordEnd, userUPP) (*userUPP)(currentPos, caller, pTE, hTE, wordStart, wordEnd)
    #define InvokeTERecalcUPP(pTE, changeLength, lineStart, firstChar, lastChar, userUPP) (*userUPP)(pTE, changeLength, lineStart, firstChar, lastChar)
    #define InvokeTEDoTextUPP(pTE, firstChar, lastChar, selector, currentGrafPort, charPosition, userUPP) (*userUPP)(pTE, firstChar, lastChar, selector, currentGrafPort, charPosition)
    #define InvokeTEClickLoopUPP(pTE, userUPP)                  (*userUPP)(pTE)
  #endif
#endif

enum {
                                        /* feature bit 4 for TEFeatureFlag no longer in use */
  teFUseTextServices            = 4     /*00010000b */
};


#if OLDROUTINENAMES
/* action for the old C "bit (un)set" interface, TEFeatureFlag */
#define TEBitClear  teBitClear
#define TEBitSet    teBitSet
#define TEBitTest   teBitTest
#define teFAutoScr  teFAutoScroll
#define toglBit     toggleBit
#endif  /* OLDROUTINENAMES */

#if !__LP64__
/*
 *  TEScrapHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern Handle 
TEScrapHandle(void)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;



/*
 *  TEGetScrapLength()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern long 
TEGetScrapLength(void)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


#if TARGET_CPU_68K && !TARGET_RT_MAC_CFM
#define TEGetScrapLength() ((long) * (unsigned short *) 0x0AB0)
#endif
/*
 *  TENew()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern TEHandle 
TENew(
  const Rect *  destRect,
  const Rect *  viewRect)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEDispose()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEDispose(TEHandle hTE)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetText()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESetText(
  const void *  text,
  long          length,
  TEHandle      hTE)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetText()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern CharsHandle 
TEGetText(TEHandle hTE)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEIdle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEIdle(TEHandle hTE)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetSelect()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESetSelect(
  long       selStart,
  long       selEnd,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEActivate()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEActivate(TEHandle hTE)                                      AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEDeactivate()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEDeactivate(TEHandle hTE)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEKey()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEKey(
  CharParameter   key,
  TEHandle        hTE)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TECut()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TECut(TEHandle hTE)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TECopy()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TECopy(TEHandle hTE)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEPaste()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEPaste(TEHandle hTE)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEDelete()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEDelete(TEHandle hTE)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEInsert()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEInsert(
  const void *  text,
  long          length,
  TEHandle      hTE)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetAlignment()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESetAlignment(
  short      just,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEUpdate()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEUpdate(
  const Rect *  rUpdate,
  TEHandle      hTE)                                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TETextBox()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TETextBox(
  const void *  text,
  long          length,
  const Rect *  box,
  short         just)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEScroll()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEScroll(
  short      dh,
  short      dv,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESelView()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESelView(TEHandle hTE)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEPinScroll()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEPinScroll(
  short      dh,
  short      dv,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEAutoView()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEAutoView(
  Boolean    fAuto,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TECalText()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TECalText(TEHandle hTE)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetOffset()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern short 
TEGetOffset(
  Point      pt,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetPoint()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern Point 
TEGetPoint(
  short      offset,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEClick()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEClick(
  Point      pt,
  Boolean    fExtend,
  TEHandle   h)                                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEStyleNew()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern TEHandle 
TEStyleNew(
  const Rect *  destRect,
  const Rect *  viewRect)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetStyleHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESetStyleHandle(
  TEStyleHandle   theHandle,
  TEHandle        hTE)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetStyleHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern TEStyleHandle 
TEGetStyleHandle(TEHandle hTE)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetStyle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEGetStyle(
  short        offset,
  TextStyle *  theStyle,
  short *      lineHeight,
  short *      fontAscent,
  TEHandle     hTE)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEStylePaste()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEStylePaste(TEHandle hTE)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetStyle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESetStyle(
  short              mode,
  const TextStyle *  newStyle,
  Boolean            fRedraw,
  TEHandle           hTE)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEReplaceStyle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEReplaceStyle(
  short              mode,
  const TextStyle *  oldStyle,
  const TextStyle *  newStyle,
  Boolean            fRedraw,
  TEHandle           hTE)                                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetStyleScrapHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern StScrpHandle 
TEGetStyleScrapHandle(TEHandle hTE)                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEStyleInsert()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEStyleInsert(
  const void *   text,
  long           length,
  StScrpHandle   hST,
  TEHandle       hTE)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetHeight()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern long 
TEGetHeight(
  long       endLine,
  long       startLine,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEContinuousStyle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern Boolean 
TEContinuousStyle(
  short *      mode,
  TextStyle *  aStyle,
  TEHandle     hTE)                                           AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEUseStyleScrap()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TEUseStyleScrap(
  long           rangeStart,
  long           rangeEnd,
  StScrpHandle   newStyles,
  Boolean        fRedraw,
  TEHandle       hTE)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TECustomHook()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TECustomHook(
  TEIntHook           which,
  UniversalProcPtr *  addr,
  TEHandle            hTE)                                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TENumStyles()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern long 
TENumStyles(
  long       rangeStart,
  long       rangeEnd,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEFeatureFlag()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern short 
TEFeatureFlag(
  short      feature,
  short      action,
  TEHandle   hTE)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetHiliteRgn()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in DragLib 1.1 and later
 */
extern OSErr 
TEGetHiliteRgn(
  RgnHandle   region,
  TEHandle    hTE)                                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetScrapLength()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESetScrapLength(long length)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEFromScrap()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
TEFromScrap(void)                                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEToScrap()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
TEToScrap(void)                                               AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetClickLoop()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
TESetClickLoop(
  TEClickLoopUPP   clikProc,
  TEHandle         hTE)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;









/*
 *  TEGetDoTextHook()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern TEDoTextUPP 
TEGetDoTextHook(void)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetDoTextHook()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TESetDoTextHook(TEDoTextUPP value)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetRecalcHook()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern TERecalcUPP 
TEGetRecalcHook(void)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetRecalcHook()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TESetRecalcHook(TERecalcUPP value)                            AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetFindWordHook()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern TEFindWordUPP 
TEGetFindWordHook(void)                                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetFindWordHook()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TESetFindWordHook(TEFindWordUPP value)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TEGetScrapHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern Handle 
TEGetScrapHandle(void)                                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  TESetScrapHandle()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   not available
 */
extern void 
TESetScrapHandle(Handle value)                                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;




/* LMGetWordRedraw and LMSetWordRedraw were previously in LowMem.h  */
/* Deprecated for Carbon on MacOS X                                 */
/* This lomem is no longer used by the implementation of TextEdit   */
/* on MacOS X, so setting it will have no effect.                   */
/*
 *  LMGetWordRedraw()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern UInt8 
LMGetWordRedraw(void)                                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;


/*
 *  LMSetWordRedraw()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.4
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern void 
LMSetWordRedraw(UInt8 value)                                  AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;




#endif  /* !__LP64__ */

#if OLDROUTINENAMES && !__LP64__
#if CALL_NOT_IN_CARBON
#define TESetJust(just, hTE) TESetAlignment(just, hTE)
#define TextBox(text, length, box, just) TETextBox(text, length, box, just)
#define TEStylNew(destRect, viewRect) TEStyleNew(destRect, viewRect)
#define SetStylHandle(theHandle, hTE) TESetStyleHandle(theHandle, hTE)
#define SetStyleHandle(theHandle, hTE) TESetStyleHandle (theHandle, hTE)
#define GetStylHandle(hTE) TEGetStyleHandle(hTE)
#define GetStyleHandle(hTE) TEGetStyleHandle(hTE)
#define TEStylPaste(hTE) TEStylePaste(hTE)
#define GetStylScrap(hTE) TEGetStyleScrapHandle(hTE)
#define GetStyleScrap(hTE) TEGetStyleScrapHandle(hTE)
#define SetStylScrap(rangeStart, rangeEnd, newStyles, redraw, hTE) TEUseStyleScrap(rangeStart, rangeEnd, newStyles, redraw, hTE)
#define SetStyleScrap(rangeStart, rangeEnd, newStyles, redraw, hTE)  TEUseStyleScrap(rangeStart, rangeEnd, newStyles, redraw, hTE)
#define TEStylInsert(text, length, hST, hTE) TEStyleInsert(text, length, hST, hTE)
#define TESetScrapLen(length) TESetScrapLength(length)
#define TEGetScrapLen() TEGetScrapLength()
#define SetClikLoop(clikProc, hTE) TESetClickLoop(clikProc, hTE)
#define SetWordBreak(wBrkProc, hTE) TESetWordBreak(wBrkProc, hTE)
#endif  /* CALL_NOT_IN_CARBON */
#endif  /* OLDROUTINENAMES && !__LP64__ */


#pragma pack(pop)

#ifdef __cplusplus
}
#endif

#endif /* __TEXTEDIT__ */

                                                                                                                                                                                                          TextInputSources.h                                                                                  0100644 0001750 0001750 00000152463 12566221370 044473  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/TextInputSources.h
 
     Copyright:  © 2006-2008 Apple Inc. All rights reserved.
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __TEXTINPUTSOURCES__
#define __TEXTINPUTSOURCES__

#ifndef __CORESERVICES__
#include <CoreServices/CoreServices.h>
#endif


#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


/*
 *  TextInputSources.h
 *  
 *  Summary:
 *    Specifies the modern, non-Script-Manager-based interfaces for
 *    operating on text input sources: finding information about them,
 *    selecting/enabling/disabling them, and receiving notifications
 *    about relevant changes.
 *  
 *  Discussion:
 *    Text input sources are of three general categories: keyboard
 *    input sources (keyboard layouts, keyboard input methods and input
 *    modes), palette input sources (character palette, keyboard
 *    viewer, private dictionary panels), and ink. Palette input
 *    sources and ink input sources are categorized as non-keyboard
 *    input sources, although palette input sources may still involve
 *    some keyboard interaction. Keyboard input methods may be
 *    mode-enabled (e.g. Kotoeri), in which case they may be the parent
 *    of several input modes which are directly selectable in the user
 *    interface (e.g. hiragana, katakana, romaji); in this case the
 *    parent input method is not directly selectable. Non-mode-enabled
 *    input methods are directly selectable. 
 *    
 *    
 *    Some input sources are invisible to system UI; they do not appear
 *    in the normal user interface for manipulating input sources.
 *    Examples include input sources such as ink, the dictionary panel,
 *    and some assistiveware; these have their own special UI for
 *    enabling, disabling, etc. Other examples include special keyboard
 *    layouts used by input methods, which have their own ways of
 *    controlling use of these keyboard layouts. 
 *    
 *    
 *    Some input sources are pre-installed by Apple. Other input
 *    sources (of any type) may be installed as third party products
 *    themselves or as part of installing certain applications. Most
 *    non-invisible input sources may be enabled or disabled by users
 *    using International Preferences, which displays a list of all
 *    visible installed input sources (Setup Assistant also enables
 *    some input sources); there is a separate UI for enabling ink.
 *    Applications may enable or disable input sources programmatically
 *    using some of the functions here. At least one keyboard input
 *    source is enabled (the system ensures this). At most one ink
 *    input source may be enabled; multiple instances of other input
 *    source types may be enabled. 
 *    
 *    
 *    Some enabled input sources are invisible but programmatically
 *    selectable, such as ink. Some are visible but not
 *    programmatically selectable, such as mode-savvy parent input
 *    methods (which must be visible so that International Preferences
 *    can display the parent input method for a group of input modes).
 *    
 *    
 *    
 *    Input modes can only be changed from disabled to enabled if their
 *    parent input method is enabled. Input modes can only be selected
 *    if both they and their parent input method are enabled. 
 *     
 *    
 *    Exactly one keyboard input source is selected at any time; this
 *    is the current keyboard input source. Selecting a new keyboard
 *    input source deselects the previous keyboard input source.
 *    Multiple palette input sources may be selected - e.g. there may
 *    be one or more character palettes and one or more keyboard
 *    viewers selected in addition to the selected keyboard input
 *    source. Selecting or deselecting a palette (or ink) input source
 *    does not affect any other input source. Input methods that
 *    provide associated input palettes may programmatically deselect
 *    the palette when the input method is deselected, for example.
 */
/*
*===============================================================================
*   Basic type
*===============================================================================
*/

/*
 *  TISInputSourceRef
 *  
 *  Summary:
 *    Opaque CF object that unambiguously (within a single process)
 *    represents a text input source.
 *  
 *  Discussion:
 *    Cannot be shared cross-process.
 */
typedef struct __TISInputSource*        TISInputSourceRef;
/*
 *  TISInputSourceGetTypeID()
 *  
 *  Summary:
 *    Gets the CFTypeID of a TISInputSourceRef.
 *  
 *  Result:
 *    Returns the CFTypeID of a TISInputSourceRef, for comparison with
 *    the result of CFGetTypeID().
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CFTypeID 
TISInputSourceGetTypeID(void)                                 AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
*===============================================================================
*   Property key constants,
*
*   Input sources may have additional properties beyond those listed here,
*   and some input sources do not have values for some of the properties
*   listed here. The property value for a particular input source can be
*   obtained using TISGetInputSourceProperty. A set of specific property
*   key-value pairs can also be used as a filter when creating a list of
*   input sources using TISCreateInputSourceList.
*
*   The following keys may be used with both TISGetInputSourceProperty and
*   TISCreateInputSourceList:
*===============================================================================
*/
/*
 *  kTISPropertyInputSourceCategory
 *  
 *  Summary:
 *    The property key constant for a CFStringRef value that indicates
 *    the category of input source.
 *  
 *  Discussion:
 *    The possible values are specified by property value constants
 *    kTISCategoryKeyboardInputSource, kTISCategoryPaletteInputSource,
 *    kTISCategoryInkInputSource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceCategory             AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputSourceType
 *  
 *  Summary:
 *    The property key constant for a CFStringRef value that indicates
 *    the specific type of input source.
 *  
 *  Discussion:
 *    The possible values are specified by property value constants
 *    kTISTypeKeyboardLayout, kTISTypeKeyboardInputMethodWithoutModes,
 *    kTISTypeKeyboardInputMethodModeEnabled,
 *    kTISTypeKeyboardInputMode, kTISTypeCharacterPalette,
 *    kTISTypeKeyboardViewer, kTISTypeInk.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceType                 AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputSourceIsASCIICapable
 *  
 *  Summary:
 *    The property key constant for a CFBooleanRef value that indicates
 *    whether the input source identifies itself as ASCII-capable.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceIsASCIICapable       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputSourceIsEnableCapable
 *  
 *  Summary:
 *    The property key constant for a CFBooleanRef value that indicates
 *    whether the input source can ever (given the right conditions) be
 *    programmatically enabled using TISEnableInputSource.
 *  
 *  Discussion:
 *    This is a static property of an input source, and does not depend
 *    on any current state. 
 *    
 *    Most input sources can be programmatically enabled at any time;
 *    kTISPropertyInputSourceIsEnableCapable is true for these.
 *    
 *    
 *    Some input sources can never be programmatically enabled. These
 *    are mainly input method private keyboard layouts that are used by
 *    the input method via TISSetInputMethodKeyboardLayoutOverride, but
 *    which cannot be directly enabled and used as keyboard layout
 *    input sources. kTISPropertyInputSourceIsEnableCapable is false
 *    for these. 
 *    
 *    Some input sources can only be programmatically enabled under the
 *    correct conditions. These are mainly input modes, which can only
 *    be changed from disabled to enabled if their parent input method
 *    is enabled (however, they can already be in the enabled state -
 *    but not currently selectable - if their parent input method is
 *    disabled). kTISPropertyInputSourceIsEnableCapable is true for
 *    these.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceIsEnableCapable      AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputSourceIsSelectCapable
 *  
 *  Summary:
 *    The property key constant for a CFBooleanRef value that indicates
 *    whether the input source can ever (given the right conditions) be
 *    programmatically selected using TISSelectInputSource.
 *  
 *  Discussion:
 *    This is a static property of an input source, and does not depend
 *    on any current state. 
 *    
 *    Most input sources can be programmatically selected if they are
 *    enabled; kTISPropertyInputSourceIsSelectCapable is true for
 *    these. 
 *    
 *    Some input sources can never be programmatically selected even if
 *    they are enabled. These are mainly input methods that have modes
 *    (parent input methods); only their modes can be selected.
 *    kTISPropertyInputSourceIsSelectCapable is false for these.
 *    
 *    
 *    Some input sources which are enabled can only be programmatically
 *    selected under the correct conditions. These are mainly input
 *    modes, which can only be selected if both they and their parent
 *    input method are enabled.  kTISPropertyInputSourceIsSelectCapable
 *    is true for these. 
 *    
 *    Input source which can never be enabled - i.e. for which
 *    kTISPropertyInputSourceIsEnableCapable is false - can also never
 *    be selected. kTISPropertyInputSourceIsSelectCapable is false for
 *    these.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceIsSelectCapable      AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputSourceIsEnabled
 *  
 *  Summary:
 *    The property key constant for a CFBooleanRef value that indicates
 *    whether the input source is currently enabled.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceIsEnabled            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputSourceIsSelected
 *  
 *  Summary:
 *    The property key constant for a CFBooleanRef value that indicates
 *    whether the input source is currently selected.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceIsSelected           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputSourceID
 *  
 *  Summary:
 *    The property key constant for a CFStringRef value for the unique
 *    reverse DNS name associated with the input source.
 *  
 *  Discussion:
 *    1. For keyboard input methods and for input sources of the
 *    palette or ink category, this is typically the bundle ID, e.g.
 *    "com.apple.Kotoeri". 
 *    
 *    2. For keyboard input modes, this is typically the bundle ID of
 *    the parent input method plus a suffix that uniquely identifies
 *    the input mode, e.g. "com.apple.Kotoeri.Katakana" (it is not the
 *    generic input mode name used across input methods, e.g.
 *    "com.apple.inputmethod.Japanese.Katakana"). 
 *    
 *    3. For keyboard layouts this is a new identification mechanism
 *    typically structured as "com.company.keyboardlayout.name", e.g.
 *    "com.apple.keyboardlayout.US".
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceID                   AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyBundleID
 *  
 *  Summary:
 *    The property key constant for a CFStringRef value for the reverse
 *    DNS BundleID associated with the input source.
 *  
 *  Discussion:
 *    Not valid for all input sources (especially some keyboard
 *    layouts).
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyBundleID                        AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyInputModeID
 *  
 *  Summary:
 *    The property key constant for a CFStringRef value that identifies
 *    a particular usage class for input modes.
 *  
 *  Discussion:
 *    For example, "com.apple.inputmethod.Japanese.Katakana" identifies
 *    a standard Katakana-input usage class that may be associated with
 *    input modes from several different input methods. 
 *    
 *    This InputModeID can be attached to a TSMDocument using
 *    TSMSetDocumentProperty with the tag
 *    kTSMDocumentInputModePropertyTag, in order to control which input
 *    mode usage class should be used with that TSMDocument.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputModeID                     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyLocalizedName
 *  
 *  Summary:
 *    The property key constant for a CFStringRef value for the input
 *    source's localized name for UI purposes.
 *  
 *  Discussion:
 *    Uses the best match (determined by CFBundle) between the
 *    localization being used by the caller and the available
 *    localizations of the input source name. In some cases this may
 *    fall back to an unlocalized name.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyLocalizedName                   AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
*===============================================================================
*   The following keys may be used with TISGetInputSourceProperty, but may NOT
*   be used in the filter dictionary passed to TISCreateInputSourceList:
*===============================================================================
*/
/*
 *  kTISPropertyInputSourceLanguages
 *  
 *  Summary:
 *    The property key constant for a value which is a CFArrayRef of
 *    CFStringRefs, where each CFString is the language code for a
 *    language that can be input using the input source.
 *  
 *  Discussion:
 *    Languages codes are in the same BCP 47 format as returned by
 *    CFLocaleCreateCanonicalLanguageIdentifierFromString. The first
 *    language code in the array is the language for which the input
 *    source is intended. If there is no such language (e.g. for the
 *    Unicode Hex Input keyboard layout), the first language code is an
 *    empty string. 
 *    
 *    NOTE: This key (and a corresponding value) may not be used in the
 *    filter dictionary passed to TISCreateInputSourceList.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyInputSourceLanguages            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyUnicodeKeyLayoutData
 *  
 *  Summary:
 *    The property key constant for a value which is a CFDataRef that
 *    refers to the 'uchr' keyboard layout data for a keyboard layout
 *    input source.
 *  
 *  Discussion:
 *    The uchr data is in native-endian order. If the input source is
 *    not a keyboard layout, or is a keyboard layout for which only
 *    'KCHR data' is available, the value is NULL. 
 *    
 *    NOTE: This key (and a corresponding value) may not be used in the
 *    filter dictionary passed to TISCreateInputSourceList.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyUnicodeKeyLayoutData            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyIconRef
 *  
 *  Summary:
 *    The property key constant for an IconRef value for the input
 *    source icon.
 *  
 *  Discussion:
 *    IconRefs are the normal icon format for keyboard layouts and
 *    input methods. If an IconRef is not available for the specified
 *    input source, the value is NULL. 
 *    
 *    NOTE: This key (and a corresponding value) may not be used in the
 *    filter dictionary passed to TISCreateInputSourceList.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyIconRef                         AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISPropertyIconImageURL
 *  
 *  Summary:
 *    The property key constant for a CFURLRef value indicating the
 *    file containing the image (typically TIFF) to be used as the
 *    input source icon.
 *  
 *  Discussion:
 *    TIFF files are the normal icon format for input modes. If an
 *    image file URL is not available for the specified input source,
 *    the value will be NULL. Note that other image formats (e.g. JPEG,
 *    PNG, PDF) may also be supported.
 *    
 *    Clients should be prepared for a URL to be unreachable, such as when
 *    an Input Method Info.plist mis-declares its icon path extension in its Info.plist.
 *    In this case, the client should try other path extensions, by using, for example,
 *    a combination of CFURLResourceIsReachable, CFURLCopyPathExtension,
 *    CFURLCreateCopyDeletingPathExtension, and CFURLCreateCopyAppendingPathExtension.
 *        For example, if the URL indicates ".png", be prepared to look for a ".tiff".
 *    TIS uses [NSBundle(NSBundleImageExtension) imageForResource:],
 *    where possible, to obtain an input source image, so the path extension (i.e. ".png")
 *    is not critical for the System to find and display the image properly.
 *    
 *    NOTE: This key (and a corresponding value) may not be used in the
 *    filter dictionary passed to TISCreateInputSourceList.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISPropertyIconImageURL                    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
*===============================================================================
*   Property value constants for input source category
*===============================================================================
*/
/*
 *  kTISCategoryKeyboardInputSource
 *  
 *  Summary:
 *    The property value constant for one input source category value
 *    associated with the property key kTISPropertyInputSourceCategory.
 *  
 *  Discussion:
 *    This category includes keyboard layouts, keyboard input methods
 *    (both with modes and without), and keyboard input modes. At least
 *    one input source in this category is installed. Of all input
 *    sources in this category, exactly one is selected; selecting a
 *    new one deselects the previous one.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISCategoryKeyboardInputSource             AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISCategoryPaletteInputSource
 *  
 *  Summary:
 *    The property value constant for one input source category value
 *    associated with the property key kTISPropertyInputSourceCategory.
 *  
 *  Discussion:
 *    This category includes character palettes and keyboard viewers.
 *    Zero or more of these can be selected.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISCategoryPaletteInputSource              AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISCategoryInkInputSource
 *  
 *  Summary:
 *    The property value constant for one input source category value
 *    associated with the property key kTISPropertyInputSourceCategory.
 *  
 *  Discussion:
 *    Zero or one ink input sources can be installed and selected.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISCategoryInkInputSource                  AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
*===============================================================================
*   Property value constants for input source type
*===============================================================================
*/
/*
 *  kTISTypeKeyboardLayout
 *  
 *  Summary:
 *    The property value constant for one input source type value
 *    associated with the property key kTISPropertyInputSourceType.
 *  
 *  Discussion:
 *    This type belongs to the category kTISCategoryKeyboardInputSource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISTypeKeyboardLayout                      AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISTypeKeyboardInputMethodWithoutModes
 *  
 *  Summary:
 *    The property value constant for one input source type value
 *    associated with the property key kTISPropertyInputSourceType.
 *  
 *  Discussion:
 *    This type belongs to the category kTISCategoryKeyboardInputSource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISTypeKeyboardInputMethodWithoutModes     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISTypeKeyboardInputMethodModeEnabled
 *  
 *  Summary:
 *    The property value constant for one input source type value
 *    associated with the property key kTISPropertyInputSourceType.
 *  
 *  Discussion:
 *    This type belongs to the category kTISCategoryKeyboardInputSource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISTypeKeyboardInputMethodModeEnabled      AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISTypeKeyboardInputMode
 *  
 *  Summary:
 *    The property value constant for one input source type value
 *    associated with the property key kTISPropertyInputSourceType.
 *  
 *  Discussion:
 *    This type belongs to the category kTISCategoryKeyboardInputSource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISTypeKeyboardInputMode                   AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISTypeCharacterPalette
 *  
 *  Summary:
 *    The property value constant for one input source type value
 *    associated with the property key kTISPropertyInputSourceType.
 *  
 *  Discussion:
 *    This type belongs to the category kTISCategoryPaletteInputSource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISTypeCharacterPalette                    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISTypeKeyboardViewer
 *  
 *  Summary:
 *    The property value constant for one input source type value
 *    associated with the property key kTISPropertyInputSourceType.
 *  
 *  Discussion:
 *    This type belongs to the category kTISCategoryPaletteInputSource.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISTypeKeyboardViewer                      AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISTypeInk
 *  
 *  Summary:
 *    The property value constant for one input source type value
 *    associated with the property key kTISPropertyInputSourceType.
 *  
 *  Discussion:
 *    This type belongs to the category kTISCategoryInkInputSource.
 *    Even though it is the only type in that category, a type is
 *    provided so that clients who don’t need category information can
 *    just check input source type.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISTypeInk                                 AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
*===============================================================================
*   Find out information about text input sources
*===============================================================================
*/
/*
 *  TISGetInputSourceProperty()
 *  
 *  Summary:
 *    Gets value of specified property for specified input source.
 *  
 *  Parameters:
 *    
 *    inputSource:
 *      The text input source for which a property value is requested.
 *    
 *    propertyKey:
 *      The property key constant specifying the desired property value.
 *  
 *  Result:
 *    Returns a pointer type appropriate for value object associated
 *    with the property key. The specific pointer type is specified for
 *    each key. Typically it is a CFTypeRef of some sort, but in one
 *    case it is IconRef. The function may return NULL if the specified
 *    property is missing or invalid for the specified input source.
 *    The objects referred to by the pointer follow the "Get" rule and
 *    should not be be released by the caller (unless first retained by
 *    the caller).
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern void * 
TISGetInputSourceProperty(
  TISInputSourceRef   inputSource,
  CFStringRef         propertyKey)                            AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISCreateInputSourceList()
 *  
 *  Summary:
 *    Creates a list of input sources that match specified properties.
 *  
 *  Discussion:
 *    This list represents a snapshot of input sources that matched the
 *    specified properties at the time the call was made. If the caller
 *    desires to include input sources that are installed but not
 *    currently enabled, the includeAllInstalled parameter may be set
 *    true. Typically this is done in order to obtain a
 *    TISInputSourceRef for a newly-installed input source; in this
 *    case the properties parameter would include very specific
 *    criteria limiting the matching input sources. 
 *    
 *    Warning: Calling this with includeAllInstalled true can have
 *    significant memory impact on the calling application if the
 *    properties parameter is NULL (match all) or if it specifies
 *    criteria that may match many installed input sources, since this
 *    may force caching of data for all matching input sources (which
 *    can result in allocation of up to 120K). If
 *    TISCreateInputSourceList is being called in order to find a
 *    specific input source or sources from among the sources included
 *    in the list, then it is best to first call
 *    TISCreateInputSourceList with includeAllInstalled = false and
 *    check whether the returned array includes the desired input
 *    source(s); if not, then call TISCreateInputSourceList again with
 *    includeAllInstalled = true.
 *  
 *  Parameters:
 *    
 *    properties:
 *      Dictionary of property keys and corresponding values to filter
 *      the input source list. May be NULL, in which case no filtering
 *      is performed.
 *    
 *    includeAllInstalled:
 *      Normally false so that only enabled input sources will be
 *      included; set true to include all installed input sources that
 *      match the filter (see discussion).
 *  
 *  Result:
 *    Returns a CFArrayRef for a list of TISInputSourceRefs that match
 *    the specified properties.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CFArrayRef 
TISCreateInputSourceList(
  CFDictionaryRef   properties,
  Boolean           includeAllInstalled)                      AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
*===============================================================================
*   Get specific input sources
*===============================================================================
*/
/*
 *  TISCopyCurrentKeyboardInputSource()
 *  
 *  Summary:
 *    Copies a TISInputSourceRef for the currently-selected keyboard
 *    input source; convenience function.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern TISInputSourceRef 
TISCopyCurrentKeyboardInputSource(void)                       AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISCopyCurrentKeyboardLayoutInputSource()
 *  
 *  Summary:
 *    Copies a TISInputSourceRef for the keyboard layout currently
 *    being used. If the currently-selected keyboard input source is a
 *    keyboard layout, the TISInputSourceRef refers to that layout; if
 *    the currently-selected keyboard input source is an input method
 *    or mode, the TISInputSourceRef refers to the keyboard layout
 *    being used by that input method or mode.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern TISInputSourceRef 
TISCopyCurrentKeyboardLayoutInputSource(void)                 AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISCopyCurrentASCIICapableKeyboardInputSource()
 *  
 *  Summary:
 *    Copies a TISInputSourceRef for the most-recently-used
 *    ASCII-capable keyboard input source.
 *  
 *  Discussion:
 *    If no ASCII-capable keyboard input source has been used yet,
 *    returns the default ASCII-capable keyboard layout (chosen by
 *    Setup Assistant).
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern TISInputSourceRef 
TISCopyCurrentASCIICapableKeyboardInputSource(void)           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISCopyCurrentASCIICapableKeyboardLayoutInputSource()
 *  
 *  Summary:
 *    Copies a TISInputSourceRef for the most-recently-used
 *    ASCII-capable keyboard layout.
 *  
 *  Discussion:
 *    If no ASCII-capable keyboard input source has been used yet,
 *    returns the default ASCII-capable keyboard layout (chosen by
 *    Setup Assistant). 
 *    
 *    This is used by input methods to get the keyboard layout that
 *    will be used for key translation if there is no specific keyboard
 *    layout override. 
 *    
 *    Note the similar TISCopyCurrentASCIICapableKeyboardInputSource,
 *    which can return input sources that are not keyboard layouts.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern TISInputSourceRef 
TISCopyCurrentASCIICapableKeyboardLayoutInputSource(void)     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISCopyInputSourceForLanguage()
 *  
 *  Summary:
 *    Copies a TISInputSourceRef for the input source that should be
 *    used to input the specified language.
 *  
 *  Discussion:
 *    Sample usage: If a text field is expected to have input in a
 *    particular language, an application can call
 *    TISCopyInputSourceForLanguage and then TISSelectInputSource to
 *    select an input source that would be appropriate for that
 *    language. 
 *    
 *    This is intended to provide a replacement for one way in which
 *    the now-deprecated KeyScript API was used: Selection of the
 *    default input source associated with a particular ScriptCode.
 *  
 *  Parameters:
 *    
 *    language:
 *      A language tag in BCP 47 format (i.e. in the same form as
 *      returned by
 *      CFLocaleCreateCanonicalLanguageIdentifierFromString) that
 *      represents the language for which an input source should be
 *      returned.
 *  
 *  Result:
 *    TISInputSourceRef for an enabled input source that can input the
 *    specified language. If there is more than one such input source
 *    and at least one has previously been used, then the
 *    most-recently-used one will be chosen. If none of them has
 *    previously been used, one will be chosen based on the intended
 *    languages of the input sources. If there is no enabled input
 *    source that can input the specified language, the function will
 *    return NULL.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern TISInputSourceRef 
TISCopyInputSourceForLanguage(CFStringRef language)           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISCreateASCIICapableInputSourceList()
 *  
 *  Summary:
 *    Creates a list of ASCII capable keyboard input sources.
 *  
 *  Discussion:
 *    This list represents a snapshot of ASCII capable keyboard input
 *    sources that were enabled at the time the call was made.
 *    Successive calls to TISCreateASCIICapableInputSourceList may
 *    return different results because, for example, in between the
 *    calls the user may enable or disable an input source in the
 *    International Preferences pane. When a keyboard input source is
 *    enabled or disabled, whether by the user or programmatically, the
 *    kTISNotifyEnabledKeyboardInputSourcesChanged CF distributed
 *    notification is posted.
 *  
 *  Result:
 *    Returns a CFArrayRef containing a list of TISInputSourceRefs.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern CFArrayRef 
TISCreateASCIICapableInputSourceList(void)                    AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
*===============================================================================
*   Manipulate input sources
*===============================================================================
*/
/*
 *  TISSelectInputSource()
 *  
 *  Summary:
 *    Selects the specified input source.
 *  
 *  Discussion:
 *    Calling TISSelectInputSource on a keyboard input source that can
 *    be selected makes the specified input source the new current
 *    keyboard input source, and deselects the previous one. Calling
 *    TISSelectInputSource on a palette input source usually results in
 *    the palette being displayed and available for input. Ink input
 *    sources are typically enabled and selected at the same time.
 *    Calling TISSelectInputSource on a palette or ink input source has
 *    no effect on other input sources. Calling TISSelectInputSource
 *    for an already-selected input source has no effect. 
 *    
 *    For TISSelectInputSource to succeed, the input source must be
 *    capable of being selected (kTISPropertyInputSourceIsSelectCapable
 *    must be true) and the input source must be enabled
 *    (kTISPropertyInputSourceIsEnabled must be true). Furthermore, if
 *    if the input source is an input mode, its parent must be enabled
 *    for it to be selected.
 *  
 *  Result:
 *    Returns an error code: paramErr if the input source is not
 *    selectable, else noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TISSelectInputSource(TISInputSourceRef inputSource)           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISDeselectInputSource()
 *  
 *  Summary:
 *    Deselects the specified input source.
 *  
 *  Discussion:
 *    TISDeselectInputSource is only intended for use with palette or
 *    ink input sources; calling it has no effect on other input
 *    sources. When palette input sources are disabled, the palette
 *    disappears. Ink input sources are usually deselected and disabled
 *    at the same time.
 *  
 *  Result:
 *    Returns an error code: paramErr if the input source is not
 *    deselectable, else noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TISDeselectInputSource(TISInputSourceRef inputSource)         AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISEnableInputSource()
 *  
 *  Summary:
 *    Enables the specified input source.
 *  
 *  Discussion:
 *    TISEnableInputSource is mainly intended for input methods, or for
 *    applications that supply their own input sources (e.g.
 *    applications that provide keyboard layouts or palette input
 *    methods, and keyboard input methods that provide their own
 *    keyboard layouts and/or input modes). It makes the specified
 *    input source available in UI for selection. 
 *    
 *    For TISEnableInputSource to succeed, the input source must be
 *    capable of being enabled (kTISPropertyInputSourceIsEnableCapable
 *    must be true). Furthermore, if the input source is an input mode,
 *    its parent must already be enabled for the mode to become enabled.
 *  
 *  Result:
 *    Returns an error code: paramErr if the input source cannot be
 *    enabled, else noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TISEnableInputSource(TISInputSourceRef inputSource)           AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISDisableInputSource()
 *  
 *  Summary:
 *    Disables the specified input source.
 *  
 *  Discussion:
 *    TISDisableInputSource is mainly intended for input methods, or
 *    for applications that supply their own input sources (e.g.
 *    applications that provide keyboard layouts or palette input
 *    methods, and keyboard input methods that provide their own
 *    keyboard layouts and/or input modes). It makes the specified
 *    input source unavailable for selection, and removes it from
 *    system UI.
 *  
 *  Result:
 *    Returns an error code: paramErr if the input source cannot be
 *    disabled, else noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TISDisableInputSource(TISInputSourceRef inputSource)          AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
*===============================================================================
*   Notification constants
*===============================================================================
*/
/*
 *  kTISNotifySelectedKeyboardInputSourceChanged
 *  
 *  Summary:
 *    The name of the CF distributed notification for a change to the
 *    selected keyboard input source.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISNotifySelectedKeyboardInputSourceChanged AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
 *  kTISNotifyEnabledKeyboardInputSourcesChanged
 *  
 *  Summary:
 *    The name of the CF distributed notification for a change to the
 *    set of enabled keyboard input sources.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern const CFStringRef kTISNotifyEnabledKeyboardInputSourcesChanged AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
/*
*===============================================================================
*   Allow input method to override keyboard layout
*===============================================================================
*/
/*
 *  TISSetInputMethodKeyboardLayoutOverride()
 *  
 *  Summary:
 *    Sets the keyboard layout override for an input method or mode.
 *  
 *  Discussion:
 *    When an input method or mode is the selected input source, TSM
 *    will by default use the most-recently-used ASCII-capable keyboard
 *    layout to translate key events* (this keyboard layout is also the
 *    one that will appear in Keyboard Viewer); an input source for
 *    this keyboard layout is returned by
 *    TISCopyCurrentASCIICapableKeyboardLayout. If a different keyboard
 *    layout should be used for a particular input method or mode, then
 *    when that input method/mode is activated it should call
 *    TISSetInputMethodKeyboardLayoutOverride to specify the desired
 *    keyboard layout. 
 *    
 *    For example, when a Kotoeri user selects kana layout for kana
 *    input, Kotoeri should call
 *    TISSetInputMethodKeyboardLayoutOverride to set the kana keyboard
 *    as the override for the appropriate input modes. 
 *    
 *    The keyboard layout set in this way will be used for the final
 *    stage of key translation in the Window Server - the connection or
 *    application-specific key translation. 
 *    
 *    The override setting is lost when the input method that set it is
 *    deactivated. 
 *    
 *    The keyboardLayout to be used for overriding need not be enabled
 *    or explicitly selectable. It can be a non-selectable layout that
 *    is included in an input method bundle and automatically
 *    registered. 
 *    
 *    *The default behavior is new for Mac OS X 10.5, and is meant to
 *    eliminate the necessity for input methods to have UI for setting
 *    which ASCII- capable keyboard to use for latin-character-based
 *    phonetic input.
 *  
 *  Parameters:
 *    
 *    keyboardLayout:
 *      TISInputSourceRef for the keyboard layout that should be used
 *      until the current input method is deactivated (if it should be
 *      something other than the most-recently-used ASCII-capable
 *      keyboard layout).
 *  
 *  Result:
 *    Returns an error code: paramErr if the current keyboard input
 *    source is not an input method/mode or if keyboardLayout does not
 *    designate a keyboard layout, else noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TISSetInputMethodKeyboardLayoutOverride(TISInputSourceRef keyboardLayout) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
 *  TISCopyInputMethodKeyboardLayoutOverride()
 *  
 *  Summary:
 *    Copies a TISInputSourceRef for the currently-selected input
 *    method's keyboard layout override, if any.
 *  
 *  Result:
 *    If the current keyboard input source is an input method or mode
 *    that has a keyboard layout override, then a TISInputSourceRef for
 *    that keyboard layout is returned; otherwise, NULL is returned.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern TISInputSourceRef 
TISCopyInputMethodKeyboardLayoutOverride(void)                AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
*===============================================================================
*   Install/register an input source
*===============================================================================
*/
/*
 *  TISRegisterInputSource()
 *  
 *  Summary:
 *    Registers the new input source(s) in a file or bundle so that a
 *    TISInputSourceRef can immediately be obtained for each of the new
 *    input source(s).
 *  
 *  Discussion:
 *    This allows an installer for an input method bundle or a keyboard
 *    layout file or bundle to notify the system that these new input
 *    sources should be registered. The system can then locate the
 *    specified file or bundle and perform any necessary cache rebuilds
 *    so that the installer can immediately call
 *    TISCreateInputSourceList with appropriate properties (e.g.
 *    BundleID or InputSourceID) in order to get TISInputSourceRefs for
 *    one or more of the newly registered input sources. 
 *    
 *    This can only be used to register the following: 
 *    
 *    - Keyboard layout files or bundles in "/Library/Keyboard
 *    Layouts/" or "~/Library/Keyboard Layouts/" (available to all
 *    users or current user, respectively). Such keyboard layouts, once
 *    enabled, are selectable. 
 *    
 *    - Input method bundles in the new "/Library/Input Methods/" or
 *    "~/Library/Input Methods/" directories (available to all users or
 *    current user, respectively). 
 *    
 *    Note: Input method bundles can include private non-selectable
 *    keyboard layouts for use with
 *    TISSetInputMethodKeyboardLayoutOverride. These are registered
 *    automatically when the input method is registered, and do not
 *    need to be separately registered. 
 *    
 *    Security: Any code that calls TISRegisterInputSource is part of
 *    an application or service that has already been validated in some
 *    way (e.g. by the user).
 *  
 *  Parameters:
 *    
 *    location:
 *      CFURLRef for the location of the input source(s), a file or
 *      bundle.
 *  
 *  Result:
 *    Error code: paramErr if location is invalid or the input
 *    source(s) in the specified location cannot be registered;
 *    otherwise noErr.
 *  
 *  Availability:
 *    Mac OS X:         in version 10.5 and later in Carbon.framework
 *    CarbonLib:        not available
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TISRegisterInputSource(CFURLRef location)                     AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*
*===============================================================================
*   Text Input Sources properties and bundle-packaged text input sources
*===============================================================================
*
*   For Leopard, there are two new keys for use in plists to provide information
*   that supports the Text Input Sources functions above (these keys will be
*   ignored in earlier systems):
*
*   "TISInputSourceID" - a key to specify the InputSourceID, a reverse-DNS-style
*   string meant to uniquely identify any input source. If this key is not
*   specified, the Text Input Sources functions will attempt to construct an
*   InputSourceID from other information.
*
*   "TISIntendedLanguage" - a key to specify the primary language which the
*   input source is intended to input. If there is none - as with the Unicode
*   Hex Input key layout, for example - this key need not be specified. The
*   language is indicated by a string in in the format described by BCP 47
*   (the successor to RFC 3066).
*
*   How these keys are used depends on the type of input source, as described
*   below.
*
*   1. Keyboard layouts ( in <domain>/Library/Keyboard Layouts/ )
*
*   Keyboard layouts packaged in bundles use either a resource file or a set of
*   xml keylayout files together with optional icns files. The following example
*   shows the two methods of packaging a set of two key layouts in Unicode 'uchr'
*   format with key layout names "MyLayoutOne" and "MyLayoutTwo" and corresponding
*   numeric IDs -9001 and -9002 (see Tech Note 2056).
*
*   MyKeyboardLayouts.bundle/
*       Contents/
*           Info.plist
*           version.plist
*           Resources/
*               MyKeyboardLayouts.rsrc, containing the following resources:
*                   resources 'uchr' (-9001, "MyLayoutOne"), 'kcs#' (-9001), 'kcs4' (-9001)
*                   resources 'uchr' (-9002, "MyLayoutTwo"), 'kcs#' (-9002), 'kcs4' (-9002)
*               en.lproj/InfoPlist.strings, maps "MyLayoutOne" & "MyLayoutTwo" to localized names
*               ja.lproj/InfoPlist.strings, maps "MyLayoutOne" & "MyLayoutTwo" to localized names
*               ...
*
*   MyKeyboardLayouts.bundle/
*       Contents/
*           Info.plist
*           version.plist
*           Resources/
*               MyLayoutOne.keylayout, specifying name="MyLayoutOne" and id=-9001
*               MyLayoutOne.icns (optional)
*               MyLayoutTwo.keylayout, specifying name="MyLayoutTwo" and id=-9002
*               MyLayoutTwo.icns (optional)
*               en.lproj/InfoPlist.strings, maps "MyLayoutOne" & "MyLayoutTwo" to localized names
*               ja.lproj/InfoPlist.strings, maps "MyLayoutOne" & "MyLayoutTwo" to localized names
*               ...
*
*   In the Info.plist file, the value for the CFBundleIdentifier key must be a
*   string that includes ".keyboardlayout."; typically this might be something
*   like "com.companyname.keyboardlayout.MyKeyboardLayouts" (Before Leopard,
*   it was required to be a string that began "com.apple.keyboardlayout", even
*   for keyboard layouts not supplied by Apple).
*
*   A dictionary of properties for each key layout in the bundle should be
*   provided using a key of the form "KLInfo_keylayoutname" (even if
*   keylayoutname includes spaces or punctuation). This dictionary is where to
*   specify the keys "TISInputSourceID" and "TISIntendedLanguage" and their
*   associated values.
*
*   "TISInputSourceID" note: For keyboard layouts this should typically be
*   something like "com.companyname.keylayout.keylayoutname". If this key is
*   not specified, an InputSourceID will be constructed by combining
*   bundleID + ". keylayout." + keylayoutname.
*
*   If the keyboard layouts in the above example were intended to input
*   Azerbaijani in Latin script, then the Info.plist entries could be:
*
*       <key>KLInfo_MyLayoutOne</key>
*       <dict>
*           <key>TISInputSourceID</key>
*           <string>com.companyname.keylayout.MyLayoutOne</string>
*           <key>TISIntendedLanguage</key>
*           <string>az-Latn</string>
*       </dict>
*       <key>KLInfo_MyLayoutTwo</key>
*       <dict>
*           <key>TISInputSourceID</key>
*           <string>com.companyname.keylayout.MyLayoutTwo</string>
*           <key>TISIntendedLanguage</key>
*           <string>az-Latn</string>
*       </dict>
*
*   2. Input methods
*
*   Input methods are always packaged as bundles, either as Component bundles
*   in "<domain>/Library/Components/" (the old way, still supported in Leopard)
*   or as application bundles in "<domain>/Library/Input Methods/" (new for
*   Leopard).
*
*   The new keys keys "TISInputSourceID" and "TISIntendedLanguage" and their
*   associated values are added at the top level of the Info.plist file.
*
*   "TISInputSourceID" note: For input methods this is typically the same as
*   the BundleID, and if this key is not specified the BundleID will be used
*   as the InputSourceID.
*
*   3. Input modes
*
*   An input method's input modes are defined using the "ComponentInputModeDict"
*   key at the top level of the input method's Info.plist file (even for
*   non-component application-based input methods). The value of this key is a
*   dictionary, one of whose keys is "tsInputModeListKey"; the value of this
*   key is also a dictionary of input modes, with the InputModeID as the key
*   and the input mode's dictionary as the value (see TextServices.h).
*
*   The new keys keys "TISInputSourceID" and "TISIntendedLanguage" and their
*   associated values are added to the input mode's dictionary.
*
*   "TISInputSourceID" note: For input modes this is a string that begins with
*   the parent input method's InputSourceID or BundleID, followed by something
*   that identifies the mode. For example, "com.apple.Kotoeri.Japanese.Katakana".
*   In general it is not necessarily the same as the InputModeID, since a
*   particular InputModeID such as "com.apple.inputmethod.Japanese.Katakana"
*   may be used by multiple input methods. If this key is not specified, an
*   InputSourceID will be constructed by combining the BundleID with an
*   InputModeID suffix formed by deleting any prefix that matches the BundleID
*   or that ends in ".inputmethod."
*/
/*
*===============================================================================
*/

#ifdef __cplusplus
}
#endif

#endif /* __TEXTINPUTSOURCES__ */

                                                                                                                                                                                                             TextServices.h                                                                                      0100644 0001750 0001750 00000224264 12566221370 043612  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers                            /*
     File:       HIToolbox/TextServices.h
 
     Contains:   Text Services Manager Interfaces.
 
     Copyright:  © 1991-2008 by Apple Computer, Inc., all rights reserved.
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __TEXTSERVICES__
#define __TEXTSERVICES__

#ifndef __APPLICATIONSERVICES__
#include <ApplicationServices/ApplicationServices.h>
#endif

#ifndef __EVENTS__
#include <HIToolbox/Events.h>
#endif

#ifndef __MENUS__
#include <HIToolbox/Menus.h>
#endif

#ifndef __AEINTERACTION__
#include <HIToolbox/AEInteraction.h>
#endif

#ifndef __CARBONEVENTS__
#include <HIToolbox/CarbonEvents.h>
#endif

#include <AvailabilityMacros.h>

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(push, 2)

enum {
  kTextService                  = 'tsvc' /* component type for the component description */
};



/*
 *  Summary:
 *    TSM Version Gestalt values
 *  
 *  Discussion:
 *    Gestalt values for gestaltTSMgrVersion selector (Gestalt.h)
 */
enum {
  kTSMVersion                   = 0x0150, /* Version 1.5 of the Text Services Manager */
  kTSM15Version                 = kTSMVersion,
  kTSM20Version                 = 0x0200, /* Version 2.0 as of Mac OS X 10.0 */
  kTSM22Version                 = 0x0220, /* Version 2.2 as of Mac OS X 10.3 */
  kTSM23Version                 = 0x0230, /* Version 2.3 as of Mac OS X 10.4 */
  kTSM24Version                 = 0x0240 /* Version 2.4 as of Mac OS X 10.5 */
};


/*  Interface types for NewTSMDocument*/
typedef OSType                          InterfaceTypeList[1];
typedef OSType                          TSMDocumentInterfaceType;

/*
 *  Summary:
 *    InterfaceTypeList - array of OSTypes passed to NewTSMDocument to
 *    specify capabilities of the new TSMDocument.
 *  
 *  Discussion:
 *    TSM's Interface types, as of 10.3, are also stored as TSMDocument
 *    properties, so once a TSMDocument is created, you can easily find
 *    out what were its InterfaceTypes at document creation.
 */
enum {

  /*
   * This is the traditional TSMDocument type.  It does not support
   * Unicode. TSM will convert all Unicode produced by input methods to
   * the Mac encoding represented by the current keyboard script (or
   * the Mac encoding specified by the input method producing text.) 
   * Full Unicode input sources may not be selectable when this
   * TSMDocument is active.
   */
  kTextServiceDocumentInterfaceType = kTextService, /* TSM Document type for traditional (non-Unicode) NewTSMDocument */

  /*
   * TSMTE document type.  This requests automatic management of inline
   * input sessions by TextEdit (the text engine.)  See Technote TE27 -
   * Inline Input for TextEdit with TSMTE.  This property (like
   * TextEdit) is not supported on 64-bit.
   */
  kTSMTEDocumentInterfaceType   = 'tmTE', /* TSM Document type for TSMTE document (see kTSMTEInterfaceType - TSMTE.h) */

  /*
   * Unicode-savvy TSMDocument.  TSM will pass thru all Unicode text
   * unchanged. When this TSMDocument is active, the full range of
   * input sources is available to the user, such as Unicode keyboard
   * layouts.
   */
  kUnicodeDocumentInterfaceType = 'udoc', /* TSM Document type for Unicode-savvy application */
                                        /*    Older names, to be deprecated*/
  kUnicodeDocument              = kUnicodeDocumentInterfaceType /* TSM Document type for Unicode-savvy application */
};

/*
    TextServiceClass constants supported by TSM
    Same as component subtype for the component description
*/
typedef OSType                          TextServiceClass;

/*
 *  Summary:
 *    TextService classes
 *  
 *  Discussion:
 *    Text Service classes fall into three categories or behaviors.
 *    
 *    (1) KeyboardInputMethodClass text services are exclusive of one
 *    another in terms of being the default for a given Mac script
 *    code, and at most one of these - regardless of script - can be
 *    currently selected. 
 *    (2) Only zero or one InkInputMethodClass text services can be
 *    selected; this is independent of what other input sources are
 *    selected. 
 *    (3) Zero or more input methods of other classes can be selected,
 *    regardless of what other input sources are selected (they are
 *    additive in nature, regardless of the current keyboard script).
 */
enum {

  /*
   * Text service class for keyboard input methods. Behavior is
   * exclusive. Input Methods in this class are normally associated
   * with a Mac ScriptCode or Unicode, although they can be associated
   * with several scripts by adopting the Input Mode protocol. Keyboard
   * input methods are always visible in the System UI.
   */
  kKeyboardInputMethodClass     = 'inpm',

  /*
   * Text service class for Ink (Handwriting) input methods. At most
   * one of these can be enabled and active regardless of script. Text
   * Services in the Ink class do not belong to any given script in the
   * sense that those of the Keyboard class do. Once selected, this
   * kind of text service will remain active regardless of the current
   * keyboard script. Although text services in this class are keyboard
   * script agnostic, like input methods of the keyboard class they can
   * still profess to produce only those Unicodes that are encoded in
   * the mac encoding specified in their component description record
   * or their implementation of the GetScriptLanguageSupport component
   * call. 
   * 
   * Mac OS X only provides System UI for enabling Apple's Ink input
   * method, not for other Ink input methods.
   */
  kInkInputMethodClass          = 'ink ',

  /*
   * Text service class for Character Palette input methods.  Behavior
   * is Additive. Text Services in the character palette class do not
   * belong to any given script in the same sense that do those of the
   * Keyboard class.  Once selected, this kind of text service will
   * remain active regardless of the current keyboard script. Although
   * text services in this class are keyboard script agnostic, like
   * input methods of the keyboard class they can still profess to
   * produce only those Unicodes that are encoded in the mac encoding
   * specified in their component description record or their
   * implementation of the GetScriptLanguageSupport component call.
   * 
   * 
   * Unlike input methods in the keyboard class, multiple such text
   * services can be activated in parallel, and unlike input methods in
   * the Ink class, Mac OS X provides System UI to allow the user to
   * both enable and select multiple such input methods. Use the
   * kComponentBundleInvisibleInSystemUIKey plist key to make Character
   * Palette input methods invisible to the System UI. 
   * 
   * (Dictionary Service input methods are visible in the system UI by
   * default.  Use the kComponentBundleInvisibleInSystemUIKey plist key
   * to make them invisible if a developer-provided UI is to be used
   * instead.)
   */
  kCharacterPaletteInputMethodClass = 'cplt',

  /*
   * Text Service class for Speech input methods.  Behavior is
   * Additive. 
   * 
   * Similar to Character palette class.  System UI for these has not
   * yet been determined.
   */
  kSpeechInputMethodClass       = 'voic',

  /*
   * Text Service class for Optical Character Recognition input
   * methods.  Behavior is Additive. 
   * 
   * Similar to Character palette class.  System UI for these has not
   * yet been determined.
   */
  kOCRInputMethodClass          = 'ocr '
};

/* New opaque definitions for types */
typedef struct OpaqueTSMDocumentID*     TSMDocumentID;
/* TSMDocumentID Properties*/
/*——————————————————————————————————————————————————————————————————————————————————————*/
/* TSMDocumentID Properties                                                             */
/*                                                                                      */
/* With the following property APIs, you can attach any piece of data you'd like to a   */
/* TSMDocument.*/
/* to attach the data to the menu itself, and not to any specific menu item.            */
/*——————————————————————————————————————————————————————————————————————————————————————*/
typedef OSType                          TSMDocumentPropertyTag;

/*
 *  Summary:
 *    TSMDocument Property Tags
 *  
 *  Discussion:
 *    With the following property APIs, you can attach any piece of
 *    data you'd like to a TSMDocument.  The property tags pre-defined
 *    below by TSM fall in several categories. Read-only properties: 
 *    these property tags are actually the interface type used to
 *    create a TSMDocument, such as kUnicodeDocumentInterfaceType.
 *    These properties are all property value-independent... see below.
 *    Value-independent properties:  these property tags are value
 *    independent. Only the fact that the tag is or is not a property
 *    of a TSMDocument is important.  These are used where the
 *    existence of the property is sufficient... Read-only TSMDocment
 *    properties are examples of value independent properties.
 *    SupportGlyphInfo is another. Pass a non-NULL actualSize parameter
 *    and a NULL propertyBuffer to check if the property exists (i.e.
 *    to obtain the size.) Value-dependent properties:  these are
 *    properties for which the value is meaningful.  Examples of this
 *    are the Refcon ProtocolVersion properties. NOTE: 
 *    Value-independent properties can read by other clients, in
 *    particular input methods.  For example, input methods may want to
 *    query the current TSMDocument to see if supports unrestricted
 *    Unicode input, or if it supports the GlyphInfo protocol.
 */
enum {
                                        /*    */
                                        /*    Property values for value-independent property tags (i.e. only the existence of*/
                                        /*    the property is meaningful).  To remove these properties, use TSMRemoveDocumentProperty.*/
                                        /*    To test these properties, it is sufficient to obtain the property's size, i.e. buffer = NULL*/
                                        /*    and test for error.*/
                                        /*    Read-only (value-independent) properties*/
                                        /*    Identical to Interface types passed to NewTSMDocument*/

  /*
   * Property is read-only, value-independent.  The value is identical
   * to the TextServiceDocument interface type, but is not needed. 
   * Simply test for existence of the property. Property available in
   * TSM 2.2 and later
   */
  kTSMDocumentTextServicePropertyTag = kTextServiceDocumentInterfaceType,

  /*
   * Property is read-only, value-independent.  The value is identical
   * to the UnicodeDocument interface type, but is not needed.  Simply
   * test for existence of the property. Property available in TSM 2.2
   * and later
   */
  kTSMDocumentUnicodePropertyTag = kUnicodeDocumentInterfaceType,

  /*
   * Property is read-only, value-independent.  The value is identical
   * to the TSMTEDocument interface type, but is not needed.  Simply
   * test for existence of the property. Property available in TSM 2.2
   * and later
   */
  kTSMDocumentTSMTEPropertyTag  = kTSMTEDocumentInterfaceType, /*    */
                                        /*    Settable value-independent properties*/

  /*
   * Property is value-independent.  The existence of this property in
   * a TSMDocument indicates that the event handlers associated with
   * the TSMDocument are aware of TSM's GlyhInfo data structure.  This
   * structure allows the input source producing text to apply Glyph
   * IDs, CIDs, or Fonts to subranges of text produced. This is useful
   * for characters in Unicode private use area, such as Windings. For
   * more information, see the Glyph Access protocol described in
   * TechNote TN20TT. By convention, this value can be a UInt32 with a
   * value of 0, but this is really arbitrary.  Simply test for
   * existence of the property. Property available in TSM 1.5 from
   * MacOSX 10.2 and later
   */
  kTSMDocumentSupportGlyphInfoPropertyTag = 'dpgi', /*  property value is arbitrary*/

  /*
   * Property is value-independent.  The presence of this property tag
   * indicates that the TSMDocument should use TSM's floating input
   * window to handle input from input methods.  This form of input
   * does not support Unicode input by default, unless the
   * UnicodeInputWindow property is set. By convention, this value can
   * be a UInt32 with a value of 0, but this is really arbitrary. 
   * Simply test for existence of the property. Property available in
   * TSM 2.2 and later
   */
  kTSMDocumentUseFloatingWindowPropertyTag = 'uswm', /*    use bottom-line input (floating TSM) window for text input*/

  /*
   * Property is value-independent.  The presence of this property tag
   * indicates that although the TSMDocument has been told to use TSM's
   * floating input window to handle input from input methods, the
   * floating window is to support Unicode input.  This is useful when
   * non input-related activity is to produce Unicode, such as keyboard
   * navigation . By convention, this value can be a UInt32 with a
   * value of 0, but this is really arbitrary.  Simply test for
   * existence of the property. Property available in TSM 2.2 and later
   */
  kTSMDocumentUnicodeInputWindowPropertyTag = 'dpub', /*    Unicode support in bottom line input window*/

  /*
   * Property is value-independent.  The presence of this property tag
   * indicates that the event handlers associated with this TSMDocument
   * support TSM's DocumentAccess event suite (see CarbonEvents.h) This
   * property also indicates that the handler for TSM's
   * kEventTextInputUpdateActiveInputArea event supports the
   * 'replaceRange' parameter and that the handler is a Carbon event
   * handler, not an AppleEvent handler. By convention, this value can
   * be a UInt32 with a value of 0, but this is really arbitrary. 
   * Simply test for existence of the property. Property available in
   * TSM 2.2 and later
   */
  kTSMDocumentSupportDocumentAccessPropertyTag = 'dapy', /*    support TSM Document Access protocol*/
                                        /*    Older names, to be deprecated*/
  kTSMDocumentPropertySupportGlyphInfo = kTSMDocumentSupportGlyphInfoPropertyTag,
  kTSMDocumentPropertyUnicodeInputWindow = kTSMDocumentUnicodeInputWindowPropertyTag, /*    */
                                        /*    Settable value-dependent properties*/
                                        /*    Property values for the following property tags are meaningful*/

  /*
   * Property is value-dependent.  The property value initially
   * contains the Refcon value passed to NewTSMDocument. This property
   * is useful for changing the refcon on-the-fly after the TSMDocument
   * has been created. Property available in TSM 2.2 and later
   */
  kTSMDocumentRefconPropertyTag = 'refc', /*    refcon passed to NewTSMDocument (SRefCon)*/

  /*
   * Property is value-dependent.  The property value indicates which
   * input mode should be used by the current keyboard-class input
   * method.  It is useful for temporarily restricting text input to a
   * subset of characters normally produced by an input method in a
   * given script, such as Katakana for Japanese input.  See details in
   * TextServiceProperty API below. Also note that this property tag
   * and value are passed unchanged to the TextServiceProperty API, so
   * it also serves as a TextServicePropertyTag. See
   * kTextServiceInputModePropertyTag for discussion on the values
   * associated with this property. Usage Note:  Property value is a
   * CFStringRef. With TSMGetDocumentProperty, the behavior is that of
   * a Copy function, and TSMSetDocumentProperty retain the CFString...
   * in either case the caller is responsible for releasing its
   * reference. Property available in TSM 2.2 and later
   */
  kTSMDocumentInputModePropertyTag = 'imim', /*    Input mode property for input methods (CFStringRef - see Input Modes below)*/

  /*
   * Property is value-dependent.  The property value indicates the
   * level of the window that will host inline input sessions for a
   * given TSMDocument. Input Methods will query this property to
   * determine the level above which its "candidate" (floating)
   * window(s) should be positioned, typically by adding its window to
   * a window group (see Carbon's WindowGroup API) and incrementing the
   * level for the group.  If no level is available, the input method
   * is expected to use the default behavior, i.e. let the Window
   * Manager manage the level for floating windows. Window levels are
   * typed as CGWindowLevel. NSWindow levels are accessed through
   * NSWindow's (int)level method. Property available in TSM 2.3 and
   * later
   */
  kTSMDocumentWindowLevelPropertyTag = 'twlp', /*    document window level (CGWindowLevel)*/

  /*
   * Property is value-dependent.  The property value is a
   * TISInputSourceRef specifying a keyboard input source that should
   * override whatever the System considers to be the current input
   * source at the time the TSMDocument is activated (i.e. when the
   * text field gains focus).  If the TSMDocument is already active
   * when this property is set, the specified input source is selected.
   * Usage Note:  Property value is a TISInputSourceRef. With
   * TSMGetDocumentProperty, the behavior is that of a Copy function,
   * and TSMSetDocumentProperty retain the CFString... in either case
   * the caller is responsible for releasing its reference. Property
   * available in TSM 2.4 (Mac OS X 10.5) and later
   */
  kTSMDocumentInputSourceOverridePropertyTag = 'inis', /*  Set an override (Initial) Input source*/

  /*
   * Property is value-dependent.  The property value is a CFArrayRef
   * containing an array of keyboard input sources (TISInputSourceRef)
   * available to the user. This is used to restrict keyboard input to
   * the specified set of input sources. The array should be a subset
   * of those keyboard input sources available to the user according to
   * the System, i.e. the enabled input sources in the International
   * Preferences pane or the Text Input menu. Since this input source
   * may need to be recomputed when input sources are enabled or
   * disabled either by the user or programmatically, this value should
   * be recomputed when the
   * kTISNotifyEnabledKeyboardInputSourcesChanged notification is
   * received or before a call to ActivateTSMDocument. If the set of
   * enabled input sources specified consists of only one input source,
   * it will be automatically selected. Usage Note:  Property value is
   * a CFArrayRef. With TSMGetDocumentProperty, the behavior is that of
   * a Copy function, and TSMSetDocumentProperty retain the CFString...
   * in either case the caller is responsible for releasing its
   * reference. Property available in TSM 2.4 (Mac OS X 10.5) and later
   */
  kTSMDocumentEnabledInputSourcesPropertyTag = 'enis' /*  Restrict input to this set of enabled Input sources*/
};


/*
 *  TSMSetDocumentProperty()
 *  
 *  Summary:
 *    Set a TSMDocument property
 *  
 *  Discussion:
 *    With the following property APIs, you can attach any piece of
 *    data you'd like to a TSMDocument.  Other uses include setting a
 *    (value-independent) property for input methods to query in order
 *    to determine an application's compliance with various TSM
 *    protocols. NOTE:  Property values are currently typed as SInt32,
 *    but should really be a void* since a variety of data types are
 *    used in practice. Note that the semantics for refcounted objects
 *    is ambiguous, so retain/release model is discussed for each
 *    TSM-defined property individually.  (See notes for
 *    TSMDocumentPropertyTag) Error Codes (MacErrors.h): 
 *    tsmComponentPropertyUnsupportedErr tsmInputModeChangeFailedErr
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TSMSetDocumentProperty(
  TSMDocumentID            docID,
  TSMDocumentPropertyTag   propertyTag,
  UInt32                   propertySize,
  void *                   propertyData)                      AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  TSMGetDocumentProperty()
 *  
 *  Summary:
 *    Get a TSMDocument property
 *  
 *  Discussion:
 *    With the following property APIs, you can attach any piece of
 *    data you'd like to a TSMDocument.  Other uses include setting a
 *    (value-independent) property for input methods to query in order
 *    to determine an application's compliance with various TSM
 *    protocols. NOTE:  Property values are currently typed as SInt32,
 *    but should really be a void* since a variety of data types are
 *    used in practice. Note that the semantics for refcounted objects
 *    is ambiguous, so retain/release model is discussed for each
 *    TSM-defined property individually.  (See notes for
 *    TSMDocumentPropertyTag) Error Codes (MacErrors.h)
 *    tsmDocPropertyNotFoundErr tsmDocPropertyBufferTooSmallErr
 *    tsmComponentPropertyNotFoundErr tsmComponentPropertyUnsupportedErr
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TSMGetDocumentProperty(
  TSMDocumentID            docID,
  TSMDocumentPropertyTag   propertyTag,
  UInt32                   bufferSize,
  UInt32 *                 actualSize,
  void *                   propertyBuffer)       /* can be NULL */ AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;


/*
 *  TSMRemoveDocumentProperty()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.2 and later in Carbon.framework
 *    CarbonLib:        not available in CarbonLib 1.x, is available on Mac OS X version 10.2 and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
TSMRemoveDocumentProperty(
  TSMDocumentID            docID,
  TSMDocumentPropertyTag   propertyTag)                       AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;



/* Language and Script constants*/
enum {
  kUnknownLanguage              = 0xFFFF,
  kUnknownScript                = 0xFFFF,
  kNeutralScript                = 0xFFFF
};


enum {
                                        /* Component Flags in ComponentDescription */
  bTakeActiveEvent              = 15,   /* bit set if the component takes active event */
  bHandleAERecording            = 16,   /* bit set if the component takes care of recording Apple Events <new in vers2.0> */
  bScriptMask                   = 0x00007F00, /* bit 8 - 14 */
  bLanguageMask                 = 0x000000FF, /* bit 0 - 7  */
  bScriptLanguageMask           = bScriptMask + bLanguageMask /* bit 0 - 14  */
};


enum {
                                        /* Low level routines which are dispatched directly to the Component Manager */
  kCMGetScriptLangSupport       = 0x0001, /* Component Manager call selector 1 */
  kCMInitiateTextService        = 0x0002, /* Component Manager call selector 2 */
  kCMTerminateTextService       = 0x0003, /* Component Manager call selector 3 */
  kCMActivateTextService        = 0x0004, /* Component Manager call selector 4 */
  kCMDeactivateTextService      = 0x0005, /* Component Manager call selector 5 */
  kCMTextServiceEvent           = 0x0006, /* Component Manager call selector 6 */
  kCMTextServiceEventRef        = kCMTextServiceEvent,
  kCMGetTextServiceMenu         = 0x0007, /* Component Manager call selector 7 */
  kCMTextServiceMenuSelect      = 0x0008, /* Component Manager call selector 8 */
  kCMFixTextService             = 0x0009, /* Component Manager call selector 9 */
  kCMSetTextServiceCursor       = 0x000A, /* Component Manager call selector 10 */
  kCMHidePaletteWindows         = 0x000B, /* Component Manager call selector 11 */
  kCMGetTextServiceProperty     = 0x000C, /* Component Manager call selector 12 */
  kCMSetTextServiceProperty     = 0x000D, /* Component Manager call selector 13 */
  kCMUCTextServiceEvent         = 0x000E, /* Component Manager call selector 14 */
  kCMCopyTextServiceInputModeList = 0x000F, /* Component Manager call selector 15 */
  kCMInputModePaletteItemHit    = 0x0010, /* Component Manager call selector 16 */
  kCMGetInputModePaletteMenu    = 0x0011 /* Component Manager call selector 17 */
};



/* extract Script/Language code from Component flag ... */
#define     mGetScriptCode(cdRec)       ((ScriptCode)   ((cdRec.componentFlags & bScriptMask) >> 8))
#define     mGetLanguageCode(cdRec)     ((LangCode)     cdRec.componentFlags & bLanguageMask)

/* Text Service Info List */
struct TextServiceInfo {
  Component           fComponent;
  Str255              fItemName;
};
typedef struct TextServiceInfo          TextServiceInfo;
typedef TextServiceInfo *               TextServiceInfoPtr;
struct TextServiceList {
  short               fTextServiceCount;      /* number of entries in the 'fServices' array */
  TextServiceInfo     fServices[1];           /* Note: array of 'TextServiceInfo' records follows */
};
typedef struct TextServiceList          TextServiceList;
typedef TextServiceList *               TextServiceListPtr;
typedef TextServiceListPtr *            TextServiceListHandle;
struct ScriptLanguageRecord {
  ScriptCode          fScript;
  LangCode            fLanguage;
};
typedef struct ScriptLanguageRecord     ScriptLanguageRecord;
struct ScriptLanguageSupport {
  SInt16              fScriptLanguageCount;   /* number of entries in the 'fScriptLanguageArray' array */
  ScriptLanguageRecord  fScriptLanguageArray[1]; /* Note: array of 'ScriptLanguageRecord' records follows */
};
typedef struct ScriptLanguageSupport    ScriptLanguageSupport;
typedef ScriptLanguageSupport *         ScriptLanguageSupportPtr;
typedef ScriptLanguageSupportPtr *      ScriptLanguageSupportHandle;
struct TSMGlyphInfo {
  CFRange             range;
  ATSFontRef          fontRef;
  UInt16              collection;             /*    kGlyphCollectionXXX enum*/
  UInt16              glyphID;                /*    GID (when collection==0) or CID*/
};
typedef struct TSMGlyphInfo             TSMGlyphInfo;
struct TSMGlyphInfoArray {
  ItemCount           numGlyphInfo;
  TSMGlyphInfo        glyphInfo[1];
};
typedef struct TSMGlyphInfoArray        TSMGlyphInfoArray;

/* High level TSM Doucment routines */
#if !__LP64__
/*
 *  NewTSMDocument()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
NewTSMDocument(
  SInt16              numOfInterface,
  InterfaceTypeList   supportedInterfaceTypes,
  TSMDocumentID *     idocID,
  SRefCon             refcon)                                 AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


#endif  /* !__LP64__ */

#if !__LP64__
/*
 *  DeleteTSMDocument()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
DeleteTSMDocument(TSMDocumentID idocID)                       AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  ActivateTSMDocument()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
ActivateTSMDocument(TSMDocumentID idocID)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  DeactivateTSMDocument()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
DeactivateTSMDocument(TSMDocumentID idocID)                   AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  FixTSMDocument()
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
FixTSMDocument(TSMDocumentID idocID)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  GetServiceList()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TISCreateInputSourceList API instead:
 *     kTISPropertyInputSourceType =
 *    kTISTypeKeyboardInputMethodWithoutModes and/or
 *    kTISTypeKeyboardInputMethodModeEnabled
 *    kTISPropertyBundleID = <input method bundle identifier of
 *    interest>
 *  
 *  Summary:
 *    Used to get a list of installed input method Components
 *  
 *  Discussion:
 *    This API was typically used to track down the Component ID for a
 *    specific input method from the Component Manager's list of
 *    installed Components, usually by componentType, componentSubType,
 *    and/or componentManufacturer.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
GetServiceList(
  SInt16                   numOfInterface,
  const OSType *           supportedInterfaceTypes,
  TextServiceListHandle *  serviceInfo,
  SInt32 *                 seedValue)                         AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  OpenTextService()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
OpenTextService(
  TSMDocumentID        idocID,
  Component            aComponent,
  ComponentInstance *  aComponentInstance)                    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  CloseTextService()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
CloseTextService(
  TSMDocumentID       idocID,
  ComponentInstance   aComponentInstance)                     AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SendAEFromTSMComponent()   *** DEPRECATED ***
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
SendAEFromTSMComponent(
  const AppleEvent *  theAppleEvent,
  AppleEvent *        reply,
  AESendMode          sendMode,
  AESendPriority      sendPriority,
  SInt32              timeOutInTicks,
  AEIdleUPP           idleProc,
  AEFilterUPP         filterProc)                             AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SendTextInputEvent()
 *  
 *  Discussion:
 *    This API replaces SendAEFromTSMComponent on Mac OS X only. Input
 *    Methods on Mac OS X are Carbon Event based instead of AppleEvent
 *    based.  The Carbon TextInput events which they generate are
 *    provided to TSM for dispatching via this API.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only]
 *    CarbonLib:        in CarbonLib N.e.v.e.r and later
 *    Non-Carbon CFM:   not available
 */
extern OSStatus 
SendTextInputEvent(EventRef inEvent)                          AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;


/*
 *  SetDefaultInputMethod()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TISSelectInputSource API
 *  
 *  Summary:
 *    Set the input method Component ID to be used for the specified
 *    script/language.
 *  
 *  Discussion:
 *    This API also switches to the specified script/language.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
SetDefaultInputMethod(
  Component               ts,
  ScriptLanguageRecord *  slRecordPtr)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetDefaultInputMethod()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TISCopyCurrentKeyboardInputSource API and query its
 *    properties.  If the current input source does not support the
 *    specified script/language, use TISCopyInputSourceForLanguage to
 *    find one that does.
 *  
 *  Summary:
 *    Get the default (last used) input method Component ID for the
 *    specified script/language.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
GetDefaultInputMethod(
  Component *             ts,
  ScriptLanguageRecord *  slRecordPtr)                        AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  SetTextServiceLanguage()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TISSelectInputSource API
 *  
 *  Summary:
 *    Switch to the last used input method (if any) for the specified
 *    script/language.
 *  
 *  Mac OS X threading:
 *    Not thread safe
 *  
 *  Availability:
 *    Mac OS X:         in version 10.0 and later in Carbon.framework [32-bit only] but deprecated in 10.5
 *    CarbonLib:        in CarbonLib 1.0 and later
 *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
 */
extern OSErr 
SetTextServiceLanguage(ScriptLanguageRecord * slRecordPtr)    AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_5;


/*
 *  GetTextServiceLanguage()   *** DEPRECATED ***
 *  
 *  Deprecated:
 *    Use TISCopyCurrentKeyboardInputSource API and query its
 *    properties, such as kTISPropertyInputSourceLanguages.
 *  
 *  Summary:
 *    Get the current script/language.
 *  
 *  Mac OS X threading:
 *    Not thread