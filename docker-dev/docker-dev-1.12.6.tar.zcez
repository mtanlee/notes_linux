SHLIB */
/*
 * This file contains the routines to manage the merging of the symbols.
 * It builds a merged symbol table and string table for external symbols.
 * It also contains all other routines that deal with symbols.
 */
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <stdio.h>
#include <ctype.h>
#include <mach/mach.h>
#else /* defined(KLD) && defined(__STATIC__) */
#include <mach/kern_return.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */
#include <stdarg.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/stab.h>
#include <mach-o/ldsyms.h>
#include <ar.h>
#include "stuff/bool.h"
#include "stuff/bytesex.h"
#include "stuff/macosx_deployment_target.h"
#ifndef RLD
#include "stuff/symbol_list.h"
#endif

#include "ld.h"
#include "specs.h"
#include "live_refs.h"
#include "objects.h"
#include "sections.h"
#include "pass1.h"
#include "symbols.h"
#include "layout.h"
#include "pass2.h"
#include "sets.h"
#include "hash_string.h"
#include "dylibs.h"
#include "mod_sections.h"

#ifdef RLD
__private_extern__ char *base_name;
#endif

/*
 * The head of the symbol list and the total count of all external symbols
 * in the list.  The total count of private externals is included in the total
 * count of the merged symbols.  The private externals may end up as global or
 * static depending on the -keep_private_externs flag.  The count of merged
 * symbols referenced only from dylibs will not be in the output file.
 */
__private_extern__ struct merged_symbol_root *merged_symbol_root = NULL;
__private_extern__ unsigned long nmerged_symbols = 0;
__private_extern__ unsigned long nmerged_private_symbols = 0;
__private_extern__ unsigned long nmerged_symbols_referenced_only_from_dylibs =0;

/*
 * nstripped_merged_symbols is set to the number of merged symbol being stripped
 * out when -dead_strip is specified or the strip_level is
 * STRIP_DYNAMIC_EXECUTABLE.
 */
__private_extern__ unsigned long nstripped_merged_symbols = 0;
/*
 * When -dead_strip is specified some of these the merged private symbols may
 * get stripped. To allow assign_output_symbol_indexes() to recalculate the
 * value of nstripped_merged_symbols when it sets the strip_level to
 * STRIP_DYNAMIC_EXECUTABLE it starts with this value and then adds the
 * additional merged symbols to strip.  This value is also used to do its
 * consistency check after assigning local symbol indexes.
 * nstripped_merged_private_symbols is set in count_live_symbols().
 */
static unsigned long nstripped_merged_private_symbols = 0;

/*
 * The head of the list of the blocks that store the strings for the merged
 * symbols and the total size of all the strings.
 */
__private_extern__ struct string_block *merged_string_blocks = NULL;
__private_extern__ unsigned long merged_string_size = 0;

/*
 * To order the merged symbol table these arrays are allocated and filled in by
 * assign_output_symbol_indexes() to assign the output symbol indexes and then
 * used by output_merged_symbols() to put the symbols out in that order.
 */
static struct merged_symbol **undefsyms_order = NULL;
static struct merged_symbol **extdefsyms_order = NULL;
/*
 * The current order of an undefined symbol.  This is set into the merged_symbol
 * and later used if bind_at_load is set to sort the undefined symbols by so
 * they are in the order the were seen by the static linker.
 */
static int undef_order = 0;
#ifndef SA_RLD
/*
 * The qsort routines used by assign_output_symbol_indexes() to order the merged
 * symbol table.
 */
static int qsort_by_module(
    const struct merged_symbol **ms1,
    const struct merged_symbol **ms2);
static int qsort_by_name(
    const struct merged_symbol **ms1,
    const struct merged_symbol **ms2);
static int qsort_by_undef_order(
    const struct merged_symbol **ms1,
    const struct merged_symbol **ms2);
#endif /* !defined(SA_RLD) */

/*
 * The number of local symbols that will appear in the output file and the
 * size of their strings.
 */
__private_extern__ unsigned long nlocal_symbols = 0;
__private_extern__ unsigned long local_string_size = 0;

/*
 * The things to deal with creating local symbols with the object file's name
 * for a given section.  If the section name is (__TEXT,__text) these are the
 * same as a UNIX link editor's file.o symbols for the text section.
 */
__private_extern__ struct sect_object_symbols sect_object_symbols = { FALSE };

/*
 * The head of the undefined list and the list of free undefined structures.
 * These are circular lists so they can be searched from start to end and so
 * new items can be put on the end.  These two structure never has their
 * merged_symbol filled in but they only serve as the heads and tails of there
 * lists.
 */
__private_extern__ struct undefined_list undefined_list = {
    NULL, &undefined_list, &undefined_list
};
static struct undefined_list free_list = {
    NULL, &free_list, &free_list
};
/*
 * The structures for the undefined list are allocated in blocks and placed on
 * a free list.  They are allocated in blocks so they can be free()'ed quickly.
 */
#define NUNDEF_BLOCKS	680
static struct undefined_block {
    struct undefined_list undefineds[NUNDEF_BLOCKS];
    struct undefined_block *next;
} *undefined_blocks;

#ifndef RLD
/*
 * The common symbol load map.  Only allocated and filled in if load map is
 * requested.
 */
__private_extern__ struct common_load_map common_load_map = { 0 };

/*
 * These symbols are used by the routines command_line_symbol(),
 * command_line_indr_symbol() and merge_dylib_symbols() to create symbols from
 * the command line options (-u and -i) and from dylibs.
 */
static struct nlist undefined_symbol = {
    {0},		/* n_un.n_strx */
    N_UNDF | N_EXT,	/* n_type */
    NO_SECT,		/* n_sect */
    0,			/* n_desc */
    0			/* n_value */
};
static struct nlist indr_symbol = {
    {0},		/* n_un.n_strx */
    N_INDR | N_EXT,	/* n_type */
    NO_SECT,		/* n_sect */
    0,			/* n_desc */
    0			/* n_value */
};
static struct nlist pbud_symbol = {
    {0},		/* n_un.n_strx */
    N_PBUD | N_EXT,	/* n_type */
    NO_SECT,		/* n_sect */
    REFERENCE_FLAG_UNDEFINED_LAZY, /* n_desc */
    0			/* n_value */
};
static struct nlist pbud_weak_def_symbol = {
    {0},		/* n_un.n_strx */
    N_PBUD | N_EXT,	/* n_type */
    NO_SECT,		/* n_sect */
    REFERENCE_FLAG_UNDEFINED_LAZY | N_WEAK_DEF, /* n_desc */
    0			/* n_value */
};

/*
 * This symbol is used by the routines that define link editor defined symbols.
 * And the routine sets it up.
 */
static struct object_file *link_edit_symbols_object = NULL;
static void setup_link_edit_symbols_object(
    void);

/*
 * Most of the time there are no local symbols marked with the NO_DEAD_STRIP
 * flag.  Since it is time consuming to mark those blocks we check to see if
 * when have any of them in merge_symbols.
 */
static enum bool local_NO_DEAD_STRIP_symbols = FALSE;
static void mark_N_NO_DEAD_STRIP_local_symbols_in_section_live(
    struct merged_section *ms);
static void removed_dead_local_symbols_in_section(
    struct merged_section *ms);
static void remove_dead_N_GSYM_stabs(
    void);
static void setup_link_editor_symbol(
    char *symbol_name);
static void define_link_editor_dylib_symbol(
    unsigned long header_address,
    char *symbol_name);
static void exports_list_processing(
    char *symbol_name,
    struct nlist *symbol);
static char * find_stab_name_end(
    char *name);
static char * find_stab_type_end(
    char *name_end);
#endif /* !defined(RLD) */
static enum bool is_type_stab(
    unsigned char n_type,
    char *symbol_name);

/*
 * These symbols are used when defining common symbols.  In the RLD case they
 * are templates and thus const and the real versions of these symbols are in
 * the sets array.
 */
static
#if defined(RLD) && !defined(__DYNAMIC__)
const
#endif
struct section link_edit_common_section = {
    SECT_COMMON,	/* sectname */
    SEG_DATA,		/* segname */
    0,			/* addr */
    0,			/* size */
    0,			/* offset */
    0,			/* align */
    0,			/* reloff */
    0,			/* nreloc */
    S_ZEROFILL,		/* flags */
    0,			/* reserved1 */
    0,			/* reserved2 */
};

static
#if defined(RLD) && !defined(__DYNAMIC__)
const
#endif
struct section_map link_edit_section_maps = {
#ifdef RLD
    NULL,		/* struct section *s */
#else
    &link_edit_common_section, /* struct section *s */
#endif /* RLD */
    NULL,		/* output_section */
    0,			/* offset */
    0,			/* flush_offset */
    NULL,		/* fine_relocs */
    0,			/* nfine_relocs */
    FALSE,		/* no_load_order */
    0,			/* order */
    NULL,		/* load_orders */
    0			/* nload_orders */
};

#ifndef RLD
__private_extern__
struct symtab_command link_edit_common_symtab = {
    LC_SYMTAB,		/* cmd */
    sizeof(struct symtab_command),	/* cmdsize */
    0,			/* symoff */
    0,			/* nsyms */
    0,			/* stroff */
    1			/* strsize */
};
#endif /* !defined(RLD) */

__private_extern__
struct object_file link_edit_common_object = {
    "\"link editor\"",	/* file_name */
    NULL,		 /* obj_addr */
    0,			/* obj_size */
    FALSE,		/* swapped */
    FALSE,		/* fvmlib_stuff */
    FALSE,		/* dylib */
    FALSE,		/* dylib_stuff */
    FALSE,		/* bundle_loader */
    0,			/* library_ordinal */
    0,			/* isub_image */
    0,			/* nload_dylibs */
    FALSE,		/* dylinker */
    FALSE,		/* command_line */
    NULL,		/* ar_hdr */
    NULL,		/* ar_name */
    0,			/* ar_name_size */
    NULL,		/* dylib_module */
    1,			/* nsection_maps */
#ifdef RLD
    NULL,		/* section_maps */
    NULL,		/* symtab */
#else
    &link_edit_section_maps,	/* section_maps */
    &link_edit_common_symtab,	/* symtab */
#endif /* RLD */
    NULL,		/* dysymtab */
    NULL,		/* rc */
    0,			/* nundefineds */
    NULL,		/* undefined_maps */
    0,			/* nextdefsym */
    0,			/* iextdefsym */
    0,			/* nprivatesym */
    0,			/* iprivatesym */
    0,			/* cprivatesym */
    0,			/* nlocalsym */
    0,			/* ilocalsym */
    NULL,		/* localsym_blocks */
    NULL		/* cur_section_map */
#ifdef RLD
    ,0,			/* set_num */
    FALSE		/* user_obj_addr */
#endif /* RLD */
};

/*
 * This is the list of multiply defined symbol names.  It is used to make sure
 * an error message for each name is only printed once and it is traced only
 * once.
 */
static char **multiple_defs = NULL;
static unsigned long nmultiple_defs = 0;

/*
 * This is the count of indirect symbols in the merged symbol table.  It is used
 * as the size of an array that needed to be allocated to reduce chains of
 * indirect symbols to their final symbol and to detect circular chains.
 */
static unsigned long nindr_symbols = 0;

/*
 * The indr_symbol_pair structure is used when there are chains of N_INDR
 * that have symbols both from dylibs and not from dylibs.  The routine
 * reduce_indr_symbols() creates this and the routines output_merged_symbols()
 * and indirect_section_merge() both use it.  What is going on is that when
 * producing an output file the N_INDR symbols from a dylib can't be used in
 * a chain of N_INDR symbols.  So this structure contains merged_symbols which
 * are N_INDR which should use the matching indr_symbol from the table instead
 * of going through (struct merged_symbol *)(merged_symbol->nlist.n_value).
 */
__private_extern__ struct indr_symbol_pair *indr_symbol_pairs = NULL;
__private_extern__ unsigned long nindr_symbol_pairs = 0;

/*
 * commons_exist is set and used in define_common_symbols().  noundefs is set
 * and used in process_undefineds().  These are then used in
 * layout_merged_symbols() to properly set the MH_NOUNDEFS flag (which in turn
 * properly set the execute bits of the file).
 */
static enum bool commons_exist = FALSE;
static enum bool noundefs = TRUE;

/*
 * merged_symbols_relocated is set when the merged symbols are relocated to
 * have addresses and section numbers as they would in the output file.
 */
__private_extern__ enum bool merged_symbols_relocated = FALSE;

static struct merged_symbol *enter_symbol(
    struct merged_symbol *hash_pointer,
    struct nlist *object_symbol,
    char *object_strings,
    struct object_file *definition_object);
static void enter_indr_symbol(
    struct merged_symbol *merged_symbol,
    struct nlist *object_symbol,
    char *object_strings,
    struct object_file *definition_object);
static char *enter_string(
    char *symbol_name,
    unsigned long *len_ret);
static void add_to_undefined_list(
    struct merged_symbol *merged_symbol);
static void multiply_defined(
    struct merged_symbol *merged_symbol,
    struct nlist *object_symbol,
    char *object_strings);
static void trace_object_symbol(
    struct nlist *symbol,
    char *strings);
static void trace_symbol(
    char *symbol_name,
    struct nlist *nlist,
    struct object_file *object_file,
    char *indr_symbol_name);
#ifndef RLD
static void define_link_editor_symbol(
    char *symbol_name,
    unsigned char type,
    unsigned char sect,
    short desc,
    unsigned long value);
static void remove_dead_N_GSYM_stabs_for_cur_obj(
    struct nlist *object_symbols,
    char *object_strings);
#endif /* !defined(RLD) */
static unsigned long merged_symbol_string_index(
    char *symbol_name);
static struct string_block *get_string_block(
    char *symbol_name);
static void get_stroff_and_mtime_for_N_OSO(
    unsigned long *stroff_for_N_OSO,
    unsigned long *mtime);

/*
 * Check all the fields of the given symbol in the current object to make sure
 * it is valid.  This is required to that the rest of the code can assume that
 * use the values in the symbol without futher checks and without causing an
 * error.
 */
static
inline
void
check_symbol(
struct nlist *symbol,
char *strings,
unsigned long index)
{
    unsigned long section_type, library_ordinal;

	/* check the n_strx field of this symbol */
	if(symbol->n_un.n_strx < 0 ||
	   (uint32_t)symbol->n_un.n_strx >= cur_obj->symtab->strsize){
	    error_with_cur_obj("bad string table index (%d) for symbol %lu",
			       symbol->n_un.n_strx, index);
	    return;
	}

	/* check the n_type field of this symbol */
	switch(symbol->n_type & N_TYPE){
	case N_UNDF:
	    if((symbol->n_type & N_STAB) == 0 &&
	       (symbol->n_type & N_EXT) == 0){
		error_with_cur_obj("undefined symbol %lu (%s) is not also "
				   "external symbol (N_EXT)", index,
				   symbol->n_un.n_strx == 0 ? "NULL name" :
				   strings + symbol->n_un.n_strx);
		return;
	    }
	    if(symbol->n_type & N_PEXT && symbol->n_value == 0){
		error_with_cur_obj("undefined symbol %lu (%s) can't be "
				   "private external symbol (N_PEXT)", index,
				   symbol->n_un.n_strx == 0 ? "NULL name" :
				   strings + symbol->n_un.n_strx);
		return;
	    }
	    if((symbol->n_type & N_STAB) == 0 &&
	       (((struct mach_header *)(cur_obj->obj_addr))->flags &
	       MH_TWOLEVEL) == MH_TWOLEVEL){
		library_ordinal = GET_LIBRARY_ORDINAL(symbol->n_desc);
		if((library_ordinal == EXECUTABLE_ORDINAL &&
		    ((struct mach_header *)(cur_obj->obj_addr))->filetype !=
		    MH_BUNDLE) ||
		   (library_ordinal != SELF_LIBRARY_ORDINAL &&
		    (library_ordinal != DYNAMIC_LOOKUP_ORDINAL ||
		     cur_obj->nload_dylibs != DYNAMIC_LOOKUP_ORDINAL) &&
		    library_ordinal-1 >= cur_obj->nload_dylibs) ){
		    error_with_cur_obj("undefined symbol %lu (%s) has bad "
				       "library oridinal %lu", index,
				       symbol->n_un.n_strx == 0 ? "NULL name" :
				       strings + symbol->n_un.n_strx,
				       library_ordinal);
		    return;
		}
	    }
	    /* fall through to the check below */
	case N_ABS:
	    if((symbol->n_type & N_STAB) == 0 &&
	       symbol->n_sect != NO_SECT){
		error_with_cur_obj("symbol %lu (%s) must have NO_SECT for "
			    "its n_sect field given its type", index,
			    symbol->n_un.n_strx == 0 ? "NULL name" :
			    strings + symbol->n_un.n_strx);
		return;
	    }
	    break;
	case N_PBUD:
	    if((symbol->n_type & N_STAB) == 0 &&
	       (symbol->n_type & N_EXT) == 0){
		error_with_cur_obj("undefined symbol %lu (%s) is not also "
				   "external symbol (N_EXT)", index,
				   symbol->n_un.n_strx == 0 ? "NULL name" :
				   strings + symbol->n_un.n_strx);
		return;
	    }
	    if((symbol->n_type & N_STAB) == 0 &&
	       symbol->n_sect != NO_SECT){
		error_with_cur_obj("symbol %lu (%s) must have NO_SECT for "
			    "its n_sect field given its type", index,
			    symbol->n_un.n_strx == 0 ? "NULL name" :
			    strings + symbol->n_un.n_strx);
		return;
	    }
	    break;
	case N_SECT:
	    if((symbol->n_type & N_STAB) == 0 &&
	       symbol->n_sect == NO_SECT){
		error_with_cur_obj("symbol %lu (%s) must not have NO_SECT "
			    "for its n_sect field given its type (N_SECT)",
			    index, symbol->n_un.n_strx == 0 ? "NULL name" :
			    strings + symbol->n_un.n_strx);
		return;
	    }
	    break;
	case N_INDR:
	    if(symbol->n_type & N_EXT){
		/* note n_value is unsigned and can't be < 0 */
		if(symbol->n_value >= cur_obj->symtab->strsize){
		    error_with_cur_obj("bad string table index (%u) for "
			"indirect name for symbol %lu (%s)",
			symbol->n_value, index, symbol->n_un.n_strx == 0 ?
			"NULL name" : strings + symbol->n_un.n_strx);
		    return;
		}
	    }
	    else if((symbol->n_type & N_STAB) == 0){
		error_with_cur_obj("indirect symbol %lu (%s) is not also "
				   "external symbol (N_EXT)", index,
				   symbol->n_un.n_strx == 0 ? "NULL name" :
				   strings + symbol->n_un.n_strx);
		return;
	    }
	    if(symbol->n_type & N_PEXT){
		error_with_cur_obj("indirect symbol %lu (%s) can't be "
				   "private external symbol (N_PEXT)", index,
				   symbol->n_un.n_strx == 0 ? "NULL name" :
				   strings + symbol->n_un.n_strx);
		return;
	    }
	    break;
	default:
	    if((symbol->n_type & N_STAB) == 0){
		error_with_cur_obj("symbol %lu (%s) has unknown n_type field "
				   "(0x%x)", index, symbol->n_un.n_strx == 0 ?
				   "NULL name" : strings + symbol->n_un.n_strx,
				   (unsigned int)(symbol->n_type));
		return;
	    }
	    break;
	}

	/*
	 * Check the n_sect field, note sections are numbered from 1 up to and
	 * including the total number of sections (that is the test is > not
	 * >= ).
	 */
	if((unsigned long)(symbol->n_sect) > cur_obj->nsection_maps){
	    error_with_cur_obj("symbol %lu (%s)'s n_sect field (%d) is "
		"greater than the number of sections in this object (%lu)",
		index, symbol->n_un.n_strx == 0 ? "NULL name" : strings +
		symbol->n_un.n_strx, symbol->n_sect, cur_obj->nsection_maps);
	    return;
	}

	/*
	 * Check to make sure this is not an enternal symbol defined in an
	 * indirect section.
	 */
	if((symbol->n_type & N_EXT) != 0 &&
	   (symbol->n_type & N_TYPE) == N_SECT){
	    section_type = (cur_obj->section_maps[symbol->n_sect - 1].s->flags)
			   & SECTION_TYPE;
	    if(section_type == S_NON_LAZY_SYMBOL_POINTERS ||
	       section_type == S_LAZY_SYMBOL_POINTERS ||
	       section_type == S_SYMBOL_STUBS){
		error_with_cur_obj("external symbol %lu (%s) not allowed in an "
		    "indirect section", index, symbol->n_un.n_strx == 0 ?
		    "NULL name" : strings + symbol->n_un.n_strx);
		return;
	    }
	}

	/*
	 * Check to see that any symbol that is marked as a weak_definition
	 * is a global symbol defined in a coalesced section.
	 */
	if((symbol->n_type & N_STAB) == 0 &&
	   (symbol->n_desc & N_WEAK_DEF) == N_WEAK_DEF){
		if((symbol->n_type & N_EXT) == 0 &&
		   (symbol->n_type & N_PEXT) != N_PEXT){
		    error_with_cur_obj("non-external symbol %lu (%s) can't be a"
			" weak definition", index, symbol->n_un.n_strx == 0 ?
			"NULL name" : strings + symbol->n_un.n_strx);
		    return;
		}
		if((symbol->n_type & N_TYPE) == N_UNDF ||
		   (symbol->n_type & N_TYPE) == N_PBUD){
		    error_with_cur_obj("undefined symbol %lu (%s) can't be a "
			"weak definition", index, symbol->n_un.n_strx == 0 ?
			"NULL name" : strings + symbol->n_un.n_strx);
		    return;
		}
		if((symbol->n_type & N_TYPE) != N_SECT){
		    error_with_cur_obj("symbol %lu (%s) can't be a weak "
			"definition (currently only supported in section of "
			"type S_COALESCED)", index, symbol->n_un.n_strx == 0 ?
			"NULL name" : strings + symbol->n_un.n_strx);
		    return;
		}
		else{
		    section_type = (cur_obj->section_maps[symbol->n_sect - 1].
				    s->flags) & SECTION_TYPE;
		    if(section_type != S_COALESCED){
			error_with_cur_obj("symbol %lu (%s) can't be a weak "
			    "definition (currently only supported in section "
			    "of type S_COALESCED)", index, symbol->n_un.n_strx
			    == 0 ? "NULL name" : strings + symbol->n_un.n_strx);
			return;
		    }
		}
	}

	/*
	 * Check to make sure this symbols is not in a debug section.
	 */
	if((symbol->n_type & N_TYPE) == N_SECT &&
	   ((cur_obj->section_maps[symbol->n_sect - 1].s->flags)
	      & S_ATTR_DEBUG) == S_ATTR_DEBUG){
	    error_with_cur_obj("malformed object, symbols not allowed in debug "
		"sections (symbol %lu (%s) is in debug section (%.16s,%.16s)",
		index, symbol->n_un.n_strx == 0 ? "NULL name" :
		strings + symbol->n_un.n_strx,
		cur_obj->section_maps[symbol->n_sect - 1].s->segname,
		cur_obj->section_maps[symbol->n_sect - 1].s->sectname);
	    return;
	}
}

/*
 * relocate_symbol() relocates the specified symbol pointed to by nlist in the
 * object file pointed to by object file.  It modifies the section number of
 * the symbol and the value of the symbol to what it should be in the output
 * file.
 */
static
inline
void
relocate_symbol(
struct nlist *nlist,
struct object_file *object_file)
{
    struct section_map *section_map;

	/*
	 * If this symbol is not in a section then it is not changed.
	 */
	if(nlist->n_sect == NO_SECT)
	    return;
#ifdef RLD
	/*
	 * If this symbol is not in the current set of objects being linked
	 * and loaded it does not get relocated.
	 */
	if(object_file->set_num != cur_set)
	    return;
#endif /* RLD */

	/*
	 * Change the section number of this symbol to the section number it
	 * will have in the output file.  For RLD all section numbers are left
	 * as they are in the input file they came from so that a future call
	 * to trace_symbol() will work.  If they are are written to an output
	 * file then they are updated in the output memory buffer by the
	 * routines that output the symbols so to leave the merged symbol table
	 * data structure the way it is.
	 */
	section_map = &(object_file->section_maps[nlist->n_sect - 1]);
#ifndef RLD
	nlist->n_sect = section_map->output_section->output_sectnum;
#endif /* RLD */

	/*
	 * If this symbol comes from base file of an incremental load
	 * then it's value is not adjusted.
	 */
	if(object_file == base_obj)
	    return;
	/*
	 * Adjust the value of this symbol by it's section.  The base
	 * of the section in the object file it came from is subtracted
	 * the base of the section in the output file is added and the
	 * offset this section appears in the output section is added.
	 *
	 * value += - old_section_base_address
	 *	    + new_section_base_address
	 *	    + offset_in_the_output_section;
	 *
	 * If the symbol is in a section that has fine relocation then
	 * it's value is set to where the value is in the output file
	 * by using the offset in the input file's section and getting
	 * the offset in the output file's section (via the fine
	 * relocation structures) and adding the address of that section
	 * in the output file.
	 */
	if(section_map->nfine_relocs == 0)
	    nlist->n_value += - section_map->s->addr
			      + section_map->output_section->s.addr
			      + section_map->offset;
	else
	    nlist->n_value = fine_reloc_output_offset(section_map,
						      nlist->n_value -
						      section_map->s->addr)
			     + section_map->output_section->s.addr;
}

#ifndef RLD
/*
 * When removing stabs from duplicate include files this hash table and
 * structure keeps the list of ones we have already seen.
 */
struct include_file {
    char *include_file_name;
    unsigned long sum;
#ifdef DEBUG
    char *object_file_name;
    unsigned long index;
#endif
    struct include_file *next;
};
#define INCLUDE_HASH_SIZE 1000
static struct include_file *include_file_hash_table[INCLUDE_HASH_SIZE] = { 0 };

/*
 * lookup_and_enter_include() looks up the include file name to see if we have
 * seen it with this sum before.  If it has not been seen before we return
 * TRUE indicating this is new and record the name and sum in the hash table.
 * If it is not new we return FALSE indicating we have seen this before.
 */
static
enum bool
lookup_and_enter_include(
char *include_file_name,
unsigned long sum,
unsigned long index,
enum bool next_eincl)
{
    unsigned long hash_index;
    struct include_file *include_file, *p, *q;

	hash_index = hash_string(include_file_name, NULL) % INCLUDE_HASH_SIZE;
	if(include_file_hash_table[hash_index] == NULL){
	    include_file = allocate(sizeof(struct include_file));
	    memset(include_file, '\0', sizeof(struct include_file));
	    include_file_hash_table[hash_index] = include_file;
	    include_file->include_file_name = include_file_name;
	    include_file->sum = sum;
#ifdef DEBUG
	    include_file->object_file_name = cur_obj->file_name;
	    include_file->index = index;
#endif
	    include_file_hash_table[hash_index] = include_file;
	    return(TRUE);
	}
	/*
	 * Look through the hash buckets and see if this is the same include
	 * file name with the same sum is found.  If so return FALSE indicating
	 * this is not new.
	 */
	p = include_file_hash_table[hash_index];
	for(;;){
	    if(p->sum == sum &&
	       strcmp(p->include_file_name, include_file_name) == 0)
#ifdef OPTIMISTIC
	    /*
	     * Be very very optimistic and assume if the names match and
	     * as long as neither sum is zero or they are zero and they
	     * match the header really should be the same.
	     */
	    if(strcmp(p->include_file_name, include_file_name) == 0 &&
	       (p->sum == sum || (p->sum != 0 && sum != 0)))
#endif /* OPTIMISTIC */
	    {
#ifdef DEBUG
		if(debug & (1 << 24))
		    printf("include file = %s in object file = %s has same "
		       "sum as previous object file = %s\n",
		       include_file_name, cur_obj->file_name,
		       p->object_file_name);
#endif /* DEBUG */
		return(FALSE);
	    }
	    if(p->next == NULL){
#ifdef DEBUG
		q = include_file_hash_table[hash_index];
		for(;;){
		    if(debug & (1 << 23) &&
		       strcmp(q->include_file_name, include_file_name) == 0 &&
		       q->sum != sum && sum != 0 && q->sum != 0 &&
		       next_eincl == FALSE){
			if(debug & (1 << 23))
			    printf("include file = %s in object file = %s at "
				   "index %lu with different sum than previous "
				   "object file = %s at index %lu\n",
				   include_file_name, cur_obj->file_name, index,
				   q->object_file_name, q->index);
			break;
		    }
		    if(q->next == NULL)
			break;
		    else
			q = q->next;
		}
#endif /* DEBUG */
		break;
	    }
	    else
		p = p->next;
	}

	/*
	 * We did not find this include file with the same sum. So create a new
	 * entry for this one and hang it off the hash chain.
	 */
	include_file = allocate(sizeof(struct include_file));
	memset(include_file, '\0', sizeof(struct include_file));
	p = include_file_hash_table[hash_index];
	include_file_hash_table[hash_index] = include_file;
	include_file->include_file_name = include_file_name;
	include_file->sum = sum;
#ifdef DEBUG
	include_file->object_file_name = cur_obj->file_name;
	include_file->index = index;
#endif
	include_file->next = p;
	return(TRUE);
}
#endif /* !defined(RLD) */

/*
 * count_dwarf_symbols() returns the number of DWARF symbols that would
 * be generated by SYM, which must be in the current object.  It is the
 * pass1 counterpart of add_dwarf_map_for_sym.
 */
static size_t
count_dwarf_symbols(const struct nlist *sym,
		    size_t i, const size_t * debug_ptr)
{
  size_t cnt;

  /* The debug map only represents symbols which are defined in
     a particular section or which are global common symbols.  */
  if ((sym->n_type & (N_TYPE | N_STAB)) != N_SECT
      && ((sym->n_type & (N_TYPE | N_STAB)) != N_UNDF
	  || sym->n_value == 0))
    return 0;
  /* If S_ATTR_STRIP_STATIC_SYMS is set on this symbol's section,
     we don't need a debug symbol for this symbol.  */
  if ((sym->n_type & (N_TYPE | N_STAB)) == N_SECT
      && (cur_obj->section_maps[sym->n_sect - 1].s->flags &
	  S_ATTR_STRIP_STATIC_SYMS))
    return 0;
  if (! debug_ptr || *debug_ptr != i)
    return 1;
  for (cnt = 0; debug_ptr[cnt + 2] & 0x80000000; cnt++)
    ;
  return cnt + 4;
}

/*
 * 'merged_symbol' is about to have its defining object changed.  If the
 * symbol was from a .o file with DWARF, remove the corresponding
 * DWARF symbols.
 */
static void
maybe_remove_dwarf_symbol (struct merged_symbol *merged_symbol)
{
  struct object_file * mo = merged_symbol->definition_object;
  struct object_file * cur_o = cur_obj;
  size_t * debug_ptr = mo->dwarf_source_data;
  size_t n;
  struct nlist * obj_symbols;
  char * obj_strings;
  size_t i;

  if (! merged_symbol->definition_object->dwarf_name)
    return;
  
  obj_symbols = (struct nlist *) (mo->obj_addr + mo->symtab->symoff);
  obj_strings = mo->obj_addr + mo->symtab->stroff;
  i = 0;
  while (strcmp (obj_strings + obj_symbols[i].n_un.n_strx,
		 merged_symbol->nlist.n_un.n_name) != 0)
    i++;
  if (debug_ptr)
    while (*debug_ptr < i)
      for (debug_ptr += 2; *debug_ptr & 0x80000000; debug_ptr++)
      ;
  cur_obj = mo;
  n = count_dwarf_symbols (obj_symbols + i, i, debug_ptr);
  cur_obj = cur_o;
  merged_symbol->definition_object->nlocalsym -= n;
  nlocal_symbols -= n;
}

/*
 * merge_symbols() merges the symbols from the current object (cur_obj) into
 * the merged symbol table.
 */
__private_extern__
void
merge_symbols(void)
{
    unsigned long i, j, object_undefineds, nrefsym, output_strlen;
    struct nlist *object_symbols;
    char *object_strings;
    struct merged_symbol *hash_pointer, *merged_symbol;
    enum bool discarded_coalesced_symbol;
    enum bool discarded_multiply_defined_symbol;
    unsigned short n_desc;
    size_t * debug_ptr;

#ifndef RLD
    unsigned long nest, sum, k;
    enum bool no_exclusion;
    char *stab_string, *include_file_name;
    struct localsym_block *localsym_block, *temp_localsym_block,
			  **next_localsym_block, *cur_localsym_block;
#endif

#if defined(DEBUG) || defined(RLD)
	/* The compiler "warning: `merged_symbol' may be used uninitialized */
	/* in this function" can safely be ignored */
	merged_symbol = NULL;
#endif

	/* If this object file has no symbols then just return */
	if(cur_obj->symtab == NULL)
	    return;

	/* setup pointers to the symbol table and string table */
	object_symbols = (struct nlist *)(cur_obj->obj_addr +
					  cur_obj->symtab->symoff);
	object_strings = (char *)(cur_obj->obj_addr + cur_obj->symtab->stroff);
	if(cur_obj->swapped &&
	   (((struct mach_header *)cur_obj->obj_addr)->filetype != MH_DYLIB ||
	    ((struct mach_header *)cur_obj->obj_addr)->filetype !=
	     MH_DYLIB_STUB))
	    swap_nlist(object_symbols, cur_obj->symtab->nsyms, host_byte_sex);


	/*
	 * For all the strings of the symbols to be valid the string table must
	 * end with a '\0'.
	 */
	if(cur_obj->symtab->strsize > 0 &&
	   object_strings[cur_obj->symtab->strsize - 1] != '\0'){
	    error_with_cur_obj("string table does not end with a '\\0'");
	    return;
	}

	/*
	 * If this object is not the base file count the number of undefined
	 * externals and commons in this object so that an undefined external
	 * map for this object can be allocated and then it will be filled in
	 * as these undefined external symbols are looked up in the merged
	 * symbol table.  This map will be used when doing relocation for
	 * external relocation entries in pass2 (and is not needed for the base
	 * file because that is not relocated or copied in to the output).
	 */
	object_undefineds = 0;
	for(i = 0; i < cur_obj->symtab->nsyms; i++){
	    check_symbol(&(object_symbols[i]), object_strings, i);
	    if(errors)
		return;
	    if((object_symbols[i].n_type & N_EXT) == N_EXT &&
	       (object_symbols[i].n_type & N_TYPE) == N_UNDF)
		object_undefineds++;
	    /*
	     * Note: coalesced symbols are always defined symbols in each object
	     * file but referenced with external relocation entries.  Since they
	     * are always defined they are not in the count of undefined
	     * symbols or in the undefined map.
	     */
#ifndef RLD
	    /*
	     * If we have an -export_symbols_list or -unexport_symbol_list
	     * option set the private extern bit on symbols that are not to
	     * be exported for global symbols that are not undefined.
	     */
	    if((object_symbols[i].n_type & N_EXT) == N_EXT &&
		object_symbols[i].n_type != (N_EXT | N_UNDF))
		exports_list_processing(object_strings +
					object_symbols[i].n_un.n_strx,
					object_symbols + i);
#endif /* !defined(RLD) */
	    /*
	     * If this is a private external defined symbol (but not a common)
	     * increment the count of private exterals for this object and the
	     * total in the output file.
	     */
	    if((object_symbols[i].n_type & N_EXT) &&
	       (object_symbols[i].n_type & N_PEXT) &&
	       (object_symbols[i].n_type & N_TYPE) != N_UNDF){
		cur_obj->nprivatesym++;
		nmerged_private_symbols++;
	    }
	}
	if(cur_obj != base_obj){
	    cur_obj->nundefineds = object_undefineds;
	    if(cur_obj->nundefineds != 0)
		cur_obj->undefined_maps = allocate(object_undefineds *
					      sizeof(struct undefined_map));
	}

#ifndef RLD
	/*
	 * If the output file type is a multi module dynamic shared library then
	 * count the number of defined externals.  And using this count, the
	 * count of undefined symbols and the count of private externs then
	 * reference map, to build the reference table, is allocated.
	 */
	if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
	    /*
	     * Note: coalesced symbols are always defined symbols in each object
	     * file but referenced with external relocation entries.  If the one
	     * in this object is discarded then cur_obj->nextdefsym is
	     * decremented and the reference_maps[].flags field is changed to
	     * some REFERENCE_FLAG_*_UNDEFINED_* value.  But note that even
	     * though cur_obj->nextdefsym is decremented cur_obj->nundefineds is
	     * NOT incremented.
	     */
	    for(i = 0; i < cur_obj->symtab->nsyms; i++){
		if((object_symbols[i].n_type & N_EXT) == N_EXT &&
		   (object_symbols[i].n_type & N_PEXT) != N_PEXT &&
		   (object_symbols[i].n_type & N_TYPE) != N_UNDF)
			cur_obj->nextdefsym++;
	    }
	    cur_obj->nrefsym = cur_obj->nundefineds + cur_obj->nextdefsym +
			       cur_obj->nprivatesym;
	    cur_obj->irefsym =
			output_dysymtab_info.dysymtab_command.nextrefsyms;
	    output_dysymtab_info.dysymtab_command.nextrefsyms +=
			cur_obj->nrefsym;
	    if(cur_obj->nrefsym != 0)
		cur_obj->reference_maps = allocate(cur_obj->nrefsym *
						  sizeof(struct reference_map));
	}
#endif /* !defined(RLD) */

	/*
	 * If local section object symbols were specified and if local symbols
	 * are to appear in the output file see if this object file has this
	 * section and if so account for this symbol.
	 */
	if(sect_object_symbols.specified &&
	   strip_level != STRIP_ALL &&
	   strip_level != STRIP_NONGLOBALS &&
	   (cur_obj != base_obj || strip_base_symbols == FALSE)){
	    if(sect_object_symbols.ms == NULL)
	        sect_object_symbols.ms = lookup_merged_section(
						  sect_object_symbols.segname,
						  sect_object_symbols.sectname);
	    if(sect_object_symbols.ms != NULL){
		if((sect_object_symbols.ms->s.flags & SECTION_TYPE) ==
			S_CSTRING_LITERALS ||
		   (sect_object_symbols.ms->s.flags & SECTION_TYPE) ==
			S_4BYTE_LITERALS ||
		   (sect_object_symbols.ms->s.flags & SECTION_TYPE) ==
			S_8BYTE_LITERALS ||
		   (sect_object_symbols.ms->s.flags & SECTION_TYPE) ==
			S_LITERAL_POINTERS){
		    warning("section (%s,%s) is a literal section "
			    "and can't be used with -sectobjectsymbols",
			    sect_object_symbols.segname,
			    sect_object_symbols.sectname);
		    sect_object_symbols.specified = FALSE;
		    sect_object_symbols.ms = NULL;
		}
		else if((sect_object_symbols.ms->s.flags & S_ATTR_DEBUG) ==
			S_ATTR_DEBUG){
		    warning("section (%s,%s) is a debug section "
			    "and can't be used with -sectobjectsymbols",
			    sect_object_symbols.segname,
			    sect_object_symbols.sectname);
		    sect_object_symbols.specified = FALSE;
		    sect_object_symbols.ms = NULL;
		}
		else{
		    /*
		     * See if this object file has the section that the section
		     * object symbols are being created for.
		     */
		    for(i = 0; i < cur_obj->nsection_maps; i++){
			if(sect_object_symbols.ms ==
			   cur_obj->section_maps[i].output_section){
			    cur_obj->nlocalsym++;
			    nlocal_symbols++;
			    if(cur_obj->ar_hdr == NULL)
				local_string_size +=
						 strlen(cur_obj->file_name) + 1;
			    else
				local_string_size += cur_obj->ar_name_size + 1;
			    break;
			}
		    }
		}
	    }
	}

	/* Allocate space for per-object-file DWARF debug map symbols.  */
	if(cur_obj->dwarf_name){
	  /* There are 3 symbols for every .o, two SOs and one OSO.  */
	  nlocal_symbols += 3;
	  cur_obj->nlocalsym += 3;
	  local_string_size += 1 + strlen (cur_obj->dwarf_name);
	  /* If there's a compilation directory, there's an extra SO.  */
	  if (cur_obj->dwarf_comp_dir) {
	    /* The compilation directory has a '/' appended.  */
	    local_string_size += 2 + strlen (cur_obj->dwarf_comp_dir);
	    nlocal_symbols++;
	    cur_obj->nlocalsym++;
	  }
	  if(cur_obj->resolved_path == NULL)
	    set_obj_resolved_path(cur_obj);
	  local_string_size += 1 + cur_obj->resolved_path_len;
	  /* Allocate space for the strings for SOL DWARF debug map symbols. */
	  for (i = 0; i < cur_obj->dwarf_num_paths; i++)
	    if (cur_obj->dwarf_paths[i])
	      local_string_size += 1 + strlen (cur_obj->dwarf_paths[i]);
	}

	/*
	 * Now merge the external symbols are looked up and merged based
	 * what was found if anything.  Locals are counted if they will
	 * appear in the output file based on the strip level.
	 */
	nrefsym = 0;
	object_undefineds = 0;
	debug_ptr = cur_obj->dwarf_source_data;
	for(i = 0; i < cur_obj->symtab->nsyms; i++){
	    discarded_coalesced_symbol = FALSE;
	    discarded_multiply_defined_symbol = FALSE;
	    if (debug_ptr && *debug_ptr < i) {
	      for (debug_ptr += 2; *debug_ptr & 0x80000000; debug_ptr++) ;
	    }

	    if(object_symbols[i].n_type & N_EXT){
		/*
		 * Do the trace of this symbol if specified.
		 */
		if(ntrace_syms != 0){
		    for(j = 0; j < ntrace_syms; j++){
			if(strcmp(trace_syms[j], object_strings +
				  object_symbols[i].n_un.n_strx) == 0){
			    trace_object_symbol(&(object_symbols[i]),
						object_strings);
			    break;
			}
		    }
		}
		/* lookup the symbol and see if it has already been seen */
		hash_pointer = lookup_symbol(object_strings +
					     object_symbols[i].n_un.n_strx);
		if(hash_pointer->name_len == 0){
		    /*
		     * If this is the basefile and the symbol is not a
		     * definition of a symbol (or an indirect) then don't enter
		     * this symbol into the symbol table.
		     */
		    if(cur_obj != base_obj ||
		       (object_symbols[i].n_type != (N_EXT | N_UNDF) &&
		        object_symbols[i].n_type != (N_EXT | N_INDR) ) ){
			/* the symbol has not been seen yet so just enter it */
			merged_symbol = enter_symbol(hash_pointer,
					         &(object_symbols[i]),
						 object_strings, cur_obj);
			merged_symbol->referenced_in_non_dylib = TRUE;
			if(merged_symbol->non_dylib_referenced_obj == NULL)
			    merged_symbol->non_dylib_referenced_obj = cur_obj;
		    }
		}
		/* the symbol has been seen so merge it */
		else{
		    merged_symbol = hash_pointer;
		    /*
		     * If this symbol has only been referenced by a dylib up to
		     * this point re-enter the symbol name so it is in a string
		     * block that will be in the output file and set
		     * referenced_in_non_dylib to TRUE now.
		     */
		    if(merged_symbol->referenced_in_non_dylib == FALSE){
			merged_symbol->nlist.n_un.n_name =
			    enter_string(object_strings +
					 object_symbols[i].n_un.n_strx, NULL);
			merged_symbol->referenced_in_non_dylib = TRUE;
			if(merged_symbol->non_dylib_referenced_obj == NULL)
			    merged_symbol->non_dylib_referenced_obj = cur_obj;
		    }
		    /*
		     * If the object's symbol was undefined ignore it and just
		     * use the merged symbol.
		     */
		    if(object_symbols[i].n_type == (N_EXT | N_UNDF) &&
		       object_symbols[i].n_value == 0){
			/*
			 * If the merged symbol was a lazy reference and the
			 * object's symbol is not then remove the lazy reference
			 * mark from the symbol.
			 */
			if(((merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
			     merged_symbol->nlist.n_value == 0) ||
			     merged_symbol->nlist.n_type == (N_EXT | N_PBUD)) &&
			   (merged_symbol->nlist.n_desc & REFERENCE_TYPE) ==
			    REFERENCE_FLAG_UNDEFINED_LAZY &&
			   (object_symbols[i].n_desc & REFERENCE_TYPE) !=
			    REFERENCE_FLAG_UNDEFINED_LAZY)
			    merged_symbol->nlist.n_desc =
			       (merged_symbol->nlist.n_desc & ~REFERENCE_TYPE) |
				REFERENCE_FLAG_UNDEFINED_NON_LAZY;

			/*
			 * If the undefined symbol is marked as
			 * REFERENCED_DYNAMICALLY keep this mark.
			 */
			merged_symbol->nlist.n_desc |=
			   (object_symbols[i].n_desc & REFERENCED_DYNAMICALLY);

			/*
			 * This is part of the cctools_aek-thumb-hack branch.
			 * It seems to think undefined symbols would be marked
			 * as symbols that are definitions of Thumb symbols.
			 * But since undefined symbols are not definitions I
			 * don't see how this code would ever be used.
			merged_symbol->nlist.n_desc |=
			   (object_symbols[i].n_desc & N_ARM_THUMB_DEF);
			 */

			/*
			 * If the merged symbol is also an undefined deal with
			 * weak reference mismatches if any.
			 */
			if((merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
			    merged_symbol->nlist.n_value == 0) ||
			    merged_symbol->nlist.n_type == (N_EXT | N_PBUD)){
			    /*
			     * The merged symbol may be from an dylib and we
			     * haven't yet seen any undefined symbols before
			     * this object.  If so just set the N_WEAK_REF bit
			     * in the merged symbol to be that in this object
			     * file.
			     */
			    if(merged_symbol->seen_undef == FALSE){
				merged_symbol->nlist.n_desc =
				  (merged_symbol->nlist.n_desc & ~N_WEAK_REF) |
				  (object_symbols[i].n_desc & N_WEAK_REF);
			    }
			    else
				/*
				 * We have seen an undefined symbol before so
				 * if the N_WEAK_REF bits don't match resolve it
				 * based on the -weak_reference_mismatches
				 * setting.
				 */
			    if(((merged_symbol->nlist.n_desc & N_WEAK_REF) ==
				 N_WEAK_REF &&
				(object_symbols[i].n_desc & N_WEAK_REF) !=
				 N_WEAK_REF) ||
			       ((merged_symbol->nlist.n_desc & N_WEAK_REF) !=
				 N_WEAK_REF &&
				(object_symbols[i].n_desc & N_WEAK_REF) ==
				 N_WEAK_REF)){
				if(weak_reference_mismatches ==
				   WEAK_REFS_MISMATCH_ERROR)
				    merged_symbol->weak_reference_mismatch =
					TRUE;
				else if(weak_reference_mismatches ==
					WEAK_REFS_MISMATCH_WEAK)
				    merged_symbol->nlist.n_desc |= N_WEAK_REF;
				else if(weak_reference_mismatches ==
					WEAK_REFS_MISMATCH_NON_WEAK)
				    merged_symbol->nlist.n_desc &=
					~(N_WEAK_REF);
			    }
			    merged_symbol->seen_undef = TRUE;
			}
		    }
		    /*
		     * See if the object's symbol is a common.
		     */
	    	    else if((object_symbols[i].n_type & N_EXT) == N_EXT &&
	       		    (object_symbols[i].n_type & N_TYPE) == N_UNDF &&
			    object_symbols[i].n_value != 0){
			/*
			 * See if the merged symbol is a common or undefined.
			 */
			if((merged_symbol->nlist.n_type & N_EXT) == N_EXT &&
		           (merged_symbol->nlist.n_type & N_TYPE) ==  N_UNDF){
			    /*
			     * If the merged symbol is a common use the larger
			     * of the two commons.  Else the merged symbol is
			     * a common so use the common symbol.
			     */
			    if(merged_symbol->nlist.n_value != 0){
				if((merged_symbol->nlist.n_type & N_PEXT) !=
				   (object_symbols[i].n_type & N_PEXT)){
				    warning("common symbol: %s both as an "
					"external symbol and a private "
					"external symbol", merged_symbol->
					nlist.n_un.n_name);
				    trace_merged_symbol(merged_symbol);
				    trace_object_symbol(&(object_symbols[i]),
							object_strings);
				}
				if(object_symbols[i].n_value >
				   merged_symbol->nlist.n_value){
				    merged_symbol->nlist.n_value =
						     object_symbols[i].n_value;
				    merged_symbol->definition_object = cur_obj;
				    /*
				     * Since we are "using" this common then
				     * "use" the private extern bit from this
				     * object's symbol for the merged symbol.
				     */
				    merged_symbol->nlist.n_type =
				      (merged_symbol->nlist.n_type & ~N_PEXT) |
				      (object_symbols[i].n_type & N_PEXT);
				}
			    }
			    else{
				merged_symbol->nlist.n_value =
						     object_symbols[i].n_value;
				merged_symbol->definition_object = cur_obj;
			    }
			}
			/*
			 * The merged symbol is not a common or undefined and
			 * the object symbol is a common so just ignore the
			 * object's common symbol and use the merged defined
			 * symbol.
			 */
		    }
		    /*
		     * If the merged symbol is undefined or common (and at this
		     * point the object's symbol is known not to be undefined
		     * or common) then use the object's symbol.
		     */
		    else if((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF){
			/* one could also say:
			 *  && merged_symbol->nlist.n_value == 0 &&
			 *     merged_symbol->nlist.n_value != 0
			 * if the above test but that is always true.
			 */
			merged_symbol->nlist.n_type = object_symbols[i].n_type;
			merged_symbol->nlist.n_sect = object_symbols[i].n_sect;
			n_desc = 0;
			/*
			 * If this symbol was previously referenced dynamically
			 * then keep this information.
			 */
			n_desc |= (merged_symbol->nlist.n_desc &
				   REFERENCED_DYNAMICALLY);
			/*
			 * If the object symbol is a symbol defined as Thumb
			 * symbol then keep this information.
			 */
			n_desc |= (object_symbols[i].n_desc & N_ARM_THUMB_DEF);

			/*
			 * If the object symbol is a weak definition it may be
			 * later discarded for a non-weak symbol from a dylib so
			 * if the undefined symbol is a weak reference keep that
			 * information.
			 */
			if((object_symbols[i].n_desc & N_WEAK_DEF) ==
			   N_WEAK_DEF)
			    n_desc |= (merged_symbol->nlist.n_desc &
				       N_WEAK_REF);
			merged_symbol->nlist.n_desc =
			    object_symbols[i].n_desc | n_desc;
			if(merged_symbol->nlist.n_type == (N_EXT | N_INDR))
			    enter_indr_symbol(merged_symbol,
					      &(object_symbols[i]),
					      object_strings, cur_obj);
			else
			    merged_symbol->nlist.n_value =
						      object_symbols[i].n_value;
			merged_symbol->definition_object = cur_obj;
		    }
		    /*
		     * If the object symbol is a weak definition then
		     * it is discarded and the merged symbol is kept,
		     * unless the merged symbol is a weak symbol in a
		     * dylib.  Note currently only symbols in
		     * coalesced sections can have this set and it is
		     * checked for in check_symbol() so it is assumed
		     * it is a coalesced symbol here.
		     */
		    else if((object_symbols[i].n_desc & N_WEAK_DEF) ==
			    N_WEAK_DEF &&
			    (merged_symbol->defined_in_dylib == FALSE ||
			     ! merged_symbol->weak_def_in_dylib)){
			discarded_coalesced_symbol = TRUE;
			if((object_symbols[i].n_type & N_EXT) &&
			   (object_symbols[i].n_type & N_PEXT)){
			    cur_obj->nprivatesym--;
			    nmerged_private_symbols--;
			}
			else{
			    cur_obj->nextdefsym--;
			}
		    }
		    /*
		     * Otherwise, if the merged symbol is a weak
		     * definition then it is discarded and the object
		     * symbol is used.
		     */
		    else if((merged_symbol->nlist.n_desc & N_WEAK_DEF) ==
			    N_WEAK_DEF ||
			    (merged_symbol->defined_in_dylib == TRUE &&
			     merged_symbol->weak_def_in_dylib)){
			if(merged_symbol->defined_in_dylib == FALSE){
			    if((merged_symbol->nlist.n_type & N_EXT) &&
			       (merged_symbol->nlist.n_type & N_PEXT)){
				merged_symbol->definition_object->nprivatesym--;
				nmerged_private_symbols--;
			    }
			    else{
				merged_symbol->definition_object->nextdefsym--;
			    }
			    maybe_remove_dwarf_symbol (merged_symbol);
			}
#ifndef RLD
			/*
			 * If the output file is a multi module MH_DYLIB type
			 * reset the reference map for the merged external
			 * symbol that is being discarded.
			 */
			if(filetype == MH_DYLIB &&
			   multi_module_dylib == TRUE &&
			   merged_symbol->defined_in_dylib == FALSE){
			    /*
			     * Discared coalesced symbols are referenced as
			     * undefined. TODO: to determine if the reference is
			     * lazy or non-lazy we would have to look at all the
			     * relocation entries in this object.  For now just
			     * assume non-lazy to be safe.
			     */
			    for(j = 0;
				j < merged_symbol->definition_object->nrefsym;
				j++){
				if(merged_symbol->definition_object->
			           reference_maps[j].merged_symbol ==
								merged_symbol){
				    if(object_symbols[i].n_type & N_PEXT)
					merged_symbol->definition_object->
					reference_maps[j].flags =
				      REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY;
				    else
					merged_symbol->definition_object->
					reference_maps[j].flags =
					    REFERENCE_FLAG_UNDEFINED_NON_LAZY;
				    break;
				}
			    }
			}
#endif /* RLD */
			merged_symbol->defined_in_dylib = FALSE;
			merged_symbol->coalesced_defined_in_dylib = FALSE;
			merged_symbol->weak_def_in_dylib = FALSE;
			merged_symbol->nlist.n_type = object_symbols[i].n_type;
			merged_symbol->nlist.n_sect = object_symbols[i].n_sect;
			/*
			 * If this symbol was previously referenced
			 * dynamically then keep this information.
			 */
			if(merged_symbol->nlist.n_desc &
			   REFERENCED_DYNAMICALLY)
			    merged_symbol->nlist.n_desc =
				object_symbols[i].n_desc |
				REFERENCED_DYNAMICALLY
				/*
				 * This was part of the cctools_aek-thumb-hack
				 * branch.  It seems to think if the discarded
				 * weak merged symbol was marked as Thumb
				 * definition then that should be preserved.
				 * But since the object symbol is being used
				 * instead it may not be a Thumb definition.
				| (merged_symbol->nlist.n_desc &
				   N_ARM_THUMB_DEF)
				*/
				;
			else
			    merged_symbol->nlist.n_desc =
				object_symbols[i].n_desc
				/*
				 * This was part of the cctools_aek-thumb-hack
				 * branch.  It seems to think if the discarded
				 * weak merged symbol was marked as Thumb
				 * definition then that should be preserved.
				 * But since the object symbol is being used
				 * instead it may not be a Thumb definition.
				| (merged_symbol->nlist.n_desc &
				   N_ARM_THUMB_DEF)
				*/
				;
			if(merged_symbol->nlist.n_type == (N_EXT | N_INDR))
			    enter_indr_symbol(merged_symbol,
					      &(object_symbols[i]),
					      object_strings, cur_obj);
			else
			    merged_symbol->nlist.n_value =
						      object_symbols[i].n_value;
			merged_symbol->definition_object = cur_obj;
		    }
		    /*
		     * If both symbols are coalesced symbols then the this
		     * symbol is discarded.
		     */
		    else if((
		       ((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		       ((merged_symbol->definition_object->section_maps[
			    merged_symbol->nlist.n_sect - 1].s->flags) &
			    SECTION_TYPE) == S_COALESCED) ||
			(merged_symbol->defined_in_dylib == TRUE &&
 			 merged_symbol->coalesced_defined_in_dylib) )
			&&
		       (object_symbols[i].n_type & N_TYPE) == N_SECT &&
		       ((cur_obj->section_maps[object_symbols[i].n_sect - 1].
			    s->flags) & SECTION_TYPE) == S_COALESCED){

			discarded_coalesced_symbol = TRUE;
			if((object_symbols[i].n_type & N_EXT) &&
			   (object_symbols[i].n_type & N_PEXT)){
			    cur_obj->nprivatesym--;
			    nmerged_private_symbols--;
			}
			else{
			    cur_obj->nextdefsym--;
			}
#ifdef COALESCE_DEBUG
printf("symbol: %s is coalesced\n", merged_symbol->nlist.n_un.n_name);
#endif
		    }
#ifdef KLD
                  /*
                   * For KLD if both symbols are absolute symbols with the
                   * value the symbol is discarded.
                   */
                  else if((merged_symbol->nlist.n_type & N_TYPE) == N_ABS &&
                          (object_symbols[i].n_type & N_TYPE) == N_ABS &&
                          merged_symbol->nlist.n_value ==
                          object_symbols[i].n_value){
                      if((object_symbols[i].n_type & N_EXT) &&
                         (object_symbols[i].n_type & N_PEXT)){
                          cur_obj->nprivatesym--;
                          nmerged_private_symbols--;
                      }
                      else{
                          cur_obj->nextdefsym--;
                      }
                  }
#endif /* KLD */
		    else{
			discarded_multiply_defined_symbol = TRUE;
			multiply_defined(merged_symbol, &(object_symbols[i]),
					 object_strings);
			if(allow_multiply_defined_symbols == TRUE){
			    /*
			     * If this is a private external then decrement
			     * the previous incremented the count of private
			     * exterals for this object and the total in the
			     * output file since we are going to ignore this
			     * this multiply defined symbol.
			     */
			    if((object_symbols[i].n_type & N_EXT) &&
			       (object_symbols[i].n_type & N_PEXT)){
				cur_obj->nprivatesym--;
				nmerged_private_symbols--;
			    }
			}
		    }
		}
		/*
		 * If this symbol was undefined or a common in this object
		 * and the object is not the basefile enter a pointer to the
		 * merged symbol and its index in the object file's undefined
		 * map.
		 */
		if((object_symbols[i].n_type & N_EXT) == N_EXT &&
		   (object_symbols[i].n_type & N_TYPE) == N_UNDF &&
		   cur_obj != base_obj){
		    cur_obj->undefined_maps[object_undefineds].index = i;
		    cur_obj->undefined_maps[object_undefineds].merged_symbol =
								merged_symbol;
		    object_undefineds++;
		    /*
		     * Note: coalesced symbols are always defined symbols in
		     * each object file but referenced with external relocation
		     * entries.  Since they are always defined they are not in
		     * in the undefined map.
		     */
		}
#ifndef RLD
		/*
		 * If the output file is a multi module MH_DYLIB type set the
		 * reference map for this external symbol.
		 */
		if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		    cur_obj->reference_maps[nrefsym].merged_symbol =
								merged_symbol;
		    /*
		     * Discared coalesced symbols are referenced as undefined.
		     * TODO: to determine if the reference is lazy or non-lazy
		     * we would have to look at all the relocation entries in
		     * this object.  For now just assume non-lazy to be safe.
		     */
		    if(discarded_coalesced_symbol == TRUE){
			if(merged_symbol->nlist.n_type & N_PEXT)
			    cur_obj->reference_maps[nrefsym].flags =
				REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY;
			else
			    cur_obj->reference_maps[nrefsym].flags =
				REFERENCE_FLAG_UNDEFINED_NON_LAZY;
		    }
		    else if(object_symbols[i].n_type == (N_EXT | N_UNDF))
			cur_obj->reference_maps[nrefsym].flags =
				      object_symbols[i].n_desc & REFERENCE_TYPE;
		    else if(object_symbols[i].n_type & N_PEXT)
			cur_obj->reference_maps[nrefsym].flags =
						 REFERENCE_FLAG_PRIVATE_DEFINED;
		    else
			cur_obj->reference_maps[nrefsym].flags =
							 REFERENCE_FLAG_DEFINED;
		    nrefsym++;
		}
#endif /* !defined(RLD) */
	    }
	    else if(cur_obj != base_obj || strip_base_symbols == FALSE){
#ifndef RLD
		if(dead_strip &&
		   (object_symbols[i].n_type & N_STAB) == 0 &&
		   (object_symbols[i].n_type & N_TYPE) == N_SECT &&
		   object_symbols[i].n_desc & N_NO_DEAD_STRIP)
		    local_NO_DEAD_STRIP_symbols = TRUE;
#endif /* !defined(RLD) */

		if(strip_level != STRIP_DUP_INCLS &&
		   is_output_local_symbol(object_symbols[i].n_type,
			object_symbols[i].n_sect, object_symbols[i].n_desc,
			cur_obj,
			object_symbols[i].n_un.n_strx == 0 ? "" :
			object_strings + object_symbols[i].n_un.n_strx,
			&output_strlen)){
		    cur_obj->nlocalsym++;
		    nlocal_symbols++;
		    local_string_size += object_symbols[i].n_un.n_strx == 0 ? 0:
					 output_strlen + 1;
		}
	    }

	    /* If this file had DWARF, account for the extra debug_map
	       symbols.  */
	    if (cur_obj->dwarf_name && ! discarded_coalesced_symbol &&
		! discarded_multiply_defined_symbol){
	      size_t n = count_dwarf_symbols (object_symbols + i, i,
					      debug_ptr);
	      cur_obj->nlocalsym += n;
	      nlocal_symbols += n;
	    }
	}

#ifndef RLD
	/*
	 * If we are stripping STABS from duplicate includes then go through the
	 * symbol table determining which local symbols (STABS and non-stabs)
	 * which are to be in the output file.
	 *
	 * The stabs for each N_BINCL/N_EINCL are parsed out as a group.  Since
	 * there can be intermixed nested groups the parsing is a bit strange
	 * as we create blocks for the symbols that have been parsed out and
	 * then restart parsing at the inter nesting level.  This allows outer
	 * groups to be excluded when inter groups can't.  The blocks must be
	 * put and kept on the list in order of their symbol table index.
	 */
	if(strip_level == STRIP_DUP_INCLS){
	    localsym_block = cur_obj->localsym_blocks;
	    next_localsym_block = &(cur_obj->localsym_blocks);
	    for(i = 0; i < cur_obj->symtab->nsyms; i++){
		/* skip blocks of symbols that have already been parsed */
		if(localsym_block != NULL && localsym_block->index == i){
		    i += localsym_block->count - 1; /* the loop will do i++ */
		    next_localsym_block = &(localsym_block->next);
		    localsym_block = localsym_block->next;
		    continue;
		}
		if(object_symbols[i].n_type & N_EXT)
		    continue;
		if((object_symbols[i].n_type & N_STAB) == 0 ||
		   object_symbols[i].n_type != N_BINCL){
		    cur_obj->nlocalsym++;
		    nlocal_symbols++;
		    /*
		     * Even though strip_level is STRIP_DUP_INCLS and we know
		     * we are keeping this symbol, it might be an N_OSO which
		     * we maybe changing the name of so is_output_local_symbol()
		     * is still called to get the output_strlen.
		     */
		    (void)is_output_local_symbol(object_symbols[i].n_type,
			object_symbols[i].n_sect, object_symbols[i].n_desc,
			cur_obj,
			object_symbols[i].n_un.n_strx == 0 ? "" :
			object_strings + object_symbols[i].n_un.n_strx,
			&output_strlen);
		    local_string_size +=
			object_symbols[i].n_un.n_strx == 0 ? 0:
			output_strlen + 1;
		    continue;
		}
		/*
		 * We now have a N_BINCL stab.  We will now see if we can
		 * exclude this stab through its closing N_EINCL stab.
		 * To exclude this group it must not have any non-stabs in it
		 * and must not have any stabs that need relocation (stabs for
		 * definitions of symbols in header files, N_FUN, N_SLINE, etc).
		 *
		 * An N_BINCL symbol indicates the start of the stabs entries
		 * for a header file.  We need to scan ahead to the next N_EINCL
		 * symbol, ignoring nesting, adding up all the characters in the
		 * symbol names, not including the file numbers in types (the
		 * first number after an open parenthesis).
		 */
		no_exclusion = FALSE;
		nest = 0;
		sum = 0;
		/*
		 * Create the first block for this bincl,
		 * then after parsing out the incl's stabs,
		 * the outer loop will start again just after this block
		 */
		localsym_block = allocate(sizeof(struct localsym_block));
		memset(localsym_block, '\0', sizeof(struct localsym_block));
		localsym_block->index = i;
		localsym_block->state = PARSE_SYMBOLS;
		localsym_block->count = 1;
		localsym_block->input_N_BINCL_n_value =
		    object_symbols[i].n_value;
		if(localsym_block->input_N_BINCL_n_value != 0)
		    sum = localsym_block->input_N_BINCL_n_value;

		/* insert the first block in the list */
		localsym_block->next = *next_localsym_block;
		*next_localsym_block = localsym_block;
		next_localsym_block = &(localsym_block->next);

		/*
		 * The current block on the chain for the group starts out
		 * as the first block.
		 */
		cur_localsym_block = localsym_block;

		for(j = i + 1; j < cur_obj->symtab->nsyms; j++){
		    if(object_symbols[j].n_type == N_EINCL){
			if(nest == 0){
			    /* count this symbol as the part of this block */
			    cur_localsym_block->count++;
			    break;
			}
			else{
			    nest--;
			    if(nest == 0){
				/*
				 * If we are going back to nest level zero
				 * we can now set the index to where the
				 * current block starts.
				 */
				cur_localsym_block->index = j + 1;
			    }
			}
		    }
		    else if(object_symbols[j].n_type == N_BINCL ||
			    object_symbols[j].n_type == N_EXCL){
			nest++;
			/*
			 * End the current block and create a new one if we
			 * haven't already.  We don't know the index yet, but
			 * we do know we need a new block as we are nesting
			 * down and expect to come back.
			 */
			if(cur_localsym_block->count != 0){
			    temp_localsym_block = allocate(
					    sizeof(struct localsym_block));
			    memset(temp_localsym_block, '\0',
					    sizeof(struct localsym_block));
			    temp_localsym_block->state = PARSE_SYMBOLS;

			    /* insert it after the current block */
			    temp_localsym_block->next =
				cur_localsym_block->next;
			    cur_localsym_block->next = temp_localsym_block;

			    /* now make it the current block */
			    cur_localsym_block = temp_localsym_block;
			}
			if(object_symbols[j].n_type == N_EXCL){
			    nest--;
			    if(nest == 0){
				/*
				 * If we are going back to nest level zero
				 * we can now set the index to where the
				 * current block starts.
				 */
				cur_localsym_block->index = j + 1;
			    }
			}
		    }
		    else if(nest == 0){
			if((object_symbols[j].n_type & N_STAB) == 0 ||
			   object_symbols[j].n_sect != NO_SECT){
			    no_exclusion = TRUE;
			}
			/*
			 * If this is a local symbol count it as the part of
			 * the current block.
			 */
			if((object_symbols[j].n_type & N_STAB) != 0){
			    cur_localsym_block->count++;

			    if(localsym_block->input_N_BINCL_n_value == 0 &&
			       object_symbols[j].n_un.n_strx != 0){
				stab_string = object_strings +
					      object_symbols[j].n_un.n_strx;
				for( ; *stab_string != '\0'; stab_string++){
				    sum += *stab_string;
				    if(*stab_string == '('){
					/* skip the file number */
					stab_string++;
					while(isdigit((unsigned char)
						      *stab_string))
					    stab_string++;
					stab_string--;
				    }
				    else if(*stab_string == '.' &&
				       stab_string[1] != '\0' &&
				       stab_string[1] == '_'){
					stab_string++; /* one for the '.' */
					sum += *stab_string;
					stab_string++; /* and one for the '_' */
					while(isdigit((unsigned char)
						      *stab_string))
					    stab_string++;
					stab_string--;
				    }
				}
			    }
			}
		    }
		}
		/*
		 * If we did not succesfully parsed a N_BINCL/N_EINCL pair or
		 * the group has symbols that can't be excluded, then just add
		 * these symbols to the count of local symbols and the sizes of
		 * the strings in this group.  Leave the blocks that were
		 * created in the PARSE_SYMBOLS state so they won't be looked
		 * at again and the symbols won't be removed.
		 */
		if(j == cur_obj->symtab->nsyms || no_exclusion == TRUE){
		    temp_localsym_block = localsym_block;
		    while(temp_localsym_block != NULL){
			cur_obj->nlocalsym += temp_localsym_block->count;
			nlocal_symbols += temp_localsym_block->count;
			for(k = temp_localsym_block->index;
			    k < temp_localsym_block->index +
				temp_localsym_block->count;
			    k++){
			    /*
			     * Even though strip_level is STRIP_DUP_INCLS and
			     * we know we are keeping this symbol, it might be
			     * an N_OSO which we maybe changing the name of.
			     * So is_output_local_symbol() is still called to
			     * get the output_strlen.
			     */
			    (void)is_output_local_symbol(
				object_symbols[k].n_type,
				object_symbols[k].n_sect,
				object_symbols[k].n_desc,
				cur_obj,
				object_symbols[k].n_un.n_strx == 0 ? "" :
				object_strings + object_symbols[k].n_un.n_strx,
				&output_strlen);
			    local_string_size +=
				object_symbols[k].n_un.n_strx == 0 ? 0:
				output_strlen + 1;
			}
			if(temp_localsym_block == cur_localsym_block)
			    break;
			else
			    temp_localsym_block = temp_localsym_block->next;
		    }
		    i = i + localsym_block->count
			- 1; /* the loop will do i++ */
		    localsym_block = localsym_block->next;
		}
		else{
		    /*
		     * We succesfully parsed out a set of stabs between a
		     * N_BINCL/N_EINCL pair that now can be considered for
		     * exclusion if we have seen the same include file with
		     * the same sum of its stab strings without file numbers.
		     * lookup_and_enter_include() will return TRUE if this is
		     * new and we have not seen this group before.
		     */
		    include_file_name = object_strings +
					object_symbols[i].n_un.n_strx;
		    if(lookup_and_enter_include(include_file_name, sum, i,
					object_symbols[i+1].n_type == N_EINCL)){
			/*
			 * This is the first time this group is seen, so count
			 * the symbols in the blocks of this include file as to
			 * be in the output (all known to be local symbols) and
			 * add up the sizes of their strings.
			 */
			temp_localsym_block = localsym_block;
			while(temp_localsym_block != NULL){
			    cur_obj->nlocalsym += temp_localsym_block->count;
			    nlocal_symbols += temp_localsym_block->count;
			    for(k = temp_localsym_block->index;
				k < temp_localsym_block->index +
				    temp_localsym_block->count;
				k++){
				/*
				 * Even though strip_level is STRIP_DUP_INCLS
				 * and we know we are keeping this symbol, it
				 * might be an N_OSO which we maybe changing
				 * the name of. So is_output_local_symbol() is
				 * still called to get the output_strlen.
				 */
				(void)is_output_local_symbol(
				    object_symbols[k].n_type,
				    object_symbols[k].n_sect,
				    object_symbols[k].n_desc,
				    cur_obj,
				    object_symbols[k].n_un.n_strx == 0 ? "" :
				    object_strings +
				        object_symbols[k].n_un.n_strx,
				    &output_strlen);
				local_string_size +=
				    object_symbols[k].n_un.n_strx == 0 ? 0:
				    output_strlen + 1;
			    }
			    if(temp_localsym_block == cur_localsym_block)
				break;
			    else
				temp_localsym_block = temp_localsym_block->next;
			}
			/*
			 * The sum for the N_BINCL needs to be set so use the
			 * the first block for this bincl group for this,
			 * resetting its count to 1 after resetting the outer
			 * loop to start after the original size of the block.
			 * The other blocks for this bincl group continue to
			 * have their state set to PARSE_SYMBOLS and will be
			 * removed from the list after all symbols are parsed.
			 * Then the symbols from this include will be in the
			 * output.
			 */
			localsym_block->state = BEGIN_INCLUDE;
			localsym_block->sum = sum;
			i = i + localsym_block->count
			    - 1; /* the loop will do i++ */
			localsym_block->count = 1;
			localsym_block = localsym_block->next;
		    }
		    else{
			/*
			 * This group of stabs has been seen before so it will
			 * be excluded from the output.  Use the the first
			 * block for this bincl group for this marking it as
			 * EXCLUDED_INCLUDE, then set the other blocks in this
			 * group to DISCARD. Then account for the one N_EXCL
			 * stab and it's sting.  Finally reset the outer loop to
			 * start after the first block.
			 */
			localsym_block->state = EXCLUDED_INCLUDE;
			localsym_block->sum = sum;
			if(localsym_block != cur_localsym_block){
			    temp_localsym_block = localsym_block->next;
			    while(temp_localsym_block != NULL){
				temp_localsym_block->state = DISCARD_SYMBOLS;
				if(temp_localsym_block == cur_localsym_block)
				    break;
				else
				    temp_localsym_block =
					temp_localsym_block->next;
			    }
			}

			/* account for the one N_EXCL replacing this group */
			cur_obj->nlocalsym += 1;
			nlocal_symbols += 1;
			/*
			   The path string for an EXCL always re-uses
			   the path from the matching BINCL
			  local_string_size += strlen(include_file_name) + 1;
			 */
			i = i + localsym_block->count - 1;
				/* the loop will do i++ */
			/*
			 * Note the count field of an EXCLUDED_INCLUDE block
			 * contains the #of symbols to that were replaced with
			 * the N_EINCL not a count of 1. So the count is not
			 * changed.
			 */
			localsym_block = localsym_block->next;
		    }
		}
	    }
	    /*
	     * Go through the list of blocks and remove any blocks that were
	     * just needed for parsing.
	     */
	    localsym_block = cur_obj->localsym_blocks;
	    next_localsym_block = &(cur_obj->localsym_blocks);
	    while(localsym_block != NULL){
		if(localsym_block->state == PARSE_SYMBOLS){
		    temp_localsym_block = localsym_block;
		    localsym_block = localsym_block->next;
		    *next_localsym_block = localsym_block;
		    free(temp_localsym_block);
		}
		else{
		    next_localsym_block = &(localsym_block->next);
		    localsym_block = localsym_block->next;
		}
	    }
	}
#endif /* !defined(RLD) */

}

#ifndef RLD
/*
 * exports_list_processing() takes a symbol_name and a defined symbol from an
 * object file and sets the private extern bit is it is not to be exported.  And
 * also marks the symbol in the list as seen.
 */
static
void
exports_list_processing(
char *symbol_name,
struct nlist *symbol)
{
    struct symbol_list *sp;

	if(save_symbols != NULL){
	    sp = bsearch(symbol_name, save_symbols, nsave_symbols,
			 sizeof(struct symbol_list),
			 (int (*)(const void *, const void *))
			    symbol_list_bsearch);
	    if(sp != NULL){
		sp->seen = TRUE;
	    }
	    else{
		if(symbol->n_desc & REFERENCED_DYNAMICALLY){
		    warning("symbol: %s referenced dynamically and must be "
			    "exported", symbol_name);
		}
		else{
		    symbol->n_type |= N_PEXT;
		}
	    }
	}
	if(remove_symbols != NULL){
	    sp = bsearch(symbol_name, remove_symbols, nremove_symbols,
			 sizeof(struct symbol_list),
			 (int (*)(const void *, const void *))
			    symbol_list_bsearch);
	    if(sp != NULL){
		sp->seen = TRUE;
		if(symbol->n_desc & REFERENCED_DYNAMICALLY){
		    warning("symbol: %s referenced dynamically and must be "
			    "exported", symbol_name);
		}
		else{
		    symbol->n_type |= N_PEXT;
		}
	    }
	}
}

/*
 * command_line_symbol() looks up a symbol name that comes from a command line
 * argument (like -u symbol_name) and returns a pointer to the merged symbol
 * table entry for it.  If the symbol doesn't exist it enters an undefined
 * symbol for it.
 */
__private_extern__
struct merged_symbol *
command_line_symbol(
char *symbol_name)
{
    unsigned long i;
    struct merged_symbol *hash_pointer, *merged_symbol;
    struct object_file *command_line_object;

	command_line_object = new_object_file();
	command_line_object->file_name = "command line";
	command_line_object->command_line = TRUE;
	/*
	 * Do the trace of this symbol if specified.
	 */
	if(ntrace_syms != 0){
	    for(i = 0; i < ntrace_syms; i++){
		if(strcmp(trace_syms[i], symbol_name) == 0){
		    trace_symbol(symbol_name, &(undefined_symbol),
			     command_line_object, "error in trace_symbol()");
		    break;
		}
	    }
	}
	/* lookup the symbol and see if it has already been seen */
	hash_pointer = lookup_symbol(symbol_name);
	if(hash_pointer->name_len == 0){
	    /*
	     * The symbol has not been seen yet so just enter it as an
	     * undefined symbol and it will be returned.
	     */
	    merged_symbol = enter_symbol(hash_pointer, &(undefined_symbol),
					 symbol_name, command_line_object);
	    if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
		command_line_object->reference_maps =
		    reallocate(command_line_object->reference_maps,
			       (command_line_object->nrefsym + 1) *
			       sizeof(struct reference_map));
		command_line_object->reference_maps[
		    command_line_object->nrefsym].flags =
			REFERENCE_FLAG_UNDEFINED_NON_LAZY;
		command_line_object->reference_maps[
		    command_line_object->nrefsym].merged_symbol =
			merged_symbol;
		command_line_object->irefsym =
		    output_dysymtab_info.dysymtab_command.nextrefsyms;
		command_line_object->nrefsym += 1;
		output_dysymtab_info.dysymtab_command.nextrefsyms += 1;
	    }
	}
	/* the symbol has been seen so just use it */
	else{
	    merged_symbol = hash_pointer;
	    /*
	     * If this symbol has only been referenced by a dylib up to
	     * this point re-enter the symbol name so it is in a string
	     * block that will be in the output file.
	     */
	    if(merged_symbol->referenced_in_non_dylib == FALSE)
		merged_symbol->nlist.n_un.n_name = enter_string(symbol_name,
							        NULL);
	}
	merged_symbol->referenced_in_non_dylib = TRUE;
	if(merged_symbol->non_dylib_referenced_obj == NULL)
	    merged_symbol->non_dylib_referenced_obj = command_line_object;
	return(merged_symbol);
}

/*
 * command_line_indr_symbol() creates an indirect symbol for symbol_name to
 * indr_symbol_name.  It is used for -i command line options.  Since this is
 * a defining symbol the problems of multiply defined symbols can happen.  This
 * and the tracing is not too neat as far as the code goes but it does exactly
 * what is intended.  That is exactly one error message for each symbol and
 * exactly one trace for each object or command line option for each symbol.
 */
__private_extern__
void
command_line_indr_symbol(
char *symbol_name,
char *indr_symbol_name)
{
    unsigned long i, j;
    enum bool was_traced;
    struct merged_symbol *hash_pointer, *merged_symbol, *merged_indr_symbol;
    struct object_file *command_line_object;

	command_line_object = new_object_file();
	command_line_object->file_name = "command line";
	command_line_object->command_line = TRUE;
	/*
	 * Do the trace of the symbol_name if specified.
	 */
	was_traced = FALSE;
	if(ntrace_syms != 0){
	    for(i = 0; i < ntrace_syms; i++){
		if(strcmp(trace_syms[i], symbol_name) == 0){
		    trace_symbol(symbol_name, &(indr_symbol),
				 command_line_object, indr_symbol_name);
		    was_traced = TRUE;
		    break;
		}
	    }
	}
	/* lookup the symbol_name and see if it has already been seen */
	hash_pointer = lookup_symbol(symbol_name);
	if(hash_pointer->name_len == 0){
	    /*
	     * The symbol has not been seen yet so just enter it as an
	     * undefined and it will be changed to a proper merged indirect
	     * symbol.
	     */
	    merged_symbol = enter_symbol(hash_pointer, &(undefined_symbol),
					 symbol_name, command_line_object);
	    merged_symbol->referenced_in_non_dylib = TRUE;
	    if(merged_symbol->non_dylib_referenced_obj == NULL)
		merged_symbol->non_dylib_referenced_obj = command_line_object;
	}
	else{
	    /*
	     * The symbol exist.  So if the symbol is anything but a common or
	     * undefined then it is multiply defined.
	     */
	    merged_symbol = hash_pointer;
	    /*
	     * If this symbol has only been referenced by a dylib up to
	     * this point re-enter the symbol name so it is in a string
	     * block that will be in the output file.
	     */
	    if(merged_symbol->referenced_in_non_dylib == FALSE)
		merged_symbol->nlist.n_un.n_name = enter_string(symbol_name,
								NULL);
	    merged_symbol->referenced_in_non_dylib = TRUE;
	    if(merged_symbol->non_dylib_referenced_obj == NULL)
		merged_symbol->non_dylib_referenced_obj = command_line_object;
	    if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF){
		/*
		 * It is multiply defined so the logic of the routine
		 * multiply_defined() is copied here so that tracing a symbol
		 * from the command line can be done.
		 */
		for(i = 0; i < nmultiple_defs; i++){
		    if(strcmp(multiple_defs[i],
			      merged_symbol->nlist.n_un.n_name) == 0)
			break;
		}
		for(j = 0; j < ntrace_syms; j++){
		    if(strcmp(trace_syms[j],
			      merged_symbol->nlist.n_un.n_name) == 0)
			break;
		}
		if(i == nmultiple_defs){
		    if(allow_multiply_defined_symbols == TRUE)
			warning("multiple definitions of symbol %s",
			      merged_symbol->nlist.n_un.n_name);
		    else
			error("multiple definitions of symbol %s",
			      merged_symbol->nlist.n_un.n_name);
		    multiple_defs = reallocate(multiple_defs, (nmultiple_defs +
					       1) * sizeof(char *));
		    multiple_defs[nmultiple_defs++] =
					       merged_symbol->nlist.n_un.n_name;
		    if(j == ntrace_syms)
			trace_merged_symbol(merged_symbol);
		}
		if(was_traced == FALSE)
		    trace_symbol(symbol_name, &(indr_symbol),
				 command_line_object, indr_symbol_name);
		return;
	    }
	}
	nindr_symbols++;
	/* Now change this symbol to an indirect symbol type */
	merged_symbol->nlist.n_type = N_INDR | N_EXT;
	merged_symbol->nlist.n_sect = NO_SECT;
	merged_symbol->nlist.n_desc = 0;

	/* lookup the indr_symbol_name and see if it has already been seen */
	hash_pointer = lookup_symbol(indr_symbol_name);
	if(hash_pointer->name_len == 0){
	    /*
	     * The symbol has not been seen yet so just enter it after tracing
	     * if the symbol is specified.
	     */
	    for(i = 0; i < ntrace_syms; i++){
		if(strcmp(trace_syms[i], indr_symbol_name) == 0){
		    trace_symbol(indr_symbol_name, &(undefined_symbol),
			     command_line_object, "error in trace_symbol()");
		    break;
		}
	    }
	    merged_indr_symbol = enter_symbol(hash_pointer, &(undefined_symbol),
				      indr_symbol_name, command_line_object);
	    merged_indr_symbol->referenced_in_non_dylib = TRUE;
	    if(merged_indr_symbol->non_dylib_referenced_obj == NULL)
		merged_indr_symbol->non_dylib_referenced_obj =
							    command_line_object;
	}
	else{
	    merged_indr_symbol = hash_pointer;
	    /*
	     * If this symbol has only been referenced by a dylib up to
	     * this point re-enter the symbol name so it is in a string
	     * block that will be in the output file.
	     */
	    if(merged_indr_symbol->referenced_in_non_dylib == FALSE)
		merged_indr_symbol->nlist.n_un.n_name =
		    enter_string(indr_symbol_name, NULL);
	    merged_indr_symbol->referenced_in_non_dylib = TRUE;
	    if(merged_indr_symbol->non_dylib_referenced_obj == NULL)
		merged_indr_symbol->non_dylib_referenced_obj =
							    command_line_object;
	}
	merged_symbol->nlist.n_value = (unsigned long)merged_indr_symbol;

	if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
	    command_line_object->nextdefsym = 1;
	    command_line_object->reference_maps =
		reallocate(command_line_object->reference_maps,
			   (command_line_object->nrefsym + 2) *
			   sizeof(struct reference_map));
	    command_line_object->reference_maps[
		command_line_object->nrefsym + 0].flags =
		    REFERENCE_FLAG_DEFINED;
	    command_line_object->reference_maps[
		command_line_object->nrefsym + 0].merged_symbol =
		    merged_symbol;
	    command_line_object->reference_maps[
		command_line_object->nrefsym + 1].flags =
		    REFERENCE_FLAG_UNDEFINED_NON_LAZY;
	    command_line_object->reference_maps[
		command_line_object->nrefsym + 1].merged_symbol =
		    merged_indr_symbol;
	    command_line_object->irefsym =
		output_dysymtab_info.dysymtab_command.nextrefsyms;
	    command_line_object->nrefsym += 2;
	    output_dysymtab_info.dysymtab_command.nextrefsyms += 2;
	}
}

/*
 * merge_dylib_module_symbols() merges the symbols from the current object
 * (cur_obj) which represents a module from a dynamic shared library into
 * the merged symbol table.  The parameter dynamic_library is the dynamic
 * library struct the current object is from.
 */
__private_extern__
void
merge_dylib_module_symbols(
struct dynamic_library *dynamic_library)
{
    unsigned long i, j, k, l, nundefineds, module_index, library_ordinal;
    char *strings, *symbol_name, *name;
    struct nlist *symbols, *fake_trace_symbol;
    struct dylib_reference *refs;
    unsigned long flags;
    enum bool was_traced, resolve_flat;
    struct merged_symbol *hash_pointer, *merged_symbol;
    struct object_file *obj;
    struct dylib_table_of_contents *toc;
    struct dynamic_library *dep;

	strings = cur_obj->obj_addr + cur_obj->symtab->stroff;
	symbols = (struct nlist *)(cur_obj->obj_addr +
				   cur_obj->symtab->symoff);
	refs = (struct dylib_reference *)(cur_obj->obj_addr +
					  cur_obj->dysymtab->extrefsymoff);

	/*
	 * First loop through the symbols defined by this module and merge them
	 * into the merged symbol table.
	 */
	for(i = 0; i < cur_obj->dylib_module->nextdefsym; i++){
	    j = i + cur_obj->dylib_module->iextdefsym;
	    symbol_name = strings + symbols[j].n_un.n_strx;
	    /*
	     * Do the trace of the symbol_name if specified.
	     */
	    if((symbols[j].n_desc & N_WEAK_DEF) == N_WEAK_DEF)
		fake_trace_symbol = &pbud_weak_def_symbol;
	    else
		fake_trace_symbol = &pbud_symbol;
	    was_traced = FALSE;
	    if(ntrace_syms != 0){
		for(k = 0; k < ntrace_syms; k++){
		    if(strcmp(trace_syms[k], symbol_name) == 0){
			trace_symbol(symbol_name, fake_trace_symbol, cur_obj,
			    "error in trace_symbol()");
			was_traced = TRUE;
			break;
		    }
		}
	    }
	    /* lookup the symbol_name and see if it has already been seen */
	    hash_pointer = lookup_symbol(symbol_name);
	    if(hash_pointer->name_len == 0){
		/*
		 * The symbol has not been seen yet so just enter it as a
		 * prebound undefined.
		 */
		merged_symbol = enter_symbol(hash_pointer, &(pbud_symbol),
					     symbol_name, cur_obj);
	    }
	    else{
		merged_symbol = hash_pointer;
		/*
		 * If the merged symbol is not undefined and if this symbol is
		 * a weak definition then it is simply ignored and the merged
		 * symbol is used.  Note currently only coalesced sections can
		 * have this attribute and this is checked for in
		 * check_symbol() so it is assumed it is a coalesced symbol
		 * here.
		 */
		if((merged_symbol->nlist.n_type != (N_UNDF | N_EXT) ||
		    merged_symbol->nlist.n_value != 0) &&
		   (symbols[j].n_desc & N_WEAK_DEF) == N_WEAK_DEF){
		    continue;
		}
		/*
		 * If the merged symbol is a weak definition then it is
		 * discarded and this symbol definition from this dylib is used.
		 */
		if((merged_symbol->nlist.n_desc & N_WEAK_DEF) == N_WEAK_DEF ||
			(merged_symbol->defined_in_dylib == TRUE &&
			 merged_symbol->weak_def_in_dylib)){
		    if(merged_symbol->defined_in_dylib == FALSE){
			if((merged_symbol->nlist.n_type & N_EXT) &&
			   (merged_symbol->nlist.n_type & N_PEXT)){
			    merged_symbol->definition_object->nprivatesym--;
			    nmerged_private_symbols--;
			}
			else{
			    merged_symbol->definition_object->nextdefsym--;
			}
		    }
		    /*
		     * If the output file is a multi module MH_DYLIB type reset
		     * the reference map for the merged external symbol that
		     * is being discarded.
		     */
		    if(filetype == MH_DYLIB &&
		       multi_module_dylib == TRUE &&
		       merged_symbol->defined_in_dylib == FALSE){
			/*
			 * Discared coalesced symbols are referenced as
			 * undefined. TODO: to determine if the reference is
			 * lazy or non-lazy we would have to look at all the
			 * relocation entries in this object.  For now just
			 * assume non-lazy to be safe.
			 */
			for(k = 0;
			    k < merged_symbol->definition_object->nrefsym;
			    k++){
			    if(merged_symbol->definition_object->
			       reference_maps[k].merged_symbol ==
							    merged_symbol){
				if(symbols[k].n_type & N_PEXT)
				    merged_symbol->definition_object->
				    reference_maps[k].flags =
				  REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY;
				else
				    merged_symbol->definition_object->
				    reference_maps[k].flags =
					REFERENCE_FLAG_UNDEFINED_NON_LAZY;
				break;
			    }
			}
		    }
		    merged_symbol->coalesced_defined_in_dylib = FALSE;
		    merged_symbol->weak_def_in_dylib = FALSE;
		    goto use_symbol_definition_from_this_dylib;
		}
		/*
		 * If both symbols are coalesced symbols then the this
		 * symbol is simply ignored.
		 */
		if((((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		      ((merged_symbol->definition_object->section_maps[
			   merged_symbol->nlist.n_sect - 1].s->flags) &
			   SECTION_TYPE) == S_COALESCED) ||
		     merged_symbol->coalesced_defined_in_dylib == TRUE) &&
		   (symbols[j].n_type & N_TYPE) == N_SECT &&
		   ((cur_obj->section_maps[symbols[j].n_sect - 1].
			s->flags) & SECTION_TYPE) == S_COALESCED){
		    continue;
		}
		/*
		 * The symbol exists and both are not coalesced symbols.  So if
		 * the merged symbol is anything but a common or undefined then
		 * it is multiply defined.
		 */
		if(merged_symbol->nlist.n_type != (N_UNDF | N_EXT)){
		    /*
		     * If this is a two-level namespace link and this library is
		     * referenced indirectly then don't issue a multiply
		     * defined error or warning about symbols from it.
		     */
		    if(twolevel_namespace == TRUE &&
		       dynamic_library->definition_obj->library_ordinal == 0)
			continue;
		    /*
		     * It is multiply defined so the logic of the routine
		     * multiply_defined() is copied here so that tracing a
		     * symbol from a dylib module can be done.
		     */
		    for(k = 0; k < nmultiple_defs; k++){
			if(strcmp(multiple_defs[k],
				  merged_symbol->nlist.n_un.n_name) == 0)
			    break;
		    }
		    for(l = 0; l < ntrace_syms; l++){
			if(strcmp(trace_syms[l],
				  merged_symbol->nlist.n_un.n_name) == 0)
			    break;
		    }
		    if(k == nmultiple_defs){
			if(allow_multiply_defined_symbols == TRUE){
			    warning("multiple definitions of symbol %s",
				  merged_symbol->nlist.n_un.n_name);
			}
			else if((twolevel_namespace == TRUE &&
			    merged_symbol->defined_in_dylib == FALSE) ||
			   (force_flat_namespace == FALSE &&
			    ((((struct mach_header *)(cur_obj->obj_addr))->
			        flags & MH_TWOLEVEL) == MH_TWOLEVEL ||
			    (merged_symbol->defined_in_dylib == TRUE &&
			     (((struct mach_header *)(merged_symbol->
			        definition_object->obj_addr))->flags &
   				MH_TWOLEVEL) == MH_TWOLEVEL)))){
				if(multiply_defined_flag ==
				   MULTIPLY_DEFINED_WARNING){
				    warning("multiple definitions of symbol %s",
					  merged_symbol->nlist.n_un.n_name);
				    if(nowarnings == TRUE)
					continue;
				}
				else if(multiply_defined_flag ==
				   MULTIPLY_DEFINED_ERROR){
				    error("multiple definitions of symbol %s",
					  merged_symbol->nlist.n_un.n_name);
				}
				else if(multiply_defined_flag ==
				   MULTIPLY_DEFINED_SUPPRESS)
				    continue;
			}
			else{
			    error("multiple definitions of symbol %s",
				  merged_symbol->nlist.n_un.n_name);
			}
			multiple_defs = reallocate(multiple_defs,
			    (nmultiple_defs + 1) * sizeof(char *));
			multiple_defs[nmultiple_defs++] =
			    merged_symbol->nlist.n_un.n_name;
			if(l == ntrace_syms)
			    trace_merged_symbol(merged_symbol);
		    }
		    if(was_traced == FALSE){
			trace_symbol(symbol_name, fake_trace_symbol, cur_obj,
			    "error in trace_symbol()");
		    }
		    continue;
		}
	    }
use_symbol_definition_from_this_dylib:
	    maybe_remove_dwarf_symbol(merged_symbol);
	    merged_symbol->nlist.n_type = N_PBUD | N_EXT;
	    merged_symbol->nlist.n_sect = NO_SECT;
	    if((symbols[j].n_type & N_TYPE) == N_SECT &&
		((cur_obj->section_maps[symbols[j].n_sect - 1].
		  s->flags) & SECTION_TYPE) == S_COALESCED){
		merged_symbol->coalesced_defined_in_dylib = TRUE;
		if((symbols[j].n_desc & N_WEAK_DEF) == N_WEAK_DEF)
		    merged_symbol->weak_def_in_dylib = TRUE;
#ifdef COALESCE_DEBUG
printf("merging in coalesced symbol %s\n", merged_symbol->nlist.n_un.n_name);
#endif
	    }
	    /*
	     * If -twolevel_namespace is in effect and this symbol is referenced
	     * from an object going into the image and will need the library
	     * ordinal recorded check to see that this dynamic library has been
	     * assigned an ordinal (that is it was listed on the link line or
	     * is a sub-framework or sub-umbrella of something listed).  If not
	     * flag this as an illegal reference to an indirect dynamic library
	     * if this library was not flagged already.
	     */
	    if(save_reloc == FALSE &&
	       twolevel_namespace == TRUE &&
	       merged_symbol->referenced_in_non_dylib == TRUE &&
	       dynamic_library->definition_obj->library_ordinal == 0 &&
	       dynamic_library->indirect_twolevel_ref_flagged == FALSE){
		obj = cur_obj;
		cur_obj = merged_symbol->definition_object;
		error_with_cur_obj("illegal reference to symbol: %s defined in "
		    "indirectly referenced dynamic library %s", symbol_name,
		    dynamic_library->dylib_file != NULL ?
		    dynamic_library->file_name : dynamic_library->dylib_name);
		cur_obj = obj;
		dynamic_library->indirect_twolevel_ref_flagged = TRUE;
	    }
	    /*
	     * Don't change the reference type bits of the n_desc field as it
	     * contains the reference type (lazy or non-lazy).
	     */
	    merged_symbol->nlist.n_value = symbols[j].n_value;
	    if(symbols[j].n_desc & N_ARM_THUMB_DEF)
		merged_symbol->nlist.n_value |= 1;
	    merged_symbol->definition_object = cur_obj;
	    merged_symbol->defined_in_dylib = TRUE;
	    merged_symbol->definition_library = dynamic_library;
	    /*
	     * If this shared library is being forced to be weak linked then
	     * set N_WEAK_REF to make this symbol a weak reference.
	     */
	    if(dynamic_library->force_weak_dylib &&
	       merged_symbol->referenced_in_non_dylib == TRUE)
		merged_symbol->nlist.n_desc |= N_WEAK_REF;
	    /*
	     * If the merged symbol we are resolving is not a weak reference
	     * and it is referenced from a non-dylib then set
	     * some_non_weak_refs to TRUE.
	     */
	    if((merged_symbol->nlist.n_desc & N_WEAK_REF) == 0 &&
	       merged_symbol->referenced_in_non_dylib == TRUE)
		dynamic_library->some_non_weak_refs = TRUE;
	    if(merged_symbol->referenced_in_non_dylib == TRUE)
		dynamic_library->some_symbols_referenced = TRUE;
	    if((symbols[j].n_type & N_TYPE) == N_INDR){
		merged_symbol->nlist.n_type = N_INDR | N_EXT;
		enter_indr_symbol(merged_symbol, symbols + j, strings, cur_obj);
	    }
	    /*
	     * If -twolevel_namespace is in effect record the library ordinal
	     * that this symbol definition is in.
	     */
	    if(twolevel_namespace == TRUE){
		SET_LIBRARY_ORDINAL(merged_symbol->nlist.n_desc,
			    dynamic_library->definition_obj->library_ordinal);
		/*
		 * It is possible that a common or undefined symbol could have
		 * been in the merged symbol table and this dylib module is now
		 * replacing it.  If so we have to look it up in the table of
		 * contents to get the correct index into the table of contents
		 * for the hint to be recorded.
		 */
		if(merged_symbol->itoc == 0){
		    bsearch_strings = dynamic_library->strings;
		    bsearch_symbols = dynamic_library->symbols;
		    toc = bsearch(merged_symbol->nlist.n_un.n_name,
			      dynamic_library->tocs,
			      dynamic_library->definition_obj->dysymtab->ntoc,
			      sizeof(struct dylib_table_of_contents),
			      (int (*)(const void *, const void *))
				dylib_bsearch);
		    merged_symbol->itoc = toc - dynamic_library->tocs;
		}
	    }
	}

	/*
	 * If the -Y flag is set (trace undefined symbols) then we create an
	 * undefined map for this object file so process_undefineds() can use it
	 * to do the work for -Y.
	 */
	if(Yflag && cur_obj->dylib_module->nrefsym != 0){
	    nundefineds = 0;
	    for(i = 0; i < cur_obj->dylib_module->nrefsym; i++){
		j = i + cur_obj->dylib_module->irefsym;
		flags = refs[j].flags;
		if(flags == REFERENCE_FLAG_UNDEFINED_NON_LAZY ||
		   flags == REFERENCE_FLAG_UNDEFINED_LAZY){
		    nundefineds++;
		}
	    }
	    cur_obj->undefined_maps = allocate(nundefineds *
					       sizeof(struct undefined_map));
	    cur_obj->nundefineds = nundefineds;
	}
	nundefineds = 0;

	/*
	 * Second loop through the symbols referenced by this module and merge
	 * undefined references into the merged symbol table.
	 */
	for(i = 0; i < cur_obj->dylib_module->nrefsym; i++){
	    j = i + cur_obj->dylib_module->irefsym;
	    flags = refs[j].flags;
	    if(flags == REFERENCE_FLAG_UNDEFINED_NON_LAZY ||
	       flags == REFERENCE_FLAG_UNDEFINED_LAZY){
		symbol_name = strings + symbols[refs[j].isym].n_un.n_strx;
		/*
		 * Do the trace of this symbol if specified.
		 */
		if(ntrace_syms != 0){
		    for(k = 0; k < ntrace_syms; k++){
			if(strcmp(trace_syms[k], symbol_name) == 0){
			    if(force_flat_namespace == TRUE ||
           		       (((struct mach_header *)(cur_obj->obj_addr))->
				flags & MH_TWOLEVEL) != MH_TWOLEVEL){
				trace_symbol(symbol_name, &(undefined_symbol),
					 cur_obj, "error in trace_symbol()");
			    }
			    else{
				print_obj_name(cur_obj);
				library_ordinal = GET_LIBRARY_ORDINAL(symbols[
				    refs[j].isym].n_desc);
				if(library_ordinal != 0 &&
				   library_ordinal != DYNAMIC_LOOKUP_ORDINAL){
				    dep = dynamic_library->dependent_images[
					      library_ordinal - 1];
				    if(dep->umbrella_name != NULL)
					name = dep->umbrella_name;
				    else if(dep->library_name != NULL)
					name = dep->library_name;
				    else
					name = dep->dylib_name;
				    print("reference to undefined %s (from %s)"
					  "\n", symbol_name, name);
				}
				else
				    print("reference to undefined %s\n",
					  symbol_name);
			    }
			    break;
			}
		    }
		}
		/*
		 * Determine how this reference will be resolved. If
		 * -force_flat_namespace is TRUE it will be resolved flat.
		 * If this dylib is not a two-level namespace dylib it will
		 * also be resolved flat.  It it is a two-level dylib then
		 * if the library_ordinal is DYNAMIC_LOOKUP_ORDINAL it will be
		 * resolved flat.  If it is a two-level namespace dylib and
		 * the library_ordinal is not DYNAMIC_LOOKUP_ORDINAL it will
		 * be resolved with two-level namespace semantics.
		 */
		if(force_flat_namespace == TRUE)
		    resolve_flat = TRUE;
		else{
		    if((((struct mach_header *)(cur_obj->obj_addr))->
			flags & MH_TWOLEVEL) == MH_TWOLEVEL){
			library_ordinal = GET_LIBRARY_ORDINAL(
						symbols[refs[j].isym].n_desc);
			if(library_ordinal == DYNAMIC_LOOKUP_ORDINAL)
			    resolve_flat = TRUE;
			else
			    resolve_flat = FALSE;
		    }
		    else{
			resolve_flat = TRUE;
		    }
		}
		if(resolve_flat == TRUE){
		    /*
		     * The new linking architecture model when building a
		     * two-level namespace image states "with two level
		     * namespace, there is no need to resolve undefines in
		     * dependent dylibs".  So if we are building a two-level
		     * namespace image even when linking against a
		     * flat-namespace dylib, that dylib's undefined references
		     * are not to be resolved.
		     *
		     * This of course has the architectural flaw that error
		     * checking is lost and we could be building a broken
		     * binary.
		     */
		    if(twolevel_namespace == TRUE &&
		       (((struct mach_header *)(cur_obj->obj_addr))->
			  flags & MH_TWOLEVEL) != MH_TWOLEVEL){
			continue; /* with for loop */
		    }
		    /* lookup the symbol and see if it has already been seen */
		    hash_pointer = lookup_symbol(symbol_name);
		    if(hash_pointer->name_len == 0){
			/*
			 * The symbol has not been seen yet so just enter it as
			 * an undefined symbol and it will be returned.
			 */
			merged_symbol = enter_symbol(hash_pointer,
				    &(undefined_symbol), symbol_name, cur_obj);
		    }
		    else{
			merged_symbol = hash_pointer;
		    }
		    merged_symbol->nlist.n_desc |= REFERENCED_DYNAMICALLY;
		}
		else{
		    /*
		     * This is a two-level namespace dylib so this must be
		     * resolved to the symbol from the referenced dylib. To do
		     * this we fake up a merged_symbol and place it on the
		     * undefined list with the twolevel_reference bit set and
		     * the referencing_library field set.  Then
		     * search_dynamic_libs() in pass1.c will figure out which
		     * dylib module is being referenced and load it.
		     */
		    /*
		     * With two level namespace, there is no need to resolve
		     * undefines in dependent dylibs.  Their location was fixed
		     * when that dylib was built.  The check here is that any
		     * undefine which already has an ordinal and the ordinal
		     * refers to a library that can't be accessed by the
		     * being-linked image, then ignore it
		     *
		     * The comment above, from the original change, does not
		     * consider the architectural need to resolve undefines in
		     * dependent dylibs for error checking, and to avoid
		     * building broken programs that could be detected at build
		     * time instead of letting that happen at runtime.  Which
		     * could be very late do to lazy binding.
		     *
		     * The logic below also seems flawed in that undefined
		     * references that are marked to be looked up dynamically
		     * are still searched. But may not be found as the
		     * indirectly referenced dylibs are now removed from the
		     * list of dylibs to be searched.
		     */
		    library_ordinal = GET_LIBRARY_ORDINAL(
						symbols[refs[j].isym].n_desc);
		    if((library_ordinal != SELF_LIBRARY_ORDINAL) &&
		       (library_ordinal != DYNAMIC_LOOKUP_ORDINAL)){
			dep = dynamic_library->dependent_images[
							library_ordinal - 1];
			if(dep->definition_obj->library_ordinal == 0)
			    continue; /* with for loop */
		    }
		    merged_symbol = allocate(sizeof(struct merged_symbol));
		    memset(merged_symbol, '\0', sizeof(struct merged_symbol));

		    merged_symbol->nlist = symbols[refs[j].isym];
		    merged_symbol->nlist.n_un.n_name = symbol_name;
		    merged_symbol->definition_object = cur_obj;
		    merged_symbol->twolevel_reference = TRUE;
		    merged_symbol->referencing_library = dynamic_library;
		    add_to_undefined_list(merged_symbol);
		}
		if(Yflag){
		    cur_obj->undefined_maps[nundefineds++].merged_symbol =
			merged_symbol;
		}
	    }
	}

	/*
	 * Last loop through the private symbols referenced by this module and
	 * make sure the module is linked in.  If not force it to be linked in.
	 * Note this is doing pass1 functionality and causing modules to be
	 * linked in.  So that cur_obj can change through out this loop.
	 */
	obj = cur_obj;
	for(i = 0; i < obj->dylib_module->nrefsym; i++){
	    j = i + obj->dylib_module->irefsym;
	    flags = refs[j].flags;
	    if(flags == REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY ||
	       flags == REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY){
		/*
		 * Using the symbol index, refs[j].isym, figure out which
		 * module owns this symbol and set that into module_index.
		 */
		for(k = 0; k < obj->dysymtab->nmodtab; k++){
		    if(refs[j].isym >= dynamic_library->mods[k].ilocalsym &&
		       refs[j].isym <  dynamic_library->mods[k].ilocalsym +
				       dynamic_library->mods[k].nlocalsym)
			break;
		}
		if(k >= obj->dysymtab->nmodtab){
		    error_with_cur_obj("isym field (%u) of reference table "
			"entry %lu for private reference not in the local "
			"symbols for any module", refs[j].isym, j);
		    return;
		}
		module_index = k;
		if(is_dylib_module_loaded(dynamic_library->mods +
					  module_index) == FALSE){

		    cur_obj = new_object_file();
		    *cur_obj = *(dynamic_library->definition_obj);
		    cur_obj->dylib_module = dynamic_library->mods +
					    module_index;
		    if(dynamic_library->linked_modules != NULL)
			dynamic_library->linked_modules[module_index / 8] |=
				1 << module_index % 8;
		    if(whyload){
			print_obj_name(cur_obj);
			symbol_name = strings +
				      symbols[refs[j].isym].n_un.n_strx;
			print("loaded to resolve private symbol: %s\n",
			      symbol_name);
		    }
		    merge_dylib_module_symbols(dynamic_library);
		    cur_obj = obj;
		}
	    }
	}
}
/*
 * merge_bundle_loader_symbols() merges the symbols from the current object
 * (cur_obj) which represents the bundle loader module into the merged symbol
 * table.  The parameter dynamic_library is the dynamic library struct the
 * current object is from.
 */
__private_extern__
void
merge_bundle_loader_symbols(
struct dynamic_library *dynamic_library)
{
    unsigned long i, j, k, l;
    char *strings, *symbol_name;
    struct nlist *symbols, *fake_trace_symbol;
    enum bool was_traced;
    struct merged_symbol *hash_pointer, *merged_symbol;

	strings = cur_obj->obj_addr + cur_obj->symtab->stroff;
	symbols = (struct nlist *)(cur_obj->obj_addr +
				   cur_obj->symtab->symoff);
	/*
	 * Loop through the symbols defined by the bundle loader and merge them
	 * into the merged symbol table.
	 */
	for(i = 0; i < cur_obj->dysymtab->nextdefsym; i++){
	    j = i + cur_obj->dysymtab->iextdefsym;
	    symbol_name = strings + symbols[j].n_un.n_strx;
	    /*
	     * Do the trace of the symbol_name if specified.
	     */
	    if((symbols[j].n_desc & N_WEAK_DEF) == N_WEAK_DEF)
		fake_trace_symbol = &pbud_weak_def_symbol;
	    else
		fake_trace_symbol = &pbud_symbol;
	    was_traced = FALSE;
	    if(ntrace_syms != 0){
		for(k = 0; k < ntrace_syms; k++){
		    if(strcmp(trace_syms[k], symbol_name) == 0){
			trace_symbol(symbol_name, fake_trace_symbol, cur_obj,
			    "error in trace_symbol()");
			was_traced = TRUE;
			break;
		    }
		}
	    }
	    /* lookup the symbol_name and see if it has already been seen */
	    hash_pointer = lookup_symbol(symbol_name);
	    if(hash_pointer->name_len == 0){
		/*
		 * The symbol has not been seen yet so just enter it as a
		 * prebound undefined.
		 */
		merged_symbol = enter_symbol(hash_pointer, &(pbud_symbol),
					     symbol_name, cur_obj);
	    }
	    else{
		merged_symbol = hash_pointer;
		/*
		 * If the merged symbol is not undefined and if this symbol is
		 * a weak definition then it is simply ignored and the merged
		 * symbol is used.  Note currently only coalesced sections can
		 * have this attribute and this is checked for in check_symbol()
		 * so it is assumed it is a coalesced symbol here.
		 */
		if((merged_symbol->nlist.n_type != (N_UNDF | N_EXT) ||
		    merged_symbol->nlist.n_value != 0) &&
		   (symbols[j].n_desc & N_WEAK_DEF) == N_WEAK_DEF){
		    continue;
		}
		/*
		 * If the merged symbol is a weak definition then it is
		 * discarded and this symbol definition from this bundle
		 * loader is used.
		 */
		if(((merged_symbol->nlist.n_desc & N_WEAK_DEF) == N_WEAK_DEF) ||
			(merged_symbol->defined_in_dylib == TRUE &&
			 merged_symbol->weak_def_in_dylib)){
		    if(merged_symbol->defined_in_dylib == FALSE){
			if((merged_symbol->nlist.n_type & N_EXT) &&
			   (merged_symbol->nlist.n_type & N_PEXT)){
			    merged_symbol->definition_object->nprivatesym--;
			    nmerged_private_symbols--;
			}
			else{
			    merged_symbol->definition_object->nextdefsym--;
			}
		    }
		    /*
		     * If the output file is a multi module MH_DYLIB type reset
		     * the reference map for the merged external symbol that
		     * is being discarded.
		     */
		    if(filetype == MH_DYLIB &&
		       multi_module_dylib == TRUE &&
		       merged_symbol->defined_in_dylib == FALSE){
			/*
			 * Discared coalesced symbols are referenced as
			 * undefined. TODO: to determine if the reference is
			 * lazy or non-lazy we would have to look at all the
			 * relocation entries in this object.  For now just
			 * assume non-lazy to be safe.
			 */
			for(k = 0;
			    k < merged_symbol->definition_object->nrefsym;
			    k++){
			    if(merged_symbol->definition_object->
			       reference_maps[k].merged_symbol ==
							    merged_symbol){
				if(symbols[k].n_type & N_PEXT)
				    merged_symbol->definition_object->
				    reference_maps[k].flags =
				  REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY;
				else
				    merged_symbol->definition_object->
				    reference_maps[k].flags =
					REFERENCE_FLAG_UNDEFINED_NON_LAZY;
				break;
			    }
			}
		    }
		    merged_symbol->coalesced_defined_in_dylib = FALSE;
		    merged_symbol->weak_def_in_dylib = FALSE;
		    goto use_symbol_definition_from_this_bundle_loader;
		}
		/*
		 * If both symbols are coalesced symbols then the this
		 * symbol is simply ignored.
		 */
		if((((merged_symbol->nlist.n_type & N_TYPE) == N_SECT &&
		      ((merged_symbol->definition_object->section_maps[
			   merged_symbol->nlist.n_sect - 1].s->flags) &
			   SECTION_TYPE) == S_COALESCED) ||
		     merged_symbol->coalesced_defined_in_dylib == TRUE) &&
		   (symbols[j].n_type & N_TYPE) == N_SECT &&
		   ((cur_obj->section_maps[symbols[j].n_sect - 1].
			s->flags) & SECTION_TYPE) == S_COALESCED){
		    continue;
		}
		/*
		 * The symbol exist and both are not coalesced symbols.  So if
		 * the merged symbol is anything but a common or undefined then
		 * it is multiply defined.
		 */
		if(merged_symbol->nlist.n_type != (N_UNDF | N_EXT)){
		    /*
		     * It is multiply defined so the logic of the routine
		     * multiply_defined() is copied here so that tracing a
		     * symbol from a dylib module can be done.
		     */
		    for(k = 0; k < nmultiple_defs; k++){
			if(strcmp(multiple_defs[k],
				  merged_symbol->nlist.n_un.n_name) == 0)
			    break;
		    }
		    for(l = 0; l < ntrace_syms; l++){
			if(strcmp(trace_syms[l],
				  merged_symbol->nlist.n_un.n_name) == 0)
			    break;
		    }
		    /*
		     * If -private_bundle is used then don't worry about any
		     * multiply defined references.
		     */
		    if(private_bundle == TRUE)
			break;
		    if(k == nmultiple_defs){
			if(allow_multiply_defined_symbols == TRUE){
			    warning("multiple definitions of symbol %s",
				  merged_symbol->nlist.n_un.n_name);
			}
			else if((twolevel_namespace == TRUE &&
			    merged_symbol->defined_in_dylib == FALSE) ||
			   (force_flat_namespace == FALSE &&
			    ((((struct mach_header *)(cur_obj->obj_addr))->
			        flags & MH_TWOLEVEL) == MH_TWOLEVEL ||
			    (merged_symbol->defined_in_dylib == TRUE &&
			     (((struct mach_header *)(merged_symbol->
			        definition_object->obj_addr))->flags &
   				MH_TWOLEVEL) == MH_TWOLEVEL)))){
				if(multiply_defined_flag ==
				   MULTIPLY_DEFINED_WARNING)
				    warning("multiple definitions of symbol %s",
					  merged_symbol->nlist.n_un.n_name);
				else if(multiply_defined_flag ==
				   MULTIPLY_DEFINED_ERROR){
				    error("multiple definitions of symbol %s",
					  merged_symbol->nlist.n_un.n_name);
				}
				else if(multiply_defined_flag ==
				   MULTIPLY_DEFINED_SUPPRESS)
				    continue;
			}
			else{
			    error("multiple definitions of symbol %s",
				  merged_symbol->nlist.n_un.n_name);
			}
			multiple_defs = reallocate(multiple_defs,
			    (nmultiple_defs + 1) * sizeof(char *));
			multiple_defs[nmultiple_defs++] =
			    merged_symbol->nlist.n_un.n_name;
			if(l == ntrace_syms)
			    trace_merged_symbol(merged_symbol);
		    }
		    if(was_traced == FALSE)
			trace_symbol(symbol_name, fake_trace_symbol, cur_obj,
			    "error in trace_symbol()");
		    continue;
		}
	    }
use_symbol_definition_from_this_bundle_loader:
	    maybe_remove_dwarf_symbol(merged_symbol);
	    merged_symbol->nlist.n_type = N_PBUD | N_EXT;
	    merged_symbol->nlist.n_sect = NO_SECT;
	    if((symbols[j].n_type & N_TYPE) == N_SECT &&
		((cur_obj->section_maps[symbols[j].n_sect - 1].
		  s->flags) & SECTION_TYPE) == S_COALESCED){
		merged_symbol->coalesced_defined_in_dylib = TRUE;
		if((symbols[j].n_desc & N_WEAK_DEF) == N_WEAK_DEF)
		    merged_symbol->weak_def_in_dylib = TRUE;
#ifdef COALESCE_DEBUG
printf("merging in coalesced symbol %s\n", merged_symbol->nlist.n_un.n_name);
#endif
	    }

	    /*
	     * Since this is the bundle loader it always has the library
	     * ordinal EXECUTABLE_ORDINAL assigned to it and we don't have to
	     * worry about illegal reference to an indirect "dynamic library".
	     */

	    /*
	     * Don't change the reference type bits if n_desc field as it
	     * contains the reference type (lazy or non-lazy).
	     */
	    merged_symbol->nlist.n_value = symbols[j].n_value;
	    merged_symbol->definition_object = cur_obj;
	    merged_symbol->defined_in_dylib = TRUE;
	    merged_symbol->definition_library = dynamic_library;
	    if((symbols[j].n_type & N_TYPE) == N_INDR){
		merged_symbol->nlist.n_type = N_INDR | N_EXT;
		enter_indr_symbol(merged_symbol, symbols + j, strings, cur_obj);
	    }
	    /*
	     * If -twolevel_namespace is in effect record the library ordinal
	     * that this symbol definition is in.
	     */
	    if(twolevel_namespace == TRUE){
		SET_LIBRARY_ORDINAL(merged_symbol->nlist.n_desc,
			    dynamic_library->definition_obj->library_ordinal);
	    }
	}

	/*
	 * For the bundle loader we simply ignore any undefined references it
	 * might have and since it is a one module image there is nothing to
	 * do for its private symbols.
	 */
}
#endif /* !defined(RLD) */

/*
 * is_output_local_symbol() returns TRUE or FALSE depending if the local symbol
 * type, section, object and name passed to it will be in the output file's
 * symbol table based on the level of symbol stripping.  If it returns TRUE it
 * also indirectly returns the size of the local string for output in
 * output_strlen (possibly truncated if the strip level is STRIP_MIN_DEBUG).
 * The obj passed must be the object this symbol came from so that the the
 * section can be checked for the S_ATTR_STRIP_STATIC_SYMS attribute flag.
 */
__private_extern__
enum bool
is_output_local_symbol(
unsigned char n_type,
unsigned char n_sect,
unsigned char n_desc,
struct object_file *obj,
char *symbol_name,
unsigned long *output_strlen)
{
#ifndef RLD
    char *end;
#endif /* !defined(RLD) */

	*output_strlen = 0;
	switch(strip_level){
	    case STRIP_NONE:
	    case STRIP_DUP_INCLS:
		/*
		 * We are not stripping stabs.  But if we see an N_OSO we
		 * will change it's name in some cases.  In here with just
		 * return the lenght of the new name.  In output_local_symbols()
		 * is where the new name is set for the output file.
		 */
		if(n_type == N_OSO){
		    /*
		     * When the compiler is producing dwarf debug info it
		     * uses stabs for debug notes.  And the N_OSO stabs in this
		     * case has a n_desc field of 1.  If the name is the empty
		     * string (not NULL but a 1 character string with just a
		     * '\0') then change the name to the full path of the
		     * object file.  If the name is not an empty string it is
		     * left unchanged.
		     */
		    if(n_desc == 1){
			if(symbol_name != NULL && *symbol_name == '\0'){
			    if(obj->resolved_path == NULL)
				set_obj_resolved_path(obj);
			    *output_strlen = cur_obj->resolved_path_len;
			}
			else{
			    *output_strlen = strlen(symbol_name);
			}
		    }
		    /*
		     * When the compiler is producing stabs debug info it will
		     * produce an N_OSO stab with an n_desc field of 0.  In this
		     * (saving all stabs an -Sp is not specified) the name gets
		     * reset to "" (that a one character string with only a '\0'
		     * character).  Unless the input n_un.n_strx field is 0 then
		     * it will end up as 0 in the output.
		     */
		    else if(n_desc == 0){
			*output_strlen = 0;
		    }
		    /*
		     * If the n_desc field of this N_OSO stab is something
		     * other than 1 or 0 leave the name unchanged.
		     */
		    else{
			*output_strlen = strlen(symbol_name);
		    }
		}
		else{
		    *output_strlen = strlen(symbol_name);
		}
		return(TRUE);
	    case STRIP_ALL:
	    case STRIP_DYNAMIC_EXECUTABLE:
	    case STRIP_NONGLOBALS:
		return(FALSE);
	    case STRIP_DEBUG:
		if(n_type & N_STAB ||
		   (*symbol_name == 'L' && (n_type & N_STAB) == 0) ||
		   (save_reloc == FALSE &&
		    (n_type & N_TYPE) == N_SECT &&
		    (obj->section_maps[n_sect - 1].s->flags &
		     S_ATTR_STRIP_STATIC_SYMS) == S_ATTR_STRIP_STATIC_SYMS))
		    return(FALSE);
		else{
		    *output_strlen = strlen(symbol_name);
		    return(TRUE);
		}
	    case STRIP_MIN_DEBUG:
#ifndef RLD
		if(n_type & N_STAB){
		    switch(n_type){
		    case N_OSO:
			/*
			 * When the compiler is producing dwarf debug info it
			 * uses stabs for debug notes.  And the N_OSO stabs in
			 * this case has a n_desc field of 1.  If the name is
			 * the empty string (not NULL but a 1 character string
			 * with just a '\0') then change the name to the full
			 * path of the object file.  If the name is not an empty
			 * string it is left unchanged.
			 */
			if(n_desc == 1){
			    if(symbol_name != NULL && *symbol_name == '\0'){
				if(obj->resolved_path == NULL)
				    set_obj_resolved_path(obj);
				*output_strlen = cur_obj->resolved_path_len;
			    }
			    else{
				*output_strlen = strlen(symbol_name);
			    }
			}
			/*
			 * When the compiler is producing stabs debug info it
			 * will produce an N_OSO stab with an n_desc field of 0.
			 * In this case where -Sp is specified name is changed
			 * to the full path of the object file.
			 */
			else if(n_desc == 0){
			    if(obj->resolved_path == NULL)
				set_obj_resolved_path(obj);
			    *output_strlen = cur_obj->resolved_path_len;
			}
			/*
			 * If the n_desc is not 0 or 1 then leave the name
			 * unchanged.
			 */
			else{
			    *output_strlen = strlen(symbol_name);
			}
			return(TRUE);
		    /* keep these and their full strings */
		    case N_SO:
		    case N_SOL:
		    case N_OPT:
			*output_strlen = strlen(symbol_name);
			return(TRUE);
		    /* keep these but truncate the string to just NAME:<type> */
		    case N_LCSYM:
		    case N_STSYM:
		    case N_GSYM:
		    case N_FUN:
			end = find_stab_type_end(
				find_stab_name_end(symbol_name));
			if(end != NULL)
			    *output_strlen = end - symbol_name;
			else
			    /*
			     * The string is not what is expected just leave
			     * the output_strlen the size of whole string.
			     */
			    *output_strlen = strlen(symbol_name);
			return(TRUE);
		    /* strip all other stabs */
		    default:
			return(FALSE);
		    }
		}
		/* it's not a stab see if we still keep it or not */
		else if(*symbol_name == 'L' ||
		   (save_reloc == FALSE &&
		    (n_type & N_TYPE) == N_SECT &&
		    (obj->section_maps[n_sect - 1].s->flags &
		     S_ATTR_STRIP_STATIC_SYMS) == S_ATTR_STRIP_STATIC_SYMS))
		    return(FALSE);
		else{
		    *output_strlen = strlen(symbol_name);
		    return(TRUE);
		}
#endif /* !defined(RLD) */
	    case STRIP_L_SYMBOLS:
		if(*symbol_name == 'L' && (n_type & N_STAB) == 0)
		    return(FALSE);
		else{
		    *output_strlen = strlen(symbol_name);
		    return(TRUE);
		}
	}
	/* never gets here but shuts up a bug in -Wall */
	*output_strlen = strlen(symbol_name);
	return(TRUE);
}

/*
 * is_type_stab() is passed the n_type and the name of a symbol.  It that is a
 * type stab returns TRUE else it returns FALSE.  A type stab is an L_LSYM stab
 * of the form:
 *	NAME:<type>
 * where <type> is a 'T' or 't'.
 */
static
enum bool
is_type_stab(
unsigned char n_type,
char *symbol_name)
#ifdef RLD
{
	return(FALSE);
}
#else /* !defined(RLD) */
{
    char *end;

	if((n_type & N_STAB) == 0 || n_type != N_LSYM)
	    return(FALSE);
	end = find_stab_name_end(symbol_name);
	if(end != NULL && end[1] != '\0' && (end[1] == 'T' || end[1] == 't'))
	    return(TRUE);
	else
	    return(FALSE);
}

/*
 * find_stab_name_end() parses a stab string of the form:
 *	NAME:<type><index>
 * And returns a pointer to the ':' if there is one or NULL.  This is the same
 * way gdb(1) parses this.
 *
 * The NAME part is either a C or C++ variable/function name, or an ObjC method
 * name.  The latter makes looking for the : a little tricky, since it can also
 * contain ":"'s...
 * The <type> field is one or more characters in the set [a-zA-Z].
 *    But gdb only allows any single character or the pair "Tt".
 * The <index> field is either an integer (positive or negative) or a comma
 * delimited pair of integers in parenthesis: "(<INT>,<INT>)".
 */
static
char *
find_stab_name_end(
char *name)
{
    char *first_colon, *next_colon, *s, *first_lbrac, *first_rbrac;

	for(first_colon = strchr(name, ':');
	    first_colon != NULL &&
		first_colon[1] == ':' && first_colon[2] != '\0';
	    /* no increment expression */){

	    /* Check for blah::blah in a C++ name */
	    next_colon = strchr(&first_colon[2], ':');
	    if(next_colon != NULL)
		first_colon = next_colon;
	    else
		break;
	}

	if(first_colon == NULL)
	    return(NULL);
	/*
	 * It's tempting to use strchr to look for the leftmost lbrac but that
	 * would mean scanning the whole stab string, which can be quite long.
	 * Since we only care whether there is a left square bracket BEFORE the
	 * first colon, restrict the search to that.
	 */
	first_lbrac = NULL;
	for(s = name; s < first_colon; s++){
	    if(*s == '['){
		first_lbrac = s;
		break;
	    }
	}
	if(first_lbrac == NULL ||
	   (first_lbrac == name ||
	    (first_lbrac[-1] != '-' && first_lbrac[-1] != '+'))){
	    return first_colon;
	}
	else{
	    first_rbrac = strchr(name, ']');
	    /* If their is no rbrac then it is really an "invalid" symbol name.
	       so in this case just return NULL saying we could not find the
	       colon at the end of the name. */
	    if(first_rbrac == NULL)
		return(NULL);
	    return(strchr(first_rbrac, ':'));
	}
}

/*
 * find_stab_type_end() is passed what find_stab_name_end() above returns and
 * then parses past the <type> in:
 *	NAME:<type><index>
 * and returns a pointer to past the type or NULL. (see above in the comments
 * for find_stab_name_end() for more details).
 *
 * The <type> field is one or more characters in the set [a-zA-Z].
 *    But gdb only allows any single character or the pair "Tt".
 * So that is what is parsed here.
 */
static
char *
find_stab_type_end(
char *name_end)
{
	if(name_end == NULL || name_end[0] != ':')
	    return(NULL);
	if(!isalpha(name_end[1]))
	    return(NULL);
	if(name_end[1] == 'T' && name_end[2] == 't')
	    return(name_end + 3);
	else
	    return(name_end + 2);
}
#endif /* !defined(RLD) */

/*
 * lookup_symbol() returns a pointer to a merged_symbol struct for the symbol
 * name passed to it.  Either the symbol is found in which case the struct
 * pointed to has a non-zero name_len field.  If the symbol is not found the
 * struct pointed to is used by enter_symbol() to enter the symbol.  This
 * is the routine that actually allocates the merged_symbol structs as part of
 * the merged_symbol_chunk structs.  And it allocates the first of the
 * merged_symbol_list structs hang off the merged_symbol_root.
 */
__private_extern__
struct merged_symbol *
lookup_symbol(
char *symbol_name)
{
    struct merged_symbol_chunk *p, *q;
    struct merged_symbol *sym;
    unsigned long hash_index, i, name_len;

	hash_index = hash_string(symbol_name, &name_len) %
		     SYMBOL_LIST_HASH_SIZE;
	if(merged_symbol_root == NULL){
	    merged_symbol_root = allocate(sizeof(struct merged_symbol_root));
	    memset(merged_symbol_root, 0, sizeof(struct merged_symbol_root));
	    merged_symbol_root->list =
		allocate(sizeof(struct merged_symbol_list));
	    memset(merged_symbol_root->list, 0,
		sizeof(struct merged_symbol_list));
	    merged_symbol_root->list->used = 0;
	    merged_symbol_root->list->next = NULL;
	    return(&merged_symbol_root->chunks[hash_index].symbols[0]);
	}
	q = NULL;
	for(p = &merged_symbol_root->chunks[hash_index]; p != NULL;p = p->next){
	    for(i = 0; i < SYMBOL_CHUNK_SIZE; i++){
		sym = &p->symbols[i];
		if(sym->name_len == 0){
			return(sym);
		}
		if(sym->name_len == name_len &&
		   strcmp(sym->nlist.n_un.n_name, symbol_name) == 0){
			return(sym);
		}
	    }
	    q = p;
	}
	q->next = allocate(sizeof(struct merged_symbol_chunk));
	memset(q->next, 0, sizeof(struct merged_symbol_chunk));
	return(&q->next->symbols[0]);
}

#ifndef RLD
/*
 * hash_instrument() is called when -hash_instrument is specified and prints out
 * the info about the hash table and the merged symbols lists.
 */
__private_extern__
void
hash_instrument(void)
{
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol_chunk *p;
    unsigned long n, u, i, j, h, b, c, t;

	n = 0;
	u = 0;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    u += merged_symbol_list->used;
	    n++;
	}
	print("Number of merged_symbol_lists = %lu (containing %d pointers "
	      "each)\n", n, SYMBOL_LIST_HASH_SIZE);
	print("sizeof(struct merged_symbol_list) is %lu (total %lu)\n",
	      sizeof(struct merged_symbol_list),
	      n * sizeof(struct merged_symbol_list));
	print("Number of used pointers in the lists = %lu (%.2f%%)\n",
	      u, ((double)u) / ((double)(SYMBOL_LIST_HASH_SIZE * n)) *
		    100.0);

	h = 0;
	b = 0;
	c = 0;
	for(i = 0; i < SYMBOL_LIST_HASH_SIZE; i++){
	    if(merged_symbol_root->chunks[i].symbols[0].name_len != 0)
		h++;
	    for(p = &merged_symbol_root->chunks[i];
		p != NULL;
		p = p->next){
		if(p != &merged_symbol_root->chunks[i])
		    c++;
		for(j = 0; j < SYMBOL_CHUNK_SIZE; j++){
		    if(p->symbols[j].name_len != 0)
			b++;
		}
	    }
	}
	print("The SYMBOL_LIST_HASH_SIZE is %d\n", SYMBOL_LIST_HASH_SIZE);
	print("sizeof(struct merged_symbol_root) is %lu\n",
	      sizeof(struct merged_symbol_root));
	print("Number of additional chunks: %lu (size of these %lu)\n", c,
	      c * sizeof(struct merged_symbol_chunk));
	print("Number of hash entries used: %lu (%.2f%%) average #buckets "
	      "%.2f\n", h, ((double)h)/ ((double)SYMBOL_LIST_HASH_SIZE) * 100.0,
	      ((double)b) / ((double)h) );
	t = SYMBOL_LIST_HASH_SIZE * SYMBOL_CHUNK_SIZE + c * SYMBOL_CHUNK_SIZE;
	print("Number of buckets (merged symbols) used: %lu out of %lu "
	      "(%.2f%%)\n", b, t, ((double)b)/ ((double)t) * 100.0);

	/* print_symbol_list("from hash_instrument()", FALSE); */
}
#endif /* !defined(RLD) */

/*
 * add_to_symbol_list() adds the passed merged_symbol to our linked list of
 * symbols that complements our hash table lookups.
 */
static
void
add_to_symbol_list(
struct merged_symbol *merged_symbol)
{
    struct merged_symbol_list *prev, *merged_symbol_list, *new;

	prev = NULL;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    if(merged_symbol_list->used != SYMBOL_LIST_HASH_SIZE){
		merged_symbol_list->symbols[merged_symbol_list->used] =
		    merged_symbol;
		merged_symbol_list->used += 1;
		return;
	    }
	    prev = merged_symbol_list;
	}
	new = allocate(sizeof(struct merged_symbol_list));
	prev->next = new;
	memset(new, '\0', sizeof(struct merged_symbol_list));
	new->symbols[0] = merged_symbol;
	new->used = 1;
	new->next = NULL;
}

/*
 * enter_symbol() enters the object_symbol passed to it in the merged symbol.
 * The object's string table and defintion object are also passed in.  The
 * hash_pointer points to an unused merged_symbol to fill in as previously
 * returned by lookup_symbol().
 */
static
struct merged_symbol *
enter_symbol(
struct merged_symbol *hash_pointer,
struct nlist *object_symbol,
char *object_strings,
struct object_file *definition_object)
{
    struct merged_symbol *merged_symbol;

	if((cur_obj != base_obj || strip_base_symbols == FALSE))
	    nmerged_symbols++;

	merged_symbol = hash_pointer;
	memset(merged_symbol, '\0', sizeof(struct merged_symbol));
	merged_symbol->nlist = *object_symbol;
#ifdef RLD
	if(cur_obj == base_obj && base_name == NULL)
	    merged_symbol->nlist.n_un.n_name = object_strings +
					       object_symbol->n_un.n_strx;
	else
#endif
	merged_symbol->nlist.n_un.n_name = enter_string(object_strings +
						 object_symbol->n_un.n_strx,
						 &merged_symbol->name_len);
	merged_symbol->definition_object = definition_object;
	add_to_symbol_list(merged_symbol);

	if(object_symbol->n_type == (N_UNDF | N_EXT) &&
	   object_symbol->n_value == 0)
	    add_to_undefined_list(merged_symbol);
	merged_symbol->undef_order = undef_order++;

	if(object_symbol->n_type == (N_INDR | N_EXT))
	    enter_indr_symbol(merged_symbol, object_symbol, object_strings,
			      definition_object);

	return(merged_symbol);
}

/*
 * enter_indr_symbol() enters the indirect symbol for the object_symbol passed
 * to it into the merged_symbol passed to it.
 */
static
void
enter_indr_symbol(
struct merged_symbol *merged_symbol,
struct nlist *object_symbol,
char *object_strings,
struct object_file *definition_object)
{
    struct merged_symbol *hash_pointer, *indr_symbol;

	nindr_symbols++;
	hash_pointer = lookup_symbol(object_strings + object_symbol->n_value);
	if(hash_pointer->name_len != 0){
	    indr_symbol = hash_pointer;
	}
	else{
	    indr_symbol = hash_pointer;
	    add_to_symbol_list(indr_symbol);
	    if(cur_obj != base_obj || strip_base_symbols == FALSE)
		nmerged_symbols++;
	    indr_symbol->nlist.n_type = N_UNDF | N_EXT;
	    indr_symbol->nlist.n_sect = NO_SECT;
	    if(definition_object != NULL &&
	       definition_object->dylib_module != NULL)
		indr_symbol->nlist.n_desc = REFERENCE_FLAG_UNDEFINED_LAZY;
	    else
		indr_symbol->nlist.n_desc = 0;
	    indr_symbol->nlist.n_value = 0;
#ifdef RLD
	    if(cur_obj == base_obj && base_name == NULL)
		indr_symbol->nlist.n_un.n_name = object_strings +
						 object_symbol->n_value;
	    else
#endif
	    indr_symbol->nlist.n_un.n_name = enter_string(object_strings +
						      object_symbol->n_value,
						      NULL);
	    indr_symbol->definition_object = definition_object;
	    add_to_undefined_list(indr_symbol);
	}
	merged_symbol->nlist.n_value = (unsigned long)indr_symbol;
}
/*
 * enter_string() places the symbol_name passed to it in the first string block
 * that will hold the string.  Since the string indexes will be assigned after
 * all the strings are entered putting the strings in the first block that fits
 * can be done rather than only last block.
 */
static
char *
enter_string(
char *symbol_name,
unsigned long *len_ret)
{
    struct string_block **p, *string_block;
    unsigned long len;
    char *r;

	len = strlen(symbol_name) + 1;
	if(len_ret != NULL)
	    *len_ret = len - 1;
	for(p = &(merged_string_blocks); *p; p = &(string_block->next)){
	    string_block = *p;
	    if(len > string_block->size - string_block->used)
		continue;
#ifdef RLD
	    if(string_block->set_num != cur_set)
		continue;
#endif /* RLD */
	    if(strip_base_symbols == TRUE &&
	       ((cur_obj == base_obj && string_block->base_strings == FALSE) ||
	        (cur_obj != base_obj && string_block->base_strings == TRUE) ) )
		continue;

	    if((cur_obj != NULL && cur_obj->dylib_module != NULL &&
		string_block->dylib_strings == FALSE) ||
	       ((cur_obj == NULL || cur_obj->dylib_module == NULL) &&
		string_block->dylib_strings == TRUE))
		continue;

	    r = strcpy(string_block->strings + string_block->used, symbol_name);
	    string_block->used += len;
	    if((strip_base_symbols == FALSE ||
	        string_block->base_strings == FALSE) &&
		string_block->dylib_strings == FALSE)
		merged_string_size += len;
	    return(r);
	}
	*p = allocate(sizeof(struct string_block));
	string_block = *p;
	string_block->size = (len > host_pagesize ? len : host_pagesize);
	string_block->used = len;
	string_block->next = NULL;
	string_block->strings = allocate(string_block->size);
	string_block->base_strings = cur_obj == base_obj ? TRUE : FALSE;
	if(cur_obj != NULL && cur_obj->dylib_module != NULL)
	    string_block->dylib_strings = TRUE;
	else
	    string_block->dylib_strings = FALSE;
#ifdef RLD
	string_block->set_num = cur_set;
#endif /* RLD */
	r = strcpy(string_block->strings, symbol_name);
	if((strip_base_symbols == FALSE ||
	    string_block->base_strings == FALSE) &&
	    string_block->dylib_strings == FALSE)
	    merged_string_size += len;
	return(r);
}

/*
 * add_to_undefined_list() adds a pointer to a merged symbol to the list of
 * undefined symbols.
 */
static
void
add_to_undefined_list(
struct merged_symbol *merged_symbol)
{
    struct undefined_block **p;
    struct undefined_list *new, *undefineds;
    unsigned long i;

	if(free_list.next == &free_list){
	    for(p = &(undefined_blocks); *p; p = &((*p)->next))
		;
	    *p = allocate(sizeof(struct undefined_block));
	    (*p)->next = 0;
	    undefineds = (*p)->undefineds;

	    /* add the newly allocated items to the empty free_list */
	    free_list.next = &undefineds[0];
	    undefineds[0].prev = &free_list;
	    undefineds[0].next = &undefineds[1];
	    for(i = 1 ; i < NUNDEF_BLOCKS - 1 ; i++){
		undefineds[i].prev  = &undefineds[i-1];
		undefineds[i].next  = &undefineds[i+1];
		undefineds[i].merged_symbol = NULL;
	    }
	    free_list.prev = &undefineds[i];
	    undefineds[i].prev = &undefineds[i-1];
	    undefineds[i].next = &free_list;
	}
	/* take the first one off the free list */
	new = free_list.next;
	new->next->prev = &free_list;
	free_list.next = new->next;

	/* fill in the pointer to the undefined symbol */
	new->merged_symbol = merged_symbol;

	/* put this at the end of the undefined list */
	new->prev = undefined_list.prev;
	new->next = &undefined_list;
	undefined_list.prev->next = new;
	undefined_list.prev = new;
}

/*
 * delete_from_undefined_list() is used by pass1() after a member is loaded from
 * an archive that satisifies an undefined symbol.  It is also called from
 * pass1() when it comes across a symbol on the undefined list that is no longer
 * undefined.
 */
__private_extern__
void
delete_from_undefined_list(
struct undefined_list *undefined)
{
	/* take this out of the list */
	undefined->prev->next = undefined->next;
	undefined->next->prev = undefined->prev;

	/* put this at the end of the free list */
	undefined->prev = free_list.prev;
	undefined->next = &free_list;
	free_list.prev->next = undefined;
	free_list.prev = undefined;
	undefined->merged_symbol = NULL;
}

/*
 * multiply_defined() prints and traces the multiply defined symbol if it hasn't
 * been printed yet.  It's slow with it linear searches and a reallocate() call
 * but this usually is an error case.
 */
static
void
multiply_defined(
struct merged_symbol *merged_symbol,
struct nlist *object_symbol,
char *object_strings)
{
    unsigned long i, j;

	if(allow_multiply_defined_symbols == TRUE && nowarnings == TRUE)
	    return;

	for(i = 0; i < nmultiple_defs; i++){
	    if(strcmp(multiple_defs[i], merged_symbol->nlist.n_un.n_name) == 0)
		break;
	}
	for(j = 0; j < ntrace_syms; j++){
	    if(strcmp(trace_syms[j], merged_symbol->nlist.n_un.n_name) == 0)
		break;
	}
	if(i == nmultiple_defs){
	    if(allow_multiply_defined_symbols == TRUE)
		warning("multiple definitions of symbol %s",
		      merged_symbol->nlist.n_un.n_name);
	    else{
		error("multiple definitions of symbol %s",
		      merged_symbol->nlist.n_un.n_name);
	    }
	    multiple_defs = reallocate(multiple_defs,
				       (nmultiple_defs + 1) * sizeof(char *));
	    multiple_defs[nmultiple_defs++] = merged_symbol->nlist.n_un.n_name;
	    if(j == ntrace_syms)
		trace_merged_symbol(merged_symbol);
	}
	if(j == ntrace_syms)
	    trace_object_symbol(object_symbol, object_strings);
}

/*
 * trace_object_symbol() traces a symbol that comes from an object file.
 */
static
void
trace_object_symbol(
struct nlist *symbol,
char *strings)
{
    char *indr_symbol_name;

	if(symbol->n_type == (N_INDR | N_EXT))
	    indr_symbol_name = strings + symbol->n_value;
	else
	    indr_symbol_name = "error in trace_symbol()";
	trace_symbol(strings + symbol->n_un.n_strx, symbol, cur_obj,
		     indr_symbol_name);
}

/*
 * trace_merged_symbol() traces a symbol that is in the merged symbol table.
 */
__private_extern__
void
trace_merged_symbol(
struct merged_symbol *merged_symbol)
{
    char *indr_symbol_name;

	if(merged_symbol->nlist.n_type == (N_INDR | N_EXT))
	    indr_symbol_name = ((struct merged_symbol *)
			(merged_symbol->nlist.n_value))->nlist.n_un.n_name;
	else
	    indr_symbol_name = "error in trace_symbol()";
	trace_symbol(merged_symbol->nlist.n_un.n_name, &(merged_symbol->nlist),
		     merged_symbol->definition_object, indr_symbol_name);
}

/*
 * trace_symbol() is the routine that really does the work of printing the
 * symbol its type and the file it is in.
 */
static
void
trace_symbol(
char *symbol_name,
struct nlist *nlist,
struct object_file *object_file,
char *indr_symbol_name)
{
	print_obj_name(object_file);
	if(nlist->n_type & N_PEXT)
	    print("private external ");
	switch(nlist->n_type & N_TYPE){
	case N_UNDF:
	    if(nlist->n_value == 0)
		print("%sreference to undefined %s\n",
		      nlist->n_desc & N_WEAK_REF ? "weak " : "", symbol_name);
	    else
		print("definition of common %s (size %u)\n", symbol_name,
		       nlist->n_value);
	    break;
	case N_PBUD:
	    print("%sdefinition of %s\n",
		  nlist->n_desc & N_WEAK_DEF ? "weak " : "", symbol_name);
	    break;
	case N_ABS:
	    print("definition of absolute %s (value 0x%x)\n", symbol_name,
		   (unsigned int)(nlist->n_value));
	    break;
	case N_SECT:
	    print("%sdefinition of %s in section (%.16s,%.16s)\n",
		  nlist->n_desc & N_WEAK_DEF ? "weak " : "", symbol_name,
		  object_file->section_maps[nlist->n_sect - 1].s->segname,
		  object_file->section_maps[nlist->n_sect - 1].s->sectname);
	    break;
	case N_INDR:
	    print("definition of %s as indirect for %s\n", symbol_name,
		   indr_symbol_name);
	    break;
	default:
	    print("unknown type (0x%x) of %s\n", (unsigned int)nlist->n_type,
		  symbol_name);
	    break;
	}
}

#ifndef RLD
/*
 * free_pass1_symbol_data() free()'s all symbol data only used in pass1().
 */
__private_extern__
void
free_pass1_symbol_data(void)
{
	free_undefined_list();
}
#endif /* !defined(RLD) */

/*
 * free_undefined_list() free's up the memory for the undefined list.
 */
__private_extern__
void
free_undefined_list(void)
{
    struct undefined_block *up, *undefined_block;
	/*
	 * Free the undefined list
	 */
	for(up = undefined_blocks; up; ){
	    undefined_block = up->next;
	    free(up);
	    up = undefined_block;
	}
	undefined_blocks = NULL;
	undefined_list.next = &undefined_list;
	undefined_list.prev = &undefined_list;
	free_list.next = &free_list;
	free_list.prev = &free_list;
}

/*
 * define_common_symbols() defines common symbols if there are any in the merged
 * symbol table.  The symbols are defined in the link editor reserved zero-fill
 * section (__DATA,__common) and the segment and section are created if needed.
 * The section is looked up to see it there is a section specification for it
 * and if so the same processing as in process_section_specs() is done here.
 * If there is a spec it uses the alignment if it is greater than the merged
 * alignment and warns if it is less.  Also it checks to make sure that no
 * section is to be created from a file for this reserved section.
 */
__private_extern__
void
define_common_symbols(void)
{
    struct section_spec *sect_spec;
    struct merged_section *ms;
    struct section *s;

    unsigned long i, j, common_size, align;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;
    struct common_symbol *common_symbol;

    struct object_list *object_list, **q;
    struct object_file *object_file;

    struct nlist *common_nlist;
    char *common_names;
    unsigned long n_strx;
#ifndef RLD
    struct mach_header *link_edit_common_object_mach_header;
#endif

#if defined(DEBUG) || defined(RLD)
	/*
	 * The compiler warning that these symbols may be used uninitialized
	 * in this function can safely be ignored.
	 */
	common_symbol = NULL;
	common_nlist = NULL;
	common_names = NULL;;
	n_strx = 0;
#endif

#ifdef RLD
	*(sets[cur_set].link_edit_common_object) =
		      link_edit_common_object;
	sets[cur_set].link_edit_common_object->set_num =
		      cur_set;
	sets[cur_set].link_edit_common_object->section_maps =
		      sets[cur_set].link_edit_section_maps;
	*(sets[cur_set].link_edit_section_maps) =
		      link_edit_section_maps;
	sets[cur_set].link_edit_section_maps->s =
		      sets[cur_set].link_edit_common_section;
	*(sets[cur_set].link_edit_common_section) =
		      link_edit_common_section;
#endif /* RLD */

#ifndef RLD
	/* see if there is a section spec for (__DATA,__common) */
	sect_spec = lookup_section_spec(SEG_DATA, SECT_COMMON);
	if(sect_spec != NULL){
	    if(sect_spec->contents_filename != NULL){
		error("section (" SEG_DATA "," SECT_COMMON ") reserved for "
		      "allocating common symbols and can't be created from the "
		      "file: %s", sect_spec->contents_filename);
		return;
	    }
	    sect_spec->processed = TRUE;
	}
#else
	sect_spec = NULL;
#endif /* !defined(RLD) */

	/* see if there is a merged section for (__DATA,__common) */
	ms = lookup_merged_section(SEG_DATA, SECT_COMMON);
	if(ms != NULL && (ms->s.flags & SECTION_TYPE) != S_ZEROFILL){
	    error("section (" SEG_DATA "," SECT_COMMON ") reserved for "
		  "allocating common symbols and exists in the loaded "
		  "objects not as a zero fill section");
	    /*
	     * Loop through all the objects and report those that have this
	     * section and then return.
	     */
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    object_file = &(object_list->object_files[i]);
		    if(object_file->dylib)
			continue;
		    if(object_file->bundle_loader)
			continue;
		    if(object_file->dylinker)
			continue;
		    for(j = 0; j < object_file->nsection_maps; j++){
			s = object_file->section_maps[j].s;
			if(strcmp(s->segname, SEG_DATA) == 0 &&
			   strcmp(s->sectname, SECT_COMMON) == 0){
			    print_obj_name(object_file);
			    print("contains section (" SEG_DATA ","
				   SECT_COMMON ")\n");
			}
		    }
		}
	    }
	    return;
	}
#ifndef RLD
	else{
	    /*
	     * This needs to be done here on the chance there is a common
	     * section but no commons get defined.  This is also done below
	     * if the common section is created.
	     */
	    if(sect_spec != NULL && sect_spec->order_filename != NULL &&
	       ms != NULL){
		ms->order_filename = sect_spec->order_filename;
		ms->order_addr = sect_spec->order_addr;
		ms->order_size = sect_spec->order_size;
	    }
	}
#endif /* !defined(RLD) */

	/*
	 * Determine if there are any commons to be defined if not just return.
	 * If a load map is requested then the number of commons to be defined
	 * is determined so a common load map can be allocated.
	 */
	commons_exist = FALSE;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if((merged_symbol->nlist.n_type & N_EXT) == N_EXT &&
		   (merged_symbol->nlist.n_type & N_TYPE) ==  N_UNDF &&
		   merged_symbol->nlist.n_value != 0){
		    /*
		     * If the output format is MH_FVMLIB then commons are not
		     * allowed because it there address may not remain fixed
		     * on sucessive link edits.  Each one is traced below.
		     */
		    if(filetype == MH_FVMLIB)
			error("common symbols not allowed with MH_FVMLIB "
			      "output format");
		    /*
		     * If the output format is multi module MH_DYLIB then			     * commons are not allowed because each symbol can only be
		     * defined in at most one module.
		     */
		    if(filetype == MH_DYLIB && multi_module_dylib == TRUE)
			error("common symbols not allowed with MH_DYLIB "
			      "output format with the -multi_module option");
		    commons_exist = TRUE;
#ifndef RLD
		    if((sect_spec != NULL &&
			sect_spec->order_filename != NULL) ||
		       dead_strip == TRUE){
			link_edit_common_symtab.nsyms++;
			link_edit_common_symtab.strsize +=
				   strlen(merged_symbol->nlist.n_un.n_name) + 1;
		    }
		    else if(load_map)
			common_load_map.ncommon_symbols++;
		    else
#endif /* !defined(RLD) */
			break;
		}
	    }
	}
	if(commons_exist == FALSE)
	    return;

	/*
	 * Now that the checks above have been done if commons are not to be
	 * defined just return.  If the output is for dyld then define common
	 * symbols always as dyld does not define commons.
	 */
	if(define_comldsyms == FALSE && output_for_dyld == FALSE)
	    return;

	/*
	 * Create the (__DATA,__common) section if needed and set the
	 * alignment for it.
	 */
	if(ms == NULL){
#ifdef RLD
	    ms = create_merged_section(sets[cur_set].link_edit_common_section);
#else
	    ms = create_merged_section(&link_edit_common_section);
#endif /* RLD */
	    if(sect_spec != NULL && sect_spec->align_specified)
		ms->s.align = sect_spec->align;
	    else
		ms->s.align = defaultsectalign;
	    if(sect_spec != NULL && sect_spec->order_filename != NULL){
		ms->order_filename = sect_spec->order_filename;
		ms->order_addr = sect_spec->order_addr;
		ms->order_size = sect_spec->order_size;
	    }
	}
	else{
	    if(sect_spec != NULL && sect_spec->align_specified){
		if(ms->s.align > sect_spec->align)
		    warning("specified alignment (0x%x) for section (" SEG_DATA
			    "," SECT_COMMON ") not used (less than the "
			    "required alignment in the input files (0x%x))",
			    (unsigned int)(1 << sect_spec->align),
			    (unsigned int)(1 << ms->s.align));
		else
		    ms->s.align = sect_spec->align;
	    }
	    if(ms->s.align < defaultsectalign)
		ms->s.align = defaultsectalign;
	}

#ifndef RLD
	/*
	 * If the common section has an order file then create a symbol table
	 * and string table for it and the load map will be generated off of
	 * these tables in layout_ordered_section() in sections.c.  If not and
	 * a load map is requested then set up the common load map.  This is
	 * used by print_load_map() in layout.c and the common_symbols allocated
	 * here are free()'ed in there also.
	 */
	if((sect_spec != NULL && sect_spec->order_filename != NULL) ||
	   dead_strip == TRUE){
	    link_edit_common_symtab.strsize =
			rnd(link_edit_common_symtab.strsize, sizeof(long));
	    link_edit_common_object.obj_size =
			sizeof(struct mach_header) +
			link_edit_common_symtab.nsyms * sizeof(struct nlist) +
			link_edit_common_symtab.strsize;
	    link_edit_common_object.obj_addr =
			allocate(link_edit_common_object.obj_size);
	    memset(link_edit_common_object.obj_addr,
		   '\0',
		   link_edit_common_object.obj_size);
	    link_edit_common_object_mach_header = (struct mach_header *)
			link_edit_common_object.obj_addr;
	    link_edit_common_object_mach_header->magic = MH_MAGIC;
	    link_edit_common_object_mach_header->filetype = MH_OBJECT;
	    link_edit_common_object_mach_header->flags =
		MH_SUBSECTIONS_VIA_SYMBOLS;
	    link_edit_common_symtab.symoff = sizeof(struct mach_header);
	    link_edit_common_symtab.stroff = sizeof(struct mach_header) +
					     link_edit_common_symtab.nsyms *
					     sizeof(struct nlist);
	    common_nlist = (struct nlist *)(link_edit_common_object.obj_addr +
			   		    link_edit_common_symtab.symoff);
	    common_names = (char *)(link_edit_common_object.obj_addr +
	    		            link_edit_common_symtab.stroff);
	    n_strx = 1;
	}
	else if(load_map){
	    common_load_map.common_ms = ms;
	    common_load_map.common_symbols = allocate(
					common_load_map.ncommon_symbols *
					sizeof(struct common_symbol));
	    common_symbol = common_load_map.common_symbols;
	}
#endif /* !defined(RLD) */

	/*
	 * Now define the commons.  This is requires building a "link editor"
	 * object file and changing these symbols to be defined in the (__DATA,
	 * __common) section in that "file".  By doing this in this way these
	 * symbols are handled normally throught the rest of the link editor.
	 * Also these symbols are trace as they are defined if they are to be
	 * traced.
	 */
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if((merged_symbol->nlist.n_type & N_EXT) == N_EXT &&
		   (merged_symbol->nlist.n_type & N_TYPE) ==  N_UNDF &&
		   merged_symbol->nlist.n_value != 0){
		    /*
		     * Commons are not allowed with MH_FVMLIB or MH_DYLIB
		     * formats so trace each one.  An error message for this
		     * has been printed above.
		     */
		    if(filetype == MH_FVMLIB ||
		       (filetype == MH_DYLIB && multi_module_dylib == TRUE))
			trace_merged_symbol(merged_symbol);
		    /* determine the alignment of this symbol */
		    common_size = merged_symbol->nlist.n_value;
		    align = 0;
		    while((unsigned long)(1 << align) < common_size &&
			  align < ms->s.align)
			align++;
		    /* round the address of the section to this alignment */
#ifdef RLD
		    sets[cur_set].link_edit_common_section->size = rnd(
		       sets[cur_set].link_edit_common_section->size, 1<< align);
#else
		    link_edit_common_section.size = rnd(
				link_edit_common_section.size, 1 << align);
#endif /* RLD */
		    /*
		     * Change this symbol's type, section number, address and
		     * object file it is defined in to be the (__DATA,__common)
		     * of the "link editor" object file at the address for it.
		     */
		    merged_symbol->nlist.n_type = N_SECT | N_EXT |
			(merged_symbol->nlist.n_type & N_PEXT);
		    merged_symbol->nlist.n_sect = 1;
#ifdef RLD
		    merged_symbol->nlist.n_value =
				   sets[cur_set].link_edit_common_section->size;
		    merged_symbol->definition_object =
				       sets[cur_set].link_edit_common_object;
		    /* Create the space for this symbol */
		    sets[cur_set].link_edit_common_section->size += common_size;
#else
		    merged_symbol->nlist.n_value =link_edit_common_section.size;
		    merged_symbol->definition_object =
						&link_edit_common_object;
		    /* Create the space for this symbol */
		    link_edit_common_section.size += common_size;
		    /*
		     * If we have an -export_symbols_list or
		     * -unexport_symbol_list option set the private extern bit
		     * on the symbol if it is not to be exported.
		     */
		    exports_list_processing(merged_symbol->nlist.n_un.n_name,
					    &(merged_symbol->nlist));
		    /*
		     * If this common symbol got made into a private extern with
		     * the processing of the exports list increment the count of
		     * private exterals.
		     */
		    if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT){
			link_edit_common_object.nprivatesym++;
			nmerged_private_symbols++;
		    }
#endif /* RLD */
		    /*
		     * Do the trace of this symbol if specified now that it has
		     * been defined.
		     */
		    if(ntrace_syms != 0){
			for(j = 0; j < ntrace_syms; j++){
			    if(strcmp(trace_syms[j],
				      merged_symbol->nlist.n_un.n_name) == 0){
				trace_merged_symbol(merged_symbol);
				break;
			    }
			}
		    }
#ifndef RLD
		    /*
		     * Set the entries in the common symbol table if the section
		     * is to be ordered or in the load map if producing it
		     */
		    if((sect_spec != NULL &&
			sect_spec->order_filename != NULL) ||
	   		dead_strip == TRUE){
			common_nlist->n_un.n_strx = n_strx;
			common_nlist->n_type = N_SECT | N_EXT;
			common_nlist->n_sect = 1;
			common_nlist->n_desc = 0;
			common_nlist->n_value = merged_symbol->nlist.n_value;
			strcpy(common_names + n_strx,
			       merged_symbol->nlist.n_un.n_name);
			common_nlist++;
			n_strx += strlen(merged_symbol->nlist.n_un.n_name) + 1;
		    }
		    else if(load_map){
			common_symbol->merged_symbol = merged_symbol;
			common_symbol->common_size = common_size;
			common_symbol++;
		    }
#endif /* !defined(RLD) */
		}
	    }
	}

	/*
	 * Now that this section in this "object file" is built merged it into
	 * the merged section list (as would be done in merge_sections()).
	 */
#ifdef RLD
	sets[cur_set].link_edit_common_object->section_maps[0].output_section =
									     ms;
	ms->s.size = rnd(ms->s.size, 1 << ms->s.align);
	sets[cur_set].link_edit_common_object->section_maps[0].offset =
								     ms->s.size;
	ms->s.size += sets[cur_set].link_edit_common_section->size;
#else
	link_edit_common_object.section_maps[0].output_section = ms;
	ms->s.size = rnd(ms->s.size, 1 << ms->s.align);
	link_edit_common_object.section_maps[0].offset = ms->s.size;
	ms->s.size += link_edit_common_section.size;
#endif /* RLD */
}

#ifndef RLD
/*
 * define_undefined_symbols_a_way() is called to setup defining all remaining
 * undefined symbols as private externs.  Their final value gets set by
 * define_link_editor_dylib_symbols().
 */
__private_extern__
void
define_undefined_symbols_a_way(
void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
		   merged_symbol->nlist.n_value == 0){
		    if(dynamic == TRUE &&
		       filetype != MH_EXECUTE &&
		       merged_segments != NULL){
			define_link_editor_symbol(
				      merged_symbol->nlist.n_un.n_name,
				      N_SECT | N_PEXT | N_EXT,	/* n_type */
				      1,			/* n_sect */
				      0,			/* n_desc */
				      0);			/* n_value */
		    }
		    else{
			define_link_editor_symbol(
				      merged_symbol->nlist.n_un.n_name,
				      N_ABS | N_PEXT | N_EXT,	/* n_type */
				      NO_SECT,			/* n_sect */
				      0,			/* n_desc */
				      0);			/* n_value */
		    }
		    /*
		     * This symbol got made into a private extern so increment
		     * the count of private exterals.
		     */
		    if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT){
			link_edit_symbols_object->nprivatesym++;
			nmerged_private_symbols++;
		    }
		    merged_symbol->define_a_way = 1;
		}
	    }
	}
}

static
void
setup_link_edit_symbols_object(
void)
{
	if(link_edit_symbols_object == NULL){
	    link_edit_symbols_object = new_object_file();
	    link_edit_symbols_object->file_name = "link editor";
	}
}

#ifndef RLD
/*
 * mark_globals_live() marks all merged symbol definitions which will be global
 * in the output (not private externs turned into statics) or symbols with the
 * N_NO_DEAD_STRIP bit, or symbols in sections with the S_ATTR_NO_DEAD_STRIP
 * section attribute live.  And marks the fine_reloc (if any) for each live
 * symbol live.
 */
__private_extern__
void
mark_globals_live(void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;
    enum bool only_referenced_dynamically;

	/*
	 * If the output is an MH_EXECUTE and there was no
	 * -exported_symbols_list or -unexported_symbols_list only symbols that
	 * are referenced dynamically are marked live and assumed to be
	 * exported.  For other outputs formats all global symbols are marked
	 * live (note that when symbols were merged the were turned into private
	 * externs if they were not to be exported).
	 */
	if(filetype == MH_EXECUTE &&
	   (save_symbols == NULL && remove_symbols == NULL))
	    only_referenced_dynamically = TRUE;
	else
	    only_referenced_dynamically = FALSE;

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		/*
		 * If the symbol is marked REFERENCED_DYNAMICALLY or
		 * N_NO_DEAD_STRIP or defined in a section with the attribute
		 * S_ATTR_NO_DEAD_STRIP mark it live.  Else it has to be
		 * a defined exported symbol to be marked live.
		 */
		if((merged_symbol->nlist.n_desc &
		    REFERENCED_DYNAMICALLY) == REFERENCED_DYNAMICALLY ||

		   (merged_symbol->nlist.n_desc &
		    N_NO_DEAD_STRIP) == N_NO_DEAD_STRIP ||

		   (((merged_symbol->nlist.n_type & N_TYPE) == N_SECT) &&
		    (merged_symbol->definition_object->
		     section_maps[merged_symbol->nlist.n_sect - 1].s->flags &
		     S_ATTR_NO_DEAD_STRIP) == S_ATTR_NO_DEAD_STRIP) ){
		    goto mark_it_live;
		}
		else{
		    /*
		     * Skip symbols defined in dynamic libraries, undefined
		     * symbols and private_extern symbols.
		     */
		    if(merged_symbol->defined_in_dylib == TRUE)
			continue;
		    if((merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
			merged_symbol->nlist.n_value == 0) ||
		       merged_symbol->nlist.n_type == (N_EXT | N_PBUD))
			continue;
		    if((merged_symbol->nlist.n_type & N_EXT) &&
		       (merged_symbol->nlist.n_type & N_PEXT))
			continue;
		    if(only_referenced_dynamically == TRUE)
			continue;
		}
#ifdef DEBUG
mark_it_live:
		if(((debug & (1 << 25)) || (debug & (1 << 26)))){
		    print("** In mark_globals_live() ");
		    if(merged_symbol->nlist.n_desc & N_NO_DEAD_STRIP)
			print("no dead strip symbol ");
		    else
			print("exported symbol ");
		    print_obj_name(merged_symbol->definition_object);
		    print("%s\n", merged_symbol->nlist.n_un.n_name);
		}
#endif /* DEBUG */
		merged_symbol->live = TRUE;
		if(merged_symbol->fine_reloc != NULL)
		    merged_symbol->fine_reloc->live = TRUE;
	    }
	}
}

/*
 * mark_N_NO_DEAD_STRIP_local_symbols_live() is called to cause the fine_relocs
 * for local symbols that have the N_NO_DEAD_STRIP bit set to be marked live.
 */
__private_extern__
void
mark_N_NO_DEAD_STRIP_local_symbols_live(void)
{
    struct merged_segment *msg, **r;
    struct merged_section *ms, **content, **zerofill;

	/*
	 * In merged_symbols() this gets set to TRUE if there were any local
	 * symbols with the N_NO_DEAD_STRIP set.  If not we don't need to do
	 * anything here.
	 */
	if(local_NO_DEAD_STRIP_symbols == FALSE)
	    return;

	r = &merged_segments;
	while(*r){
	    msg = *r;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		mark_N_NO_DEAD_STRIP_local_symbols_in_section_live(ms);
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		mark_N_NO_DEAD_STRIP_local_symbols_in_section_live(ms);
		zerofill = &(ms->next);
	    }
	    r = &(msg->next);
	}
}

/*
 * mark_N_NO_DEAD_STRIP_local_symbols_in_section_live() for the specified
 * merged section marks fine_relocs for local symbols that have the
 * N_NO_DEAD_STRIP bit set live.
 */
static
void
mark_N_NO_DEAD_STRIP_local_symbols_in_section_live(
struct merged_section *ms)
{
    unsigned long i, j, k, nsect, input_offset;
    struct object_list *object_list, **q;
    struct section_map *map;
    struct nlist *object_symbols;
    char *object_strings;
    struct fine_reloc *fine_reloc;

	/*
	 * For each object file that has this section process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		map = NULL;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(cur_obj->section_maps[j].output_section != ms)
			continue;
		    if(cur_obj->section_maps[j].s->size == 0)
			continue;
		    map = &(cur_obj->section_maps[j]);
		    break;
		}
		if(map == NULL)
		    continue;
		object_symbols = NULL;
		object_strings = NULL;
		if(cur_obj->symtab != NULL){
		    object_symbols = (struct nlist *)(cur_obj->obj_addr +
						      cur_obj->symtab->symoff);
		    object_strings = (char *)(cur_obj->obj_addr +
					      cur_obj->symtab->stroff);
		}
		nsect = j + 1;
		/*
		 * Now look through the symbol table for local symbols in this
		 * section that are marked with the N_NO_DEAD_STRIP bit.
		 */
		for(k = 0; k < cur_obj->symtab->nsyms; k++){
		    if((object_symbols[k].n_type & N_EXT) == 0 &&
		       (object_symbols[k].n_type & N_TYPE) == N_SECT &&
		       (object_symbols[k].n_type & N_STAB) == 0 &&
		       object_symbols[k].n_sect == nsect &&
		       object_symbols[k].n_desc & N_NO_DEAD_STRIP){
			input_offset = object_symbols[k].n_value - map->s->addr;
			fine_reloc = fine_reloc_for_input_offset(
			    map, input_offset);
			fine_reloc->live = TRUE;
		    }
		}
	    }
	}
}

/*
 * set_fine_relocs_for_merged_symbols() is called when -dead_strip is specified
 * to set the fine_reloc field of the merged symbols.  Most of these are set
 * in layout_ordered_section() but when a section from an object is linked
 * as one block they are not set.  So this is done here.
 */
__private_extern__
void
set_fine_relocs_for_merged_symbols(void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		/*
		 * Skip symbols that have already had there fine_reloc set which
		 * happens if the block was created using symbol's addresses.
		 */
		if(merged_symbol->fine_reloc != NULL)
		    continue;
		/*
		 * If this symbol is defined in a dylib or undefined then
		 * it will not have a fine_reloc block.
		 */
		if(merged_symbol->defined_in_dylib == TRUE ||
		   merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
		   (merged_symbol->nlist.n_type & N_TYPE) == N_PBUD)
		    continue;
		/*
		 * Skip symbols only referenced from dynamic libraries.
		 */
		if(merged_symbol->referenced_in_non_dylib == FALSE)
		    continue;

		/*
		 * The remaining symbols might be in a fine_reloc so set it
		 * up if it has one (note this still maybe NULL).
		 */
		merged_symbol->fine_reloc = get_fine_reloc_for_merged_symbol(
						merged_symbol, NULL);

	    }
	}
}

/*
 * count_live_symbols() is called when -dead_strip is specified after things
 * have been marked live.  It adjust the counts and reference maps of symbols
 * to account for just the live symbols.
 */
__private_extern__
void
count_live_symbols(void)
{
    unsigned long i, j, nrefsym;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;
    struct object_list *object_list, **q;
    struct object_file *obj;
    struct merged_segment *msg, **r;
    struct merged_section *ms, **content, **zerofill;

	/*
	 * In order to not put out strings for merged symbols that are not live
	 * we need to rebuild the merged string table for only the live symbols.
	 * This is done by resetting these two variables and recalling
	 * enter_string() on the live symbols.
	 */
	merged_string_blocks = NULL;
	merged_string_size = 0;

	/*
	 * The value of nstripped_merged_symbols is incremented here for each
	 * merged symbol that would have been in the output but is not live.
	 * Note: nstripped_merged_symbols can be reset to zero later in
	 * assign_output_symbol_indexes() if strip_level is set to
	 * STRIP_DYNAMIC_EXECUTABLE.  This works since any symbol to be
	 * saved with STRIP_DYNAMIC_EXECUTABLE would also be live since
	 * it would have REFERENCED_DYNAMICALLY set.
	 */
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		/*
		 * Because a live fine_reloc's could have multiple global
		 * symbols, we need to check all global symbols to see if they
		 * are in a live block.  And if so mark the global symbol live.
		 */
		if(merged_symbol->live == FALSE){
		    if(merged_symbol->fine_reloc != NULL &&
		       merged_symbol->fine_reloc->live == TRUE)
			merged_symbol->live = TRUE;
		}
		/*
		 * Skip symbols only referenced from dynamic libraries.
		 */
		if(merged_symbol->referenced_in_non_dylib == FALSE)
		    continue;
		if(merged_symbol->live == TRUE){
		    merged_symbol->nlist.n_un.n_name =
			enter_string(merged_symbol->nlist.n_un.n_name, NULL);
		}
		else{
		    /*
		     * This symbol is not live so account for it the number of
		     * stripped merged symbols.
		     */
		    nstripped_merged_symbols++;
/*
printf("count_live_symbols() nstripped_merged_symbols %s\n", merged_symbol->nlist.n_un.n_name);
*/

		    /*
		     * If this symbol is defined in a dylib or undefined then
		     * we are done accounting for it being stripped.
		     */
		    if(merged_symbol->defined_in_dylib == TRUE ||
		       merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
                       (merged_symbol->nlist.n_type & N_TYPE) == N_PBUD)
			continue;
		    /*
		     * This symbol was defined in the .o files so adjust the
		     * counts in the object_file struct.
		     */

		    /*
		     * If this is a private symbol adjust the count of
		     * private symbols in this object.  Also increment the
		     * file level static variable for the number of private
		     * merged symbols that are being stripped so later
		     * assign_output_symbol_indexes() can use its value do its
		     * consistency check.
		     */
		    if(merged_symbol->nlist.n_type & N_PEXT){
			merged_symbol->definition_object->nprivatesym--;
			nstripped_merged_private_symbols++;
/*
printf("count_live_symbols() nstripped_merged_private_symbols %s\n", merged_symbol->nlist.n_un.n_name);
*/
		    }
		    /*
		     * This symbol is defined in the .o file and not a
		     * private symbol, so if we are creating a multi-module
		     * dylib this files to adjust the count of the defined
		     * externals in this object.
		     */
		    else if(filetype == MH_DYLIB &&
			    multi_module_dylib == TRUE)
			merged_symbol->definition_object->nextdefsym--;
		}
	    }
	}

	/*
	 * If we are creating a multi-module dylib then we need to update the
	 * reference table and the number of references for each object to only
	 * contain live symbols.
	 */
	output_dysymtab_info.dysymtab_command.nextrefsyms = 0;
	if(filetype == MH_DYLIB && multi_module_dylib == TRUE){
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    obj = &(object_list->object_files[i]);
		    if(obj->dylib)
			continue;
		    if(obj->bundle_loader)
			continue;
		    if(obj->dylinker)
			continue;
		    nrefsym = 0;
		    for(j = 0; j < obj->nrefsym; j++){
			if(obj->reference_maps[j].merged_symbol->live){
			    obj->reference_maps[nrefsym] =
				obj->reference_maps[j];
			    nrefsym++;
			}
		    }
		    obj->nrefsym = nrefsym;
		    if(nrefsym != 0)
			obj->irefsym =
			    output_dysymtab_info.dysymtab_command.nextrefsyms;
		    output_dysymtab_info.dysymtab_command.nextrefsyms +=
			nrefsym;
		}
	    }
	}

	/*
	 * To get the global variable nlocal_symbols and the nlocal_symbols
	 * field in the object_file structs adjusted to include just live
	 * symbols call removed_dead_local_symbols_in_section() which will call
	 * discard_local_symbols_for_section() for each section in each object.
	 */
	r = &merged_segments;
	while(*r){
	    msg = *r;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		removed_dead_local_symbols_in_section(ms);
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		removed_dead_local_symbols_in_section(ms);
		zerofill = &(ms->next);
	    }
	    r = &(msg->next);
	}

	/*
 	 * Call remove_dead_N_GSYM_stabs() to get rid of dead N_GSYM stabs.
	 * For common symbols this has to be done as they are not defined or
 	 * in a section and so they can't be bracked by N_BNSYM/N_ENSYM stabs.
	 */
	remove_dead_N_GSYM_stabs();
}

/*
 * removed_dead_local_symbols_in_section() is pass a pointer to a merged section
 * and then calls discard_local_symbols_for_section() for each object with that
 * section to get the global variable nlocal_symbols and the nlocal_symbols
 * field in the object_file structs adjusted to include just live symbols.
 */
static
void
removed_dead_local_symbols_in_section(
struct merged_section *ms)
{
    unsigned long i, j;
    struct object_list *object_list, **q;
    struct section_map *map;
    struct nlist *object_symbols;
    char *object_strings;

	/*
	 * For each object file that has this section process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		map = NULL;
		for(j = 0; j < cur_obj->nsection_maps; j++){
		    if(cur_obj->section_maps[j].output_section != ms)
			continue;
		    if(cur_obj->section_maps[j].s->size == 0)
			continue;
		    map = &(cur_obj->section_maps[j]);
		    break;
		}
		if(map == NULL)
		    continue;
		object_symbols = NULL;
		object_strings = NULL;
		if(cur_obj->symtab != NULL){
		    object_symbols = (struct nlist *)(cur_obj->obj_addr +
						      cur_obj->symtab->symoff);
		    object_strings = (char *)(cur_obj->obj_addr +
					      cur_obj->symtab->stroff);
		}
		discard_local_symbols_for_section(j + 1,
		    object_symbols, object_strings,
		    cur_obj->section_maps[j].s, map);
	    }
	}
}

/*
 * remove_dead_N_GSYM_stabs() is used by count_live_symbols() when -dead_strip
 * is specified to get rid of dead N_GSYM stabs.  For common symbols this has
 * to be done as they are not defined or in a section and so they can't be
 * bracked by N_BNSYM/N_ENSYM stabs.
 */
static
void
remove_dead_N_GSYM_stabs(
void)
{
    unsigned long i;
    struct object_list *object_list, **q;
    struct nlist *object_symbols;
    char *object_strings;

	/*
	 * For each object that has symbols process it.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj == base_obj)
		    continue;
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
		if(cur_obj->symtab != NULL){
		    object_symbols = (struct nlist *)(cur_obj->obj_addr +
						      cur_obj->symtab->symoff);
		    object_strings = (char *)(cur_obj->obj_addr +
					      cur_obj->symtab->stroff);
		    remove_dead_N_GSYM_stabs_for_cur_obj(object_symbols,
			object_strings);

		}
	    }
	}
}
#endif /* !defined(RLD) */

/*
 * define_link_editor_execute_symbols() is called when the output file type is
 * MH_EXECUTE and it sets the address of the loader defined symbols for this
 * file type.  For the MH_EXECUTE file type there are two loader defined symbols
 * which are the address of the header.  Since these symbols are not in a 
 * section (it is before the first section) they are absolute symbols.
 */
__private_extern__
void
define_link_editor_execute_symbols(
unsigned long header_address)
{
    struct merged_symbol *merged_symbol;

	/* look up the first symbol to see if it is present */
	merged_symbol = lookup_symbol(_MH_EXECUTE_SYM);
	/* if it is present set it's correct value */
	if(merged_symbol->name_len != 0)
	    merged_symbol->nlist.n_value = header_address;

	/* look up the second symbol to see if it is present */
	merged_symbol = lookup_symbol("___dso_handle");
	/* if it is present set it's correct value */
	if(merged_symbol->name_len != 0)
	    merged_symbol->nlist.n_value = header_address;
}

#ifndef RLD
/*
 * setup_link_editor_symbols() is called when the output file type can be an
 * output for dyld and it sets up the loader defined symbols for the file
 * type. These symbols have to be set up (defined and made a private extern)
 * before their real addresses are known so that the dylib tables and the
 * relocation entries can be laied out.  For the MH_DYLIB, MH_BUNDLE and
 * MH_DYLINKER file types the loader defined symbols, which is the address of
 * the header, must be relative to the sections even thought it is not in a
 * section (it is before the first section).  So it is set as the an address
 * relative to the first section.  This is done since these output files can be
 * slid by the dynamic link editor.  Also for these file types the symbol is
 * also made a private extern.
 */
__private_extern__
void
setup_link_editor_symbols(
void)
{
	if(filetype == MH_EXECUTE){
	    setup_link_editor_symbol(_MH_EXECUTE_SYM);
	    setup_link_editor_symbol("___dso_handle");
	}
	else if(filetype == MH_BUNDLE){
	    setup_link_editor_symbol(_MH_BUNDLE_SYM);
	    setup_link_editor_symbol("___dso_handle");
	}
	else if(filetype == MH_DYLIB){
	    setup_link_editor_symbol(_MH_DYLIB_SYM);
	    setup_link_editor_symbol("___dso_handle");
	}
	else{ /* filetype == MH_DYLINKER */
	    setup_link_editor_symbol(_MH_DYLINKER_SYM);
	    setup_link_editor_symbol("___dso_handle");
	}
}

/*
 * setup_link_editor_symbol() does the real work of setting up a single loader
 * defined symbol for the name passed to it.
 */ 
static
void
setup_link_editor_symbol(
char *symbol_name)
{
    struct merged_symbol *merged_symbol;
    unsigned long nsects, i, j, n;
    struct section *sections;
    struct section_map *section_maps;
    struct merged_segment **p, *msg;
    struct merged_section **q, *ms;

	/* look up the symbol to see if it is present */
	merged_symbol = lookup_symbol(symbol_name);
	/* if it is not present just return */
	if(merged_symbol->name_len == 0)
	    return;
	/*
	 * For MH_BUNDLE files we need to special case the handling of the
	 * link editor defined symbol ___dso_handle since it is allowed to
	 * be defined in the -bundle_loader file.  But it may not referenced
	 * from any of the the objects being linked.  In this case we treat it
	 * like the symbol is not present and just return.
	 */
	if(filetype == MH_BUNDLE &&
	   strcmp(symbol_name, "___dso_handle") == 0 &&
	   merged_symbol->definition_object->bundle_loader == TRUE &&
	   merged_symbol->non_dylib_referenced_obj == NULL)
	    return;

	/*
	 * For MH_EXECUTE file types the symbol is always absolute so just
	 * defined it with a value of zero for now.
	 */
	if(filetype == MH_EXECUTE){
	    define_link_editor_symbol(symbol_name, N_EXT | N_ABS, NO_SECT,
		merged_symbol->nlist.n_desc & REFERENCED_DYNAMICALLY, 0);
	    return;
	}

	/*
	 * For the MH_DYLIB, MH_BUNDLE and MH_DYLINKER file types set up the
	 * defining object file with the correct values for defining one more
	 * private external symbol.
	 */
	setup_link_edit_symbols_object();
	n = link_edit_symbols_object->nprivatesym;
	link_edit_symbols_object->nprivatesym += 1;
	nmerged_private_symbols++;

	link_edit_symbols_object->nrefsym += 1;
	if(n == 0)
	    link_edit_symbols_object->irefsym =
		    output_dysymtab_info.dysymtab_command.nextrefsyms;
	if(filetype == MH_DYLIB)
	    output_dysymtab_info.dysymtab_command.nextrefsyms += 1;
	link_edit_symbols_object->reference_maps =
	    reallocate(link_edit_symbols_object->reference_maps,
		       sizeof(struct reference_map) * (n + 1));
	link_edit_symbols_object->reference_maps[n].flags =
	    REFERENCE_FLAG_PRIVATE_DEFINED;
	link_edit_symbols_object->reference_maps[n].merged_symbol =
	    merged_symbol;

	/* count the number of merged sections */
	nsects = 0;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    nsects += msg->sg.nsects;
	    p = &(msg->next);
	}

	if(nsects > 0 && link_edit_symbols_object->nsection_maps == 0){
	    /*
	     * Create the sections and section maps for the sections in the
	     * "link editor" object file.  To make it easy all merged sections
	     * will be in this object file.  The addr in all of the sections
	     * and the offset in all the maps will be zero so that
	     * layout_symbols() will set the final value of these symbols
	     * to their correct location in the output file.
	     */
	    sections = allocate(nsects * sizeof(struct section));
	    memset(sections, '\0', nsects * sizeof(struct section));
	    section_maps = allocate(nsects * sizeof(struct section_map));
	    memset(section_maps, '\0', nsects * sizeof(struct section_map));
	    setup_link_edit_symbols_object();
	    link_edit_symbols_object->nsection_maps = nsects;
	    link_edit_symbols_object->section_maps = section_maps;

	    i = 0;
	    p = &merged_segments;
	    while(*p){
		msg = *p;
		for(j = 0; j < 2 ; j++){
		    if(j == 0)
			/* process the content sections */
			q = &(msg->content_sections);
		    else
			/* process the zerofill sections */
			q = &(msg->zerofill_sections);
		    while(*q){
			ms = *q;
			/* create the section and map for this section */
			strncpy(sections[i].sectname, ms->s.sectname,
				sizeof(ms->s.sectname));
			strncpy(sections[i].segname, ms->s.segname,
				sizeof(ms->s.segname));
			section_maps[i].s = &(sections[i]);
			section_maps[i].output_section = ms;
			i++;
			q = &(ms->next);
		    }
		}
		p = &(msg->next);
	    }
	}
	if(nsects > 0)
	    define_link_editor_symbol(symbol_name, N_SECT | N_PEXT | N_EXT,
		1, merged_symbol->nlist.n_desc & REFERENCED_DYNAMICALLY, 0);
	else
	    define_link_editor_symbol(symbol_name, N_ABS | N_PEXT | N_EXT,
	      NO_SECT, merged_symbol->nlist.n_desc & REFERENCED_DYNAMICALLY, 0);
}

/*
 * define_link_editor_dylib_symbols() is called when the output file type is
 * MH_DYLIB, MH_BUNDLE or MH_DYLINKER and it defines the loader defined symbols
 * for these file types.  This routine actually sets the value of the symbols
 * where as the above routine defines the symbol. For these file types there are
 * two loader defined symbols which are the address of the header.  Since these
 * output files can be slid this symbol must be relative to the sections even
 * thought it is not in a section (it is before the first section) it is set as
 * the an address relative to the first section.  This symbol is also a private 
 * extern. This routine also sets the define_a_way symbols to their final value.
 */
__private_extern__
void
define_link_editor_dylib_symbols(
unsigned long header_address)
{
    struct merged_symbol *merged_symbol;
    struct merged_symbol_list *merged_symbol_list;
    unsigned long i;

	if(filetype == MH_BUNDLE)
	    define_link_editor_dylib_symbol(header_address, _MH_BUNDLE_SYM);
	else if(filetype == MH_DYLIB)
	    define_link_editor_dylib_symbol(header_address, _MH_DYLIB_SYM);
	else /* filetype == MH_DYLINKER */
	    define_link_editor_dylib_symbol(header_address, _MH_DYLINKER_SYM);
	define_link_editor_dylib_symbol(header_address, "___dso_handle");

	/* set the correct values of the undefined symbols defined a way */
	if(undefined_flag == UNDEFINED_DEFINE_A_WAY){
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				     merged_symbol_root->list;
		merged_symbol_list != NULL;
		merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if(merged_symbol->define_a_way == 1){
			if(merged_symbol->nlist.n_sect == NO_SECT)
			    merged_symbol->nlist.n_value = header_address;
			else
			    merged_symbol->nlist.n_value = header_address -
			       link_edit_symbols_object->section_maps[0].
				    output_section->s.addr;
		    }
		}
	    }
	}
}

/*
 * define_link_editor_dylib_symbol() does the real work of setting the address
 * of the loader defined symbols for filetypes that can be slid.
 */
static
void
define_link_editor_dylib_symbol(
unsigned long header_address,
char *symbol_name)
{
    struct merged_symbol *merged_symbol;

	/* look up the symbol to see if it is present */
	merged_symbol = lookup_symbol(symbol_name);

	/* if it is not present just return */
	if(merged_symbol->name_len == 0)
	    return;

	/* set it's correct value */
	if(merged_symbol->nlist.n_sect == NO_SECT)
	    merged_symbol->nlist.n_value = header_address;
	else
	    merged_symbol->nlist.n_value = header_address -
	       link_edit_symbols_object->section_maps[0].output_section->s.addr;

}
#endif /* !defined(RLD) */

/*
 * define_link_editor_preload_symbols() is called when the output file type is
 * MH_PRELOAD and it defines the loader defined symbols for this file type.
 * For the MH_PRELOAD file type there are loader defined symbols for the
 * beginning and ending of each segment and section.  Their names are of the
 * form: <segname>{,<sectname>}{__begin,__end} .  They are N_SECT symbols for
 * the closest section they belong to (in some cases the *__end symbols will
 * be outside the section).
 */
__private_extern__
void
define_link_editor_preload_symbols(
enum bool setup)
{
    unsigned long nsects, i, j, first_section;
    struct section *sections;
    struct section_map *section_maps;
    struct merged_segment **p, *msg;
    struct merged_section **q, *ms;
    struct merged_symbol *merged_symbol;
    char symbol_name[sizeof(ms->s.segname) + sizeof(ms->s.sectname) +
		     sizeof("__begin")];

	sections = NULL;
	section_maps = NULL;
	if(setup == TRUE){
	    /* count the number of merged sections */
	    nsects = 0;
	    p = &merged_segments;
	    while(*p){
		msg = *p;
		nsects += msg->sg.nsects;
		p = &(msg->next);
	    }

	    /*
	     * Create the sections and section maps for the sections in the
	     * "link editor" object file.  To make it easy all merged sections
	     * will be in this object file.  The addr in all of the sections
	     * and the offset in all the maps will be zero so that
	     * layout_symbols() will set the final value of these symbols
	     * to their correct location in the output file.
	     */
	    sections = allocate(nsects * sizeof(struct section));
	    memset(sections, '\0', nsects * sizeof(struct section));
	    section_maps = allocate(nsects * sizeof(struct section_map));
	    memset(section_maps, '\0', nsects * sizeof(struct section_map));
	    setup_link_edit_symbols_object();
	    link_edit_symbols_object->nsection_maps = nsects;
	    link_edit_symbols_object->section_maps = section_maps;
	}

	i = 0;
	p = &merged_segments;
	while(*p){
	    msg = *p;
	    /* create the symbol for the beginning of the segment */
	    strncpy(symbol_name, msg->sg.segname, sizeof(msg->sg.segname));
	    strcat(symbol_name, "__begin");
	    if(setup == TRUE)
		define_link_editor_symbol(symbol_name, N_EXT | N_SECT, i+1,0,0);
	    first_section = i + 1;
	    for(j = 0; j < 2 ; j++){
		if(j == 0)
		    /* process the content sections */
		    q = &(msg->content_sections);
		else
		    /* process the zerofill sections */
		    q = &(msg->zerofill_sections);
		while(*q){
		    ms = *q;
		    /* create the section and map for this section */
		    if(setup == TRUE){
			strncpy(sections[i].sectname, ms->s.sectname,
				sizeof(ms->s.sectname));
			strncpy(sections[i].segname, ms->s.segname,
				sizeof(ms->s.segname));
			section_maps[i].s = &(sections[i]);
			section_maps[i].output_section = ms;
		    }
		    /* create the symbol for the beginning of the section */
		    strncpy(symbol_name, ms->s.segname,
			    sizeof(ms->s.segname));
		    strncat(symbol_name, ms->s.sectname,
			    sizeof(ms->s.sectname));
		    strcat(symbol_name, "__begin");
		    if(setup == TRUE)
			define_link_editor_symbol(symbol_name, N_EXT | N_SECT,
						  i+1, 0, 0);
		    /* create the symbol for the end of the section */
		    strncpy(symbol_name, ms->s.segname,
			    sizeof(ms->s.segname));
		    strncat(symbol_name, ms->s.sectname,
			    sizeof(ms->s.sectname));
		    strcat(symbol_name, "__end");
		    if(setup)
			define_link_editor_symbol(symbol_name, N_EXT | N_SECT,
						  i+1, 0, 0);
		    else{
			merged_symbol = lookup_symbol(symbol_name);
			if(merged_symbol->name_len != 0)
			    merged_symbol->nlist.n_value = ms->s.size;
		    }
		    i++;
		    q = &(ms->next);
		}
	    }

	    /* create the symbol for the end of the segment */
	    strncpy(symbol_name, msg->sg.segname,
		    sizeof(msg->sg.segname));
	    strcat(symbol_name, "__end");
	    if(setup)
		define_link_editor_symbol(symbol_name, N_EXT | N_SECT,
					  first_section, 0, 0);
	    else{
		merged_symbol = lookup_symbol(symbol_name);
		if(merged_symbol->name_len != 0)
		    merged_symbol->nlist.n_value = msg->sg.vmsize;
	    }
	    p = &(msg->next);
	}
}

/*
 * define_link_editor_symbol() is passed then name of a link editor defined
 * symbol and the information to define it.  If this symbol exist it must be
 * undefined or it is an error.  If it exist and link editor defined symbols
 * are being defined it is defined using the information passed to it.
 */
static
void
define_link_editor_symbol(
char *symbol_name,
unsigned char type,
unsigned char sect,
short desc,
unsigned long value)
{
    unsigned long i;
    struct merged_symbol *merged_symbol;

	/* look up the symbol to see if it is present */
	merged_symbol = lookup_symbol(symbol_name);
	/* if it is not present just return */
	if(merged_symbol->name_len == 0)
	    return;
	/*
	 * The symbol is present and must be undefined unless it is defined
	 * in the base file of an incremental link or in the -bundle_loader
	 * file (for the case of the ___dso_handle symbol).
	 */
	if((merged_symbol->nlist.n_type & N_EXT) != N_EXT ||
	   (merged_symbol->nlist.n_type & N_TYPE) != N_UNDF ||
	   merged_symbol->nlist.n_value != 0){
	    if(merged_symbol->definition_object != base_obj &&
	       merged_symbol->definition_object->bundle_loader == FALSE){
		error("loaded objects attempt to redefine link editor "
		      "defined symbol %s", symbol_name);
		trace_merged_symbol(merged_symbol);
		return;
	    }
	}

	/*
	 * Now that the checks above have been done if link editor defined
	 * symbols are not to be defined just return.
	 */
	if(define_comldsyms == FALSE)
	    return;

	/* define this symbol */
	setup_link_edit_symbols_object();
	merged_symbol->nlist.n_type = type;
	merged_symbol->nlist.n_sect = sect;
	merged_symbol->nlist.n_desc = desc;
	merged_symbol->nlist.n_value = value;
	merged_symbol->definition_object = link_edit_symbols_object;

#ifndef RLD
	/*
	 * If this symbol is already a private extern then it does not get
	 * processed with the export lists.
	 */
	if((merged_symbol->nlist.n_type & N_PEXT) != N_PEXT){
	    /*
	     * If we have an -export_symbols_list or
	     * -unexport_symbol_list option set the private extern bit
	     * on the symbol if it is not to be exported.
	     */
	    exports_list_processing(merged_symbol->nlist.n_un.n_name,
				    &(merged_symbol->nlist));
	    /*
	     * If this symbol got made into a private extern with the processing
	     * of the exports list increment the count of private exterals.
	     */
	    if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT){
		merged_symbol->definition_object->nprivatesym++;
		nmerged_private_symbols++;
	    }
	}
#endif

	/*
	 * Do the trace of this symbol if specified now that it has
	 * been defined.
	 */
	if(ntrace_syms != 0){
	    for(i = 0; i < ntrace_syms; i++){
		if(strcmp(trace_syms[i], symbol_name) == 0){
		    trace_merged_symbol(merged_symbol);
		    break;
		}
	    }
	}
}
#endif /* !defined(RLD) */

/*
 * reduce_indr_symbols() reduces indirect symbol chains to have all the indirect
 * symbols point at their leaf symbol.  Also catch loops of indirect symbols.
 */
__private_extern__
void
reduce_indr_symbols(void)
{
    unsigned long i, j, k, indr_depth, from_dylibs, not_from_dylibs;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol, **indr_symbols, *indr_symbol;
    struct indr_symbol_pair *indr_symbol_pair;

	indr_symbols = allocate(nindr_symbols * sizeof(struct merged_symbol *));
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];

		/*
		 * Reduce indirect symbol chains to have all the indirect
		 * symbols point at their leaf symbol.  Also catch loops of
		 * indirect symbols.  If an indirect symbol was previously
		 * in a loop it's n_value is set to zero so not to print the
		 * loop more than once.
		 */
		if(merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		   merged_symbol->nlist.n_value != 0){
		    if(merged_symbol->defined_in_dylib == TRUE){
			from_dylibs = 1;
			not_from_dylibs = 0;
		    }
		    else{
			from_dylibs = 0;
			not_from_dylibs = 1;
		    }
		    indr_symbols[0] = merged_symbol;
		    indr_depth = 1;
		    indr_symbol = (struct merged_symbol *)
						(merged_symbol->nlist.n_value);
		    while(indr_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		          indr_symbol->nlist.n_value != 0){
			for(j = 0; j < indr_depth; j++){
			    if(indr_symbols[j] == indr_symbol)
				break;
			}
			if(j == indr_depth){
			    if(indr_symbol->defined_in_dylib == TRUE)
				from_dylibs++;
			    else
				not_from_dylibs++;
			    indr_symbols[indr_depth++] = indr_symbol;
			    indr_symbol = (struct merged_symbol *)
						(indr_symbol->nlist.n_value);
			}
			else{
			    error("indirect symbol loop:");
			    for(k = j; k < indr_depth; k++){
				trace_merged_symbol(indr_symbols[k]);
				indr_symbols[k]->nlist.n_value = 0;
			    }
			    indr_symbol->nlist.n_value = 0;
			}
		    }
		    /*
		     * If this N_INDR chain has symbols both from dylib and
		     * not from dylibs record a pair for each merged symbol
		     * not defined in a dylib and the first in the chain
		     * defined in a dylib.
		     */
		    if(from_dylibs != 0 && not_from_dylibs != 0 &&
		       indr_symbol->nlist.n_type != (N_EXT | N_INDR)){
			for(j = 0; j < indr_depth; j++){
			    if(indr_symbols[j]->defined_in_dylib == FALSE){
				for(k = j + 1; k < indr_depth; k++){
				    if(indr_symbols[k]->defined_in_dylib)
					break;
				}
				indr_symbol_pairs = reallocate(
				    indr_symbol_pairs,
				    sizeof(struct indr_symbol_pair) *
					(nindr_symbol_pairs + 1));
				indr_symbol_pair = indr_symbol_pairs +
						   nindr_symbol_pairs;
				nindr_symbol_pairs++;
				indr_symbol_pair->merged_symbol = merged_symbol;
				if(k < indr_depth &&
				   indr_symbols[k]->defined_in_dylib)
				    indr_symbol_pair->indr_symbol =
					indr_symbols[k];
				else
				    indr_symbol_pair->indr_symbol =
					indr_symbol;
			    }
			}
		    }
		    if(indr_symbol->nlist.n_type != (N_EXT | N_INDR)){
			for(j = 0; j < indr_depth; j++){
			    indr_symbols[j]->nlist.n_value =
						    (unsigned long)indr_symbol;
			    /*
			     * If this indirect symbol is pointing to a
			     * private extern then increment the count of
			     * private exterals.
			     */
			    if((indr_symbol->nlist.n_type & N_PEXT) == N_PEXT){
				indr_symbols[j]->definition_object->
				    nprivatesym++;
				nmerged_private_symbols++;
			    }
			}
		    }
		}
	    }
	}
	free(indr_symbols);
}

/*
 * layout_merged_symbols() sets the values and section numbers of the merged
 * symbols.
 */
__private_extern__
void
layout_merged_symbols(void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		relocate_symbol(&(merged_symbol->nlist),
				merged_symbol->definition_object);
	    }
	}
	/*
	 * Set this global variable to let routines that look at merged symbols
	 * in both the first pass and second pass that the merged symbols are
	 * relocated.  This is need for example when looking at the n_sect value
	 * of a merged symbol.  In the first pass it can be used as an index
	 * into definition_object->section_maps[] but in the second pass it can
	 * not.
	 */
	merged_symbols_relocated = TRUE;

	/*
	 * The MH_NOUNDEFS flag is set only if there are no undefined symbols
	 * or commons left undefined.  This is only set if we think the file is
	 * executable as the execute bits are based on this.
	 */
	if(noundefs == TRUE &&
	   (define_comldsyms == TRUE || commons_exist == FALSE))
	    output_mach_header.flags |= MH_NOUNDEFS;
}

/*
 * discard_local_symbols_for_section() is used by coalesced_section_merge(),
 * indirect_section_merge() and removed_dead_local_symbols_in_section() (when
 * -dead_strip is specified) to deal with the symbol table entries for local
 * symbols and N_STAB symbols in this section in the current object file after
 * the fine relocation entries have been set up to determined for which items
 * the contents will be used from current object file object file.
 */
__private_extern__
void
discard_local_symbols_for_section(
unsigned long nsect,
struct nlist *object_symbols,
char *object_strings,
struct section *s,
struct section_map *section_map)
{
    unsigned long i, j, k, output_strlen;
    struct localsym_block *localsym_block, **next_localsym_block;
    struct fine_reloc *fine_reloc;
    enum bool closed_last_block;
    size_t * debug_ptr;

	/*
	 * Previouly in merge_symbols(), nlocal_symbols and local_string_size
	 * were incremented for all symbols in this section. So now we decrement
	 * these variables for symbols in the items that will not be in the
	 * output file.
	 */
	localsym_block = cur_obj->localsym_blocks;
	next_localsym_block = &(cur_obj->localsym_blocks);
	debug_ptr = cur_obj->dwarf_source_data;
	for(i = 0; i < cur_obj->symtab->nsyms; i++){
	    if (debug_ptr && *debug_ptr < i) {
	      for (debug_ptr += 2; *debug_ptr & 0x80000000; debug_ptr++) ;
	    }
	    /* skip blocks of symbols that have already been removed */
	    if(localsym_block != NULL && localsym_block->index == i){
		i += localsym_block->count - 1; /* the loop will do i++ */
		next_localsym_block = &(localsym_block->next);
		localsym_block = localsym_block->next;
		continue;
	    }
	    /*
	     * See if this is a local symbol for this section that would be in
	     * the output file.
	     */
	    if((object_symbols[i].n_type & N_EXT) == 0 &&
	       ((object_symbols[i].n_type & N_TYPE) == N_SECT ||
	        (object_symbols[i].n_type & N_STAB) != 0) &&
	       object_symbols[i].n_sect == nsect &&
	       is_output_local_symbol(object_symbols[i].n_type,
				      object_symbols[i].n_sect,
				      object_symbols[i].n_desc, cur_obj,
				      object_symbols[i].n_un.n_strx == 0 ? "" :
				      object_strings +
				      object_symbols[i].n_un.n_strx,
				      &output_strlen)){
		/*
		 * If this local symbol from this section that part of a
		 * fine_reloc that is not going to be in the output then make
		 * sure the symbol is not going to be in the output by creating
		 * a local symbol block for it marked to discard the symbol.
		 * Unless the symbol is an N_SO stab, which must be kept for
		 * the debugger to work correctly.  Note these stabs would have
		 * addresses that are meaningless if the block they are in is
		 * dead stripped, gdb(1) has code to handle this if the address
		 * zero (see below where this is done).
		 */
		if(fine_reloc_offset_in_output(section_map,
			object_symbols[i].n_value - s->addr) == FALSE &&
		   object_symbols[i].n_type != N_SO){
		    nlocal_symbols--;
		    cur_obj->nlocalsym--;

		    local_string_size -=
			    object_symbols[i].n_un.n_strx == 0 ? 0:
			    output_strlen + 1;

		    /* If this file had DWARF, the debug map symbols
		       for this symbol will also go away.  */
		    if (cur_obj->dwarf_name){
		      size_t n = count_dwarf_symbols (object_symbols + i, i,
						      debug_ptr);
		      cur_obj->nlocalsym -= n;
		      nlocal_symbols -= n;
		    }

		    /*
		     * Create a block for this symbol which will cause it to
		     * be discarded for the output.
		     */
		    localsym_block = allocate(sizeof(struct localsym_block));
		    memset(localsym_block, '\0', sizeof(struct localsym_block));
		    localsym_block->index = i;
		    localsym_block->state = DISCARD_SYMBOLS;
		    localsym_block->count = 1;

		    /* insert this block in the list */
		    localsym_block->next = *next_localsym_block;
		    *next_localsym_block = localsym_block;
		    next_localsym_block = &(localsym_block->next);

		    /*
		     * If this is a begin nsect symbol stab (N_BNSYM) scan
		     * forward to the end nsect symbol stab (N_ENSYM) and cause
		     * all stabs to also be removed.
		     */
		    fine_reloc = fine_reloc_for_input_offset(section_map,
					object_symbols[i].n_value - s->addr);
		    if(object_symbols[i].n_type == N_BNSYM &&
			i + 1 < cur_obj->symtab->nsyms){
			for(j = i + 1; j < cur_obj->symtab->nsyms; j++){
			    if(localsym_block->next != NULL &&
			       j >= localsym_block->next->index)
				break;
			    if(object_symbols[j].n_type == N_ENSYM)
				break;
	    		    if((object_symbols[j].n_type & N_EXT) == N_EXT)
				break;
			    if((object_symbols[j].n_type & N_STAB) == 0)
				break;
			    if(object_symbols[j].n_sect == NO_SECT)
				continue;
			    if(object_symbols[j].n_sect != nsect)
				break;
			    if(fine_reloc != fine_reloc_for_input_offset(
				section_map,
				object_symbols[j].n_value - s->addr))
				break;
			}
			/*
			 * If we really found an end nsect symbol stab (N_ENSYM)
			 * adjust the counts of the symbols and string sizes
			 * for the symbols being removed and add the symbols
			 * being removed to a local symbol block.
			 */
			if(j < cur_obj->symtab->nsyms &&
			   (localsym_block->next == NULL ||
			    j < localsym_block->next->index) &&
			   object_symbols[j].n_type == N_ENSYM &&
			   object_symbols[j].n_sect == nsect){
			    /*
			     * If there are type stabs in the N_BNSYM/N_ENSYM
			     * block these must not be removed to allow
			     * debugging to work.  To do this we scan the
			     * symbols in this block.  If we find a type stab we
			     * close the current local symbol block and
			     * step over this stab.  If we then run into another
			     * non-type stab we create a new local block and
			     * put that in that block.
			     */
			    closed_last_block = FALSE;
			    for(k = i + 1; k <= j; k++){
				if(is_type_stab(object_symbols[k].n_type,
				       object_symbols[k].n_un.n_strx == 0 ? "" :
				       object_strings +
				       object_symbols[k].n_un.n_strx)){
				    closed_last_block = TRUE;
				}
				else{
				    if(closed_last_block == TRUE){
					/*
					 * Create a block for this next group of
					 * symbols which will cause it to be
					 * discarded for the output.
					 */
					localsym_block = allocate(
						sizeof(struct localsym_block));
					memset(localsym_block, '\0',
					       sizeof(struct localsym_block));
					localsym_block->index = k;
					localsym_block->state = DISCARD_SYMBOLS;

					/* insert this block in the list */
					localsym_block->next =
						*next_localsym_block;
					*next_localsym_block = localsym_block;
					next_localsym_block =
						&(localsym_block->next);
					closed_last_block = FALSE;
				    }
				    localsym_block->count++;
				    nlocal_symbols--;
				    cur_obj->nlocalsym--;
				    local_string_size -=
				       object_symbols[k].n_un.n_strx == 0 ? 0:
				       strlen(object_strings +
					   object_symbols[k].n_un.n_strx) + 1;
				}
			    }
			    i = j;
			}
		    }

		    /*
		     * Move the pointer from the block we just created to the
		     * the next block
		     */
		    localsym_block = localsym_block->next;
		}
		/*
		 * This local symbol is from this section and is that part of a
		 * fine_reloc that WILL be in the output.  If this is a begin
		 * nsect symbol stab (N_BNSYM) scan forward to the end nsect
		 * symbol stab (N_ENSYM) and cause all stabs to also be kept.
		 * This scan is needed just like the scan above for removing
		 * symbols when to keep all the stabs for unstripped
		 * fine_reloc's.
		 */
		else if(object_symbols[i].n_type == N_BNSYM &&
			i + 1 < cur_obj->symtab->nsyms){
		    fine_reloc = fine_reloc_for_input_offset(section_map,
					object_symbols[i].n_value - s->addr);
		    for(j = i + 1; j < cur_obj->symtab->nsyms; j++){
			if(localsym_block != NULL &&
			   j >= localsym_block->index)
			    break;
			if(object_symbols[j].n_type == N_ENSYM)
			    break;
			if((object_symbols[j].n_type & N_EXT) == N_EXT)
			    break;
			if((object_symbols[j].n_type & N_STAB) == 0)
			    break;
			if(object_symbols[j].n_sect == NO_SECT)
			    continue;
			if(object_symbols[j].n_sect != nsect)
			    break;
			if(fine_reloc != fine_reloc_for_input_offset(
			    section_map,
			    object_symbols[j].n_value - s->addr))
			    break;
		    }
		    /*
		     * If we really found an end nsect symbol stab (N_ENSYM)
		     * move the index i to skip these stabs so they are kept.
		     */
		    if(j < cur_obj->symtab->nsyms &&
		       (localsym_block == NULL ||
			j < localsym_block->index) &&
		       object_symbols[j].n_type == N_ENSYM &&
		       object_symbols[j].n_sect == nsect){
			i = j;
		    }
		}
		/*
		 * This local symbol is being kept, if it is an N_SO stab,
		 * from this section that part of a fine_reloc that is not
		 * going to be in the output then change it so the debugger
		 * will work correctly.  These stabs would have addresses that
		 * are meaningless if the block they are in is dead stripped,
		 * gdb(1) has code to handle this if the address zero.  So
		 * set the n_sect to NO_SECT and the n_value to zero.
		 */
		else if(object_symbols[i].n_type == N_SO &&
		   fine_reloc_offset_in_output(section_map,
			object_symbols[i].n_value - s->addr) == FALSE){
		       object_symbols[i].n_sect = NO_SECT;
		       object_symbols[i].n_value = 0;
		}
	    }
	}
}

#ifndef RLD
/*
 * remove_dead_N_GSYM_stabs_for_cur_obj() is used by remove_dead_N_GSYM_stabs()
 * when -dead_strip is specified to get rid of dead N_GSYM stabs for the
 * cur_obj.  For common symbols this has to be done as they are not defined or
 * in a section and so they can't be bracked by N_BNSYM/N_ENSYM stabs.
 */
static
void
remove_dead_N_GSYM_stabs_for_cur_obj(
struct nlist *object_symbols,
char *object_strings)
{
    unsigned long i, len, symbol_name_len;
    long output_strlen;
    struct localsym_block *localsym_block, **next_localsym_block;
    char *stab_name, *symbol_name, *p;
    struct merged_symbol *hash_pointer, *merged_symbol;
    size_t * debug_ptr;

	/*
	 * Previouly in merge_symbols(), nlocal_symbols and local_string_size
	 * were incremented for all symbols in this section. So now we decrement
	 * these variables for N_GSYM stabs that will not be in the output file.
	 */
	symbol_name_len = 0;
	symbol_name = NULL;
	localsym_block = cur_obj->localsym_blocks;
	next_localsym_block = &(cur_obj->localsym_blocks);
	debug_ptr = cur_obj->dwarf_source_data;
	for(i = 0; i < cur_obj->symtab->nsyms; i++){
	    if (debug_ptr && *debug_ptr < i) {
	      for (debug_ptr += 2; *debug_ptr & 0x80000000; debug_ptr++) ;
	    }

	    /* Remove the DWARF symbols that correspond to an external
	       symbol which will not be in the output file.
	       This has to be done here rather than in count_live_symbols
	       (where it would be much more efficient) for the same reason
	       that this processing has to be done for GSYM symbols:
	       a common variable which turns out to be dead might have
	       GSYM entries in multiple .o files.  */
	    if (cur_obj->dwarf_name
		&& object_symbols[i].n_type & N_EXT
		&& object_symbols[i].n_un.n_strx != 0) {
	      size_t cnt = count_dwarf_symbols (object_symbols + i, i,
						debug_ptr);
	      if (cnt == 0)
		/* Avoid expensive hash lookup for symbols not actually
		   defined in this object file.  */
		continue;
	      hash_pointer = lookup_symbol(object_strings
					   + object_symbols[i].n_un.n_strx);
	      if (hash_pointer->name_len == 0
		  || hash_pointer->live
		  || (object_symbols[i].n_sect != NO_SECT
		      && hash_pointer->definition_object != cur_obj))
		continue;

	      cur_obj->nlocalsym -= cnt;
	      nlocal_symbols -= cnt;
	    }

	    /* skip blocks of symbols that have already been removed */
	    if(localsym_block != NULL && localsym_block->index == i){
		i += localsym_block->count - 1; /* the loop will do i++ */
		next_localsym_block = &(localsym_block->next);
		localsym_block = localsym_block->next;
		continue;
	    }
	    /*
	     * See if this is a N_GSYM stab and would be in the output file.
	     */
	    output_strlen = -1;
	    if(object_symbols[i].n_type == N_GSYM &&
	       is_output_local_symbol(object_symbols[i].n_type,
				      object_symbols[i].n_sect,
				      object_symbols[i].n_desc, cur_obj,
				      object_symbols[i].n_un.n_strx == 0 ? "" :
				      object_strings +
				      object_symbols[i].n_un.n_strx,
				      (unsigned long *)&output_strlen)){
		/*
		 * If is_output_local_symbol() was called in the if() above then
		 * output_strlen will not be -1.  Else we need to calculate the
		 * output string size. This is without the trailing '\0' since
		 * if it is set by is_output_local_symbol() we could be
		 * truncating the string.
		 */
		if(output_strlen == -1)
		   output_strlen = object_symbols[i].n_un.n_strx == 0 ? 0:
				   strlen(object_strings +
					  object_symbols[i].n_un.n_strx);
		/*
		 * Parse out the global symbol name from the N_GSYM stab and
		 * look it up to see if the merged symbol symbol is live.
		 */
		if(object_symbols[i].n_un.n_strx == 0)
		    continue;
		stab_name = object_strings + object_symbols[i].n_un.n_strx;
		p = strchr(stab_name, ':');
		if(p == NULL)
		    continue;
		len = p - stab_name;
		if(len == 0)
		    continue;
		if(len + 2 > symbol_name_len){
		     if(len + 2 < 4096)
			symbol_name_len = 4096;
		     else
			symbol_name_len = len + 2;
		     symbol_name = reallocate(symbol_name, symbol_name_len);
		}
		strcpy(symbol_name, "_");
		strncat(symbol_name, stab_name, len);
		hash_pointer = lookup_symbol(symbol_name);
		if(hash_pointer->name_len == 0)
		    continue;
		merged_symbol = hash_pointer;
		if(merged_symbol->live == FALSE){
		    nlocal_symbols--;
		    cur_obj->nlocalsym--;
		    local_string_size -= output_strlen == 0 ? 0:
					 output_strlen + 1;
		    /*
		     * Create a block for this symbol which will cause it to
		     * be discarded for the output.
		     */
		    localsym_block = allocate(sizeof(struct localsym_block));
		    memset(localsym_block, '\0', sizeof(struct localsym_block));
		    localsym_block->index = i;
		    localsym_block->state = DISCARD_SYMBOLS;
		    localsym_block->count = 1;

		    /* insert this block in the list */
		    localsym_block->next = *next_localsym_block;
		    *next_localsym_block = localsym_block;
		    next_localsym_block = &(localsym_block->next);

		    /*
		     * Move the pointer from the block we just created to the
		     * the next block
		     */
		    localsym_block = localsym_block->next;
		}
	    }
	}
	if(symbol_name != NULL)
	    free(symbol_name);
}
#endif /* !defined(RLD) */

/* these keep track of BINCL strings, so they can be re-used by EXCL */
struct bincl_entry {
    unsigned long sum;
    unsigned long stroffset;
    const char* path;
};
static struct bincl_entry* bincl_entries = NULL;
static unsigned int bincl_entries_used = 0;
static unsigned int bincl_entry_count = 0;

/*
 * record_bincl() records the string offset of a BINCL for a checksum/path pair.
 */
static
void
record_bincl(
unsigned long sum,
const char* path,
unsigned long output_stroffset)
{
    struct bincl_entry *tmp;
    char *path_copy;

	if(bincl_entries == NULL){
	    bincl_entry_count = 8192;
	    bincl_entries = allocate(sizeof(struct bincl_entry) *
				     bincl_entry_count);
	}
	if(bincl_entries_used == bincl_entry_count){
	    bincl_entry_count *= 2;
	    tmp = allocate(sizeof(struct bincl_entry)*bincl_entry_count);
	    memcpy(tmp, bincl_entries, sizeof(struct bincl_entry) *
				       bincl_entries_used);
	    free(bincl_entries);
	    bincl_entries = tmp;
	}
	bincl_entries[bincl_entries_used].sum = sum;
	bincl_entries[bincl_entries_used].stroffset = output_stroffset;
	path_copy = allocate(strlen(path) + 1);
	strcpy(path_copy, path);
	bincl_entries[bincl_entries_used].path = path_copy;
	bincl_entries_used++;
}

/*
 * find_bincl() finds the string offset of a BINCL for a checksum/path pair.
 */
static
unsigned long
find_bincl(
unsigned long sum,
const char* path)
{
    unsigned long i;

	for(i = 0; i < bincl_entries_used; i++){
	    if(bincl_entries[i].sum == sum &&
	       strcmp(bincl_entries[i].path, path) == 0){
		return(bincl_entries[i].stroffset);
	    }
	}
	return(0);
}


/*
 * add_dwarf_map_entry() adds a single DWARF map symbol to 'nlist'.
 */
static void
add_dwarf_map_entry(struct nlist ** nlist, unsigned long *output_nsyms,
		    int32_t n_strx, uint8_t n_type, uint8_t n_sect,
		    int16_t n_desc, uint32_t n_value)
{
  (*nlist)->n_un.n_strx = n_strx;
  (*nlist)->n_type = n_type;
  (*nlist)->n_sect = n_sect;
  (*nlist)->n_desc = n_desc;
  (*nlist)->n_value = n_value;
  (*nlist)++;
  (*output_nsyms)++;
}

/*
 * add_dwarf_map_for_sym() adds the DWARF symbols for a single object file
 * symbol to 'nlist'.  It is the pass2 counterterpart of count_dwarf_symbols.
 */
static void
add_dwarf_map_for_sym(const struct nlist * sym,
		      size_t i, const size_t * debug_ptr, uint32_t n_strx,
		      uint16_t old_sect,
		      struct nlist ** nlist, unsigned long *output_nsyms)
{
  size_t j;

  /* The debug map only represents symbols which are defined in
     a particular section or which are global common symbols.  */
  if ((sym->n_type & (N_TYPE | N_STAB)) != N_SECT
      && ((sym->n_type & (N_TYPE | N_STAB)) != N_UNDF
	  || sym->n_value == 0))
    return;
  /* If S_ATTR_STRIP_STATIC_SYMS is set on this symbol's section,
     we don't need a debug symbol for this symbol.  */
  if ((sym->n_type & (N_TYPE | N_STAB)) == N_SECT
      && old_sect != NO_SECT
      && (cur_obj->section_maps[old_sect - 1].s->flags &
	  S_ATTR_STRIP_STATIC_SYMS))
    return;

  if (! debug_ptr || *debug_ptr != i)
    {
      if (sym->n_type & N_EXT)
	add_dwarf_map_entry (nlist, output_nsyms, n_strx, N_GSYM, 0, 0, 0);
      else
	add_dwarf_map_entry (nlist, output_nsyms,
			     sym->n_un.n_strx, N_STSYM,
			     sym->n_sect, 0, sym->n_value);
      return;
    }
  add_dwarf_map_entry (nlist, output_nsyms,
		       0, N_BNSYM, sym->n_sect, 0, sym->n_value);
  add_dwarf_map_entry (nlist, output_nsyms,
		       n_strx, N_FUN, sym->n_sect, 0, sym->n_value);
  for (j = 2; debug_ptr[j] & 0x80000000; j++)
    add_dwarf_map_entry (nlist, output_nsyms,
			 (cur_obj->dwarf_paths[debug_ptr[j] & 0x7fffffff]
			  - output_addr
			  - output_symtab_info.symtab_command.stroff),
			 N_SOL, 0, 0, 0);
  add_dwarf_map_entry (nlist, output_nsyms, 0, N_FUN, 0, 0, debug_ptr[1]);
  add_dwarf_map_entry (nlist, output_nsyms, 0, N_ENSYM,
		       sym->n_sect, 0, sym->n_value);
}

/*
 * output_local_symbols() copys the local symbols and their strings from the
 * current object file into the output file's memory buffer.  The symbols also
 * get relocated.
 */
__private_extern__
void
output_local_symbols(void)
{
    unsigned long i, flush_symbol_offset, output_nsyms, flush_string_offset,
		  start_string_size, mtime, stroff_for_N_OSO;
    long output_strlen;
    struct nlist *object_symbols, *nlist;
    char *object_strings, *string;
    struct localsym_block *localsym_block;
    size_t * debug_ptr;

	/* If no symbols are not to appear in the output file just return */
	if(strip_level == STRIP_ALL)
	    return;

	/* If this object file has no symbols then just return */
	if(cur_obj->symtab == NULL)
	    return;

	/* If this is the base file and base file symbols are stripped return */
	if(cur_obj == base_obj && strip_base_symbols == TRUE)
	    return;

#ifdef RLD
	/* If this object is not from the current set then just return */
	if(cur_obj->set_num != cur_set)
	    return;
#endif /* RLD */

	/* setup pointers to the symbol table and string table */
	object_symbols = (struct nlist *)(cur_obj->obj_addr +
					  cur_obj->symtab->symoff);
	object_strings = (char *)(cur_obj->obj_addr + cur_obj->symtab->stroff);

	flush_symbol_offset = output_symtab_info.symtab_command.symoff +
			      cur_obj->ilocalsym * sizeof(struct nlist);
	flush_string_offset = output_symtab_info.symtab_command.stroff +
			      output_symtab_info.output_local_strsize;
	start_string_size = output_symtab_info.output_local_strsize;

	output_nsyms = 0;
	stroff_for_N_OSO = 0;
	nlist = (struct nlist *)(output_addr + flush_symbol_offset);
	/* If we are creating section object symbols, create one if needed */
	if(sect_object_symbols.ms != NULL){
	    /*
	     * See if this object file has the section that the section object
	     * symbols are being created for.
	     */
	    for(i = 0; i < cur_obj->nsection_maps; i++){
		if(sect_object_symbols.ms ==
		   cur_obj->section_maps[i].output_section){
		    /* make the nlist entry in the output file */
		    nlist->n_value =
			    cur_obj->section_maps[i].output_section->s.addr +
			    cur_obj->section_maps[i].offset;
		    nlist->n_sect =
			cur_obj->section_maps[i].output_section->output_sectnum;
		    nlist->n_type = N_SECT;
		    nlist->n_desc = 0;

		    nlist->n_un.n_strx = output_symtab_info.
					 output_local_strsize;
		    string = output_addr +
			     output_symtab_info.symtab_command.stroff +
			     output_symtab_info.output_local_strsize;
		    if(cur_obj->ar_hdr == NULL){
			strcpy(string, cur_obj->file_name);
			output_symtab_info.output_local_strsize +=
						 strlen(cur_obj->file_name) + 1;
		    }
		    else{
			strncpy(string, cur_obj->ar_name,cur_obj->ar_name_size);
			string[cur_obj->ar_name_size] = '\0';
			output_symtab_info.output_local_strsize +=
				       cur_obj->ar_name_size + 1;
		    }
		    nlist++;
		    output_nsyms++;
		    break;
		}
	    }
	}

	/* Add initial DWARF map symbols.  */
	if(cur_obj->dwarf_name){
	  size_t len = strlen (cur_obj->dwarf_name) + 1;
	  char * strbase = (output_addr
			    + output_symtab_info.symtab_command.stroff);

	  if (cur_obj->dwarf_comp_dir){
	    size_t len = strlen (cur_obj->dwarf_comp_dir);
	    add_dwarf_map_entry (&nlist, &output_nsyms,
				 output_symtab_info.output_local_strsize,
				 N_SO, 0, 0, 0);
	    memcpy (strbase + output_symtab_info.output_local_strsize,
		    cur_obj->dwarf_comp_dir, len);
	    output_symtab_info.output_local_strsize += len + 2;
	    strbase[output_symtab_info.output_local_strsize - 2] = '/';
	    strbase[output_symtab_info.output_local_strsize - 1] = 0;
	  }

	  add_dwarf_map_entry (&nlist, &output_nsyms,
			       output_symtab_info.output_local_strsize,
			       N_SO, 0, 0, 0);
	  memcpy (strbase + output_symtab_info.output_local_strsize,
		  cur_obj->dwarf_name, len);
	  output_symtab_info.output_local_strsize += len;

	  get_stroff_and_mtime_for_N_OSO(&stroff_for_N_OSO, &mtime);
	  add_dwarf_map_entry (&nlist, &output_nsyms,
			       stroff_for_N_OSO, N_OSO, 0, 1, mtime);

	  /* Add SOL strings to the local string table, and update
	     cur_obj->dwarf_paths to point into it.  */
	  for (i = 0; i < cur_obj->dwarf_num_paths; i++)
	    if (cur_obj->dwarf_paths[i]){
	      char * st = strbase + output_symtab_info.output_local_strsize;
	      size_t len = strlen (cur_obj->dwarf_paths[i]) + 1;
	      output_symtab_info.output_local_strsize += len;
	      memcpy (st, cur_obj->dwarf_paths[i], len);
	      cur_obj->dwarf_paths[i] = st;
	    }
	}

	/*
	 * Loop through this object file's local symbols.
	 */
	localsym_block = cur_obj->localsym_blocks;
	debug_ptr = cur_obj->dwarf_source_data;
	for(i = 0; i < cur_obj->symtab->nsyms; i++){
	    if (debug_ptr && *debug_ptr < i) {
	      for (debug_ptr += 2; *debug_ptr & 0x80000000; debug_ptr++) ;
	    }
	    /*
	     * Some of the local symbols may be excluded.  These have
	     * localsym_blocks.  The localsym_blocks are ordered by the index
	     * field.  For local symbol blocks marked with the state
	     * EXCLUDED_INCLUDE are for blocks of N_BINCL/N_EINC local symbols
	     * to be exclude and replaced with a single N_EXCL.  For the state
	     * BEGIN_INCLUDE the sum is just set into the n_value.  Others are
	     * simply excluded as the could have been local symbols for
	     * coalesced or indirect symbols that were removed.
	     */
	    if(localsym_block != NULL && localsym_block->index == i){
		if(localsym_block->state ==  EXCLUDED_INCLUDE ||
		   localsym_block->state == BEGIN_INCLUDE){
		    *nlist = object_symbols[i];
		    if(localsym_block->state == EXCLUDED_INCLUDE)
			nlist->n_type = N_EXCL;
		    nlist->n_value = localsym_block->sum;
		    /*
		     * set the string of the N_BINCL/N_EXCL to the output file.
		     * (it should have one)
		     */
		    if(object_symbols[i].n_un.n_strx != 0){
			int doCopy = 1;
			/* try to re-use an existing BINCL string */
			nlist->n_un.n_strx = find_bincl(nlist->n_value,
				object_strings + object_symbols[i].n_un.n_strx);
			if(nlist->n_un.n_strx != 0){
			    if(nlist->n_type == N_EXCL){
				/* EXCL always re-uses BINCL string,
				   n_un.n_strx already set */
				doCopy = 0;
			    }
			}
			else if(nlist->n_type == N_BINCL){
			    /* first time this BINCL has been seen, so add it */
			    record_bincl(nlist->n_value,
				 object_strings +
				 object_symbols[i].n_un.n_strx,
				 output_symtab_info.output_local_strsize);
			}
			if(doCopy){
			    nlist->n_un.n_strx = output_symtab_info.
						 output_local_strsize;
			    string = output_addr +
				     output_symtab_info.symtab_command.stroff +
				     output_symtab_info.output_local_strsize;
			    strcpy(string,
				   object_strings +
				      object_symbols[i].n_un.n_strx);
			    output_symtab_info.output_local_strsize +=
			      strlen(object_strings +
				     object_symbols[i].n_un.n_strx) + 1;
			}
		    }
		    output_nsyms++;
		    nlist++;
		}
		i += localsym_block->count - 1; /* the loop will do i++ */
		localsym_block = localsym_block->next;
		continue;
	    }

	    /* Add debug map entries for global symbols.  */
	    if (cur_obj->dwarf_name
		/* The debug map contains symbols defined in a section... */
		&& (((object_symbols[i].n_type & (N_TYPE | N_STAB | N_EXT))
		     == (N_SECT | N_EXT))
		    /* ... and global common symbols.  */
		    || (((object_symbols[i].n_type & (N_TYPE | N_STAB | N_EXT))
			 == (N_UNDF | N_EXT))
			&& object_symbols[i].n_value != 0))){
	      struct merged_symbol *hash_pointer;
	      hash_pointer = lookup_symbol(object_strings
					   + object_symbols[i].n_un.n_strx);

	      /* Only those symbols whose definitions in this object
		 were actually output get a debug_map entry.  Common symbols
	         are always 'output' if they are live.  */
	      if (hash_pointer->name_len != 0
		  && (! dead_strip || hash_pointer->live)
		  && (object_symbols[i].n_sect == NO_SECT
		      || hash_pointer->definition_object == cur_obj)){
		unsigned long symbol_index;
		symbol_index = (output_symtab_info.output_merged_strsize
				+ (merged_symbol_string_index
				   (hash_pointer->nlist.n_un.n_name)));
		add_dwarf_map_for_sym (&hash_pointer->nlist, i, debug_ptr,
				       symbol_index, object_symbols[i].n_sect,
				       &nlist, &output_nsyms);
	      }
	    }

	    /*
	     * If this is a local symbol and it is to be in the output file then
	     * copy it and it's string into the output file and relocate the
	     * symbol.
	     */
	    output_strlen = -1;
	    if((object_symbols[i].n_type & N_EXT) == 0 &&
	       is_output_local_symbol(object_symbols[i].n_type,
		    object_symbols[i].n_sect, object_symbols[i].n_desc, cur_obj,
		    object_symbols[i].n_un.n_strx == 0 ? "" :
		    object_strings + object_symbols[i].n_un.n_strx,
		    (unsigned long *)&output_strlen)){

		/*
		 * If is_output_local_symbol() was called in the if() above then
		 * output_strlen will not be -1.  Else we need to calculate the
		 * output string size. This is without the trailing '\0' since
		 * if it is set by is_output_local_symbol() we could be
		 * truncating the string.
		 */
		if(output_strlen == -1)
		   output_strlen = object_symbols[i].n_un.n_strx == 0 ? 0:
				   strlen(object_strings +
					  object_symbols[i].n_un.n_strx);
		/* copy the nlist to the output file */
		*nlist = object_symbols[i];
		relocate_symbol(nlist, cur_obj);
		/*
		 * If we are not producing a relocatable file clear the
		 * N_NO_DEAD_STRIP bit in non-stab symbols as it is overloaded
		 * and can't appear in a linked image.
		 */
		if(save_reloc == FALSE &&
		   (nlist->n_type & N_TYPE) == N_SECT &&
		   (nlist->n_type & N_STAB) == 0)
		    nlist->n_desc = nlist->n_desc & ~(N_NO_DEAD_STRIP);
#ifdef RLD
		/*
		 * Now change the section number of this symbol to the section
		 * number it will have in the output file.  For RLD all this
		 * has to be done on for only the symbol in an output file and
		 * not in the merged symbol table.  relocate_symbol() does not
		 * modify n_sect for RLD.
		 */
		if(nlist->n_sect != NO_SECT)
		    nlist->n_sect = cur_obj->section_maps[nlist->n_sect - 1].
				    output_section->output_sectnum;
#endif /* RLD */
		/*
		 * Now if this is an N_OSO we may need to set the n_value
		 * and change its name.
		 */
		if(nlist->n_type == N_OSO){
		    /*
		     * When the compiler is producing dwarf debug info it
		     * uses stabs for debug notes.  And the N_OSO stabs in this
		     * case has a n_desc field of 1.  If the name is the empty
		     * string (not NULL but a 1 character string with just a
		     * '\0') then change the name to the full path of the
		     * object file and set the mod time into n_value.  If the
		     * name is not an empty string it is left unchanged.
		     */
		    if(nlist->n_desc == 1){
			if(object_symbols[i].n_un.n_strx != 0 &&
			   object_strings[object_symbols[i].n_un.n_strx] ==
			   '\0'){
/* GUESS */
			    /*
			     * Copy the string (the full path name) for the
			     * N_OSO to the output file.
			     */
			    get_stroff_and_mtime_for_N_OSO(
				&stroff_for_N_OSO, &mtime);
			    /*
			     * Reset the string index and n_value of the N_OSO.
			     */
			    nlist->n_un.n_strx = stroff_for_N_OSO;
			    nlist->n_value = mtime;
			}
			/*
			 * The name of the dwarf N_OSO debug_note is not empty
			 * so leave it unchanged.
			 */
			else{
			    goto copy_string_to_output_file;
			}
		    }
		    /*
		     * When the compiler is producing stabs debug info it will
		     * produce an N_OSO stab with an n_desc field of 0.
		     */
		    else if(nlist->n_desc == 0){
			/*
			 * When -Sp is specified then change the name to the
			 * full path of the object file and set the mod time
			 * into n_value.
			 */
			if(strip_level == STRIP_MIN_DEBUG){
/* GUESS */
			    /*
			     * Copy the string (the full path name) for the
			     * N_OSO to the output file.
			     */
			    get_stroff_and_mtime_for_N_OSO(
				&stroff_for_N_OSO, &mtime);
			    /*
			     * Reset the string index and n_value of the N_OSO.
			     */
			    nlist->n_un.n_strx = stroff_for_N_OSO;
			    nlist->n_value = mtime;
			}
			/*
			 * When -Sp is not specified the name gets reset to ""
			 * reset to "" (that a one character string with only a
			 * '\0' character).  Unless the input the n_un.n_strx
			 * field is 0 then it will end up as 0 in the output.
			 */
			else{
			    output_strlen = 0;
			    goto copy_string_to_output_file;
			}
		    }
		    /*
		     * If the n_desc is not 0 or 1 then leave the name
		     * unchanged.
		     */
		    else{
			goto copy_string_to_output_file;
		    }
		}
		else{
copy_string_to_output_file:
		    /* copy the string to the output file (if it has one) */
		    if(object_symbols[i].n_un.n_strx != 0){
			nlist->n_un.n_strx = output_symtab_info.
					     output_local_strsize;
			string = output_addr +
				 output_symtab_info.symtab_command.stroff +
				 output_symtab_info.output_local_strsize;
			/*
			 * Note, output_strlen does not include the trailing
			 * '\0' as we could be truncating the string.  But the
			 * increment below does as the output memory contains
			 * zeroes and we use a zero in it after the string as
			 * the trailing '\0'.
			 */
			strncpy(string,
			        object_strings + object_symbols[i].n_un.n_strx,
				output_strlen);
			output_symtab_info.output_local_strsize +=
				        output_strlen + 1;
		    }
		}
		output_nsyms++;
		nlist++;

		/* Add the DWARF map entry/entries for this local symbol,
		   if necessary.  */
		if(cur_obj->dwarf_name)
		  add_dwarf_map_for_sym (nlist - 1, i, debug_ptr,
					 nlist[-1].n_un.n_strx,
					 object_symbols[i].n_sect,
					 &nlist, &output_nsyms);
	    }
	}

	/* Add terminal DWARF map symbol.  */
	if(cur_obj->dwarf_name)
	  add_dwarf_map_entry (&nlist, &output_nsyms, 0, N_SO, 0, 0, 0);

	if(host_byte_sex != target_byte_sex){
	    nlist = (struct nlist *)(output_addr + flush_symbol_offset);
	    swap_nlist(nlist, output_nsyms, target_byte_sex);
	}
#ifndef RLD
	output_flush(flush_symbol_offset, output_nsyms * sizeof(struct nlist));
	output_flush(flush_string_offset, output_symtab_info.
					  output_local_strsize -
					  start_string_size);
#endif /* !defined(RLD) */
	/*
	 * Check to make sure the count is consistent.
	 */
	if(output_nsyms != cur_obj->nlocalsym)
	    fatal("internal error: output_local_symbols() inconsistent local "
		  "symbol count");
}

/*
 * get_stroff_and_mtime_for_N_OSO() is used when modifying an N_OSO from the
 * the cur_obj.  It places a string with the resolved_path in the string table
 * and returns the offset to it indirectly through stroff_for_N_OSO.  It also
 * returns the modifification time indirectly through mtime.
 */
static
void
get_stroff_and_mtime_for_N_OSO(
unsigned long *stroff_for_N_OSO,
unsigned long *mtime)
{
    char *string, *endptr;
#if !(defined(KLD) && defined(__STATIC__))
    struct stat stat_buf;
#endif /* !(defined(KLD) && defined(__STATIC__)) */

	*stroff_for_N_OSO = output_symtab_info.output_local_strsize;
	string = output_addr +
		 output_symtab_info.symtab_command.stroff +
		 output_symtab_info.output_local_strsize;
	strcpy(string, cur_obj->resolved_path);
	output_symtab_info.output_local_strsize +=
	    cur_obj->resolved_path_len + 1;
	/*
	 * Do not cause errors if we can't get a valid timestamp to use for the
	 * N_OSO n_value.
	 */
	if(cur_obj->ar_hdr != NULL)
	    *mtime = strtol(cur_obj->ar_hdr->ar_date, &endptr, 10);
	else{
#if !(defined(KLD) && defined(__STATIC__))
	    if(stat(cur_obj->file_name, &stat_buf) != -1)
		*mtime = stat_buf.st_mtime;
	    else
#endif /* !(defined(KLD) && defined(__STATIC__)) */
		*mtime = 0;
	}
}

/*
 * local_symbol_output_index() calculates the output symbol offset for the
 * symbol at index in the object file obj.  This is very slow and is only
 * called by output_indirect_symbols() when a symbol that was a private extern
 * that is no longer external is being used as an indirect symbol.
 */
__private_extern__
unsigned long
local_symbol_output_index(
struct object_file *obj,
unsigned long index)
{
    unsigned long i, output_nsyms, output_strlen;
    struct nlist *object_symbols;
    char *object_strings;
    struct localsym_block *localsym_block;

	/* setup pointers to the symbol table and string table */
	object_symbols = (struct nlist *)(obj->obj_addr +
					  obj->symtab->symoff);
	object_strings = (char *)(obj->obj_addr + obj->symtab->stroff);
	output_nsyms = 0;
	/* If we are creating section object symbols, count one if needed */
	if(sect_object_symbols.ms != NULL){
	    /*
	     * See if this object file has the section that the section object
	     * symbols are being created for.
	     */
	    for(i = 0; i < obj->nsection_maps; i++){
		if(sect_object_symbols.ms ==
		   obj->section_maps[i].output_section){
		    output_nsyms++;
		    break;
		}
	    }
	}

	localsym_block = obj->localsym_blocks;
	for(i = 0; i < obj->symtab->nsyms; i++){
	    /* skip blocks of symbols that have been removed */
	    if(localsym_block != NULL && localsym_block->index == i){
		i += localsym_block->count - 1; /* the loop will do i++ */
		localsym_block = localsym_block->next;
		continue;
	    }
	    /*
	     * If this is a local symbol and it is to be in the output file then
	     * count it.
	     */
	    if((object_symbols[i].n_type & N_EXT) == 0 &&
	       is_output_local_symbol(object_symbols[i].n_type,
		    object_symbols[i].n_sect, object_symbols[i].n_desc, obj,
		    object_symbols[i].n_un.n_strx == 0 ? "" :
		    object_strings + object_symbols[i].n_un.n_strx,
		    &output_strlen)){

		/*
		 * This symbol was in the output file if this symbol is at the
		 * the symbol index we are looking for then we know what output
		 * index it is.
		 */
		if(i == index)
		    return(obj->ilocalsym + output_nsyms);
		output_nsyms++;
	    }
	}
	fatal("internal error: local_symbol_output_index() could not determine "
	      "output_index");
	return(0);
}

/*
 * set_merged_string_block_indexes() set the relitive indexes for each merged
 * string block.
 */
__private_extern__
void
set_merged_string_block_indexes(
void)
{
    unsigned long index;
    struct string_block **q, *string_block;

	index = 0;
	for(q = &(merged_string_blocks); *q; q = &(string_block->next)){
	    string_block = *q;
	    if(strip_base_symbols == TRUE && string_block->base_strings == TRUE)
		continue;
	    if(string_block->dylib_strings == TRUE)
		continue;
#ifdef RLD
	    if(string_block->set_num != cur_set)
		continue;
#endif /* RLD */
	    string_block->index = index,
	    index += string_block->used;
	}
}

/*
 * output_merged_symbols() readies the merged symbols for the output file (sets
 * string indexes and handles indirect symbols) and copies the merged symbols
 * and their strings to the output file.  This routine also copies out the
 * two-level namespace hints for the undefined symbols if they are to be in
 * the output.
 */
__private_extern__
void
output_merged_symbols(void)
{
    unsigned long i, j, flush_symbol_offset,
		  flush_string_offset, start_string_size;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol, *indr_symbol;
    struct string_block **q, *string_block;
    struct nlist *nlist;
    struct twolevel_hint *hint;

	if(strip_level == STRIP_ALL)
	    return;

	/*
	 * Indirect symbols are readied for output.  For indirect symbols that
	 * the symbol they are refering to is defined (not undefined or common)
	 * the the type, value, etc. of the refered symbol is propagated to
	 * indirect symbol.  If the indirect symbol is not defined then the
	 * value field is set to the index of the string the symbol is refering
	 * to.
	 */
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if(merged_symbol->nlist.n_type == (N_EXT | N_INDR)){
		    /*
		     * If this N_INDR symbol was in a chain has symbols both
		     * from dylib and not from dylibs get then there was a
		     * recorded a pair for the merged symbol and the first in
		     * the chain defined in a dylib for the indr_symbol to be
		     * used.  If not then merged_symbol->nlist.n_value can be
		     * used.
		     */
		    indr_symbol = NULL;
		    for(j = 0; j < nindr_symbol_pairs; j++){
			if(indr_symbol_pairs[j].merged_symbol == merged_symbol)
			    indr_symbol = indr_symbol_pairs[j].indr_symbol;
		    }
		    if(indr_symbol == NULL)
			indr_symbol = (struct merged_symbol *)
				(merged_symbol->nlist.n_value);

		    /*
		     * Check to see if this symbol is defined (not undefined or
		     * common)
		     */
		    if(indr_symbol->nlist.n_type != (N_EXT | N_UNDF) &&
		       indr_symbol->nlist.n_type != (N_EXT | N_PBUD) &&
		       (filetype != MH_DYLIB ||
			(filetype == MH_DYLIB && multi_module_dylib == FALSE) ||
			merged_symbol->definition_object ==
				indr_symbol->definition_object)){
			merged_symbol->nlist.n_type = indr_symbol->nlist.n_type;
			merged_symbol->nlist.n_sect = indr_symbol->nlist.n_sect;
			merged_symbol->nlist.n_desc = indr_symbol->nlist.n_desc;
			merged_symbol->nlist.n_value =
						     indr_symbol->nlist.n_value;
		    }
		    else{
			merged_symbol->nlist.n_value =
				output_symtab_info.output_merged_strsize +
				merged_symbol_string_index(
					indr_symbol->nlist.n_un.n_name);
		    }
		}
	    }
	}

	/*
	 * Copy the merged symbols into the memory buffer for the output file
	 * and set their string indexes.  This is done in three groups:
	 * 	the private externals (if keep_private_externs is FALSE)
	 *	the defined external symbols
	 *	the undefined externals
	 */

	/*
	 * First group of merged symbols to be copied to into the buffer for
	 * the output file is the private externs if they are not to be kept
	 * (that is they are to be made static and not kept as global symbols).
	 */
	if(nmerged_private_symbols != 0 &&
	   keep_private_externs == FALSE &&
	   (strip_level != STRIP_NONGLOBALS ||
	    (filetype == MH_DYLIB && multi_module_dylib == TRUE)) ){
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				     merged_symbol_root->list;
	        merged_symbol_list != NULL;
		merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if(merged_symbol->referenced_in_non_dylib == FALSE)
			continue;
		    if(strip_base_symbols == TRUE &&
		       merged_symbol->definition_object == base_obj)
			continue;
#ifdef RLD
		    if(merged_symbol->definition_object->set_num != cur_set)
			continue;
#endif /* RLD */
		    if(strip_level == STRIP_DYNAMIC_EXECUTABLE &&
		       (((merged_symbol->nlist.n_desc &
			  REFERENCED_DYNAMICALLY) != REFERENCED_DYNAMICALLY) ||
			 (merged_symbol->nlist.n_type & N_PEXT) == N_PEXT))
			continue;
		    if(dead_strip == TRUE && merged_symbol->live == FALSE)
			continue;

		    /*
		     * See if this is a defined private extern symbol (but not
		     * still a common private extern symbol).
		     */
		    if((merged_symbol->nlist.n_type & N_PEXT) == N_PEXT &&
		       (merged_symbol->nlist.n_type & N_TYPE) != N_UNDF){
			/*
			 * Place this symbol with the local symbols for the
			 * object that defined this symbol.  The output symbol
			 * index for private externs was calculated by
			 * assign_output_symbol_indexes() and recorded in
			 * iprivatesym for the definition object.
			 */
			flush_symbol_offset =
				output_symtab_info.symtab_command.symoff +
				merged_symbol->definition_object->iprivatesym *
				sizeof(struct nlist);
			merged_symbol->definition_object->iprivatesym++;
			nlist = (struct nlist *)(output_addr +
						 flush_symbol_offset);
			*nlist = merged_symbol->nlist;
			/*
			 * Since this is a symbol definition make sure the
			 * weak reference bit is off.
			 */
			nlist->n_desc = nlist->n_desc & ~(N_WEAK_REF);
			/*
			 * If we are not producing a relocatable file clear the
			 * N_NO_DEAD_STRIP bit as it is overloaded and can't
			 * appear in a linked image.
			 */
			if(save_reloc == FALSE)
			    nlist->n_desc = nlist->n_desc & ~(N_NO_DEAD_STRIP);
			nlist->n_un.n_strx = output_symtab_info.
					     output_merged_strsize +
					     merged_symbol_string_index(
					     merged_symbol->nlist.n_un.n_name);
			/* make this private extern a non-external symbol */
			nlist->n_type &= ~(N_EXT);
#ifdef RLD
			/*
			 * Now change the section number of this symbol to the
			 * section number it will have in the output file.  For
			 * RLD all this has to be done for only the symbols in
			 * the output file and not in the merged symbol table.
			 * relocate_symbol() does not modify n_sect for RLD.
			 */
			if(nlist->n_sect != NO_SECT)
			    nlist->n_sect = merged_symbol->definition_object->
					    section_maps[nlist->n_sect - 1].
					    output_section->output_sectnum;
#endif /* RLD */
			if(host_byte_sex != target_byte_sex)
			    swap_nlist(nlist, 1, target_byte_sex);
#ifndef RLD
			output_flush(flush_symbol_offset, sizeof(struct nlist));
#endif /* !defined(RLD) */
		    }
		}
	    }
	}
	/*
	 * Second group of merged symbols to be copied to into the buffer for
	 * the output file is the defined externals.  They are copied out in the
	 * order creaded by assign_output_symbol_indexes() and left in the array
	 * extdefsyms_order.
	 */
	flush_symbol_offset = output_symtab_info.symtab_command.symoff +
			      output_dysymtab_info.dysymtab_command.iextdefsym *
			      sizeof(struct nlist);
	nlist = (struct nlist *)(output_addr + flush_symbol_offset);
	for(i = 0; i < output_dysymtab_info.dysymtab_command.nextdefsym; i++){
	    merged_symbol = extdefsyms_order[i];
	    *nlist = merged_symbol->nlist;
	    /*
	     * Since this is a symbol definition make sure the weak reference
	     * bit is off.
	     */
	    nlist->n_desc = nlist->n_desc & ~(N_WEAK_REF);
	    /*
	     * If we are not producing a relocatable file clear the
	     * N_NO_DEAD_STRIP bit as it is overloaded and can't appear in a
	     * linked image.
	     */
	    if(save_reloc == FALSE)
		nlist->n_desc = nlist->n_desc & ~(N_NO_DEAD_STRIP);
	    nlist->n_un.n_strx = output_symtab_info.output_merged_strsize +
				 merged_symbol_string_index(
				    merged_symbol->nlist.n_un.n_name);
	    /*
	     * If this defined external symbol is also a weak definition then
	     * set the MH_WEAK_DEFINES and MH_BINDS_TO_WEAK bits in the
	     * mach_header.
	     */
	    if(nlist->n_desc & N_WEAK_DEF)
		output_mach_header.flags |= MH_WEAK_DEFINES | MH_BINDS_TO_WEAK;
#ifdef RLD
	    /*
	     * Now change the section number of this symbol to the section
	     * number it will have in the output file.  For RLD all this
	     * has to be done on for only the symbol in an output file and
	     * not in the merged symbol table.  relocate_symbol() does not
	     * modify n_sect for RLD.
	     */
	    if(nlist->n_sect != NO_SECT)
		nlist->n_sect = merged_symbol->definition_object->
				section_maps[nlist->n_sect - 1].
				output_section->output_sectnum;
#endif
	    nlist++;
	}
	if(host_byte_sex != target_byte_sex){
	    nlist = (struct nlist *)(output_addr + flush_symbol_offset);
	    swap_nlist(nlist, output_dysymtab_info.dysymtab_command.nextdefsym,
		       target_byte_sex);
	}
#ifndef RLD
	output_flush(flush_symbol_offset,
		     output_dysymtab_info.dysymtab_command.nextdefsym *
		     sizeof(struct nlist));
#endif
	if(extdefsyms_order != NULL){
	    free(extdefsyms_order);
	    extdefsyms_order = NULL;
	}
	/*
	 * Third group of merged symbols to be copied to into the buffer for
	 * the output file is the undefined symbols.  They are copied out in the
	 * order creaded by assign_output_symbol_indexes() and left in the array
	 * undefsyms_order.
	 */
	flush_symbol_offset = output_symtab_info.symtab_command.symoff +
			      output_dysymtab_info.dysymtab_command.iundefsym *
			      sizeof(struct nlist);
	nlist = (struct nlist *)(output_addr + flush_symbol_offset);
	for(i = 0; i < output_dysymtab_info.dysymtab_command.nundefsym; i++){
	    merged_symbol = undefsyms_order[i];
	    *nlist = merged_symbol->nlist;
	    /*
	     * Since this is an undefined symbol make sure the weak definition
	     * bit and N_NO_DEAD_STRIP bits are off.
	     */
	    nlist->n_desc = nlist->n_desc & ~(N_WEAK_DEF & N_NO_DEAD_STRIP);
	    /*
	     * If this undefined symbol is referencing an undefined symbol that
	     * is a weak symbol set the N_REF_TO_WEAK bit and set the
	     * MH_BINDS_TO_WEAK bit in the mach_header.
	     */
	    if(merged_symbol->defined_in_dylib == TRUE &&
	       merged_symbol->weak_def_in_dylib == TRUE){
		nlist->n_desc |= N_REF_TO_WEAK;
		output_mach_header.flags |= MH_BINDS_TO_WEAK;
	    }
	    nlist->n_un.n_strx = output_symtab_info.output_merged_strsize +
				 merged_symbol_string_index(
				    merged_symbol->nlist.n_un.n_name);
	    /* note all undefined symbols have n_sect == NO_SECT */
	    nlist++;
	}
	if(host_byte_sex != target_byte_sex){
	    nlist = (struct nlist *)(output_addr + flush_symbol_offset);
	    swap_nlist(nlist, output_dysymtab_info.dysymtab_command.nundefsym,
		       target_byte_sex);
	}
#ifndef RLD
	output_flush(flush_symbol_offset,
		     output_dysymtab_info.dysymtab_command.nundefsym *
		     sizeof(struct nlist));
#endif
	/*
	 * Copy the merged strings into the memory buffer for the output file.
	 */
	flush_string_offset = output_symtab_info.symtab_command.stroff +
			      output_symtab_info.output_merged_strsize;
	start_string_size = output_symtab_info.output_merged_strsize;
	for(q = &(merged_string_blocks); *q; q = &(string_block->next)){
	    string_block = *q;
	    if(strip_base_symbols == TRUE && string_block->base_strings == TRUE)
		continue;
	    if(string_block->dylib_strings == TRUE)
		continue;
#ifdef RLD
	    if(string_block->set_num != cur_set)
		continue;
#endif /* RLD */
	    memcpy(output_addr + output_symtab_info.symtab_command.stroff +
				 output_symtab_info.output_merged_strsize,
		   string_block->strings,
		   string_block->used);
	    output_symtab_info.output_merged_strsize += string_block->used;
	}

#ifndef RLD
	output_flush(flush_string_offset, output_symtab_info.
					  output_merged_strsize -
					  start_string_size);
#endif /* !defined(RLD) */

	/*
	 * Lastly create and copy out the two-level namespace hints for the
	 * undefined symbols.  This must be in the same order as the undefined
	 * symbols so the undefsyms_order array is used.
	 */
	hint = (struct twolevel_hint *)(output_addr +
			output_hints_info.twolevel_hints_command.offset);
	if(output_for_dyld && twolevel_namespace == TRUE &&
	   twolevel_namespace_hints == TRUE){
	    for(i = 0; i < output_dysymtab_info.dysymtab_command.nundefsym;i++){
		merged_symbol = undefsyms_order[i];
		hint->isub_image = merged_symbol->definition_object->isub_image;
		hint->itoc = merged_symbol->itoc;
		hint++;
	    }
	    if(host_byte_sex != target_byte_sex){
		hint = (struct twolevel_hint *)(output_addr +
			    output_hints_info.twolevel_hints_command.offset);
		swap_twolevel_hint(hint,
			       output_dysymtab_info.dysymtab_command.nundefsym,
			       target_byte_sex);
	    }
#ifndef RLD
	    output_flush(output_hints_info.twolevel_hints_command.offset,
			 output_dysymtab_info.dysymtab_command.nundefsym *
			 sizeof(struct twolevel_hint));
#endif
	}
	/*
	 * Now the undefsyms_order array is no longer needed.
	 */
	if(undefsyms_order != NULL){
	    free(undefsyms_order);
	    undefsyms_order = NULL;
	}
}

#if defined(RLD) && !defined(SA_RLD)
/*
 * output_rld_symfile_merged_symbols() copies the merged symbol table into the
 * output file for the rld symfile.  It makes all the symbols absolute.
 */
__private_extern__
void
output_rld_symfile_merged_symbols(
void)
{
    struct nlist *nlist;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;
    unsigned long string_offset;
    struct string_block **q, *string_block;
    unsigned long i;

	nlist = (struct nlist *)(output_addr +
				 output_symtab_info.symtab_command.symoff);
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if(merged_symbol->definition_object->set_num != cur_set)
		    continue;
		*nlist = merged_symbol->nlist;
		nlist->n_un.n_strx = output_symtab_info.output_merged_strsize +
				     merged_symbol_string_index(
					merged_symbol->nlist.n_un.n_name);
		nlist->n_sect = NO_SECT;
		nlist->n_type = N_ABS | N_EXT;
		nlist++;
	    }
	}

	/*
	 * Copy the merged strings into the memory buffer for the output file.
	 */
	string_offset = output_symtab_info.symtab_command.stroff +
			      output_symtab_info.output_merged_strsize;
	for(q = &(merged_string_blocks); *q; q = &(string_block->next)){
	    string_block = *q;
	    if(string_block->set_num != cur_set)
		continue;
	    memcpy(output_addr + output_symtab_info.symtab_command.stroff +
				 output_symtab_info.output_merged_strsize,
		   string_block->strings,
		   string_block->used);
	    output_symtab_info.output_merged_strsize += string_block->used;
	}
}
#endif /* defined(RLD) && !defined(SA_RLD) */

/*
 * merged_symbol_string_index() returns the string index of a merged symbol's
 * name relative to the start of the merged strings.
 */
static
unsigned long
merged_symbol_string_index(
char *symbol_name)
{
#ifndef RLD
    static struct string_block *string_block = NULL;

	if(string_block == NULL)
	    string_block = merged_string_blocks;

	if(symbol_name < string_block->strings ||
	   symbol_name >= string_block->strings + string_block->used)
	    string_block = get_string_block(symbol_name);
#else
    struct string_block *string_block;

	string_block = get_string_block(symbol_name);
#endif
	return(string_block->index + (symbol_name - string_block->strings));
}

/*
 * get_string_block() returns a pointer to the string block the specified
 * merged symbol name is in.
 */
static
struct string_block *
get_string_block(
char *symbol_name)
{
    struct string_block **p, *string_block;

	for(p = &(merged_string_blocks); *p; p = &(string_block->next)){
	    string_block = *p;
	    if(symbol_name >= string_block->strings &&
	       symbol_name < string_block->strings + string_block->used)
		return(string_block);
	}
	fatal("internal error: get_string_block() called with symbol_name (%s) "
	      "not in the string blocks", symbol_name);
	return(NULL); /* to prevent warning from compiler */
}

/*
 * process_undefineds() is called after all the dylibs have been searched in
 * layout.  It first checks for undefined symbols.  Then it sets the value of
 * nmerged_symbols_referenced_only_from_dylibs which is the number of merged
 * symbols that are only referenced from dylibs and will not appear in the
 * output file.
 */
__private_extern__
void
process_undefineds(
void)
{
    unsigned long i, j, Ycount, errors_save;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;
    enum bool printed_undef, allowed_undef, prebound_undef;
    struct object_list *object_list, **q;
#ifndef RLD
    unsigned long k;
    struct nlist *object_symbols;
    struct object_file *obj;
    struct undefined_list *undefined, *prevs;
    char *short_name;
    struct dynamic_library *dep, *lib, *prev_lib;
    unsigned long library_ordinal;
    enum bool reported, weak_ref_warning;
#endif

	errors_save = 0;
	printed_undef = FALSE;
	prebound_undef = FALSE;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		/*
		 * If the output file is not relocatable check to see if this
		 * symbol is undefined.  If it is and it is not on the allowed
		 * undefined list print it's name.
		 */
		if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
		   merged_symbol->nlist.n_value == 0){
		    /*
		     * If we are dead stripping and this undefined symbol is not
		     * live just ignore it.
		     */
		    if(dead_strip == TRUE &&
		       merged_symbol->live == FALSE)
			continue;

		    if(prebinding == TRUE){
			if(ld_trace_prebinding_disabled == TRUE)
			    print("[Logging for XBS] prebinding"
				  " disabled for %s because of undefined "
				  "symbols\n", final_output != NULL ?
		      		  final_output : outputfile);
			warning("prebinding disabled because of undefined "
				"symbols");
			prebinding = FALSE;
			prebound_undef = TRUE;
		    }
		    allowed_undef = FALSE;
		    if(nundef_syms != 0){
			for(j = 0; j < nundef_syms; j++){
			    if(strcmp(undef_syms[j],
				  merged_symbol->nlist.n_un.n_name) == 0){
				allowed_undef = TRUE;
				break;
			    }
			}
		    }
		    if(allowed_undef == FALSE)
			noundefs = FALSE;
		    if(save_reloc == FALSE &&
		       (undefined_flag == UNDEFINED_ERROR ||
			undefined_flag == UNDEFINED_WARNING)){
			if(allowed_undef == FALSE || prebound_undef == TRUE){
			    if(printed_undef == FALSE){
				if(undefined_flag == UNDEFINED_WARNING)
				    warning("undefined symbols:");
				else{
				    if(allowed_undef == TRUE &&
				       prebound_undef == TRUE)
					errors_save = errors;
				    error("Undefined symbols:");
				    if(allowed_undef == TRUE &&
				       prebound_undef == TRUE)
					errors = errors_save;
				}
				printed_undef = TRUE;
			    }
			    else if(errors == 0 &&
				    undefined_flag == UNDEFINED_ERROR &&
				    allowed_undef == FALSE){
				errors = 1;
			    }
			    print("%s\n", merged_symbol->nlist.n_un.n_name);
			}
		    }
		    else if(save_reloc == FALSE &&
			    undefined_flag == UNDEFINED_DYNAMIC_LOOKUP &&
			    twolevel_namespace == TRUE){
			SET_LIBRARY_ORDINAL(merged_symbol->nlist.n_desc,
					    DYNAMIC_LOOKUP_ORDINAL);
		    }
		}
#ifndef RLD
		else {
		    /*
		     * The merged symbol is not an undefined symbol.  But could
		     * be defined in a dynamic library as a coalesed symbol or
		     * a weak symbol.  Where a later symbol was discarded from a
		     * non_dylib.  If -twolevel_namespace is in effect this
		     * symbol, now a reference from an object, is going into
		     * the image and will need the library ordinal recorded.
		     * We need to see that this dynamic library has been
		     * assigned an ordinal (that is it was listed on the link
		     * line or is a sub-framework or sub-umbrella of
		     * something listed).  If not flag this as an illegal
		     * reference to an indirect dynamic library if this library
		     * was not flagged already.
		     */
		    if(save_reloc == FALSE &&
		       twolevel_namespace == TRUE &&
		       merged_symbol->defined_in_dylib == TRUE &&
		       merged_symbol->referenced_in_non_dylib == TRUE &&
		       merged_symbol->definition_library->
			   definition_obj->library_ordinal == 0 &&
		       merged_symbol->definition_library->
			   indirect_twolevel_ref_flagged == FALSE){
			obj = cur_obj;
			cur_obj = merged_symbol->non_dylib_referenced_obj;
			error_with_cur_obj("illegal reference to symbol: %s "
			    "defined in indirectly referenced dynamic library "
			    "%s", merged_symbol->nlist.n_un.n_name,
			    merged_symbol->definition_library->dylib_file
				!= NULL ?
			    merged_symbol->definition_library->file_name :
			    merged_symbol->definition_library->dylib_name);
			cur_obj = obj;
			merged_symbol->definition_library->
			    indirect_twolevel_ref_flagged = TRUE;
		    }
		}
#endif /* !defined(RLD) */
	    }
	}

#ifndef RLD
	/*
	 * Deal with weak references.  If we have them and the target deployment
	 * does not support them generate a warning can clear the weak reference
	 * bit.
	 */
	if(macosx_deployment_target.major <= 1){
	    weak_ref_warning = FALSE;
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				     merged_symbol_root->list;
	        merged_symbol_list != NULL;
		merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if(((merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
			 merged_symbol->nlist.n_value == 0) ||
		       (merged_symbol->nlist.n_type & N_TYPE) == N_PBUD) &&
			(merged_symbol->nlist.n_desc & N_WEAK_REF) ==
			 N_WEAK_REF){
			if(weak_ref_warning == FALSE){
			    warning("weak symbol references not set in output "
				    "with MACOSX_DEPLOYMENT_TARGET environment "
				    "variable set to: %s",
				    macosx_deployment_target.name);
			    warning("weak referenced symbols:");
			    weak_ref_warning = TRUE;
			}
			merged_symbol->nlist.n_desc &= ~(N_WEAK_REF);
			print("%s\n", merged_symbol->nlist.n_un.n_name);
		    }
		}
	    }
	}
	/*
	 * The target deployment does support weak references.
	 */
	else{
	    /*
	     * If there have been some weak reference mismatches when symbols
	     * were merged make a pass through merged symbols and for any
	     * symbols that had a weak reference mismatch that is still
	     * undefined print the error for it.
	     */
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	        merged_symbol_list != NULL;
	        merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if(merged_symbol->weak_reference_mismatch == TRUE &&
		       ((merged_symbol->nlist.n_type == (N_EXT | N_UNDF) &&
			 merged_symbol->nlist.n_value == 0) ||
		       (merged_symbol->nlist.n_type & N_TYPE) == N_PBUD) &&
		       (merged_symbol->defined_in_dylib == FALSE ||
			merged_symbol->definition_library->
						force_weak_dylib == FALSE)){
			error("mismatching weak references for symbol: %s",
			      merged_symbol->nlist.n_un.n_name);
			for(q = &objects; *q; q = &(object_list->next)){
			    object_list = *q;
			    for(j = 0; j < object_list->used; j++){
				cur_obj = &(object_list->object_files[j]);
				if(cur_obj->dylib && cur_obj->dylib_module ==
						     NULL)
				    continue;
				if(cur_obj->bundle_loader)
				    continue;
				if(cur_obj->dylinker)
				    continue;
				for(k = 0; k < cur_obj->nundefineds; k++){
				    if(merged_symbol == cur_obj->
				       undefined_maps[k].merged_symbol){
					print_obj_name(cur_obj);
					object_symbols = (struct nlist *)
					    (cur_obj->obj_addr +
					     cur_obj->symtab->symoff);
					if((object_symbols[
					    cur_obj->undefined_maps[
					    k].index].n_desc & N_WEAK_REF) ==
					    N_WEAK_REF)
					    print("reference to weak %s\n",
					      merged_symbol->nlist.n_un.n_name);
					else
					    print("reference to non-weak %s\n",
					      merged_symbol->nlist.n_un.n_name);
				    }
				}
			    }
			}
		    }
		}
	    }
	}
#endif /* !defined(RLD) */

#ifndef RLD
	lib = NULL;
	prev_lib = NULL;
	/*
	 * There can be two-level references left on the undefined list.  These
	 * are "fake" merged symbols as they are not entered in the symbol
	 * merged table so the will not be reported in the above loop.  There
	 * can be many references to the same symbol expected to be defined in
	 * ( a specific library (from many different modules).
	 */
	for(undefined = undefined_list.next;
	    undefined != &undefined_list;
	    undefined = undefined->next){
	    if(undefined->merged_symbol->twolevel_reference == TRUE){
		/*
		 * Avoid printing the same undefined symbol expected from a
		 * a specific library more then once by checking if we have
		 * already reported this symbol before.  This is very slow
		 * method but this is an error case.
		 */
		library_ordinal = GET_LIBRARY_ORDINAL(
				    undefined->merged_symbol->nlist.n_desc);
		if(library_ordinal == SELF_LIBRARY_ORDINAL)
		    lib = undefined->merged_symbol->referencing_library;
		/*
		 * Note that if library_ordinal was DYNAMIC_LOOKUP_ORDINAL then
		 * merge_dylib_module_symbols() in symbols.c would not have
		 * set the twolevel_reference field to TRUE in the merged_symbol
		 * and if we get here it with this it is an internal error.
		 */
		else if(library_ordinal == DYNAMIC_LOOKUP_ORDINAL)
		    fatal("internal error: process_undefineds() 1 with a "
			  "merged_symbol (%s) on the undefined list with "
			  "twolevel_reference == TRUE and library_ordinal == "
			  "DYNAMIC_LOOKUP_ORDINAL", undefined->merged_symbol->
			  nlist.n_un.n_name);
		else
		    lib = undefined->merged_symbol->referencing_library->
			    dependent_images[library_ordinal - 1];
		reported = FALSE;
		for(prevs = undefined_list.next;
		    prevs != undefined;
		    prevs = prevs->next){
		    if(prevs->merged_symbol->twolevel_reference == FALSE)
			continue;
		    library_ordinal = GET_LIBRARY_ORDINAL(
					prevs->merged_symbol->nlist.n_desc);
		    if(library_ordinal == SELF_LIBRARY_ORDINAL)
			prev_lib = prevs->merged_symbol->referencing_library;
		    /*
		     * Note that if library_ordinal was DYNAMIC_LOOKUP_ORDINAL
		     * then merge_dylib_module_symbols() in symbols.c would not
		     * have set the twolevel_reference field to TRUE in the
		     * merged_symbol and if we get here it with this it is an
		     * internal error.
		     */
		    else if(library_ordinal == DYNAMIC_LOOKUP_ORDINAL)
			fatal("internal error: process_undefineds() 2 with a "
			      "merged_symbol (%s) on the undefined list with "
			      "twolevel_reference == TRUE and library_ordinal "
			      "== DYNAMIC_LOOKUP_ORDINAL",
			      prevs->merged_symbol->nlist.n_un.n_name);
		    else
			prev_lib = prevs->merged_symbol->referencing_library->
				dependent_images[library_ordinal - 1];
		    if(lib == prev_lib &&
		       strcmp(undefined->merged_symbol->nlist.n_un.n_name,
			      prevs->merged_symbol->nlist.n_un.n_name) == 0){
			reported = TRUE;
			break;
		    }
		}
		if(reported == FALSE){
		    /*
		     * Since these are undefined two-level references they are
		     * never allowed and always cause an error.
		     */
		    if(printed_undef == FALSE){
			error("Undefined symbols:");
			printed_undef = TRUE;
		    }
		    print("%s ", undefined->merged_symbol->nlist.n_un.n_name);
		    dep = undefined->merged_symbol->referencing_library;
		    if(dep->umbrella_name != NULL)
			short_name = dep->umbrella_name;
		    else if(dep->library_name != NULL)
			short_name = dep->library_name;
		    else
			short_name = dep->dylib_name;
		    print("referenced from %s ", short_name);
		    if(lib->umbrella_name != NULL)
			short_name = lib->umbrella_name;
		    else if(lib->library_name != NULL)
			short_name = lib->library_name;
		    else
			short_name = lib->dylib_name;
		    print("expected to be defined in %s\n", short_name);
		}
	    }
	}
#endif /* !defined(RLD) */

	if(printed_undef == TRUE && Yflag != 0){
	    Ycount = 0;
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    cur_obj = &(object_list->object_files[i]);
		    if(cur_obj->dylib)
			continue;
		    if(cur_obj->bundle_loader)
			continue;
		    if(cur_obj->dylinker)
			continue;
		    for(j = 0; j < cur_obj->nundefineds; j++){
			merged_symbol =
			    cur_obj->undefined_maps[j].merged_symbol;
			if(merged_symbol == NULL ||
			   merged_symbol->twolevel_reference == TRUE)
			    continue;
			if(merged_symbol->nlist.n_type == (N_EXT|N_UNDF) &&
			   merged_symbol->nlist.n_value == 0){
			    if(Ycount >= Yflag){
				print("more references to undefined "
				      "symbols ...\n");
				goto done;
			    }
			    print_obj_name(cur_obj);
			    print("%sreference to undefined %s",
				  merged_symbol->nlist.n_desc & N_WEAK_REF ?
				  "weak " : "",
				  merged_symbol->nlist.n_un.n_name);
#ifndef RLD
			    library_ordinal = GET_LIBRARY_ORDINAL(
					       merged_symbol->nlist.n_desc);
			    if(merged_symbol->twolevel_reference == TRUE &&
			       library_ordinal != DYNAMIC_LOOKUP_ORDINAL){
				if(library_ordinal == SELF_LIBRARY_ORDINAL)
				    lib = merged_symbol->referencing_library;
				else
				    lib = merged_symbol->referencing_library->
					  dependent_images[library_ordinal - 1];
				if(lib->umbrella_name != NULL)
				    short_name = lib->umbrella_name;
				else if(lib->library_name != NULL)
				    short_name = lib->library_name;
				else
				    short_name = lib->dylib_name;
				print(" expected to be defined in %s\n",
				      short_name);
			    }
			    else
#endif /* !defined(RLD) */
				print("\n");
			    Ycount++;
			}
		    }
		}
	    }
	}
done:
	/*
	 * Determine the number of merged symbols that are only referenced from
	 * dylibs.  These will not be in the output file so this count is need
	 * so the number of merged symbols in the output file is know for
	 * laying out the output file.
	 */
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		/*
		 * If this symbol is only referenced from a dylib then it will
		 * not be in the file's output.
		 */
		if(merged_symbol->referenced_in_non_dylib == FALSE)
		    nmerged_symbols_referenced_only_from_dylibs++;
	    }
	}
}

#ifndef RLD
/*
 * reset_prebound_undefines() resets the prebound undefined symbols back to
 * undefined symbols if prebinding is not to be done.
 */
__private_extern__
void
reset_prebound_undefines(
void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol, *indr_symbol;

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if((merged_symbol->nlist.n_type & N_TYPE) == N_PBUD){
		    /*
		     * If not prebinding then reset this prebound undefined
		     * to an undefined symbol.
		     */
		    if(prebinding == FALSE){
			merged_symbol->nlist.n_type = N_UNDF | N_EXT;
			merged_symbol->nlist.n_value = 0;
			merged_symbol->nlist.n_desc &= ~REFERENCED_DYNAMICALLY;
		    }
		}
		else if(merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		        merged_symbol->defined_in_dylib == TRUE){
		    /*
		     * If not prebinding then reset this indirect symbol that
		     * was defined in a dylib back to an undefined symbol.
		     */
		    if(prebinding == FALSE){
			merged_symbol->nlist.n_type = N_UNDF | N_EXT;
			merged_symbol->nlist.n_value = 0;
			merged_symbol->nlist.n_desc &= ~REFERENCED_DYNAMICALLY;
		    }
		    else{
			/*
			 * When prebinding if the indirect symbol is defined
			 * (not an undefined of common) then change the indirect
			 * symbol to a prebound undefined using the value of the
			 * indr symbol.  Else make it an undefined symbol.
			 */
			indr_symbol = (struct merged_symbol *)
				      (merged_symbol->nlist.n_value);
			if(indr_symbol->nlist.n_type != (N_EXT | N_UNDF)){
			    merged_symbol->nlist.n_type = N_PBUD | N_EXT;
			    merged_symbol->nlist.n_sect = NO_SECT;
			    /*
			     * Do not change the n_desc of the symbol as it
			     * contains the proper LAZY or NON-LAZY reference
			     * bits as well as the REFERENCED_DYNAMICALLY bit.
			     */
			    merged_symbol->nlist.n_value =
						    indr_symbol->nlist.n_value;
			}
			else{
			    merged_symbol->nlist.n_type = N_UNDF | N_EXT;
			    merged_symbol->nlist.n_value = 0;
			    merged_symbol->nlist.n_desc &=
							~REFERENCED_DYNAMICALLY;
			}
		    }
		}
	    }
	}
}
#endif /* !defined(RLD) */

/*
 * assign_output_symbol_indexes() assigns the symbol indexes to all symbols in
 * the output file based on the type of output file (MH_DYLIB or not).  The
 * difference for the MH_DYLIB format is that the external symbol are grouped
 * by the module they are defined in instead of being sorted by symbol name.
 * The order of the symbol table is as follows:
 * 	Local Symbols
 *	    Grouped by the module they are defined in
 *		sect_object_symbol (if specified)
 *		local symbols in the same order as the input module
 *		private_extern symbols (if -keep_private_externs is FALSE)
 *	Exterally defined Symbols
 *	    Sorted by name for non-MH_DYLIB format
 *	    Grouped by the module they are defined in for MH_DYLIB format
 *	Undefinded Symbols
 *	    Sorted by name
 */
__private_extern__
void
assign_output_symbol_indexes(
void)
{
    unsigned long index, i, nextdefsym, nundefsym, n_pext;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol, *indr_symbol;
    struct object_list *object_list, **q;
    struct object_file *last_object;
    enum bool rebuild_merged_string_table;

	rebuild_merged_string_table = FALSE;
	if(strip_level == STRIP_ALL){
	    if(has_dynamic_linker_command){
		strip_level = STRIP_DYNAMIC_EXECUTABLE;
		/*
		 * In order to not put out strings for merged symbols that will
		 * be discared we need to rebuild the merged string table for
		 * only the symbols not stripped.
		 */
		merged_string_blocks = NULL;
		merged_string_size = 0;
		rebuild_merged_string_table = TRUE;
		/*
		 * The value of nstripped_merged_symbols is reset here since we
		 * are setting the strip_level to STRIP_DYNAMIC_EXECUTABLE.
		 * This routine will then increment nstripped_merged_symbols
		 * for the symbols to be stripped. It may have previouly held
		 * the count of dead symbols to strip if -dead_strip was
		 * specified. We start with the the number of dead stripped
		 * merged private symbols then add the live merged symbols to
		 * strip.  This works since any symbol to be saved with
		 * STRIP_DYNAMIC_EXECUTABLE would also be live since it would
		 * have REFERENCED_DYNAMICALLY set.  Except for undefined
		 * symbols, so if -dead_strip is specified and the undefined
		 * symbol is not live then nstripped_merged_symbols
		 * is incremented to account for these.
		 */
		nstripped_merged_symbols = nstripped_merged_private_symbols;
	    }
	    else{
		seglinkedit = FALSE;
		return;
	    }
	}
	/*
	 * If we are stripping non-globals and we are not keeping private
	 * externs and we have some private externs in the merged symbol table,
	 * and the output is not a multi-module dylib, then in order to not put
	 * out strings for them we also need to rebuild the merged string table
	 * without these symbols.
	 */
	else if(strip_level == STRIP_NONGLOBALS &&
		keep_private_externs == FALSE &&
		nmerged_private_symbols != 0 &&
		(filetype != MH_DYLIB || multi_module_dylib == FALSE)){
	    merged_string_blocks = NULL;
	    merged_string_size = 0;
	    rebuild_merged_string_table = TRUE;
	}

	/*
	 * Add a copy of the object file for the common symbols that the link
	 * editor allocated into the object file list.  Since it is possible
	 * that some of the common symbols are not on the export list they could
	 * have been made into private externs.
	 */
	last_object = add_last_object_file(&link_edit_common_object);

	/*
	 * Private exterals are always kept when any symbols are kept (except in
	 * the case of STRIP_DYNAMIC_EXECUTABLE).  The private externals on the
	 * merged symbol list may be kept as local symbols or external depending
	 * on the keep_private_externs flag. Private externals that are local
	 * symbols (no N_EXT bit set) are always counted in the
	 * cur_obj->nlocalsym unless the strip level is STRIP_ALL.
	 */

	/*
	 * Note if -dead_strip is specified the values of the nlocalsym and
	 * nprivatesym fields in the object_file structs were previously
	 * adjusted to account for only the live symbols in
	 * count_live_symbols().
	 */

	index = 0;
	output_dysymtab_info.dysymtab_command.ilocalsym = index;
	/*
	 * Set the indexes into the symbol table for local symbols.
	 * Private exterals are counted as local symbols if keep_private_externs
	 * is FALSE.
	 */
	for(q = &objects; *q; q = &(object_list->next)){
	    object_list = *q;
	    for(i = 0; i < object_list->used; i++){
		cur_obj = &(object_list->object_files[i]);
		if(cur_obj->dylib)
		    continue;
		if(cur_obj->bundle_loader)
		    continue;
		if(cur_obj->dylinker)
		    continue;
#ifdef RLD
		/*
		 * If this object is not from the current set
		 * don't count these.
		 */
		if(cur_obj->set_num != cur_set)
		    continue;
#endif /* RLD */
		cur_obj->ilocalsym = index;
/*
print_obj_name(cur_obj);
print(" cur_obj->nlocalsym %lu\n", cur_obj->nlocalsym);
*/
		index += cur_obj->nlocalsym;

		if(keep_private_externs == FALSE){
		    cur_obj->iprivatesym = index;
		    cur_obj->cprivatesym = index;
		    if(strip_level != STRIP_DYNAMIC_EXECUTABLE &&
		       (strip_level != STRIP_NONGLOBALS ||
			(filetype == MH_DYLIB && multi_module_dylib == TRUE))){
			index += cur_obj->nprivatesym;
/*
print(" adding cur_obj->nprivatesym %lu to index\n", cur_obj->nprivatesym);
*/
		    }
		    else{
			nstripped_merged_symbols +=
			    cur_obj->nprivatesym;
			nstripped_merged_private_symbols +=
			    cur_obj->nprivatesym;
/*
print("assign_output_symbol_indexes() adding cur_obj->nprivatesym %lu to nstripped_merged_symbols\n", cur_obj->nprivatesym);
*/
		    }
		}
	    }
	}
	/*
	 * Check to make sure the counts are consistent.
	 */
	if((keep_private_externs == TRUE && index != nlocal_symbols) ||
	   (keep_private_externs == FALSE && index != nlocal_symbols +
	    nmerged_private_symbols - nstripped_merged_private_symbols))
		fatal("internal error: assign_output_symbol_indexes() "
		      "inconsistent local symbol counts");
	output_dysymtab_info.dysymtab_command.nlocalsym = index;

	/*
	 * Copy the values that got set in the above loop back into the
	 * object file for the the common symbols.  Then remove the copy of
	 * the object file from the object file list.
	 */
	link_edit_common_object = *last_object;
	remove_last_object_file(last_object);


	/*
	 * Count the number of undefined symbols and defined external symbols.
	 * Private exterals are counted as defined externals if
	 * keep_private_externs is TRUE.
	 */
	nundefsym = 0;
	nextdefsym = 0;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if(merged_symbol->referenced_in_non_dylib == FALSE)
		    continue;
		if(strip_base_symbols == TRUE &&
		   merged_symbol->definition_object == base_obj)
		    continue;
#ifdef RLD
		if(merged_symbol->definition_object->set_num != cur_set)
		    continue;
#endif /* RLD */
		/*
		 * The value of nstripped_merged_symbols is recalculated if we
		 * set the strip_level to STRIP_DYNAMIC_EXECUTABLE in the case
		 * -dead_strip is specified.
		 */
		if(strip_level != STRIP_DYNAMIC_EXECUTABLE &&
		   dead_strip == TRUE && merged_symbol->live == FALSE)
		    continue;
		if((merged_symbol->nlist.n_type & N_EXT) == N_EXT &&
		   ((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF ||
		    (merged_symbol->nlist.n_type & N_TYPE) == N_PBUD) |
		   (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		    merged_symbol->defined_in_dylib == TRUE)){
		    if(dead_strip == FALSE || merged_symbol->live == TRUE){
			nundefsym++;
			if(rebuild_merged_string_table == TRUE)
			    merged_symbol->nlist.n_un.n_name =
				enter_string(merged_symbol->nlist.n_un.n_name,
					     NULL);
		    }
		    else{
/*
printf("assign_output_symbol_indexes() nstripped_merged_symbols incremented for undefined %s\n", merged_symbol->nlist.n_un.n_name);
*/
			nstripped_merged_symbols++;
		    }
		}
		else{
		    if(merged_symbol->nlist.n_type == (N_EXT | N_INDR)){
			indr_symbol = (struct merged_symbol *)
				    (merged_symbol->nlist.n_value);
			n_pext = indr_symbol->nlist.n_type & N_PEXT;
		    }
		    else{
			n_pext = merged_symbol->nlist.n_type & N_PEXT;
		    }
		    if(keep_private_externs == TRUE || n_pext == 0){
			if(strip_level != STRIP_DYNAMIC_EXECUTABLE ||
			   (merged_symbol->nlist.n_desc &
			    REFERENCED_DYNAMICALLY) == REFERENCED_DYNAMICALLY){
			    nextdefsym++;
			    if(rebuild_merged_string_table == TRUE)
				merged_symbol->nlist.n_un.n_name =
				    enter_string(merged_symbol->
						 nlist.n_un.n_name, NULL);
			}
			else{
/*
printf("assign_output_symbol_indexes() nstripped_merged_symbols incremented for %s\n", merged_symbol->nlist.n_un.n_name);
*/
			    nstripped_merged_symbols++;
			}
		    }
		}
	    }
	}

	/*
	 * Allocate arrays to order the undefined symbols and defined external
	 * symbols.
	 */
	undefsyms_order  = allocate(nundefsym *
				    sizeof(struct merged_symbol *));
	extdefsyms_order = allocate(nextdefsym *
				    sizeof(struct merged_symbol *));
	/*
	 * Fill in the arrays with their respective symbols.
	 */
	nundefsym = 0;
	nextdefsym = 0;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if(merged_symbol->referenced_in_non_dylib == FALSE)
		    continue;
		if(strip_base_symbols == TRUE &&
		   merged_symbol->definition_object == base_obj)
		    continue;
#ifdef RLD
		if(merged_symbol->definition_object->set_num != cur_set)
		    continue;
#endif /* RLD */
		if(dead_strip == TRUE && merged_symbol->live == FALSE)
		    continue;
		if(((merged_symbol->nlist.n_type & N_EXT) == N_EXT &&
		    ((merged_symbol->nlist.n_type & N_TYPE) == N_UNDF ||
		     (merged_symbol->nlist.n_type & N_TYPE) == N_PBUD)) ||
		   (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
		    merged_symbol->defined_in_dylib == TRUE))
		    undefsyms_order[nundefsym++] = merged_symbol;
		else{
		    if(merged_symbol->nlist.n_type == (N_EXT | N_INDR)){
			indr_symbol = (struct merged_symbol *)
				    (merged_symbol->nlist.n_value);
			n_pext = indr_symbol->nlist.n_type & N_PEXT;
		    }
		    else{
			n_pext = merged_symbol->nlist.n_type & N_PEXT;
		    }
		    if(keep_private_externs == TRUE || n_pext == 0){
			if(strip_level != STRIP_DYNAMIC_EXECUTABLE ||
			   (merged_symbol->nlist.n_desc &
			    REFERENCED_DYNAMICALLY) == REFERENCED_DYNAMICALLY){
			    extdefsyms_order[nextdefsym++] = merged_symbol;
			}
			else{
			    if((merged_symbol->nlist.n_type & N_TYPE) == N_ABS)
				merged_symbol->output_index =
				    INDIRECT_SYMBOL_ABS | INDIRECT_SYMBOL_LOCAL;
			    else
				merged_symbol->output_index =
				    INDIRECT_SYMBOL_LOCAL;
			}
		    }
		}
	    }
	}
#ifndef SA_RLD
	/*
	 * Sort the defined symbols by module for MH_DYLIB formats and by
	 * name for other formats.
	 */
	if(filetype == MH_DYLIB)
	    qsort(extdefsyms_order, nextdefsym, sizeof(struct merged_symbol *),
		  (int (*)(const void *, const void *))qsort_by_module);
	else
	    qsort(extdefsyms_order, nextdefsym, sizeof(struct merged_symbol *),
		  (int (*)(const void *, const void *))qsort_by_name);
	/*
	 * Sort the undefined symbols.  If we are doing bind_at_load then sort
	 * them by the order the symbols were seen else sort them by name.
	 */
	if(bind_at_load == TRUE)
	    qsort(undefsyms_order, nundefsym, sizeof(struct merged_symbol **),
		  (int (*)(const void *, const void *))qsort_by_undef_order);
	else
	    qsort(undefsyms_order, nundefsym, sizeof(struct merged_symbol **),
		  (int (*)(const void *, const void *))qsort_by_name);
#endif /* !defined(SA_RLD) */

	/*
	 * Assign the symbol indexes to the defined symbols.
	 */
	output_dysymtab_info.dysymtab_command.iextdefsym = index;
	output_dysymtab_info.dysymtab_command.nextdefsym = nextdefsym;
	cur_obj = NULL;
	for(i = 0; i < nextdefsym; i++){
	    if(filetype == MH_DYLIB){
		if(cur_obj != extdefsyms_order[i]->definition_object){
		    cur_obj = extdefsyms_order[i]->definition_object;
		    cur_obj->iextdefsym = index;
		}
	    }
	    extdefsyms_order[i]->output_index = index++;
	}

	/*
	 * Assign the symbol indexes to the undefined symbols.
	 */
	output_dysymtab_info.dysymtab_command.iundefsym = index;
	output_dysymtab_info.dysymtab_command.nundefsym = nundefsym;
	for(i = 0; i < nundefsym; i++){
	    undefsyms_order[i]->output_index = index++;
	}

	/*
	 * If -twolevel_namespace is in effect set the number of the two-level
	 * hints in the hints table to the number of undefined symbols.
	 */
	if(twolevel_namespace == TRUE)
	    output_hints_info.twolevel_hints_command.nhints = nundefsym;

	/*
	 * Assign the symbol indexes to the private extern symbols if they are
	 * turned into local symbols.
	 */
	if(nmerged_private_symbols != 0 && keep_private_externs == FALSE){
	    cur_obj = NULL;
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				     merged_symbol_root->list;
		merged_symbol_list != NULL;
		merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if(merged_symbol->referenced_in_non_dylib == FALSE)
			continue;
		    if(strip_base_symbols == TRUE &&
		       merged_symbol->definition_object == base_obj)
			continue;
#ifdef RLD
		    if(merged_symbol->definition_object->set_num != cur_set)
			continue;
#endif /* RLD */
		    if(dead_strip == TRUE && merged_symbol->live == FALSE)
			continue;
		    if(merged_symbol->nlist.n_type & N_PEXT){
			merged_symbol->output_index =
				merged_symbol->definition_object->cprivatesym++;
		    }
		}
	    }
	}
}

#ifndef SA_RLD
/*
 * qsort_by_module() is used by assign_output_symbol_indexes() to sort (in
 * this case group) the defined external symbols by the module they are defined
 * in for the MH_DYLIB format.
 */
static
int
qsort_by_module(
const struct merged_symbol **ms1,
const struct merged_symbol **ms2)
{
	return((int)((*ms1)->definition_object) -
	       (int)((*ms2)->definition_object));
}

/*
 * qsort_by_name() is used by assign_output_symbol_indexes() to sort the
 * the defined external symbols and the undefined symbols by symbol name.
 */
static
int
qsort_by_name(
const struct merged_symbol **ms1,
const struct merged_symbol **ms2)
{
	return(strcmp((*ms1)->nlist.n_un.n_name, (*ms2)->nlist.n_un.n_name));
}

/*
 * qsort_by_undef_order() is used by assign_output_symbol_indexes() to sort the
 * the undefined symbols by the order the undefined symbol appeared.
 */
static
int
qsort_by_undef_order(
const struct merged_symbol **ms1,
const struct merged_symbol **ms2)
{
	return(((*ms1)->undef_order - (*ms2)->undef_order));
}

/*
 * merged_symbol_output_index() returns the index in the output file's symbol
 * table for the merged_symbol pointer passed to it.
 */
__private_extern__
unsigned long
merged_symbol_output_index(
struct merged_symbol *merged_symbol)
{
    return(merged_symbol->output_index);
}
#endif /* !defined(SA_RLD) */

#ifndef RLD
/*
 * This is a pointer to the module name saved in the merged string table for
 * the one module table entry for a single module dylib.
 */
char *dylib_single_module_name;

/*
 * layout_dylib_tables() sizes and readys the tables for a dynamic library file.
 * The merged symbol indexes have already been assigned before this is called.
 * There are three tables:
 *	The reference table
 *	The module table
 *	The table of contents
 */
__private_extern__
void
layout_dylib_tables(
void)
{
    unsigned long i, j, flags;
    struct merged_symbol *merged_symbol;
    struct object_list *object_list, **q;
    char *p;

	if(multi_module_dylib == TRUE){
	    /*
	     * For multi module dylibs the reference table was sized as the
	     * symbols were merged.  All that is left to do for the reference
	     * table is to adjust the flags for undefined references that ended
	     * up referencing private externs.
	     */
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    cur_obj = &(object_list->object_files[i]);
		    if(cur_obj->dylib)
			continue;
		    if(cur_obj->bundle_loader)
			continue;
		    if(cur_obj->dylinker)
			continue;
		    for(j = 0; j < cur_obj->nrefsym; j++){
			merged_symbol =
			    cur_obj->reference_maps[j].merged_symbol;
			if(merged_symbol->nlist.n_type & N_PEXT){
			    flags = cur_obj->reference_maps[j].flags;
			    if(flags == REFERENCE_FLAG_UNDEFINED_NON_LAZY)
				cur_obj->reference_maps[j].flags =
				    REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY;
			    else if(flags == REFERENCE_FLAG_UNDEFINED_LAZY)
				cur_obj->reference_maps[j].flags =
				    REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY;
			}
			else{
			    /*
			     * The merged symbol is not a private extern. So it
			     * might be a non-weak symbol that is being used and
			     * some weak private externs refs were discarded.
			     * If so we need to make the refs non-weak.
			     */
			    flags = cur_obj->reference_maps[j].flags;
			    if(flags ==
			       REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY)
				cur_obj->reference_maps[j].flags =
				    REFERENCE_FLAG_UNDEFINED_NON_LAZY;
			    else if(flags ==
				    REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY)
				cur_obj->reference_maps[j].flags =
				    REFERENCE_FLAG_UNDEFINED_LAZY;
			}
		    }
		}
	    }
	}
	else{
	    /*
	     * For single module dylibs the reference table size is reset here
	     * from the defined and undefined merged symbols.  The contents of
	     * the reference table for single module dylibs will be filled in
	     * output_dylib_tables() from the merged symbol table.
	     */
	    output_dysymtab_info.dysymtab_command.nextrefsyms =
		output_dysymtab_info.dysymtab_command.nextdefsym +
		output_dysymtab_info.dysymtab_command.nundefsym;
	}

	if(multi_module_dylib == TRUE){
	    /*
	     * For multi module dylibs the module table is sized from the number
	     * of modules loaded.  The module_name of each module in the dynamic
	     * shared library is set from base name or archive member name of
	     * the object loaded.  The string for the module_name is then saved
	     * with the merged strings so that it can be converted to a string
	     * table index on output.
	     */
	    output_dysymtab_info.dysymtab_command.nmodtab = 0;
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    cur_obj = &(object_list->object_files[i]);
		    if(cur_obj->dylib == TRUE)
			continue;
		    if(cur_obj->bundle_loader == TRUE)
			continue;
		    cur_obj->imodtab =
			output_dysymtab_info.dysymtab_command.nmodtab;
		    output_dysymtab_info.dysymtab_command.nmodtab++;
		    if(cur_obj->ar_hdr){
			p = allocate(cur_obj->ar_name_size + 1);
			memcpy(p, cur_obj->ar_name, cur_obj->ar_name_size);
			p[cur_obj->ar_name_size] = '\0';
			cur_obj->module_name = enter_string(p, NULL);
			free(p);
		    }
		    else{
			p = strrchr(cur_obj->file_name, '/');
			if(p != NULL)
			    p++;
			else
			    p = cur_obj->file_name;
			cur_obj->module_name = enter_string(p, NULL);
		    }
		}
	    }
	}
	else{
	    /*
	     * For single module dylibs there is one module table entry.
	     * The module_name is set to "single module".  The string for the
	     * module_name is then saved with the merged strings so that it can
	     * be converted to a string table index on output.
	     */
	    output_dysymtab_info.dysymtab_command.nmodtab = 1;
	    dylib_single_module_name = enter_string("single module", NULL);
	}

	/*
	 * The table of contents is sized from the number of defined external
	 * symbols.
	 */
	output_dysymtab_info.dysymtab_command.ntoc =
	    output_dysymtab_info.dysymtab_command.nextdefsym;
}

/*
 * output_dylib_tables() outputs the tables for a dynamic library file.
 * There are three tables:
 *	The reference table
 *	The module table
 *	The table of contents
 */
__private_extern__
void
output_dylib_tables(
void)
{
    unsigned long i, j, flush_offset, ntoc;
    struct object_list *object_list, **q;
    struct dylib_reference *ref, *refs;
    struct dylib_module *mod, *mods;
    struct merged_symbol **toc_order;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;
    struct dylib_table_of_contents *tocs, *toc;
    struct merged_section *ms;

	/*
	 * Output the reference table.
	 */
	flush_offset = output_dysymtab_info.dysymtab_command.extrefsymoff;
	refs = (struct dylib_reference *)(output_addr + flush_offset);
	ref = refs;
	if(multi_module_dylib == TRUE){
	    /*
	     * For multi module dylibs there is a reference table for each
	     * object loaded built from the reference_maps.
	     */
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    cur_obj = &(object_list->object_files[i]);
		    if(cur_obj->dylib)
			continue;
		    if(cur_obj->bundle_loader)
			continue;
		    if(cur_obj->dylinker)
			continue;
		    for(j = 0; j < cur_obj->nrefsym; j++){
			ref->isym = merged_symbol_output_index(
				    cur_obj->reference_maps[j].merged_symbol);
			ref->flags = cur_obj->reference_maps[j].flags;
			ref++;
		    }
		}
	    }
	}
	else{
	    /*
	     * For single module dylibs there is one reference table and it is
	     * built from the merged symbol table.
	     */
	    for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				     merged_symbol_root->list;
		merged_symbol_list != NULL;
		merged_symbol_list = merged_symbol_list->next){
		for(i = 0; i < merged_symbol_list->used; i++){
		    merged_symbol = merged_symbol_list->symbols[i];
		    if(merged_symbol->referenced_in_non_dylib == FALSE)
			continue;
		    if(dead_strip == TRUE && merged_symbol->live == FALSE)
			continue;
		    if(merged_symbol->nlist.n_type == (N_EXT | N_UNDF) ||
		       merged_symbol->nlist.n_type == (N_EXT | N_PBUD) ||
		       (merged_symbol->nlist.n_type == (N_EXT | N_INDR) &&
			merged_symbol->defined_in_dylib == TRUE)){
			ref->isym = merged_symbol_output_index(merged_symbol);
			ref->flags = merged_symbol->nlist.n_desc &
				     REFERENCE_TYPE;
			ref++;
		    }
		    else if((merged_symbol->nlist.n_type & N_PEXT) == 0){
			ref->isym = merged_symbol_output_index(merged_symbol);
			ref->flags = REFERENCE_FLAG_DEFINED;
			ref++;
		    }
		}
	    }
	}
	if(host_byte_sex != target_byte_sex){
	    swap_dylib_reference(refs,
			    output_dysymtab_info.dysymtab_command.nextrefsyms,
			    target_byte_sex);
	}
	output_flush(flush_offset,
		     output_dysymtab_info.dysymtab_command.nextrefsyms *
		     sizeof(struct dylib_reference));

	/*
	 * Output the module table.
	 */
	flush_offset = output_dysymtab_info.dysymtab_command.modtaboff;
	mods = (struct dylib_module *)(output_addr + flush_offset);
	mod = mods;
	if(multi_module_dylib == TRUE){
	    /*
	     * For multi module dylibs there is a module table for each
	     * object loaded built from the info saved in the object struct.
	     */
	    for(q = &objects; *q; q = &(object_list->next)){
		object_list = *q;
		for(i = 0; i < object_list->used; i++){
		    cur_obj = &(object_list->object_files[i]);
		    if(cur_obj->dylib == TRUE)
			continue;
		    if(cur_obj->bundle_loader == TRUE)
			continue;
		    mod->module_name = STRING_SIZE_OFFSET +
			       merged_symbol_string_index(cur_obj->module_name);
		    mod->iextdefsym = cur_obj->iextdefsym;
		    mod->nextdefsym = cur_obj->nextdefsym;

		    mod->nrefsym = cur_obj->nrefsym;
		    if(mod->nrefsym == 0)
    			mod->irefsym = 0;
		    else
			mod->irefsym = cur_obj->irefsym;

		    mod->nlocalsym = cur_obj->nlocalsym + cur_obj->nprivatesym;
		    if(mod->nlocalsym == 0)
			mod->ilocalsym = 0;
		    else
			mod->ilocalsym = cur_obj->ilocalsym;

		    mod->nextrel = cur_obj->nextrel;
		    if(mod->nextrel == 0)
			mod->iextrel = 0;
		    else
			mod->iextrel    = cur_obj->iextrel;

		    mod->ninit_nterm = (cur_obj->nterm << 16) | cur_obj->ninit;
		    if(cur_obj->ninit == 0)
			cur_obj->iinit = 0;
		    if(cur_obj->nterm == 0)
			cur_obj->iterm = 0;
		    mod->iinit_iterm = (cur_obj->iterm << 16) | cur_obj->iinit;
		    if(cur_obj->objc_module_info != NULL){
			mod->objc_module_info_addr =
			    cur_obj->objc_module_info->output_section->s.addr +
			    cur_obj->objc_module_info->offset;
			mod->objc_module_info_size =
			    cur_obj->objc_module_info->s->size;
		    }
		    else{
			mod->objc_module_info_addr = 0;
			mod->objc_module_info_size = 0;
		    }
		    mod++;
		}
	    }
	}
	else{
	    /*
	     * For single module dylibs there is one module table entry.
	     */
	    mod->module_name = STRING_SIZE_OFFSET +
			   merged_symbol_string_index(dylib_single_module_name);
	    mod->iextdefsym =
		output_dysymtab_info.dysymtab_command.iextdefsym;
	    mod->nextdefsym =
		output_dysymtab_info.dysymtab_command.nextdefsym;
	    mod->irefsym = 0;
	    mod->nrefsym =
		output_dysymtab_info.dysymtab_command.nextrefsyms;
	    mod->ilocalsym =
		output_dysymtab_info.dysymtab_command.ilocalsym;
	    mod->nlocalsym =
		output_dysymtab_info.dysymtab_command.nlocalsym;
	    mod->iextrel = 0;
	    mod->nextrel =
		output_dysymtab_info.dysymtab_command.nextrel;
	    mod->iinit_iterm = 0;
	    mod->ninit_nterm = (nterm << 16) | ninit;
	    ms = lookup_merged_section(SEG_OBJC, SECT_OBJC_MODULES);
	    if(ms != NULL){
		mod->objc_module_info_addr = ms->s.addr;
		mod->objc_module_info_size = ms->s.size;
	    }
	    else{
		mod->objc_module_info_addr = 0;
		mod->objc_module_info_size = 0;
	    }
	}
	if(host_byte_sex != target_byte_sex){
	    swap_dylib_module(mods,
			      output_dysymtab_info.dysymtab_command.nmodtab,
			      target_byte_sex);
	}
	output_flush(flush_offset,
		     output_dysymtab_info.dysymtab_command.nmodtab *
		     sizeof(struct dylib_module));

	/*
	 * Output the table of contents.
	 */
	toc_order = allocate(output_dysymtab_info.dysymtab_command.ntoc *
			     sizeof(struct merged_symbol *));
	ntoc = 0;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if(merged_symbol->referenced_in_non_dylib == FALSE)
		    continue;
		if((merged_symbol->nlist.n_type & N_TYPE) != N_UNDF &&
		   (merged_symbol->nlist.n_type & N_TYPE) != N_PBUD &&
		   (merged_symbol->nlist.n_type & N_PEXT) == 0)
		    toc_order[ntoc++] = merged_symbol;
	    }
	}
	if(ntoc != output_dysymtab_info.dysymtab_command.ntoc)
	    fatal("internal error: output_dylib_tables() inconsistent toc "
		  "counts");
	qsort(toc_order, ntoc, sizeof(struct merged_symbol *),
	      (int (*)(const void *, const void *))qsort_by_name);
	flush_offset = output_dysymtab_info.dysymtab_command.tocoff;
	tocs = (struct dylib_table_of_contents *)(output_addr +
							 flush_offset);
	toc = tocs;
	for(i = 0; i < ntoc; i++){
	    toc->symbol_index = merged_symbol_output_index(toc_order[i]);
	    toc->module_index = object_index(toc_order[i]->definition_object);
	    toc++;
	}
	if(host_byte_sex != target_byte_sex){
	    swap_dylib_table_of_contents(tocs, ntoc, target_byte_sex);
	}
	output_flush(flush_offset, ntoc *
				   sizeof(struct dylib_table_of_contents));
	free(toc_order);
}

/*
 * When any merged_symbol has its flagged_read_only_reloc set then this static
 * is also set.  This allows clear_read_only_reloc_flags() to avoid doing any
 * work.
 */
static enum bool some_read_only_reloc_flags_set = FALSE;

/*
 * clear_read_only_reloc_flags() clears the flagged_read_only_reloc flags on
 * all the merged symbols.
 */
__private_extern__
void
clear_read_only_reloc_flags(
void)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

	if(some_read_only_reloc_flags_set == FALSE)
	    return;

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		merged_symbol->flagged_read_only_reloc = FALSE;
	    }
	}
	some_read_only_reloc_flags_set = FALSE;
}

/*
 * flag_read_only_reloc() is called to flag an external relocation entry
 * refering to output_index in the specified section.  If the symbol has not
 * already been flaged it's name is printed.  Also if first_time point to
 * a TRUE value a leading print statement is done.
 */
__private_extern__
void
flag_read_only_reloc(
struct section *s,
unsigned long output_index,
enum bool *first_time)
{
    unsigned long i;
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol *merged_symbol;

	if(*first_time == TRUE){
	    if(read_only_reloc_flag == READ_ONLY_RELOC_ERROR)
		error_with_cur_obj("has external relocation entries in "
		    "non-writable section (%.16s,%.16s) for symbols:",
		    s->segname, s->sectname);
	    else
		warning_with_cur_obj("has external relocation entries in "
		    "non-writable section (%.16s,%.16s) for symbols:",
		    s->segname, s->sectname);
	    *first_time = FALSE;
	}

	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = 0; i < merged_symbol_list->used; i++){
		merged_symbol = merged_symbol_list->symbols[i];
		if(merged_symbol->output_index == output_index){
		    if(merged_symbol->flagged_read_only_reloc == FALSE){
			print("%s\n", merged_symbol->nlist.n_un.n_name);
			merged_symbol->flagged_read_only_reloc = TRUE;
			some_read_only_reloc_flags_set = TRUE;
		    }
		    return;
		}
	    }
	}
}
#endif /* !defined(RLD) */

#ifdef RLD
/*
 * free_multiple_defs() frees the multiple_defs array and resets the count to
 * zero if it exist.
 */
__private_extern__
void
free_multiple_defs(void)
{
	if(nmultiple_defs != 0){
	    free(multiple_defs);
	    multiple_defs = NULL;
	    nmultiple_defs = 0;
	}
}

/*
 * remove_merged_symbols() removes the merged symbols that are defined in the
 * current object file set and their strings.  This take advantage of the fact
 * that symbols from the current set of symbols were all merged after the
 * previous set and appear last in symbol list and hash table.
 */
__private_extern__
void
remove_merged_symbols(void)
{
    long i;
    unsigned long j;
    struct merged_symbol_list *m, *merged_symbol_list, *prev_merged_symbol_list,
			      *next_merged_symbol_list;
    enum bool have_some_symbols;
    struct merged_symbol_chunk *p, *first_chunk, *prev_chunk, *next_chunk;
    struct string_block *string_block, *prev_string_block, *next_string_block;

	/*
	 * Clear all the merged symbol table entries for symbols that come
	 * from the current set of object files.
	 */

	/*
	 * First clear all symbol pointers in the merged_symbol_list from this
	 * set.  Then if there are any symbol lists with no used symbols free
	 * them.
	 */
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    for(i = merged_symbol_list->used - 1; i >= 0; i--){
		if(merged_symbol_list->symbols[i] != NULL &&
		   merged_symbol_list->symbols[i]->name_len != 0 &&
		   merged_symbol_list->symbols[i]->definition_object != NULL &&
		   merged_symbol_list->symbols[i]->definition_object->set_num ==
		   cur_set){
		    merged_symbol_list->symbols[i] = NULL;
		    merged_symbol_list->used--;
		}
	    }
	}
	/*
	 * Find the first symbol list that now has 0 entries used if any.
	 */
	prev_merged_symbol_list = merged_symbol_root == NULL ? NULL :
				  merged_symbol_root->list;
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    if(merged_symbol_list->used == 0)
		break;
	    prev_merged_symbol_list = merged_symbol_list;
	}
	/*
	 * If there are any symbol lists with 0 entries used free it and the
	 * chain of lists that follows.
	 */
	if(merged_symbol_list != NULL && merged_symbol_list->used == 0){
	    /*
	     * First set the pointer to this list in the previous list to NULL.
	     */
	    if(merged_symbol_list == merged_symbol_root->list)
		merged_symbol_root->list = NULL;
	    else
		prev_merged_symbol_list->next = NULL;
	    for(m = merged_symbol_list; m != NULL; m = next_merged_symbol_list){
		next_merged_symbol_list = m->next;
		free(m);
	    }
	}

	/*
	 * Second clear out the hash table entries and free any allocated chunks
	 * that only have symbols from this set.
	 */
	have_some_symbols = FALSE;
	for(i = 0; i < SYMBOL_LIST_HASH_SIZE; i++){
	    if(merged_symbol_root == NULL)
		break;
	    first_chunk = NULL;
	    prev_chunk = NULL;
	    for(p = &merged_symbol_root->chunks[i]; p != NULL; p = p->next){
		for(j = 0; j < SYMBOL_CHUNK_SIZE; j++){
		    if(p->symbols[j].name_len != 0 &&
		       p->symbols[j].definition_object->set_num == cur_set){
			memset(p->symbols + j, '\0',
			       sizeof(struct merged_symbol));
			/*
			 * Save a pointer to the first chunk that is allocated
			 * in the chain who first symbol (and all remaining) is
			 * for this set.
			 */
			if(first_chunk == NULL &&
			   p != &merged_symbol_root->chunks[i] &&
			   j == 0)
			    first_chunk = p;
		    }
		    else{
			if(p->symbols[j].name_len != 0)
			    have_some_symbols = TRUE;
		    }
		}
		/*
		 * If we have not yet found a first allocated chunk that has all
		 * symbols from this set, save the pointer to this chunk as it
		 * may end up being the previous chunk.
		 */
		if(first_chunk == NULL)
		    prev_chunk = p;
	    }
	    /*
	     * Free any allocated chunks after the first one in the hash table
	     * that had symbols all from this set and clear the next pointer to
	     * this chain.
	     */
	    if(first_chunk != NULL){
		for(p = first_chunk; p != NULL; p = next_chunk){
		    next_chunk = p->next;
		    free(p);
		}
		prev_chunk->next = NULL;
	    }
	}
	/*
	 * If there are no symbol left in the hash table then free it too.
	 */
	if(have_some_symbols == FALSE){
	    free(merged_symbol_root);
	    merged_symbol_root = NULL;
	}

	/*
	 * Third, find the first string block for the current set of object
	 * files to clear them out.
	 */
	prev_string_block = NULL;
	for(string_block = merged_string_blocks;
	    string_block != NULL;
	    string_block = string_block->next){
	    if(string_block->set_num == cur_set)
		break;
	    prev_string_block = string_block;
	}
	/*
	 * If there are any string blocks for the current set of object files
	 * free their strings and the blocks.
	 */
	if(string_block != NULL && string_block->set_num == cur_set){
	    /*
	     * First set the pointer to this block in the previous block to
	     * NULL.
	     */
	    if(string_block == merged_string_blocks)
		merged_string_blocks = NULL;
	    else
		prev_string_block->next = NULL;
	    /*
	     * Now free the stings for this block the block itself and do the
	     * same for all remaining blocks.
	     */
	    do {
		free(string_block->strings);
		next_string_block = string_block->next;
		free(string_block);
		string_block = next_string_block;
	    }while(string_block != NULL);
	}
}
#endif /* RLD */

#ifdef DEBUG
/*
 * print_symbol_list() prints the merged symbol table.  Used for debugging.
 */
__private_extern__
void
print_symbol_list(
char *string,
enum bool input_based)
{
    struct merged_symbol_list *merged_symbol_list;
    struct merged_symbol_chunk *p;
    unsigned long i, j;
    struct nlist *nlist;
    struct section *s;
    struct section_map *maps;

	print("Merged symbol list (%s)\n", string);
	for(merged_symbol_list = merged_symbol_root == NULL ? NULL :
				 merged_symbol_root->list;
	    merged_symbol_list != NULL;
	    merged_symbol_list = merged_symbol_list->next){
	    print("merged_symbols\n");
	    for(i = 0; i < merged_symbol_list->used; i++){
		print("%-4lu[0x%x]\n", i,
		      (unsigned int)(merged_symbol_list->symbols + i));
		nlist = &(merged_symbol_list->symbols[i]->nlist);
		print("    n_name %s\n", nlist->n_un.n_name);
		print("    n_type ");
		switch(nlist->n_type & N_TYPE){
		case N_UNDF:
		    if(nlist->n_value == 0)
			print("N_UNDF\n");
		    else
			print("common (size %u)\n", nlist->n_value);
		    break;
		case N_PBUD:
		    print("N_PBUD\n");
		    break;
		case N_ABS:
		    print("N_ABS\n");
		    break;
		case N_SECT:
		    print("N_SECT\n");
		    break;
		case N_INDR:
		    print("N_INDR for %s\n", ((struct merged_symbol *)
				(nlist->n_value))->nlist.n_un.n_name);
		    break;
		default:
		    print("unknown 0x%x\n", (unsigned int)(nlist->n_type));
		    break;
		}
		print("    n_sect %d ", nlist->n_sect);
		maps = merged_symbol_list->symbols[i]->
		       definition_object->section_maps;
		if(nlist->n_sect == NO_SECT)
		    print("NO_SECT\n");
		else{
		    if(input_based == TRUE)
			print("(%.16s,%.16s)\n",
			       maps[nlist->n_sect - 1].s->segname,
			       maps[nlist->n_sect - 1].s->sectname);
		    else{
			s = get_output_section(nlist->n_sect);
			if(s != NULL)
			    print("(%.16s,%.16s)\n",s->segname, s->sectname);
			else
			    print("(bad section #%d)\n", nlist->n_sect);
		    }
		}
		print("    n_desc 0x%04x\n", (unsigned int)(nlist->n_desc));
		print("    n_value 0x%08x\n", (unsigned int)(nlist->n_value));
#ifdef RLD
		print("    definition_object ");
		print_obj_name(
		       merged_symbol_list->merged_symbols[i].definition_object);
		print("\n");
		print("    set_num %d\n", merged_symbol_list->merged_symbols[i].
		      definition_object->set_num);
#endif
	    }
	}

	print("Hash table (merged_symbol_root 0x%x)\n",
	      (unsigned int)(merged_symbol_root));
	for(i = 0; i < SYMBOL_LIST_HASH_SIZE; i++){
	    for(p = &merged_symbol_root->chunks[i]; p != NULL; p = p->next){
		for(j = 0; j < SYMBOL_CHUNK_SIZE; j++){
		    if(p->symbols[j].name_len != 0){
			print("    %-5lu %-2lu [0x%x] %s\n", i, j,
			      (unsigned int)(p->symbols + j),
			       p->symbols[j].nlist.n_un.n_name);
		    }
		}
	    }
	}
}

#endif /* DEBUG */
/*
 * get_output_section() returns a pointer to the output section structure for
 * the section number passed to it.  It returns NULL for section numbers that
 * are not in the output file.
 */
__private_extern__
struct section *
get_output_section(
unsigned long sect)
{
    struct merged_segment **p, *msg;
    struct merged_section **content, **zerofill, *ms;

	p = &merged_segments;
	while(*p){
	    msg = *p;
	    content = &(msg->content_sections);
	    while(*content){
		ms = *content;
		if(ms->output_sectnum == sect)
		    return(&(ms->s));
		content = &(ms->next);
	    }
	    zerofill = &(msg->zerofill_sections);
	    while(*zerofill){
		ms = *zerofill;
		if(ms->output_sectnum == sect)
		    return(&(ms->s));
		zerofill = &(ms->next);
	    }
	    p = &(msg->next);
	}
	return(NULL);
}

#ifdef DEBUG

#ifndef RLD
/*
 * print_undefined_list() prints the undefined symbol list.  Used for debugging.
 */
__private_extern__
void
print_undefined_list(void)
{
    struct undefined_list *undefined;

	print("Undefined list\n");
	for(undefined = undefined_list.next;
	    undefined != &undefined_list;
	    undefined = undefined->next){
	    print("    %s", undefined->merged_symbol->nlist.n_un.n_name);
	    if(undefined->merged_symbol->nlist.n_type == (N_UNDF | N_EXT) ||
	       undefined->merged_symbol->nlist.n_value != 0)
		print("\n");
	    else
		print(" (no longer undefined)\n");
	}
}
#endif /* !defined(RLD) */
#endif /* DEBUG */
                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/symbols.h                                0100644 0001750 0001750 00000041365 12612724205 022710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

/*
 * Global types, variables and routines declared in the file symbols.c.
 *
 * The following include file need to be included before this file:
 * #include <nlist.h>
 * #include "ld.h"
 */

/*
 * This structure holds an external symbol that has been merged and will be in
 * the output file.  The nlist feilds are used as follows:
 *      union {
 *	    char *n_name;  The name of the symbol (pointing into the merged
 * 			   string table).
 *	    long  n_strx;  Only set write before the symbol is written to the
 *			   output file and then the symbol is no longer used.
 *      } n_un;
 *      unsigned char n_type;	Same as in an object file.
 *      unsigned char n_sect;	"
 *      short	      n_desc;	"
 *      unsigned long n_value;	The value of the symbol as it came from the
 * 				object it was defined in for N_SECT and N_ABS
 *				type symbols.
 *				For common symbols the size of the largest
 *				common.
 *				For N_INDR symbols a pointer to the
 *				merged_symbol that it is an indirect for.
 *	
 */
struct merged_symbol {
    struct nlist nlist;		/* the nlist structure of this merged symbol */
    unsigned long name_len;	/* the size of the symbol name */
    struct object_file		/* pointer to the object file this symbol is */
	*definition_object;	/*  defined in */
    struct dynamic_library	/* pointer to the dynamic library this symbol */
	*definition_library;	/*  is defined in, if defined_in_dylib==TRUE */
    struct object_file		/* pointer to the object file this symbol is */
	*non_dylib_referenced_obj; /* first referenced in, */
				   /* if referenced_in_non_dylib == TRUE */
    unsigned long
	error_flagged_for_dylib:1, /* symbol reported as an error in dylib */
	defined_in_dylib:1,	   /* symbol defined in dylib */
	coalesced_defined_in_dylib:1, /* symbol defined in dylib that is a */
				      /*  coalesced symbol */
	weak_def_in_dylib:1,	   /* a weak definition in a dylib */
	referenced_in_non_dylib:1, /* symbol referenced in loaded objects and */
				   /*  will be in output file */
	flagged_read_only_reloc:1, /* symbol reported as an external reloc */
				   /*  in a read only section */
	twolevel_reference:1,	   /* set only for merged_symbol structs that */
				   /*  are not in the merged symbol table but */
				   /*  only in the undefined list as a two- */
				   /*  level namespace reference from a dylib.*/
	weak_reference_mismatch:1, /* seen both a weak and non-weak reference */
	seen_undef:1,		   /* seen an undefined reference from an */
				   /*  object file. So the N_WEAK_REF bit */
				   /*  does reflect the value for the output. */
	define_a_way:1,		   /* set if this symbol was defined as a */
				   /*  result of -undefined define_a_way */
	live:1,			   /* TRUE if the symbol is not to be dead */
				   /*  stripped. */
	unused:21;
    unsigned long output_index;	/* the symbol table index this symbol will */
				/*  have in the output file. */
    int undef_order;		/* if the symbol was undefined the order it */
				/*  was seen. */
    /*
     * For two-level namespace hints this is the index into the table of
     * contents for the definition symbol in the dylib it is defined in,
     */
    unsigned long itoc;

    /*
     * If the twolevel_reference bit above is set this is a pointer to
     * the dynamic_library struct the two-level reference is in.  Then the
     * library ordinal in the nlist struct can be used with the dependent_images
     * to cause the correct module to be loaded.
     */
    struct dynamic_library *referencing_library;

    /*
     * When doing dead code stripping this is set to the fine_reloc this symbol
     * is in if any.
     */
    struct fine_reloc *fine_reloc;
};

/*
 * The number of merged_symbol structrures in a merged_symbol_list.
 */
#ifndef RLD
#define NSYMBOLS 20001
#else
#define NSYMBOLS 201
#endif /* RLD */
/* The number of size of the hash table in a merged_symbol_list */
#define SYMBOL_LIST_HASH_SIZE	(NSYMBOLS * 2)

/* The number of buckets for conflicts */
#define SYMBOL_CHUNK_SIZE 10

/* The collection of buckets for conflicting hash values */
struct merged_symbol_chunk
{
    /* the buckets */
    struct merged_symbol symbols[SYMBOL_CHUNK_SIZE];

    /*
     * next chunk (if this is not null, it means all of the buckets of this
     * chunk are full)
     */
    struct merged_symbol_chunk *next;
};

/*
 * The block that has the hash table and a pointer to symbol list.
 */
struct merged_symbol_root {
    /* the hashed array of chunks */
    struct merged_symbol_chunk chunks[SYMBOL_LIST_HASH_SIZE];

    /* the list of used symbols */
    struct merged_symbol_list *list;
};

/*
 * The symbol list is the list of symbols that have been used. It's a compact
 * flat array of pointers into the sparse hash table.
 */
struct merged_symbol_list {
    /* pointers to symbols in the merged_symbol_chunk */
    struct merged_symbol *symbols[SYMBOL_LIST_HASH_SIZE];

    /* next free location in the symbols array */
    unsigned long used;

    /* next linked symbol list (NULL means no more) */
    struct merged_symbol_list *next;
};


/* the blocks that store the strings; allocated as needed */
struct string_block {
    unsigned long size;		/* the number of bytes in this block */
    unsigned long used;		/* the number of bytes used in this block */
    char *strings;		/* the strings */
    unsigned long index;	/* the relitive index into the final symbol */
				/*  table for the block (set in pass2). */
    enum bool base_strings;	/* TRUE if this block is for strings from the */
				/*  base file (used if strip_base_symbols is */
				/*  TRUE) */
    enum bool dylib_strings;	/* TRUE if this block is for strings from a */
				/*  dylib file (string won't be in output). */
#ifdef RLD
    long set_num;		/* the object file set number these strings */
				/*  come from. */
#endif /* RLD */
    struct string_block *next;	/* the next block */
};

/*
 * The structure for the undefined list and the structure that the items
 * are allocated out of.
 */
struct undefined_list {
    struct merged_symbol
	*merged_symbol;		/* the undefined symbol */
    struct undefined_list *prev;/* previous in the chain */
    struct undefined_list *next;/* next in the chain */
};

/*
 * The structure of the load map for common symbols.  This is only used to help
 * print the load map.  It is created by define_commmon_symbols() in symbols.c
 * and used in print_load_map() in layout.c.
 */
struct common_load_map {
    struct merged_section
	*common_ms;		/* the section common symbol were allocated in*/
    unsigned long
	ncommon_symbols;	/* number of common symbols */
    struct common_symbol	/* a pointer to an array of structures (one */
	*common_symbols;	/*  for each common symbol) */
};
struct common_symbol {
    struct merged_symbol	/* a pointer the merged common symbol */
	*merged_symbol;
    unsigned long common_size;	/* the size of the merged common symbol */
};

/*
 * The head of the symbol list and the total count of all external symbols
 * in the list.  The total count of private externals is included in the total
 * count of the merged symbols.  The count of merged symbols referenced only
 * from dylibs will not be in the output file.
 */
__private_extern__ struct merged_symbol_root *merged_symbol_root;
__private_extern__ unsigned long nmerged_symbols;
__private_extern__ unsigned long nmerged_private_symbols;
__private_extern__ unsigned long nmerged_symbols_referenced_only_from_dylibs;

/*
 * nstripped_merged_symbols is set to the number of merged symbol being stripped
 * out when the strip_level is STRIP_DYNAMIC_EXECUTABLE.
 */
__private_extern__ unsigned long nstripped_merged_symbols;

/*
 * The head of the list of the blocks that store the strings for the merged
 * symbols and the total size of all the strings.  The size of the strings for
 * the private externals is included in the the merge string size.
 */
__private_extern__ struct string_block *merged_string_blocks;
__private_extern__ unsigned long merged_string_size;
__private_extern__ unsigned long merged_private_string_size;

/*
 * The head of the undefined list itself.  This is a circular list so it can be
 * searched from start to end and so new items can be put on the end.  This 
 * structure never has it's merged_symbol filled in but only serves as the
 * head and tail of the list.
 */
__private_extern__ struct undefined_list undefined_list;

/*
 * The common symbol load map.  Only allocated and filled in if load map is
 * requested.
 */
__private_extern__ struct common_load_map common_load_map;

/*
 * The object file that is created for the common symbols to be allocated in.
 */
__private_extern__
struct object_file link_edit_common_object;

/*
 * The number of local symbols that will appear in the output file and the
 * size of their strings.
 */
__private_extern__ unsigned long nlocal_symbols;
__private_extern__ unsigned long local_string_size;

/*
 * For local symbols of an object file that are not to be in the output a
 * local symbol block is created and linked off of the object structure's
 * localsym_blocks pointer.  These blocks are linked in order by the index.
 * If the symbols in that block are simply to be discarded the state is set
 * to DISCARD_SYMBOLS.
 *
 * When a block of local symbols are being excluded from the output because
 * it is a duplicate block of stabs in an include file (a N_BINCL/N_EINCL
 * group) then the state is set to EXCLUDED_INCLUDE and the sum field is filled
 * in and used to create the one N_EXCL stab to replace the group.
 *
 * The first time a N_BINCL is seen its sum needs to be set into its n_value
 * so a local symbol block state will be set to BEGIN_INCLUDE and it will
 * have a count of 1.
 * 
 * For the other cases of when a block of local symbols are being excluded from
 * the output (deleted coalesced symbols or indirect symbols) the state is set
 * to DISCARD_SYMBOLS.
 *
 * The PARSE_SYMBOLS is used temporarily while parsing out N_BINCL/N_EINCL and
 * then are removed from the list after parsing is done.
 */
enum localsym_block_state {
    PARSE_SYMBOLS,
    BEGIN_INCLUDE,
    EXCLUDED_INCLUDE,
    DISCARD_SYMBOLS
};
struct localsym_block {
    unsigned long index;
    unsigned long count;
    enum localsym_block_state state;
    unsigned long input_N_BINCL_n_value;
    unsigned long sum;
    struct localsym_block *next;
};

/*
 * The things to deal with creating local symbols with the object file's name
 * for a given section.  If the section name is (__TEXT,__text) these are the
 * same as a UNIX link editor's file.o symbols for the text section.
 */
struct sect_object_symbols {
    enum bool specified; /* if this has been specified on the command line */
    char *segname;	 /* the segment name */
    char *sectname;	 /* the section name */
    struct merged_section *ms;	/* the merged section structure */
};
__private_extern__ struct sect_object_symbols sect_object_symbols;

/*
 * The indr_symbol_pair structure is used when there are chains of N_INDR
 * that have symbols both from dylibs and not from dylibs.  The routine
 * reduce_indr_symbols() creates this and the routines output_merged_symbols()
 * and indirect_section_merge() both use it.  What is going on is that when
 * producing an output file the N_INDR symbols from a dylib can't be used in
 * a chain of N_INDR symbols.  So this structure contains merged_symbols which
 * are N_INDR which should use the matching indr_symbol from the table instead
 * of going through (struct merged_symbol *)(merged_symbol->nlist.n_value).
 */
struct indr_symbol_pair {
    struct merged_symbol *merged_symbol;
    struct merged_symbol *indr_symbol;
};
__private_extern__ struct indr_symbol_pair *indr_symbol_pairs;
__private_extern__ unsigned long nindr_symbol_pairs;

/*
 * merged_symbols_relocated is set when the merged symbols are relocated to
 * have addresses and section numbers as they would in the output file.
 */
__private_extern__ enum bool merged_symbols_relocated;

/*
 * The strings in the string table can't start at offset 0 because a symbol with
 * a string offset of zero is defined to have a null "" symbol name.  So the
 * first STRING_SIZE_OFFSET bytes are not used and the first string starts after
 * this amount.  Also these first bytes are zero so that if the special case of
 * a zero index is not handled by a program it will happen to work.
 */
#define STRING_SIZE_OFFSET (sizeof(long))

__private_extern__ void merge_symbols(
    void);
__private_extern__ struct merged_symbol *command_line_symbol(
    char *symbol_name);
__private_extern__ struct merged_symbol *lookup_symbol(
    char *symbol_name);
__private_extern__ void command_line_indr_symbol(
    char *symbol_name,
    char *indr_symbol_name);
#ifndef RLD
__private_extern__ void hash_instrument(
    void);
__private_extern__ void merge_dylib_module_symbols(
    struct dynamic_library *dynamic_library);
__private_extern__ void merge_bundle_loader_symbols(
    struct dynamic_library *dynamic_library);
#endif /* !defined(RLD) */
__private_extern__ void delete_from_undefined_list(
    struct undefined_list *undefined);
__private_extern__ void trace_merged_symbol(
    struct merged_symbol *merged_symbol);
__private_extern__ void free_pass1_symbol_data(
    void);
__private_extern__ void free_undefined_list(
    void);
__private_extern__ void define_common_symbols(
    void);
__private_extern__ void define_undefined_symbols_a_way(
    void);
__private_extern__ void mark_globals_live(
    void);
__private_extern__ void mark_N_NO_DEAD_STRIP_local_symbols_live(
    void);
__private_extern__ void set_fine_relocs_for_merged_symbols(
    void);
__private_extern__ void count_live_symbols(
    void);
__private_extern__ void define_link_editor_execute_symbols(
    unsigned long header_address);
__private_extern__ void setup_link_editor_symbols(
    void);
__private_extern__ void define_link_editor_dylib_symbols(
    unsigned long header_address);
__private_extern__ void define_link_editor_preload_symbols(
    enum bool setup);
__private_extern__ void reduce_indr_symbols(
    void);
__private_extern__ void process_undefineds(
    void);
__private_extern__ void reset_prebound_undefines(
    void);
__private_extern__ void assign_output_symbol_indexes(
    void);
#ifndef RLD
__private_extern__ void layout_dylib_tables(
    void);
__private_extern__ void output_dylib_tables(
    void);
#endif
__private_extern__ void layout_merged_symbols(
    void);
__private_extern__ void discard_local_symbols_for_section(
    unsigned long nsect,
    struct nlist *object_symbols,
    char *object_strings,
    struct section *s, 
    struct section_map *section_map);
__private_extern__ void output_local_symbols(
    void);
__private_extern__ unsigned long local_symbol_output_index(
    struct object_file *obj,
    unsigned long index);
__private_extern__ void set_merged_string_block_indexes(
    void);
__private_extern__ void output_merged_symbols(
    void);
#if defined(RLD) && !defined(SA_RLD)
__private_extern__
void output_rld_symfile_merged_symbols(
    void);
#endif /* defined(RLD) && !defined(SA_RLD) */
__private_extern__ enum bool is_output_local_symbol(
    unsigned char n_type,
    unsigned char n_sect,
    unsigned char n_desc,
    struct object_file *obj,
    char *symbol_name,
    unsigned long *output_strlen);
__private_extern__ unsigned long merged_symbol_output_index(
    struct merged_symbol *merged_symbol);
__private_extern__ void clear_read_only_reloc_flags(
    void);
__private_extern__ void flag_read_only_reloc(
    struct section *s,
    unsigned long output_index,
    enum bool *first_time);

#ifdef RLD
__private_extern__ void free_multiple_defs(
    void);
__private_extern__ void remove_merged_symbols(
    void);
#endif /* RLD */

__private_extern__ struct section *get_output_section(
    unsigned long sect);

#ifdef DEBUG
__private_extern__ void print_symbol_list(
    char *string,
    enum bool input_based);
__private_extern__ void print_undefined_list(
    void);
#endif /* DEBUG */
                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/uuid.c                                   0100644 0001750 0001750 00000003042 12612724205 022147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#if defined(__MWERKS__) && !defined(__private_extern__)
#define __private_extern__ __declspec(private_extern)
#endif

#include <stdint.h>
#include <string.h>
#if !(defined(KLD) && defined(__STATIC__))
#include <uuid/uuid.h>
#else
#include <mach-o/loader.h>
#endif /* !(defined(KLD) && defined(__STATIC__)) */

/*
 * uuid() is called to set the uuid[] bytes for the uuid load command.
 */
__private_extern__
void
uuid(
uint8_t *uuid)
{
#if defined(KLD) && defined(__STATIC__)
    memset(uuid, '\0', sizeof(struct uuid_command));
#else 
    uuid_generate_random((void *)uuid);
#endif 
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld/uuid.h                                   0100644 0001750 0001750 00000002132 12612724205 022153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
 * uuid() is called to set the uuid[] bytes for the uuid load command.
 */
__private_extern__ void uuid(
    uint8_t *uuid);
                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/                                       0040755 0001750 0001750 00000000000 13101126656 021213  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/APPLE_LICENSE                          0100644 0001750 0001750 00000046565 12612724205 023156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        APPLE PUBLIC SOURCE LICENSE
Version 2.0 - August 6, 2003

Please read this License carefully before downloading this software.
By downloading or using this software, you are agreeing to be bound by
the terms of this License. If you do not or cannot agree to the terms
of this License, please do not download or use the software.

1. General; Definitions. This License applies to any program or other
work which Apple Computer, Inc. ("Apple") makes publicly available and
which contains a notice placed by Apple identifying such program or
work as "Original Code" and stating that it is subject to the terms of
this Apple Public Source License version 2.0 ("License"). As used in
this License:

1.1 "Applicable Patent Rights" mean: (a) in the case where Apple is
the grantor of rights, (i) claims of patents that are now or hereafter
acquired, owned by or assigned to Apple and (ii) that cover subject
matter contained in the Original Code, but only to the extent
necessary to use, reproduce and/or distribute the Original Code
without infringement; and (b) in the case where You are the grantor of
rights, (i) claims of patents that are now or hereafter acquired,
owned by or assigned to You and (ii) that cover subject matter in Your
Modifications, taken alone or in combination with Original Code.

1.2 "Contributor" means any person or entity that creates or
contributes to the creation of Modifications.

1.3 "Covered Code" means the Original Code, Modifications, the
combination of Original Code and any Modifications, and/or any
respective portions thereof.

1.4 "Externally Deploy" means: (a) to sublicense, distribute or
otherwise make Covered Code available, directly or indirectly, to
anyone other than You; and/or (b) to use Covered Code, alone or as
part of a Larger Work, in any way to provide a service, including but
not limited to delivery of content, through electronic communication
with a client other than You.

1.5 "Larger Work" means a work which combines Covered Code or portions
thereof with code not governed by the terms of this License.

1.6 "Modifications" mean any addition to, deletion from, and/or change
to, the substance and/or structure of the Original Code, any previous
Modifications, the combination of Original Code and any previous
Modifications, and/or any respective portions thereof. When code is
released as a series of files, a Modification is: (a) any addition to
or deletion from the contents of a file containing Covered Code;
and/or (b) any new file or other representation of computer program
statements that contains any part of Covered Code.

1.7 "Original Code" means (a) the Source Code of a program or other
work as originally made available by Apple under this License,
including the Source Code of any updates or upgrades to such programs
or works made available by Apple under this License, and that has been
expressly identified by Apple as such in the header file(s) of such
work; and (b) the object code compiled from such Source Code and
originally made available by Apple under this License.

1.8 "Source Code" means the human readable form of a program or other
work that is suitable for making modifications to it, including all
modules it contains, plus any associated interface definition files,
scripts used to control compilation and installation of an executable
(object code).

1.9 "You" or "Your" means an individual or a legal entity exercising
rights under this License. For legal entities, "You" or "Your"
includes any entity which controls, is controlled by, or is under
common control with, You, where "control" means (a) the power, direct
or indirect, to cause the direction or management of such entity,
whether by contract or otherwise, or (b) ownership of fifty percent
(50%) or more of the outstanding shares or beneficial ownership of
such entity.

2. Permitted Uses; Conditions & Restrictions. Subject to the terms
and conditions of this License, Apple hereby grants You, effective on
the date You accept this License and download the Original Code, a
world-wide, royalty-free, non-exclusive license, to the extent of
Apple's Applicable Patent Rights and copyrights covering the Original
Code, to do the following:

2.1 Unmodified Code. You may use, reproduce, display, perform,
internally distribute within Your organization, and Externally Deploy
verbatim, unmodified copies of the Original Code, for commercial or
non-commercial purposes, provided that in each instance:

(a) You must retain and reproduce in all copies of Original Code the
copyright and other proprietary notices and disclaimers of Apple as
they appear in the Original Code, and keep intact all notices in the
Original Code that refer to this License; and

(b) You must include a copy of this License with every copy of Source
Code of Covered Code and documentation You distribute or Externally
Deploy, and You may not offer or impose any terms on such Source Code
that alter or restrict this License or the recipients' rights
hereunder, except as permitted under Section 6.

2.2 Modified Code. You may modify Covered Code and use, reproduce,
display, perform, internally distribute within Your organization, and
Externally Deploy Your Modifications and Covered Code, for commercial
or non-commercial purposes, provided that in each instance You also
meet all of these conditions:

(a) You must satisfy all the conditions of Section 2.1 with respect to
the Source Code of the Covered Code;

(b) You must duplicate, to the extent it does not already exist, the
notice in Exhibit A in each file of the Source Code of all Your
Modifications, and cause the modified files to carry prominent notices
stating that You changed the files and the date of any change; and

(c) If You Externally Deploy Your Modifications, You must make
Source Code of all Your Externally Deployed Modifications either
available to those to whom You have Externally Deployed Your
Modifications, or publicly available. Source Code of Your Externally
Deployed Modifications must be released under the terms set forth in
this License, including the license grants set forth in Section 3
below, for as long as you Externally Deploy the Covered Code or twelve
(12) months from the date of initial External Deployment, whichever is
longer. You should preferably distribute the Source Code of Your
Externally Deployed Modifications electronically (e.g. download from a
web site).

2.3 Distribution of Executable Versions. In addition, if You
Externally Deploy Covered Code (Original Code and/or Modifications) in
object code, executable form only, You must include a prominent
notice, in the code itself as well as in related documentation,
stating that Source Code of the Covered Code is available under the
terms of this License with information on how and where to obtain such
Source Code.

2.4 Third Party Rights. You expressly acknowledge and agree that
although Apple and each Contributor grants the licenses to their
respective portions of the Covered Code set forth herein, no
assurances are provided by Apple or any Contributor that the Covered
Code does not infringe the patent or other intellectual property
rights of any other entity. Apple and each Contributor disclaim any
liability to You for claims brought by any other entity based on
infringement of intellectual property rights or otherwise. As a
condition to exercising the rights and licenses granted hereunder, You
hereby assume sole responsibility to secure any other intellectual
property rights needed, if any. For example, if a third party patent
license is required to allow You to distribute the Covered Code, it is
Your responsibility to acquire that license before distributing the
Covered Code.

3. Your Grants. In consideration of, and as a condition to, the
licenses granted to You under this License, You hereby grant to any
person or entity receiving or distributing Covered Code under this
License a non-exclusive, royalty-free, perpetual, irrevocable license,
under Your Applicable Patent Rights and other intellectual property
rights (other than patent) owned or controlled by You, to use,
reproduce, display, perform, modify, sublicense, distribute and
Externally Deploy Your Modifications of the same scope and extent as
Apple's licenses under Sections 2.1 and 2.2 above.

4. Larger Works. You may create a Larger Work by combining Covered
Code with other code not governed by the terms of this License and
distribute the Larger Work as a single product. In each such instance,
You must make sure the requirements of this License are fulfilled for
the Covered Code or any portion thereof.

5. Limitations on Patent License. Except as expressly stated in
Section 2, no other patent rights, express or implied, are granted by
Apple herein. Modifications and/or Larger Works may require additional
patent licenses from Apple which Apple may grant in its sole
discretion.

6. Additional Terms. You may choose to offer, and to charge a fee for,
warranty, support, indemnity or liability obligations and/or other
rights consistent with the scope of the license granted herein
("Additional Terms") to one or more recipients of Covered Code.
However, You may do so only on Your own behalf and as Your sole
responsibility, and not on behalf of Apple or any Contributor. You
must obtain the recipient's agreement that any such Additional Terms
are offered by You alone, and You hereby agree to indemnify, defend
and hold Apple and every Contributor harmless for any liability
incurred by or claims asserted against Apple or such Contributor by
reason of any such Additional Terms.

7. Versions of the License. Apple may publish revised and/or new
versions of this License from time to time. Each version will be given
a distinguishing version number. Once Original Code has been published
under a particular version of this License, You may continue to use it
under the terms of that version. You may also choose to use such
Original Code under the terms of any subsequent version of this
License published by Apple. No one other than Apple has the right to
modify the terms applicable to Covered Code created under this
License.

8. NO WARRANTY OR SUPPORT. The Covered Code may contain in whole or in
part pre-release, untested, or not fully tested works. The Covered
Code may contain errors that could cause failures or loss of data, and
may be incomplete or contain inaccuracies. You expressly acknowledge
and agree that use of the Covered Code, or any portion thereof, is at
Your sole and entire risk. THE COVERED CODE IS PROVIDED "AS IS" AND
WITHOUT WARRANTY, UPGRADES OR SUPPORT OF ANY KIND AND APPLE AND
APPLE'S LICENSOR(S) (COLLECTIVELY REFERRED TO AS "APPLE" FOR THE
PURPOSES OF SECTIONS 8 AND 9) AND ALL CONTRIBUTORS EXPRESSLY DISCLAIM
ALL WARRANTIES AND/OR CONDITIONS, EXPRESS OR IMPLIED, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES AND/OR CONDITIONS OF
MERCHANTABILITY, OF SATISFACTORY QUALITY, OF FITNESS FOR A PARTICULAR
PURPOSE, OF ACCURACY, OF QUIET ENJOYMENT, AND NONINFRINGEMENT OF THIRD
PARTY RIGHTS. APPLE AND EACH CONTRIBUTOR DOES NOT WARRANT AGAINST
INTERFERENCE WITH YOUR ENJOYMENT OF THE COVERED CODE, THAT THE
FUNCTIONS CONTAINED IN THE COVERED CODE WILL MEET YOUR REQUIREMENTS,
THAT THE OPERATION OF THE COVERED CODE WILL BE UNINTERRUPTED OR
ERROR-FREE, OR THAT DEFECTS IN THE COVERED CODE WILL BE CORRECTED. NO
ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE, AN APPLE
AUTHORIZED REPRESENTATIVE OR ANY CONTRIBUTOR SHALL CREATE A WARRANTY.
You acknowledge that the Covered Code is not intended for use in the
operation of nuclear facilities, aircraft navigation, communication
systems, or air traffic control machines in which case the failure of
the Covered Code could lead to death, personal injury, or severe
physical or environmental damage.

9. LIMITATION OF LIABILITY. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO
EVENT SHALL APPLE OR ANY CONTRIBUTOR BE LIABLE FOR ANY INCIDENTAL,
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR RELATING
TO THIS LICENSE OR YOUR USE OR INABILITY TO USE THE COVERED CODE, OR
ANY PORTION THEREOF, WHETHER UNDER A THEORY OF CONTRACT, WARRANTY,
TORT (INCLUDING NEGLIGENCE), PRODUCTS LIABILITY OR OTHERWISE, EVEN IF
APPLE OR SUCH CONTRIBUTOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES AND NOTWITHSTANDING THE FAILURE OF ESSENTIAL PURPOSE OF ANY
REMEDY. SOME JURISDICTIONS DO NOT ALLOW THE LIMITATION OF LIABILITY OF
INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS LIMITATION MAY NOT APPLY
TO YOU. In no event shall Apple's total liability to You for all
damages (other than as may be required by applicable law) under this
License exceed the amount of fifty dollars ($50.00).

10. Trademarks. This License does not grant any rights to use the
trademarks or trade names "Apple", "Apple Computer", "Mac", "Mac OS",
"QuickTime", "QuickTime Streaming Server" or any other trademarks,
service marks, logos or trade names belonging to Apple (collectively
"Apple Marks") or to any trademark, service mark, logo or trade name
belonging to any Contributor. You agree not to use any Apple Marks in
or as part of the name of products derived from the Original Code or
to endorse or promote products derived from the Original Code other
than as expressly permitted by and in strict compliance at all times
with Apple's third party trademark usage guidelines which are posted
at http://www.apple.com/legal/guidelinesfor3rdparties.html.

11. Ownership. Subject to the licenses granted under this License,
each Contributor retains all rights, title and interest in and to any
Modifications made by such Contributor. Apple retains all rights,
title and interest in and to the Original Code and any Modifications
made by or on behalf of Apple ("Apple Modifications"), and such Apple
Modifications will not be automatically subject to this License. Apple
may, at its sole discretion, choose to license such Apple
Modifications under this License, or on different terms from those
contained in this License or may choose not to license them at all.

12. Termination.

12.1 Termination. This License and the rights granted hereunder will
terminate:

(a) automatically without notice from Apple if You fail to comply with
any term(s) of this License and fail to cure such breach within 30
days of becoming aware of such breach;

(b) immediately in the event of the circumstances described in Section
13.5(b); or

(c) automatically without notice from Apple if You, at any time during
the term of this License, commence an action for patent infringement
against Apple; provided that Apple did not first commence
an action for patent infringement against You in that instance.

12.2 Effect of Termination. Upon termination, You agree to immediately
stop any further use, reproduction, modification, sublicensing and
distribution of the Covered Code. All sublicenses to the Covered Code
which have been properly granted prior to termination shall survive
any termination of this License. Provisions which, by their nature,
should remain in effect beyond the termination of this License shall
survive, including but not limited to Sections 3, 5, 8, 9, 10, 11,
12.2 and 13. No party will be liable to any other for compensation,
indemnity or damages of any sort solely as a result of terminating
this License in accordance with its terms, and termination of this
License will be without prejudice to any other right or remedy of
any party.

13. Miscellaneous.

13.1 Government End Users. The Covered Code is a "commercial item" as
defined in FAR 2.101. Government software and technical data rights in
the Covered Code include only those rights customarily provided to the
public as defined in this License. This customary commercial license
in technical data and software is provided in accordance with FAR
12.211 (Technical Data) and 12.212 (Computer Software) and, for
Department of Defense purchases, DFAR 252.227-7015 (Technical Data --
Commercial Items) and 227.7202-3 (Rights in Commercial Computer
Software or Computer Software Documentation). Accordingly, all U.S.
Government End Users acquire Covered Code with only those rights set
forth herein.

13.2 Relationship of Parties. This License will not be construed as
creating an agency, partnership, joint venture or any other form of
legal association between or among You, Apple or any Contributor, and
You will not represent to the contrary, whether expressly, by
implication, appearance or otherwise.

13.3 Independent Development. Nothing in this License will impair
Apple's right to acquire, license, develop, have others develop for
it, market and/or distribute technology or products that perform the
same or similar functions as, or otherwise compete with,
Modifications, Larger Works, technology or products that You may
develop, produce, market or distribute.

13.4 Waiver; Construction. Failure by Apple or any Contributor to
enforce any provision of this License will not be deemed a waiver of
future enforcement of that or any other provision. Any law or
regulation which provides that the language of a contract shall be
construed against the drafter will not apply to this License.

13.5 Severability. (a) If for any reason a court of competent
jurisdiction finds any provision of this License, or portion thereof,
to be unenforceable, that provision of the License will be enforced to
the maximum extent permissible so as to effect the economic benefits
and intent of the parties, and the remainder of this License will
continue in full force and effect. (b) Notwithstanding the foregoing,
if applicable law prohibits or restricts You from fully and/or
specifically complying with Sections 2 and/or 3 or prevents the
enforceability of either of those Sections, this License will
immediately terminate and You must immediately discontinue any use of
the Covered Code and destroy all copies of it that are in your
possession or control.

13.6 Dispute Resolution. Any litigation or other dispute resolution
between You and Apple relating to this License shall take place in the
Northern District of California, and You and Apple hereby consent to
the personal jurisdiction of, and venue in, the state and federal
courts within that District with respect to this License. The
application of the United Nations Convention on Contracts for the
International Sale of Goods is expressly excluded.

13.7 Entire Agreement; Governing Law. This License constitutes the
entire agreement between the parties with respect to the subject
matter hereof. This License shall be governed by the laws of the
United States and the State of California, except that body of
California law concerning conflicts of law.

Where You are located in the province of Quebec, Canada, the following
clause applies: The parties hereby confirm that they have requested
that this License and all related documents be drafted in English. Les
parties ont exige que le present contrat et tous les documents
connexes soient rediges en anglais.

EXHIBIT A.

"Portions Copyright (c) 1999-2003 Apple Computer, Inc. All Rights
Reserved.

This file contains Original Code and/or Modifications of Original Code
as defined in and that are subject to the Apple Public Source License
Version 2.0 (the 'License'). You may not use this file except in
compliance with the License. Please obtain a copy of the License at
http://www.opensource.apple.com/apsl/ and read it before using this
file.

The Original Code and all software distributed under the License are
distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
Please see the License for the specific language governing rights and
limitations under the License."
                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/Makefile                               0100644 0000000 0000000 00000047666 13101126656 022641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# ld64/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.



am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/cctools
pkgincludedir = $(includedir)/cctools
pkglibdir = $(libdir)/cctools
pkglibexecdir = $(libexecdir)/cctools
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = x86_64-unknown-linux-gnu
host_triplet = x86_64-unknown-linux-gnu
target_triplet = x86_64-apple-darwin15
subdir = ld64
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
depcomp =
am__depfiles_maybe =
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing aclocal-1.15
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 1
AR = ar
ASLIBEXECDIR = ${libexecdir}/as
AUTOCONF = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoconf
AUTOHEADER = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoheader
AUTOMAKE = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing automake-1.15
AWK = mawk
CC = clang
CCAS = clang
CCASFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include
CFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include -DDISABLE_CLANG_AS
CPP = clang -E
CPPFLAGS = 
CXX = clang++
CXXABI_LIB = -lsupc++
CXXCPP = clang++ -E
CXXFLAGS = -O3 -std=c++0x -isystem /usr/local/include -isystem /usr/pkg/include  -fblocks
CYGPATH_W = echo
DEFS = -DPACKAGE_NAME=\"cctools\" -DPACKAGE_TARNAME=\"cctools\" -DPACKAGE_VERSION=\"877.5\" -DPACKAGE_STRING=\"cctools\ 877.5\" -DPACKAGE_BUGREPORT=\"t.poechtrager@gmail.com\" -DPACKAGE_URL=\"\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DEMULATED_HOST_CPU_TYPE=16777223 -DEMULATED_HOST_CPU_SUBTYPE=3 -D__STDC_LIMIT_MACROS=1 -D__STDC_CONSTANT_MACROS=1 -DHAVE_EXECINFO_H=1
DLLTOOL = false
DL_LIB = -ldl
DSYMUTIL = 
DUMPBIN = 
ECHO_C = 
ECHO_N = -n
ECHO_T = 
EGREP = /bin/grep -E
ENDIAN_FLAG = -D__LITTLE_ENDIAN__=1
EXECINFO_LIB = 
EXEEXT = 
FGREP = /bin/grep -F
GREP = /bin/grep
HOST_AR = ar
HOST_RANLIB = ranlib
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
LD = /usr/bin/ld -m elf_x86_64
LDFLAGS =  -L/usr/local/lib -L/usr/pkg/lib 
LIBOBJS = 
LIBS = 
LIBTOOL = $(SHELL) $(top_builddir)/libtool
LIPO = 
LLVM_CONFIG = no
LLVM_INCLUDE_DIR = 
LLVM_LIB_DIR = 
LN_S = ln -s
LTLIBOBJS = 
LTO_DEF = 
LTO_LIB = 
LTO_RPATH = 
LT_SYS_LIBRARY_PATH = 
MAINT = #
MAKEINFO = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing makeinfo
MANIFEST_TOOL = :
MKDIR_P = /bin/mkdir -p
NM = /usr/bin/nm -B
NMEDIT = 
OBJC = clang
OBJCFLAGS = -O3
OBJCWARNINGS = -Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage
OBJDUMP = objdump
OBJEXT = o
OTOOL = 
OTOOL64 = 
PACKAGE = cctools
PACKAGE_BUGREPORT = t.poechtrager@gmail.com
PACKAGE_NAME = cctools
PACKAGE_STRING = cctools 877.5
PACKAGE_TARNAME = cctools
PACKAGE_URL = 
PACKAGE_VERSION = 877.5
PATH_SEPARATOR = :
PROGRAM_PREFIX = ${target_alias}-
PTHREAD_FLAGS = -pthread
RANLIB = ranlib
SED = /bin/sed
SET_MAKE = 
SHELL = /bin/bash
STRIP = strip
UUID_LIB = 
VERSION = 877.5
WARNINGS =  -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof -Wno-int-conversion -Wno-char-subscripts
XAR_LIB = 
abs_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64
abs_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64
abs_top_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
abs_top_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
ac_ct_AR = ar
ac_ct_CC = clang
ac_ct_CXX = 
ac_ct_DUMPBIN = 
ac_ct_OBJC = 
am__leading_dot = .
am__tar = tar --format=ustar -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = x86_64-unknown-linux-gnu
build_alias = 
build_cpu = x86_64
build_os = linux-gnu
build_vendor = unknown
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
host = x86_64-unknown-linux-gnu
host_alias = 
host_cpu = x86_64
host_os = linux-gnu
host_vendor = unknown
htmldir = ${docdir}
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
prefix = /osxcross/target
program_transform_name = s&^&x86_64-apple-darwin15-&
psdir = ${docdir}
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target = x86_64-apple-darwin15
target_alias = x86_64-apple-darwin15
target_cpu = x86_64
target_os = darwin15
target_vendor = apple
top_build_prefix = ../
top_builddir = ..
top_srcdir = ..
SUBDIRS = src
ACLOCAL_AMFLAGS = -I m4
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: # $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/Makefile.am                            0100644 0001750 0001750 00000000046 12612724205 023244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = src
ACLOCAL_AMFLAGS = -I m4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/Makefile.in                            0100644 0001750 0001750 00000045273 12612724226 023273  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@
VPATH = @srcdir@
am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = ld64
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
depcomp =
am__depfiles_maybe =
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
ASLIBEXECDIR = @ASLIBEXECDIR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASFLAGS = @CCASFLAGS@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CXX = @CXX@
CXXABI_LIB = @CXXABI_LIB@
CXXCPP = @CXXCPP@
CXXFLAGS = @CXXFLAGS@
CYGPATH_W = @CYGPATH_W@
DEFS = @DEFS@
DLLTOOL = @DLLTOOL@
DL_LIB = @DL_LIB@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
ENDIAN_FLAG = @ENDIAN_FLAG@
EXECINFO_LIB = @EXECINFO_LIB@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
GREP = @GREP@
HOST_AR = @HOST_AR@
HOST_RANLIB = @HOST_RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIPO = @LIPO@
LLVM_CONFIG = @LLVM_CONFIG@
LLVM_INCLUDE_DIR = @LLVM_INCLUDE_DIR@
LLVM_LIB_DIR = @LLVM_LIB_DIR@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
LTO_DEF = @LTO_DEF@
LTO_LIB = @LTO_LIB@
LTO_RPATH = @LTO_RPATH@
LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
OBJC = @OBJC@
OBJCFLAGS = @OBJCFLAGS@
OBJCWARNINGS = @OBJCWARNINGS@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
PROGRAM_PREFIX = @PROGRAM_PREFIX@
PTHREAD_FLAGS = @PTHREAD_FLAGS@
RANLIB = @RANLIB@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
STRIP = @STRIP@
UUID_LIB = @UUID_LIB@
VERSION = @VERSION@
WARNINGS = @WARNINGS@
XAR_LIB = @XAR_LIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_CXX = @ac_ct_CXX@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
ac_ct_OBJC = @ac_ct_OBJC@
am__leading_dot = @am__leading_dot@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
SUBDIRS = src
ACLOCAL_AMFLAGS = -I m4
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                                     osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/compile_stubs                          0100755 0001750 0001750 00000002542 12612724205 024011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/csh

# Attempt to find the architecture.
# First look through the command line args.
set arch=unknown
set link_cmd=(`cat link_command`)
while ( $#link_cmd > 0 )
	if ( "$link_cmd[1]" == "-arch" ) then
		set arch=$link_cmd[2]
	endif
	shift link_cmd
end

# look for an explicit arch file
if ( "$arch" == "unknown" ) then
	if ( -e arch ) then
		set arch=`cat arch`
	endif
endif

if ( "$arch" == "unknown" ) then
echo "***** Unable to determine architecture."
exit 1
endif 

# Create .dylibs for each file in the dylib_stubs directory.
if ( -e dylib_stubs ) then
	set files=`cd dylib_stubs ; echo *`
	mkdir -p dylibs
	foreach file ($files)
		if ( ! -e dylibs/$file ) then
			clang -arch $arch -c -fno-builtin -o tmp_object.o -x c dylib_stubs/$file
			ld -arch $arch -dylib -macosx_version_min 10.1 -no_version_load_command -o dylibs/$file tmp_object.o
		endif
	end
endif

# Create .frameworks for each file in the framework_stubs directory.
if ( -e framework_stubs ) then
	set files=`cd framework_stubs ; echo *`
	foreach file ($files)
		if ( ! -e frameworks/$file.framework ) then
			clang -arch $arch -c -fno-builtin -o tmp_object.o -x c framework_stubs/$file
			mkdir -p frameworks/$file.framework
			ld -arch $arch -dylib -macosx_version_min 10.1 -no_version_load_command -o frameworks/$file.framework/$file tmp_object.o
		endif
	end
endif

# Clean up.
rm -f tmp_object.o
                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/                                   0040755 0001750 0001750 00000000000 12612724205 021760  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/design/                            0040755 0001750 0001750 00000000000 12612724205 023231  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/design/bindings.png                0100644 0001750 0001750 00000061335 12612724205 025541  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        PNG

   IHDR       5   	pHYs         IDATxUffef[/333+2323-3333s_IN$N2# em<H31C0!`!`?X!`!!`Fk!`1Z0C0"#0l0C0b2`!`D1F`!`!`he0C0b]C0C!`!!`a!`7ZdAzNq!`t$!$<B2G42D~pAu<H},nC0#+1>?&xp>}Do!`@E1	yw%o{?AnzJ|7` &6`a#O"KB#t!`@.obR}nmq7/1z)Hi+CAc=}nt'pBDo'vC\^C=fq}+3ZLnD`d\h e]M7twc9fdz~\sMww:G>ad3%4HCa8QyTVWX UMC\1&E~38n6szjG}]}nFpC9dr$MRYeEG&LVk?d"BJuwt#4;IM6`7jUi
.&@/u]Mh2F-BnUVqs5W(?yDVLnF s#.ToZ^{uvXo|CLL^ye}#oK=e?s9]"HQyB{|MKM?ow|AY!D/aB_2,}B9"_Jy21b P71/5/9/e]OGA>XcwWb*V&r3.qq,N:x;D{)[lN/5vM>!diCOfi.#`@MY.T^;j9V_}u7p@O?r$dTgW^	#cqBFp@9zVrB>hwG'l2wGi2SN9iO<[yc"H!EruQn"]I'\4D;0%*ZS%=!`TGnb)q3>tIFW?LdQ]x <>Npk>70\>-rnp6{>c)N>Y[r{>vuY.Aj~#S;cdF	"BH[|q5}F27<c04qB;u%0c
$AK,DH
KWtkV[RDu]7n[Q]it1-]tMEUOzA4L@k8cp]l4MTy#_g%4C|QI=="<i}g=DZ0d9({=H#|,+5:5CYu#4RX	jYg-OE4LC5d"F*b"de-R	m`-bze6h`!a2S;#%}favP2{UW],wDH/<?1Ky,@DTbG^Fe_J>?;q27sYbVTRFXMw*}XX.h\N ;]IBwkgY$ky1	I*1^d6V~Vvm#*?Q9Vyg2d-O6U
s"qAK-b?OXdI,0ERT$a?g<)jlvR~-/@;!P7"A^hZT^_}[dE2YP#<p+S(xq>]tQXuQGS%29u*Mo	4Q(7,A?:LbTYIg(O{SB2	OA#T%!d
M-,a;}mTY-z{WO>dTTovFe\q4<t)p{n BE{"T:!Yd"F"B<[7ec^OzG,G:5 WyMqa`.&*e?\nhAY)u!rebC NYq1NX3uWYMA'7pCPi..F	##pb:^XnXt&7X\-j'C K`I&*g_-N d{_VC@~^RY@"	XR@TJk$1RiQBhCBlqR|}J'h."/e|[ZMaJ1!PXbKK|})6}A\J0T#$?evEYs1s@wiw%<0C9uYa[`	U#>B.Mk7#	eN-U4gYEBE2162T@e y7c-Q 4-nH`J@R^~i@[B6X0j?Xs=spB5n< E*d)xuYO=Th^(|=Bu,k&'+=NdN{
/8Vm1FF`sfmp+l8i1BJs
),jH:(BZTX/eY_|1wj43kn$Y=/jILi5)X	XkzjGeQ|K7HgykqtZclfl,YI3oOLnbTzG%W,B)RR%Oos~m]K)
s#*@qcKYAy//&#	E[<0q3ofa;*1}7usa"CT</3:CK.$0qsq3B;F?k<sa#@h\>G}%i3p5sc1!u_<'/;F+,zIyk=h;v[(E~__uQz_x*=w47dIn8sboFjEXXWzL:	s .<I*oF@'= ,77k.J*cJ/:VnJ/Rp*uaQ*m4"K35th2fv?}W_}i )#(|T|?$Jc8xR|P!/BH4\0!W.<#B.`JZX[yrg!QgsK\QW2aZ>ub'YyE~'\TT" Yh(<jO?\\hPhhpT:4z$$KX.nrU\"(XX 0ya*\03QiyERYi`qbb|x;m2N$~%+8<HR; N34 e#dFwH%3 lhT"A?a\ X>)g"+Ofb9(,HrWCSPF(" AKviS.Bri`!!quz\k"bt{wHI!M
q[/k
\tB$MFd;$$fMD'x@71s2z-#4VQ\TBjDz{]o"}`U%1W<	5N(CN)J_g	',Gy/&-^*{\ISa4^#%|#2KqfvEHxadt0&)3@Qw<x@"X[j\Ghi u
'-N,OrJ*Y*LEx^B(YIp@=_0+	Uaf1&'^.e"IQ9sVZ\:!fHh6*yt#&2 $)d&wY B < ^/IPICP2h$.rJ 4l(YA`J=}8x2h+Fd<x08 !pnKr/\K~4]'!SD*=pPMx&1gPl(BJ-Z>SO7^,hWy)xbm0Sz5(ST),"YRsWT
w^(STl*S+Wz}X!Rzl$V:hE?x8e
z9u-RL1P10'9MK>ku%L3%z.3otlIdjyX=|;E| VU'#aArW
qh@gMn/*R,X*BE\;)":iUZ='}""+"%7<Fv}quL2L+?y=vLA >!},I?TS<x#lyN`3ECt'fR1P2Tq|	C;A/!Z<I[T4<,ZZ
Y1*YNX:YaK?&FwBNE^}(zC Q!DAM!vQlP{`22QKRkc"?'qZ-uC{25!t,_5Uq2dL|AJLYs. _i.ja|*CzP=Kj2^j#0sFAqD(
Ez>~X"0M2bR+.I3/2$s4NA~XwGeHaE'`uMK"$kIb VdN[|0$d&W_6#bHc,Q_n=.j/:&R
FQk-4 P1*/*/b"cuF1HJ0d !
&?)szG')03aoV`x	^W3z;.KG7-!	MdX	C**;*9:9Fb+,HS%eI~Fn ,y&*K);L#8snH]/"ycgCT8\5=;Q
'RT%GeMB EX^w\Tfl*^aI*S`3y)"z|/gp_Qr,`W$rAL(FEyG!PZ	B	BtXl~lyJ#qE
X(*Y\Qaq*sabaP(O*'#6d~6*:2
o]Lg$`@#clcdWBdeXiztu[J[a~9c-RJE
R"XW++rD6q>&DfPX^*6 Y29C:/(NFSokQ0Z@&b+*XR#IJWJ}~ZCMOkG l)*;qyHz!..S~3s<Pv <aL*{iqL@D(Le*4k18<GJ]!TjTXqkt_zu{\`@*4b"/e,j=nlQnMDFj}j!`@fb$***0UXTyW3l']/ybt_2>s='d]x"]hT[,*7^YqM-50@.r 8S9@TrrqH4RL;EoLI~~g?,pqB11HCAOt ArMR1r#FBC$FJ.I:"hJ_Subi(BAg1[RWrD"TR"j!zjd=*1h!`@HI	r^qV%}UjqJnK)"G1
"FUe+e)M)R!1"ic_4jt/qgVIqO'Bfd\^ 8k)	k9@1h1#E! rIjs^NdGq<IGtO3C2F3B@$'C.lII;$oQYh#b=Dr"As5DKD|"F'n	@1X4DX4LCG5QnBu!`TE*Dv!`@7!`MOj!P#!`c7=m!`@UBd!`tF-!`U0b
]`!M1v!`TE*Dv!`@7!`MOj!P#!`c7=m!`@UBd!`tF-!`U0b
]`!M1v!`TE*Dv!`@7!`MOj!P#!`c7=m!`@UBd!`tF-!`U0b
]`!M1v!`TE*Dv!`@7!`MOj!P#!`c7=m!`@UzEJRj^2H{?!`@C1Izg O'5!>_2tA:%7R0C,aV    IDATJ1	1o61!*dQg!<r#FbLG wy]r%ot{c70n&r6X2G;j@' !~-lfm|w1ze+RD}cu_~[p	';/	`!A|%>:uvBD,ns~s1+Q~[s5wvGqD7+,=90f1w\7ls9HH!;mfnw|M!|Y-C0Jd 	HC.w4Hn`NHrrlXP(6CDGm0F )bExw#=B~WAQ2z7^zfu~a7,|}gJ+<0vFnb)#U.?N}=@k+""V1(*/qj:~{w}W_=MM3C o&F)
17jgK8p9OB\9{!?XOo0K/,gM2$N*c 	qkO:ptMnrL0nV_~/3L3C9|~w}7X+b&!`5bK|e_QK~C>(1gQo"o~c/+!_}U~xU?Gt7fw<fu[oUzKSL1Efe^*i$%W[}!=N8[o5
+<>b-V[DC?4<{sY#K>`w-(=%O.{S}Nz.y--!-?#]c@;"g FT2J~zC.x5s-/o<WoEo-_3$:|]b%@Lo)4>${![NKotbB<{9k^~ev3kqCvZ8g?!`tuR=a 'V6/!G9SO]d6rN;'l2'^?O>2c=KdL4q#La-By{qTHXh@&b H0:Y Fw{f}~a >|K.{wg	>#HQD83T;#s0L(Y &Xy+ 1Z|Xkms,LXC~^uXp4nH R'<;5y]EJ=5>0QJQ@Yemuznz'k|m=.La{M>a$n@Xwu<050k{l#Q'`4*H.:%zY]kza.n\Xxs=C#0BXm)w}a-guSN9~Yh}xgk14yWx}EGe7AJ0:a#|_[>+0B3>}Fd22OIe<A}#ZuEty> oAP`C~:`(L_v*#*Y)_	:e.2CB}+S-N9K*x.fdw't>e/QYn>K/y}uGydiN=\tEK[}PF}"bpu>tMK~>3(+e';&w*^)b,/\{~`yX/eUVO00xM-20{@LCFuWZSx2S~uo5y'x`3	B-AuOrr\RoyY')HLXP7Bj>8cissk$# S<ynj^<jv>F;|oA2C=txk2&%*NK|L(R$xz=['
9}qaf.d96 F-9nW^ye9\|o1GQyU5nO5	-m?4y$c(.VaNz0it*%&;aN;	Eh#Pw(}qiK2yKX[raaF+zq,~S8R]?)GN,r33$fDyGKYo>c5c\.~>rry"4hU"s{Cl'9&2 N788\pA0
X`QH2NE#_XACY`)0&RxpcTHi@%IKOzZD
)PB
!R'TB#N*/d$spxq	_%,FE[gutXP-,ul~|N>!	X+{
/
jsG,b @T*yihB@)5p>;$7-8KxT)}
xi&4|O8y~<B|@0GS\PsD},.'kcg NFS>tE?G@;uNOiB?+O.={ XY{!_~yh$JWdx%F=	,Cd~A&D}#	$s?C\DYa4/#Hl0-5FECs$69^T:s|@EPhh$-ymI2}=E_306,Z^hRa
pix]\KBEY)+N@c!RiAD."FN"q?<$0y_ 2<Ji;API! *J[V)_9$YI/t@\)WX2V.]EY.Cg6R}w7~}?~+miydsH.!_C>"BE7ux%)<xaaQ1b1! Gk.A /

raAXzfM[C52,o?m^+eUR1E%\T|0-4"0`@sXFF!$R8}"M>R /_1bC~LSeQzD= Fn8u	,14HRVL
k *{/bqRe
HXa4
Vq9Z3,yyK+b'X*kHF.L</tqU[gN<k9.I'e<=/(}RQpfsX#XJ`}/X04N[!=%<w}F6,C|(X$NE'O9=x7t(/J*to\R0r
Sf%|ESr-ySJ+2xk$`<O?=\,7O\%?)f+,Hy}0::-)q|JT!Ff>d$3Oex7|gtc%]zu#Rrv.yK_H+9Ar}HFeI.0X)0#kp<!pOb/3PK-Wn?21y0_hZ:|#pNnbEY$-:Fhce0D\g@ZXh9RvrXpY2o~Awn\aI.DVq`}{
,'c)NZ7@]G}+UFAyZa@H:<PQ&]x)]5Ch.E
>cqQu)Kp_{7K2~af8aE1ABL+9-$CltQ6>y5Bt&`8Kt4+\m?:5=Q8( xx"q?T*P\Jx8%_) 5X}@Ai n,{#uq<x6(BPNi41h2ZnZ1Y+}T"a)<G.}iB?E!|.4I#Mu,TIsuBA)j<wO@'J[V,}=7c##<P8 ~*kO_uM?@LXQ/sZg_w,*N3X;t5bpG3xD]Bq)y=v+GAaP:CWNtshgnn"Fmq!`4t9R:<N~e!<2cRb-E;It4j'=]!`=D1),vNEjc1'b@7#1B!^\O'	%p?d'=m!`t;udAY"aNA~SyU;I[CQ E+w9RL<ZC0A 1r"(MBdR@,}<(Pbll!Qd B~C{o[)_gB>MH~e)!`3Q r4XYN^8-1A|6}F%v.!`?89+%v}eO"+y|qav"#/C|OW/27S+s+Xm0C]{Ta1a1b-BXV308d9(l&rKw0b#?"BFSe1+foi!`4u 
$i@z
!?y9rQ
bDX"FY")0Anb 0&HOy@
y(kbl)GOteBMzc3r2bB`$ FY
9.l*EM"E](*%	1r!`@g!	 
D`-BrBEU#!QY!`@ E
XP@l"q#ib]*j
&T0C3D@ 9@,!b4ZI1sDjGW eED#O,.C0"Q9h/b+&Eh!N,U3H!,uLy}q\o!=?-6Icdk8d|[ XDp:B~"?p\!`@ +1M'$IPuL5 <DDqy]!`@g";1
DQ*%">$}]g!`@"0bLBe|FHZN7C(M#d41C0*#sE!`!1vcL!`cHu!`]cW<f!`@1]g!1vcL!`cHu!`]cW<f!`@1]g!1vcL!`cHu!`]cW<f!`@1]g!1vcL!`cHu!`]cW<f!`@1]g!1vcL!`cHu!`]cW<f!`@1]g!LJT:zqA$s^lC !<<!;#-0""`XuI?ktA&C]G!`EChO#30-w6XdCD-S6C16 QB"?!J7[ _>aS"BC0:#=ZR9b&(D,4NA`O2!_~ZOeR[KC##:Q.TXl~!$!Q6C16qbk1]MC4l=Q&&FR[)?c[ mM1rlC16qc3<X0R,cB0U7+t,gLY*ctCh&%WgP(5j?IOFW8	+Uz.f>V6B!
3D3]4G+Eu^a3m`Tb_+Y3a@R(xs9vjy5"@()4Lnuu3Oq1&xk51:H=F6CU6F*Q{,j+7aecgfe6;o-mk 1%R<)b%n9?nu@sNN;=zk/8FdF
 }CXVf!']T\m"s=^r;n:7<6-"n&r_}xQ1!m+Yng0C(#I;tm{N^x~F i##cb!9drBXNl#"u{k3TL3;lT.=sfN:G^ MeHaR^3f'Cd"Fr)BUW]k,`V%[n97c|Ao%;M>r11p6Cy.xVH;}b#*7qv!`4]TA!UVYz75UW]zne    IDAT	ZD>F\c=GXpcuSM5;SF0nWz?+;lSx_ePDu%T9!TB]*}-]C7u#QQU1bQ=wJm|d%t~c1mH{pb<fmn@{QGB30mHsT)$Hy;K.	{?YT G=h\1K<iYShuRJ#V~{S5Lknci#.W^	zN<!llN'"X=7/1z8S,B;^xKN8}wUWN@UibTi0HeFhK/Q4!$9BXbi 7|94O<f:P,.A/COB)@4")CT;Jv!`4
e"RiEoE'W6GT$1)B Xld@T;	}$%R;t5:0xET`,r?xL+$Eb}n4G53Yr=i=
L )r!XN)J:n"%Xb%7\-u5"Ek-; Nc2+,DLobA #YU@e+jnVpWS#@0@}7Di0jRr7/$Iq-	0[E+xe5\3'lp+(RR|ZvE.bTFUBe>M5p@7k*Q;Ym&Qg@yu)1g/.0_va+boN'9w-OD_S'by1@]+CVb\{[/XqT?H#o%)(,4Ja}n>wEyP:yG-"TYoRC#I'P-b-|]h!Pw##0k1p-X_j`_|1TLf3HDpn
C;hKI>'~PUTlT0#O<Dl,vPj#vBK5g0bjBWg"QMZj2hM}]`J%
\sh[z<-H~<d7_"cz{XcJ_"%*+tPNB~S^uzy#VHn)t9%`+gdGmIsTYfm6,WX;oR#Vc'H	H0K7WG>xG(4M{5\j'1t(=YZK;scZyc95Nq2f9tFG qwq9^6>:+\db=2 cuK7,&BYYpE_DZw8cW[:4H
oB4{)c|oi7}Yd*D=
K\p[z;TI"SEJqM~q7o;`.l Lb.hhr.WV,/6(T Ymgyvis#GQnEH#a,qp/C#-k/k|my5-}x@X;6)x{bIknb-2${vqHR.QP`er!n6
u'AW_}uZd	,RU;31E~L>a8%=$XenDki_+/to.jTcY@>k4mw?,c>[J)I0e7H'0]GW>V[
i52:g`>1uQIqyD/vK{/$c>Ap,Hg=.`|BRG=HG>NCno!#Jufpkx|GN;q><Q1b>dc~@~x!].b$X|&bm\or1qJHo3V#xezByh$_+H1GLuc2s=T
g^}P_ .V-"Q _b0)&|
8TvcV);L}uOE/WpaK k*:|E2jXY<[>nG*/u^ :F	3*tz+N9sqIB""[t! dE	,L3^}eRfA}7A-cXiJW#!Fz?dHY-zV6GHP.iW*,YV0'evmCx:S2tiPi<<oX)|x(I]byN;bwWqu	'QA7-qV!sRB)?#<hFYSB
e,DNSpAe4^N
V=D*J0}|	TX\C%<sn=i!<rB#YE xo}q@ T4*PAFXiHIFbj~1s?#FCXj+^{w}wsT4!?ICR [L?xbIcBz-6_(;`J9I,< *!}-'i."TFB2U>z@x6V&q;-B#.~gy	q`]o,(m/p;qwIc'8^v:''YD9IyM;Mk_a|LT.*KO|T*lv k*CxT"@XD h#X-z{<-~H"u
q IR*Y09z*N~J,3Vpa=RzEc&cq$WC:)z@$u5iC~>q
X
@`N`9u&l<#hxR[RB(8;,\wXV2~Ygr%MG#,[C U"n!Vt!O61Tk1aZA7ZT lXx0'>pK"OH ] |+Q_<*3RrH
d6{,k_L7>E(/=ii,/G-G)$~,S^DN8,cbQ~1Q*P*y@d+ry\PIA<wF/'  !(	y"M*tIkE7	'kI'z_=C+rQ  kEE7MxX'5@n/^" /}+*$AB|v%IEH7/oR#+EECBI:QaQ)@k%GEH\ycfh5(epB=,JiLaYV@pY!Sp>03#$R>V!v!ZUTXqA).H%mE/ 8 RY%[KDO=$n4
_LA&8)xA[{gw#ebLC+2?#.-BS@0 4]'!s h<Xu!q\*'GC8]xCxwRb#x/yWXrJP}%(>YCw-?)Jp%.WeH/-$Y%G|'T
]@%/T[+q[4%lIGeVK	+,8pCz.SufP-vtC:3akOB|,HpmT:/2nw:)G'M*ykzyJ1-cv=n*BQ\IZ{l1U_ 0;itC\$ro_mN.*ZJJ|MEZ//-]OP>
pb	3V6DN~C4J)@JZ>u0~eMX>dPrNMR$O!,lG+eU@i$)Xz_C(J2XtM|,K|R8)xosU_KBC		aF2a_,;M	2?a PxxQQ?C%q>o+A0P+#@(n<<B 
V0D"TXOyFvJ^;5.cRT>-n]G>xM<l&!P<F!j/ dPTujkbbX8OY8dG 1sqcHg43:Q0C
Of7V iUDcFm1R|?
B*
WR?Ya13-Dnb9,D<J+^~6-6adAlWUd=I4,lh&u#JB"BHXc"0+d(~Xc$u'QDR;CLCx=F@Q@lD`,-&a/eXAn[Fg3	lMVcL<V#
wKb"DZ>vC.bVWEb]=3p[qo%QN>D y`
m"Hq[8h_T}crY@aD'#ayT/32NG.bUZ!FHb)	s9@R>
V>Db- +fsK:w4XTC&=!MdK(R<_T`kZ%|td d-qe[UtEE#+#x., 1'T^+SMvFnb-rbTA 	DrS&QV(yr-FBblDU>lzsbE!-,C@YdAXb*WGOJ!dD4kMGg2j0J##Accd6_`.|qXM,vC@&b,2Eb(7`DH
rux! ,E`9`ok|FOw,ar*_*sqA0@ 1JYOA%WlX[U5#T%,}EtQ)/\>q4CNO<\q0X}_WAf	OgB"zF%BKy',R^:Y$J &G"^| G FH\)Io
\qX0&e-B"lXYckHgq7tP[+Q; A> JPj 0'BV#y&!|2#*cCpD?CU	=5Z_U_z(v}=;.;"FW4"$Iu<=HIa=z{#*G8F:Cl>(bTW}!P?#EQ9@TT-=j[N8E( -HE^`s>l_qM+W\OeI{%!`4QP9!r)\k*ltzOe"zs+ebR,FYV+!oY#TT9&=	z0{C ;TRPu>*VWn Q)@6X,b\Q.T-v/!`c2[TII;*V"UW]>s_ZbcxQ)~X5#<r7:Iz>9"jX' Z1[AO-GgJGCwFagcD:"+*N qdQeJY5CI%Z%nbAG	EHb]!=0+$8oExHRJ>\!,FH^" =6E)2iQ>$ZEI3%8jPZZv0ccSemP91(bSbI
 EIt~7U.[tO
H! dfGg0%D$9<d|0c15" *m%eQ53O\L "ixb+CGb?<87!`:+LEIJAI8&KNnDYJ@bB"GA{!JGHdC^uzpd=?qy]!`#b<<!dN%
9!YKk
tIGAB*t!"B Yq "}G:_71b!`XB$\!@*m E"Nmi->:c]I?:Y!PFR.$UTTg;3z!7sjJB[,:t?l!BF=\cf(}tMJc!`$YK&#{2Y?DE7D0O%E]u].!$<3:X,!MH0NDO[ouM7kz-Bn}uz?)va m~{\rI{:>>/rofXAo"'pBj^{
Zq9+rzr)1dT,:88@-7C 3=gQg"+~ ?5\h>@'|Y>r'x[wu=|I/>:|v>~O[o@[n6
i:>8g!`O  kIDATXf}`?{L34wyLjUV	dy"A>gyvZ% ;.XXi,;Yf%X|,u[gu8Z7CmYKm6:Cqc|ySa_$7/v;CFm87yN
./M8SsJEKtP,C0;\zcYV[m6x0QN;UW]5|oV!m.px VW7xK.q{oW>W^9^qbaB&!`tNHBv|7>7/>6F"M1V:eqo)O'}
#eMyCh7!`E
En!n13}C0cCC0#v{b!`@C0bl(!`@!`nO5Ch(F"7Ch7!`EZ!`9-    IENDB`                                                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/design/hello.png                   0100644 0001750 0001750 00000026471 12612724205 025051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        PNG

   IHDR         %d  
liCCPICC Profile  xgTS@(RBH..lB(1T`DE*8@" `2((*|{_^{}Z YA,@2?Mb<I$XTs`/p@[FZ79l @d;NF4"@ \`f a29 ;*1 W$ <r ":#EjD9<> dxhaY,wMnTA+{rJNJG"3/z6Ct~	=XYs]86}N[Nv_-q<Kc.>+q `f\	<n|ybL>afbj*	?;R )@WK}Sx~7 zhD 4.0f'A ``x l [A>(>PQ Up;` Dh
iAd9@/EBChT@:]!4
MBo/0
&22/agW\8]p9\K<Q EBQj(#5BMTDnFPSh,fvh/t(NAoB+6tz-BP0J-p1|Lsss3bXMab[]!v)p ]q$*2|~?C"hl	!PL%tn	3DiBL n%[WH$:#m!NFIT>NE'wQ(m%FEi\<|IK0%8%*%$%^K$$%HHI)9%ErbIm:+uOjZ&m* ,]$$'=AQT5zz:FC4h46mv6.a$RefVt&=^L?IK",,+SEnXy'XV;_


{(W(f*R8Df%'<T+UWVVQT(P<BWqRIP)U2JSuP^T}e83HMIK-]zzzFFFHSUOsfC-V~^:'tu:9::u))5zzza}xJ!oXcxllal4jL755n7~Tsi=K{~70I25ydJ5654}ko64mN10lafeYYlfie)lg-ch]d}cbg[K4%5M,Yv=!#s1.&.B3.]m]7v<
O=="O]^/=^L6)C	y+= f':)\Qyi`Z!.!!BuCC$V5}w/	X1Fb$/#
U5},VZgu5k_+T4&:<)++UaTW'N)g2>$E}\I;_?sU$x%T'|LHOM
OjM'G'Su*	})".J]&tG32*3>eeggg~zzjn&hS6o5q&%oS7{W@i&e_E4]q-qOCtIN^m+[VV?}Hoy|SRZTACNZH[vMQkj{N[=~!InNo<q-F-GZ'/IO:]uvjntDv>iy_</{B9]Sv?qv+>W]z5kl^~F[E_-~=3`9vf`nzy;CwC}I<x8hc'RO*=Mn=c=y)^h08719rWW3SGkp_!#|3wON?ac'O?~	b&+k7o}?M9/Bf8. P"_=;b>=\% N nCBb`s(H37,Dw :&98; Jl qbQ/L   	pHYs         IDATx]pV~D0`W[!2JIpXlw%+ (25"L[eg(Xt\p*P-B]`M$@vs7~!}N9sswf)@ #*E@JSP()=ET@ dOA0%""(SD:LE@:JSHK4m=zVz[n[E$~";L",f&a(TJv/Ip!7\X8	87.iWb$B3MZ3.8$)P{IKb1<^xaq$72Lv!U?O?4mO?m.>}1m4vm:t%<Il:E=b%s?sjjjdXr%<h' 4l\ "fX={D	[6FJ'D23f@^^JKK_F:pw`,\tE{b)@`IvZk1('zDj"b9S@`.d%%T:U"\zw=u<:E-]]WVVbxwzt.Ggy#F@ff]%}X'.$;ekk1uV;rr%LoUk.
&d2baq3vXskwWDB ee?z]bFjLbGwbL?	coEk#Q],k|4hPrbLc-Q;!&';59
eu#NOe''kbKo2^8Ps`s&bYa +$'be%aWLvZY6
:!L"%z[	DvJ%dSuA9J}m=:.
P]AM0g(2a<V8y*vpT68AfLJ6V5YKrQ6hH+qHdb2]7asMlou6cbm9'pBv{%@dLy-7 1y?J-P`~A U6vt*s+-`^_Be=Ph-5y~;3t* bOJJJ0dL:/B+v9zc#;=6`Eb&\!3C8W{lX {F,g"|{V799_hyX{1_Xeq-}zq:MTyO%{m_.0SUX<(Go+mB:1|-?	'+EVZP|} C;f}!yf}UAgO`*GRV'`HKM^l>jAYe#[xim(/i:,d?sr |{![! ]8@X&dfFZnmhDnHibw1]f;	c-<y.yycX\/SxP.aVe	T6 i@dr6JE#q?"Z'~TI|w}31=*/
KbtF787_0[7FD?jsohpkSN}>3YZ=E_4k yW/\|v.eV@d~?{W}Zd 7O`nfht=Gfr}$#`Nw,3sBt(OBt[68|Lhi&zr
Ehu,{I%J1oyjiL!6=P4RT6W@|tSC>y,i(9_m'l"{ImGwc]ALoX[0`b)X/7O7}DPs&XH ;qewo]7al=_y/\gF/aON1mUm<j@#.nI{fg8b4;}MD7Y<4Ku4SY(]O&5qG^usaoXyfnyFLL#E KjC1+!;8OG$@WF ddOO&u>d=iQSrz92>}|)7=an@
?ATrip>Adukv#l|sqK}9I5TB@!G#J8U).#dwY:7E (Veh8"d#Z"2Jv}S@
GPS%sKHqoc$AMZ5doG9q#=':n8=k=8su'G?[1]v00Ik)(7Ddff6$KJs5.Z[CP{H|KK>nk
*D]P'_ZvwwZw{Bl]j;Rr}HdK.#G:)G-Bx		%X#@dRy(}'O>/wmjHd[!=kO=;#YO6mG<1/d_l	5(J8q"UUUU8!@L_o.m[51WT2T2RW1vX,Y$i#vb/`S4Ni3f`=(..vg]'r]9sf3\j;.$T<zlS9]'>ArC^#<={6"B&{Qq4pQ
E#b3hI>}#Gw;y"fs}_\W	v'

&FN%<s|.,,>x 'N>Njhr-]vob6/g6%.T-;Dvv_OQD'999v"dtz7nw-x+&\$;uREH%ndJ'@=]"$<IxIvur5G]`%@d$Y)HF$'Ds3,'a#'1'Bv	Dv^c=TXD.V[NNPH$;VP.D,\tjJ`TP:Q:*L\rz:Ng9TsBvbGhP[uQ-;2!=O(],;gzYeg9?RwB%Gu'$9Cq [kewG"-'QPJ*1oQQ9
@2QXx0%^0dRkewG"1Dx*(#Ij'K4BX^3.*q)kA-{0Q*fST8*7.d[,ZuU?GG_-Wa*d+.!.Ih38OFv((WqG'Xs(Xy4Ito~wGBq'Lkz
VZvw0w_w#Cw=	jY'jY'jY'JvwdwG.Y'jY'jY'jY'jY'jY'jY'jk_im&y=?N^oY=f*,T0.RZb^"K\B#ID.#Kd\,dg-?c/y%N3NK]H).dT43/i)PI+0<}elexBP!!gu?O?4mf?G6[x&u}1m4vm:t%wY]&]ujLLwD,YS+WnaFp 65?n<Q=QdDvvJJ%'}n;C?)nF4fS2jX3bb!SN\S:H&0NEE>|8Z_sg]'n(..j-|$S.:%;R	LvFuuuXlaM cuZ}$c	)@7DV?wy'PPXFM7#F4,Q'k3j;eNc-;t~>o[uJ)Vbjm&(IM9*o&=;h!0gb-NAG#@d+"]v.1K2	.X-;b9^N?3pd8vXeR6^-;5uee<Nes.wbK5=WU$:\#:G?uG 0u
d'H\pdecZZ}\~"lSuBvpE.H(;G:J b$|dHS9DLHP't9:^+Q]J.&||5%iDMvv],);0'BrjT~,e	{NC@HqZvw$p\T6[CWWLv&[(xK#!iO\B@4"=e;baFOw	]ZvwT.t~%[dOOx'm"{*HhmcgJCr%db*V`Lp8Y
_(GX;nktCv+P0s# C3 *MFz >JHyj3%n]uWtZ_,^|&WE~u<cKG/,J{kA)w+MBVGOdcmZm,.(zc}
Pk]rO^P\ff1P\pUI'PR~qZ(|fQjgjP8(f[o{E>}PTTd7|c7
^|&@o!xs,lp}{#vDPxq9buF}8,!R7Iv<6CE(tmIEz^]TsXK a@Ko`QkbN+n) V[[_8q"L'|N333[$eUj>e"7<}U,~_TfIx}("[ye6W#h`_]_GVv'd>:x7+	yb<9w?W[ 1[ oQXWM'c{F|5o`&1smy(0yB<U9992e!U&;<,qB-Dx%wKcwsLo\|931(v&uMT?>VoTrLGUirR4\nW6[hfD*~0l9c{eee:NFJ;<,#E:wa}ed2}u
sw_D1ne5Ywb{,LX;7
s-ykjkUk[j9G,\?3mE`Gs[ZAG 0	X7wI7?\T535lV9_X`Vs}n7s,!w6'k0x^b&}%fW9%<}-O6_1w)~3/va^
c3t_YI1;plWzzG[_=XSWFC'~R
Q5iP[r-`}1^M5cs2,^ixqxl.sx.3CR_"@AXkqX=2ewQu#7L[1<hVP	 9r[j:W/\|;oVRY#_mu3L
5$\~4" 5{U*)=Me,}{J!dO)q`S%{*K_R(SJ:TF@J6Pu)@Ld%L).].8@ S{JE#q?"z{-t+L(PC"ws"s,qBl:E Zb>.9}W%G%d["Duv}{#qQ8}EeeeG[>]dh[ 5COeckSO=M6$xHxj#5.*(7P!$qBb]&85@d/{c%KBWr1'^P"	@dgE\bIxzt=(..@X3g*7e j	Lv!9$#TkbAtK/GA=L"chNNrBv
%%%{p#G{n>|X?BwtbD'n_\%y@Sg)*$)x;y$N8a?=2>jNL Iw5myqiI~nWm@}SPx]nz:*0?h/9W@sw-x+x$6?y]*ItdM%>2@&[s%E<IxDZr<'N,z)m!$+!,c  gIDATTLZg6OBvdx6JI;wN]	fM}l.
EAI^z::D^US)2'7D5Pz*iH|Bt!7tTZ^>.S	1&BzG38V=4%&4+er~02!J1	^NLIr$720cH-P((IK%7r'YN ]Ee\,LDgH/yH~gF+!+\ByNBa>TKx$J0kG[BV!1C<G'=HBz/y'6*)E ndg^/R^
9F3K:IMSY+7]*{i<'%_*BpXL&W:@@{dn0E4vK!id!iK"		MSB=B!)PGBE"dPuH@$P4E (C(T"	%{$T4M!J
UDB@	MSB=B!){G    IENDB`                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/design/linker.html                 0100644 0001750 0001750 00000042643 12612724205 025411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        <html>
<head>
  <title>Linker</title>
</head>
<body>


<h1>
  Inside the Linker 
</h1>
<div class="doc_author">
  <p>Written by <a href="mailto:kledzik@apple.com">Nick Kledzik</a></p>
</div>


<h2>
  <a name="introduction">Introduction</a>
</h2>

<p>The Darwin linker is a new generation of linker.  It is not "section" based
like traditional linkers which mostly just interlace sections from multiple
object files into the output file.  The Darwin linker is based on "Atoms".
Traditional section based linking work well for simple linking, but their model
makes advanced linking features difficult to implement.  Features like dead code 
stripping, reordering functions for locality, and C++ coalescing require the
linker to work at a finer grain.
</p>

<p>An atom is an indivisible chunk of code or data.  An atom has a set of
attributes, such as: name, scope, content-type, alignment, etc.  An atom also
has a list of Fixups.  A Fixup contains: a kind, an optional offset, an optional
addend, and an optional target atom.</p>

<p>The Atom model allows the linker to use standard graph theory models for 
linking data structures.  Each atom is a node, and each Fixup is an edge. 
The feature of dead code stripping is implemented by following edges to mark
all live atoms, and then delete the non-live atoms.</p>
<br>
<h2>
  <a name="Atom model">Atom model</a>
</h2>

<p>An atom is an indivisible chuck of code or data.  Typically each user
written function or global variable is an atom.  In addition, the compiler may
emit other atoms, such as for literal c-strings or floating point constants, or
for runtime data structures like dwarf unwind info or pointers to initializers.
</p>

<p>A simple "hello world" object file would be modeled like this:</p>
<img src="hello.png" alt="hello world graphic"/>
<p>There are two atoms: main and an anonymous atom containing the c-string
literal "hello world".  The Atom "main" has two fixups.  One is the call site
for the call to printf, and the other is a fixup for the instruction that loads
the address of the c-string literal. </p>

<br>
<h2>
  <a name="File model">File model</a>
</h2>

<p>The linker views the input files as basically containers of Atoms and Fixups,
 and just a few attributes of their own.  The linker works with three kinds
of files: object files, static libraries, and dynamic libraries.  Each kind
of file has reader object which presents the file in the model expected by 
the linker.</p>
<h4> <a>Object File</a> 
</h4>
An object file is just a container of atoms.  When linking with
an object file, all atoms are added to the initial graph of atoms.

<h4> <a>Static Library (Archive)</a> 
</h4>
This is the traditional unix static archive which is just a collection of
object files with a "table of contents". When linking with a static library,
by default nothing is added to the initial graph of atoms. Instead, if there
are unresolved references (dangling edges) in the master graph of all atoms, 
and the table of contents for a static library says that one of the object files 
in the library defines one of the missing symbols (dangling edge), 
the set of atoms from the specified object file in the static library is added 
to the master graph of atoms. 

<h4> <a>Dynamic Library (Shared Object)</a> 
</h4>
Dynamic libraries are unique in that the don't directly add add any atoms.  
Their purpose is to check at build time that all references are resolved and
provide a list of dynamic libraries (SO_NEEDED) that will be needed at runtime. 
The way this is modeled in the linker is that a dynamic library contributes
no atoms to the initial graph of atoms.  Instead, (like static libraries) if
there are unresolved references (dangling edges) in the master graph of all atoms, 
if a dynamic library exports a required symbol, then a "proxy" atom is 
instantiated by the linker.  The proxy atom allows the master atom graph to have
all edges resolved and also records from which dynamic library a symbol came.</p>

<br>
<h2>
  <a name="Linking Steps">Linking Steps</a>
</h2>
<p>Through the use of abstract Atoms, the core of linking is architecture 
independent and file format independent.  All command line parsing is factored
out into a separate "options" abstraction which enables the linker to be driven
with different command line sets.</p>
<p>The overall steps in linking are:<p>
<ol>
  <li>Command line processing</li>
  <li>Parsing input files</li>
  <li>Resolving</li>
  <li>Passes/Optimizations</li>
  <li>Generate output file</li>
</ol>

<p>The Resolving and Passes steps are done purely on the master graph of atoms, 
so they have no notion of file formats such as mach-o or ELF.</p>

<h4> <a>Resolving</a> 
</h4>
<p>The resolving step takes all the atoms graphs from each object file and 
combines them into one master object graph.  Unfortunately, it is not as simple
as appending the atom list from each file into one big list.  There are many
cases where atoms need to be coalesced.  That is, two or more atoms need to 
be coalesced into one atom.  This is necessary to support: C language
 "tentative definitions", C++ weak symbols for templates and inlines defined
in headers, and for merging copies of constants like c-strings and floating
point constants.</p>

<p>The linker support coalescing by-name and by-content. By-name is used for
tentative definitions and weak symbols.  By-content is used for constant data
that can be merged. </p>

<p>When one atom has a reference (FixUp) to another atom, there is also a binding
type: by-name, direct, or indirect. A Fixup contains a tagged union that if
the binding type is by-name, the union field is a pointer to a c-string.  If
the binding type is direct, the union is a pointer to an Atom.  If the binding
type is indirect, the union is a index into a table of pointers to Atoms. Below
is a graphical representation of the binding types:</p>
<img src="bindings.png" alt="binding types graphic"/>

<p>Input file Atoms contain only direct and by-name references.  Direct 
references are used for atoms defined in the same object file for which the 
target atom is either unnamed or cannot change.  For instance, calling 
a static function in a translation unit will result in a direct reference 
to the static functions's atom.  Also the FDE (dwarf unwind info) for a function
has a direct reference to its function.  On the other hand references to 
global symbols (e.g. call to printf) use by-name binding in object files.
</p>

<p>The resolving process maintains some global linking "state", including:
a "symbol table" which is a map from c-string to Atom*, an indirect symbol
table which is a growable array of Atom*, and for each kind of coalesable
constants there is a content to Atom* map.  With these data structures,
the linker walks all atoms in all input files. For each
atom, it checks if the atom should be in one symbol table or one of the 
coalescing tables.  If so, it attempts to add the atom.  If there already is
a matching atom in that table, that means the current atom needs to be 
coalesced with the found atom.  
</p>

<p>To support coalescing, all references to coalesable atoms are changed to
indirect binding and an entry is added to the indirect table which points
to the current chosen atom.  When all input atoms have been processed by
the resolver, there should be only direct and indirect bindings left.  If
there are any NULL entries in the indirect table, that means there are  
undefined references.  The linker then looks to the supplied libraries (both
static and dynamic) to resolve those references.  
</p>

<p>Dead code stripping (if requested) is done at the end of resolving.  The
linker does a simple mark-and-sweep. It starts with "root" atoms (like "main"
in a main executable) and follows each references and marks each Atom that
it visits as "live".  When done, all atoms not marked "live" are removed.
</p>

<h4> <a>Passes</a> 
</h4>
<p>The Passes step
is an open ended set of routines that each get a change to modify or enhance
the master graph of atoms. Passes are only run if the master graph of 
atoms is completely resolved (no dangling edges). 
The current set of Passes in the Darwin linker are:</p>
<ul>
  <li>Objective-C optimizations (Apple)</li>
  <li>stub (PLT) generation</li>
  <li>GOT instantiation</li>
  <li>TLV instantiation (Apple)</li>
  <li>order_file optimization</li>
  <li>branch island generation</li>
  <li>branch shim generation</li>
  <li>dtrace probe processing (Apple)</li>
  <li>compact unwind encoding (Apple)</li>
</ul>
<p>Some of these passes are specific to Apple's runtime environments.  But many
of the passes are applicable to any OS (such as generating branch island for 
out of range branch instructions).</p>

<p>The general structure of a pass is to walk the master graph inspecting each
atom and doing something.  For instance, the stub pass, walks the graph looking
for atoms with call sites to proxy atoms (e.g. call to printf).  It then
instantiates a "stub" atom (PLT entry) and a "lazy pointer" atom for each 
proxy atom needed, and these new atoms are added to the master graph.  Next
all the noted call sites to proxy atoms are replaced with calls to the 
corresponding stub atom.</p>  

<h4><a>Generate Output File</a> 
</h4>
<p>Once the passes are done, the output file generator is given a sorted list
of atoms.  Its job is to create the executable content file wrapper and place
the content of the atoms into it. 
</p>


<h2>
  <a name="Future Directions">Future Directions</a>
</h2>

<h4><a>Sections</a> 
</h4>
<p>The current use of sections in mach-o .o files over-constrains the linker.
By default, the linker should preserve the section an atom is in.  But since
all sections must be contiguous in the output, that limits the ability of
the linker to order atoms for locality.  It would be helpful to enrich the
object file with with reason something is in the section it is.  For instance,
is the section found at runtime? Or was the use of a section just a quick
way to group some content together?
</p>
<p>The ELF model for sections is a little better than mach-o because ELF
sections have write and execute bits, whereas mach-o sections must be in some
segment and the segment has the write and execute bits.  
</p>

<h4><a>Mach-o Object File Format</a> 
</h4>
<p>
The messiest part of the linker is the mach-o parser. This is because mach-o
is a traditional section and symbols based file format.  The parser must infer
atom boundaries using two approaches.  The first is that some section types have  
well defined content which the linker can parse into atoms (e.g.  __cstring, 
__eh_frame). The other approach is a naming convention (which the compiler follows)
by which the linker breaks sections into atoms at any non-local (not starting 
with 'L') symbol. The processing the linker has to do parse mach-o .o files is a
significant part of the link time. 
</p>

<p>Given that the assembler writes object files once, whereas the linker reads
them many times (during development), it would make sense to optimize the object
file format to be something the linker can read/parse efficiently.</p>  

<h4><a>New Object File Model</a> 
</h4>
<p>LLVM has a nice model for its IR.  There are three representations:
the binary bit code file, the in-memory object model, and a textual 
representation.  LLVM contains utility possible code for converting between these
representations.  The same model makes sense for atoms too.  There should be
three representations for atoms: binary file, in-memory, and textual. The Darwin 
linker already has an in-memory C++ object model for Atoms.  All we need is a 
textual representation and binary file format.
</p>
<p>Note: in the darwin linker the binary format for input object files is  
independent of the output executable format.  That is, we could have one 
universal object file format which the linker could use as input to produce 
mach-o, ELF, or PE executables.</p>
<p>
The object file binary format should be designed to instantiate into atoms
as fast as possible.  The obvious way to do that is that the 
file format would be an array of atoms.  The linker just mmaps in the file and
looks at the header to see how many atoms there and instantiate that many atoms
with the atom attribute information coming from that array.  The trick is 
designing this in a way that can be extended as the Atom mode evolves and new
attributes are added.
</p>
<p>
In designing a textual format we want something easy for humans to read and
easy for the linker to parse.  Since an atom has lots of attributes most of
which are usually just the default, we should define default values for 
every attribute so that those can be omitted from the text representation.
One possile format is YAML.  Here is the atoms for a simple hello world
program expressed in YAML.
</p>
<pre>
---
target-triple:   x86_64-apple-darwin11
source:

atoms:
    - name:    _main
      scope:   linkage-unit
      type:    code
      alignment: 
          power: 4
      content: [ 55, 48, 89, e5, 48, 8d, 3d, 00, 00, 00, 00, 30, c0, e8, 00, 00,
                 00, 00, 31, c0, 5d, c3 ]
      fixups:
      - offset: 07
        kind:   pcrel32
        target: 2
      - offset: 0E
        kind:   call32
        target: _fprintf

    - type:    c-string
      merge:   by-content
      content: [ 73, 5A, 00 ]

...
</pre>

<p>One big use for the textual format will be writing test cases. The Darwin
linker test suite test cases are written mostly in C/C++ and a few assembly
files.  The use of C means the same test case can be compiled for different
architectures.  But writing test cases in C is problematic because the compiler 
may vary its output over time for its own optimization reasons which my 
inadvertently disable or break the linker feature trying to be tested. By 
writing test cases in the linkers own textual format, we can exactly specify 
every attribute of every atom and thus target specific linker logic.
</p>

<h4><a>Debug Info</a> 
</h4>
<p>Around 2005 when Apple switched from using STABS to using DWARF for debug 
information, we made a design decision to have the linker ignore DWARF in
.o files.  This improves linking performance because the linker is not
copying tons of debug info.  Instead, the linker adds "debug notes" into
output binary that contain the paths of the original .o files. During development
the Darwin debugger will notice the debug notes and the load the dwarf
debug information from the original object files.  For release builds,
a tool named dsymutil is run on the program.  It finds the debug notes and
then the original object files, then reads, merges and optimizes all the dwarf
debug information into one .dSYM file which can be loaded by the debugger
if needed.</p>

<p>The current way DWARF is generated is that all debug information for all
functions in a translation unit are merged and optimized into sections based 
on debug info kind.  For instance the mapping of instructions to source line
numbers for all functions is compressed and put in one section. This does not
play well in an Atom based file format.  One idea is to have the compiler
emit some intermediate representation debug information (one which is 
partitioned per atom) into the Atom based file format.  The linker could 
then have code to convert that intermediate debug into to final dwarf.
This is still an open question.</p>

<h4><a>Extending Atom attributes to ELF and XCOFF</a> 
</h4>
<p>The current set of attributes defined for Atoms in the darwin linker
were chosen to meet the requirements of developing code to run on iOS and 
Mac OS X.  Below is a list of the attributes and their possible values.
It may just require adding more values to support ELF and XCOFF.  Or there
may need to be new attributes added to capture new functionality.
</p>
<ul>
  <li>Name</li>
  <li>Size</li>
  <li>Section (I'd like to get rid of this)</li>
  <li>ContentType (currently some of this comes from section)</li>
  <ul>
	  <li>code</li>
	  <li>stub</li>
	  <li>data</li>
	  <li>zeroFill</li>
	  <li>initializerPointer</li>
	  <li>objc1Class</li>
	  <li>objc2Class</li>
	  <li>objcClassPointer</li>
	  <li>objc2CategoryList</li>
	  <li>non-lazy-pointer</li>
	  <li>lazy-pointer</li>
	  <li>constant</li>
	  <li>literal4</li>
	  <li>literal8</li>
	  <li>literal16</li>
	  <li>cstring</li>
	  <li>cstringPointer</li>
	  <li>utf16string</li>
	  <li>CFString</li>
	  <li>CFI</li>
	  <li>LSDA</li>
	  </ul>
  </li>
  <li>Scope
  <ul>
	  <li>translationUnit  (static functions)</li>
	  <li>linkageUnit      (visibility hidden)</li>
	  <li>global</li>
	  </ul>
  </li>
  <li>DefinitionKind
  <ul>
	  <li>regular</li>
	  <li>tentative         (ANSI C feature)</li>
	  <li>absolute          (assembly code feature)</li>
	  <li>proxy             (stand-in for dynamic library symbol)</li>
  </ul>
  </li>
  <li>Combine
  <ul>
	  <li>never</li>
	  <li>byName          (weak symbols)</li>
	  <li>byContent       (simple constants)</li>
	  <li>byContentAndReferences (complex constants)</li>
  </ul>
  </li>
  <li>SymbolTableStatus
  <ul>
	  <li>In</li>
	  <li>notIn              (anonymous)</li>
	  <li>inAsAbsolute       (assembly code feature)</li>
	  <li>inAndNeverStrip    (tell strip tool to leave)</li>
	  <li>inWithRandomName   (mach-o .o feature)</li>
  </ul>
  <li>Alignment
  <ul>
	  <li>powerOfTwo</li>
	  <li>modulus</li>
  </ul>
  <li>NeverDeadStrip (boolean)</li>
  <li>IsThumb (ARM specific)</li>
</ul>
<p>Where does dllexport fit in here?  Where does visibility protected and 
internal fit?  Protected seems like scope=global plus the rule to not 
indirect references to it.  Internal is like hidden plus enables some
compiler optimizations.  I'm not sure the linker needs to know about internal.
</p>

</body>
</html>

                                                                                             osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/man/                               0040755 0001750 0001750 00000000000 12612724205 022533  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/man/man1/                          0040755 0001750 0001750 00000000000 12612724205 023367  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/man/man1/dyldinfo.1                0100644 0001750 0001750 00000003364 12612724205 025264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd November 10, 2010
.Dt dyldinfo 1
.Os Darwin
.Sh NAME
.Nm dyldinfo
.Nd "Displays information used by dyld in an executable"
.Sh SYNOPSIS
.Nm
.Op Fl arch Ar arch-name 
.Op Fl dylibs
.Op Fl rebase
.Op Fl bind
.Op Fl weak_bind
.Op Fl lazy_bind
.Op Fl export
.Op Fl opcodes
.Op Fl function_starts
.Ar file(s)
.Sh DESCRIPTION
Executables built for Mac OS X 10.6 and later have a new format for the
information in the __LINKEDIT segment.  The dyldinfo tool will display
that information.   
.Pp
The options are as follows:
.Bl -tag -width indent
.It Fl arch Ar arch
Only display the specified architecture.  Other architectures in a universal image are ignored.
.It Fl dylibs
Display the table of dylibs on which this image depends.
.It Fl rebase
Display the table of rebasing information.  Rebasing is what dyld does when an image is 
not loaded at its preferred address.  Typically, this involves updating pointers in the __DATA
segment which point within the image. 
.It Fl bind
Display the table of binding information.  These are the symbolic fix ups that dyld must
do when an image is loaded.
.It Fl weak_bind
Display the table of weak binding information.  Typically, only C++ progams will have any 
weak binding.  These are symbols which dyld must unique accross all images.
.It Fl lazy_bind
Display the table of lazy binding information. These are symbols which dyld delays binding
until they are first used.  Lazy binding is automatically used for all function calls to
functions in some external dylib.
.It Fl export
Display the table symbols which this image exports.
.It Fl opcodes
Display the low level opcodes used to encode all rebase and binding information.
.It Fl function_starts
Decodes the list of function start addresses.
.El
.Sh SEE ALSO
.Xr otool 1
.Xr nm 1
                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/man/man1/ld.1                      0100644 0001750 0001750 00000142241 12612724205 024051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd March 7, 2011
.Dt ld 1
.Os Darwin
.Sh NAME
.Nm ld
.Nd "linker"
.Sh SYNOPSIS
.Nm
files... 
.Op options 
.Op Fl o Ar outputfile 
.Sh DESCRIPTION
The
.Nm ld
command combines several object files and libraries, resolves references, and
produces an ouput file. 
.Nm ld
can produce a final linked image (executable, dylib, or bundle), or with the -r
option, produce another object file.  If the -o option is not used, the output
file produced is named "a.out".
.Ss Universal
The linker accepts universal (multiple-architecture) input files, but
always creates a "thin" (single-architecture), standard Mach-O output file.
The architecture for the output file is specified using the -arch option.  
If this option is not used,
.Nm ld
attempts to determine the output architecture by examining the object
files in command line order.  The first "thin"
architecture determines that of the output file.  If no input
object file is a "thin" file, the native 32-bit architecture for the host is used.
.Pp
Usually, 
.Nm ld
is not used directly.  Instead the 
.Xr gcc(1)
compiler driver invokes
.Nm ld.
The compiler driver can be passed multiple -arch options and it will create a 
universal final linked image by invoking 
.Nm ld
multiple times and then running
.Xr lipo(1)
merge the outputs into a universal file.
.Ss Layout
The object files are loaded in the order in which they are specified on the
command line.  The segments and the sections in those segments will appear in 
the output file in the order they are encountered in the object files being linked. 
All zero fill sections will appear after all non-zero fill sections in their segments.
Sections created from files with the -sectcreate option will be laid out at after 
sections from .o files. The use of the -order_file option will alter the layout 
rules above, and move the symbols specified to start of their section.
.Ss Libraries
A static library (aka static archive) is a collection of .o files with a table of contents
that lists the global symbols in the .o files. 
.Nm ld
will only pull .o files out of a static library if needed to resolve some symbol reference.
Unlike traditional linkers, 
.Nm ld
will continually search a static library while linking. There is no need to specify a static
library multiple times on the command line.  
.Pp
A dynamic library (aka dylib or framework) is a final linked image.  Putting a dynamic
library on the command line causes two things: 1) The generated final linked image 
will have encoded that it depends on that dynamic library. 2) Exported symbols from the
dynamic library are used to resolve references.  
.Pp
Both dynamic and static libraries are searched as they appear on the command line.  
.Ss Search paths
.Nm ld
maintains a list of directories to search for a library or framework to use.  The default
library search path is /usr/lib then /usr/local/lib.  The -L option will add a new library search
path.  The default framework search path is /Library/Frameworks then /System/Library/Frameworks.
(Note: previously, /Network/Library/Frameworks was at the end of the default path.  If you need
that functionality, you need to explicitly add -F/Network/Library/Frameworks). 
The -F option will add a new framework search path.  The -Z option will remove
the standard search paths.  The -syslibroot option will prepend a prefix to all search
paths.
.Ss Two-level namespace
By default all references resolved to a dynamic library record the library to which 
they were resolved. At runtime, dyld uses that information to directly resolve
symbols.  The alternative is to use the -flat_namespace option.  With flat namespace,
the library is not recorded.  At runtime, dyld will search each dynamic library in load
order when resolving symbols. This is slower, but more like how other operating systems 
resolve symbols. 
.Ss Indirect dynamic libraries
If the command line specifies to link against dylib A, and when dylib A was built it linked
against dylib B, then B is considered an indirect dylib.  
When linking for two-level namespace, ld does not look at indirect dylibs, except when 
re-exported by a direct dylibs.  On the other hand when linking for flat namespace, 
ld does load all indirect dylibs and uses them to resolve references.
Even though indirect dylibs are specified via a full path, 
.Nm ld
first uses the specified search paths to locate each indirect dylib.  If one cannot
be found using the search paths, the full path is used.
.Ss Dynamic libraries undefines
When linking for two-level namespace, 
.Nm ld 
does not verify that undefines in dylibs actually
exist.  But when linking for flat namespace, 
.Nm ld
does check that all undefines from all loaded dylibs have a matching definition.  
This is sometimes used to force selected functions to be loaded from a static library.
.Sh OPTIONS
.Ss Options that control the kind of output
.Bl -tag
.It Fl execute
The default.  Produce a mach-o main executable that has file type MH_EXECUTE.
.It Fl dylib
Produce a mach-o shared library that has file type MH_DYLIB.
.It Fl bundle
Produce a mach-o bundle that has file type MH_BUNDLE.
.It Fl r
Merges object files to produce another mach-o object file with file type MH_OBJECT.  
.It Fl dylinker
Produce a mach-o dylinker that has file type MH_DYLINKER.  Only used when building dyld.
.It Fl dynamic
The default.  Implied by -dylib, -bundle, or -execute
.It Fl static
Produces a mach-o file that does not use the dyld.  Only used building the kernel. 
.It Fl preload
Produces a mach-o file in which the mach_header, load commands, and symbol table are
not in any segment.  This output type is used for firmware or embedded development
where the segments are copied out of the mach-o into ROM/Flash.
.It Fl arch Ar arch_name
Specifies which architecture (e.g. ppc, ppc64, i386, x86_64) the output file should be.
.It Fl o Ar path
Specifies the name and location of the output file.  If not specified, `a.out' is used.
.El
.Ss Options that control libraries
.Bl -tag
.It Fl l Ns x
This option tells the linker to search for libx.dylib or libx.a in the library search path.
If string x is of the form y.o, then that file is searched for in the same places, but without
prepending `lib' or appending `.a' or `.dylib' to the filename.
.It Fl weak-l Ns Ar x
This is the same as the -lx but forces the library and all references to it to be marked as weak imports.
That is, the library is allowed to be missing at runtime.
.It Fl weak_library Ar path_to_library
This is the same as listing a file name path to a library on the link line except that it forces the
library and all references to it to be marked as weak imports. 
.It Fl reexport-l Ns Ar x
This is the same as the -lx but specifies that the all symbols in library x should be available to 
clients linking to the library being created.  This was previously done with a separate -sub_library option.
.It Fl reexport_library Ar path_to_library
This is the same as listing a file name path to a library on the link line and it specifies that the 
all symbols in library path should be available to clients linking to the library being created.
This was previously done with a separate -sub_library option.
.It Fl lazy-l Ns Ar x
This is the same as the -lx but it is only for shared libraries and the linker
will construct glue code so that the shared library is not loaded until 
the first function in it is called.
.It Fl lazy_library Ar path_to_library
This is the same as listing a file name path to a shared library on the link line
except that the linker will construct glue code so that the shared library is not 
loaded until the first function in it is called.
.It Fl upward-l Ns Ar x
This is the same as the -lx but specifies that the dylib is an upward dependency. 
.It Fl upward_library Ar path_to_library
This is the same as listing a file name path to a library on the link line but also marks 
the dylib as an upward dependency.
.It Fl L Ns dir
Add 
.Ar dir 
to the list of directories in which to search for libraries. 
Directories specified with -L are searched in the order they appear on the command line
and before the default search path. In Xcode4 and later, there can be a space between
the -L and directory.
.It Fl Z
Do not search the standard directories when searching for libraries and frameworks.
.It Fl syslibroot Ar rootdir
Prepend 
.Ar rootdir 
to all search paths when searching for libraries or frameworks.
.It Fl search_paths_first
This is now the default (in Xcode4 tools).  When processing -lx the linker now searches each directory 
in its library search paths for `libx.dylib' then `libx.a' before the moving on to the next path 
in the library search path.  
.It Fl search_dylibs_first
Changes the searching behavior for libraries.  The default is that when processing -lx the linker
searches each directory in its library search paths for `libx.dylib' then `libx.a'.
This option changes the behavior to first search for a file of the form `libx.dylib' in each directory
in the library search path, then a file of the form `libx.a' is searched for in the library search paths.
This option restores the search behavior of the linker prior to Xcode4.
.It Fl framework Ar name[,suffix]
This option tells the linker to search for `name.framework/name' the framework search path.
If the optional suffix is specified the framework is first searched for the name with the suffix and then without
(e.g. look for `name.framework/name_suffix' first, if not there try `name.framework/name').
.It Fl weak_framework Ar name[,suffix]
This is the same as the -framework name[,suffix] but forces the framework and all 
references to it to be marked as weak imports. 
.It Fl reexport_framework Ar name[,suffix]
This is the same as the -framework name[,suffix] but also specifies that the 
all symbols in that framework should be available to clients linking to the library being created.
This was previously done with a separate -sub_umbrella option.
.It Fl lazy_framework Ar name[,suffix]
This is the same as the -framework name[,suffix] except that the linker will 
construct glue code so that the framework is not 
loaded until the first function in it is called.  You cannot directly access
data or Objective-C classes in a framework linked this way.
.It Fl upward_framework Ar name[,suffix]
This is the same as the -framework name[,suffix] but also specifies that the 
framework is an upward dependency.  
.It Fl F Ns dir
Add 
.Ar dir
to the list of directories in which to search for frameworks. 
Directories specified with -F are searched in the order they appear on the command line
and before the default search path. In Xcode4 and later, there can be a space between
the -F and directory.
.It Fl all_load
Loads all members of static archive libraries.
.It Fl ObjC
Loads all members of static archive libraries that implement an Objective-C class or category.
.It Fl force_load Ar path_to_archive
Loads all members of the specified static archive library.  Note: -all_load forces all members of all
archives to be loaded.  This option allows you to target a specific archive.
.El
.Ss Options that control additional content
.Bl -tag
.It Fl sectcreate Ar segname sectname file
The section 
.Ar sectname 
in the segment 
.Ar segname 
is created from the contents of file 
.Ar file. 
The combination of segname and sectname must be unique  there cannot already be a section (segname,sectname) 
from any other input.
.It Fl filelist Ar file[,dirname]
Specifies that the linker should link the files listed in 
.Ar file . 
This is an alternative to listing the files on the command line. 
The file names are listed one per line separated only by newlines. (Spaces and tabs are assumed to be part of the file name.)
If the optional directory name, 
.Ar dirname 
is specified, it is prepended to each name in the list file.
.It Fl dtrace Ar file
Enables dtrace static probes when producing a final linked image.  The file 
.Ar file
must be a DTrace script which declares the static probes.
.El
.Ss Options that control optimizations 
.Bl -tag
.It Fl dead_strip
Remove functions and data that are unreachable by the entry point or exported symbols.  
.It Fl order_file Ar file
Alters the order in which functions and data are laid out.  For each section in the output file,
any symbol in that section that are specified in the order file 
.Ar file
is moved to the start of its section and laid out in the same order as in the order file 
.Ar file .
Order files are text files with one symbol name per line.  Lines starting with a # are comments.
A symbol name may be optionally preceded with its object file leaf name and a colon (e.g. foo.o:_foo). 
This is useful for static functions/data that occur in multiple files. 
A symbol name may also be optionally preceded with the architecture (e.g. ppc:_foo or ppc:foo.o:_foo).
This enables you to have one order file that works for multiple architectures. 
Literal c-strings may be ordered by by quoting the string (e.g. "Hello, world\\n") in the order file.
.It Fl no_order_inits
When the -order_file option is not used, the linker lays out functions in object file order and
it moves all initializer routines to the start of the __text section and terminator routines
to the end. Use this option to disable the automatic rearrangement of initializers and terminators.
.It Fl no_order_data
By default the linker reorders global data in the __DATA segment so that all global variables that
dyld will need to adjust at launch time will early in the __DATA segment.  This reduces the number
of dirty pages at launch time.  This option disables that optimization.
.It Fl macosx_version_min Ar version
This is set to indicate the oldest Mac OS X version that that the output is to be used on.  Specifying
a later version enables the linker to assumes features of that OS in the output file.  The format of
.Ar version
is a Mac OS X version number such as 10.4 or 10.5
.It Fl ios_version_min Ar version
This is set to indicate the oldest iOS version that that the output is to be used on.  Specifying
a later version enables the linker to assumes features of that OS in the output file.  The format of
.Ar version
is an iOS version number such as 3.1 or 4.0
.It Fl image_base Ar address
Specifies the perferred load address for a dylib or bundle. The argument
.Ar address
is a hexadecimal number with an optional leading 0x.  By choosing non-overlapping address for all
dylibs and bundles that a program loads, launch time can be improved because dyld will not need to
"rebase" the image (that is, adjust pointers within the image to work at the loaded address).
It is often easier to not use this option, but instead use the rebase(1) tool, and give it a list of dylibs.  
It will then choose non-overlapping addresses for the list and rebase them all.
This option is also called -seg1addr for compatibility.
.It Fl no_implicit_dylibs
When creating a two-level namespace final linked image, normally the linker will hoist up public dylibs 
that are implicitly linked to make the two-level namespace
encoding more efficient for dyld.  For example, Cocoa re-exports AppKit and AppKit re-exports Foundation. 
If you link with -framework Cocoa and use a symbol from Foundation, the linker will implicitly add a load
command to load Foundation and encode the symbol as coming from Foundation.  If you use this option, 
the linker will not add a load command for Foundation and encode the symbol as coming from Cocoa.  Then
at runtime dyld will have to search Cocoa and AppKit before finding the symbol in Foundation.
.It Fl exported_symbols_order Ar file
When targeting Mac OS X 10.6 or later, the format of the exported symbol information can be optimized to
make lookups of popular symbols faster.  This option is used to pass a file containing a list of
the symbols most frequently used by clients of the dynamic library being built. Not all exported symbols
need to be listed.  
.It Fl no_zero_fill_sections
By default the linker moves all zero fill sections to the end of the __DATA segment and configures
them to use no space on disk.  This option suppresses that optimization, so zero-filled data occupies
space on disk in a final linked image.
.It Fl merge_zero_fill_sections
Causes all zero-fill sections in the __DATA segment to be merged into one __zerofill section.
.It Fl no_branch_islands
Disables linker creation of branch islands which allows images to be created that are larger than the
maximum branch distance. Useful with -preload when code is in multiple sections but all are within
the branch range.
.El
.Ss Options when creating a dynamic library (dylib) 
.Bl -tag
.It Fl install_name Ar name
Sets an internal "install path" (LC_ID_DYLIB) in a dynamic library. Any clients linked against the library 
will record that path as the way dyld should locate this library.  If this option is not specified, then 
the -o path will be used.  This option is also called -dylib_install_name for compatibility.
.It Fl mark_dead_strippable_dylib
Specifies that the dylib being built can be dead strip by any client.  That is, the dylib has 
no initialization side effects.  So if a client links against the dylib, but never uses
any symbol from it, the linker can optimize away the use of the dylib.
.It Fl compatibility_version Ar number
Specifies the compatibility version number of the library.  When a library is loaded by dyld, the 
compatibility version is checked and if the program's version is greater that the library's version, it is an error.
The format of 
.Ar number 
is X[.Y[.Z]] where X must be a positive non-zero number less than or equal to 65535, 
and .Y and .Z are optional and if present must be non-negative numbers less than or equal to 255. 
If the compatibility version number is not specified, it has a value of 0 and no checking is done when the library is used. 
This option is also called -dylib_compatibility_version for compatibility.
.It Fl current_version Ar number
Specifies the current version number of the library. The current version of the library can be obtained 
programmatically by the user of the library so it can determine exactly which version of the library it is using. 
The format of 
.Ar number 
is X[.Y[.Z]] where X must be a positive non-zero number less than or equal to 65535, 
and .Y and .Z are optional and if present must be non-negative numbers less than or equal to 255. 
If the version number is not specified, it has a value of 0.
This option is also called -dylib_current_version for compatibility.
.El
.Ss Options when creating a main executable
.Bl -tag
.It Fl pie
This makes a special kind of main executable that is position independent (PIE).  On Mac OS X 10.5 and later, the OS
the OS will load a PIE at a random address each time it is executed.  You cannot create a PIE from .o files compiled 
with -mdynamic-no-pic.  That means the codegen is less optimal, but the address randomization adds some 
security. When targeting Mac OS X 10.7 or later PIE is the default for main executables.
.It Fl no_pie
Do not make a position independent executable (PIE).  This is the default, when targeting 10.6 and earlier.
.It Fl pagezero_size Ar size
By default the linker creates an unreadable segment starting at address zero named __PAGEZERO.  Its existence
will cause a bus error if a NULL pointer is dereferenced.  The argument
.Ar size
is a hexadecimal number with an optional leading 0x.  If  
.Ar size
is zero, the linker will not generate a page zero segment.  By default on 32-bit architectures the page zero size 
is 4KB.  On 64-bit architectures, the default size is 4GB.  The ppc64 architecture has some special cases. Since Mac
OS X 10.4 did not support 4GB page zero programs, the default page zero size for ppc64 will be 4KB unless 
-macosx_version_min is 10.5 or later.  Also, the -mdynamic-no-pic codegen model for ppc64 will only work if the
code is placed in the lower 2GB of the address space, so the if the linker detects any such code, the page zero
size is set to 4KB and then a new unreadable trailing segment is created after the code, filling up the lower 4GB.
.It Fl stack_size Ar size
Specifies the maximum stack size for the main thread in a program.  Without this option a program has a 8MB stack.
The argument
.Ar size
is a hexadecimal number with an optional leading 0x. The 
.Ar size
should be an even multiple of 4KB, that is the last three hexadecimal digits should be zero.
.It Fl allow_stack_execute 
Marks executable so that all stacks in the task will be given stack execution privilege. This includes pthread stacks.
.It Fl export_dynamic
Preserves all global symbols in main executables during LTO.  Without this option, Link Time Optimization
is allowed to inline and remove global functions. This option is used when a main executable may load
a plug-in which requires certain symbols from the main executable. 
.El
.Ss Options when creating a bundle
.Bl -tag
.It Fl bundle_loader Ar executable
This specifies the 
.Ar executable 
that will be loading the bundle output file being linked. 
Undefined symbols from the bundle are checked against the specified 
.Ar executable 
like it was one of the 
dynamic libraries the bundle was linked with.
.El
.Ss Options when creating an object file
.Bl -tag
.It Fl keep_private_externs
Don't turn private external (aka visibility=hidden) symbols into static symbols, 
but rather leave them as private external in the resulting object file.
.It Fl d
Force definition of common symbols.  That is, transform tentative definitions into real definitions.
.El
.Ss Options that control symbol resolution
.Bl -tag
.It Fl exported_symbols_list Ar filename
The specified 
.Ar filename 
contains a list of global symbol names that will remain as global symbols in the output file. 
All other global symbols will be treated as if they were marked as __private_extern__ (aka visibility=hidden) 
and will not be global in the output file. The symbol names listed in filename must be one per line.
Leading and trailing white space are not part of the symbol name. 
Lines starting with # are ignored, as are lines with only white space.
Some wildcards (similar to shell file matching) are supported.  The * matches zero or more characters.
The ? matches one character.  [abc] matches one character which must be an 'a', 'b', or 'c'.  [a-z] matches
any single lower case letter from 'a' to 'z'. 
.It Fl exported_symbol Ar symbol
The specified 
.Ar symbol
is added to the list of global symbols names that will remain as global symbols in the output file.  This 
option can be used multiple times.  For short lists, this can be more convenient than creating a file and using 
-exported_symbols_list.
.It Fl unexported_symbols_list Ar file
The specified 
.Ar filename 
contains a list of global symbol names that will not remain as global symbols in the output file. 
The symbols will be treated as if they were marked as __private_extern__ (aka visibility=hidden) and will not be global
in the output file. The symbol names listed in filename must be one per line. 
Leading and trailing white space are not part of the symbol name. 
Lines starting with # are ignored, as are lines with only white space.
Some wildcards (similar to shell file matching) are supported.  The * matches zero or more characters.
The ? matches one character.  [abc] matches one character which must be an 'a', 'b', or 'c'.  [a-z] matches
any single lower case letter from 'a' to 'z'. 
.It Fl unexported_symbol Ar symbol
The specified 
.Ar symbol
is added to the list of global symbols names that will not remain as global symbols in the output file.  This 
option can be used multiple times.  For short lists, this can be more convenient than creating a file and using 
-unexported_symbols_list.
.It Fl reexported_symbols_list Ar file
The specified 
.Ar filename 
contains a list of symbol names that are implemented in a dependent dylib and should be re-exported
through the dylib being created. 
.It Fl alias Ar symbol_name Ar alternate_symbol_name
Create an alias named 
.Ar alternate_symbol_name
for the symbol
.Ar symbol_name .
By default the alias symbol has global visibility.  This option was previous the -idef:indir option.
.It Fl alias_list Ar filename
The specified 
.Ar filename
contains a list of aliases. The symbol name and its alias are on one line, separated by whitespace.
Lines starting with # are ignored.
.It Fl flat_namespace 
Alters how symbols are resolved at build time and runtime.  With -two_levelnamespace (the default), the linker
only searches dylibs on the command line for symbols, and records in which dylib they were found.  With -flat_namespace, 
the linker searches all dylibs on the command line and all dylibs those original dylibs depend on.  The linker
does not record which dylib an external symbol came from, so at runtime dyld again searches all images and uses
the first definition it finds.  In addition, any undefines in loaded flat_namespace dylibs must be resolvable
at build time.  
.It Fl u Ar symbol_name
Specified that symbol 
.Ar symbol_name
must be defined for the link to succeed.  This is useful to force selected functions to be loaded
from a static library.
.It Fl U Ar symbol_name
Specified that it is ok for 
.Ar symbol_name
to have no definition.  With -two_levelnamespace, the resulting symbol will be marked dynamic_lookup which
means dyld will search all loaded images.
.It Fl undefined Ar treatment
Specifies how undefined symbols are to be treated. Options are: error, warning, suppress, or dynamic_lookup.  The
default is error. 
.It Fl rpath Ar path
Add 
.Ar path
to the runpath search path list for image being created.  At runtime, dyld uses the runpath when searching
for dylibs whose load path begins with @rpath/.
.It Fl commons Ar treatment
Specifies how commons (aka tentative definitions) are resolved with respect to dylibs.  Options are: 
ignore_dylibs, use_dylibs, error.  The default is ignore_dylibs which means the linker will turn a tentative
definition in an object file into a real definition and not even check dylibs for conflicts.  The dylibs
option means the linker should check linked dylibs for definitions and use them to replace tentative definitions 
from object files.  The error option means the linker should issue an error whenever a tentative definition in an
object file conflicts with an external symbol in a linked dylib.  See also -warn_commons.
.El
.Ss Options for introspecting the linker
.Bl -tag
.It Fl why_load
Log why each object file in a static library is loaded. That is, what symbol was needed.  Also called -whyload
for compatibility.
.It Fl why_live Ar symbol_name
Logs a chain of references to 
.Ar symbol_name .
Only applicable with -dead_strip .
It can help debug why something that you think should be dead strip removed is not removed.
See -exported_symbols_list for syntax and use of wildcards.
.It Fl print_statistics
Logs information about the amount of memory and time the linker used.
.It Fl t
Logs each file (object, archive, or dylib) the linker loads.  Useful for debugging problems with search paths where the wrong library is loaded.
.It Fl whatsloaded
Logs just object files the linker loads.
.It Fl order_file_statistics
Logs information about the processing of a -order_file.
.It Fl map Ar map_file_path
Writes a map file to the specified path which details all symbols and their addresses in the output image.
.El
.Ss Options for controling symbol table optimizations
.Bl -tag
.It Fl S
Do not put debug information (STABS or DWARF) in the output file.
.It Fl x
Do not put non-global symbols in the output file's symbol table. Non-global symbols are useful when debugging and
getting symbol names in back traces, but are not used at runtime. If -x is used with -r
non-global symbol names are not removed, but instead replaced with a unique, dummy name
that will be automatically removed when linked into a final linked image.  This
allows dead code stripping, which uses symbols to break up code and data, to
work properly and provides the security of having source symbol names removed.
.It Fl non_global_symbols_strip_list Ar filename
The specified 
.Ar filename 
contains a list of non-global symbol names that should be removed from the output file's symbol table.  All other 
non-global symbol names will remain in the output files symbol table. See -exported_symbols_list for syntax and use
of wildcards.
.It Fl non_global_symbols_no_strip_list Ar filename
The specified 
.Ar filename 
contains a list of non-global symbol names that should be remain in the output file's symbol table.  All other 
symbol names will be removed from the output file's symbol table. See -exported_symbols_list for syntax and use
of wildcards.
.El
.Ss Options for Bitcode build flow
.Bl -tag
.It Fl bitcode_bundle
Generates an embedded bitcode bundle in the output binary. The bitcode bundle is embedded in __LLVM, __bundle section.
This option requires all the object files, static libraries and user frameworks/dylibs contain bitcode.
Note: not all the linker options are supported to use together with -bitcode_bundle.
.It Fl bitcode_hide_symbol
Specifies this option together with -bitcode_bundle to hide all non-exported symbols from output bitcode bundle.
The hide symbol process might not be reversible. To obtain a reverse mapping file to recover all the symbols, use
-bitcode_symbol_map option.
.It Fl bitcode_symbol_map Ar path
Specifies the output for bitcode symbol reverse mapping (.bcsymbolmap). If
.Ar path
is an existing directory, UUID.bcsymbolmap will be written to that directory.
Otherwise, the reverse map will be written to a file at
.Ar path .
.El
.Ss Rarely used Options
.Bl -tag
.It Fl v
Prints the version of the linker.
.It Fl dirty_data_list Ar filename
Specifies a file containing the names of data symbols likely to be dirtied.
If the linker is creating a __DATA_DIRTY segment, those symbols will be moved
to that segment.
.It Fl move_to_rw_segment Ar segment_name Ar filename
Moves data symbols to another segment.  The command line option specifies the
target segment name and a path to a file containing a list of symbols to move.
Comments can be added to the symbol file by starting a line with a #.
If there are multiple instances of a symbol name (for instance a "static int foo=5;" in multiple files)
the symbol name in the symbol list file can be prefixed with the object file name 
(e.g. "init.o:_foo") to move a specific instance.
.It Fl move_to_ro_section Ar segment_name Ar section_name Ar filename
Moves code symbols to another segment.  The command line option specifies the
target segment name and a path to a file containing a list of symbols to move.
Comments can be added to the symbol file by starting a line with a #.
If there are multiple instances of a symbol name (for instance a "static int foo() {}" in multiple files)
the symbol name in the symbol list file can be prefixed with the object file name 
(e.g. "init.o:_foo") to move a specific instance.
.It Fl rename_section Ar orgSegment orgSection newSegment newSection
Renames section orgSegment/orgSection to newSegment/newSection.
.It Fl rename_segment Ar orgSegment newSegment 
Renames all sections with orgSegment segment name to have newSegment segment name.
.It Fl trace_symbol_layout
For using in debugging -rename_section, -rename_segment, -move_to_ro_segment, and -move_to_rw_segment.
This option prints out a line show where and why each symbol was moved.
Note: These options do not chain.  For each symbol, the linker first checks
-move_to_ro_segment and -move_to_rw_segment.  If the symbol is not moved,
it checks for an applicable -rename_section.  Only if the symbol still has
not been moved, does the linker look for an applicable -rename_segment option.
.It Fl section_order Ar segname Ar colon_separated_section_list
Only for use with -preload.  Specifies the order that sections with the specified segment should be layout out.
For example: "-section_order __ROM __text:__const:__cstring". 
.It Fl segment_order Ar colon_separated_segment_list
Only for use with -preload.  Specifies the order segments should be layout out.
For example: "-segment_order __ROM:__ROM2:__RAM". 
.It Fl allow_heap_execute
Normally i386 main executables will be marked so that the Mac OS X 10.7 and later kernel 
will only allow pages with the x-bit to execute instructions. This option overrides that
behavior and allows instructions on any page to be executed.
.It Fl application_extension
Specifies that the code is being linked for use in an application extension.  The linker
will then validiate that any dynamic libraries linked against are safe for use in
application extensions.
.It Fl no_application_extension
Specifies that the code is being linked is not safe for use in an application extension. 
For instance, can be used when creating a framework that should not be used in
an application extension.
.It Fl fatal_warnings
Causes the linker to exit with a non-zero value if any warnings were emitted.
.It Fl no_eh_labels
Normally in -r mode, the linker produces .eh labels on all FDEs in the __eh_frame section.
This option suppresses those labels.  Those labels are not needed by the Mac OS X 10.6
linker but are needed by earlier linker tools.
.It Fl warn_compact_unwind
When producing a final linked image, the linker processes the __eh_frame section and
produces an __unwind_info section. Most FDE entries in the __eh_frame can be represented
by a 32-bit value in the __unwind_info section.  The option issues a warning for 
any function whose FDE cannot be expressed in the compact unwind format.
.It Fl warn_weak_exports
Issue a warning if the resulting final linked image contains weak external symbols. Such
symbols require dyld to do extra work at launch time to coalesce those symbols.
.It Fl objc_gc_compaction
Marks the Objective-C image info in the final linked image with the bit that says that the  
code was built to work the compacting garbage collection.
.It Fl objc_gc
Verifies all code was compiled with -fobjc-gc or -fobjc-gc-only.
.It Fl objc_gc_only
Verifies all code was compiled with -fobjc-gc-only.
.It Fl dead_strip_dylibs
Remove dylibs that are unreachable by the entry point or exported symbols. That is,  
suppresses the generation of load command commands for dylibs which supplied no
symbols during the link. This option should not be used when linking against a dylib which 
is required at runtime for some indirect reason such as the dylib has an important initializer.
.It Fl allow_sub_type_mismatches
Normally the linker considers different cpu-subtype for ARM (e.g. armv4t and armv6) to be different
different architectures that cannot be mixed at build time.  This option relaxes that requirement,
allowing you to mix object files compiled for different ARM subtypes.
.It Fl no_uuid
Do not generate an LC_UUID load command in the output file.
.It Fl root_safe
Sets the MH_ROOT_SAFE bit in the mach header of the output file.
.It Fl setuid_safe
Sets the MH_SETUID_SAFE bit in the mach header of the output file.
.It Fl interposable
Indirects access to all to exported symbols when creating a dynamic library.  
.It Fl init Ar symbol_name
The specified symbol_name will be run as the first initializer.   Only used when creating a dynamic library.  
.It Fl sub_library Ar library_name
The specified dylib will be re-exported. For example the library_name for /usr/lib/libobjc_profile.A.dylib would be libobjc. 
Only used when creating a dynamic library.  
.It Fl sub_umbrella Ar framework_name
The specified framework will be re-exported.  Only used when creating a dynamic library. 
.It Fl allowable_client Ar name
Restricts what can link against the dynamic library being created.  By default any code 
can link against any dylib. But if a dylib is supposed to be private to a small
set of clients, you can formalize that by adding a -allowable_client for each client.
If a client is libfoo.1.dylib its -allowable_client name would be "foo".  If a
client is Foo.framework its -allowable_client name would be "Foo".  For the degenerate
case where you want no one to ever link against a dylib, you can set the 
-allowable_client to "!".  
.It Fl client_name Ar name
Enables a bundle to link against a dylib that was built with -allowable_client.  
The name specified must match one of the -allowable_client names specified when the dylib was created.
.It Fl umbrella Ar framework_name
Specifies that the dylib being linked is re-exported through an umbrella framework of the specified name.
.It Fl headerpad Ar size
Specifies the minimum space for future expansion of the load commands.  Only useful if intend to run 
install_name_tool to alter the load commands later. Size is a hexadecimal number.
.It Fl headerpad_max_install_names
Automatically adds space for future expansion of load commands such that all paths could expand to MAXPATHLEN. 
Only useful if intend to run install_name_tool to alter the load commands later.
.It Fl bind_at_load
Sets a bit in the mach header of the resulting binary which tells dyld to bind all symbols when the binary is loaded, rather than lazily.
.It Fl force_flat_namespace
Sets a bit in the mach header of the resulting binary which tells dyld to not only use flat namespace for the binary,
but force flat namespace binding on all dylibs and bundles loaded in the process.  Can only be used when linking main executables.
.It Fl sectalign Ar segname Ar sectname Ar value
The section named sectname in the segment segname will have its alignment set to value, where value is a hexadecimal 
number that must be an integral power of 2. 
.It Fl stack_addr Ar address
Specifies the initial address of the stack pointer value, where value is a hexadecimal number rounded to a page boundary.
.It Fl segprot Ar segname Ar max_prot Ar init_prot
Specifies the maximum and initial virtual memory protection of the named segment, name, to be max and init ,respectively. 
The values for max and init are any combination of the characters `r' (for read), `w' (for write), `x' (for execute) and `-' (no access).
.It Fl seg_addr_table Ar filename
Specifies a file containing base addresses for dynamic libraries.  Each line of the file is a hexadecimal base address 
followed by whitespace then the install name of the corresponding dylib. The # character denotes a comment.
.It Fl segs_read_write_addr Ar address
Allows a dynamic library to be built where the read-only and read-write segments are not contiguous.  The address 
specified is a hexadecimal number that indicates the base address for the read-write segments.
.It Fl segs_read_only_addr Ar address
Allows a dynamic library to be built where the read-only and read-write segments are not contiguous.  The address 
specified is a hexadecimal number that indicates the base address for the read-only segments.
.It Fl segaddr Ar name Ar address
Specifies the starting address of the segment named name to be address. The address must be a hexadecimal number 
that is a multiple of 4K page size.
.It Fl seg_page_size Ar name Ar size
Specifies the page size used by the specified segment.  By default the page size is 4096 for all segments. 
The linker will lay out segments such that size of a segment is always an even multiple of its page size.
.It Fl dylib_file Ar install_name:file_name
Specifies that a dynamic shared library is in a different location than its standard location. Use this option 
when you link with a library that is dependent on a dynamic library, and the dynamic library is in a location other 
than its default location. install_name specifies the path where the library normally resides. file_name specifies 
the path of the library you want to use instead. For example, if you link to a library that depends upon the dynamic 
library libsys and you have libsys installed in a nondefault location, you would use this option: 
-dylib_file /lib/libsys_s.A.dylib:/me/lib/libsys_s.A.dylib.
.It Fl prebind
The created output file will be in the prebound format.  This was used in Mac OS X 10.3 and earlier to improve launch performance.  
.It Fl weak_reference_mismatches Ar treatment
Specifies what to do if a symbol is weak-imported in one object file but not weak-imported in another.  The valid 
treatments are: error, weak, or non-weak.  The default is non-weak.
.It Fl read_only_relocs Ar treatment
Enables the use of relocations which will cause dyld to modify (copy-on-write) read-only pages.  The compiler will 
normally never generate such code.  
.It Fl force_cpusubtype_ALL
The is only applicable with -arch ppc.  It tells the linker to ignore the PowerPC cpu requirements (e.g. G3, G4 or G5) encoded
in the object files and mark the resulting binary as runnable on any PowerPC cpu.
.It Fl dylinker_install_name Ar path
Only used when building dyld.
.It Fl no_arch_warnings
Suppresses warning messages about files that have the wrong architecture for the -arch flag
.It Fl arch_errors_fatal
Turns into errors, warnings about files that have the wrong architecture for the -arch flag. 
.It Fl e Ar symbol_name
Specifies the entry point of a main executable.  By default the entry name is "start" which is found in crt1.o which contains
the glue code need to set up and call main().
.It Fl w
Suppress all warning messages
.It Fl final_output Ar name
Specifies the install name of a dylib if -install_name is not used.  This option is used by gcc driver when it is invoked 
with multiple -arch arguments.  
.It Fl arch_multiple
Specifes that the linker should augment error and warning messages with the architecture name.  This option is used by gcc 
driver when it is invoked with multiple -arch arguments.  
.It Fl twolevel_namespace_hints
Specifies that hints should be added to the resulting binary that can help speed up runtime binding by dyld as long as the 
libraries being linked against have not changed.
.It Fl dot Ar path
Create a file at the specified path containing a graph of symbol dependencies.  The .dot file can be viewed in GraphViz.
.It Fl keep_relocs
Add section based relocation records to a final linked image.  These relocations are ignored at runtime by dyld.
.It Fl warn_stabs
Print a warning when the linker cannot do a BINCL/EINCL optimization because the compiler put a bad stab symbol inside
a BINCL/EINCL range.
.It Fl warn_commons
Print a warning whenever the a tentative definition in an object file is found and a external symbol by the same name
is also found in a linked dylib.  This often means that the extern keyword is missing from a variable declaration
in a header file.
.It Fl read_only_stubs
[i386 only] Makes the __IMPORT segment of a final linked images read-only.  This option makes a program slightly more
secure in that the JMP instructions in the i386 fast stubs cannot be easily overwritten by malicious code.  The downside
is the dyld must use mprotect() to temporarily make the segment writable while it is binding the stubs. 
.It Fl slow_stubs
[i386 only]  Instead of using single JMP instruction stubs, the linker creates code in the __TEXT segment which 
calls through a lazy pointer in the __DATA segment.  
.It Fl interposable_list Ar filename
The specified 
.Ar filename 
contains a list of global symbol names that should always be accessed indirectly.  For instance, if libSystem.dylib
is linked such that _malloc is interposable, then calls to malloc() from within libSystem will go through a dyld
stub and could potentially indirected to an alternate malloc.  If libSystem.dylib were built without making _malloc 
interposable then if _malloc was interposed at runtime, calls to malloc from with libSystem would be missed 
(not interposed) because they would be direct calls.
.It Fl no_function_starts
By default the linker creates a compress table of function start addresses in the LINKEDIT of
final linked image.  This option disables that behavior.
.It Fl no_version_load_command
By default the linker creates a load command in final linked images that contains the -macosx_version_min.
This option disables that behavior.
.It Fl no_objc_category_merging
By default when producing final linked image, the linker will optimize Objective-C classes by merging
any categories on a class into the class.  Both the class and its categories must be defined in the image
being linked for the optimization to occur.  Using this option disables that behavior.
.It Fl object_path_lto Ar filename
When performing Link Time Optimization (LTO) and a temporary mach-o object file is needed, if this
option is used, the temporary file will be stored at the specified path and remain after the link
is complete.  Without the option, the linker picks a path and deletes the object file before the linker 
tool completes, thus tools such as the debugger or dsymutil will not be able to access the DWARF debug
info in the temporary object file.
.It Fl page_align_data_atoms
During development, this option can be used to space out all global variables so each is on a separate page. 
This is useful when analyzing dirty and resident pages.  The information can then be used to create an 
order file  to cluster commonly used/dirty globals onto the same page(s).
.It Fl not_for_dyld_shared_cache
Normally, the linker will add extra info to dylibs with -install_name starting with /usr/lib or
/System/Library/ that allows the dylib to be placed into the dyld shared cache.  Adding this option
tells the linker to not add that extra info.
.El
.Ss Obsolete Options
.Bl -tag
.It Fl segalign Ar value
All segments must be page aligned. 
.It Fl seglinkedit
Object files (MH_OBJECT) with a LINKEDIT segment are no longer supported. This option is obsolete.
.It Fl noseglinkedit
This is the default.  This option is obsolete.
.It Fl fvmlib
Fixed VM shared libraries (MH_FVMLIB) are no longer supported. This option is obsolete.
.It Fl sectobjectsymbols Ar segname Ar sectname
Adding a local label at a section start is no longer supported.  This option is obsolete.
.It Fl nofixprebinding
The MH_NOFIXPREBINDING bit of mach_headers has been ignored since Mac OS X 10.3.9.  This option is obsolete.
.It Fl noprebind_all_twolevel_modules
Multi-modules in dynamic libraries have been ignored at runtime since Mac OS X 10.4.0.  This option is obsolete.
.It Fl prebind_all_twolevel_modules
Multi-modules in dynamic libraries have been ignored at runtime since Mac OS X 10.4.0.  This option is obsolete.
.It Fl prebind_allow_overlap
When using -prebind, the linker allows overlapping by default, so this option is obsolete.
.It Fl noprebind
LD_PREBIND is no longer supported as a way to force on prebinding, so there no longer needs to
be a command line way to override LD_PREBIND.  This option is obsolete.
.It Fl sect_diff_relocs Ar treatment
This option was an attempt to warn about linking .o files compiled without -mdynamic-no-pic into 
a main executable, but the false positive rate generated too much noise to make the option useful.
This option is obsolete.
.It Fl run_init_lazily
This option was removed in Mac OS X 10.2.
.It Fl single_module
This is now the default so does not need to be specified. 
.It Fl multi_module
Multi-modules in dynamic libraries have been ignored at runtime since Mac OS X 10.4.0.  This option is obsolete.
.It Fl no_dead_strip_inits_and_terms
The linker never dead strips initialization and termination routines.  They are considered "roots" of the dead strip graph.
.It Fl A Ar basefile
Obsolete incremental load format.  This option is obsolete.
.It Fl b
Used with -A option to strip base file's symbols.  This option is obsolete.
..It Fl M
Obsolete option to produce a load map.  Use -map option instead. 
.It Fl Sn
Don't strip any symbols.  This is the default.  This option is obsolete.
.It Fl Si
Optimize stabs debug symbols to remove duplicates.  This is the default.  This option is obsolete.
.It Fl Sp
Write minimal stabs which causes the debugger to open and read the original .o file for full stabs.
This style of debugging is obsolete in Mac OS X 10.5.  This option is obsolete.
.It Fl X
Strip local symbols that begin with 'L'.  This is the default.  This option is obsolete.
.It Fl s
Completely strip the output, including removing the symbol table.  This file format variant is no longer supported.  
This option is obsolete.
.It Fl m
Don't treat multiple definitions as an error.  This is no longer supported. This option is obsolete.
.It Fl y Ns symbol
Display each file in which 
.Ar symbol
is used.  This was previously used to debug where an undefined symbol was used, but the linker now
automatically prints out all usages.  The -why_live option can also be used to display what kept 
a symbol from being dead striped.  This option is obsolete.
.It Fl Y Ar number
Used to control how many occurrences of each symbol specified with -y would be shown.  This option is obsolete.
.It Fl nomultidefs
Only used when linking an umbrella framework.  Sets the MH_NOMULTIDEFS bit in the mach_header.  The MH_NOMULTIDEFS
bit has been obsolete since Mac OS X 10.4.  This option is obsolete.
.It Fl multiply_defined_unused Ar treatment
Previously provided a way to warn or error if any of the symbol definitions in the output file matched any
definitions in dynamic library being linked.  This option is obsolete.
.It Fl multiply_defined Ar treatment
Previously provided a way to warn or error if any of the symbols used from a dynamic library were also 
available in another linked dynamic library.  This option is obsolete.
.It Fl private_bundle
Previously prevented errors when -flat_namespace, -bundle, and -bundle_loader were used and the bundle 
contained a definition that conflicted with a symbol in the main executable.  The linker no longer
errors on such conflicts.  This option is obsolete.
.It Fl noall_load
This is the default.  This option is obsolete.
.It Fl seg_addr_table_filename Ar path
Use 
.Ar path
instead of the install name of the library for matching an entry in the seg_addr_table.  This option is obsolete.
.It Fl sectorder Ar segname sectname orderfile
Replaced by more general -order_file option.
.It Fl sectorder_detail
Produced extra logging about which entries from a sectorder entries were used.  Replaced by -order_file_statistics. 
This option is obsolete. 
.El
.Sh SEE ALSO
as(1), ar(1), cc(1), nm(1), otool(1) lipo(1),
arch(3), dyld(3), Mach-O(5), strip(1), rebase(1)
                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/man/man1/ld64.1                    0100644 0001750 0001750 00000000016 12612724205 024214  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man1/ld.1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/man/man1/rebase.1                  0100644 0001750 0001750 00000002620 12612724205 024707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd June 6, 2006
.Dt rebase 1
.Os Darwin
.Sh NAME
.Nm rebase
.Nd "Changes base address of dylibs and bundles"
.Sh SYNOPSIS
.Nm
.Op Fl low_address Ar addr 
.Op Fl high_address Ar addr 
.Op Fl arch Ar arch 
.Op Fl v
.Ar file(s)
.Sh DESCRIPTION
The base address of an image (dylib or bundle) is the preferred address for it to be loaded.  By
default all images are built with a base address of zero.  At runtime, if the
preferred memory range is already occupied, dyld will "slide" the image to a new address range.
There is a small cost to the slide, as dyld must do some fix ups.
The rebase tool takes a list of images and adjust their base address to be non-overlapping. If no
low or high address is specified, the a suitable address range is choosen for the architecture.
.Pp
The options are as follows:
.Bl -tag -width indent
.It Fl low_address Ar addr
Force the base address for the first image to be 
.Ar addr
(specified in hex). Each subsequent file gets the next available base address.
.It Fl high_address Ar addr
Force the base address for the last image to be such that when that image is loaded it occupies 
memory up to
.Ar addr
(specified in hex). Each preceeding file gets the previous available base address.
.It Fl arch Ar arch
Only rebase the specified architecture.  Other architectures in a universal image are left as is.
.It Fl v
Verbose. Print information about rebasing done.
.El
.Sh SEE ALSO
.Xr ld 1
                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/doc/man/man1/unwinddump.1              0100644 0001750 0001750 00000001402 12612724205 025635  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd November 7, 2008
.Dt unwinddump 1
.Os Darwin
.Sh NAME
.Nm unwinddump
.Nd "Displays compact unwind information in an executable"
.Sh SYNOPSIS
.Nm
.Op Fl arch Ar arch-name 
.Ar file(s)
.Sh DESCRIPTION
When a C++ (or x86_64 Objective-C) exception is thrown, the runtime must unwind
the stack looking for some function to catch the exception.  Traditionally, 
the unwind information is stored in the __TEXT/__eh_frame section of each executable
as Dwarf CFI (call frame information).  Beginning in Mac OS X 10.6, the unwind
information is also encoded in the __TEXT/__unwind_info section using a two-level
lookup table of compact unwind encodings.  
.Pp
The unwinddump tool displays the content of the __TEXT/__unwind_info section.
.Sh SEE ALSO
.Xr ld 1
.Xr dwarfdump 1
                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/                                   0040755 0001750 0001750 00000000000 13101126656 022002  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/                               0040755 0001750 0001750 00000000000 13101126761 022467  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/                         0040755 0000000 0000000 00000000000 13101126761 023444  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper.a              0100644 0000000 0000000 00000071262 13101126761 025561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        !<arch>
/               1493478897  0     0     0       338       `
     ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  r  r  r  r  NF  U"  _  _  _OSAtomicAdd32 OSAtomicAdd64 _NSGetExecutablePath __assert_rtn _dyld_find_unwind_sections host_statistics ldVersionString mach_absolute_time mach_host_self mach_timebase_info __heapsort_r fls flsl qsort_r_local strlcat strlcpy md5_append md5_finish md5_init  //                                              140       `
libhelper_la-helper.o/
libhelper_la-qsort_r.o/
libhelper_la-strlcat.o/
libhelper_la-strlcpy.o/
libhelper_la-eprintf.o/
libhelper_la-md5.o/

/0              1493478895  0     0     100644  2776      `
ELF         >                              @     @   PH        AVSPHIHcH=    L    tHA 1H[A^1ffff.     1ffff.     _   f.     SH1H<$1    uHi$@B H\$HH[@ H     H1>f     H>H   253.3
 /proc/self/exe  Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)        zR x            	    A   0       ?    BAA      P                 d                 x                        ,    AD                                                	        .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .rodata .data .rodata.str1.1                                                                                      @                                                           	      `                           [                                                                                                                    S                                                         a      2               #                                         0               2      N                                                                                        /                                                         *                       
                	                 9                      `      p                              K                      P      X                          C                                                                                                      B                                                                                                                                                                                   	                                                	       r            ?       \             	            P              2     p                                              ,            `              I                                                                                     i                       gettimeofday __assert _dyld_find_unwind_sections host_statistics .L.str mach_timebase_info __assert_rtn readlink _NSGetExecutablePath ldVersionString mach_host_self mach_absolute_time helper.c _GLOBAL_OFFSET_TABLE_ OSAtomicAdd64 OSAtomicAdd32                  $             ,                                                4                    T             P       h             `       |             p                                                                                       /23             1493478895  0     0     100644  16536     `
ELF         >                    :          @     @  	 1Ht   fHHu@ 1t    ufD  UAWAVAUATSH   LHIL$   1I(  H  IHI    HHL$hH  H$   H$   LHMLL$pML$     IIHL$xIKHL$XLHHL$P     HD$`L4 M9H\  ff.     ILIHL)LM9sHLL$   LHHL$   AL$   LL$pL	H$   LHHL$   H$   L$   L$   H$   LIIM)O4;LHLML$   ML$   H$     MtALHt$IMK#HT$xHT H9w#JDH9wLH1nf.     LkLH)IMMHT HLd$XHt$Pf     AD$A$U] AT$A$EM H I HuL9H   HHHtHuH`f.     HuH6HuHAU AIM HHHA] AIU HHA] AIU HHHrH@ AU AE AFUAVEAFUAVEAFUAVEIHHuL4?M9HD$`HIH|$h	  IEHD$8IIHL$xJLHL$LHHt$ IHD$0LIHHL$(KLHL$LHHL$XHIHHHL$`HO0H$N|0IC0HD$@ICHD$1fff.     Hl$HL|$PHHHD$0LMHT$(LMMM)K,MMMIH   LIIIH       IHD$XI)L<ILHt$`HtHHA    tCCLOA    HrLH$J1HL$PJ1Ht$XL)    AICKA	CH@H@HuLHt$pH9I   LHMtHuLKf.     HuL(HuLHAII[HAIHHAIHIr1f     AHAOHAOHAOHIHuM   LH   L;D$MH\$XwL9ML       MI)I,2LI3LD$`MtLH    tAAKCCL    IrFHL$@H9HT$Pf     AID:L:A	D::H@H@H9uH'fff.     MMLD  MML1L9   LHMtHuLGfD  HuL(HuLHM HINH] HHH] HHIr.f     U PUPUPUHHHuIL$   ILMA   A   4  @ LMMLL)LI9s8MH$   HLMM$   MMAAM	IHfMHIHL)I;MtGLHt$HIMHt$xHt5 I9w4JLH9w*LI1   ffff.     LH$      LH)HLLD LT$`MtLH    tE MA;AL;    IrHH|50HH\$@Hl$XH) GOCKGCH@H@Hu@ H$   L9L   HHHtHuHGfD  HuH(HuHU HHHQ] HHH] HHHHr.f     M MHMHMHHHHuO4?I9HMMM)O,#I   LMIL$   MMM)K,#H$   Ht$hHM$     MM   LH   ILIL$   JDIMI9L$   w!K3HT$xHLH9L       LH)L,MI,LHT$IHHT$XfD  AFACI H HuHBffff.     LL$   L$   )ff.     L1L$   L$   L9   HHHtHuHSfff.     HuH,HuHM HAM IHHU HAU IHU HAU IHHr- E AE EAEEAEEAEHIHuO,#IH$   MH$   L$   ff.     IMt8LHtOL;l$H|$hwbHD$xID H9wSLM7fff.     LH|$hHHt$ L|$PHl$H   LMH|$hH1Ht$ L|$P   LH)MD HHt$`HtHHHA    tOAE AMA    HH\$XL|$PrLKt50H,$Jl5 L)fffff.     EMFNEM FH@H@HuHt$ Hl$HL9M   HHHtHuHK    HuH*HuHHAU IHQHA] IHHA] IHHr/fD  AM HAMHAMHAMHIHuHIH;l$8M    1        H   [A\A]A^A_]     AHt&E1HtA   H HAHuGL	ffff.     UAWAVAUATSH  EL$   H$   IL$   IHE$  LHH$   HID$$IcH$   HHH$   K4 Ht$(HHHIHHHNH\H\$xHH$   HHHL$XL)HL$HHHHNHTH$   HH$   I@HD$   L)HL$8HHT$hHH\$PL)HD$@D	HH$      DD$$$   I#  LHIHH,I   Ml$MJ.H$   I)   Lt$`LL$   HIH$   L<L$   H H$   HFHD$pL$   LH$   LL$   AD$LLLL|$pLA|$L xi   H$   L$   LLAMHc H$   H$   K  ff.     Lt$`HH$   L$   a  x'H$   L$   LLAMIL$   IH$   I)L$   MHLL$   LLHAD$pLHHA|$p x :H$   LHAIHHxH$   LHALHLML+$   H$   IL+$   IH$   HLLAAHLH$   AEx)LH$   LL$   L$   MH'x#H$   LL$   L$   MIL$   H$   H$   L$   LHHH$   ALHLExGL$   Lt$`H$   sH$   H$   HLM$   MLHLEL$   Lt$`H$   x,H$   H$   HLM$   MIH AFD$L$    tnH$       H   H$   H   HD H$   H9	  HH9   Lt$`H$   H   ff.     Lt$`H$   HHM H
HE p  H$      Ht$xH  HL$XHD H$   H9  HH9  H$   Lt$`HH  Lt$`H$   H$      Lt$`H$   H$   H1   H$   Lt$`HH$   H$     MILt$`H$   H)HHt HHH\$h     GU] WEM H H HuLMH{H9H>  HHHHHNHTHHHtHtKHt0Ht@1] H@u HH@1] H@u HH@1] H@u HHH  fffff.     ] U Q]YUQ]YUQ]YUHHHHl  H$   Lt$`HH$   H$   1TLt$`HD HH$   H)HHH\$PfGU] WEM H H HuH$   HH9   HHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHr]ffff.     H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H H$   J HL$0L$   IT$IHHT$p$       IIHH$   H$   KLI$      LML$   H9IA    .  ff.     LIH$   LL$     I  $      MLIJ4H$   H$      H$   H$   L$   LL   ML$   IH$   LL       H$   LH$   I9w$H$   IH9H$   LL    v^H$   L)KK1HD$hfff.     A3AL3A6A\6A3A\3A6AL6H H9uLH$   HpH9M  HHHHHNHt5HHHtHtEHt,Ht@9H@:HH@9H@:HH@9H@:HHH  fD  AZYBAZYBAZYBHHHH  ML$   IIII  H$   Hl$PL$   tBLLD$xIt!HD$XHHH$   I9w,IH9w#LLH$   E1]LLH$   eKKH$   L)1 AALAA\AA\AALHH9uH$   HvL9I   HHHHHNHt2HHHtHtQHt4HtH9HHHH8HHH9HHHH8HHH9HHHH8HHHrQH1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H ML$   $      MH$   MILI9ff.     LH$   I9A    ILLd$p  ff.     H$   LH$       $      LHIH$   H:H$      IH$   H$   LL   L$   IH$   LL       H$   IH9w(H$   H$   I9H$   LL    vdH$   L)KL K1HD$hffffff.     AD= AL=A<A\<AT= A\=A<AL<H H9uLH$   HxH9  HHHHHNHt5HHHtHtEHt,Ht@9H@:HH@9H@:HH@9H@:HHH      AZYBAZYBAZYBHHHH  IIIE I$IM I$  H$   t9Ht$xHtHL$XIH9w3HHI9w(ILLH$   1vILLH$   xIIIL H$   H)1Hl$Pfffff.     AD ALAA\AT A\AALHH9uH$   HH9   HHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHrRfH1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H LI$      LIIM9       I$      H$    L$     Ld$pIH$   H$   LL   ML$   IH$   LL    H$      ID= I9wI>I9H$   LL    v]HH$   L)KKT I}I^Ht$hf     CWSGH H HuLHHH9M`HHHHHNHt5HHHtHtEHt,Ht@9H@:HH@9H@:HH@9H@:HHHfD  AZYBAZYBAZYBHHHHLd$pIIIM IIE L$   {H$   tAMLD$xItHL$XID I9w<II9w3Ld$pILLH$   E1yLd$pILLH$   yLd$pIKD KH$   L)I}I^Ht$Pfffff.     CWSGH H HuH$   HvL9MHHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHH     H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H HL$   fD  H$   HH)LH)HD$pH9HOHL$   LL$@  LH)H$    Lcb  LUI)HL)I9HIMH H    H1H IIIIHIOHH,2H  H$   HD2H$   M9ML$   MMLH H1H HHHHHNII  I,HIl.H$   H9HwHKl1HHH9Hs  M)JT= LH)LH}H$   I9IMI\IHLNJtHffffff.     GSWCH H Hu   MILUI)HL)I9HIMH H    H1H HHIIIHIOH4:H  LL:I9HH$   IMHH H1H HHHHHHLIt*HHH2I\H91  JT2HH9   HE1M  HHL$   ,H$   HE1L$   H$   L9LL$@I  LHHHHNIt0HHHtHtEHt,Ht@:H@9HI@:H@9HI@:H@9HIH  ffffff.     BYZABYZABYZAIHHM~  HM   H$   JJT M)H$   I9IMI\HuIHLNI|;Hffffff.     FSVCH H HuMH$   L9LL$@   LHHHHNIt0HHHtHtWHHt4HtH:H)H*HH9HIH:H)H*HH9HIH:H)H*HH9HIHHrUD  H2H9H:H1HrHyHzHqHrHyHzHqHrHyHzHqIH H M L$   MJD= H$   LL)H$   L)L)H9HBH  LH)HL= H$    H   HT$N"L+$   IM)M9LIGH I    L1H IIIHIOH4H"  MH$   LLLL$M9MMGLH L1H HHHHHNMI,  J,>MLHL$   Il,I9$  MKl<HLH9  E1LMx      HHT$N"L+$   IM)M9LIGH H    H1H HIIIHIOH4H   MLDM9MMGLH H1H HHHHHHMIt-HHMI?HTI9  IT/LH9  LE1M  E1H$   M   L  L)LHLK<IM9MGMKT,IHLNJtHLM    AFARAVAB
I H HuIHT$L9LL$@<  HHHHHNHTHHHtHtHHt.HtA6AI@1HHA6AI@1HHA6AI@1HHH  ffffff.     AAAVYA^QAVYA^QAVYA^QHIHHf  JKL)M9MGMMJt-IIHLNI|Hffff.     AFAVAVAFH I HuM9LL$@   HHHHHNHt0HHHtHtWHHt4HtH:H)H*HH9HHH:H)H*HH9HHH:H)H*HH9HHHHr\fff.     H2H9H:H1HrHyHzHqHrHyHzHqHrHyHzHqHH H H L$   $      H$   H;$   HL$0  H$   HHH$   E1H$   H$   HD$0H$   McE1Iffffff.     MLH91  H$   L$H$   LH$     $       LH$   H$   L1HH+$   HH$       IH$      H$   H   HD$8H0HH$   H)LIHH+$   HI9>  H$   LH9    HD$hM+  H$   IL1G  fD  IHI$HI$M      H$   txLD$xItHD$H0HI9wrHt$XHH9weILHH$   E1M   H$   LM  H$   IL1H$   M  ILHH$   MiIKJH$   L)MJ41Hl$P LT\DHH9uH$   HvL9  HHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHh       H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H  1HD$hM@ 3L3I<1T;;3\3D;;H H9uH$   HpH9L   HHHHHNH|HHHtHtEHt,Ht@3H@1HH@3H@1HH@3H@1HHHrACQSACQSACQSAHHHH IIL;$   L7    HD$0HD$(H;$   HMu  ffff.     H$   HD$pH9v(1HHHHH$   L$   DL$LvH9$     H$   H$   H)H1IIIHD$`D$LARHLLH$   L$   H  [A\A]A^A_]SML$   M9M	  H$   LH$   H| HcHHHHHHIHIINLLLL$pHH$   HHHt$`H)Ht$hHHHINHH$   HLH$   H)H$      H)H$   HHL$xILL$XHfD  H$   H$   H$   H9  $    H$   I  H$    A    H$   IA    I  LH$   L$H$   LH$     H$      L$   ItxLH$   H$   L8H$   H49HH$   L)NLL$   L)HI9wXH$   H4>HL)HH9    H$   HT$xw?H$   ILE1]fff.     H$   L\1H$   HT$x@ ;L;H48T33;\;D33H H9uH$   HpL9L   HHHHHNH|HHHtHtEHt,Ht@3H@1HH@3H@1HH@3H@1HHHr>CQSACQSACQSAHHHHIL;$     ffff.     H$   H,H$   HH$   g  HH$   HHHHH;$   Hw<  fff.     LH$   Ll H$   LH$     H$   thLD$pItELH$   H$   HHT$hHHH9wOHL$`HHH+$   HH9w3LHH$   E1   fLHH$   H$      KD JL H$   L)H$   H|= 1Ht$Xfff.     D LTT \DHH9uH$   H$   HL9   HHHHHNHt2HHHtHtWHHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHHrYfff.     H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H HII9    H$   HD$(H;$   H$   HH$   H  [A\A]A^A_] Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)          zR x                      0              0   D       h   ABB B(B0A8G    x       3       4          0+   ABB B(B0A8G      .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                             @        9                                                   ?      H       
                    S                     `9                                                          `9                                           0               `9      N                                                   9                                     /                     9                                    *                       @      x       
                    9                      p:      Y                              K                      =               	                 C                      h?      i                                                      I                               0+                                                                                                                                              @       h                          *                    /           3       S                                            =                      B                       _qsort fls __heapsort_r __errno_location flsl qsort_r_local free malloc qsort_r.c _GLOBAL_OFFSET_TABLE_                     ~                                              4                     H             @       |                                      /47             1493478896  0     0     100644  1696      `
ELF         >                              @     @  	 AWAVAUATSIIIL    ILL    HL9uL/LH)I| I9sIVL    HL    CD/ LH[A\A]A^A_ Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)              zR x  ,          t    BBB B(A0       .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                             @       t                                                    (      `       
                    S                                                                                                                            0                      N                                                                                        /                           H                              *                                   
                    9                      P      Y                              K                            8                          C                            ?                                                                                                                                                                                                                           t       )                                                                                         memcpy strlcat strlen strnlen strlcat.c _GLOBAL_OFFSET_TABLE_               $             M          
   Z          
                         /71             1493478896  0     0     100644  1608      `
ELF         >                              @     @  	 AWAVATSPIIIL    HL9sHSLL    MtIWLL    CD> HH[A\A^A_  Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)              zR x  $          [    BBB A(A0 .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                             @       [                                                          H       
                    S                                                                                                                            0                      N                                                                                         /                            @                              *                      0             
                    9                      0      Y                              K                                                       C                            7                                                                                                                                                                                                                           [       !                                                                   memcpy strlcpy strlen strlcpy.c _GLOBAL_OFFSET_TABLE_               ,          
   B          
                         /95             1493478896  0     0     100644  971       `
ELF         >                               @     @ 	   Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)  .text .comment .bss .note.GNU-stack .shstrtab .strtab .symtab .data                                                                                           @                                      ?                     @                                                           @                                            0               @       N                                                                                         %                             E                              7                                                       /                                                                                                                                                                                                                     eprintf.c 
/119            1493478897  0     0     100644  4808      `
ELF         >                              @     @  
 G        G#EgHHGGvT2fD  UAWAVAUATSPAIIE   A?B    DAGAGAsAGt?B+@   )@ANI|LcLL    D@|nIwME)Lr   A@|?EeDHE@H$L@ LHE   H@AA?A)L4$EEtIIcLL    H[A\A]A^A_]    UAWAVAUATSHXH|$DGGDO1ffff.     T	\	T	THHuD!!	HT$HT$H\$H\$ABxjH!D!	H H$:V!!	ABp $!!	H H\$!!	HT$ HT$H/|!!	H H\$D2*GAAD!D!	HT$(HT$HF0DD!!	H H\$F!D!	HL$0HL$H:i!!	HH HL$ABD!!	Ht$8Ht$H/[!!	HIH Ht$HD\AADD!!	HD$@HD$HD"kAEDDD!!	HH HD$DqAEDEDD!AD!	HD$HHD$H.CyDAED!AE!A	HHH HD$AHC7!IAE!A!E	H$AGb%AAEA!A!E	HL$AG@@A	EEAA!AE!E	E3QZ^&AEEDE!D!D	HL$DAEDDD!D!	LD$EF6]/AEDDD!D!	EF>SDA	EEDE!D!D	AF&AEEDE!D!D	Hl$AFAEEDE!D!D	H\$AF0!AEDDD!D!	AIF>7A	EDDD!D!	HD$AF&AEEDE!D!D	HL$AFZEAEEDE!D!D	H|$AB0DADE!D!D	Ll$EF>A	AEDE!!D	HT$AF&ogAEDE !D!	LD$EFL*DAED1D1FB9DAED1D1AB6qDDD11HL$AF8"amAAD1D1EF 8DAE1D1H$AFDDAED1D10KDDD11AIF`KAAD1D1Ld$EF0pDAE1D1AF~(DAED1D1HL$0'DDD11HT$AF0AAD1D1H|$AF0DAE1D1AF9DAED1D1L0DDD11Hl$AF|AAD1D1EF0eVAAED	D1FD")DDAED	D1D0*CHD$ADA
ED	D1B8#HL$ADD	D1B9AD	1B6Y[eA	1FA
ADD	1}DH$	D1]HL$D	17O~oA	1B,
HL$	1CHL$	1NHT$	12~SHt$	1>5:
D	1*H|$	1H|$WWWGwHX[A\A]A^A_]f     AVSPIH$d$L$L$KL$l$T$L$7   )?H5        H4$   H    11HctA4JHctHAtHHuH[A^                                                                          Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)          zR x            *       0   0           ABB B(B0A8A@  0   d          ABB B(B0A8D                BAA        .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .rodata .data                                                                                             @       
                                                         x                           [                                                                                                                    S                            @                                    0               `      N                                                                                        /                                                         *                      h      `                           9                      h      a                              K                                                      C                            ^                                                      B                    3             @            0                                                                                                                                                                      (     0                    
                          *       H                                             memcpy md5_init md5_process md5_finish md5_append md5_finish.pad md5.c _GLOBAL_OFFSET_TABLE_                            r
            w
            
                                  4             0       h             0                    
                                                                                                                                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper.la             0120777 0000000 0000000 00000000000 13101126761 030423  2../libhelper.la                                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper_la-eprintf.o   0100644 0000000 0000000 00000001713 13101126760 027711  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                               @     @ 	   Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)  .text .comment .bss .note.GNU-stack .shstrtab .strtab .symtab .data                                                                                           @                                      ?                     @                                                           @                                            0               @       N                                                                                         %                             E                              7                                                       /                                                                                                                                                                                                                     eprintf.c                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper_la-helper.o    0100644 0000000 0000000 00000005330 13101126757 027526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                              @     @   PH        AVSPHIHcH=    L    tHA 1H[A^1ffff.     1ffff.     _   f.     SH1H<$1    uHi$@B H\$HH[@ H     H1>f     H>H   253.3
 /proc/self/exe  Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)        zR x            	    A   0       ?    BAA      P                 d                 x                        ,    AD                                                	        .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .rodata .data .rodata.str1.1                                                                                      @                                                           	      `                           [                                                                                                                    S                                                         a      2               #                                         0               2      N                                                                                        /                                                         *                       
                	                 9                      `      p                              K                      P      X                          C                                                                                                      B                                                                                                                                                                                   	                                                	       r            ?       \             	            P              2     p                                              ,            `              I                                                                                     i                       gettimeofday __assert _dyld_find_unwind_sections host_statistics .L.str mach_timebase_info __assert_rtn readlink _NSGetExecutablePath ldVersionString mach_host_self mach_absolute_time helper.c _GLOBAL_OFFSET_TABLE_ OSAtomicAdd64 OSAtomicAdd32                  $             ,                                                4                    T             P       h             `       |             p                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper_la-md5.o       0100644 0000000 0000000 00000011310 13101126761 026722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                              @     @  
 G        G#EgHHGGvT2fD  UAWAVAUATSPAIIE   A?B    DAGAGAsAGt?B+@   )@ANI|LcLL    D@|nIwME)Lr   A@|?EeDHE@H$L@ LHE   H@AA?A)L4$EEtIIcLL    H[A\A]A^A_]    UAWAVAUATSHXH|$DGGDO1ffff.     T	\	T	THHuD!!	HT$HT$H\$H\$ABxjH!D!	H H$:V!!	ABp $!!	H H\$!!	HT$ HT$H/|!!	H H\$D2*GAAD!D!	HT$(HT$HF0DD!!	H H\$F!D!	HL$0HL$H:i!!	HH HL$ABD!!	Ht$8Ht$H/[!!	HIH Ht$HD\AADD!!	HD$@HD$HD"kAEDDD!!	HH HD$DqAEDEDD!AD!	HD$HHD$H.CyDAED!AE!A	HHH HD$AHC7!IAE!A!E	H$AGb%AAEA!A!E	HL$AG@@A	EEAA!AE!E	E3QZ^&AEEDE!D!D	HL$DAEDDD!D!	LD$EF6]/AEDDD!D!	EF>SDA	EEDE!D!D	AF&AEEDE!D!D	Hl$AFAEEDE!D!D	H\$AF0!AEDDD!D!	AIF>7A	EDDD!D!	HD$AF&AEEDE!D!D	HL$AFZEAEEDE!D!D	H|$AB0DADE!D!D	Ll$EF>A	AEDE!!D	HT$AF&ogAEDE !D!	LD$EFL*DAED1D1FB9DAED1D1AB6qDDD11HL$AF8"amAAD1D1EF 8DAE1D1H$AFDDAED1D10KDDD11AIF`KAAD1D1Ld$EF0pDAE1D1AF~(DAED1D1HL$0'DDD11HT$AF0AAD1D1H|$AF0DAE1D1AF9DAED1D1L0DDD11Hl$AF|AAD1D1EF0eVAAED	D1FD")DDAED	D1D0*CHD$ADA
ED	D1B8#HL$ADD	D1B9AD	1B6Y[eA	1FA
ADD	1}DH$	D1]HL$D	17O~oA	1B,
HL$	1CHL$	1NHT$	12~SHt$	1>5:
D	1*H|$	1H|$WWWGwHX[A\A]A^A_]f     AVSPIH$d$L$L$KL$l$T$L$7   )?H5        H4$   H    11HctA4JHctHAtHHuH[A^                                                                          Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)          zR x            *       0   0           ABB B(B0A8A@  0   d          ABB B(B0A8D                BAA        .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .rodata .data                                                                                             @       
                                                         x                           [                                                                                                                    S                            @                                    0               `      N                                                                                        /                                                         *                      h      `                           9                      h      a                              K                                                      C                            ^                                                      B                    3             @            0                                                                                                                                                                      (     0                    
                          *       H                                             memcpy md5_init md5_process md5_finish md5_append md5_finish.pad md5.c _GLOBAL_OFFSET_TABLE_                            r
            w
            
                                  4             0       h             0                    
                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper_la-qsort_r.o   0100644 0000000 0000000 00000040230 13101126757 027736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                    :          @     @  	 1Ht   fHHu@ 1t    ufD  UAWAVAUATSH   LHIL$   1I(  H  IHI    HHL$hH  H$   H$   LHMLL$pML$     IIHL$xIKHL$XLHHL$P     HD$`L4 M9H\  ff.     ILIHL)LM9sHLL$   LHHL$   AL$   LL$pL	H$   LHHL$   H$   L$   L$   H$   LIIM)O4;LHLML$   ML$   H$     MtALHt$IMK#HT$xHT H9w#JDH9wLH1nf.     LkLH)IMMHT HLd$XHt$Pf     AD$A$U] AT$A$EM H I HuL9H   HHHtHuH`f.     HuH6HuHAU AIM HHHA] AIU HHA] AIU HHHrH@ AU AE AFUAVEAFUAVEAFUAVEIHHuL4?M9HD$`HIH|$h	  IEHD$8IIHL$xJLHL$LHHt$ IHD$0LIHHL$(KLHL$LHHL$XHIHHHL$`HO0H$N|0IC0HD$@ICHD$1fff.     Hl$HL|$PHHHD$0LMHT$(LMMM)K,MMMIH   LIIIH       IHD$XI)L<ILHt$`HtHHA    tCCLOA    HrLH$J1HL$PJ1Ht$XL)    AICKA	CH@H@HuLHt$pH9I   LHMtHuLKf.     HuL(HuLHAII[HAIHHAIHIr1f     AHAOHAOHAOHIHuM   LH   L;D$MH\$XwL9ML       MI)I,2LI3LD$`MtLH    tAAKCCL    IrFHL$@H9HT$Pf     AID:L:A	D::H@H@H9uH'fff.     MMLD  MML1L9   LHMtHuLGfD  HuL(HuLHM HINH] HHH] HHIr.f     U PUPUPUHHHuIL$   ILMA   A   4  @ LMMLL)LI9s8MH$   HLMM$   MMAAM	IHfMHIHL)I;MtGLHt$HIMHt$xHt5 I9w4JLH9w*LI1   ffff.     LH$      LH)HLLD LT$`MtLH    tE MA;AL;    IrHH|50HH\$@Hl$XH) GOCKGCH@H@Hu@ H$   L9L   HHHtHuHGfD  HuH(HuHU HHHQ] HHH] HHHHr.f     M MHMHMHHHHuO4?I9HMMM)O,#I   LMIL$   MMM)K,#H$   Ht$hHM$     MM   LH   ILIL$   JDIMI9L$   w!K3HT$xHLH9L       LH)L,MI,LHT$IHHT$XfD  AFACI H HuHBffff.     LL$   L$   )ff.     L1L$   L$   L9   HHHtHuHSfff.     HuH,HuHM HAM IHHU HAU IHU HAU IHHr- E AE EAEEAEEAEHIHuO,#IH$   MH$   L$   ff.     IMt8LHtOL;l$H|$hwbHD$xID H9wSLM7fff.     LH|$hHHt$ L|$PHl$H   LMH|$hH1Ht$ L|$P   LH)MD HHt$`HtHHHA    tOAE AMA    HH\$XL|$PrLKt50H,$Jl5 L)fffff.     EMFNEM FH@H@HuHt$ Hl$HL9M   HHHtHuHK    HuH*HuHHAU IHQHA] IHHA] IHHr/fD  AM HAMHAMHAMHIHuHIH;l$8M    1        H   [A\A]A^A_]     AHt&E1HtA   H HAHuGL	ffff.     UAWAVAUATSH  EL$   H$   IL$   IHE$  LHH$   HID$$IcH$   HHH$   K4 Ht$(HHHIHHHNH\H\$xHH$   HHHL$XL)HL$HHHHNHTH$   HH$   I@HD$   L)HL$8HHT$hHH\$PL)HD$@D	HH$      DD$$$   I#  LHIHH,I   Ml$MJ.H$   I)   Lt$`LL$   HIH$   L<L$   H H$   HFHD$pL$   LH$   LL$   AD$LLLL|$pLA|$L xi   H$   L$   LLAMHc H$   H$   K  ff.     Lt$`HH$   L$   a  x'H$   L$   LLAMIL$   IH$   I)L$   MHLL$   LLHAD$pLHHA|$p x :H$   LHAIHHxH$   LHALHLML+$   H$   IL+$   IH$   HLLAAHLH$   AEx)LH$   LL$   L$   MH'x#H$   LL$   L$   MIL$   H$   H$   L$   LHHH$   ALHLExGL$   Lt$`H$   sH$   H$   HLM$   MLHLEL$   Lt$`H$   x,H$   H$   HLM$   MIH AFD$L$    tnH$       H   H$   H   HD H$   H9	  HH9   Lt$`H$   H   ff.     Lt$`H$   HHM H
HE p  H$      Ht$xH  HL$XHD H$   H9  HH9  H$   Lt$`HH  Lt$`H$   H$      Lt$`H$   H$   H1   H$   Lt$`HH$   H$     MILt$`H$   H)HHt HHH\$h     GU] WEM H H HuLMH{H9H>  HHHHHNHTHHHtHtKHt0Ht@1] H@u HH@1] H@u HH@1] H@u HHH  fffff.     ] U Q]YUQ]YUQ]YUHHHHl  H$   Lt$`HH$   H$   1TLt$`HD HH$   H)HHH\$PfGU] WEM H H HuH$   HH9   HHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHr]ffff.     H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H H$   J HL$0L$   IT$IHHT$p$       IIHH$   H$   KLI$      LML$   H9IA    .  ff.     LIH$   LL$     I  $      MLIJ4H$   H$      H$   H$   L$   LL   ML$   IH$   LL       H$   LH$   I9w$H$   IH9H$   LL    v^H$   L)KK1HD$hfff.     A3AL3A6A\6A3A\3A6AL6H H9uLH$   HpH9M  HHHHHNHt5HHHtHtEHt,Ht@9H@:HH@9H@:HH@9H@:HHH  fD  AZYBAZYBAZYBHHHH  ML$   IIII  H$   Hl$PL$   tBLLD$xIt!HD$XHHH$   I9w,IH9w#LLH$   E1]LLH$   eKKH$   L)1 AALAA\AA\AALHH9uH$   HvL9I   HHHHHNHt2HHHtHtQHt4HtH9HHHH8HHH9HHHH8HHH9HHHH8HHHrQH1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H ML$   $      MH$   MILI9ff.     LH$   I9A    ILLd$p  ff.     H$   LH$       $      LHIH$   H:H$      IH$   H$   LL   L$   IH$   LL       H$   IH9w(H$   H$   I9H$   LL    vdH$   L)KL K1HD$hffffff.     AD= AL=A<A\<AT= A\=A<AL<H H9uLH$   HxH9  HHHHHNHt5HHHtHtEHt,Ht@9H@:HH@9H@:HH@9H@:HHH      AZYBAZYBAZYBHHHH  IIIE I$IM I$  H$   t9Ht$xHtHL$XIH9w3HHI9w(ILLH$   1vILLH$   xIIIL H$   H)1Hl$Pfffff.     AD ALAA\AT A\AALHH9uH$   HH9   HHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHrRfH1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H LI$      LIIM9       I$      H$    L$     Ld$pIH$   H$   LL   ML$   IH$   LL    H$      ID= I9wI>I9H$   LL    v]HH$   L)KKT I}I^Ht$hf     CWSGH H HuLHHH9M`HHHHHNHt5HHHtHtEHt,Ht@9H@:HH@9H@:HH@9H@:HHHfD  AZYBAZYBAZYBHHHHLd$pIIIM IIE L$   {H$   tAMLD$xItHL$XID I9w<II9w3Ld$pILLH$   E1yLd$pILLH$   yLd$pIKD KH$   L)I}I^Ht$Pfffff.     CWSGH H HuH$   HvL9MHHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHH     H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H HL$   fD  H$   HH)LH)HD$pH9HOHL$   LL$@  LH)H$    Lcb  LUI)HL)I9HIMH H    H1H IIIIHIOHH,2H  H$   HD2H$   M9ML$   MMLH H1H HHHHHNII  I,HIl.H$   H9HwHKl1HHH9Hs  M)JT= LH)LH}H$   I9IMI\IHLNJtHffffff.     GSWCH H Hu   MILUI)HL)I9HIMH H    H1H HHIIIHIOH4:H  LL:I9HH$   IMHH H1H HHHHHHLIt*HHH2I\H91  JT2HH9   HE1M  HHL$   ,H$   HE1L$   H$   L9LL$@I  LHHHHNIt0HHHtHtEHt,Ht@:H@9HI@:H@9HI@:H@9HIH  ffffff.     BYZABYZABYZAIHHM~  HM   H$   JJT M)H$   I9IMI\HuIHLNI|;Hffffff.     FSVCH H HuMH$   L9LL$@   LHHHHNIt0HHHtHtWHHt4HtH:H)H*HH9HIH:H)H*HH9HIH:H)H*HH9HIHHrUD  H2H9H:H1HrHyHzHqHrHyHzHqHrHyHzHqIH H M L$   MJD= H$   LL)H$   L)L)H9HBH  LH)HL= H$    H   HT$N"L+$   IM)M9LIGH I    L1H IIIHIOH4H"  MH$   LLLL$M9MMGLH L1H HHHHHNMI,  J,>MLHL$   Il,I9$  MKl<HLH9  E1LMx      HHT$N"L+$   IM)M9LIGH H    H1H HIIIHIOH4H   MLDM9MMGLH H1H HHHHHHMIt-HHMI?HTI9  IT/LH9  LE1M  E1H$   M   L  L)LHLK<IM9MGMKT,IHLNJtHLM    AFARAVAB
I H HuIHT$L9LL$@<  HHHHHNHTHHHtHtHHt.HtA6AI@1HHA6AI@1HHA6AI@1HHH  ffffff.     AAAVYA^QAVYA^QAVYA^QHIHHf  JKL)M9MGMMJt-IIHLNI|Hffff.     AFAVAVAFH I HuM9LL$@   HHHHHNHt0HHHtHtWHHt4HtH:H)H*HH9HHH:H)H*HH9HHH:H)H*HH9HHHHr\fff.     H2H9H:H1HrHyHzHqHrHyHzHqHrHyHzHqHH H H L$   $      H$   H;$   HL$0  H$   HHH$   E1H$   H$   HD$0H$   McE1Iffffff.     MLH91  H$   L$H$   LH$     $       LH$   H$   L1HH+$   HH$       IH$      H$   H   HD$8H0HH$   H)LIHH+$   HI9>  H$   LH9    HD$hM+  H$   IL1G  fD  IHI$HI$M      H$   txLD$xItHD$H0HI9wrHt$XHH9weILHH$   E1M   H$   LM  H$   IL1H$   M  ILHH$   MiIKJH$   L)MJ41Hl$P LT\DHH9uH$   HvL9  HHHHHNHt2HHHtHtQHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHh       H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H H  1HD$hM@ 3L3I<1T;;3\3D;;H H9uH$   HpH9L   HHHHHNH|HHHtHtEHt,Ht@3H@1HH@3H@1HH@3H@1HHHrACQSACQSACQSAHHHH IIL;$   L7    HD$0HD$(H;$   HMu  ffff.     H$   HD$pH9v(1HHHHH$   L$   DL$LvH9$     H$   H$   H)H1IIIHD$`D$LARHLLH$   L$   H  [A\A]A^A_]SML$   M9M	  H$   LH$   H| HcHHHHHHIHIINLLLL$pHH$   HHHt$`H)Ht$hHHHINHH$   HLH$   H)H$      H)H$   HHL$xILL$XHfD  H$   H$   H$   H9  $    H$   I  H$    A    H$   IA    I  LH$   L$H$   LH$     H$      L$   ItxLH$   H$   L8H$   H49HH$   L)NLL$   L)HI9wXH$   H4>HL)HH9    H$   HT$xw?H$   ILE1]fff.     H$   L\1H$   HT$x@ ;L;H48T33;\;D33H H9uH$   HpL9L   HHHHHNH|HHHtHtEHt,Ht@3H@1HH@3H@1HH@3H@1HHHr>CQSACQSACQSAHHHHIL;$     ffff.     H$   H,H$   HH$   g  HH$   HHHHH;$   Hw<  fff.     LH$   Ll H$   LH$     H$   thLD$pItELH$   H$   HHT$hHHH9wOHL$`HHH+$   HH9w3LHH$   E1   fLHH$   H$      KD JL H$   L)H$   H|= 1Ht$Xfff.     D LTT \DHH9uH$   H$   HL9   HHHHHNHt2HHHtHtWHHt4HtH9H(H)HH8HHH9H(H)HH8HHH9H(H)HH8HHHHrYfff.     H1H8H9H0HqHxHyHpHqHxHyHpHqHxHyHpHH H HII9    H$   HD$(H;$   H$   HH$   H  [A\A]A^A_] Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)          zR x                      0              0   D       h   ABB B(B0A8G    x       3       4          0+   ABB B(B0A8G      .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                             @        9                                                   ?      H       
                    S                     `9                                                          `9                                           0               `9      N                                                   9                                     /                     9                                    *                       @      x       
                    9                      p:      Y                              K                      =               	                 C                      h?      i                                                      I                               0+                                                                                                                                              @       h                          *                    /           3       S                                            =                      B                       _qsort fls __heapsort_r __errno_location flsl qsort_r_local free malloc qsort_r.c _GLOBAL_OFFSET_TABLE_                     ~                                              4                     H             @       |                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper_la-strlcat.o   0100644 0000000 0000000 00000003240 13101126760 027713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                              @     @  	 AWAVAUATSIIIL    ILL    HL9uL/LH)I| I9sIVL    HL    CD/ LH[A\A]A^A_ Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)              zR x  ,          t    BBB B(A0       .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                             @       t                                                    (      `       
                    S                                                                                                                            0                      N                                                                                        /                           H                              *                                   
                    9                      P      Y                              K                            8                          C                            ?                                                                                                                                                                                                                           t       )                                                                                         memcpy strlcat strlen strnlen strlcat.c _GLOBAL_OFFSET_TABLE_               $             M          
   Z          
                                                                                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/.libs/libhelper_la-strlcpy.o   0100644 0000000 0000000 00000003110 13101126760 027733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                              @     @  	 AWAVATSPIIIL    HL9sHSLL    MtIWLL    CD> HH[A\A^A_  Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)              zR x  $          [    BBB A(A0 .rela.text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                             @       [                                                          H       
                    S                                                                                                                            0                      N                                                                                         /                            @                              *                      0             
                    9                      0      Y                              K                                                       C                            7                                                                                                                                                                                                                           [       !                                                                   memcpy strlcpy strlen strlcpy.c _GLOBAL_OFFSET_TABLE_               ,          
   B          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/                 0040755 0001750 0001750 00000000000 13101126756 025254  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/.libs/           0040755 0000000 0000000 00000000000 13101126756 026231  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/.libs/data.o     0100644 0000000 0000000 00000003030 13101126756 027313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                    (          @     @                   Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)          zR x                        .text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                          @                                     N                     D                                                           P                                           0               P       N                                                                                         *                            0                              %                                    	                    4                             T                              F                            h      
                    >                      P                                                                                                                                                                                                                                                           U                   (                   p                   ?                                        _Block_copy_error _NSConcreteAutoBlock _NSConcreteGlobalBlock _NSConcreteStackBlock _NSConcreteFinalizingBlock _NSConcreteMallocBlock _NSConcreteWeakBlockVariable data.c                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    libBlocksRuntime.a                                                                                  0100644 0000000 0000000 00000033216 13101126756 031566  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/.libs                                                                               !<arch>
/               1493478894  0     0     0       418       `
                   :  :  :  :  :  :  :  :  :  :  :_Block_copy_error _NSConcreteAutoBlock _NSConcreteFinalizingBlock _NSConcreteGlobalBlock _NSConcreteMallocBlock _NSConcreteStackBlock _NSConcreteWeakBlockVariable Block_size _Block_byref_dump _Block_copy _Block_copy_collectable _Block_dump _Block_object_assign _Block_object_dispose _Block_release _Block_use_GC _Block_use_GC5 _Block_use_RR  data.o/         1493478894  0     0     100644  1560      `
ELF         >                    (          @     @                   Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)          zR x                        .text .comment .bss .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data                                                                                          @                                     N                     D                                                           P                                           0               P       N                                                                                         *                            0                              %                                    	                    4                             T                              F                            h      
                    >                      P                                                                                                                                                                                                                                                           U                   (                   p                   ?                                        _Block_copy_error _NSConcreteAutoBlock _NSConcreteGlobalBlock _NSConcreteStackBlock _NSConcreteFinalizingBlock _NSConcreteMallocBlock _NSConcreteWeakBlockVariable data.c                            runtime.o/      1493478894  0     0     100644  11800     `
ELF         >                    (          @     @       H=    H;   H    H    H5        H    H    H    L    fffffff.         H=    HH    H    H5        H    H    H    H   H    ff.     Htff.     HHHHHuff.     H=    H5       	f     UAWAVATSAH1H  HKHck   t%      t[PuHn  A   tFAtP  tKPu      H    H$  H     tH  H  H          II   LHHCHxAD    I1M   HCHPLH    %  A	A   E~   tHCLHPMH    HE    ILcH^LsI~    H1HtGIVHH    E    MH    HM    tHHAVHH[A\A^A_]ff.     SHHtgHK  t  tOPufuA   tH    1H[   t   t
HCHPH[%       t[H=    1H[    fff.     1f     HGH@    UAWAVSPHI@t@   H       @tNHKA     f        HD       Pu   uL=    HHLL   uH    H    H   H[A^A_]Hc{1             ESPH@HCKHu
H    HCtHKHHHK HH HHSHxHsHcSH    H    H{LH[A^A_]fff.     AVSPI@thI^C     f   HK  t      Puf      tHS HH[A^%    %   u\M   AF   IN  t     Pufux   tHH    1LH[A^   uOLH[A^%    H=    1LH[A^       t   t
IFLPL8   tH[A^H=         AWAVAUATSIM   AF   L=    H5    1LL    HcI<IHt}H;       H;       H;       H;       H;       H5    1    HHI               )    =  Hisa: NULHG
 fGL
N|;
       fG
 N|;oH Block
 HG    N|;P    Gck
 N|;8    G fGk
N|;H Block
 HG    N|;AG fAGs:AflagMgAF       t*HCRIPTOR ID$H HASDESCI$MgAF      tH FREEME I$IAFM   tfAD$C A$ ISGIAF   tH HASHELPI$AD$ IAF   tH HASCTORI$AD$ IAFH5    1L    LcK<<IVH5    1    HcLI<M~H5    1L    LcIK<,IH5    1    HcLI<IWH5    1    AFt7LcIK<4IWH5    1    HcLLIWH5    1    H    [A\A]A^A_H=               D  AWAVATSPIL5    H5    1LL    LcK<&IWH5    1    HcLI<AWH5    1    LcIK<&AWH5    1    AGt7HcLI<IWH5    1    HcHLIW H5    1    H    H[A\A^A_     H>fff.     P    X     H>fff.     ffffff.     ffffff.     ffffff.                                                                                    Block_release called upon a stack Block: %p, ignored
 NULL passed to _Block_dump
 ^%p (new layout) =
 isa: NULL
 isa: stack Block
 isa: malloc heap Block
 isa: GC heap Block
 isa: global Block
 isa: finalizing Block
 isa?: %p
 flags:  HASDESCRIPTOR  ISGC  HASHELP  HASCTOR 
refcount: %u
 invoke: %p
 descriptor: %p
 descriptor->reserved: %lu
 descriptor->size: %lu
 descriptor->copy helper: %p
 descriptor->dispose helper: %p
 byref data block %p contents:
   forwarding: %p
   flags: 0x%x
   size: %d
   copy helper: %p
   dispose helper: %p
 _Block_byref_release: Block byref data structure at %p underflowed
             Block compiled by obsolete compiler, please recompile source for this Block  Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)              zR x            N          0                 D       U          X       %          l                               (             ABB B(A0                A                             	       $          t   ABB A(A0   (      H   BAA   (   H      +   BBB B(A0  $   t          BBB A(A0                             A                                                                                      .rela.text .comment .bss .rela.data.rel .rela.data.rel.local .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data .rodata.str1.16 .rodata.str1.1                                                                                          @       
                                                   !      	                          w                                                                                                                  .                           8                              )                      `+                                                      H                                                          ,                                       2               P      d                            }      2                     L                                   0                     N                             >                      Z                                     S                     `      (                             N                       ,                                ]                                                          o                                     :                 g                            +                                                                           	         6          	 6              "   	        
          	                 	               n   	 ,                	 <                	 W                	 n                	                  	                 	                 	                 	                 	              e   	 
                	 R                 	        D          	 q                 	                  	               w   	               ]   	                  
         L            
             5                                          `
             U    (                   
             Y                                 "                   h    P              F                      0                   p
                        %                           e     
                                H     
                                *     
                               J                                                                                                                                      	                      
                                                                                             	       ~    	                                    p             r    `      +                t                H                       O            N           `       U       <                  &                                          #                                          >                                                                                                                                                                          {                                          z                      _Block_copy memcpy _Block_setHasRefcount _Block_setHasRefcount_default _Block_retain_object_default _Block_release_object_default _Block_assign_default _Block_assign_weak_default _Block_memmove_default _Block_alloc_default exit _Block_retain_object _Block_release_object puts .Lstr .L.str _Block_deallocator _Block_allocator _Block_dump.buffer _Block_byref_dump.buffer _Block_dump _Block_byref_dump _Block_object_assign _Block_assign _Block_memmove_gc_broken _Block_copy_internal _NSConcreteAutoBlock _NSConcreteGlobalBlock _NSConcreteStackBlock _NSConcreteFinalizingBlock _NSConcreteMallocBlock _Block_assign_weak _Block_do_nothing sprintf Block_size _Block_memmove _Byref_flag_initial_value _Block_object_dispose _Block_release _Block_copy_collectable _NSConcreteWeakBlockVariable free malloc runtime.c _GLOBAL_OFFSET_TABLE_ _Block_use_RR isGC _Block_use_GC .L.str9 .L.str29 .L.str19 .L.str8 .L.str28 .L.str18 .L.str7 .L.str27 .L.str17 .L.str6 .L.str26 .L.str5 _Block_use_GC5 .L.str25 .L.str24 .L.str3 .L.str23 .L.str22 .L.str1 .L.str21 .L.str30 .L.str20 .L.str10                2   
          3             4             3          &          3          ,          2   4          3          ;          3          B          3   $       I          3   ,       b          2   j          3   x          4             3                    3                    2             3                    3                    3   $                 3   ,                 3                    3                   3                   2             3   !         P   U      	   F   ]      	   G   w         N            O         	   I            3          E         4   U            `         Q            3   $                3          E         3          L         3          w         3   }         2         	   K            3   ,                3                   4            3                   3                               Q   R                     2                               S         	   J         	   I         	   F         	   H         	   G                        S   	                            2                               2          K            p                                                                     S                        S                        S               	         S   	         	   "	         S   >	         
   E	         S   Y	            `	         S   g	         2          x	            }	         R   	         L   	         2         	            	         S   	            	         S   	            	         S   	            
         S   
            &
         S   :
            A
         S   H
         2         r
         P   
         N              0   
                0   `
                0   
                0   
                 0   
      (          0   
      0          0   p
                 M                      0           4          0   P       H          0   `       \          0          p          0                    0                    0                   0                   0   p                0                  0         ,         0         L         0   `      x         0   	               0   `
               0   p
               0   
               0   
               0   
               0   
               0   
                                                                                                                                                                                                                                                                                                                                                                                        libBlocksRuntime.la                                                                                 0120777 0000000 0000000 00000000000 13101126756 035735  2../libBlocksRuntime.la                                                                              ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/.libs                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/.libs/runtime.o  0100644 0000000 0000000 00000027030 13101126756 030073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ELF         >                    (          @     @       H=    H;   H    H    H5        H    H    H    L    fffffff.         H=    HH    H    H5        H    H    H    H   H    ff.     Htff.     HHHHHuff.     H=    H5       	f     UAWAVATSAH1H  HKHck   t%      t[PuHn  A   tFAtP  tKPu      H    H$  H     tH  H  H          II   LHHCHxAD    I1M   HCHPLH    %  A	A   E~   tHCLHPMH    HE    ILcH^LsI~    H1HtGIVHH    E    MH    HM    tHHAVHH[A\A^A_]ff.     SHHtgHK  t  tOPufuA   tH    1H[   t   t
HCHPH[%       t[H=    1H[    fff.     1f     HGH@    UAWAVSPHI@t@   H       @tNHKA     f        HD       Pu   uL=    HHLL   uH    H    H   H[A^A_]Hc{1             ESPH@HCKHu
H    HCtHKHHHK HH HHSHxHsHcSH    H    H{LH[A^A_]fff.     AVSPI@thI^C     f   HK  t      Puf      tHS HH[A^%    %   u\M   AF   IN  t     Pufux   tHH    1LH[A^   uOLH[A^%    H=    1LH[A^       t   t
IFLPL8   tH[A^H=         AWAVAUATSIM   AF   L=    H5    1LL    HcI<IHt}H;       H;       H;       H;       H;       H5    1    HHI               )    =  Hisa: NULHG
 fGL
N|;
       fG
 N|;oH Block
 HG    N|;P    Gck
 N|;8    G fGk
N|;H Block
 HG    N|;AG fAGs:AflagMgAF       t*HCRIPTOR ID$H HASDESCI$MgAF      tH FREEME I$IAFM   tfAD$C A$ ISGIAF   tH HASHELPI$AD$ IAF   tH HASCTORI$AD$ IAFH5    1L    LcK<<IVH5    1    HcLI<M~H5    1L    LcIK<,IH5    1    HcLI<IWH5    1    AFt7LcIK<4IWH5    1    HcLLIWH5    1    H    [A\A]A^A_H=               D  AWAVATSPIL5    H5    1LL    LcK<&IWH5    1    HcLI<AWH5    1    LcIK<&AWH5    1    AGt7HcLI<IWH5    1    HcHLIW H5    1    H    H[A\A^A_     H>fff.     P    X     H>fff.     ffffff.     ffffff.     ffffff.                                                                                    Block_release called upon a stack Block: %p, ignored
 NULL passed to _Block_dump
 ^%p (new layout) =
 isa: NULL
 isa: stack Block
 isa: malloc heap Block
 isa: GC heap Block
 isa: global Block
 isa: finalizing Block
 isa?: %p
 flags:  HASDESCRIPTOR  ISGC  HASHELP  HASCTOR 
refcount: %u
 invoke: %p
 descriptor: %p
 descriptor->reserved: %lu
 descriptor->size: %lu
 descriptor->copy helper: %p
 descriptor->dispose helper: %p
 byref data block %p contents:
   forwarding: %p
   flags: 0x%x
   size: %d
   copy helper: %p
   dispose helper: %p
 _Block_byref_release: Block byref data structure at %p underflowed
             Block compiled by obsolete compiler, please recompile source for this Block  Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)              zR x            N          0                 D       U          X       %          l                               (             ABB B(A0                A                             	       $          t   ABB A(A0   (      H   BAA   (   H      +   BBB B(A0  $   t          BBB A(A0                             A                                                                                      .rela.text .comment .bss .rela.data.rel .rela.data.rel.local .note.GNU-stack .rela.eh_frame .shstrtab .strtab .symtab .data .rodata.str1.16 .rodata.str1.1                                                                                          @       
                                                   !      	                          w                                                                                                                  .                           8                              )                      `+                                                      H                                                          ,                                       2               P      d                            }      2                     L                                   0                     N                             >                      Z                                     S                     `      (                             N                       ,                                ]                                                          o                                     :                 g                            +                                                                           	         6          	 6              "   	        
          	                 	               n   	 ,                	 <                	 W                	 n                	                  	                 	                 	                 	                 	              e   	 
                	 R                 	        D          	 q                 	                  	               w   	               ]   	                  
         L            
             5                                          `
             U    (                   
             Y                                 "                   h    P              F                      0                   p
                        %                           e     
                                H     
                                *     
                               J                                                                                                                                      	                      
                                                                                             	       ~    	                                    p             r    `      +                t                H                       O            N           `       U       <                  &                                          #                                          >                                                                                                                                                                          {                                          z                      _Block_copy memcpy _Block_setHasRefcount _Block_setHasRefcount_default _Block_retain_object_default _Block_release_object_default _Block_assign_default _Block_assign_weak_default _Block_memmove_default _Block_alloc_default exit _Block_retain_object _Block_release_object puts .Lstr .L.str _Block_deallocator _Block_allocator _Block_dump.buffer _Block_byref_dump.buffer _Block_dump _Block_byref_dump _Block_object_assign _Block_assign _Block_memmove_gc_broken _Block_copy_internal _NSConcreteAutoBlock _NSConcreteGlobalBlock _NSConcreteStackBlock _NSConcreteFinalizingBlock _NSConcreteMallocBlock _Block_assign_weak _Block_do_nothing sprintf Block_size _Block_memmove _Byref_flag_initial_value _Block_object_dispose _Block_release _Block_copy_collectable _NSConcreteWeakBlockVariable free malloc runtime.c _GLOBAL_OFFSET_TABLE_ _Block_use_RR isGC _Block_use_GC .L.str9 .L.str29 .L.str19 .L.str8 .L.str28 .L.str18 .L.str7 .L.str27 .L.str17 .L.str6 .L.str26 .L.str5 _Block_use_GC5 .L.str25 .L.str24 .L.str3 .L.str23 .L.str22 .L.str1 .L.str21 .L.str30 .L.str20 .L.str10                2   
          3             4             3          &          3          ,          2   4          3          ;          3          B          3   $       I          3   ,       b          2   j          3   x          4             3                    3                    2             3                    3                    3   $                 3   ,                 3                    3                   3                   2             3   !         P   U      	   F   ]      	   G   w         N            O         	   I            3          E         4   U            `         Q            3   $                3          E         3          L         3          w         3   }         2         	   K            3   ,                3                   4            3                   3                               Q   R                     2                               S         	   J         	   I         	   F         	   H         	   G                        S   	                            2                               2          K            p                                                                     S                        S                        S               	         S   	         	   "	         S   >	         
   E	         S   Y	            `	         S   g	         2          x	            }	         R   	         L   	         2         	            	         S   	            	         S   	            	         S   	            
         S   
            &
         S   :
            A
         S   H
         2         r
         P   
         N              0   
                0   `
                0   
                0   
                 0   
      (          0   
      0          0   p
                 M                      0           4          0   P       H          0   `       \          0          p          0                    0                    0                   0                   0   p                0                  0         ,         0         L         0   `      x         0   	               0   `
               0   p
               0   
               0   
               0   
               0   
               0   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/Block.h          0100644 0001750 0001750 00000003730 12612724205 026456  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Block.h
 *
 * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#ifndef _BLOCK_H_
#define _BLOCK_H_

#if !defined(BLOCK_EXPORT)
#   if defined(__cplusplus)
#       define BLOCK_EXPORT extern "C" 
#   else
#       define BLOCK_EXPORT extern
#   endif
#endif

#if defined(__cplusplus)
extern "C" {
#endif

/* Create a heap based copy of a Block or simply add a reference to an existing one.
 * This must be paired with Block_release to recover memory, even when running
 * under Objective-C Garbage Collection.
 */
BLOCK_EXPORT void *_Block_copy(const void *aBlock);

/* Lose the reference, and if heap based and last reference, recover the memory. */
BLOCK_EXPORT void _Block_release(const void *aBlock);

#if defined(__cplusplus)
}
#endif

/* Type correct macros. */

#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))
#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))


#endif
                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/Block_private.h  0100644 0001750 0001750 00000013701 12612724205 030207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Block_private.h
 *
 * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#ifndef _BLOCK_PRIVATE_H_
#define _BLOCK_PRIVATE_H_

#if !defined(BLOCK_EXPORT)
#   if defined(__cplusplus)
#       define BLOCK_EXPORT extern "C" 
#   else
#       define BLOCK_EXPORT extern
#   endif
#endif

#ifndef _MSC_VER
#include <stdbool.h>
#else
/* MSVC doesn't have <stdbool.h>. Compensate. */
typedef char bool;
#define true (bool)1
#define false (bool)0
#endif

#if defined(__cplusplus)
extern "C" {
#endif


enum {
    BLOCK_REFCOUNT_MASK =     (0xffff),
    BLOCK_NEEDS_FREE =        (1 << 24),
    BLOCK_HAS_COPY_DISPOSE =  (1 << 25),
    BLOCK_HAS_CTOR =          (1 << 26), /* Helpers have C++ code. */
    BLOCK_IS_GC =             (1 << 27),
    BLOCK_IS_GLOBAL =         (1 << 28),
    BLOCK_HAS_DESCRIPTOR =    (1 << 29)
};


/* Revised new layout. */
struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};


struct Block_layout {
    void *isa;
    int flags;
    int reserved; 
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};


struct Block_byref {
    void *isa;
    struct Block_byref *forwarding;
    int flags; /* refcount; */
    int size;
    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
    void (*byref_destroy)(struct Block_byref *);
    /* long shared[0]; */
};


struct Block_byref_header {
    void *isa;
    struct Block_byref *forwarding;
    int flags;
    int size;
};


/* Runtime support functions used by compiler when generating copy/dispose helpers. */

enum {
    /* See function implementation for a more complete description of these fields and combinations */
    BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */
    BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */
    BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */
    BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */
    BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */
};

/* Runtime entry point called by compiler when assigning objects inside copy helper routines */
BLOCK_EXPORT void _Block_object_assign(void *destAddr, const void *object, const int flags);
    /* BLOCK_FIELD_IS_BYREF is only used from within block copy helpers */


/* runtime entry point called by the compiler when disposing of objects inside dispose helper routine */
BLOCK_EXPORT void _Block_object_dispose(const void *object, const int flags);



/* Other support functions */

/* Runtime entry to get total size of a closure */
BLOCK_EXPORT unsigned long int Block_size(void *block_basic);



/* the raw data space for runtime classes for blocks */
/* class+meta used for stack, malloc, and collectable based blocks */
BLOCK_EXPORT void * _NSConcreteStackBlock[32];
BLOCK_EXPORT void * _NSConcreteMallocBlock[32];
BLOCK_EXPORT void * _NSConcreteAutoBlock[32];
BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32];
BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];
BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32];


/* the intercept routines that must be used under GC */
BLOCK_EXPORT void _Block_use_GC( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
                                  void (*setHasRefcount)(const void *, const bool),
                                  void (*gc_assign_strong)(void *, void **),
                                  void (*gc_assign_weak)(const void *, void *),
                                  void (*gc_memmove)(void *, void *, unsigned long));

/* earlier version, now simply transitional */
BLOCK_EXPORT void _Block_use_GC5( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
                                  void (*setHasRefcount)(const void *, const bool),
                                  void (*gc_assign_strong)(void *, void **),
                                  void (*gc_assign_weak)(const void *, void *));

BLOCK_EXPORT void _Block_use_RR( void (*retain)(const void *),
                                 void (*release)(const void *));

/* make a collectable GC heap based Block.  Not useful under non-GC. */
BLOCK_EXPORT void *_Block_copy_collectable(const void *aBlock);

/* thread-unsafe diagnostic */
BLOCK_EXPORT const char *_Block_dump(const void *block);


/* Obsolete */

/* first layout */
struct Block_basic {
    void *isa;
    int Block_flags;  /* int32_t */
    int Block_size;  /* XXX should be packed into Block_flags */
    void (*Block_invoke)(void *);
    void (*Block_copy)(void *dst, void *src);  /* iff BLOCK_HAS_COPY_DISPOSE */
    void (*Block_dispose)(void *);             /* iff BLOCK_HAS_COPY_DISPOSE */
    /* long params[0];  // where const imports, __block storage references, etc. get laid down */
};


#if defined(__cplusplus)
}
#endif


#endif /* _BLOCK_PRIVATE_H_ */
                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/Makefile         0100644 0000000 0000000 00000044067 13101126656 026671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# ld64/src/3rd/BlocksRuntime/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.





am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/cctools
pkgincludedir = $(includedir)/cctools
pkglibdir = $(libdir)/cctools
pkglibexecdir = $(libexecdir)/cctools
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = x86_64-unknown-linux-gnu
host_triplet = x86_64-unknown-linux-gnu
target_triplet = x86_64-apple-darwin15
subdir = ld64/src/3rd/BlocksRuntime
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(noinst_HEADERS) \
	$(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
LTLIBRARIES = $(noinst_LTLIBRARIES)
libBlocksRuntime_la_LIBADD =
am_libBlocksRuntime_la_OBJECTS = data.lo runtime.lo
libBlocksRuntime_la_OBJECTS = $(am_libBlocksRuntime_la_OBJECTS)
AM_V_lt = $(am__v_lt_$(V))
am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
am__v_lt_0 = --silent
am__v_lt_1 = 
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_$(V))
am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_$(V))
am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(libBlocksRuntime_la_SOURCES)
DIST_SOURCES = $(libBlocksRuntime_la_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
HEADERS = $(noinst_HEADERS)
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing aclocal-1.15
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 1
AR = ar
ASLIBEXECDIR = ${libexecdir}/as
AUTOCONF = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoconf
AUTOHEADER = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoheader
AUTOMAKE = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing automake-1.15
AWK = mawk
CC = clang
CCAS = clang
CCASFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include
CFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include -DDISABLE_CLANG_AS
CPP = clang -E
CPPFLAGS = 
CXX = clang++
CXXABI_LIB = -lsupc++
CXXCPP = clang++ -E
CXXFLAGS = -O3 -std=c++0x -isystem /usr/local/include -isystem /usr/pkg/include  -fblocks
CYGPATH_W = echo
DEFS = -DPACKAGE_NAME=\"cctools\" -DPACKAGE_TARNAME=\"cctools\" -DPACKAGE_VERSION=\"877.5\" -DPACKAGE_STRING=\"cctools\ 877.5\" -DPACKAGE_BUGREPORT=\"t.poechtrager@gmail.com\" -DPACKAGE_URL=\"\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DEMULATED_HOST_CPU_TYPE=16777223 -DEMULATED_HOST_CPU_SUBTYPE=3 -D__STDC_LIMIT_MACROS=1 -D__STDC_CONSTANT_MACROS=1 -DHAVE_EXECINFO_H=1
DLLTOOL = false
DL_LIB = -ldl
DSYMUTIL = 
DUMPBIN = 
ECHO_C = 
ECHO_N = -n
ECHO_T = 
EGREP = /bin/grep -E
ENDIAN_FLAG = -D__LITTLE_ENDIAN__=1
EXECINFO_LIB = 
EXEEXT = 
FGREP = /bin/grep -F
GREP = /bin/grep
HOST_AR = ar
HOST_RANLIB = ranlib
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
LD = /usr/bin/ld -m elf_x86_64
LDFLAGS =  -L/usr/local/lib -L/usr/pkg/lib 
LIBOBJS = 
LIBS = 
LIBTOOL = $(SHELL) $(top_builddir)/libtool
LIPO = 
LLVM_CONFIG = no
LLVM_INCLUDE_DIR = 
LLVM_LIB_DIR = 
LN_S = ln -s
LTLIBOBJS = 
LTO_DEF = 
LTO_LIB = 
LTO_RPATH = 
LT_SYS_LIBRARY_PATH = 
MAINT = #
MAKEINFO = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing makeinfo
MANIFEST_TOOL = :
MKDIR_P = /bin/mkdir -p
NM = /usr/bin/nm -B
NMEDIT = 
OBJC = clang
OBJCFLAGS = -O3
OBJCWARNINGS = -Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage
OBJDUMP = objdump
OBJEXT = o
OTOOL = 
OTOOL64 = 
PACKAGE = cctools
PACKAGE_BUGREPORT = t.poechtrager@gmail.com
PACKAGE_NAME = cctools
PACKAGE_STRING = cctools 877.5
PACKAGE_TARNAME = cctools
PACKAGE_URL = 
PACKAGE_VERSION = 877.5
PATH_SEPARATOR = :
PROGRAM_PREFIX = ${target_alias}-
PTHREAD_FLAGS = -pthread
RANLIB = ranlib
SED = /bin/sed
SET_MAKE = 
SHELL = /bin/bash
STRIP = strip
UUID_LIB = 
VERSION = 877.5
WARNINGS =  -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof -Wno-int-conversion -Wno-char-subscripts
XAR_LIB = 
abs_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime
abs_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime
abs_top_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
abs_top_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
ac_ct_AR = ar
ac_ct_CC = clang
ac_ct_CXX = 
ac_ct_DUMPBIN = 
ac_ct_OBJC = 
am__leading_dot = .
am__tar = tar --format=ustar -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = x86_64-unknown-linux-gnu
build_alias = 
build_cpu = x86_64
build_os = linux-gnu
build_vendor = unknown
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
host = x86_64-unknown-linux-gnu
host_alias = 
host_cpu = x86_64
host_os = linux-gnu
host_vendor = unknown
htmldir = ${docdir}
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
prefix = /osxcross/target
program_transform_name = s&^&x86_64-apple-darwin15-&
psdir = ${docdir}
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target = x86_64-apple-darwin15
target_alias = x86_64-apple-darwin15
target_cpu = x86_64
target_os = darwin15
target_vendor = apple
top_build_prefix = ../../../../
top_builddir = ../../../..
top_srcdir = ../../../..
noinst_LTLIBRARIES = libBlocksRuntime.la
noinst_HEADERS = \
	Block.h  \
	Block_private.h  \
	config.h 

libBlocksRuntime_la_SOURCES = \
	data.c  \
	runtime.c 

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/BlocksRuntime/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/BlocksRuntime/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: # $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

clean-noinstLTLIBRARIES:
	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
	@list='$(noinst_LTLIBRARIES)'; \
	locs=`for p in $$list; do echo $$p; done | \
	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
	      sort -u`; \
	test -z "$$locs" || { \
	  echo rm -f $${locs}; \
	  rm -f $${locs}; \
	}

libBlocksRuntime.la: $(libBlocksRuntime_la_OBJECTS) $(libBlocksRuntime_la_DEPENDENCIES) $(EXTRA_libBlocksRuntime_la_DEPENDENCIES) 
	$(AM_V_CCLD)$(LINK)  $(libBlocksRuntime_la_OBJECTS) $(libBlocksRuntime_la_LIBADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(LTLIBRARIES) $(HEADERS)
installdirs:
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
	mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am:

.MAKE: install-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
	ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-data \
	install-data-am install-dvi install-dvi-am install-exec \
	install-exec-am install-html install-html-am install-info \
	install-info-am install-man install-pdf install-pdf-am \
	install-ps install-ps-am install-strip installcheck \
	installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-compile \
	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
	tags tags-am uninstall uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/Makefile.am      0100644 0001750 0001750 00000000242 12612724205 027302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        noinst_LTLIBRARIES = libBlocksRuntime.la

noinst_HEADERS =  \
	Block.h  \
	Block_private.h  \
	config.h 

libBlocksRuntime_la_SOURCES =  \
	data.c  \
	runtime.c 
                                                                                                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/Makefile.in      0100644 0001750 0001750 00000041324 12612724226 027324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@


VPATH = @srcdir@
am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = ld64/src/3rd/BlocksRuntime
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(noinst_HEADERS) \
	$(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
LTLIBRARIES = $(noinst_LTLIBRARIES)
libBlocksRuntime_la_LIBADD =
am_libBlocksRuntime_la_OBJECTS = data.lo runtime.lo
libBlocksRuntime_la_OBJECTS = $(am_libBlocksRuntime_la_OBJECTS)
AM_V_lt = $(am__v_lt_@AM_V@)
am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
am__v_lt_0 = --silent
am__v_lt_1 = 
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.@am__isrc@
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_@AM_V@)
am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_@AM_V@)
am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(libBlocksRuntime_la_SOURCES)
DIST_SOURCES = $(libBlocksRuntime_la_SOURCES)
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
HEADERS = $(noinst_HEADERS)
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
ACLOCAL = @ACLOCAL@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
ASLIBEXECDIR = @ASLIBEXECDIR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASFLAGS = @CCASFLAGS@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CXX = @CXX@
CXXABI_LIB = @CXXABI_LIB@
CXXCPP = @CXXCPP@
CXXFLAGS = @CXXFLAGS@
CYGPATH_W = @CYGPATH_W@
DEFS = @DEFS@
DLLTOOL = @DLLTOOL@
DL_LIB = @DL_LIB@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
ENDIAN_FLAG = @ENDIAN_FLAG@
EXECINFO_LIB = @EXECINFO_LIB@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
GREP = @GREP@
HOST_AR = @HOST_AR@
HOST_RANLIB = @HOST_RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIPO = @LIPO@
LLVM_CONFIG = @LLVM_CONFIG@
LLVM_INCLUDE_DIR = @LLVM_INCLUDE_DIR@
LLVM_LIB_DIR = @LLVM_LIB_DIR@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
LTO_DEF = @LTO_DEF@
LTO_LIB = @LTO_LIB@
LTO_RPATH = @LTO_RPATH@
LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
OBJC = @OBJC@
OBJCFLAGS = @OBJCFLAGS@
OBJCWARNINGS = @OBJCWARNINGS@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
PROGRAM_PREFIX = @PROGRAM_PREFIX@
PTHREAD_FLAGS = @PTHREAD_FLAGS@
RANLIB = @RANLIB@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
STRIP = @STRIP@
UUID_LIB = @UUID_LIB@
VERSION = @VERSION@
WARNINGS = @WARNINGS@
XAR_LIB = @XAR_LIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_CXX = @ac_ct_CXX@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
ac_ct_OBJC = @ac_ct_OBJC@
am__leading_dot = @am__leading_dot@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
noinst_LTLIBRARIES = libBlocksRuntime.la
noinst_HEADERS = \
	Block.h  \
	Block_private.h  \
	config.h 

libBlocksRuntime_la_SOURCES = \
	data.c  \
	runtime.c 

all: all-am

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/BlocksRuntime/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/BlocksRuntime/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

clean-noinstLTLIBRARIES:
	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
	@list='$(noinst_LTLIBRARIES)'; \
	locs=`for p in $$list; do echo $$p; done | \
	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
	      sort -u`; \
	test -z "$$locs" || { \
	  echo rm -f $${locs}; \
	  rm -f $${locs}; \
	}

libBlocksRuntime.la: $(libBlocksRuntime_la_OBJECTS) $(libBlocksRuntime_la_DEPENDENCIES) $(EXTRA_libBlocksRuntime_la_DEPENDENCIES) 
	$(AM_V_CCLD)$(LINK)  $(libBlocksRuntime_la_OBJECTS) $(libBlocksRuntime_la_LIBADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-am
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-am

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-am

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-am
all-am: Makefile $(LTLIBRARIES) $(HEADERS)
installdirs:
install: install-am
install-exec: install-exec-am
install-data: install-data-am
uninstall: uninstall-am

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-am
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-am

clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
	mostlyclean-am

distclean: distclean-am
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-am

dvi-am:

html: html-am

html-am:

info: info-am

info-am:

install-data-am:

install-dvi: install-dvi-am

install-dvi-am:

install-exec-am:

install-html: install-html-am

install-html-am:

install-info: install-info-am

install-info-am:

install-man:

install-pdf: install-pdf-am

install-pdf-am:

install-ps: install-ps-am

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-am
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-am

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-am

pdf-am:

ps: ps-am

ps-am:

uninstall-am:

.MAKE: install-am install-strip

.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
	ctags-am distclean distclean-compile distclean-generic \
	distclean-libtool distclean-tags distdir dvi dvi-am html \
	html-am info info-am install install-am install-data \
	install-data-am install-dvi install-dvi-am install-exec \
	install-exec-am install-html install-html-am install-info \
	install-info-am install-man install-pdf install-pdf-am \
	install-ps install-ps-am install-strip installcheck \
	installcheck-am installdirs maintainer-clean \
	maintainer-clean-generic mostlyclean mostlyclean-compile \
	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
	tags tags-am uninstall uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/config.h         0100644 0001750 0001750 00000000504 12612724205 026665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* AUTOMATICALLY GENERATED -- DO NOT EDIT */

#define HAVE_SYNC_BOOL_COMPARE_AND_SWAP_INT 1
#define HAVE_SYNC_BOOL_COMPARE_AND_SWAP_LONG 1
#define PROGRAM "libBlocksRuntime"
#define VERSION "0.1"
#define TARGET "linux"
#define CFLAGS "-DBlocksRuntime_EXPORTS -fPIC -std=c99 -Wall -Wextra -W -pedantic -Wno-unused-parameter"
                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/data.c           0100644 0001750 0001750 00000003667 12612724205 026341  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * data.c
 *
 * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/********************
NSBlock support

We allocate space and export a symbol to be used as the Class for the on-stack and malloc'ed copies until ObjC arrives on the scene.  These data areas are set up by Foundation to link in as real classes post facto.

We keep these in a separate file so that we can include the runtime code in test subprojects but not include the data so that compiled code that sees the data in libSystem doesn't get confused by a second copy.  Somehow these don't get unified in a common block.
**********************/

void * _NSConcreteStackBlock[32] = { 0 };
void * _NSConcreteMallocBlock[32] = { 0 };
void * _NSConcreteAutoBlock[32] = { 0 };
void * _NSConcreteFinalizingBlock[32] = { 0 };
void * _NSConcreteGlobalBlock[32] = { 0 };
void * _NSConcreteWeakBlockVariable[32] = { 0 };

void _Block_copy_error(void) {
}
                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/data.lo          0100644 0000000 0000000 00000000404 13101126756 026462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # data.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/data.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                                                            libBlocksRuntime.la                                                                                 0100644 0000000 0000000 00000001611 13101126756 030725  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime                                                                                     # libBlocksRuntime.la - a libtool library file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# The name that we can dlopen(3).
dlname=''

# Names of this library.
library_names=''

# The name of the static archive.
old_library='libBlocksRuntime.a'

# Linker flags that cannot go in dependency_libs.
inherited_linker_flags=''

# Libraries that this one depends upon.
dependency_libs=' -L/usr/local/lib -L/usr/pkg/lib'

# Names of additional weak libraries provided by this library
weak_library_names=''

# Version information for libBlocksRuntime.
current=
age=
revision=

# Is this an already installed library?
installed=no

# Should we warn about portability when linking against -modules?
shouldnotlink=no

# Files to dlopen/dlpreopen
dlopen=''
dlpreopen=''

# Directory that this library needs to be installed in:
libdir=''
                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/runtime.c        0100644 0001750 0001750 00000063600 12612724205 027104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * runtime.c
 *
 * Copyright 2008-2010 Apple, Inc. Permission is hereby granted, free of charge,
 * to any person obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#include "Block_private.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "config.h"

#ifdef HAVE_AVAILABILITY_MACROS_H
#include <AvailabilityMacros.h>
#endif /* HAVE_AVAILABILITY_MACROS_H */

#ifdef HAVE_TARGET_CONDITIONALS_H
#include <TargetConditionals.h>
#endif /* HAVE_TARGET_CONDITIONALS_H */

#if defined(HAVE_OSATOMIC_COMPARE_AND_SWAP_INT) && defined(HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG)

#ifdef HAVE_LIBKERN_OSATOMIC_H
#include <libkern/OSAtomic.h>
#endif /* HAVE_LIBKERN_OSATOMIC_H */

#elif defined(__WIN32__) || defined(_WIN32)
#define _CRT_SECURE_NO_WARNINGS 1
#include <windows.h>

static __inline bool OSAtomicCompareAndSwapLong(long oldl, long newl, long volatile *dst) {
    /* fixme barrier is overkill -- see objc-os.h */
    long original = InterlockedCompareExchange(dst, newl, oldl);
    return (original == oldl);
}

static __inline bool OSAtomicCompareAndSwapInt(int oldi, int newi, int volatile *dst) {
    /* fixme barrier is overkill -- see objc-os.h */
    int original = InterlockedCompareExchange(dst, newi, oldi);
    return (original == oldi);
}

/*
 * Check to see if the GCC atomic built-ins are available.  If we're on
 * a 64-bit system, make sure we have an 8-byte atomic function
 * available.
 *
 */

#elif defined(HAVE_SYNC_BOOL_COMPARE_AND_SWAP_INT) && defined(HAVE_SYNC_BOOL_COMPARE_AND_SWAP_LONG)

static __inline bool OSAtomicCompareAndSwapLong(long oldl, long newl, long volatile *dst) {
  return __sync_bool_compare_and_swap(dst, oldl, newl);
}

static __inline bool OSAtomicCompareAndSwapInt(int oldi, int newi, int volatile *dst) {
  return __sync_bool_compare_and_swap(dst, oldi, newi);
}

#else
#error unknown atomic compare-and-swap primitive
#endif /* HAVE_OSATOMIC_COMPARE_AND_SWAP_INT && HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG */


/*
 * Globals:
 */

static void *_Block_copy_class = _NSConcreteMallocBlock;
static void *_Block_copy_finalizing_class = _NSConcreteMallocBlock;
static int _Block_copy_flag = BLOCK_NEEDS_FREE;
static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;

static const int WANTS_ONE = (1 << 16);

static bool isGC = false;

/*
 * Internal Utilities:
 */

#if 0
static unsigned long int latching_incr_long(unsigned long int *where) {
    while (1) {
        unsigned long int old_value = *(volatile unsigned long int *)where;
        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
            return BLOCK_REFCOUNT_MASK;
        }
        if (OSAtomicCompareAndSwapLong(old_value, old_value+1, (volatile long int *)where)) {
            return old_value+1;
        }
    }
}
#endif /* if 0 */

static int latching_incr_int(int *where) {
    while (1) {
        int old_value = *(volatile int *)where;
        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
            return BLOCK_REFCOUNT_MASK;
        }
        if (OSAtomicCompareAndSwapInt(old_value, old_value+1, (volatile int *)where)) {
            return old_value+1;
        }
    }
}

#if 0
static int latching_decr_long(unsigned long int *where) {
    while (1) {
        unsigned long int old_value = *(volatile int *)where;
        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
            return BLOCK_REFCOUNT_MASK;
        }
        if ((old_value & BLOCK_REFCOUNT_MASK) == 0) {
            return 0;
        }
        if (OSAtomicCompareAndSwapLong(old_value, old_value-1, (volatile long int *)where)) {
            return old_value-1;
        }
    }
}
#endif /* if 0 */

static int latching_decr_int(int *where) {
    while (1) {
        int old_value = *(volatile int *)where;
        if ((old_value & BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
            return BLOCK_REFCOUNT_MASK;
        }
        if ((old_value & BLOCK_REFCOUNT_MASK) == 0) {
            return 0;
        }
        if (OSAtomicCompareAndSwapInt(old_value, old_value-1, (volatile int *)where)) {
            return old_value-1;
        }
    }
}


/*
 * GC support stub routines:
 */
#if 0
#pragma mark GC Support Routines
#endif /* if 0 */


static void *_Block_alloc_default(const unsigned long size, const bool initialCountIsOne, const bool isObject) {
    return malloc(size);
}

static void _Block_assign_default(void *value, void **destptr) {
    *destptr = value;
}

static void _Block_setHasRefcount_default(const void *ptr, const bool hasRefcount) {
}

static void _Block_do_nothing(const void *aBlock) { }

static void _Block_retain_object_default(const void *ptr) {
    if (!ptr) return;
}

static void _Block_release_object_default(const void *ptr) {
    if (!ptr) return;
}

static void _Block_assign_weak_default(const void *ptr, void *dest) {
    *(void **)dest = (void *)ptr;
}

static void _Block_memmove_default(void *dst, void *src, unsigned long size) {
    memmove(dst, src, (size_t)size);
}

static void _Block_memmove_gc_broken(void *dest, void *src, unsigned long size) {
    void **destp = (void **)dest;
    void **srcp = (void **)src;
    while (size) {
        _Block_assign_default(*srcp, destp);
        destp++;
        srcp++;
        size -= sizeof(void *);
    }
}

/*
 * GC support callout functions - initially set to stub routines:
 */

static void *(*_Block_allocator)(const unsigned long, const bool isOne, const bool isObject) = _Block_alloc_default;
static void (*_Block_deallocator)(const void *) = (void (*)(const void *))free;
static void (*_Block_assign)(void *value, void **destptr) = _Block_assign_default;
static void (*_Block_setHasRefcount)(const void *ptr, const bool hasRefcount) = _Block_setHasRefcount_default;
static void (*_Block_retain_object)(const void *ptr) = _Block_retain_object_default;
static void (*_Block_release_object)(const void *ptr) = _Block_release_object_default;
static void (*_Block_assign_weak)(const void *dest, void *ptr) = _Block_assign_weak_default;
static void (*_Block_memmove)(void *dest, void *src, unsigned long size) = _Block_memmove_default;


/*
 * GC support SPI functions - called from ObjC runtime and CoreFoundation:
 */

/* Public SPI
 * Called from objc-auto to turn on GC.
 * version 3, 4 arg, but changed 1st arg
 */
void _Block_use_GC( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
                    void (*setHasRefcount)(const void *, const bool),
                    void (*gc_assign)(void *, void **),
                    void (*gc_assign_weak)(const void *, void *),
                    void (*gc_memmove)(void *, void *, unsigned long)) {

    isGC = true;
    _Block_allocator = alloc;
    _Block_deallocator = _Block_do_nothing;
    _Block_assign = gc_assign;
    _Block_copy_flag = BLOCK_IS_GC;
    _Block_copy_class = _NSConcreteAutoBlock;
    /* blocks with ctors & dtors need to have the dtor run from a class with a finalizer */
    _Block_copy_finalizing_class = _NSConcreteFinalizingBlock;
    _Block_setHasRefcount = setHasRefcount;
    _Byref_flag_initial_value = BLOCK_IS_GC;   // no refcount
    _Block_retain_object = _Block_do_nothing;
    _Block_release_object = _Block_do_nothing;
    _Block_assign_weak = gc_assign_weak;
    _Block_memmove = gc_memmove;
}

/* transitional */
void _Block_use_GC5( void *(*alloc)(const unsigned long, const bool isOne, const bool isObject),
                    void (*setHasRefcount)(const void *, const bool),
                    void (*gc_assign)(void *, void **),
                    void (*gc_assign_weak)(const void *, void *)) {
    /* until objc calls _Block_use_GC it will call us; supply a broken internal memmove implementation until then */
    _Block_use_GC(alloc, setHasRefcount, gc_assign, gc_assign_weak, _Block_memmove_gc_broken);
}

 
/*
 * Called from objc-auto to alternatively turn on retain/release.
 * Prior to this the only "object" support we can provide is for those
 * super special objects that live in libSystem, namely dispatch queues.
 * Blocks and Block_byrefs have their own special entry points.
 *
 */
void _Block_use_RR( void (*retain)(const void *),
                    void (*release)(const void *)) {
    _Block_retain_object = retain;
    _Block_release_object = release;
}

/*
 * Internal Support routines for copying:
 */

#if 0
#pragma mark Copy/Release support
#endif /* if 0 */

/* Copy, or bump refcount, of a block.  If really copying, call the copy helper if present. */
static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
    const bool wantsOne = (WANTS_ONE & flags) == WANTS_ONE;

    //printf("_Block_copy_internal(%p, %x)\n", arg, flags);	
    if (!arg) return NULL;
    
    
    // The following would be better done as a switch statement
    aBlock = (struct Block_layout *)arg;
    if (aBlock->flags & BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&aBlock->flags);
        return aBlock;
    }
    else if (aBlock->flags & BLOCK_IS_GC) {
        // GC refcounting is expensive so do most refcounting here.
        if (wantsOne && ((latching_incr_int(&aBlock->flags) & BLOCK_REFCOUNT_MASK) == 1)) {
            // Tell collector to hang on this - it will bump the GC refcount version
            _Block_setHasRefcount(aBlock, true);
        }
        return aBlock;
    }
    else if (aBlock->flags & BLOCK_IS_GLOBAL) {
        return aBlock;
    }

    // Its a stack block.  Make a copy.
    if (!isGC) {
        struct Block_layout *result = malloc(aBlock->descriptor->size);
        if (!result) return (void *)0;
        memmove(result, aBlock, aBlock->descriptor->size); // bitcopy first
        // reset refcount
        result->flags &= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
        result->flags |= BLOCK_NEEDS_FREE | 1;
        result->isa = _NSConcreteMallocBlock;
        if (result->flags & BLOCK_HAS_COPY_DISPOSE) {
            //printf("calling block copy helper %p(%p, %p)...\n", aBlock->descriptor->copy, result, aBlock);
            (*aBlock->descriptor->copy)(result, aBlock); // do fixup
        }
        return result;
    }
    else {
        // Under GC want allocation with refcount 1 so we ask for "true" if wantsOne
        // This allows the copy helper routines to make non-refcounted block copies under GC
        unsigned long int flags = aBlock->flags;
        bool hasCTOR = (flags & BLOCK_HAS_CTOR) != 0;
        struct Block_layout *result = _Block_allocator(aBlock->descriptor->size, wantsOne, hasCTOR);
        if (!result) return (void *)0;
        memmove(result, aBlock, aBlock->descriptor->size); // bitcopy first
        // reset refcount
        // if we copy a malloc block to a GC block then we need to clear NEEDS_FREE.
        flags &= ~(BLOCK_NEEDS_FREE|BLOCK_REFCOUNT_MASK);   // XXX not needed
        if (wantsOne)
            flags |= BLOCK_IS_GC | 1;
        else
            flags |= BLOCK_IS_GC;
        result->flags = flags;
        if (flags & BLOCK_HAS_COPY_DISPOSE) {
            //printf("calling block copy helper...\n");
            (*aBlock->descriptor->copy)(result, aBlock); // do fixup
        }
        if (hasCTOR) {
            result->isa = _NSConcreteFinalizingBlock;
        }
        else {
            result->isa = _NSConcreteAutoBlock;
        }
        return result;
    }
}


/*
 * Runtime entry points for maintaining the sharing knowledge of byref data blocks.
 *
 * A closure has been copied and its fixup routine is asking us to fix up the reference to the shared byref data
 * Closures that aren't copied must still work, so everyone always accesses variables after dereferencing the forwarding ptr.
 * We ask if the byref pointer that we know about has already been copied to the heap, and if so, increment it.
 * Otherwise we need to copy it and update the stack forwarding pointer
 * XXX We need to account for weak/nonretained read-write barriers.
 */

static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
        
    //printf("_Block_byref_assign_copy called, byref destp %p, src %p, flags %x\n", destp, src, flags);
    //printf("src dump: %s\n", _Block_byref_dump(src));
    if (src->forwarding->flags & BLOCK_IS_GC) {
        ;   // don't need to do any more work
    }
    else if ((src->forwarding->flags & BLOCK_REFCOUNT_MASK) == 0) {
        //printf("making copy\n");
        // src points to stack
        bool isWeak = ((flags & (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK)) == (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK));
        // if its weak ask for an object (only matters under GC)
        struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);
        copy->flags = src->flags | _Byref_flag_initial_value; // non-GC one for caller, one for stack
        copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
        src->forwarding = copy;  // patch stack to point to heap copy
        copy->size = src->size;
        if (isWeak) {
            copy->isa = &_NSConcreteWeakBlockVariable;  // mark isa field so it gets weak scanning
        }
        if (src->flags & BLOCK_HAS_COPY_DISPOSE) {
            // Trust copy helper to copy everything of interest
            // If more than one field shows up in a byref block this is wrong XXX
            copy->byref_keep = src->byref_keep;
            copy->byref_destroy = src->byref_destroy;
            (*src->byref_keep)(copy, src);
        }
        else {
            // just bits.  Blast 'em using _Block_memmove in case they're __strong
            _Block_memmove(
                (void *)&copy->byref_keep,
                (void *)&src->byref_keep,
                src->size - sizeof(struct Block_byref_header));
        }
    }
    // already copied to heap
    else if ((src->forwarding->flags & BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&src->forwarding->flags);
    }
    // assign byref data block pointer into new Block
    _Block_assign(src->forwarding, (void **)destp);
}

// Old compiler SPI
static void _Block_byref_release(const void *arg) {
    struct Block_byref *shared_struct = (struct Block_byref *)arg;
    int refcount;

    // dereference the forwarding pointer since the compiler isn't doing this anymore (ever?)
    shared_struct = shared_struct->forwarding;
    
    //printf("_Block_byref_release %p called, flags are %x\n", shared_struct, shared_struct->flags);
    // To support C++ destructors under GC we arrange for there to be a finalizer for this
    // by using an isa that directs the code to a finalizer that calls the byref_destroy method.
    if ((shared_struct->flags & BLOCK_NEEDS_FREE) == 0) {
        return; // stack or GC or global
    }
    refcount = shared_struct->flags & BLOCK_REFCOUNT_MASK;
    if (refcount <= 0) {
        printf("_Block_byref_release: Block byref data structure at %p underflowed\n", arg);
    }
    else if ((latching_decr_int(&shared_struct->flags) & BLOCK_REFCOUNT_MASK) == 0) {
        //printf("disposing of heap based byref block\n");
        if (shared_struct->flags & BLOCK_HAS_COPY_DISPOSE) {
            //printf("calling out to helper\n");
            (*shared_struct->byref_destroy)(shared_struct);
        }
        _Block_deallocator((struct Block_layout *)shared_struct);
    }
}


/*
 *
 * API supporting SPI
 * _Block_copy, _Block_release, and (old) _Block_destroy
 *
 */

#if 0
#pragma mark SPI/API
#endif /* if 0 */

void *_Block_copy(const void *arg) {
    return _Block_copy_internal(arg, WANTS_ONE);
}


// API entry point to release a copied Block
void _Block_release(void *arg) {
    struct Block_layout *aBlock = (struct Block_layout *)arg;
    int32_t newCount;
    if (!aBlock) return;
    newCount = latching_decr_int(&aBlock->flags) & BLOCK_REFCOUNT_MASK;
    if (newCount > 0) return;
    // Hit zero
    if (aBlock->flags & BLOCK_IS_GC) {
        // Tell GC we no longer have our own refcounts.  GC will decr its refcount
        // and unless someone has done a CFRetain or marked it uncollectable it will
        // now be subject to GC reclamation.
        _Block_setHasRefcount(aBlock, false);
    }
    else if (aBlock->flags & BLOCK_NEEDS_FREE) {
        if (aBlock->flags & BLOCK_HAS_COPY_DISPOSE)(*aBlock->descriptor->dispose)(aBlock);
        _Block_deallocator(aBlock);
    }
    else if (aBlock->flags & BLOCK_IS_GLOBAL) {
        ;
    }
    else {
        printf("Block_release called upon a stack Block: %p, ignored\n", (void *)aBlock);
    }
}



// Old Compiler SPI point to release a copied Block used by the compiler in dispose helpers
static void _Block_destroy(const void *arg) {
    struct Block_layout *aBlock;
    if (!arg) return;
    aBlock = (struct Block_layout *)arg;
    if (aBlock->flags & BLOCK_IS_GC) {
        // assert(aBlock->Block_flags & BLOCK_HAS_CTOR);
        return; // ignore, we are being called because of a DTOR
    }
    _Block_release(aBlock);
}



/*
 *
 * SPI used by other layers
 *
 */

// SPI, also internal.  Called from NSAutoBlock only under GC
void *_Block_copy_collectable(const void *aBlock) {
    return _Block_copy_internal(aBlock, 0);
}


// SPI
unsigned long int Block_size(void *arg) {
    return ((struct Block_layout *)arg)->descriptor->size;
}


#if 0
#pragma mark Compiler SPI entry points
#endif /* if 0 */

    
/*******************************************************

Entry points used by the compiler - the real API!


A Block can reference four different kinds of things that require help when the Block is copied to the heap.
1) C++ stack based objects
2) References to Objective-C objects
3) Other Blocks
4) __block variables

In these cases helper functions are synthesized by the compiler for use in Block_copy and Block_release, called the copy and dispose helpers.  The copy helper emits a call to the C++ const copy constructor for C++ stack based objects and for the rest calls into the runtime support function _Block_object_assign.  The dispose helper has a call to the C++ destructor for case 1 and a call into _Block_object_dispose for the rest.

The flags parameter of _Block_object_assign and _Block_object_dispose is set to
	* BLOCK_FIELD_IS_OBJECT (3), for the case of an Objective-C Object,
	* BLOCK_FIELD_IS_BLOCK (7), for the case of another Block, and
	* BLOCK_FIELD_IS_BYREF (8), for the case of a __block variable.
If the __block variable is marked weak the compiler also or's in BLOCK_FIELD_IS_WEAK (16).

So the Block copy/dispose helpers should only ever generate the four flag values of 3, 7, 8, and 24.

When  a __block variable is either a C++ object, an Objective-C object, or another Block then the compiler also generates copy/dispose helper functions.  Similarly to the Block copy helper, the "__block" copy helper (formerly and still a.k.a. "byref" copy helper) will do a C++ copy constructor (not a const one though!) and the dispose helper will do the destructor.  And similarly the helpers will call into the same two support functions with the same values for objects and Blocks with the additional BLOCK_BYREF_CALLER (128) bit of information supplied.

So the __block copy/dispose helpers will generate flag values of 3 or 7 for objects and Blocks respectively, with BLOCK_FIELD_IS_WEAK (16) or'ed as appropriate and always 128 or'd in, for the following set of possibilities:
	__block id                   128+3
        __weak block id              128+3+16
	__block (^Block)             128+7
	__weak __block (^Block)      128+7+16
        
The implementation of the two routines would be improved by switch statements enumerating the eight cases.

********************************************************/

/*
 * When Blocks or Block_byrefs hold objects then their copy routine helpers use this entry point
 * to do the assignment.
 */
void _Block_object_assign(void *destAddr, const void *object, const int flags) {
    //printf("_Block_object_assign(*%p, %p, %x)\n", destAddr, object, flags);
    if ((flags & BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {
        if ((flags & BLOCK_FIELD_IS_WEAK) == BLOCK_FIELD_IS_WEAK) {
            _Block_assign_weak(object, destAddr);
        }
        else {
            // do *not* retain or *copy* __block variables whatever they are
            _Block_assign((void *)object, destAddr);
        }
    }
    else if ((flags & BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
    // (this test must be before next one)
    else if ((flags & BLOCK_FIELD_IS_BLOCK) == BLOCK_FIELD_IS_BLOCK) {
        // copying a Block declared variable from the stack Block to the heap
        _Block_assign(_Block_copy_internal(object, flags), destAddr);
    }
    // (this test must be after previous one)
    else if ((flags & BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {
        //printf("retaining object at %p\n", object);
        _Block_retain_object(object);
        //printf("done retaining object at %p\n", object);
        _Block_assign((void *)object, destAddr);
    }
}

// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point
// to help dispose of the contents
// Used initially only for __attribute__((NSObject)) marked pointers.
void _Block_object_dispose(const void *object, const int flags) {
    //printf("_Block_object_dispose(%p, %x)\n", object, flags);
    if (flags & BLOCK_FIELD_IS_BYREF)  {
        // get rid of the __block data structure held in a Block
        _Block_byref_release(object);
    }
    else if ((flags & (BLOCK_FIELD_IS_BLOCK|BLOCK_BYREF_CALLER)) == BLOCK_FIELD_IS_BLOCK) {
        // get rid of a referenced Block held by this Block
        // (ignore __block Block variables, compiler doesn't need to call us)
        _Block_destroy(object);
    }
    else if ((flags & (BLOCK_FIELD_IS_WEAK|BLOCK_FIELD_IS_BLOCK|BLOCK_BYREF_CALLER)) == BLOCK_FIELD_IS_OBJECT) {
        // get rid of a referenced object held by this Block
        // (ignore __block object variables, compiler doesn't need to call us)
        _Block_release_object(object);
    }
}


/*
 * Debugging support:
 */
#if 0
#pragma mark Debugging
#endif /* if 0 */


const char *_Block_dump(const void *block) {
    struct Block_layout *closure = (struct Block_layout *)block;
    static char buffer[512];
    char *cp = buffer;
    if (closure == NULL) {
        sprintf(cp, "NULL passed to _Block_dump\n");
        return buffer;
    }
    if (! (closure->flags & BLOCK_HAS_DESCRIPTOR)) {
        printf("Block compiled by obsolete compiler, please recompile source for this Block\n");
        exit(1);
    }
    cp += sprintf(cp, "^%p (new layout) =\n", (void *)closure);
    if (closure->isa == NULL) {
        cp += sprintf(cp, "isa: NULL\n");
    }
    else if (closure->isa == _NSConcreteStackBlock) {
        cp += sprintf(cp, "isa: stack Block\n");
    }
    else if (closure->isa == _NSConcreteMallocBlock) {
        cp += sprintf(cp, "isa: malloc heap Block\n");
    }
    else if (closure->isa == _NSConcreteAutoBlock) {
        cp += sprintf(cp, "isa: GC heap Block\n");
    }
    else if (closure->isa == _NSConcreteGlobalBlock) {
        cp += sprintf(cp, "isa: global Block\n");
    }
    else if (closure->isa == _NSConcreteFinalizingBlock) {
        cp += sprintf(cp, "isa: finalizing Block\n");
    }
    else {
        cp += sprintf(cp, "isa?: %p\n", (void *)closure->isa);
    }
    cp += sprintf(cp, "flags:");
    if (closure->flags & BLOCK_HAS_DESCRIPTOR) {
        cp += sprintf(cp, " HASDESCRIPTOR");
    }
    if (closure->flags & BLOCK_NEEDS_FREE) {
        cp += sprintf(cp, " FREEME");
    }
    if (closure->flags & BLOCK_IS_GC) {
        cp += sprintf(cp, " ISGC");
    }
    if (closure->flags & BLOCK_HAS_COPY_DISPOSE) {
        cp += sprintf(cp, " HASHELP");
    }
    if (closure->flags & BLOCK_HAS_CTOR) {
        cp += sprintf(cp, " HASCTOR");
    }
    cp += sprintf(cp, "\nrefcount: %u\n", closure->flags & BLOCK_REFCOUNT_MASK);
    cp += sprintf(cp, "invoke: %p\n", (void *)(uintptr_t)closure->invoke);
    {
        struct Block_descriptor *dp = closure->descriptor;
        cp += sprintf(cp, "descriptor: %p\n", (void *)dp);
        cp += sprintf(cp, "descriptor->reserved: %lu\n", dp->reserved);
        cp += sprintf(cp, "descriptor->size: %lu\n", dp->size);

        if (closure->flags & BLOCK_HAS_COPY_DISPOSE) {
            cp += sprintf(cp, "descriptor->copy helper: %p\n", (void *)(uintptr_t)dp->copy);
            cp += sprintf(cp, "descriptor->dispose helper: %p\n", (void *)(uintptr_t)dp->dispose);
        }
    }
    return buffer;
}


const char *_Block_byref_dump(struct Block_byref *src) {
    static char buffer[256];
    char *cp = buffer;
    cp += sprintf(cp, "byref data block %p contents:\n", (void *)src);
    cp += sprintf(cp, "  forwarding: %p\n", (void *)src->forwarding);
    cp += sprintf(cp, "  flags: 0x%x\n", src->flags);
    cp += sprintf(cp, "  size: %d\n", src->size);
    if (src->flags & BLOCK_HAS_COPY_DISPOSE) {
        cp += sprintf(cp, "  copy helper: %p\n", (void *)(uintptr_t)src->byref_keep);
        cp += sprintf(cp, "  dispose helper: %p\n", (void *)(uintptr_t)src->byref_destroy);
    }
    return buffer;
}

                                                                                                                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/BlocksRuntime/runtime.lo       0100644 0000000 0000000 00000000412 13101126756 027233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # runtime.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/runtime.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/Makefile                       0100644 0000000 0000000 00000060635 13101126656 024107  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# ld64/src/3rd/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.





am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/cctools
pkgincludedir = $(includedir)/cctools
pkglibdir = $(libdir)/cctools
pkglibexecdir = $(libexecdir)/cctools
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = x86_64-unknown-linux-gnu
host_triplet = x86_64-unknown-linux-gnu
target_triplet = x86_64-apple-darwin15
subdir = ld64/src/3rd
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(noinst_HEADERS) \
	$(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
LTLIBRARIES = $(noinst_LTLIBRARIES)
libhelper_la_LIBADD =
am_libhelper_la_OBJECTS = libhelper_la-helper.lo \
	libhelper_la-qsort_r.lo libhelper_la-strlcat.lo \
	libhelper_la-strlcpy.lo libhelper_la-eprintf.lo \
	libhelper_la-md5.lo
libhelper_la_OBJECTS = $(am_libhelper_la_OBJECTS)
AM_V_lt = $(am__v_lt_$(V))
am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
am__v_lt_0 = --silent
am__v_lt_1 = 
libhelper_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libhelper_la_CFLAGS) \
	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_$(V))
am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_$(V))
am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(libhelper_la_SOURCES)
DIST_SOURCES = $(libhelper_la_SOURCES)
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
HEADERS = $(noinst_HEADERS)
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing aclocal-1.15
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 1
AR = ar
ASLIBEXECDIR = ${libexecdir}/as
AUTOCONF = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoconf
AUTOHEADER = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoheader
AUTOMAKE = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing automake-1.15
AWK = mawk
CC = clang
CCAS = clang
CCASFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include
CFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include -DDISABLE_CLANG_AS
CPP = clang -E
CPPFLAGS = 
CXX = clang++
CXXABI_LIB = -lsupc++
CXXCPP = clang++ -E
CXXFLAGS = -O3 -std=c++0x -isystem /usr/local/include -isystem /usr/pkg/include  -fblocks
CYGPATH_W = echo
DEFS = -DPACKAGE_NAME=\"cctools\" -DPACKAGE_TARNAME=\"cctools\" -DPACKAGE_VERSION=\"877.5\" -DPACKAGE_STRING=\"cctools\ 877.5\" -DPACKAGE_BUGREPORT=\"t.poechtrager@gmail.com\" -DPACKAGE_URL=\"\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DEMULATED_HOST_CPU_TYPE=16777223 -DEMULATED_HOST_CPU_SUBTYPE=3 -D__STDC_LIMIT_MACROS=1 -D__STDC_CONSTANT_MACROS=1 -DHAVE_EXECINFO_H=1
DLLTOOL = false
DL_LIB = -ldl
DSYMUTIL = 
DUMPBIN = 
ECHO_C = 
ECHO_N = -n
ECHO_T = 
EGREP = /bin/grep -E
ENDIAN_FLAG = -D__LITTLE_ENDIAN__=1
EXECINFO_LIB = 
EXEEXT = 
FGREP = /bin/grep -F
GREP = /bin/grep
HOST_AR = ar
HOST_RANLIB = ranlib
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
LD = /usr/bin/ld -m elf_x86_64
LDFLAGS =  -L/usr/local/lib -L/usr/pkg/lib 
LIBOBJS = 
LIBS = 
LIBTOOL = $(SHELL) $(top_builddir)/libtool
LIPO = 
LLVM_CONFIG = no
LLVM_INCLUDE_DIR = 
LLVM_LIB_DIR = 
LN_S = ln -s
LTLIBOBJS = 
LTO_DEF = 
LTO_LIB = 
LTO_RPATH = 
LT_SYS_LIBRARY_PATH = 
MAINT = #
MAKEINFO = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing makeinfo
MANIFEST_TOOL = :
MKDIR_P = /bin/mkdir -p
NM = /usr/bin/nm -B
NMEDIT = 
OBJC = clang
OBJCFLAGS = -O3
OBJCWARNINGS = -Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage
OBJDUMP = objdump
OBJEXT = o
OTOOL = 
OTOOL64 = 
PACKAGE = cctools
PACKAGE_BUGREPORT = t.poechtrager@gmail.com
PACKAGE_NAME = cctools
PACKAGE_STRING = cctools 877.5
PACKAGE_TARNAME = cctools
PACKAGE_URL = 
PACKAGE_VERSION = 877.5
PATH_SEPARATOR = :
PROGRAM_PREFIX = ${target_alias}-
PTHREAD_FLAGS = -pthread
RANLIB = ranlib
SED = /bin/sed
SET_MAKE = 
SHELL = /bin/bash
STRIP = strip
UUID_LIB = 
VERSION = 877.5
WARNINGS =  -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof -Wno-int-conversion -Wno-char-subscripts
XAR_LIB = 
abs_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd
abs_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd
abs_top_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
abs_top_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
ac_ct_AR = ar
ac_ct_CC = clang
ac_ct_CXX = 
ac_ct_DUMPBIN = 
ac_ct_OBJC = 
am__leading_dot = .
am__tar = tar --format=ustar -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = x86_64-unknown-linux-gnu
build_alias = 
build_cpu = x86_64
build_os = linux-gnu
build_vendor = unknown
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
host = x86_64-unknown-linux-gnu
host_alias = 
host_cpu = x86_64
host_os = linux-gnu
host_vendor = unknown
htmldir = ${docdir}
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
prefix = /osxcross/target
program_transform_name = s&^&x86_64-apple-darwin15-&
psdir = ${docdir}
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target = x86_64-apple-darwin15
target_alias = x86_64-apple-darwin15
target_cpu = x86_64
target_os = darwin15
target_vendor = apple
top_build_prefix = ../../../
top_builddir = ../../..
top_srcdir = ../../..
SUBDIRS = BlocksRuntime
noinst_LTLIBRARIES = libhelper.la
noinst_HEADERS = helper.h strlcat.h strlcpy.h qsort_r.h
libhelper_la_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign $(ENDIAN_FLAG) $(WARNINGS)
libhelper_la_SOURCES = \
	helper.c  \
	qsort_r.c  \
	strlcat.c  \
	strlcpy.c \
	eprintf.c \
	md5.c

all: all-recursive

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: # $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

clean-noinstLTLIBRARIES:
	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
	@list='$(noinst_LTLIBRARIES)'; \
	locs=`for p in $$list; do echo $$p; done | \
	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
	      sort -u`; \
	test -z "$$locs" || { \
	  echo rm -f $${locs}; \
	  rm -f $${locs}; \
	}

libhelper.la: $(libhelper_la_OBJECTS) $(libhelper_la_DEPENDENCIES) $(EXTRA_libhelper_la_DEPENDENCIES) 
	$(AM_V_CCLD)$(libhelper_la_LINK)  $(libhelper_la_OBJECTS) $(libhelper_la_LIBADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

libhelper_la-helper.lo: helper.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-helper.lo `test -f 'helper.c' || echo '$(srcdir)/'`helper.c

libhelper_la-qsort_r.lo: qsort_r.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-qsort_r.lo `test -f 'qsort_r.c' || echo '$(srcdir)/'`qsort_r.c

libhelper_la-strlcat.lo: strlcat.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-strlcat.lo `test -f 'strlcat.c' || echo '$(srcdir)/'`strlcat.c

libhelper_la-strlcpy.lo: strlcpy.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-strlcpy.lo `test -f 'strlcpy.c' || echo '$(srcdir)/'`strlcpy.c

libhelper_la-eprintf.lo: eprintf.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-eprintf.lo `test -f 'eprintf.c' || echo '$(srcdir)/'`eprintf.c

libhelper_la-md5.lo: md5.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-md5.lo `test -f 'md5.c' || echo '$(srcdir)/'`md5.c

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile $(LTLIBRARIES) $(HEADERS)
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
	mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool \
	clean-noinstLTLIBRARIES cscopelist-am ctags ctags-am distclean \
	distclean-compile distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/Makefile.am                    0100644 0001750 0001750 00000000476 12612724205 024532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = BlocksRuntime
noinst_LTLIBRARIES = libhelper.la
noinst_HEADERS = helper.h strlcat.h strlcpy.h qsort_r.h
libhelper_la_CFLAGS=-I$(top_srcdir)/include -I$(top_srcdir)/include/foreign $(ENDIAN_FLAG) $(WARNINGS)

libhelper_la_SOURCES =  \
	helper.c  \
	qsort_r.c  \
	strlcat.c  \
	strlcpy.c \
	eprintf.c \
	md5.c
                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/Makefile.in                    0100644 0001750 0001750 00000056155 12612724226 024553  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@


VPATH = @srcdir@
am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = ld64/src/3rd
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(noinst_HEADERS) \
	$(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
LTLIBRARIES = $(noinst_LTLIBRARIES)
libhelper_la_LIBADD =
am_libhelper_la_OBJECTS = libhelper_la-helper.lo \
	libhelper_la-qsort_r.lo libhelper_la-strlcat.lo \
	libhelper_la-strlcpy.lo libhelper_la-eprintf.lo \
	libhelper_la-md5.lo
libhelper_la_OBJECTS = $(am_libhelper_la_OBJECTS)
AM_V_lt = $(am__v_lt_@AM_V@)
am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
am__v_lt_0 = --silent
am__v_lt_1 = 
libhelper_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libhelper_la_CFLAGS) \
	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
DEFAULT_INCLUDES = -I.@am__isrc@
depcomp =
am__depfiles_maybe =
COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
	$(AM_CFLAGS) $(CFLAGS)
AM_V_CC = $(am__v_CC_@AM_V@)
am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
am__v_CC_0 = @echo "  CC      " $@;
am__v_CC_1 = 
CCLD = $(CC)
LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@
AM_V_CCLD = $(am__v_CCLD_@AM_V@)
am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
am__v_CCLD_0 = @echo "  CCLD    " $@;
am__v_CCLD_1 = 
SOURCES = $(libhelper_la_SOURCES)
DIST_SOURCES = $(libhelper_la_SOURCES)
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
HEADERS = $(noinst_HEADERS)
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
ASLIBEXECDIR = @ASLIBEXECDIR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASFLAGS = @CCASFLAGS@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CXX = @CXX@
CXXABI_LIB = @CXXABI_LIB@
CXXCPP = @CXXCPP@
CXXFLAGS = @CXXFLAGS@
CYGPATH_W = @CYGPATH_W@
DEFS = @DEFS@
DLLTOOL = @DLLTOOL@
DL_LIB = @DL_LIB@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
ENDIAN_FLAG = @ENDIAN_FLAG@
EXECINFO_LIB = @EXECINFO_LIB@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
GREP = @GREP@
HOST_AR = @HOST_AR@
HOST_RANLIB = @HOST_RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIPO = @LIPO@
LLVM_CONFIG = @LLVM_CONFIG@
LLVM_INCLUDE_DIR = @LLVM_INCLUDE_DIR@
LLVM_LIB_DIR = @LLVM_LIB_DIR@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
LTO_DEF = @LTO_DEF@
LTO_LIB = @LTO_LIB@
LTO_RPATH = @LTO_RPATH@
LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
OBJC = @OBJC@
OBJCFLAGS = @OBJCFLAGS@
OBJCWARNINGS = @OBJCWARNINGS@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
PROGRAM_PREFIX = @PROGRAM_PREFIX@
PTHREAD_FLAGS = @PTHREAD_FLAGS@
RANLIB = @RANLIB@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
STRIP = @STRIP@
UUID_LIB = @UUID_LIB@
VERSION = @VERSION@
WARNINGS = @WARNINGS@
XAR_LIB = @XAR_LIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_CXX = @ac_ct_CXX@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
ac_ct_OBJC = @ac_ct_OBJC@
am__leading_dot = @am__leading_dot@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
SUBDIRS = BlocksRuntime
noinst_LTLIBRARIES = libhelper.la
noinst_HEADERS = helper.h strlcat.h strlcpy.h qsort_r.h
libhelper_la_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign $(ENDIAN_FLAG) $(WARNINGS)
libhelper_la_SOURCES = \
	helper.c  \
	qsort_r.c  \
	strlcat.c  \
	strlcpy.c \
	eprintf.c \
	md5.c

all: all-recursive

.SUFFIXES:
.SUFFIXES: .c .lo .o .obj
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/src/3rd/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

clean-noinstLTLIBRARIES:
	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
	@list='$(noinst_LTLIBRARIES)'; \
	locs=`for p in $$list; do echo $$p; done | \
	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
	      sort -u`; \
	test -z "$$locs" || { \
	  echo rm -f $${locs}; \
	  rm -f $${locs}; \
	}

libhelper.la: $(libhelper_la_OBJECTS) $(libhelper_la_DEPENDENCIES) $(EXTRA_libhelper_la_DEPENDENCIES) 
	$(AM_V_CCLD)$(libhelper_la_LINK)  $(libhelper_la_OBJECTS) $(libhelper_la_LIBADD) $(LIBS)

mostlyclean-compile:
	-rm -f *.$(OBJEXT)

distclean-compile:
	-rm -f *.tab.c

.c.o:
	$(AM_V_CC)$(COMPILE) -c -o $@ $<

.c.obj:
	$(AM_V_CC)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`

.c.lo:
	$(AM_V_CC)$(LTCOMPILE) -c -o $@ $<

libhelper_la-helper.lo: helper.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-helper.lo `test -f 'helper.c' || echo '$(srcdir)/'`helper.c

libhelper_la-qsort_r.lo: qsort_r.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-qsort_r.lo `test -f 'qsort_r.c' || echo '$(srcdir)/'`qsort_r.c

libhelper_la-strlcat.lo: strlcat.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-strlcat.lo `test -f 'strlcat.c' || echo '$(srcdir)/'`strlcat.c

libhelper_la-strlcpy.lo: strlcpy.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-strlcpy.lo `test -f 'strlcpy.c' || echo '$(srcdir)/'`strlcpy.c

libhelper_la-eprintf.lo: eprintf.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-eprintf.lo `test -f 'eprintf.c' || echo '$(srcdir)/'`eprintf.c

libhelper_la-md5.lo: md5.c
	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libhelper_la_CFLAGS) $(CFLAGS) -c -o libhelper_la-md5.lo `test -f 'md5.c' || echo '$(srcdir)/'`md5.c

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile $(LTLIBRARIES) $(HEADERS)
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
	mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-compile distclean-generic \
	distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool \
	clean-noinstLTLIBRARIES cscopelist-am ctags ctags-am distclean \
	distclean-compile distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-compile mostlyclean-generic \
	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
	uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/eprintf.c                      0100644 0001750 0001750 00000001671 12612724205 024307  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* ===---------- eprintf.c - Implements __eprintf --------------------------===
 *
 *                     The LLVM Compiler Infrastructure
 *
 * This file is dual licensed under the MIT and the University of Illinois Open
 * Source Licenses. See LICENSE.TXT for details.
 *
 * ===----------------------------------------------------------------------===
 */

#ifdef __APPLE__

#include <stdio.h>
#include <stdlib.h>

/*
 * __eprintf() was used in an old version of <assert.h>.
 * It can eventually go away, but it is needed when linking
 * .o files built with the old <assert.h>.
 *
 * It should never be exported from a dylib, so it is marked
 * visibility hidden.
 */
__attribute__((visibility("hidden")))
void __eprintf(const char* format, const char* assertion_expression,
                const char* line, const char* file)
{
    fprintf(stderr, format, assertion_expression, line, file);
    fflush(stderr);
    abort();
}

#endif /* __APPLE__ */
                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/helper.c                       0100644 0001750 0001750 00000010740 12612724205 024114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        const char ldVersionString[] = "253.3\n";

#ifndef __APPLE__

#include <unistd.h> 
#include <mach/mach.h>
#include <mach/mach_error.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/attr.h>
#include <errno.h>
#include <inttypes.h>
#include <mach/mach_time.h>
#include <mach/mach_host.h>
#include <mach/host_info.h>
#include <sys/time.h>
#include <assert.h>

#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
#include <sys/sysctl.h>
#endif

#ifdef __OpenBSD__
#include <sys/types.h>
#include <sys/user.h>
#include <sys/stat.h>
#endif

#include "helper.h"

void __assert_rtn(const char *func, const char *file, int line, const char *msg)
{
#if defined(__FreeBSD__) || defined(__DragonFly__)
    __assert(msg, file, line, func);
#elif defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__)
    __assert(msg, line, file);
#else
    __assert(msg, file, line);
#endif /* __FreeBSD__ */
}

int _NSGetExecutablePath(char *epath, unsigned int *size)
{
#if defined(__FreeBSD__) || defined(__DragonFly__)
    int mib[4];
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_PATHNAME;
    mib[3] = -1;
    size_t cb = *size;
    if (sysctl(mib, 4, epath, &cb, NULL, 0) != 0)
        return -1;
    *size = cb;
    return 0;
#elif defined(__OpenBSD__)
    int mib[4];
    char **argv;
    size_t len;
    const char *comm;
    int ok = 0;
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC_ARGS;
    mib[2] = getpid();
    mib[3] = KERN_PROC_ARGV;
    if (sysctl(mib, 4, NULL, &len, NULL, 0) < 0)
        abort();
    if (!(argv = malloc(len)))
        abort();
    if (sysctl(mib, 4, argv, &len, NULL, 0) < 0)
        abort();
    comm = argv[0];
    if (*comm == '/' || *comm == '.')
    {
        char *rpath;
        if ((rpath = realpath(comm, NULL)))
        {
          strlcpy(epath, rpath, *size);
          free(rpath);
          ok = 1;
        }
    }
    else
    {
        char *sp;
        char *xpath = strdup(getenv("PATH"));
        char *path = strtok_r(xpath, ":", &sp);
        struct stat st;
        if (!xpath)
            abort();
        while (path)
        {
            snprintf(epath, *size, "%s/%s", path, comm);
            if (!stat(epath, &st) && (st.st_mode & S_IXUSR))
            {
                ok = 1;
                break;
            }
            path = strtok_r(NULL, ":", &sp);
        }
        free(xpath);
    }
    free(argv);
    if (ok)
    {
        *size = strlen(epath);
        return 0;
    }
    return -1;
#else
    int bufsize = *size;
    int ret_size;
    ret_size = readlink("/proc/self/exe", epath, bufsize-1);
    if (ret_size != -1)
    {
        *size = ret_size;
        epath[ret_size]=0;
        return 0;
    }
    else
        return -1;
#endif
}

int _dyld_find_unwind_sections(void *i, struct dyld_unwind_sections* sec)
{
    return 0;
}

mach_port_t mach_host_self(void)
{
    return 0;
}

kern_return_t host_statistics(host_t host_priv, host_flavor_t flavor,
                              host_info_t host_info_out,
                              mach_msg_type_number_t *host_info_outCnt)
{
    return ENOTSUP;
}

uint64_t mach_absolute_time(void)
{
    struct timeval tv;
    if (gettimeofday(&tv, NULL))
      return 0;
    return (tv.tv_sec*1000000ULL)+tv.tv_usec;
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
    info->numer = 1000;
    info->denom = 1;
    return 0;
}

#if defined(__ppc__) && !defined(__ppc64__)

/*
 * __sync_fetch_and_add_8 is missing on ppc 32-bit for some reason.
 */

#include <pthread.h>
static pthread_mutex_t lock;

__attribute__((constructor (101)))
static void init_mutex() { pthread_mutex_init(&lock, NULL); }

int64_t __clang_does_not_like_redeclaring_sync_fetch_and_add_8(
    volatile int64_t *ptr, int64_t value, ...)
{
    pthread_mutex_lock(&lock);
    *ptr = value;
    pthread_mutex_unlock(&lock);
    return *ptr;
}

asm
(
    ".global __sync_fetch_and_add_8\n"
    ".weak   __sync_fetch_and_add_8\n"
    ".type   __sync_fetch_and_add_8, @function\n"
    "__sync_fetch_and_add_8:\n"
    "b       __clang_does_not_like_redeclaring_sync_fetch_and_add_8\n"
    ".size   __sync_fetch_and_add_8, .-__sync_fetch_and_add_8"
);

#endif /* __ppc__ && !__ppc64__ */

int32_t OSAtomicAdd32(int32_t __theAmount, volatile int32_t *__theValue)
{
   return __sync_fetch_and_add(__theValue, __theAmount);
}

int64_t OSAtomicAdd64(int64_t __theAmount, volatile int64_t *__theValue)
{
   return __sync_fetch_and_add(__theValue, __theAmount);
}

#endif /* __APPLE__ */
                                osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/helper.h                       0100644 0001750 0001750 00000002444 13101126650 024115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _HELPER_H
#define _HELPER_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __has_extension
#define __has_extension(x) 0
#endif

#ifndef __has_include
#define __has_include(x) 0
#endif

#ifndef __has_include_next
#define __has_include_next(x) 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <mach/mach_time.h>
#include <mach/mach_host.h>
#include <mach/host_info.h>
#include <sys/time.h>

#ifndef __USE_GNU
#define __USE_GNU
#endif

#ifndef __APPLE__
typedef char uuid_string_t__[37];
#define uuid_string_t uuid_string_t__
#endif

#include <dlfcn.h>

struct dyld_unwind_sections
{
    const struct mach_header*      mh;
    const void*                    dwarf_section;
    intptr_t                       dwarf_section_length;
    const void*                    compact_unwind_section;
    intptr_t                       compact_unwind_section_length;
};

typedef Dl_info dl_info;

int _NSGetExecutablePath(char *path, unsigned int *size);

int _dyld_find_unwind_sections(void* i, struct dyld_unwind_sections* sec);

mach_port_t mach_host_self(void);

kern_return_t host_statistics ( host_t host_priv, host_flavor_t flavor, host_info_t host_info_out, mach_msg_type_number_t *host_info_outCnt);

uint64_t mach_absolute_time(void);

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/helper.h.orig                  0100644 0001750 0001750 00000002337 12612724205 025063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _HELPER_H
#define _HELPER_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __has_extension
#define __has_extension(x) 0
#endif

#ifndef __has_include
#define __has_include(x) 0
#endif

#ifndef __has_include_next
#define __has_include_next(x) 0
#endif

#include <mach/mach_time.h>
#include <mach/mach_host.h>
#include <mach/host_info.h>
#include <sys/time.h>

#ifndef __USE_GNU
#define __USE_GNU
#endif

#ifndef __APPLE__
typedef char uuid_string_t__[37];
#define uuid_string_t uuid_string_t__
#endif

#include <dlfcn.h>

struct dyld_unwind_sections
{
    const struct mach_header*      mh;
    const void*                    dwarf_section;
    intptr_t                       dwarf_section_length;
    const void*                    compact_unwind_section;
    intptr_t                       compact_unwind_section_length;
};

typedef Dl_info dl_info;

int _NSGetExecutablePath(char *path, unsigned int *size);

int _dyld_find_unwind_sections(void* i, struct dyld_unwind_sections* sec);

mach_port_t mach_host_self(void);

kern_return_t host_statistics ( host_t host_priv, host_flavor_t flavor, host_info_t host_info_out, mach_msg_type_number_t *host_info_outCnt);

uint64_t mach_absolute_time(void);

#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                                                                                                                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/include/                       0040755 0001750 0001750 00000000000 12612724205 024115  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/include/CommonCrypto/          0040755 0001750 0001750 00000000000 12612724205 026546  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        CommonDigest.h                                                                                      0100644 0001750 0001750 00000002025 12612724205 031224  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/include/CommonCrypto                                                                              #ifdef __APPLE__

#include_next <CommonCrypto/CommonDigest.h>

#else

#include "md5.h"
#include "assert.h"

#define CC_MD5_DIGEST_LENGTH 16
#define CC_MD5_CTX           md5_state_t

static int CC_MD5_Init(CC_MD5_CTX *c) {
    md5_init(c);
    return 1;
}

static int CC_MD5_Update(CC_MD5_CTX *c, const void *data,
                         unsigned long nbytes) {
    assert(nbytes <= 0x7fffffff && "would overflow");
    md5_append(c, (const unsigned char*)data, nbytes);
    return 1;
}

static int CC_MD5_Final(unsigned char digest[CC_MD5_DIGEST_LENGTH],
                        CC_MD5_CTX *c) {
    md5_finish(c, digest);
    return 1;
}

static unsigned char *CC_MD5(const void *data, unsigned long nbytes,
                             unsigned char *md) {
    static unsigned char smd[CC_MD5_DIGEST_LENGTH];

    if (!md)
        md = smd;

    assert(nbytes <= 0x7fffffff && "would overflow");

    CC_MD5_CTX c;
    CC_MD5_Init(&c);
    CC_MD5_Update(&c, data, nbytes);
    CC_MD5_Final(md, &c);

    return md;
}

#endif /* __APPLE__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/libhelper.la                   0100644 0000000 0000000 00000001564 13101126761 024724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # libhelper.la - a libtool library file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# The name that we can dlopen(3).
dlname=''

# Names of this library.
library_names=''

# The name of the static archive.
old_library='libhelper.a'

# Linker flags that cannot go in dependency_libs.
inherited_linker_flags=''

# Libraries that this one depends upon.
dependency_libs=' -L/usr/local/lib -L/usr/pkg/lib'

# Names of additional weak libraries provided by this library
weak_library_names=''

# Version information for libhelper.
current=
age=
revision=

# Is this an already installed library?
installed=no

# Should we warn about portability when linking against -modules?
shouldnotlink=no

# Files to dlopen/dlpreopen
dlopen=''
dlpreopen=''

# Directory that this library needs to be installed in:
libdir=''
                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/libhelper_la-eprintf.lo        0100644 0000000 0000000 00000000444 13101126760 027056  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # libhelper_la-eprintf.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/libhelper_la-eprintf.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/libhelper_la-helper.lo         0100644 0000000 0000000 00000000442 13101126757 026672  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # libhelper_la-helper.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/libhelper_la-helper.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/libhelper_la-md5.lo            0100644 0000000 0000000 00000000434 13101126761 026074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # libhelper_la-md5.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/libhelper_la-md5.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                                    osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/libhelper_la-qsort_r.lo        0100644 0000000 0000000 00000000444 13101126757 027106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # libhelper_la-qsort_r.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/libhelper_la-qsort_r.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/libhelper_la-strlcat.lo        0100644 0000000 0000000 00000000444 13101126760 027063  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # libhelper_la-strlcat.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/libhelper_la-strlcat.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/libhelper_la-strlcpy.lo        0100644 0000000 0000000 00000000444 13101126760 027107  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # libhelper_la-strlcpy.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/libhelper_la-strlcpy.o'

# Name of the non-PIC object
non_pic_object=none

                                                                                                                                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/md5.c                          0100644 0001750 0001750 00000025624 12612724205 023331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
  Copyright (C) 1999 Aladdin Enterprises.  All rights reserved.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  L. Peter Deutsch
  ghost@aladdin.com

 */
/*$Id: md5.c,v 1.1.1.4 2002/12/23 18:59:38 jlovell Exp $ */
/*
  Independent implementation of MD5 (RFC 1321).

  This code implements the MD5 Algorithm defined in RFC 1321.
  It is derived directly from the text of the RFC and not from the
  reference implementation.

  The original and principal author of md5.c is L. Peter Deutsch
  <ghost@aladdin.com>.  Other authors are noted in the change history
  that follows (in reverse chronological order):

  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).
  1999-05-03 lpd Original version.
 */

#ifndef __APPLE__

#include "md5.h"
#include "string.h"

#ifdef TEST
/*
 * Compile with -DTEST to create a self-contained executable test program.
 * The test program should print out the same values as given in section
 * A.5 of RFC 1321, reproduced below.
 */
main()
{
    static const char *const test[7] = {
	"", /*d41d8cd98f00b204e9800998ecf8427e*/
	"a", /*0cc175b9c0f1b6a831c399e269772661*/
	"abc", /*900150983cd24fb0d6963f7d28e17f72*/
	"message digest", /*f96b697d7cb7938d525a2f31aaf161d0*/
	"abcdefghijklmnopqrstuvwxyz", /*c3fcd3d76192e4007dfb496cca67e13b*/
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
				/*d174ab98d277d9f5a5611c2c9f419d9f*/
	"12345678901234567890123456789012345678901234567890123456789012345678901234567890" /*57edf4a22be3c955ac49da2e2107b67a*/
    };
    int i;

    for (i = 0; i < 7; ++i) {
	md5_state_t state;
	md5_byte_t digest[16];
	int di;

	md5_init(&state);
	md5_append(&state, (const md5_byte_t *)test[i], strlen(test[i]));
	md5_finish(&state, digest);
	printf("MD5 (\"%s\") = ", test[i]);
	for (di = 0; di < 16; ++di)
	    printf("%02x", digest[di]);
	printf("\n");
    }
    return 0;
}
#endif /* TEST */


/*
 * For reference, here is the program that computed the T values.
 */
#if 0
#include <math.h>
main()
{
    int i;
    for (i = 1; i <= 64; ++i) {
	unsigned long v = (unsigned long)(4294967296.0 * fabs(sin((double)i)));
	printf("#define T%d 0x%08lx\n", i, v);
    }
    return 0;
}
#endif
/*
 * End of T computation program.
 */
#define T1 0xd76aa478
#define T2 0xe8c7b756
#define T3 0x242070db
#define T4 0xc1bdceee
#define T5 0xf57c0faf
#define T6 0x4787c62a
#define T7 0xa8304613
#define T8 0xfd469501
#define T9 0x698098d8
#define T10 0x8b44f7af
#define T11 0xffff5bb1
#define T12 0x895cd7be
#define T13 0x6b901122
#define T14 0xfd987193
#define T15 0xa679438e
#define T16 0x49b40821
#define T17 0xf61e2562
#define T18 0xc040b340
#define T19 0x265e5a51
#define T20 0xe9b6c7aa
#define T21 0xd62f105d
#define T22 0x02441453
#define T23 0xd8a1e681
#define T24 0xe7d3fbc8
#define T25 0x21e1cde6
#define T26 0xc33707d6
#define T27 0xf4d50d87
#define T28 0x455a14ed
#define T29 0xa9e3e905
#define T30 0xfcefa3f8
#define T31 0x676f02d9
#define T32 0x8d2a4c8a
#define T33 0xfffa3942
#define T34 0x8771f681
#define T35 0x6d9d6122
#define T36 0xfde5380c
#define T37 0xa4beea44
#define T38 0x4bdecfa9
#define T39 0xf6bb4b60
#define T40 0xbebfbc70
#define T41 0x289b7ec6
#define T42 0xeaa127fa
#define T43 0xd4ef3085
#define T44 0x04881d05
#define T45 0xd9d4d039
#define T46 0xe6db99e5
#define T47 0x1fa27cf8
#define T48 0xc4ac5665
#define T49 0xf4292244
#define T50 0x432aff97
#define T51 0xab9423a7
#define T52 0xfc93a039
#define T53 0x655b59c3
#define T54 0x8f0ccc92
#define T55 0xffeff47d
#define T56 0x85845dd1
#define T57 0x6fa87e4f
#define T58 0xfe2ce6e0
#define T59 0xa3014314
#define T60 0x4e0811a1
#define T61 0xf7537e82
#define T62 0xbd3af235
#define T63 0x2ad7d2bb
#define T64 0xeb86d391

static void
md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)
{
    md5_word_t
	a = pms->abcd[0], b = pms->abcd[1],
	c = pms->abcd[2], d = pms->abcd[3];
    md5_word_t t;

#ifndef ARCH_IS_BIG_ENDIAN
# define ARCH_IS_BIG_ENDIAN 1	/* slower, default implementation */
#endif
#if ARCH_IS_BIG_ENDIAN

    /*
     * On big-endian machines, we must arrange the bytes in the right
     * order.  (This also works on machines of unknown byte order.)
     */
    md5_word_t X[16];
    const md5_byte_t *xp = data;
    int i;

    for (i = 0; i < 16; ++i, xp += 4)
	X[i] = xp[0] + (xp[1] << 8) + (xp[2] << 16) + (xp[3] << 24);

#else  /* !ARCH_IS_BIG_ENDIAN */

    /*
     * On little-endian machines, we can process properly aligned data
     * without copying it.
     */
    md5_word_t xbuf[16];
    const md5_word_t *X;

    if (!((data - (const md5_byte_t *)0) & 3)) {
	/* data are properly aligned */
	X = (const md5_word_t *)data;
    } else {
	/* not aligned */
	memcpy(xbuf, data, 64);
	X = xbuf;
    }
#endif

#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

    /* Round 1. */
    /* Let [abcd k s i] denote the operation
       a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
#define F(x, y, z) (((x) & (y)) | (~(x) & (z)))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + F(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
    /* Do the following 16 operations. */
    SET(a, b, c, d,  0,  7,  T1);
    SET(d, a, b, c,  1, 12,  T2);
    SET(c, d, a, b,  2, 17,  T3);
    SET(b, c, d, a,  3, 22,  T4);
    SET(a, b, c, d,  4,  7,  T5);
    SET(d, a, b, c,  5, 12,  T6);
    SET(c, d, a, b,  6, 17,  T7);
    SET(b, c, d, a,  7, 22,  T8);
    SET(a, b, c, d,  8,  7,  T9);
    SET(d, a, b, c,  9, 12, T10);
    SET(c, d, a, b, 10, 17, T11);
    SET(b, c, d, a, 11, 22, T12);
    SET(a, b, c, d, 12,  7, T13);
    SET(d, a, b, c, 13, 12, T14);
    SET(c, d, a, b, 14, 17, T15);
    SET(b, c, d, a, 15, 22, T16);
#undef SET

     /* Round 2. */
     /* Let [abcd k s i] denote the operation
          a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */
#define G(x, y, z) (((x) & (z)) | ((y) & ~(z)))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + G(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
     /* Do the following 16 operations. */
    SET(a, b, c, d,  1,  5, T17);
    SET(d, a, b, c,  6,  9, T18);
    SET(c, d, a, b, 11, 14, T19);
    SET(b, c, d, a,  0, 20, T20);
    SET(a, b, c, d,  5,  5, T21);
    SET(d, a, b, c, 10,  9, T22);
    SET(c, d, a, b, 15, 14, T23);
    SET(b, c, d, a,  4, 20, T24);
    SET(a, b, c, d,  9,  5, T25);
    SET(d, a, b, c, 14,  9, T26);
    SET(c, d, a, b,  3, 14, T27);
    SET(b, c, d, a,  8, 20, T28);
    SET(a, b, c, d, 13,  5, T29);
    SET(d, a, b, c,  2,  9, T30);
    SET(c, d, a, b,  7, 14, T31);
    SET(b, c, d, a, 12, 20, T32);
#undef SET

     /* Round 3. */
     /* Let [abcd k s t] denote the operation
          a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + H(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
     /* Do the following 16 operations. */
    SET(a, b, c, d,  5,  4, T33);
    SET(d, a, b, c,  8, 11, T34);
    SET(c, d, a, b, 11, 16, T35);
    SET(b, c, d, a, 14, 23, T36);
    SET(a, b, c, d,  1,  4, T37);
    SET(d, a, b, c,  4, 11, T38);
    SET(c, d, a, b,  7, 16, T39);
    SET(b, c, d, a, 10, 23, T40);
    SET(a, b, c, d, 13,  4, T41);
    SET(d, a, b, c,  0, 11, T42);
    SET(c, d, a, b,  3, 16, T43);
    SET(b, c, d, a,  6, 23, T44);
    SET(a, b, c, d,  9,  4, T45);
    SET(d, a, b, c, 12, 11, T46);
    SET(c, d, a, b, 15, 16, T47);
    SET(b, c, d, a,  2, 23, T48);
#undef SET

     /* Round 4. */
     /* Let [abcd k s t] denote the operation
          a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */
#define I(x, y, z) ((y) ^ ((x) | ~(z)))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + I(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
     /* Do the following 16 operations. */
    SET(a, b, c, d,  0,  6, T49);
    SET(d, a, b, c,  7, 10, T50);
    SET(c, d, a, b, 14, 15, T51);
    SET(b, c, d, a,  5, 21, T52);
    SET(a, b, c, d, 12,  6, T53);
    SET(d, a, b, c,  3, 10, T54);
    SET(c, d, a, b, 10, 15, T55);
    SET(b, c, d, a,  1, 21, T56);
    SET(a, b, c, d,  8,  6, T57);
    SET(d, a, b, c, 15, 10, T58);
    SET(c, d, a, b,  6, 15, T59);
    SET(b, c, d, a, 13, 21, T60);
    SET(a, b, c, d,  4,  6, T61);
    SET(d, a, b, c, 11, 10, T62);
    SET(c, d, a, b,  2, 15, T63);
    SET(b, c, d, a,  9, 21, T64);
#undef SET

     /* Then perform the following additions. (That is increment each
        of the four registers by the value it had before this block
        was started.) */
    pms->abcd[0] += a;
    pms->abcd[1] += b;
    pms->abcd[2] += c;
    pms->abcd[3] += d;
}

void
md5_init(md5_state_t *pms)
{
    pms->count[0] = pms->count[1] = 0;
    pms->abcd[0] = 0x67452301;
    pms->abcd[1] = 0xefcdab89;
    pms->abcd[2] = 0x98badcfe;
    pms->abcd[3] = 0x10325476;
}

void
md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)
{
    const md5_byte_t *p = data;
    int left = nbytes;
    int offset = (pms->count[0] >> 3) & 63;
    md5_word_t nbits = (md5_word_t)(nbytes << 3);

    if (nbytes <= 0)
	return;

    /* Update the message length. */
    pms->count[1] += nbytes >> 29;
    pms->count[0] += nbits;
    if (pms->count[0] < nbits)
	pms->count[1]++;

    /* Process an initial partial block. */
    if (offset) {
	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);

	memcpy(pms->buf + offset, p, copy);
	if (offset + copy < 64)
	    return;
	p += copy;
	left -= copy;
	md5_process(pms, pms->buf);
    }

    /* Process full blocks. */
    for (; left >= 64; p += 64, left -= 64)
	md5_process(pms, p);

    /* Process a final partial block. */
    if (left)
	memcpy(pms->buf, p, left);
}

void
md5_finish(md5_state_t *pms, md5_byte_t digest[16])
{
    static const md5_byte_t pad[64] = {
	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    md5_byte_t data[8];
    int i;

    /* Save the length before padding. */
    for (i = 0; i < 8; ++i)
	data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));
    /* Pad to 56 bytes mod 64. */
    md5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
    /* Append the length. */
    md5_append(pms, data, 8);
    for (i = 0; i < 16; ++i)
	digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
}

#endif /* ! __APPLE__ */
                                                                                                            osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/md5.h                          0100644 0001750 0001750 00000005745 12612724205 023340  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
  Copyright (C) 1999 Aladdin Enterprises.  All rights reserved.

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  L. Peter Deutsch
  ghost@aladdin.com

 */
/*$Id: md5.h,v 1.1.1.4 2002/12/23 18:59:38 jlovell Exp $ */
/*
  Independent implementation of MD5 (RFC 1321).

  This code implements the MD5 Algorithm defined in RFC 1321.
  It is derived directly from the text of the RFC and not from the
  reference implementation.

  The original and principal author of md5.h is L. Peter Deutsch
  <ghost@aladdin.com>.  Other authors are noted in the change history
  that follows (in reverse chronological order):

  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
	added conditionalization for C++ compilation from Martin
	Purschke <purschke@bnl.gov>.
  1999-05-03 lpd Original version.
 */

#ifndef md5_INCLUDED
#  define md5_INCLUDED

/*
 * This code has some adaptations for the Ghostscript environment, but it
 * will compile and run correctly in any environment with 8-bit chars and
 * 32-bit ints.  Specifically, it assumes that if the following are
 * defined, they have the same meaning as in Ghostscript: P1, P2, P3,
 * ARCH_IS_BIG_ENDIAN.
 */

typedef unsigned char md5_byte_t; /* 8-bit byte */
typedef unsigned int md5_word_t; /* 32-bit word */

/* Define the state of the MD5 Algorithm. */
typedef struct md5_state_s {
    md5_word_t count[2];	/* message length in bits, lsw first */
    md5_word_t abcd[4];		/* digest buffer */
    md5_byte_t buf[64];		/* accumulate block */
} md5_state_t;

#ifdef __cplusplus
extern "C" 
{
#endif

/* Initialize the algorithm. */
#ifdef P1
void md5_init(P1(md5_state_t *pms));
#else
void md5_init(md5_state_t *pms);
#endif

/* Append a string to the message. */
#ifdef P3
void md5_append(P3(md5_state_t *pms, const md5_byte_t *data, int nbytes));
#else
void md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes);
#endif

/* Finish the message and return the digest. */
#ifdef P2
void md5_finish(P2(md5_state_t *pms, md5_byte_t digest[16]));
#else
void md5_finish(md5_state_t *pms, md5_byte_t digest[16]);
#endif

#ifdef __cplusplus
}  /* end extern "C" */
#endif

#endif /* md5_INCLUDED */

                           osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/qsort_r.c                      0100644 0001750 0001750 00000030161 12612724205 024325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*-
 * Copyright (c) 1992, 1993
 *  The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define I_AM_QSORT_R
#define qsort_r qsort_r_local

#include <sys/cdefs.h>

#include <errno.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#ifndef __FreeBSD__
/* flsl.c */
int
flsl(long mask)
{
    int bit;

    if (mask == 0)
        return (0);
    for (bit = 1; mask != 1; bit++)
        mask = (unsigned long)mask >> 1;
    return (bit);
}

/* fsl.c */
int
fls(int mask)
{
    int bit;
    if (mask == 0)
        return (0);
    for (bit = 1; mask != 1; bit++)
        mask = (unsigned int)mask >> 1;
    return (bit);
}
#endif

/*
 * Swap two areas of size number of bytes.  Although qsort(3) permits random
 * blocks of memory to be sorted, sorting pointers is almost certainly the
 * common case (and, were it not, could easily be made so).  Regardless, it
 * isn't worth optimizing; the SWAP's get sped up by the cache, and pointer
 * arithmetic gets lost in the time required for comparison function calls.
 */
#define SWAP(a, b, count, size, tmp) { \
    count = size; \
    do { \
        tmp = *a; \
        *a++ = *b; \
        *b++ = tmp; \
    } while (--count); \
}

/* Copy one block of size size to another. */
#define COPY(a, b, count, size, tmp1, tmp2) { \
    count = size; \
    tmp1 = a; \
    tmp2 = b; \
    do { \
        *tmp1++ = *tmp2++; \
    } while (--count); \
}

/*
 * Build the list into a heap, where a heap is defined such that for
 * the records K1 ... KN, Kj/2 >= Kj for 1 <= j/2 <= j <= N.
 *
 * There two cases.  If j == nmemb, select largest of Ki and Kj.  If
 * j < nmemb, select largest of Ki, Kj and Kj+1.
 */
#define CREATE(initval, nmemb, par_i, child_i, par, child, size, count, tmp) { \
    for (par_i = initval; (child_i = par_i * 2) <= nmemb; \
        par_i = child_i) { \
        child = base + child_i * size; \
        if (child_i < nmemb && compar(thunk, child, child + size) < 0) { \
            child += size; \
            ++child_i; \
        } \
        par = base + par_i * size; \
        if (compar(thunk, child, par) <= 0) \
            break; \
        SWAP(par, child, count, size, tmp); \
    } \
}

/*
 * Select the top of the heap and 'heapify'.  Since by far the most expensive
 * action is the call to the compar function, a considerable optimization
 * in the average case can be achieved due to the fact that k, the displaced
 * elememt, is ususally quite small, so it would be preferable to first
 * heapify, always maintaining the invariant that the larger child is copied
 * over its parent's record.
 *
 * Then, starting from the *bottom* of the heap, finding k's correct place,
 * again maintianing the invariant.  As a result of the invariant no element
 * is 'lost' when k is assigned its correct place in the heap.
 *
 * The time savings from this optimization are on the order of 15-20% for the
 * average case. See Knuth, Vol. 3, page 158, problem 18.
 *
 * XXX Don't break the #define SELECT line, below.  Reiser cpp gets upset.
 */
#define SELECT(par_i, child_i, nmemb, par, child, size, k, count, tmp1, tmp2) { \
    for (par_i = 1; (child_i = par_i * 2) <= nmemb; par_i = child_i) { \
        child = base + child_i * size; \
        if (child_i < nmemb && compar(thunk, child, child + size) < 0) { \
            child += size; \
            ++child_i; \
        } \
        par = base + par_i * size; \
        COPY(par, child, count, size, tmp1, tmp2); \
    } \
    for (;;) { \
        child_i = par_i; \
        par_i = child_i / 2; \
        child = base + child_i * size; \
        par = base + par_i * size; \
        if (child_i == 1 || compar(thunk, k, par) < 0) { \
            COPY(child, k, count, size, tmp1, tmp2); \
            break; \
        } \
        COPY(child, par, count, size, tmp1, tmp2); \
    } \
}

/*
 * Heapsort -- Knuth, Vol. 3, page 145.  Runs in O (N lg N), both average
 * and worst.  While heapsort is faster than the worst case of quicksort,
 * the BSD quicksort does median selection so that the chance of finding
 * a data set that will trigger the worst case is nonexistent.  Heapsort's
 * only advantage over quicksort is that it requires little additional memory.
 */
__private_extern__ int
__heapsort_r(
    void *vbase,
    size_t nmemb,
    size_t size,
    void *thunk,
    int (*compar)(void *, const void *, const void *)
)
{
    size_t cnt, i, j, l;
    char tmp, *tmp1, *tmp2;
    char *base, *k, *p, *t;

    if (nmemb <= 1)
        return (0);

    if (!size) {
        errno = EINVAL;
        return (-1);
    }

    if ((k = malloc(size)) == NULL)
        return (-1);

    /*
     * Items are numbered from 1 to nmemb, so offset from size bytes
     * below the starting address.
     */
    base = (char *)vbase - size;

    for (l = nmemb / 2 + 1; --l;)
        CREATE(l, nmemb, i, j, t, p, size, cnt, tmp);

    /*
     * For each element of the heap, save the largest element into its
     * final slot, save the displaced element (k), then recreate the
     * heap.
     */
    while (nmemb > 1) {
        COPY(k, base + nmemb * size, cnt, size, tmp1, tmp2);
        COPY(base + nmemb * size, base + size, cnt, size, tmp1, tmp2);
        --nmemb;
        SELECT(i, j, nmemb, t, p, size, k, cnt, tmp1, tmp2);
    }
    free(k);
    return (0);
}

/* qsort.c */

#include <string.h>

#ifdef I_AM_QSORT_R
typedef int      cmp_t(void *, const void *, const void *);
#else
typedef int      cmp_t(const void *, const void *);
#endif
#ifdef I_AM_QSORT_B
static inline char  *med3(char *, char *, char *, cmp_t ^, void *) __attribute__((always_inline));
#else
static inline char  *med3(char *, char *, char *, cmp_t *, void *) __attribute__((always_inline));
#endif
static inline void   swapfunc(char *, char *, int, int) __attribute__((always_inline));

#define min(a, b)   (a) < (b) ? a : b

/*
 * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
 */
#define swapcode(TYPE, parmi, parmj, n) {       \
    long i = (n) / sizeof (TYPE);           \
    TYPE *pi = (TYPE *) (parmi);        \
    TYPE *pj = (TYPE *) (parmj);        \
    do {                        \
        TYPE    t = *pi;        \
        *pi++ = *pj;                \
        *pj++ = t;              \
        } while (--i > 0);              \
}

#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
    es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;

static inline void
swapfunc(a, b, n, swaptype)
    char *a, *b;
    int n, swaptype;
{
    if(swaptype <= 1)
        swapcode(long, a, b, n)
    else
        swapcode(char, a, b, n)
}

#define swap(a, b)                  \
    if (swaptype == 0) {                \
        long t = *(long *)(a);          \
        *(long *)(a) = *(long *)(b);        \
        *(long *)(b) = t;           \
    } else                      \
        swapfunc(a, b, es, swaptype)

#define vecswap(a, b, n)    if ((n) > 0) swapfunc(a, b, n, swaptype)

#ifdef I_AM_QSORT_R
#define CMP(t, x, y) (cmp((t), (x), (y)))
#else
#define CMP(t, x, y) (cmp((x), (y)))
#endif

static inline char *
med3(char *a, char *b, char *c,
#ifdef I_AM_QSORT_B
cmp_t ^cmp,
#else
cmp_t *cmp,
#endif
void *thunk
#ifndef I_AM_QSORT_R
__unused
#endif
)
{
    return CMP(thunk, a, b) < 0 ?
           (CMP(thunk, b, c) < 0 ? b : (CMP(thunk, a, c) < 0 ? c : a ))
              :(CMP(thunk, b, c) > 0 ? b : (CMP(thunk, a, c) < 0 ? a : c ));
}

#ifdef __LP64__
#define DEPTH(x)    (2 * (flsl((long)(x)) - 1))
#else /* !__LP64__ */
#define DEPTH(x)    (2 * (fls((int)(x)) - 1))
#endif /* __LP64__ */

#ifdef I_AM_QSORT_R
int __heapsort_r(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *));
#endif

static void
_qsort(void *a, size_t n, size_t es,
#ifdef I_AM_QSORT_R
void *thunk,
#else
#define thunk   NULL
#endif
#ifdef I_AM_QSORT_B
cmp_t ^cmp,
#else
cmp_t *cmp,
#endif
int depth_limit)
{
    char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
    size_t d, r;
    int cmp_result;
    int swaptype, swap_cnt;

loop:
    if (depth_limit-- <= 0) {
#ifdef I_AM_QSORT_B
        heapsort_b(a, n, es, cmp);
#elif defined(I_AM_QSORT_R)
        __heapsort_r(a, n, es, thunk, cmp);
#else
        heapsort(a, n, es, cmp);
#endif
        return;
    }
    SWAPINIT(a, es);
    swap_cnt = 0;
    if (n < 7) {
        for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
            for (pl = pm; 
                 pl > (char *)a && CMP(thunk, pl - es, pl) > 0;
                 pl -= es)
                swap(pl, pl - es);
        return;
    }
    pm = (char *)a + (n / 2) * es;
    if (n > 7) {
        pl = a;
        pn = (char *)a + (n - 1) * es;
        if (n > 40) {
            d = (n / 8) * es;
            pl = med3(pl, pl + d, pl + 2 * d, cmp, thunk);
            pm = med3(pm - d, pm, pm + d, cmp, thunk);
            pn = med3(pn - 2 * d, pn - d, pn, cmp, thunk);
        }
        pm = med3(pl, pm, pn, cmp, thunk);
    }
    swap(a, pm);
    pa = pb = (char *)a + es;

    pc = pd = (char *)a + (n - 1) * es;
    for (;;) {
        while (pb <= pc && (cmp_result = CMP(thunk, pb, a)) <= 0) {
            if (cmp_result == 0) {
                swap_cnt = 1;
                swap(pa, pb);
                pa += es;
            }
            pb += es;
        }
        while (pb <= pc && (cmp_result = CMP(thunk, pc, a)) >= 0) {
            if (cmp_result == 0) {
                swap_cnt = 1;
                swap(pc, pd);
                pd -= es;
            }
            pc -= es;
        }
        if (pb > pc)
            break;
        swap(pb, pc);
        swap_cnt = 1;
        pb += es;
        pc -= es;
    }

    pn = (char *)a + n * es;
    r = min(pa - (char *)a, pb - pa);
    vecswap(a, pb - r, r);
    r = min(pd - pc, pn - pd - es);
    vecswap(pb, pn - r, r);

    if (swap_cnt == 0) {  /* Switch to insertion sort */
        r = 1 + n / 4; /* n >= 7, so r >= 2 */
        for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
            for (pl = pm; 
                 pl > (char *)a && CMP(thunk, pl - es, pl) > 0;
                 pl -= es) {
                swap(pl, pl - es);
                if (++swap_cnt > r) goto nevermind;
            }
        return;
    }

nevermind:
    if ((r = pb - pa) > es)
#ifdef I_AM_QSORT_R
        _qsort(a, r / es, es, thunk, cmp, depth_limit);
#else
        _qsort(a, r / es, es, cmp, depth_limit);
#endif
    if ((r = pd - pc) > es) {
        /* Iterate rather than recurse to save stack space */
        a = pn - r;
        n = r / es;
        goto loop;
    }
/*      qsort(pn - r, r / es, es, cmp);*/
}

void
#ifdef I_AM_QSORT_R
qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
#elif defined(I_AM_QSORT_B)
qsort_b(void *a, size_t n, size_t es, cmp_t ^cmp)
#else
qsort(void *a, size_t n, size_t es, cmp_t *cmp)
#endif
{
    _qsort(a, n, es,
#ifdef I_AM_QSORT_R
        thunk,
#endif
        cmp, DEPTH(n));
}


                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/qsort_r.h                      0100644 0001750 0001750 00000000476 12612724205 024340  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _QSORT_R_H
#define _QSORT_R_H
#include <sys/types.h>

#if defined(__cplusplus)
extern "C" {
#endif
void qsort_r_local(void *base, size_t nmemb, size_t size, void *thunk, int (*compar)(void *, const void *, const void *));
#undef qsort_r
#define qsort_r qsort_r_local
#if defined(__cplusplus)
};
#endif

#endif
                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/strlcat.c                      0100644 0001750 0001750 00000003111 12612724205 024303  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2011 Apple, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __APPLE__

/*
 * Otherwise string.h may hide strnlen().
 * https://github.com/tpoechtrager/cctools-port/pull/8
 */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <string.h>

size_t
strlcat(char * restrict dst, const char * restrict src, size_t maxlen) {
    const size_t srclen = strlen(src);
    const size_t dstlen = strnlen(dst, maxlen);
    if (dstlen == maxlen) return maxlen+srclen;
    if (srclen < maxlen-dstlen) {
        memcpy(dst+dstlen, src, srclen+1);
    } else {
        memcpy(dst+dstlen, src, maxlen-dstlen-1);
        dst[maxlen-1] = '\0';
    }
    return dstlen + srclen;
}

#endif /* ! __APPLE__ */                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/strlcat.h                      0100644 0001750 0001750 00000000352 12612724205 024314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef __APPLE__

#ifndef STRLCAT_H
#define STRLCAT_H

#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

size_t strlcat(char *dst, const char *src, size_t siz);

#ifdef __cplusplus
}
#endif

#endif

#endif /* ! __APPLE__ */                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/strlcpy.c                      0100644 0001750 0001750 00000002476 12612724205 024344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2011 Apple, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __APPLE__

#include <string.h>

size_t
strlcpy(char * restrict dst, const char * restrict src, size_t maxlen) {
    const size_t srclen = strlen(src);
    if (srclen < maxlen) {
        memcpy(dst, src, srclen+1);
    } else if (maxlen != 0) {
        memcpy(dst, src, maxlen-1);
        dst[maxlen-1] = '\0';
    }
    return srclen;
}

#endif /* ! __APPLE__ */
                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/3rd/strlcpy.h                      0100644 0001750 0001750 00000000352 12612724205 024340  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef __APPLE__

#ifndef STRLCPY_H
#define STRLCPY_H

#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

size_t strlcpy(char *dst, const char *src, size_t siz);

#ifdef __cplusplus
}
#endif

#endif

#endif /* ! __APPLE__ */                                                                                                                                                                                                                                                                                      osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/Makefile                           0100644 0000000 0000000 00000047711 13101126656 023417  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# ld64/src/Makefile.  Generated from Makefile.in by configure.

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.



am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/cctools
pkgincludedir = $(includedir)/cctools
pkglibdir = $(libdir)/cctools
pkglibexecdir = $(libexecdir)/cctools
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = x86_64-unknown-linux-gnu
host_triplet = x86_64-unknown-linux-gnu
target_triplet = x86_64-apple-darwin15
subdir = ld64/src
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_$(V))
am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_$(V))
am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_$(V))
am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
am__v_at_0 = @
am__v_at_1 = 
depcomp =
am__depfiles_maybe =
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing aclocal-1.15
AMTAR = $${TAR-tar}
AM_DEFAULT_VERBOSITY = 1
AR = ar
ASLIBEXECDIR = ${libexecdir}/as
AUTOCONF = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoconf
AUTOHEADER = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing autoheader
AUTOMAKE = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing automake-1.15
AWK = mawk
CC = clang
CCAS = clang
CCASFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include
CFLAGS = -O3 -isystem /usr/local/include -isystem /usr/pkg/include -DDISABLE_CLANG_AS
CPP = clang -E
CPPFLAGS = 
CXX = clang++
CXXABI_LIB = -lsupc++
CXXCPP = clang++ -E
CXXFLAGS = -O3 -std=c++0x -isystem /usr/local/include -isystem /usr/pkg/include  -fblocks
CYGPATH_W = echo
DEFS = -DPACKAGE_NAME=\"cctools\" -DPACKAGE_TARNAME=\"cctools\" -DPACKAGE_VERSION=\"877.5\" -DPACKAGE_STRING=\"cctools\ 877.5\" -DPACKAGE_BUGREPORT=\"t.poechtrager@gmail.com\" -DPACKAGE_URL=\"\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DLT_OBJDIR=\".libs/\" -DEMULATED_HOST_CPU_TYPE=16777223 -DEMULATED_HOST_CPU_SUBTYPE=3 -D__STDC_LIMIT_MACROS=1 -D__STDC_CONSTANT_MACROS=1 -DHAVE_EXECINFO_H=1
DLLTOOL = false
DL_LIB = -ldl
DSYMUTIL = 
DUMPBIN = 
ECHO_C = 
ECHO_N = -n
ECHO_T = 
EGREP = /bin/grep -E
ENDIAN_FLAG = -D__LITTLE_ENDIAN__=1
EXECINFO_LIB = 
EXEEXT = 
FGREP = /bin/grep -F
GREP = /bin/grep
HOST_AR = ar
HOST_RANLIB = ranlib
INSTALL = /usr/bin/install -c
INSTALL_DATA = ${INSTALL} -m 644
INSTALL_PROGRAM = ${INSTALL}
INSTALL_SCRIPT = ${INSTALL}
INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
LD = /usr/bin/ld -m elf_x86_64
LDFLAGS =  -L/usr/local/lib -L/usr/pkg/lib 
LIBOBJS = 
LIBS = 
LIBTOOL = $(SHELL) $(top_builddir)/libtool
LIPO = 
LLVM_CONFIG = no
LLVM_INCLUDE_DIR = 
LLVM_LIB_DIR = 
LN_S = ln -s
LTLIBOBJS = 
LTO_DEF = 
LTO_LIB = 
LTO_RPATH = 
LT_SYS_LIBRARY_PATH = 
MAINT = #
MAKEINFO = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/missing makeinfo
MANIFEST_TOOL = :
MKDIR_P = /bin/mkdir -p
NM = /usr/bin/nm -B
NMEDIT = 
OBJC = clang
OBJCFLAGS = -O3
OBJCWARNINGS = -Wall -Wno-objc-root-class -Wno-deprecated-objc-isa-usage
OBJDUMP = objdump
OBJEXT = o
OTOOL = 
OTOOL64 = 
PACKAGE = cctools
PACKAGE_BUGREPORT = t.poechtrager@gmail.com
PACKAGE_NAME = cctools
PACKAGE_STRING = cctools 877.5
PACKAGE_TARNAME = cctools
PACKAGE_URL = 
PACKAGE_VERSION = 877.5
PATH_SEPARATOR = :
PROGRAM_PREFIX = ${target_alias}-
PTHREAD_FLAGS = -pthread
RANLIB = ranlib
SED = /bin/sed
SET_MAKE = 
SHELL = /bin/bash
STRIP = strip
UUID_LIB = 
VERSION = 877.5
WARNINGS =  -Wall -Wno-long-long -Wno-import -Wno-format -Wno-deprecated -Wno-unused-variable -Wno-unused-private-field -Wno-unused-function -Wno-invalid-offsetof -Wno-int-conversion -Wno-char-subscripts
XAR_LIB = 
abs_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src
abs_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src
abs_top_builddir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
abs_top_srcdir = /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools
ac_ct_AR = ar
ac_ct_CC = clang
ac_ct_CXX = 
ac_ct_DUMPBIN = 
ac_ct_OBJC = 
am__leading_dot = .
am__tar = tar --format=ustar -chf - "$$tardir"
am__untar = tar -xf -
bindir = ${exec_prefix}/bin
build = x86_64-unknown-linux-gnu
build_alias = 
build_cpu = x86_64
build_os = linux-gnu
build_vendor = unknown
builddir = .
datadir = ${datarootdir}
datarootdir = ${prefix}/share
docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
dvidir = ${docdir}
exec_prefix = ${prefix}
host = x86_64-unknown-linux-gnu
host_alias = 
host_cpu = x86_64
host_os = linux-gnu
host_vendor = unknown
htmldir = ${docdir}
includedir = ${prefix}/include
infodir = ${datarootdir}/info
install_sh = ${SHELL} /osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/install-sh
libdir = ${exec_prefix}/lib
libexecdir = ${exec_prefix}/libexec
localedir = ${datarootdir}/locale
localstatedir = ${prefix}/var
mandir = ${datarootdir}/man
mkdir_p = $(MKDIR_P)
oldincludedir = /usr/include
pdfdir = ${docdir}
prefix = /osxcross/target
program_transform_name = s&^&x86_64-apple-darwin15-&
psdir = ${docdir}
sbindir = ${exec_prefix}/sbin
sharedstatedir = ${prefix}/com
srcdir = .
sysconfdir = ${prefix}/etc
target = x86_64-apple-darwin15
target_alias = x86_64-apple-darwin15
target_cpu = x86_64
target_os = darwin15
target_vendor = apple
top_build_prefix = ../../
top_builddir = ../..
top_srcdir = ../..
SUBDIRS = 3rd ld other 
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: # $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/src/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/src/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: # $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): # $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/Makefile.am                        0100644 0001750 0001750 00000000030 12612724205 024024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        SUBDIRS = 3rd ld other 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/Makefile.in                        0100644 0001750 0001750 00000045271 12612724226 024060  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Makefile.in generated by automake 1.15 from Makefile.am.
# @configure_input@

# Copyright (C) 1994-2014 Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.

@SET_MAKE@
VPATH = @srcdir@
am__is_gnu_make = { \
  if test -z '$(MAKELEVEL)'; then \
    false; \
  elif test -n '$(MAKE_HOST)'; then \
    true; \
  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
    true; \
  else \
    false; \
  fi; \
}
am__make_running_with_option = \
  case $${target_option-} in \
      ?) ;; \
      *) echo "am__make_running_with_option: internal error: invalid" \
              "target option '$${target_option-}' specified" >&2; \
         exit 1;; \
  esac; \
  has_opt=no; \
  sane_makeflags=$$MAKEFLAGS; \
  if $(am__is_gnu_make); then \
    sane_makeflags=$$MFLAGS; \
  else \
    case $$MAKEFLAGS in \
      *\\[\ \	]*) \
        bs=\\; \
        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
    esac; \
  fi; \
  skip_next=no; \
  strip_trailopt () \
  { \
    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
  }; \
  for flg in $$sane_makeflags; do \
    test $$skip_next = yes && { skip_next=no; continue; }; \
    case $$flg in \
      *=*|--*) continue;; \
        -*I) strip_trailopt 'I'; skip_next=yes;; \
      -*I?*) strip_trailopt 'I';; \
        -*O) strip_trailopt 'O'; skip_next=yes;; \
      -*O?*) strip_trailopt 'O';; \
        -*l) strip_trailopt 'l'; skip_next=yes;; \
      -*l?*) strip_trailopt 'l';; \
      -[dEDm]) skip_next=yes;; \
      -[JT]) skip_next=yes;; \
    esac; \
    case $$flg in \
      *$$target_option*) has_opt=yes; break;; \
    esac; \
  done; \
  test $$has_opt = yes
am__make_dryrun = (target_option=n; $(am__make_running_with_option))
am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
pkgdatadir = $(datadir)/@PACKAGE@
pkgincludedir = $(includedir)/@PACKAGE@
pkglibdir = $(libdir)/@PACKAGE@
pkglibexecdir = $(libexecdir)/@PACKAGE@
am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :
build_triplet = @build@
host_triplet = @host@
target_triplet = @target@
subdir = ld64/src
ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
	$(top_srcdir)/m4/llvm.m4 $(top_srcdir)/m4/ltoptions.m4 \
	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/configure.ac
am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
	$(ACLOCAL_M4)
DIST_COMMON = $(srcdir)/Makefile.am $(am__DIST_COMMON)
mkinstalldirs = $(install_sh) -d
CONFIG_CLEAN_FILES =
CONFIG_CLEAN_VPATH_FILES =
AM_V_P = $(am__v_P_@AM_V@)
am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
am__v_P_0 = false
am__v_P_1 = :
AM_V_GEN = $(am__v_GEN_@AM_V@)
am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
am__v_GEN_0 = @echo "  GEN     " $@;
am__v_GEN_1 = 
AM_V_at = $(am__v_at_@AM_V@)
am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
am__v_at_0 = @
am__v_at_1 = 
depcomp =
am__depfiles_maybe =
SOURCES =
DIST_SOURCES =
RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
	ctags-recursive dvi-recursive html-recursive info-recursive \
	install-data-recursive install-dvi-recursive \
	install-exec-recursive install-html-recursive \
	install-info-recursive install-pdf-recursive \
	install-ps-recursive install-recursive installcheck-recursive \
	installdirs-recursive pdf-recursive ps-recursive \
	tags-recursive uninstall-recursive
am__can_run_installinfo = \
  case $$AM_UPDATE_INFO_DIR in \
    n|no|NO) false;; \
    *) (install-info --version) >/dev/null 2>&1;; \
  esac
RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
  distclean-recursive maintainer-clean-recursive
am__recursive_targets = \
  $(RECURSIVE_TARGETS) \
  $(RECURSIVE_CLEAN_TARGETS) \
  $(am__extra_recursive_targets)
AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
	distdir
am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
# Read a list of newline-separated strings from the standard input,
# and print each of them once, without duplicates.  Input order is
# *not* preserved.
am__uniquify_input = $(AWK) '\
  BEGIN { nonempty = 0; } \
  { items[$$0] = 1; nonempty = 1; } \
  END { if (nonempty) { for (i in items) print i; }; } \
'
# Make sure the list of sources is unique.  This is necessary because,
# e.g., the same source file might be shared among _SOURCES variables
# for different programs/libraries.
am__define_uniq_tagged_files = \
  list='$(am__tagged_files)'; \
  unique=`for i in $$list; do \
    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
  done | $(am__uniquify_input)`
ETAGS = etags
CTAGS = ctags
DIST_SUBDIRS = $(SUBDIRS)
am__DIST_COMMON = $(srcdir)/Makefile.in
DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
am__relativize = \
  dir0=`pwd`; \
  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
  sed_rest='s,^[^/]*/*,,'; \
  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
  sed_butlast='s,/*[^/]*$$,,'; \
  while test -n "$$dir1"; do \
    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
    if test "$$first" != "."; then \
      if test "$$first" = ".."; then \
        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
      else \
        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
        if test "$$first2" = "$$first"; then \
          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
        else \
          dir2="../$$dir2"; \
        fi; \
        dir0="$$dir0"/"$$first"; \
      fi; \
    fi; \
    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
  done; \
  reldir="$$dir2"
ACLOCAL = @ACLOCAL@
AMTAR = @AMTAR@
AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
AR = @AR@
ASLIBEXECDIR = @ASLIBEXECDIR@
AUTOCONF = @AUTOCONF@
AUTOHEADER = @AUTOHEADER@
AUTOMAKE = @AUTOMAKE@
AWK = @AWK@
CC = @CC@
CCAS = @CCAS@
CCASFLAGS = @CCASFLAGS@
CFLAGS = @CFLAGS@
CPP = @CPP@
CPPFLAGS = @CPPFLAGS@
CXX = @CXX@
CXXABI_LIB = @CXXABI_LIB@
CXXCPP = @CXXCPP@
CXXFLAGS = @CXXFLAGS@
CYGPATH_W = @CYGPATH_W@
DEFS = @DEFS@
DLLTOOL = @DLLTOOL@
DL_LIB = @DL_LIB@
DSYMUTIL = @DSYMUTIL@
DUMPBIN = @DUMPBIN@
ECHO_C = @ECHO_C@
ECHO_N = @ECHO_N@
ECHO_T = @ECHO_T@
EGREP = @EGREP@
ENDIAN_FLAG = @ENDIAN_FLAG@
EXECINFO_LIB = @EXECINFO_LIB@
EXEEXT = @EXEEXT@
FGREP = @FGREP@
GREP = @GREP@
HOST_AR = @HOST_AR@
HOST_RANLIB = @HOST_RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
INSTALL_SCRIPT = @INSTALL_SCRIPT@
INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
LD = @LD@
LDFLAGS = @LDFLAGS@
LIBOBJS = @LIBOBJS@
LIBS = @LIBS@
LIBTOOL = @LIBTOOL@
LIPO = @LIPO@
LLVM_CONFIG = @LLVM_CONFIG@
LLVM_INCLUDE_DIR = @LLVM_INCLUDE_DIR@
LLVM_LIB_DIR = @LLVM_LIB_DIR@
LN_S = @LN_S@
LTLIBOBJS = @LTLIBOBJS@
LTO_DEF = @LTO_DEF@
LTO_LIB = @LTO_LIB@
LTO_RPATH = @LTO_RPATH@
LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
MAINT = @MAINT@
MAKEINFO = @MAKEINFO@
MANIFEST_TOOL = @MANIFEST_TOOL@
MKDIR_P = @MKDIR_P@
NM = @NM@
NMEDIT = @NMEDIT@
OBJC = @OBJC@
OBJCFLAGS = @OBJCFLAGS@
OBJCWARNINGS = @OBJCWARNINGS@
OBJDUMP = @OBJDUMP@
OBJEXT = @OBJEXT@
OTOOL = @OTOOL@
OTOOL64 = @OTOOL64@
PACKAGE = @PACKAGE@
PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
PACKAGE_NAME = @PACKAGE_NAME@
PACKAGE_STRING = @PACKAGE_STRING@
PACKAGE_TARNAME = @PACKAGE_TARNAME@
PACKAGE_URL = @PACKAGE_URL@
PACKAGE_VERSION = @PACKAGE_VERSION@
PATH_SEPARATOR = @PATH_SEPARATOR@
PROGRAM_PREFIX = @PROGRAM_PREFIX@
PTHREAD_FLAGS = @PTHREAD_FLAGS@
RANLIB = @RANLIB@
SED = @SED@
SET_MAKE = @SET_MAKE@
SHELL = @SHELL@
STRIP = @STRIP@
UUID_LIB = @UUID_LIB@
VERSION = @VERSION@
WARNINGS = @WARNINGS@
XAR_LIB = @XAR_LIB@
abs_builddir = @abs_builddir@
abs_srcdir = @abs_srcdir@
abs_top_builddir = @abs_top_builddir@
abs_top_srcdir = @abs_top_srcdir@
ac_ct_AR = @ac_ct_AR@
ac_ct_CC = @ac_ct_CC@
ac_ct_CXX = @ac_ct_CXX@
ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
ac_ct_OBJC = @ac_ct_OBJC@
am__leading_dot = @am__leading_dot@
am__tar = @am__tar@
am__untar = @am__untar@
bindir = @bindir@
build = @build@
build_alias = @build_alias@
build_cpu = @build_cpu@
build_os = @build_os@
build_vendor = @build_vendor@
builddir = @builddir@
datadir = @datadir@
datarootdir = @datarootdir@
docdir = @docdir@
dvidir = @dvidir@
exec_prefix = @exec_prefix@
host = @host@
host_alias = @host_alias@
host_cpu = @host_cpu@
host_os = @host_os@
host_vendor = @host_vendor@
htmldir = @htmldir@
includedir = @includedir@
infodir = @infodir@
install_sh = @install_sh@
libdir = @libdir@
libexecdir = @libexecdir@
localedir = @localedir@
localstatedir = @localstatedir@
mandir = @mandir@
mkdir_p = @mkdir_p@
oldincludedir = @oldincludedir@
pdfdir = @pdfdir@
prefix = @prefix@
program_transform_name = @program_transform_name@
psdir = @psdir@
sbindir = @sbindir@
sharedstatedir = @sharedstatedir@
srcdir = @srcdir@
sysconfdir = @sysconfdir@
target = @target@
target_alias = @target_alias@
target_cpu = @target_cpu@
target_os = @target_os@
target_vendor = @target_vendor@
top_build_prefix = @top_build_prefix@
top_builddir = @top_builddir@
top_srcdir = @top_srcdir@
SUBDIRS = 3rd ld other 
all: all-recursive

.SUFFIXES:
$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
	@for dep in $?; do \
	  case '$(am__configure_deps)' in \
	    *$$dep*) \
	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
	        && { if test -f $@; then exit 0; else break; fi; }; \
	      exit 1;; \
	  esac; \
	done; \
	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu --ignore-deps ld64/src/Makefile'; \
	$(am__cd) $(top_srcdir) && \
	  $(AUTOMAKE) --gnu --ignore-deps ld64/src/Makefile
Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
	@case '$?' in \
	  *config.status*) \
	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
	  *) \
	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
	esac;

$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh

$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
$(am__aclocal_m4_deps):

mostlyclean-libtool:
	-rm -f *.lo

clean-libtool:
	-rm -rf .libs _libs

# This directory's subdirectories are mostly independent; you can cd
# into them and run 'make' without going through this Makefile.
# To change the values of 'make' variables: instead of editing Makefiles,
# (1) if the variable is set in 'config.status', edit 'config.status'
#     (which will cause the Makefiles to be regenerated when you run 'make');
# (2) otherwise, pass the desired values on the 'make' command line.
$(am__recursive_targets):
	@fail=; \
	if $(am__make_keepgoing); then \
	  failcom='fail=yes'; \
	else \
	  failcom='exit 1'; \
	fi; \
	dot_seen=no; \
	target=`echo $@ | sed s/-recursive//`; \
	case "$@" in \
	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
	  *) list='$(SUBDIRS)' ;; \
	esac; \
	for subdir in $$list; do \
	  echo "Making $$target in $$subdir"; \
	  if test "$$subdir" = "."; then \
	    dot_seen=yes; \
	    local_target="$$target-am"; \
	  else \
	    local_target="$$target"; \
	  fi; \
	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
	  || eval $$failcom; \
	done; \
	if test "$$dot_seen" = "no"; then \
	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
	fi; test -z "$$fail"

ID: $(am__tagged_files)
	$(am__define_uniq_tagged_files); mkid -fID $$unique
tags: tags-recursive
TAGS: tags

tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	set x; \
	here=`pwd`; \
	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
	  include_option=--etags-include; \
	  empty_fix=.; \
	else \
	  include_option=--include; \
	  empty_fix=; \
	fi; \
	list='$(SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    test ! -f $$subdir/TAGS || \
	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
	  fi; \
	done; \
	$(am__define_uniq_tagged_files); \
	shift; \
	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
	  test -n "$$unique" || unique=$$empty_fix; \
	  if test $$# -gt 0; then \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      "$$@" $$unique; \
	  else \
	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
	      $$unique; \
	  fi; \
	fi
ctags: ctags-recursive

CTAGS: ctags
ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
	$(am__define_uniq_tagged_files); \
	test -z "$(CTAGS_ARGS)$$unique" \
	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
	     $$unique

GTAGS:
	here=`$(am__cd) $(top_builddir) && pwd` \
	  && $(am__cd) $(top_srcdir) \
	  && gtags -i $(GTAGS_ARGS) "$$here"
cscopelist: cscopelist-recursive

cscopelist-am: $(am__tagged_files)
	list='$(am__tagged_files)'; \
	case "$(srcdir)" in \
	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
	  *) sdir=$(subdir)/$(srcdir) ;; \
	esac; \
	for i in $$list; do \
	  if test -f "$$i"; then \
	    echo "$(subdir)/$$i"; \
	  else \
	    echo "$$sdir/$$i"; \
	  fi; \
	done >> $(top_builddir)/cscope.files

distclean-tags:
	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags

distdir: $(DISTFILES)
	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
	list='$(DISTFILES)'; \
	  dist_files=`for file in $$list; do echo $$file; done | \
	  sed -e "s|^$$srcdirstrip/||;t" \
	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
	case $$dist_files in \
	  */*) $(MKDIR_P) `echo "$$dist_files" | \
			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
			   sort -u` ;; \
	esac; \
	for file in $$dist_files; do \
	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
	  if test -d $$d/$$file; then \
	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
	    if test -d "$(distdir)/$$file"; then \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
	    fi; \
	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
	  else \
	    test -f "$(distdir)/$$file" \
	    || cp -p $$d/$$file "$(distdir)/$$file" \
	    || exit 1; \
	  fi; \
	done
	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
	  if test "$$subdir" = .; then :; else \
	    $(am__make_dryrun) \
	      || test -d "$(distdir)/$$subdir" \
	      || $(MKDIR_P) "$(distdir)/$$subdir" \
	      || exit 1; \
	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
	    $(am__relativize); \
	    new_distdir=$$reldir; \
	    dir1=$$subdir; dir2="$(top_distdir)"; \
	    $(am__relativize); \
	    new_top_distdir=$$reldir; \
	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
	    ($(am__cd) $$subdir && \
	      $(MAKE) $(AM_MAKEFLAGS) \
	        top_distdir="$$new_top_distdir" \
	        distdir="$$new_distdir" \
		am__remove_distdir=: \
		am__skip_length_check=: \
		am__skip_mode_fix=: \
	        distdir) \
	      || exit 1; \
	  fi; \
	done
check-am: all-am
check: check-recursive
all-am: Makefile
installdirs: installdirs-recursive
installdirs-am:
install: install-recursive
install-exec: install-exec-recursive
install-data: install-data-recursive
uninstall: uninstall-recursive

install-am: all-am
	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am

installcheck: installcheck-recursive
install-strip:
	if test -z '$(STRIP)'; then \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	      install; \
	else \
	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
	fi
mostlyclean-generic:

clean-generic:

distclean-generic:
	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)

maintainer-clean-generic:
	@echo "This command is intended for maintainers to use"
	@echo "it deletes files that may require special tools to rebuild."
clean: clean-recursive

clean-am: clean-generic clean-libtool mostlyclean-am

distclean: distclean-recursive
	-rm -f Makefile
distclean-am: clean-am distclean-generic distclean-tags

dvi: dvi-recursive

dvi-am:

html: html-recursive

html-am:

info: info-recursive

info-am:

install-data-am:

install-dvi: install-dvi-recursive

install-dvi-am:

install-exec-am:

install-html: install-html-recursive

install-html-am:

install-info: install-info-recursive

install-info-am:

install-man:

install-pdf: install-pdf-recursive

install-pdf-am:

install-ps: install-ps-recursive

install-ps-am:

installcheck-am:

maintainer-clean: maintainer-clean-recursive
	-rm -f Makefile
maintainer-clean-am: distclean-am maintainer-clean-generic

mostlyclean: mostlyclean-recursive

mostlyclean-am: mostlyclean-generic mostlyclean-libtool

pdf: pdf-recursive

pdf-am:

ps: ps-recursive

ps-am:

uninstall-am:

.MAKE: $(am__recursive_targets) install-am install-strip

.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
	check-am clean clean-generic clean-libtool cscopelist-am ctags \
	ctags-am distclean distclean-generic distclean-libtool \
	distclean-tags distdir dvi dvi-am html html-am info info-am \
	install install-am install-data install-data-am install-dvi \
	install-dvi-am install-exec install-exec-am install-html \
	install-html-am install-info install-info-am install-man \
	install-pdf install-pdf-am install-ps install-ps-am \
	install-strip installcheck installcheck-am installdirs \
	installdirs-am maintainer-clean maintainer-clean-generic \
	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
	ps ps-am tags tags-am uninstall uninstall-am

.PRECIOUS: Makefile


# Tell versions [3.59,3.63) of GNU make to not export all variables.
# Otherwise a system limit (for SysV at least) may be exceeded.
.NOEXPORT:
                                                                                                                                                                                                                                                                                                                                       osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/abstraction/                       0040755 0001750 0001750 00000000000 12612724205 024313  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/abstraction/FileAbstraction.hpp    0100644 0001750 0001750 00000013374 12612724205 030102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- 
 *
 * Copyright (c) 2005 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __FILE_ABSTRACTION__
#define __FILE_ABSTRACTION__


#include <stdint.h>
#include <string.h>
#include <libkern/OSByteOrder.h>

#ifdef __OPTIMIZE__
#define INLINE	__attribute__((always_inline))
#else
#define INLINE
#endif

//
// This abstraction layer is for use with file formats that have 64-bit/32-bit and Big-Endian/Little-Endian variants
//
// For example: to make a utility that handles 32-bit little enidan files use:  Pointer32<LittleEndian>
//
//
//		get16()			read a 16-bit number from an E endian struct
//		set16()			write a 16-bit number to an E endian struct
//		get32()			read a 32-bit number from an E endian struct
//		set32()			write a 32-bit number to an E endian struct
//		get64()			read a 64-bit number from an E endian struct
//		set64()			write a 64-bit number to an E endian struct
//
//		getBits()		read a bit field from an E endian struct (bitCount=number of bits in field, firstBit=bit index of field)
//		setBits()		write a bit field to an E endian struct (bitCount=number of bits in field, firstBit=bit index of field)
//
//		getBitsRaw()	read a bit field from a struct with native endianness
//		setBitsRaw()	write a bit field from a struct with native endianness
//

class BigEndian
{
public:
	static uint16_t	get16(const uint16_t& from)				INLINE { return OSReadBigInt16(&from, 0); }
	static void		set16(uint16_t& into, uint16_t value)	INLINE { OSWriteBigInt16(&into, 0, value); }
	
	static uint32_t	get32(const uint32_t& from)				INLINE { return OSReadBigInt32(&from, 0); }
	static void		set32(uint32_t& into, uint32_t value)	INLINE { OSWriteBigInt32(&into, 0, value); }
	
	static uint64_t get64(const uint64_t& from)				INLINE { return OSReadBigInt64(&from, 0); }
	static void		set64(uint64_t& into, uint64_t value)	INLINE { OSWriteBigInt64(&into, 0, value); }
	
	static uint32_t	getBits(const uint32_t& from, 
						uint8_t firstBit, uint8_t bitCount)	INLINE { return getBitsRaw(get32(from), firstBit, bitCount); }
	static void		setBits(uint32_t& into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE { uint32_t temp = get32(into); setBitsRaw(temp, value, firstBit, bitCount); set32(into, temp); }

	static uint32_t	getBitsRaw(const uint32_t& from, 
						uint8_t firstBit, uint8_t bitCount)	INLINE { return ((from >> (32-firstBit-bitCount)) & ((1<<bitCount)-1)); }
	static void		setBitsRaw(uint32_t& into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE { uint32_t temp = into; 
																							const uint32_t mask = ((1<<bitCount)-1); 
																							temp &= ~(mask << (32-firstBit-bitCount)); 
																							temp |= ((value & mask) << (32-firstBit-bitCount)); 
																							into = temp; }
	enum { little_endian = 0 };
};


class LittleEndian
{
public:
	static uint16_t	get16(const uint16_t& from)				INLINE { return OSReadLittleInt16(&from, 0); }
	static void		set16(uint16_t& into, uint16_t value)	INLINE { OSWriteLittleInt16(&into, 0, value); }
	
	static uint32_t	get32(const uint32_t& from)				INLINE { return OSReadLittleInt32(&from, 0); }
	static void		set32(uint32_t& into, uint32_t value)	INLINE { OSWriteLittleInt32(&into, 0, value); }
	
	static uint64_t get64(const uint64_t& from)				INLINE { return OSReadLittleInt64(&from, 0); }
	static void		set64(uint64_t& into, uint64_t value)	INLINE { OSWriteLittleInt64(&into, 0, value); }

	static uint32_t	getBits(const uint32_t& from,
						uint8_t firstBit, uint8_t bitCount)	INLINE { return getBitsRaw(get32(from), firstBit, bitCount); }
	static void		setBits(uint32_t& into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE { uint32_t temp = get32(into); setBitsRaw(temp, value, firstBit, bitCount); set32(into, temp); }

	static uint32_t	getBitsRaw(const uint32_t& from,
						uint8_t firstBit, uint8_t bitCount)	INLINE { return ((from >> firstBit) & ((1<<bitCount)-1)); }
	static void		setBitsRaw(uint32_t& into, uint32_t value,
						uint8_t firstBit, uint8_t bitCount)	INLINE {  uint32_t temp = into; 
																							const uint32_t mask = ((1<<bitCount)-1); 
																							temp &= ~(mask << firstBit); 
																							temp |= ((value & mask) << firstBit); 
																							into = temp; }
	enum { little_endian = 1 };
};


template <typename _E>
class Pointer32
{
public:
	typedef uint32_t	uint_t;
	typedef int32_t		sint_t;
	typedef _E			E;
	
	static uint64_t	getP(const uint_t& from)				INLINE { return _E::get32(from); }
	static void		setP(uint_t& into, uint64_t value)		INLINE { _E::set32(into, value); }
};


template <typename _E>
class Pointer64
{
public:
	typedef uint64_t	uint_t;
	typedef int64_t		sint_t;
	typedef _E			E;
	
	static uint64_t	getP(const uint_t& from)				INLINE { return _E::get64(from); }
	static void		setP(uint_t& into, uint64_t value)		INLINE { _E::set64(into, value); }
};





#endif // __FILE_ABSTRACTION__


                                                                                                                                                                                                                                                                    MachOFileAbstraction.hpp                                                                            0100644 0001750 0001750 00000204576 12612724205 030741  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/abstraction                                                                                           /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- 
 *
 * Copyright (c) 2005-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
*/
#ifndef __MACH_O_FILE_ABSTRACTION__
#define __MACH_O_FILE_ABSTRACTION__

#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/reloc.h>
#include <mach-o/fat.h>
#include <mach-o/stab.h>
#include <mach-o/reloc.h>
#include <mach-o/x86_64/reloc.h>
#include <mach-o/compact_unwind_encoding.h>
#include <mach/machine.h>
#include <stddef.h>
#include <libunwind.h>

#include "FileAbstraction.hpp"

#include "configure.h"

// stuff that will eventually go away once newer cctools headers are widespread
#ifndef LC_LOAD_UPWARD_DYLIB
	#define	LC_LOAD_UPWARD_DYLIB (0x23|LC_REQ_DYLD)	/* load of dylib whose initializers run later */
#endif

#ifndef CPU_SUBTYPE_ARM_V5TEJ
	#define CPU_SUBTYPE_ARM_V5TEJ		((cpu_subtype_t) 7)
#endif
#ifndef CPU_SUBTYPE_ARM_XSCALE
	#define CPU_SUBTYPE_ARM_XSCALE		((cpu_subtype_t) 8)
#endif
#ifndef CPU_SUBTYPE_ARM_V7
	#define CPU_SUBTYPE_ARM_V7			((cpu_subtype_t) 9)
#endif

#ifndef N_ARM_THUMB_DEF
	#define N_ARM_THUMB_DEF	0x0008 
#endif
#ifndef MH_DEAD_STRIPPABLE_DYLIB
	#define MH_DEAD_STRIPPABLE_DYLIB 0x400000
#endif
#ifndef MH_KEXT_BUNDLE
	#define MH_KEXT_BUNDLE 11
#endif
#ifndef LC_DYLD_INFO
	#define	LC_DYLD_INFO 	0x22	/* compressed dyld information */
	#define	LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD)	/* compressed dyld information only */

	struct dyld_info_command {
	   uint32_t   cmd;		/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */
	   uint32_t   cmdsize;		/* sizeof(struct dyld_info_command) */
		uint32_t   rebase_off;	/* file offset to rebase info  */
		uint32_t   rebase_size;	/* size of rebase info   */
		uint32_t   bind_off;	/* file offset to binding info   */
		uint32_t   bind_size;	/* size of binding info  */
		uint32_t   weak_bind_off;	/* file offset to weak binding info   */
		uint32_t   weak_bind_size;  /* size of weak binding info  */
		uint32_t   lazy_bind_off;	/* file offset to lazy binding info */
		uint32_t   lazy_bind_size;  /* size of lazy binding infs */
		uint32_t   export_off;	/* file offset to lazy binding info */
		uint32_t   export_size;	/* size of lazy binding infs */
	};

	#define REBASE_TYPE_POINTER					1
	#define REBASE_TYPE_TEXT_ABSOLUTE32				2
	#define REBASE_TYPE_TEXT_PCREL32				3

	#define REBASE_OPCODE_MASK					0xF0
	#define REBASE_IMMEDIATE_MASK					0x0F
	#define REBASE_OPCODE_DONE					0x00
	#define REBASE_OPCODE_SET_TYPE_IMM				0x10
	#define REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB		0x20
	#define REBASE_OPCODE_ADD_ADDR_ULEB				0x30
	#define REBASE_OPCODE_ADD_ADDR_IMM_SCALED			0x40
	#define REBASE_OPCODE_DO_REBASE_IMM_TIMES			0x50
	#define REBASE_OPCODE_DO_REBASE_ULEB_TIMES			0x60
	#define REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB			0x70
	#define REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB	0x80

	#define BIND_TYPE_POINTER					1
	#define BIND_TYPE_TEXT_ABSOLUTE32				2
	#define BIND_TYPE_TEXT_PCREL32					3

	#define BIND_SPECIAL_DYLIB_SELF					 0
	#define BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE			-1
	#define BIND_SPECIAL_DYLIB_FLAT_LOOKUP				-2

	#define BIND_SYMBOL_FLAGS_WEAK_IMPORT				0x1
	#define BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION			0x8

	#define BIND_OPCODE_MASK					0xF0
	#define BIND_IMMEDIATE_MASK					0x0F
	#define BIND_OPCODE_DONE					0x00
	#define BIND_OPCODE_SET_DYLIB_ORDINAL_IMM			0x10
	#define BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB			0x20
	#define BIND_OPCODE_SET_DYLIB_SPECIAL_IMM			0x30
	#define BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM		0x40
	#define BIND_OPCODE_SET_TYPE_IMM				0x50
	#define BIND_OPCODE_SET_ADDEND_SLEB				0x60
	#define BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB			0x70
	#define BIND_OPCODE_ADD_ADDR_ULEB				0x80
	#define BIND_OPCODE_DO_BIND					0x90
	#define BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB			0xA0
	#define BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED			0xB0
	#define BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB		0xC0

	#define EXPORT_SYMBOL_FLAGS_KIND_MASK				0x03
	#define EXPORT_SYMBOL_FLAGS_KIND_REGULAR			0x00
	#define EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL			0x01
	#define EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION			0x04
	#define EXPORT_SYMBOL_FLAGS_INDIRECT_DEFINITION			0x08
	#define EXPORT_SYMBOL_FLAGS_HAS_SPECIALIZATIONS			0x10

#endif 

#ifndef S_THREAD_LOCAL_REGULAR
	#define S_THREAD_LOCAL_REGULAR                   0x11
#endif

#ifndef S_THREAD_LOCAL_ZEROFILL
	#define S_THREAD_LOCAL_ZEROFILL                  0x12
#endif

#ifndef S_THREAD_LOCAL_VARIABLES
	#define S_THREAD_LOCAL_VARIABLES                 0x13
#endif

#ifndef S_THREAD_LOCAL_VARIABLE_POINTERS
	#define S_THREAD_LOCAL_VARIABLE_POINTERS         0x14
#endif

#ifndef S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
	#define S_THREAD_LOCAL_INIT_FUNCTION_POINTERS    0x15
#endif

#ifndef MH_HAS_TLV_DESCRIPTORS
	#define MH_HAS_TLV_DESCRIPTORS 0x800000
#endif

#ifndef X86_64_RELOC_TLV
	#define X86_64_RELOC_TLV    9
#endif

#define GENERIC_RLEOC_TLV  5

#ifndef EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER
	#define EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER 0x10
#endif

#ifndef EXPORT_SYMBOL_FLAGS_REEXPORT
	#define EXPORT_SYMBOL_FLAGS_REEXPORT 0x08
#endif

// type internal to linker
#define BIND_TYPE_OVERRIDE_OF_WEAKDEF_IN_DYLIB 0

#ifndef LC_VERSION_MIN_MACOSX
	#define	LC_VERSION_MIN_MACOSX 	0x24
	#define	LC_VERSION_MIN_IPHONEOS 	0x25

	struct version_min_command {
		uint32_t	cmd;		/* LC_VERSION_MIN_MACOSX or LC_VERSION_MIN_IPHONEOS  */
		uint32_t	cmdsize;	/* sizeof(struct min_version_command) */
		uint32_t	version;	/* X.Y.Z is encoded in nibbles xxxx.yy.zz */
		uint32_t	reserved;	/* zero */
	};
#endif

#ifndef N_SYMBOL_RESOLVER
	#define N_SYMBOL_RESOLVER 0x100
#endif

#ifndef N_AST
	#define N_AST 0x32
#endif

#ifndef LC_FUNCTION_STARTS
	#define	LC_FUNCTION_STARTS 	0x26
#endif

#ifndef MH_NO_HEAP_EXECUTION
	#define MH_NO_HEAP_EXECUTION 0x1000000
#endif

#ifndef LC_DYLD_ENVIRONMENT
	#define	LC_DYLD_ENVIRONMENT 	0x27
#endif

#ifndef LC_DATA_IN_CODE
	#define LC_DATA_IN_CODE 0x29 /* table of non-instructions in __text */
 	struct data_in_code_entry {
		uint32_t	offset;
		uint16_t	length;
		uint16_t	kind;
	};
#endif

#ifndef LC_DYLIB_CODE_SIGN_DRS
	#define LC_DYLIB_CODE_SIGN_DRS 0x2B
#endif

#ifndef LC_ENCRYPTION_INFO_64
	#define LC_ENCRYPTION_INFO_64 0x2C
  struct encryption_info_command_64 {
     uint32_t	cmd;		
     uint32_t	cmdsize;
     uint32_t	cryptoff;
     uint32_t	cryptsize;
     uint32_t	cryptid;
     uint32_t	pad;
  };
#endif

#ifndef MH_APP_EXTENSION_SAFE
	#define MH_APP_EXTENSION_SAFE 0x02000000
#endif

#ifndef N_ALT_ENTRY
	#define N_ALT_ENTRY 0x0200
#endif

#ifndef CPU_SUBTYPE_ARM_V7F
  #define CPU_SUBTYPE_ARM_V7F    ((cpu_subtype_t) 10)
#endif
#ifndef CPU_SUBTYPE_ARM_V7K
  #define CPU_SUBTYPE_ARM_V7K    ((cpu_subtype_t) 12)
#endif
#ifndef CPU_SUBTYPE_ARM_V7S
  #define CPU_SUBTYPE_ARM_V7S    ((cpu_subtype_t) 11)
#endif



// hack until arm64 headers are worked out
#ifndef CPU_TYPE_ARM64
	#define CPU_TYPE_ARM64			(CPU_TYPE_ARM | CPU_ARCH_ABI64)
#endif
#ifndef CPU_SUBTYPE_ARM64_ALL
	#define CPU_SUBTYPE_ARM64_ALL	0
#endif
#ifndef CPU_SUBTYPE_ARM64_V8
	#define CPU_SUBTYPE_ARM64_V8    1
#endif


#define ARM64_RELOC_UNSIGNED            0 // for pointers
#define ARM64_RELOC_SUBTRACTOR          1 // must be followed by a ARM64_RELOC_UNSIGNED
#define ARM64_RELOC_BRANCH26            2 // a B/BL instruction with 26-bit displacement
#define ARM64_RELOC_PAGE21              3 // pc-rel distance to page of target
#define ARM64_RELOC_PAGEOFF12           4 // offset within page, scaled by r_length
#define ARM64_RELOC_GOT_LOAD_PAGE21     5 // pc-rel distance to page of GOT slot
#define ARM64_RELOC_GOT_LOAD_PAGEOFF12  6 // offset within page of GOT slot, scaled by r_length
#define ARM64_RELOC_POINTER_TO_GOT      7 // for pointers to GOT slots
#define ARM64_RELOC_TLVP_LOAD_PAGE21    8 // pc-rel distance to page of TLVP slot
#define ARM64_RELOC_TLVP_LOAD_PAGEOFF12 9 // offset within page of TLVP slot, scaled by r_length
#define ARM64_RELOC_ADDEND				10 // r_symbolnum is addend for next reloc



#define UNW_ARM64_X0     0
#define UNW_ARM64_X1     1
#define UNW_ARM64_X2     2
#define UNW_ARM64_X3     3
#define UNW_ARM64_X4     4
#define UNW_ARM64_X5     5
#define UNW_ARM64_X6     6
#define UNW_ARM64_X7     7
#define UNW_ARM64_X8     8
#define UNW_ARM64_X9     9
#define UNW_ARM64_X10   10
#define UNW_ARM64_X11   11
#define UNW_ARM64_X12   12
#define UNW_ARM64_X13   13
#define UNW_ARM64_X14   14
#define UNW_ARM64_X15   15
#define UNW_ARM64_X16   16
#define UNW_ARM64_X17   17
#define UNW_ARM64_X18   18
#define UNW_ARM64_X19   19
#define UNW_ARM64_X20   20
#define UNW_ARM64_X21   21
#define UNW_ARM64_X22   22
#define UNW_ARM64_X23   23
#define UNW_ARM64_X24   24
#define UNW_ARM64_X25   25
#define UNW_ARM64_X26   26
#define UNW_ARM64_X27   27
#define UNW_ARM64_X28   28
#define UNW_ARM64_X29   29  
#define UNW_ARM64_FP    29
#define UNW_ARM64_X30   30  
#define UNW_ARM64_LR    30
#define UNW_ARM64_X31   31  
#define UNW_ARM64_SP    31
#define UNW_ARM64_D0    64
#define UNW_ARM64_D1    65
#define UNW_ARM64_D2    66
#define UNW_ARM64_D3    67
#define UNW_ARM64_D4    68
#define UNW_ARM64_D5    69
#define UNW_ARM64_D6    70
#define UNW_ARM64_D7    71
#define UNW_ARM64_D8    72
#define UNW_ARM64_D9    73
#define UNW_ARM64_D10   74
#define UNW_ARM64_D11   75
#define UNW_ARM64_D12   76
#define UNW_ARM64_D13   77
#define UNW_ARM64_D14   78
#define UNW_ARM64_D15   79
#define UNW_ARM64_D16   80
#define UNW_ARM64_D17   81
#define UNW_ARM64_D18   82
#define UNW_ARM64_D19   83
#define UNW_ARM64_D20   84
#define UNW_ARM64_D21   85
#define UNW_ARM64_D22   86
#define UNW_ARM64_D23   87
#define UNW_ARM64_D24   88
#define UNW_ARM64_D25   89
#define UNW_ARM64_D26   90
#define UNW_ARM64_D27   91
#define UNW_ARM64_D28   92
#define UNW_ARM64_D29   93
#define UNW_ARM64_D30   94
#define UNW_ARM64_D31   95

#define UNWIND_ARM64_MODE_MASK                          0x0F000000
#define UNWIND_ARM64_MODE_FRAME_OLD                     0x01000000
#define UNWIND_ARM64_MODE_FRAMELESS                     0x02000000
#define UNWIND_ARM64_MODE_DWARF                         0x03000000
#define UNWIND_ARM64_MODE_FRAME                         0x04000000
    
#define UNWIND_ARM64_FRAME_X19_X20_PAIR                 0x00000001
#define UNWIND_ARM64_FRAME_X21_X22_PAIR                 0x00000002
#define UNWIND_ARM64_FRAME_X23_X24_PAIR                 0x00000004
#define UNWIND_ARM64_FRAME_X25_X26_PAIR                 0x00000008
#define UNWIND_ARM64_FRAME_X27_X28_PAIR                 0x00000010
#define UNWIND_ARM64_FRAME_D8_D9_PAIR                   0x00000100
#define UNWIND_ARM64_FRAME_D10_D11_PAIR                 0x00000200
#define UNWIND_ARM64_FRAME_D12_D13_PAIR                 0x00000400
#define UNWIND_ARM64_FRAME_D14_D15_PAIR                 0x00000800

#define UNWIND_ARM64_FRAMELESS_STACK_SIZE_MASK			0x00FFF000

#define UNWIND_ARM64_FRAME_X21_X22_PAIR_OLD                 0x00000001
#define UNWIND_ARM64_FRAME_X23_X24_PAIR_OLD                 0x00000002
#define UNWIND_ARM64_FRAME_X25_X26_PAIR_OLD                 0x00000004
#define UNWIND_ARM64_FRAME_X27_X28_PAIR_OLD                 0x00000008
#define UNWIND_ARM64_FRAME_D8_D9_PAIR_OLD                   0x00000010
#define UNWIND_ARM64_FRAME_D10_D11_PAIR_OLD                 0x00000020
#define UNWIND_ARM64_FRAME_D12_D13_PAIR_OLD                 0x00000040
#define UNWIND_ARM64_FRAME_D14_D15_PAIR_OLD                 0x00000080


#define UNWIND_ARM64_DWARF_SECTION_OFFSET               0x00FFFFFF

#define UNW_ARM_D31 287


#ifndef LC_SOURCE_VERSION
	#define LC_SOURCE_VERSION 0x2A
	struct source_version_command {
		uint32_t  cmd;	/* LC_SOURCE_VERSION */
		uint32_t  cmdsize;	/* 16 */
		uint64_t  version;	/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */
	};
#endif

#ifndef LC_MAIN
	#define LC_MAIN (0x28|LC_REQ_DYLD) /* replacement for LC_UNIXTHREAD */
	struct entry_point_command {
		uint32_t  cmd;	/* LC_MAIN only used in MH_EXECUTE filetypes */
		uint32_t  cmdsize;	/* 24 */
		uint64_t  entryoff;	/* file (__TEXT) offset of main() */
		uint64_t  stacksize;/* if not zero, initial stack size */
	};
#endif

#ifndef LC_DYLIB_CODE_SIGN_DRS
	#define LC_DYLIB_CODE_SIGN_DRS 0x2B 
#endif	

#ifndef LC_LINKER_OPTION 
	#define LC_LINKER_OPTION   0x2D

	struct linker_option_command {
		uint32_t	cmd;	  /*LC_LINKER_OPTION only used in MH_OBJECT filetypes */
		uint32_t	cmdsize;
		uint32_t	count;	  /* number of strings */
		/* concatenation of zero terminated UTF8 strings.  Zero filled at end to align */
	};
#endif

#ifndef LC_LINKER_OPTIMIZATION_HINTS 
	#define LC_LINKER_OPTIMIZATION_HINTS   0x2E
	#define LOH_ARM64_ADRP_ADRP				1
	#define LOH_ARM64_ADRP_LDR				2
	#define LOH_ARM64_ADRP_ADD_LDR			3
	#define LOH_ARM64_ADRP_LDR_GOT_LDR		4
	#define LOH_ARM64_ADRP_ADD_STR			5
	#define LOH_ARM64_ADRP_LDR_GOT_STR		6
	#define LOH_ARM64_ADRP_ADD				7
	#define LOH_ARM64_ADRP_LDR_GOT			8
#endif

#ifndef LC_VERSION_MIN_TVOS
	#define LC_VERSION_MIN_TVOS			0x2F
#endif

#ifndef LC_VERSION_MIN_WATCHOS
	#define LC_VERSION_MIN_WATCHOS		0x30
#endif

#ifndef EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE
	#define EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE			0x02
#endif

#ifndef CPU_SUBTYPE_ARM_V8
	#define CPU_SUBTYPE_ARM_V8		((cpu_subtype_t) 13) 
#endif

#ifndef CPU_SUBTYPE_ARM_V6M
	#define CPU_SUBTYPE_ARM_V6M		((cpu_subtype_t) 14) 
#endif	

#ifndef CPU_SUBTYPE_ARM_V7M
	#define CPU_SUBTYPE_ARM_V7M		((cpu_subtype_t) 15) 
#endif	

#ifndef CPU_SUBTYPE_ARM_V7EM
	#define CPU_SUBTYPE_ARM_V7EM	((cpu_subtype_t) 16) 
#endif	

#ifndef CPU_SUBTYPE_X86_64_H
	#define CPU_SUBTYPE_X86_64_H	((cpu_subtype_t) 8) 
#endif	

#define UNWIND_ARM_MODE_MASK                          0x0F000000
#define UNWIND_ARM_MODE_FRAME                         0x01000000
#define UNWIND_ARM_MODE_FRAME_D                       0x02000000
#define UNWIND_ARM_MODE_DWARF                         0x04000000
 
#define  UNWIND_ARM_FRAME_STACK_ADJUST_MASK           0x00C00000

#define UNWIND_ARM_FRAME_FIRST_PUSH_R4                0x00000001
#define UNWIND_ARM_FRAME_FIRST_PUSH_R5                0x00000002
#define UNWIND_ARM_FRAME_FIRST_PUSH_R6                0x00000004
  
#define UNWIND_ARM_FRAME_SECOND_PUSH_R8               0x00000008
#define UNWIND_ARM_FRAME_SECOND_PUSH_R9               0x00000010
#define UNWIND_ARM_FRAME_SECOND_PUSH_R10              0x00000020
#define UNWIND_ARM_FRAME_SECOND_PUSH_R11              0x00000040
#define UNWIND_ARM_FRAME_SECOND_PUSH_R12              0x00000080
 
#define UNWIND_ARM_FRAME_D_REG_COUNT_MASK             0x00000F00
 
#define UNWIND_ARM_DWARF_SECTION_OFFSET               0x00FFFFFF


// ( <opcode> (delta-uleb128)+ <zero> )+ <zero>
#define DYLD_CACHE_ADJ_V1_POINTER_32		0x01
#define DYLD_CACHE_ADJ_V1_POINTER_64		0x02
#define DYLD_CACHE_ADJ_V1_ADRP				0x03
#define DYLD_CACHE_ADJ_V1_ARM_THUMB_MOVT	0x10 // thru 0x1F
#define DYLD_CACHE_ADJ_V1_ARM_MOVT			0x20 // thru 0x2F


// Whole		 :== <new-marker> <count> FromToSection+
// FromToSection :== <from-sect-index> <to-sect-index> <count> ToOffset+
// ToOffset		 :== <to-sect-offset-delta> <count> FromOffset+
// FromOffset	 :== <kind> <count> <from-sect-offset-delta>
#define DYLD_CACHE_ADJ_V2_FORMAT				0x7F

#define DYLD_CACHE_ADJ_V2_POINTER_32			0x01
#define DYLD_CACHE_ADJ_V2_POINTER_64			0x02
#define DYLD_CACHE_ADJ_V2_DELTA_32			    0x03
#define DYLD_CACHE_ADJ_V2_DELTA_64			    0x04
#define DYLD_CACHE_ADJ_V2_ARM64_ADRP			0x05
#define DYLD_CACHE_ADJ_V2_ARM64_OFF12			0x06
#define DYLD_CACHE_ADJ_V2_ARM64_BR26			0x07
#define DYLD_CACHE_ADJ_V2_ARM_MOVW_MOVT			0x08
#define DYLD_CACHE_ADJ_V2_ARM_BR24				0x09
#define DYLD_CACHE_ADJ_V2_THUMB_MOVW_MOVT		0x0A
#define DYLD_CACHE_ADJ_V2_THUMB_BR22			0x0B
#define DYLD_CACHE_ADJ_V2_IMAGE_OFF_32			0x0C



// kind target-address fixup-addr [adj] 



struct ArchInfo {
	const char*			archName;
	cpu_type_t			cpuType;
	cpu_subtype_t		cpuSubType;
	const char*			llvmTriplePrefix;
	const char*			llvmTriplePrefixAlt;
	bool				isSubType;
	bool				supportsThumb2;
};

static const ArchInfo archInfoArray[] = {
#if SUPPORT_ARCH_x86_64
	{ "x86_64", CPU_TYPE_X86_64, CPU_SUBTYPE_X86_64_ALL, "x86_64-",  "", true, false },
#endif
#if SUPPORT_ARCH_x86_64h
	{ "x86_64h", CPU_TYPE_X86_64, CPU_SUBTYPE_X86_64_H,	 "x86_64h-",  "", true, false },
#endif
#if SUPPORT_ARCH_i386
	{ "i386",   CPU_TYPE_I386,   CPU_SUBTYPE_I386_ALL,   "i386-",    "", false, false },
#endif
#if SUPPORT_ARCH_armv4t
	{ "armv4t", CPU_TYPE_ARM,    CPU_SUBTYPE_ARM_V4T,    "armv4t-",  "", true,  false },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv5
	{ "armv5", CPU_TYPE_ARM,     CPU_SUBTYPE_ARM_V5TEJ,  "armv5e-",  "", true,  false },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv6
	{ "armv6", CPU_TYPE_ARM,     CPU_SUBTYPE_ARM_V6,     "armv6-",   "", true,  false },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv7
	{ "armv7", CPU_TYPE_ARM,     CPU_SUBTYPE_ARM_V7,     "thumbv7-", "armv7-", true,  true },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv7f
	{ "armv7f", CPU_TYPE_ARM,    CPU_SUBTYPE_ARM_V7F,    "thumbv7f-", "", true,  true },
	#define SUPPORT_ARCH_arm_any 1
#endif 
#if SUPPORT_ARCH_armv7k
	{ "armv7k", CPU_TYPE_ARM,    CPU_SUBTYPE_ARM_V7K,    "thumbv7k-", "", true,  true },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv7s
	{ "armv7s", CPU_TYPE_ARM,    CPU_SUBTYPE_ARM_V7S,    "thumbv7s-", "armv7s", true,  true },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv6m
	{ "armv6m", CPU_TYPE_ARM,    CPU_SUBTYPE_ARM_V6M,    "thumbv6m-", "", true,  false },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv7m
	{ "armv7m", CPU_TYPE_ARM,    CPU_SUBTYPE_ARM_V7M,    "thumbv7m-", "armv7m", true,  true },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv7em
	{ "armv7em", CPU_TYPE_ARM,   CPU_SUBTYPE_ARM_V7EM,   "thumbv7em-", "armv7em", true,  true },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_armv8
	{ "armv8", CPU_TYPE_ARM,     CPU_SUBTYPE_ARM_V8,     "thumbv8-", "armv8", true,  true },
	#define SUPPORT_ARCH_arm_any 1
#endif
#if SUPPORT_ARCH_arm64
	{ "arm64", CPU_TYPE_ARM64,   CPU_SUBTYPE_ARM64_ALL,  "arm64-",  "aarch64-",  false,  false },
#endif
#if SUPPORT_ARCH_arm64v8
	{ "arm64v8", CPU_TYPE_ARM64, CPU_SUBTYPE_ARM64_V8,   "arm64v8-",  "aarch64-",   true,  false },
#endif
	{ NULL, 0, 0, NULL, NULL, false, false }
};

 
// weird, but this include must wait until after SUPPORT_ARCH_arm_any is set up
#if SUPPORT_ARCH_arm_any
#include <mach-o/arm/reloc.h>
#endif

// hack until newer <mach-o/arm/reloc.h> everywhere
#define ARM_RELOC_HALF 8
#define ARM_RELOC_HALF_SECTDIFF 9



//
// This abstraction layer makes every mach-o file look like a 64-bit mach-o file with native endianness
//



//
// mach-o file header
//
template <typename P> struct macho_header_content {};
template <> struct macho_header_content<Pointer32<BigEndian> >    { mach_header		fields; };
template <> struct macho_header_content<Pointer64<BigEndian> >	  { mach_header_64	fields; };
template <> struct macho_header_content<Pointer32<LittleEndian> > { mach_header		fields; };
template <> struct macho_header_content<Pointer64<LittleEndian> > { mach_header_64	fields; };

template <typename P>
class macho_header {
public:
	uint32_t		magic() const					INLINE { return E::get32(header.fields.magic); }
	void			set_magic(uint32_t value)		INLINE { E::set32(header.fields.magic, value); }

	uint32_t		cputype() const					INLINE { return E::get32(header.fields.cputype); }
	void			set_cputype(uint32_t value)		INLINE { E::set32((uint32_t&)header.fields.cputype, value); }

	uint32_t		cpusubtype() const				INLINE { return E::get32(header.fields.cpusubtype); }
	void			set_cpusubtype(uint32_t value)	INLINE { E::set32((uint32_t&)header.fields.cpusubtype, value); }

	uint32_t		filetype() const				INLINE { return E::get32(header.fields.filetype); }
	void			set_filetype(uint32_t value)	INLINE { E::set32(header.fields.filetype, value); }

	uint32_t		ncmds() const					INLINE { return E::get32(header.fields.ncmds); }
	void			set_ncmds(uint32_t value)		INLINE { E::set32(header.fields.ncmds, value); }

	uint32_t		sizeofcmds() const				INLINE { return E::get32(header.fields.sizeofcmds); }
	void			set_sizeofcmds(uint32_t value)	INLINE { E::set32(header.fields.sizeofcmds, value); }

	uint32_t		flags() const					INLINE { return E::get32(header.fields.flags); }
	void			set_flags(uint32_t value)		INLINE { E::set32(header.fields.flags, value); }

	uint32_t		reserved() const				INLINE { return E::get32(header.fields.reserved); }
	void			set_reserved(uint32_t value)	INLINE { E::set32(header.fields.reserved, value); }

	typedef typename P::E		E;
private:
	macho_header_content<P>	header;
};


//
// mach-o load command
//
template <typename P>
class macho_load_command {
public:
	uint32_t		cmd() const						INLINE { return E::get32(command.cmd); }
	void			set_cmd(uint32_t value)			INLINE { E::set32(command.cmd, value); }

	uint32_t		cmdsize() const					INLINE { return E::get32(command.cmdsize); }
	void			set_cmdsize(uint32_t value)		INLINE { E::set32(command.cmdsize, value); }

	typedef typename P::E		E;
private:
	load_command	command;
};


//
// mach-o segment load command
//
template <typename P> struct macho_segment_content {};
template <> struct macho_segment_content<Pointer32<BigEndian> >    { segment_command	fields; enum { CMD = LC_SEGMENT		}; };
template <> struct macho_segment_content<Pointer64<BigEndian> >	   { segment_command_64	fields; enum { CMD = LC_SEGMENT_64	}; };
template <> struct macho_segment_content<Pointer32<LittleEndian> > { segment_command	fields; enum { CMD = LC_SEGMENT		}; };
template <> struct macho_segment_content<Pointer64<LittleEndian> > { segment_command_64	fields; enum { CMD = LC_SEGMENT_64	}; };

template <typename P>
class macho_segment_command {
public:
	uint32_t		cmd() const						INLINE { return E::get32(segment.fields.cmd); }
	void			set_cmd(uint32_t value)			INLINE { E::set32(segment.fields.cmd, value); }

	uint32_t		cmdsize() const					INLINE { return E::get32(segment.fields.cmdsize); }
	void			set_cmdsize(uint32_t value)		INLINE { E::set32(segment.fields.cmdsize, value); }

	const char*		segname() const					INLINE { return segment.fields.segname; }
	void			set_segname(const char* value)	INLINE { strncpy(segment.fields.segname, value, 16); }
	
	uint64_t		vmaddr() const					INLINE { return P::getP(segment.fields.vmaddr); }
	void			set_vmaddr(uint64_t value)		INLINE { P::setP(segment.fields.vmaddr, value); }

	uint64_t		vmsize() const					INLINE { return P::getP(segment.fields.vmsize); }
	void			set_vmsize(uint64_t value)		INLINE { P::setP(segment.fields.vmsize, value); }

	uint64_t		fileoff() const					INLINE { return P::getP(segment.fields.fileoff); }
	void			set_fileoff(uint64_t value)		INLINE { P::setP(segment.fields.fileoff, value); }

	uint64_t		filesize() const				INLINE { return P::getP(segment.fields.filesize); }
	void			set_filesize(uint64_t value)	INLINE { P::setP(segment.fields.filesize, value); }

	uint32_t		maxprot() const					INLINE { return E::get32(segment.fields.maxprot); }
	void			set_maxprot(uint32_t value)		INLINE { E::set32((uint32_t&)segment.fields.maxprot, value); }

	uint32_t		initprot() const				INLINE { return E::get32(segment.fields.initprot); }
	void			set_initprot(uint32_t value)	INLINE { E::set32((uint32_t&)segment.fields.initprot, value); }

	uint32_t		nsects() const					INLINE { return E::get32(segment.fields.nsects); }
	void			set_nsects(uint32_t value)		INLINE { E::set32(segment.fields.nsects, value); }

	uint32_t		flags() const					INLINE { return E::get32(segment.fields.flags); }
	void			set_flags(uint32_t value)		INLINE { E::set32(segment.fields.flags, value); }

	enum {
		CMD = macho_segment_content<P>::CMD
	};

	typedef typename P::E		E;
private:
	macho_segment_content<P>	segment;
};


//
// mach-o section 
//
template <typename P> struct macho_section_content {};
template <> struct macho_section_content<Pointer32<BigEndian> >    { section	fields; };
template <> struct macho_section_content<Pointer64<BigEndian> >	   { section_64	fields; };
template <> struct macho_section_content<Pointer32<LittleEndian> > { section	fields; };
template <> struct macho_section_content<Pointer64<LittleEndian> > { section_64	fields; };

template <typename P>
class macho_section {
public:
	const char*		sectname() const				INLINE { return section.fields.sectname; }
	void			set_sectname(const char* value)	INLINE { strncpy(section.fields.sectname, value, 16); }
	
	const char*		segname() const					INLINE { return section.fields.segname; }
	void			set_segname(const char* value)	INLINE { strncpy(section.fields.segname, value, 16); }
	
	uint64_t		addr() const					INLINE { return P::getP(section.fields.addr); }
	void			set_addr(uint64_t value)		INLINE { P::setP(section.fields.addr, value); }

	uint64_t		size() const					INLINE { return P::getP(section.fields.size); }
	void			set_size(uint64_t value)		INLINE { P::setP(section.fields.size, value); }

	uint32_t		offset() const					INLINE { return E::get32(section.fields.offset); }
	void			set_offset(uint32_t value)		INLINE { E::set32(section.fields.offset, value); }

	uint32_t		align() const					INLINE { return E::get32(section.fields.align); }
	void			set_align(uint32_t value)		INLINE { E::set32(section.fields.align, value); }

	uint32_t		reloff() const					INLINE { return E::get32(section.fields.reloff); }
	void			set_reloff(uint32_t value)		INLINE { E::set32(section.fields.reloff, value); }

	uint32_t		nreloc() const					INLINE { return E::get32(section.fields.nreloc); }
	void			set_nreloc(uint32_t value)		INLINE { E::set32(section.fields.nreloc, value); }

	uint32_t		flags() const					INLINE { return E::get32(section.fields.flags); }
	void			set_flags(uint32_t value)		INLINE { E::set32(section.fields.flags, value); }

	uint32_t		reserved1() const				INLINE { return E::get32(section.fields.reserved1); }
	void			set_reserved1(uint32_t value)	INLINE { E::set32(section.fields.reserved1, value); }

	uint32_t		reserved2() const				INLINE { return E::get32(section.fields.reserved2); }
	void			set_reserved2(uint32_t value)	INLINE { E::set32(section.fields.reserved2, value); }

	typedef typename P::E		E;
private:
	macho_section_content<P>	section;
};


//
// mach-o dylib load command
//
template <typename P>
class macho_dylib_command {
public:
	uint32_t		cmd() const									INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)						INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const								INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)					INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		name_offset() const							INLINE { return E::get32(fields.dylib.name.offset); }
	void			set_name_offset(uint32_t value)				INLINE { E::set32(fields.dylib.name.offset, value);  }
	
	uint32_t		timestamp() const							INLINE { return E::get32(fields.dylib.timestamp); }
	void			set_timestamp(uint32_t value)				INLINE { E::set32(fields.dylib.timestamp, value); }

	uint32_t		current_version() const						INLINE { return E::get32(fields.dylib.current_version); }
	void			set_current_version(uint32_t value)			INLINE { E::set32(fields.dylib.current_version, value); }

	uint32_t		compatibility_version() const				INLINE { return E::get32(fields.dylib.compatibility_version); }
	void			set_compatibility_version(uint32_t value)	INLINE { E::set32(fields.dylib.compatibility_version, value); }

	const char*		name() const								INLINE { return (const char*)&fields + name_offset(); }
	void			set_name_offset()							INLINE { set_name_offset(sizeof(fields)); }
	
	typedef typename P::E		E;
private:
	dylib_command	fields;
};


//
// mach-o dylinker load command
//
template <typename P>
class macho_dylinker_command {
public:
	uint32_t		cmd() const							INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)				INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const						INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)			INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		name_offset() const					INLINE { return E::get32(fields.name.offset); }
	void			set_name_offset(uint32_t value)		INLINE { E::set32(fields.name.offset, value);  }
	
	const char*		name() const						INLINE { return (const char*)&fields + name_offset(); }
	void			set_name_offset()					INLINE { set_name_offset(sizeof(fields)); }
	
	typedef typename P::E		E;
private:
	dylinker_command	fields;
};


//
// mach-o sub_framework load command
//
template <typename P>
class macho_sub_framework_command {
public:
	uint32_t		cmd() const							INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)				INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const						INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)			INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		umbrella_offset() const				INLINE { return E::get32(fields.umbrella.offset); }
	void			set_umbrella_offset(uint32_t value)	INLINE { E::set32(fields.umbrella.offset, value);  }
	
	const char*		umbrella() const					INLINE { return (const char*)&fields + umbrella_offset(); }
	void			set_umbrella_offset()				INLINE { set_umbrella_offset(sizeof(fields)); }
		
	typedef typename P::E		E;
private:
	sub_framework_command	fields;
};


//
// mach-o sub_client load command
//
template <typename P>
class macho_sub_client_command {
public:
	uint32_t		cmd() const							INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)				INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const						INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)			INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		client_offset() const				INLINE { return E::get32(fields.client.offset); }
	void			set_client_offset(uint32_t value)	INLINE { E::set32(fields.client.offset, value);  }
	
	const char*		client() const						INLINE { return (const char*)&fields + client_offset(); }
	void			set_client_offset()					INLINE { set_client_offset(sizeof(fields)); }
		
	typedef typename P::E		E;
private:
	sub_client_command	fields;
};


//
// mach-o sub_umbrella load command
//
template <typename P>
class macho_sub_umbrella_command {
public:
	uint32_t		cmd() const								INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)					INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const							INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)				INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		sub_umbrella_offset() const				INLINE { return E::get32(fields.sub_umbrella.offset); }
	void			set_sub_umbrella_offset(uint32_t value)	INLINE { E::set32(fields.sub_umbrella.offset, value);  }
	
	const char*		sub_umbrella() const					INLINE { return (const char*)&fields + sub_umbrella_offset(); }
	void			set_sub_umbrella_offset()				INLINE { set_sub_umbrella_offset(sizeof(fields)); }
		
	typedef typename P::E		E;
private:
	sub_umbrella_command	fields;
};


//
// mach-o sub_library load command
//
template <typename P>
class macho_sub_library_command {
public:
	uint32_t		cmd() const								INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)					INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const							INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)				INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		sub_library_offset() const				INLINE { return E::get32(fields.sub_library.offset); }
	void			set_sub_library_offset(uint32_t value)	INLINE { E::set32(fields.sub_library.offset, value);  }
	
	const char*		sub_library() const						INLINE { return (const char*)&fields + sub_library_offset(); }
	void			set_sub_library_offset()				INLINE { set_sub_library_offset(sizeof(fields)); }
		
	typedef typename P::E		E;
private:
	sub_library_command	fields;
};


//
// mach-o uuid load command
//
template <typename P>
class macho_uuid_command {
public:
	uint32_t		cmd() const								INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)					INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const							INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)				INLINE { E::set32(fields.cmdsize, value); }

	const uint8_t*	uuid() const							INLINE { return fields.uuid; }
	void			set_uuid(const uint8_t u[16])			INLINE { memcpy(&fields.uuid, u, 16); }
			
	typedef typename P::E		E;
private:
	uuid_command	fields;
};


//
// mach-o routines load command
//
template <typename P> struct macho_routines_content {};
template <> struct macho_routines_content<Pointer32<BigEndian> >    { routines_command		fields; enum { CMD = LC_ROUTINES	}; };
template <> struct macho_routines_content<Pointer64<BigEndian> >	{ routines_command_64	fields; enum { CMD = LC_ROUTINES_64	}; };
template <> struct macho_routines_content<Pointer32<LittleEndian> > { routines_command		fields; enum { CMD = LC_ROUTINES	}; };
template <> struct macho_routines_content<Pointer64<LittleEndian> > { routines_command_64	fields; enum { CMD = LC_ROUTINES_64	}; };

template <typename P>
class macho_routines_command {
public:
	uint32_t		cmd() const							INLINE { return E::get32(routines.fields.cmd); }
	void			set_cmd(uint32_t value)				INLINE { E::set32(routines.fields.cmd, value); }

	uint32_t		cmdsize() const						INLINE { return E::get32(routines.fields.cmdsize); }
	void			set_cmdsize(uint32_t value)			INLINE { E::set32(routines.fields.cmdsize, value); }

	uint64_t		init_address() const				INLINE { return P::getP(routines.fields.init_address); }
	void			set_init_address(uint64_t value)	INLINE { P::setP(routines.fields.init_address, value); }

	uint64_t		init_module() const					INLINE { return P::getP(routines.fields.init_module); }
	void			set_init_module(uint64_t value)		INLINE { P::setP(routines.fields.init_module, value); }

	uint64_t		reserved1() const					INLINE { return P::getP(routines.fields.reserved1); }
	void			set_reserved1(uint64_t value)		INLINE { P::setP(routines.fields.reserved1, value); }
	
	uint64_t		reserved2() const					INLINE { return P::getP(routines.fields.reserved2); }
	void			set_reserved2(uint64_t value)		INLINE { P::setP(routines.fields.reserved2, value); }
	
	uint64_t		reserved3() const					INLINE { return P::getP(routines.fields.reserved3); }
	void			set_reserved3(uint64_t value)		INLINE { P::setP(routines.fields.reserved3, value); }
	
	uint64_t		reserved4() const					INLINE { return P::getP(routines.fields.reserved4); }
	void			set_reserved4(uint64_t value)		INLINE { P::setP(routines.fields.reserved4, value); }
	
	uint64_t		reserved5() const					INLINE { return P::getP(routines.fields.reserved5); }
	void			set_reserved5(uint64_t value)		INLINE { P::setP(routines.fields.reserved5, value); }
	
	uint64_t		reserved6() const					INLINE { return P::getP(routines.fields.reserved6); }
	void			set_reserved6(uint64_t value)		INLINE { P::setP(routines.fields.reserved6, value); }
	
	typedef typename P::E		E;
	enum {
		CMD = macho_routines_content<P>::CMD
	};
private:
	macho_routines_content<P>	routines;
};


//
// mach-o symbol table load command
//
template <typename P>
class macho_symtab_command {
public:
	uint32_t		cmd() const					INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)		INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const				INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)	INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		symoff() const				INLINE { return E::get32(fields.symoff); }
	void			set_symoff(uint32_t value)	INLINE { E::set32(fields.symoff, value);  }
	
	uint32_t		nsyms() const				INLINE { return E::get32(fields.nsyms); }
	void			set_nsyms(uint32_t value)	INLINE { E::set32(fields.nsyms, value);  }
	
	uint32_t		stroff() const				INLINE { return E::get32(fields.stroff); }
	void			set_stroff(uint32_t value)	INLINE { E::set32(fields.stroff, value);  }
	
	uint32_t		strsize() const				INLINE { return E::get32(fields.strsize); }
	void			set_strsize(uint32_t value)	INLINE { E::set32(fields.strsize, value);  }
	
	
	typedef typename P::E		E;
private:
	symtab_command	fields;
};


//
// mach-o dynamic symbol table load command
//
template <typename P>
class macho_dysymtab_command {
public:
	uint32_t		cmd() const							INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)				INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const						INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)			INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		ilocalsym() const					INLINE { return E::get32(fields.ilocalsym); }
	void			set_ilocalsym(uint32_t value)		INLINE { E::set32(fields.ilocalsym, value);  }
	
	uint32_t		nlocalsym() const					INLINE { return E::get32(fields.nlocalsym); }
	void			set_nlocalsym(uint32_t value)		INLINE { E::set32(fields.nlocalsym, value);  }
	
	uint32_t		iextdefsym() const					INLINE { return E::get32(fields.iextdefsym); }
	void			set_iextdefsym(uint32_t value)		INLINE { E::set32(fields.iextdefsym, value);  }
	
	uint32_t		nextdefsym() const					INLINE { return E::get32(fields.nextdefsym); }
	void			set_nextdefsym(uint32_t value)		INLINE { E::set32(fields.nextdefsym, value);  }
	
	uint32_t		iundefsym() const					INLINE { return E::get32(fields.iundefsym); }
	void			set_iundefsym(uint32_t value)		INLINE { E::set32(fields.iundefsym, value);  }
	
	uint32_t		nundefsym() const					INLINE { return E::get32(fields.nundefsym); }
	void			set_nundefsym(uint32_t value)		INLINE { E::set32(fields.nundefsym, value);  }
	
	uint32_t		tocoff() const						INLINE { return E::get32(fields.tocoff); }
	void			set_tocoff(uint32_t value)			INLINE { E::set32(fields.tocoff, value);  }
	
	uint32_t		ntoc() const						INLINE { return E::get32(fields.ntoc); }
	void			set_ntoc(uint32_t value)			INLINE { E::set32(fields.ntoc, value);  }
	
	uint32_t		modtaboff() const					INLINE { return E::get32(fields.modtaboff); }
	void			set_modtaboff(uint32_t value)		INLINE { E::set32(fields.modtaboff, value);  }
	
	uint32_t		nmodtab() const						INLINE { return E::get32(fields.nmodtab); }
	void			set_nmodtab(uint32_t value)			INLINE { E::set32(fields.nmodtab, value);  }
	
	uint32_t		extrefsymoff() const				INLINE { return E::get32(fields.extrefsymoff); }
	void			set_extrefsymoff(uint32_t value)	INLINE { E::set32(fields.extrefsymoff, value);  }
	
	uint32_t		nextrefsyms() const					INLINE { return E::get32(fields.nextrefsyms); }
	void			set_nextrefsyms(uint32_t value)		INLINE { E::set32(fields.nextrefsyms, value);  }
	
	uint32_t		indirectsymoff() const				INLINE { return E::get32(fields.indirectsymoff); }
	void			set_indirectsymoff(uint32_t value)	INLINE { E::set32(fields.indirectsymoff, value);  }
	
	uint32_t		nindirectsyms() const				INLINE { return E::get32(fields.nindirectsyms); }
	void			set_nindirectsyms(uint32_t value)	INLINE { E::set32(fields.nindirectsyms, value);  }
	
	uint32_t		extreloff() const					INLINE { return E::get32(fields.extreloff); }
	void			set_extreloff(uint32_t value)		INLINE { E::set32(fields.extreloff, value);  }
	
	uint32_t		nextrel() const						INLINE { return E::get32(fields.nextrel); }
	void			set_nextrel(uint32_t value)			INLINE { E::set32(fields.nextrel, value);  }
	
	uint32_t		locreloff() const					INLINE { return E::get32(fields.locreloff); }
	void			set_locreloff(uint32_t value)		INLINE { E::set32(fields.locreloff, value);  }
	
	uint32_t		nlocrel() const						INLINE { return E::get32(fields.nlocrel); }
	void			set_nlocrel(uint32_t value)			INLINE { E::set32(fields.nlocrel, value);  }
	
	typedef typename P::E		E;
private:
	dysymtab_command	fields;
};




//
// mach-o module table entry (for compatibility with old ld/dyld)
//
template <typename P> struct macho_dylib_module_content {};
template <> struct macho_dylib_module_content<Pointer32<BigEndian> >    { struct dylib_module		fields; };
template <> struct macho_dylib_module_content<Pointer32<LittleEndian> > { struct dylib_module		fields; };
template <> struct macho_dylib_module_content<Pointer64<BigEndian> >    { struct dylib_module_64	fields; };
template <> struct macho_dylib_module_content<Pointer64<LittleEndian> > { struct dylib_module_64	fields; };

template <typename P>
class macho_dylib_module {
public:
	uint32_t		module_name() const				INLINE { return E::get32(module.fields.module_name); }
	void			set_module_name(uint32_t value)	INLINE { E::set32(module.fields.module_name, value);  }
	
	uint32_t		iextdefsym() const				INLINE { return E::get32(module.fields.iextdefsym); }
	void			set_iextdefsym(uint32_t value)	INLINE { E::set32(module.fields.iextdefsym, value);  }
	
	uint32_t		nextdefsym() const				INLINE { return E::get32(module.fields.nextdefsym); }
	void			set_nextdefsym(uint32_t value)	INLINE { E::set32(module.fields.nextdefsym, value);  }
	
	uint32_t		irefsym() const					INLINE { return E::get32(module.fields.irefsym); }
	void			set_irefsym(uint32_t value)		INLINE { E::set32(module.fields.irefsym, value);  }
	
	uint32_t		nrefsym() const					INLINE { return E::get32(module.fields.nrefsym); }
	void			set_nrefsym(uint32_t value)		INLINE { E::set32(module.fields.nrefsym, value);  }
	
	uint32_t		ilocalsym() const				INLINE { return E::get32(module.fields.ilocalsym); }
	void			set_ilocalsym(uint32_t value)	INLINE { E::set32(module.fields.ilocalsym, value);  }
	
	uint32_t		nlocalsym() const				INLINE { return E::get32(module.fields.nlocalsym); }
	void			set_nlocalsym(uint32_t value)	INLINE { E::set32(module.fields.nlocalsym, value);  }
	
	uint32_t		iextrel() const					INLINE { return E::get32(module.fields.iextrel); }
	void			set_iextrel(uint32_t value)		INLINE { E::set32(module.fields.iextrel, value);  }
	
	uint32_t		nextrel() const					INLINE { return E::get32(module.fields.nextrel); }
	void			set_nextrel(uint32_t value)		INLINE { E::set32(module.fields.nextrel, value);  }
	
	uint16_t		iinit() const					INLINE { return E::get32(module.fields.iinit_iterm) & 0xFFFF; }
	uint16_t		iterm() const					INLINE { return E::get32(module.fields.iinit_iterm) > 16; }
	void			set_iinit_iterm(uint16_t init, uint16_t term)	INLINE { E::set32(module.fields.iinit_iterm, (term<<16) | (init &0xFFFF));  }
	
	uint16_t		ninit() const					INLINE { return E::get32(module.fields.ninit_nterm) & 0xFFFF; }
	uint16_t		nterm() const					INLINE { return E::get32(module.fields.ninit_nterm) > 16; }
	void			set_ninit_nterm(uint16_t init, uint16_t term)	INLINE { E::set32(module.fields.ninit_nterm, (term<<16) | (init &0xFFFF));  }
	
	uint64_t		objc_module_info_addr() const				INLINE { return P::getP(module.fields.objc_module_info_addr); }
	void			set_objc_module_info_addr(uint64_t value)	INLINE { P::setP(module.fields.objc_module_info_addr, value);  }
	
	uint32_t		objc_module_info_size() const				INLINE { return E::get32(module.fields.objc_module_info_size); }
	void			set_objc_module_info_size(uint32_t value)	INLINE { E::set32(module.fields.objc_module_info_size, value);  }
	
	
	typedef typename P::E		E;
private:
	macho_dylib_module_content<P>	module;
};


//
// mach-o dylib_reference entry
//
template <typename P>
class macho_dylib_reference {
public:
	uint32_t		isym() const				INLINE { return E::getBits(fields, 0, 24); }
	void			set_isym(uint32_t value)	INLINE { E::setBits(fields, value, 0, 24); }
	
	uint8_t			flags() const				INLINE { return E::getBits(fields, 24, 8); }
	void			set_flags(uint8_t value)	INLINE { E::setBits(fields, value, 24, 8); }
	
	typedef typename P::E		E;
private:
	uint32_t		fields;
};



//
// mach-o two-level hints load command
//
template <typename P>
class macho_dylib_table_of_contents {
public:
	uint32_t		symbol_index() const				INLINE { return E::get32(fields.symbol_index); }
	void			set_symbol_index(uint32_t value)	INLINE { E::set32(fields.symbol_index, value); }

	uint32_t		module_index() const				INLINE { return E::get32(fields.module_index); }
	void			set_module_index(uint32_t value)	INLINE { E::set32(fields.module_index, value);  }
		
	typedef typename P::E		E;
private:
	dylib_table_of_contents	fields;
};



//
// mach-o two-level hints load command
//
template <typename P>
class macho_twolevel_hints_command {
public:
	uint32_t		cmd() const					INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)		INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const				INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)	INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		offset() const				INLINE { return E::get32(fields.offset); }
	void			set_offset(uint32_t value)	INLINE { E::set32(fields.offset, value);  }
	
	uint32_t		nhints() const				INLINE { return E::get32(fields.nhints); }
	void			set_nhints(uint32_t value)	INLINE { E::set32(fields.nhints, value);  }
	
	typedef typename P::E		E;
private:
	twolevel_hints_command	fields;
};


//
// mach-o threads load command
//
template <typename P>
class macho_thread_command {
public:
	uint32_t		cmd() const											INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)								INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const										INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)							INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		flavor() const										INLINE { return E::get32(fields_flavor); }
	void			set_flavor(uint32_t value)							INLINE { E::set32(fields_flavor, value);  }
	
	uint32_t		count() const										INLINE { return E::get32(fields_count); }
	void			set_count(uint32_t value)							INLINE { E::set32(fields_count, value);  }
	
	uint64_t		thread_register(uint32_t index) const				INLINE { return P::getP(thread_registers[index]); }
	void			set_thread_register(uint32_t index, uint64_t value)	INLINE { P::setP(thread_registers[index], value); }
	
	typedef typename P::E		E;
	typedef typename P::uint_t	pint_t;
private:
	struct thread_command	fields;
	uint32_t				fields_flavor;
	uint32_t				fields_count;
	pint_t					thread_registers[1];
};


//
// mach-o misc data 
//
template <typename P>
class macho_linkedit_data_command {
public:
	uint32_t		cmd() const					INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)		INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const				INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)	INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		dataoff() const				INLINE { return E::get32(fields.dataoff); }
	void			set_dataoff(uint32_t value)	INLINE { E::set32(fields.dataoff, value);  }
	
	uint32_t		datasize() const			INLINE { return E::get32(fields.datasize); }
	void			set_datasize(uint32_t value)INLINE { E::set32(fields.datasize, value);  }
	
	
	typedef typename P::E		E;
private:
	struct linkedit_data_command	fields;
};


//
// mach-o rpath  
//
template <typename P>
class macho_rpath_command {
public:
	uint32_t		cmd() const						INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)			INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const					INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)		INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		path_offset() const				INLINE { return E::get32(fields.path.offset); }
	void			set_path_offset(uint32_t value)	INLINE { E::set32(fields.path.offset, value);  }
	
	const char*		path() const					INLINE { return (const char*)&fields + path_offset(); }
	void			set_path_offset()				INLINE { set_path_offset(sizeof(fields)); }
	
	
	typedef typename P::E		E;
private:
	struct rpath_command	fields;
};



//
// mach-o symbol table entry 
//
template <typename P> struct macho_nlist_content {};
template <> struct macho_nlist_content<Pointer32<BigEndian> >    { struct nlist		fields; };
template <> struct macho_nlist_content<Pointer64<BigEndian> >	 { struct nlist_64	fields; };
template <> struct macho_nlist_content<Pointer32<LittleEndian> > { struct nlist		fields; };
template <> struct macho_nlist_content<Pointer64<LittleEndian> > { struct nlist_64	fields; };

template <typename P>
class macho_nlist {
public:
	uint32_t		n_strx() const					INLINE { return E::get32(entry.fields.n_un.n_strx); }
	void			set_n_strx(uint32_t value)		INLINE { E::set32((uint32_t&)entry.fields.n_un.n_strx, value); }

	uint8_t			n_type() const					INLINE { return entry.fields.n_type; }
	void			set_n_type(uint8_t value)		INLINE { entry.fields.n_type = value; }

	uint8_t			n_sect() const					INLINE { return entry.fields.n_sect; }
	void			set_n_sect(uint8_t value)		INLINE { entry.fields.n_sect = value; }

	uint16_t		n_desc() const					INLINE { return E::get16(entry.fields.n_desc); }
	void			set_n_desc(uint16_t value)		INLINE { E::set16((uint16_t&)entry.fields.n_desc, value); }

	uint64_t		n_value() const					INLINE { return P::getP(entry.fields.n_value); }
	void			set_n_value(uint64_t value)		INLINE { P::setP(entry.fields.n_value, value); }

	typedef typename P::E		E;
private:
	macho_nlist_content<P>	entry;
};



//
// mach-o relocation info
//
template <typename P>
class macho_relocation_info {
public:
	uint32_t		r_address() const				INLINE { return E::get32(address); }
	void			set_r_address(uint32_t value)	INLINE { E::set32(address, value); }

	uint32_t		r_symbolnum() const				INLINE { return E::getBits(other, 0, 24); }
	void			set_r_symbolnum(uint32_t value) INLINE { E::setBits(other, value, 0, 24); }

	bool			r_pcrel() const					INLINE { return E::getBits(other, 24, 1); }
	void			set_r_pcrel(bool value)			INLINE { E::setBits(other, value, 24, 1); }	
	
	uint8_t			r_length() const				INLINE { return E::getBits(other, 25, 2); }
	void			set_r_length(uint8_t value)		INLINE { E::setBits(other, value, 25, 2); }
	
	bool			r_extern() const				INLINE { return E::getBits(other, 27, 1); }
	void			set_r_extern(bool value)		INLINE { E::setBits(other, value, 27, 1); }
	
	uint8_t			r_type() const					INLINE { return E::getBits(other, 28, 4); }
	void			set_r_type(uint8_t value)		INLINE { E::setBits(other, value, 28, 4); }
		
	void			set_r_length()					INLINE { set_r_length((sizeof(typename P::uint_t)==8) ? 3 : 2); }

	typedef typename P::E		E;
private:
	uint32_t		address;
	uint32_t		other;
};


//
// mach-o scattered relocation info
// The bit fields are always in big-endian order (see mach-o/reloc.h)
//
template <typename P>
class macho_scattered_relocation_info {
public:
	bool			r_scattered() const			INLINE { return BigEndian::getBitsRaw(E::get32(other), 0, 1); }
	void			set_r_scattered(bool x)		INLINE { uint32_t temp = E::get32(other); BigEndian::setBitsRaw(temp, x, 0, 1);  E::set32(other, temp); }

	bool			r_pcrel() const				INLINE { return BigEndian::getBitsRaw(E::get32(other), 1, 1); }
	void			set_r_pcrel(bool x)			INLINE { uint32_t temp = E::get32(other); BigEndian::setBitsRaw(temp, x, 1, 1);  E::set32(other, temp); }

	uint8_t			r_length() const			INLINE { return BigEndian::getBitsRaw(E::get32(other), 2, 2); }
	void			set_r_length(uint8_t x)		INLINE { uint32_t temp = E::get32(other); BigEndian::setBitsRaw(temp, x, 2, 2);  E::set32(other, temp); }

	uint8_t			r_type() const				INLINE { return BigEndian::getBitsRaw(E::get32(other), 4, 4); }
	void			set_r_type(uint8_t x)		INLINE { uint32_t temp = E::get32(other); BigEndian::setBitsRaw(temp, x, 4, 4);  E::set32(other, temp); }

	uint32_t		r_address() const			INLINE { return BigEndian::getBitsRaw(E::get32(other), 8, 24); }
	void			set_r_address(uint32_t x)			{ if ( x > 0x00FFFFFF ) throw "scattered reloc r_address too large"; 
														uint32_t temp = E::get32(other); BigEndian::setBitsRaw(temp, x, 8, 24);  E::set32(other, temp); }

	uint32_t		r_value() const				INLINE { return E::get32(value); }
	void			set_r_value(uint32_t x)		INLINE { E::set32(value, x); }

	uint32_t		r_other() const				INLINE { return other; }
	
	void			set_r_length()				INLINE { set_r_length((sizeof(typename P::uint_t)==8) ? 3 : 2); }

	typedef typename P::E		E;
private:
	uint32_t		other;
	uint32_t		value;
};



//
// mach-o encyrption info load command
//
template <typename P> struct macho_encryption_info_content {};
template <> struct macho_encryption_info_content<Pointer32<BigEndian> >    { struct encryption_info_command		fields; };
template <> struct macho_encryption_info_content<Pointer64<BigEndian> >	   { struct encryption_info_command_64	fields; };
template <> struct macho_encryption_info_content<Pointer32<LittleEndian> > { struct encryption_info_command		fields; };
template <> struct macho_encryption_info_content<Pointer64<LittleEndian> > { struct encryption_info_command_64	fields; };


template <typename P>
class macho_encryption_info_command {
public:
	uint32_t		cmd() const						INLINE { return E::get32(entry.fields.cmd); }
	void			set_cmd(uint32_t value)			INLINE { E::set32(entry.fields.cmd, value); }

	uint32_t		cmdsize() const					INLINE { return E::get32(entry.fields.cmdsize); }
	void			set_cmdsize(uint32_t value)		INLINE { E::set32(entry.fields.cmdsize, value); }

	uint32_t		cryptoff() const				INLINE { return E::get32(entry.fields.cryptoff); }
	void			set_cryptoff(uint32_t value)	INLINE { E::set32(entry.fields.cryptoff, value);  }
	
	uint32_t		cryptsize() const				INLINE { return E::get32(entry.fields.cryptsize); }
	void			set_cryptsize(uint32_t value)	INLINE { E::set32(entry.fields.cryptsize, value);  }
	
	uint32_t		cryptid() const					INLINE { return E::get32(entry.fields.cryptid); }
	void			set_cryptid(uint32_t value)		INLINE { E::set32(entry.fields.cryptid, value);  }
	
	uint32_t		pad() const						INLINE { return E::get32(entry.fields.pad); }
	void			set_pad(uint32_t value)			INLINE { E::set32(entry.fields.pad, value);  }

	typedef typename P::E		E;
private:
	macho_encryption_info_content<P>	entry;
};


//
// start of __unwind_info section  
//
template <typename P>
class macho_unwind_info_section_header {
public:
	uint32_t		version() const											INLINE { return E::get32(fields.version); }
	void			set_version(uint32_t value)								INLINE { E::set32(fields.version, value); }

	uint32_t		commonEncodingsArraySectionOffset() const				INLINE { return E::get32(fields.commonEncodingsArraySectionOffset); }
	void			set_commonEncodingsArraySectionOffset(uint32_t value)	INLINE { E::set32(fields.commonEncodingsArraySectionOffset, value); }

	uint32_t		commonEncodingsArrayCount() const						INLINE { return E::get32(fields.commonEncodingsArrayCount); }
	void			set_commonEncodingsArrayCount(uint32_t value)			INLINE { E::set32(fields.commonEncodingsArrayCount, value); }

	uint32_t		personalityArraySectionOffset() const					INLINE { return E::get32(fields.personalityArraySectionOffset); }
	void			set_personalityArraySectionOffset(uint32_t value)		INLINE { E::set32(fields.personalityArraySectionOffset, value); }

	uint32_t		personalityArrayCount() const							INLINE { return E::get32(fields.personalityArrayCount); }
	void			set_personalityArrayCount(uint32_t value)				INLINE { E::set32(fields.personalityArrayCount, value); }

	uint32_t		indexSectionOffset() const								INLINE { return E::get32(fields.indexSectionOffset); }
	void			set_indexSectionOffset(uint32_t value)					INLINE { E::set32(fields.indexSectionOffset, value); }

	uint32_t		indexCount() const										INLINE { return E::get32(fields.indexCount); }
	void			set_indexCount(uint32_t value)							INLINE { E::set32(fields.indexCount, value); }

	typedef typename P::E		E;
private:
	unwind_info_section_header	fields;
};



//
// uwind first level index entry  
//
template <typename P>
class macho_unwind_info_section_header_index_entry {
public:
	uint32_t		functionOffset() const								INLINE { return E::get32(fields.functionOffset); }
	void			set_functionOffset(uint32_t value)					INLINE { E::set32(fields.functionOffset, value); }

	uint32_t		secondLevelPagesSectionOffset() const				INLINE { return E::get32(fields.secondLevelPagesSectionOffset); }
	void			set_secondLevelPagesSectionOffset(uint32_t value)	INLINE { E::set32(fields.secondLevelPagesSectionOffset, value); }

	uint32_t		lsdaIndexArraySectionOffset() const					INLINE { return E::get32(fields.lsdaIndexArraySectionOffset); }
	void			set_lsdaIndexArraySectionOffset(uint32_t value)		INLINE { E::set32(fields.lsdaIndexArraySectionOffset, value); }

	typedef typename P::E		E;
private:
	unwind_info_section_header_index_entry	fields;
};


//
// LSDA table entry  
//
template <typename P>
class macho_unwind_info_section_header_lsda_index_entry {
public:
	uint32_t		functionOffset() const								INLINE { return E::get32(fields.functionOffset); }
	void			set_functionOffset(uint32_t value)					INLINE { E::set32(fields.functionOffset, value); }

	uint32_t		lsdaOffset() const									INLINE { return E::get32(fields.lsdaOffset); }
	void			set_lsdaOffset(uint32_t value)						INLINE { E::set32(fields.lsdaOffset, value); }

	typedef typename P::E		E;
private:
	unwind_info_section_header_lsda_index_entry	fields;
};


//
// regular second level entry  
//
template <typename P>
class macho_unwind_info_regular_second_level_entry {
public:
	uint32_t		functionOffset() const								INLINE { return E::get32(fields.functionOffset); }
	void			set_functionOffset(uint32_t value)					INLINE { E::set32(fields.functionOffset, value); }

	uint32_t		encoding() const									INLINE { return E::get32(fields.encoding); }
	void			set_encoding(uint32_t value)						INLINE { E::set32(fields.encoding, value); }

	typedef typename P::E		E;
private:
	unwind_info_regular_second_level_entry	fields;
};


//
// start of second level regular page  
//
template <typename P>
class macho_unwind_info_regular_second_level_page_header {
public:
	uint32_t		kind() const								INLINE { return E::get32(fields.kind); }
	void			set_kind(uint32_t value)					INLINE { E::set32(fields.kind, value); }

	uint16_t		entryPageOffset() const						INLINE { return E::get16(fields.entryPageOffset); }
	void			set_entryPageOffset(uint16_t value)			INLINE { E::set16((uint16_t&)fields.entryPageOffset, value); }

	uint16_t		entryCount() const							INLINE { return E::get16(fields.entryCount); }
	void			set_entryCount(uint16_t value)				INLINE { E::set16((uint16_t&)fields.entryCount, value); }

	typedef typename P::E		E;
private:
	unwind_info_regular_second_level_page_header	fields;
};


//
// start of second level compressed page  
//
template <typename P>
class macho_unwind_info_compressed_second_level_page_header {
public:
	uint32_t		kind() const								INLINE { return E::get32(fields.kind); }
	void			set_kind(uint32_t value)					INLINE { E::set32(fields.kind, value); }

	uint16_t		entryPageOffset() const						INLINE { return E::get16(fields.entryPageOffset); }
	void			set_entryPageOffset(uint16_t value)			INLINE { E::set16((uint16_t&)fields.entryPageOffset, value); }

	uint16_t		entryCount() const							INLINE { return E::get16(fields.entryCount); }
	void			set_entryCount(uint16_t value)				INLINE { E::set16((uint16_t&)fields.entryCount, value); }

	uint16_t		encodingsPageOffset() const					INLINE { return E::get16(fields.encodingsPageOffset); }
	void			set_encodingsPageOffset(uint16_t value)		INLINE { E::set16((uint16_t&)fields.encodingsPageOffset, value); }

	uint16_t		encodingsCount() const						INLINE { return E::get16(fields.encodingsCount); }
	void			set_encodingsCount(uint16_t value)			INLINE { E::set16((uint16_t&)fields.encodingsCount, value); }

	typedef typename P::E		E;
private:
	unwind_info_compressed_second_level_page_header	fields;
};


//
// compressed dyld info load command
//
template <typename P>
class macho_dyld_info_command {
public:
	uint32_t		cmd() const					INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)		INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const				INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)	INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		rebase_off() const				INLINE { return E::get32(fields.rebase_off); }
	void			set_rebase_off(uint32_t value)	INLINE { E::set32(fields.rebase_off, value);  }
	
	uint32_t		rebase_size() const				INLINE { return E::get32(fields.rebase_size); }
	void			set_rebase_size(uint32_t value)	INLINE { E::set32(fields.rebase_size, value);  }
	
	uint32_t		bind_off() const				INLINE { return E::get32(fields.bind_off); }
	void			set_bind_off(uint32_t value)	INLINE { E::set32(fields.bind_off, value);  }
	
	uint32_t		bind_size() const				INLINE { return E::get32(fields.bind_size); }
	void			set_bind_size(uint32_t value)	INLINE { E::set32(fields.bind_size, value);  }
	
	uint32_t		weak_bind_off() const				INLINE { return E::get32(fields.weak_bind_off); }
	void			set_weak_bind_off(uint32_t value)	INLINE { E::set32(fields.weak_bind_off, value);  }
	
	uint32_t		weak_bind_size() const				INLINE { return E::get32(fields.weak_bind_size); }
	void			set_weak_bind_size(uint32_t value)	INLINE { E::set32(fields.weak_bind_size, value);  }
	
	uint32_t		lazy_bind_off() const				INLINE { return E::get32(fields.lazy_bind_off); }
	void			set_lazy_bind_off(uint32_t value)	INLINE { E::set32(fields.lazy_bind_off, value);  }
	
	uint32_t		lazy_bind_size() const				INLINE { return E::get32(fields.lazy_bind_size); }
	void			set_lazy_bind_size(uint32_t value)	INLINE { E::set32(fields.lazy_bind_size, value);  }
	
	uint32_t		export_off() const				INLINE { return E::get32(fields.export_off); }
	void			set_export_off(uint32_t value)	INLINE { E::set32(fields.export_off, value);  }
	
	uint32_t		export_size() const				INLINE { return E::get32(fields.export_size); }
	void			set_export_size(uint32_t value)	INLINE { E::set32(fields.export_size, value);  }
	
	
	typedef typename P::E		E;
private:
	dyld_info_command	fields;
};


//
// mach-o version load command
//
template <typename P>
class macho_version_min_command {
public:
	uint32_t		cmd() const								INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)					INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const							INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)				INLINE { E::set32(fields.cmdsize, value); }

	uint32_t		version() const							INLINE { return fields.version; }
	void			set_version(uint32_t value)				INLINE { E::set32(fields.version, value); }

#ifdef DICE_KIND_DATA
	uint32_t		sdk() const								INLINE { return fields.sdk; }
	void			set_sdk(uint32_t value)					INLINE { E::set32(fields.sdk, value); }
#else
	uint32_t		sdk() const								INLINE { return fields.reserved; }
	void			set_sdk(uint32_t value)					INLINE { E::set32(fields.reserved, value); }
#endif

	typedef typename P::E		E;
private:
	version_min_command	fields;
};


//
// mach-o __LD, __compact_unwind section in object files
//
template <typename P>
class macho_compact_unwind_entry {
public:
	typedef typename P::E		E;
	typedef typename P::uint_t	pint_t;

	pint_t			codeStart() const						INLINE { return P::getP(_codeStart); }
	void			set_codeStart(pint_t value)				INLINE { P::setP(_codeStart, value); }

	uint32_t		codeLen() const							INLINE { return E::get32(_codeLen); }
	void			set_codeLen(uint32_t value)				INLINE { E::set32(_codeLen, value); }

	uint32_t		compactUnwindInfo() const				INLINE { return E::get32(_compactUnwindInfo); }
	void			set_compactUnwindInfo(uint32_t value)	INLINE { E::set32(_compactUnwindInfo, value);  }
	
	pint_t			personality() const						INLINE { return P::getP(_personality); }
	void			set_personality(pint_t value)			INLINE { P::setP(_personality, value);  }
	
	pint_t			lsda() const							INLINE { return P::getP(_lsda); }
	void			set_lsda(pint_t value)					INLINE { P::setP(_lsda, value);  }
	
	static uint32_t	codeStartFieldOffset()					INLINE { return offsetof(macho_compact_unwind_entry<P>,_codeStart); }
	static uint32_t	personalityFieldOffset()				INLINE { return offsetof(macho_compact_unwind_entry<P>,_personality); }
	static uint32_t	lsdaFieldOffset()						INLINE { return offsetof(macho_compact_unwind_entry<P>,_lsda); }
	
private:
	pint_t		_codeStart;
	uint32_t	_codeLen;
	uint32_t	_compactUnwindInfo;
	pint_t		_personality;
	pint_t		_lsda;
};


//
// mach-o source version load command
//
template <typename P>
class macho_source_version_command {
public:
	uint32_t		cmd() const								INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)					INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const							INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)				INLINE { E::set32(fields.cmdsize, value); }

	uint64_t		version() const							INLINE { return fields.version; }
	void			set_version(uint64_t value)				INLINE { E::set64(fields.version, value); }

	typedef typename P::E		E;
private:
	source_version_command	fields;
};


//
// mach-o source version load command
//
template <typename P>
class macho_entry_point_command {
public:
	uint32_t		cmd() const								INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)					INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const							INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)				INLINE { E::set32(fields.cmdsize, value); }

	uint64_t		entryoff() const						INLINE { return fields.entryoff; }
	void			set_entryoff(uint64_t value)			INLINE { E::set64(fields.entryoff, value); }

	uint64_t		stacksize() const						INLINE { return fields.stacksize; }
	void			set_stacksize(uint64_t value)			INLINE { E::set64(fields.stacksize, value); }

	typedef typename P::E		E;
private:
	entry_point_command	fields;
};



template <typename P>
class macho_data_in_code_entry {
public:
	uint32_t		offset() const								INLINE { return E::get32(fields.offset); }
	void			set_offset(uint32_t value)					INLINE { E::set32(fields.offset, value); }

	uint16_t		length() const								INLINE { return E::get16(fields.length); }
	void			set_length(uint16_t value)					INLINE { E::set16((uint16_t&)fields.length, value); }

	uint16_t		kind() const								INLINE { return E::get16(fields.kind); }
	void			set_kind(uint16_t value)					INLINE { E::set16((uint16_t&)fields.kind, value); }

	typedef typename P::E		E;
private:
	data_in_code_entry	fields;
};

#ifndef DICE_KIND_DATA
  #define DICE_KIND_DATA              0x0001 
  #define DICE_KIND_JUMP_TABLE8       0x0002 
  #define DICE_KIND_JUMP_TABLE16      0x0003 
  #define DICE_KIND_JUMP_TABLE32      0x0004 
  #define DICE_KIND_ABS_JUMP_TABLE32  0x0005 
#endif

template <typename P>
class macho_linker_option_command {
public:
	uint32_t		cmd() const								INLINE { return E::get32(fields.cmd); }
	void			set_cmd(uint32_t value)					INLINE { E::set32(fields.cmd, value); }

	uint32_t		cmdsize() const							INLINE { return E::get32(fields.cmdsize); }
	void			set_cmdsize(uint32_t value)				INLINE { E::set32(fields.cmdsize, value); }

	uint64_t		count() const							INLINE { return fields.count; }
	void			set_count(uint32_t value)				INLINE { E::set32(fields.count, value); }

	const char*		buffer() const							INLINE { return ((char*)&fields) + sizeof(linker_option_command); }
	char*			buffer()								INLINE { return ((char*)&fields) + sizeof(linker_option_command); }

	typedef typename P::E		E;
private:
	linker_option_command	fields;
};





#endif	// __MACH_O_FILE_ABSTRACTION__


                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/abstraction/MachOTrie.hpp          0100644 0001750 0001750 00000030046 12612724205 026637  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- 
 *
 * Copyright (c) 2008-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
*/
#ifndef __MACH_O_TRIE__
#define __MACH_O_TRIE__

#include <algorithm>
#include <assert.h>

#include "MachOFileAbstraction.hpp"


namespace mach_o {
namespace trie {

struct Edge
{
					Edge(const char* s, struct Node* n) : fSubString(s), fChild(n) { }
					~Edge() {  }
	const char*		fSubString;
	struct Node*	fChild;
	
};

struct Node
{
						Node(const char* s) : fCummulativeString(s), fAddress(0), fFlags(0), 
											fOther(0), fImportedName(NULL), fOrdered(false), 
											fHaveExportInfo(false), fTrieOffset(0) {}
						~Node() { }
	const char*			fCummulativeString;
	std::vector<Edge>	fChildren;
	uint64_t			fAddress;
	uint64_t			fFlags;
	uint64_t			fOther;
	const char*			fImportedName;
	bool				fOrdered;
	bool				fHaveExportInfo;
	uint32_t			fTrieOffset;
	
	void addSymbol(const char* fullStr, uint64_t address, uint64_t flags, uint64_t other, const char* importName) {
		const char* partialStr = &fullStr[strlen(fCummulativeString)];
		for (std::vector<Edge>::iterator it = fChildren.begin(); it != fChildren.end(); ++it) {
			Edge& e = *it;
			int subStringLen = strlen(e.fSubString);
			if ( strncmp(e.fSubString, partialStr, subStringLen) == 0 ) {
				// already have matching edge, go down that path
				e.fChild->addSymbol(fullStr, address, flags, other, importName);
				return;
			}
			else {
				for (int i=subStringLen-1; i > 0; --i) {
					if ( strncmp(e.fSubString, partialStr, i) == 0 ) {
						// found a common substring, splice in new node
						//  was A -> C,  now A -> B -> C
						char* bNodeCummStr = strdup(e.fChild->fCummulativeString);
						bNodeCummStr[strlen(bNodeCummStr)+i-subStringLen] = '\0';
						//node* aNode = this;
						Node* bNode = new Node(bNodeCummStr);
						Node* cNode = e.fChild;
						char* abEdgeStr = strdup(e.fSubString);
						abEdgeStr[i] = '\0';
						char* bcEdgeStr = strdup(&e.fSubString[i]);
						Edge& abEdge = e;
						abEdge.fSubString = abEdgeStr;
						abEdge.fChild = bNode;
						Edge bcEdge(bcEdgeStr, cNode);
						bNode->fChildren.push_back(bcEdge);
						bNode->addSymbol(fullStr, address, flags, other, importName);
						return;
					}
				}
			}
		}
		if ( flags & EXPORT_SYMBOL_FLAGS_REEXPORT ) {
			assert(importName != NULL);
			assert(other != 0);
		}
		if ( flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER ) {
			assert(other != 0);
		}
		// no commonality with any existing child, make a new edge that is this whole string
		Node* newNode = new Node(strdup(fullStr));
		Edge newEdge(strdup(partialStr), newNode);
		fChildren.push_back(newEdge);
		newNode->fAddress = address;
		newNode->fFlags = flags;
		newNode->fOther = other;
		if ( (flags & EXPORT_SYMBOL_FLAGS_REEXPORT) && (importName != NULL) && (strcmp(fullStr,importName) != 0) )
			newNode->fImportedName = importName;
		else
			newNode->fImportedName = NULL;
		newNode->fHaveExportInfo = true;
	}
	
	void addOrderedNodes(const char* name, std::vector<Node*>& orderedNodes) {
		if ( !fOrdered ) {
			orderedNodes.push_back(this);
			//fprintf(stderr, "ordered %p %s\n", this, fCummulativeString);
			fOrdered = true;
		}
		const char* partialStr = &name[strlen(fCummulativeString)];
		for (std::vector<Edge>::iterator it = fChildren.begin(); it != fChildren.end(); ++it) {
			Edge& e = *it;
			int subStringLen = strlen(e.fSubString);
			if ( strncmp(e.fSubString, partialStr, subStringLen) == 0 ) {
				// already have matching edge, go down that path
				e.fChild->addOrderedNodes(name, orderedNodes);
				return;
			}
		}
	}

	// byte for terminal node size in bytes, or 0x00 if not terminal node
	// teminal node (uleb128 flags, uleb128 addr [uleb128 other])
	// byte for child node count
	//  each child: zero terminated substring, uleb128 node offset
	bool updateOffset(uint32_t& offset) {
		uint32_t nodeSize = 1; // length of export info when no export info
		if ( fHaveExportInfo ) {
			if ( fFlags & EXPORT_SYMBOL_FLAGS_REEXPORT ) {
				nodeSize = uleb128_size(fFlags) + uleb128_size(fOther); // ordinal
				if ( fImportedName != NULL )
					nodeSize += strlen(fImportedName);
				++nodeSize; // trailing zero in imported name
			}
			else {
				nodeSize = uleb128_size(fFlags) + uleb128_size(fAddress);
				if ( fFlags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER )
					nodeSize += uleb128_size(fOther);
			}
			// do have export info, overall node size so far is uleb128 of export info + export info
			nodeSize += uleb128_size(nodeSize); 
		}
		// add children
		++nodeSize; // byte for count of chidren
		for (std::vector<Edge>::iterator it = fChildren.begin(); it != fChildren.end(); ++it) {
			Edge& e = *it;
			nodeSize += strlen(e.fSubString) + 1 + uleb128_size(e.fChild->fTrieOffset);
		}
		bool result = (fTrieOffset != offset);
		fTrieOffset = offset;
		//fprintf(stderr, "updateOffset %p %05d %s\n", this, fTrieOffset, fCummulativeString);
		offset += nodeSize;
		// return true if fTrieOffset was changed
		return result;
	}

	void appendToStream(std::vector<uint8_t>& out) {
		if ( fHaveExportInfo ) {
			if ( fFlags & EXPORT_SYMBOL_FLAGS_REEXPORT ) {
				if ( fImportedName != NULL ) {
					// nodes with re-export info: size, flags, ordinal, string
					uint32_t nodeSize = uleb128_size(fFlags) + uleb128_size(fOther) + strlen(fImportedName) + 1;
					out.push_back(nodeSize);
					append_uleb128(fFlags, out);
					append_uleb128(fOther, out);
					append_string(fImportedName, out);
				}
				else {
					// nodes with re-export info: size, flags, ordinal, empty-string
					uint32_t nodeSize = uleb128_size(fFlags) + uleb128_size(fOther) + 1;
					out.push_back(nodeSize);
					append_uleb128(fFlags, out);
					append_uleb128(fOther, out);
					out.push_back(0);
				}
			}
			else if ( fFlags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER ) {
				// nodes with export info: size, flags, address, other
				uint32_t nodeSize = uleb128_size(fFlags) + uleb128_size(fAddress) + uleb128_size(fOther);
				out.push_back(nodeSize);
				append_uleb128(fFlags, out);
				append_uleb128(fAddress, out);
				append_uleb128(fOther, out);
			}
			else {
				// nodes with export info: size, flags, address
				uint32_t nodeSize = uleb128_size(fFlags) + uleb128_size(fAddress);
				out.push_back(nodeSize);
				append_uleb128(fFlags, out);
				append_uleb128(fAddress, out);
			}
		}
		else {
			// no export info uleb128 of zero is one byte of zero
			out.push_back(0);
		}
		// write number of children
		out.push_back(fChildren.size());
		// write each child
		for (std::vector<Edge>::iterator it = fChildren.begin(); it != fChildren.end(); ++it) {
			Edge& e = *it;
			append_string(e.fSubString, out);
			append_uleb128(e.fChild->fTrieOffset, out);
		}
	}
	
private:
	static void append_uleb128(uint64_t value, std::vector<uint8_t>& out) {
		uint8_t byte;
		do {
			byte = value & 0x7F;
			value &= ~0x7F;
			if ( value != 0 )
				byte |= 0x80;
			out.push_back(byte);
			value = value >> 7;
		} while( byte >= 0x80 );
	}
	
	static void append_string(const char* str, std::vector<uint8_t>& out) {
		for (const char* s = str; *s != '\0'; ++s)
			out.push_back(*s);
		out.push_back('\0');
	}
	
	static unsigned int	uleb128_size(uint64_t value) {
		uint32_t result = 0;
		do {
			value = value >> 7;
			++result;
		} while ( value != 0 );
		return result;
	}
	

};

inline uint64_t read_uleb128(const uint8_t*& p, const uint8_t* end) {
	uint64_t result = 0;
	int		 bit = 0;
	do {
		if (p == end)
			throw "malformed uleb128 extends beyond trie";

		uint64_t slice = *p & 0x7f;

		if (bit >= 64 || slice << bit >> bit != slice)
			throw "uleb128 too big for 64-bits";
		else {
			result |= (slice << bit);
			bit += 7;
		}
	} 
	while (*p++ & 0x80);
	return result;
}
	


struct Entry
{
	const char*		name;
	uint64_t		address;
	uint64_t		flags;
	uint64_t		other;
	const char*		importName;
};



inline void makeTrie(const std::vector<Entry>& entries, std::vector<uint8_t>& output)
{
	Node start(strdup(""));
	
	// make nodes for all exported symbols
	for (std::vector<Entry>::const_iterator it = entries.begin(); it != entries.end(); ++it) {
		start.addSymbol(it->name, it->address, it->flags, it->other, it->importName);
	}

	// create vector of nodes
	std::vector<Node*> orderedNodes;
	orderedNodes.reserve(entries.size()*2);
	for (std::vector<Entry>::const_iterator it = entries.begin(); it != entries.end(); ++it) {
		start.addOrderedNodes(it->name, orderedNodes);
	}
	
	// assign each node in the vector an offset in the trie stream, iterating until all uleb128 sizes have stabilized
	bool more;
	do {
		uint32_t offset = 0;
		more = false;
		for (std::vector<Node*>::iterator it = orderedNodes.begin(); it != orderedNodes.end(); ++it) {
			if ( (*it)->updateOffset(offset) )
				more = true;
		}
	} while ( more );
	
	// create trie stream
	for (std::vector<Node*>::iterator it = orderedNodes.begin(); it != orderedNodes.end(); ++it) {
		(*it)->appendToStream(output);
	}
}

struct EntryWithOffset
{
	uintptr_t		nodeOffset;
	Entry			entry;
	
	bool operator<(const EntryWithOffset& other) const { return ( nodeOffset < other.nodeOffset ); }
};



static inline void processExportNode(const uint8_t* const start, const uint8_t* p, const uint8_t* const end, 
									char* cummulativeString, int curStrOffset, 
									std::vector<EntryWithOffset>& output) 
{
	if ( p >= end )
		throw "malformed trie, node past end";
	const uint64_t terminalSize = read_uleb128(p, end);
	const uint8_t* children = p + terminalSize;
	if ( terminalSize != 0 ) {
		EntryWithOffset e;
		e.nodeOffset = p-start;
		e.entry.name = strdup(cummulativeString);
		e.entry.flags = read_uleb128(p, end);
		if ( e.entry.flags & EXPORT_SYMBOL_FLAGS_REEXPORT ) {
			e.entry.address = 0;
			e.entry.other = read_uleb128(p, end); // dylib ordinal
			e.entry.importName = (char*)p;
		}
		else {
			e.entry.address = read_uleb128(p, end); 
			if ( e.entry.flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER )
				e.entry.other = read_uleb128(p, end); 
			else
				e.entry.other = 0;
			e.entry.importName = NULL;
		}
		output.push_back(e);
	}
	const uint8_t childrenCount = *children++;
	const uint8_t* s = children;
	for (uint8_t i=0; i < childrenCount; ++i) {
		int edgeStrLen = 0;
		while (*s != '\0') {
			cummulativeString[curStrOffset+edgeStrLen] = *s++;
			++edgeStrLen;
		}
		cummulativeString[curStrOffset+edgeStrLen] = *s++;
		uint32_t childNodeOffset = read_uleb128(s, end);
		if (childNodeOffset == 0)
			throw "malformed trie, childNodeOffset==0";
		processExportNode(start, start+childNodeOffset, end, cummulativeString, curStrOffset+edgeStrLen, output);
	}
}


inline void parseTrie(const uint8_t* start, const uint8_t* end, std::vector<Entry>& output)
{
	// empty trie has no entries
	if ( start == end )
		return;
	// worst case largest exported symbol names is length of whole trie
	char* cummulativeString = new char[end-start]; 
	std::vector<EntryWithOffset> entries;
	processExportNode(start, start, end, cummulativeString, 0, entries);
	// to preserve tie layout order, sort by node offset
	std::sort(entries.begin(), entries.end());
	// copy to output
	output.reserve(entries.size());
	for (std::vector<EntryWithOffset>::iterator it=entries.begin(); it != entries.end(); ++it)
		output.push_back(it->entry);
	delete[] cummulativeString; // ld64-port: delete -> delete[]
}




}; // namespace trie
}; // namespace mach_o


#endif	// __MACH_O_TRIE__


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/compile_stubs.h                    0100644 0001750 0001750 00000000236 12612724205 025021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #include "configure.h"
//compile_stubs.h generated by xcode to dump compile_subs to a string.
//here we fake one.
static const char *compile_stubs ="Empty"; 
                                                                                                                                                                                                                                                                                                                                                                  osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/configure.h                        0100644 0001750 0001750 00000002247 12612724205 024136  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #ifndef _CONFIGURE_H
#define _CONFIGURE_H
#include <sys/param.h>
#include <limits.h>
#include <unistd.h>
#include <stddef.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

#include "strlcat.h"
#include "strlcpy.h"
#include "helper.h"

#ifdef __GLIBCXX__
#include <algorithm>
#endif

#define CPU_SUBTYPE_X86_ALL     ((cpu_subtype_t)3)

#define SUPPORT_ARCH_armv4t 1
#define SUPPORT_ARCH_armv5 1
#define SUPPORT_ARCH_armv6 1
#define SUPPORT_ARCH_armv7 1
#define SUPPORT_ARCH_armv7f 1
#define SUPPORT_ARCH_armv7k 1
#define SUPPORT_ARCH_armv7s 1
#define SUPPORT_ARCH_armv6m 1
#define SUPPORT_ARCH_armv7m 1
#define SUPPORT_ARCH_armv7em 1
#define SUPPORT_ARCH_armv8 1
#define SUPPORT_ARCH_arm64 1
#define SUPPORT_ARCH_arm64v8 1
#define SUPPORT_ARCH_i386 1
#define SUPPORT_ARCH_x86_64 1
#define SUPPORT_ARCH_x86_64h 1

#define SUPPORT_APPLE_TV 1

#define ALL_SUPPORTED_ARCHS  "armv4t armv5 armv6 armv7 armv7f armv7k armv7s armv6m armv7m armv7em armv8 arm64 arm64v8 i386 x86_64 x86_64h (tvOS)"

#define BITCODE_XAR_VERSION "1.0"

#ifndef HW_NCPU
#define HW_NCPU 3
#endif

#ifndef CTL_HW
#define CTL_HW  6
#endif

#ifndef ARG_MAX
#define ARG_MAX 31072
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/create_configure                   0100755 0001750 0001750 00000003615 12612724205 025236  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/bash

echo "" > ${DERIVED_FILE_DIR}/configure.h

if [ -n "${IPHONEOS_DEPLOYMENT_TARGET}" ]; then
	echo "#define DEFAULT_IPHONEOS_MIN_VERSION \"${IPHONEOS_DEPLOYMENT_TARGET}\"" >> ${DERIVED_FILE_DIR}/configure.h
else
  if [ -n "${MACOSX_DEPLOYMENT_TARGET}" ]; then
	echo "#define DEFAULT_MACOSX_MIN_VERSION \"${MACOSX_DEPLOYMENT_TARGET}\"" >> ${DERIVED_FILE_DIR}/configure.h
  fi
fi

if [ -z "${RC_SUPPORTED_ARCHS}" ]; then
	RC_SUPPORTED_ARCHS="i386 x86_64 x86_64h armv6 armv7 armv7s armv7m armv7k arm64"
fi

for ANARCH in ${RC_SUPPORTED_ARCHS}
do
	KNOWN_ARCHS=",armv4t,armv5,armv6,armv7,armv7f,armv7k,armv7s,armv6m,armv7m,armv7em,armv8,arm64,arm64v8,i386,x86_64,x86_64h,"
	FOUND=`echo "$KNOWN_ARCHS" | grep ",$ANARCH,"`
	if [ $FOUND ]; then
		echo "#define SUPPORT_ARCH_$ANARCH  1" >> ${DERIVED_FILE_DIR}/configure.h
	else
		echo "#error unknown architecture: $ANARCH" >> ${DERIVED_FILE_DIR}/configure.h
	fi
done

if [ -n "${RC_HIDE_TIDE}" ]; then
	echo "#define ALL_SUPPORTED_ARCHS  \"${RC_SUPPORTED_ARCHS}\"" >> ${DERIVED_FILE_DIR}/configure.h
	echo "#define SUPPORT_APPLE_TV 0" >> ${DERIVED_FILE_DIR}/configure.h
else
	if [ -n "${DT_VARIANT}" -a "${DT_VARIANT}" != "PONDEROSA" ]; then
		echo "#define ALL_SUPPORTED_ARCHS  \"${RC_SUPPORTED_ARCHS}\"" >> ${DERIVED_FILE_DIR}/configure.h
		echo "#define SUPPORT_APPLE_TV 0" >> ${DERIVED_FILE_DIR}/configure.h
	else
		echo "#define ALL_SUPPORTED_ARCHS  \"${RC_SUPPORTED_ARCHS} (tvOS)\"" >> ${DERIVED_FILE_DIR}/configure.h
		echo "#define SUPPORT_APPLE_TV 1" >> ${DERIVED_FILE_DIR}/configure.h
	fi
fi

if [ -f "${DT_TOOLCHAIN_DIR}/usr/lib/libswiftDemangle.dylib" ]; then
	echo "-Wl,-lazy_library,${DT_TOOLCHAIN_DIR}/usr/lib/libswiftDemangle.dylib" >  ${DERIVED_FILE_DIR}/linkExtras
	echo "#define DEMANGLE_SWIFT 1" >> ${DERIVED_FILE_DIR}/configure.h
else
	echo "" > ${DERIVED_FILE_DIR}/linkExtras
fi

echo "#define BITCODE_XAR_VERSION \"1.0\"" >> ${DERIVED_FILE_DIR}/configure.h
                                                                                                                   osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/ld/                                0040755 0001750 0001750 00000000000 13101127056 022374  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/ld/.dirstamp                       0100644 0000000 0000000 00000000000 13101127050 024143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/ld/.libs/                          0040755 0000000 0000000 00000000000 13101127046 023350  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/ld/Architectures.hpp               0100644 0001750 0001750 00000002727 12612724205 025724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- 
 *
 * Copyright (c) 2005-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
 
#ifndef __ARCHITECTURES__
#define __ARCHITECTURES__

#include "FileAbstraction.hpp"


//
// Architectures
//
struct ppc
{
	typedef Pointer32<BigEndian>		P;
};

struct ppc64
{
	typedef Pointer64<BigEndian>		P;
};

struct x86
{
	typedef Pointer32<LittleEndian>		P;
};

struct x86_64
{
	typedef Pointer64<LittleEndian>		P;
};

struct arm
{
	typedef Pointer32<LittleEndian>		P;
};

struct arm64
{
	typedef Pointer64<LittleEndian>		P;
};

#endif // __ARCHITECTURES__


                                         osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/ld/Bitcode.hpp                     0100644 0001750 0001750 00000005757 12612724205 024476  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-
 *
 * Copyright (c) 2005-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __BITCODE_HPP__
#define __BITCODE_HPP__

#include <unistd.h>

namespace ld {

class Bitcode {
public:
    Bitcode(const uint8_t* content, uint32_t size) : _content(content), _size(size) { }

    virtual bool isMarker() const                               { return _size <= 1 ; }
    virtual const uint8_t* getContent() const                   { return _content; }
    virtual uint32_t getSize() const                            { return _size; }
private:
    const uint8_t* _content;
    uint32_t _size;
};

class LLVMBitcode : public Bitcode {
public:
    LLVMBitcode(const uint8_t* content, uint32_t size, const uint8_t* cmd, uint32_t cmdSize) :
        Bitcode(content, size), _cmdline(cmd), _cmdSize(cmdSize)    { }

    virtual const uint8_t* getCmdline() const                   { return _cmdline; }
    virtual uint32_t getCmdSize() const                         { return _cmdSize; }
    virtual const char* getBitcodeName() const                  { return "llvm"; }
private:
    const uint8_t* _cmdline;
    uint32_t _cmdSize;
};

class ClangBitcode : public LLVMBitcode {
public:
    ClangBitcode(const uint8_t* content, uint32_t size, const uint8_t* cmd, uint32_t cmdSize) :
        LLVMBitcode(content, size, cmd, cmdSize)    { }
    virtual const char* getBitcodeName() const override         { return "clang"; }
};

class SwiftBitcode : public LLVMBitcode {
public:
    SwiftBitcode(const uint8_t* content, uint32_t size, const uint8_t* cmd, uint32_t cmdSize) :
        LLVMBitcode(content, size, cmd, cmdSize)    { }
    virtual const char* getBitcodeName() const override         { return "swift"; }
};

class AsmBitcode : public Bitcode {
public:
    AsmBitcode(const uint8_t* content, uint32_t size) : Bitcode(content, size) { }

    virtual bool isMarker() const override                      { return false; }
};

class BundleBitcode : public Bitcode {
public:
    BundleBitcode(const uint8_t* content, uint32_t size) :
        Bitcode(content, size)  { }
};

}


#endif /* defined(__BITCODE_HPP__) */
                 osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/ld/HeaderAndLoadCommands.hpp       0100644 0001750 0001750 00000164362 12612724205 027220  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-*
 *
 * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __HEADER_LOAD_COMMANDS_HPP__
#define __HEADER_LOAD_COMMANDS_HPP__

#include <stdlib.h>
#include <limits.h>
#include <unistd.h>
#include <mach-o/loader.h>

#include <vector>

// ld64-port start
#if defined(__arm__) || defined(__arm64__)
#undef THREAD_STATE_NONE
#undef VALID_THREAD_STATE_FLAVOR
#undef MACHINE_THREAD_STATE
#undef MACHINE_THREAD_STATE_COUNT
#endif

#include <mach/i386/thread_status.h>
// ld64-port end

#include "MachOFileAbstraction.hpp"
#include "Options.h"
#include "ld.hpp"

namespace ld {
namespace tool {

class HeaderAndLoadCommandsAbtract : public ld::Atom
{
public:
							HeaderAndLoadCommandsAbtract(const ld::Section& sect, ld::Atom::Definition d, 
												ld::Atom::Combine c, ld::Atom::Scope s, ld::Atom::ContentType ct, 
												ld::Atom::SymbolTableInclusion i, bool dds, bool thumb, bool al, 
												ld::Atom::Alignment a) : ld::Atom(sect, d, c, s, ct, i, dds, thumb, al, a) { }

	virtual void setUUID(const uint8_t digest[16]) = 0;
	virtual void recopyUUIDCommand() = 0;
	virtual const uint8_t* getUUID() const = 0;
	virtual bool bitcodeBundleCommand(uint64_t& cmdOffset, uint64_t& cmdEnd,
									  uint64_t& sectOffset, uint64_t& sectEnd) const = 0;
};

template <typename A>
class HeaderAndLoadCommandsAtom : public HeaderAndLoadCommandsAbtract
{
public:
												HeaderAndLoadCommandsAtom(const Options& opts, ld::Internal& state, 
																			OutputFile& writer);

	// overrides of ld::Atom
	virtual ld::File*							file() const		{ return NULL; }
	virtual const char*							name() const		{ return "mach-o header and load commands"; }
	virtual uint64_t							size() const;
	virtual uint64_t							objectAddress() const { return _address; }
	virtual void								copyRawContent(uint8_t buffer[]) const;

	// overrides of HeaderAndLoadCommandsAbtract
	virtual void setUUID(const uint8_t digest[16])	{ memcpy(_uuid, digest, 16); }
	virtual void recopyUUIDCommand();
	virtual const uint8_t* getUUID() const                          { return &_uuid[0]; }
	virtual bool bitcodeBundleCommand(uint64_t& cmdOffset, uint64_t& cmdEnd,
									  uint64_t& sectOffset, uint64_t& sectEnd) const;
	
private:
	typedef typename A::P						P;
	typedef typename A::P::E					E;
	typedef typename A::P::uint_t				pint_t;
	
	unsigned int				nonHiddenSectionCount() const;
	unsigned int				segmentCount() const;
	static uint32_t				alignedSize(uint32_t x);
	uint32_t					magic() const;
	uint32_t					cpuType() const;
	uint32_t					cpuSubType() const;
	uint32_t					flags() const;
	uint32_t					fileType() const;
	uint32_t					commandsCount() const;
	uint32_t					threadLoadCommandSize() const;
	uint8_t*					copySingleSegmentLoadCommand(uint8_t* p) const;
	uint8_t*					copySegmentLoadCommands(uint8_t* p) const;
	uint8_t*					copyDyldInfoLoadCommand(uint8_t* p) const;
	uint8_t*					copySymbolTableLoadCommand(uint8_t* p) const;
	uint8_t*					copyDynamicSymbolTableLoadCommand(uint8_t* p) const;
	uint8_t*					copyDyldLoadCommand(uint8_t* p) const;
	uint8_t*					copyDylibIDLoadCommand(uint8_t* p) const;
	uint8_t*					copyRoutinesLoadCommand(uint8_t* p) const;
	uint8_t*					copyUUIDLoadCommand(uint8_t* p) const;
	uint8_t*					copyVersionLoadCommand(uint8_t* p) const;
	uint8_t*					copySourceVersionLoadCommand(uint8_t* p) const;
	uint8_t*					copyThreadsLoadCommand(uint8_t* p) const;
	uint8_t*					copyEntryPointLoadCommand(uint8_t* p) const;
	uint8_t*					copyEncryptionLoadCommand(uint8_t* p) const;
	uint8_t*					copySplitSegInfoLoadCommand(uint8_t* p) const;
	uint8_t*					copyDylibLoadCommand(uint8_t* p, const ld::dylib::File*) const;
	uint8_t*					copyRPathLoadCommand(uint8_t* p, const char*) const;
	uint8_t*					copySubFrameworkLoadCommand(uint8_t* p) const;
	uint8_t*					copyAllowableClientLoadCommand(uint8_t* p, const char* client) const;
	uint8_t*					copySubLibraryLoadCommand(uint8_t* p, const char* name) const;
	uint8_t*					copySubUmbrellaLoadCommand(uint8_t* p, const char* name) const;
	uint8_t*					copyFunctionStartsLoadCommand(uint8_t* p) const;
	uint8_t*					copyDataInCodeLoadCommand(uint8_t* p) const;
	uint8_t*					copyDyldEnvLoadCommand(uint8_t* p, const char* env) const;
	uint8_t*					copyLinkerOptionsLoadCommand(uint8_t* p, const std::vector<const char*>&) const;
	uint8_t*					copyOptimizationHintsLoadCommand(uint8_t* p) const;

	uint32_t					sectionFlags(ld::Internal::FinalSection* sect) const;
	bool						sectionTakesNoDiskSpace(ld::Internal::FinalSection* sect) const;
	

	const Options&				_options;
	ld::Internal&				_state;
	OutputFile&					_writer;
	pint_t						_address;
	bool						_hasDyldInfoLoadCommand;
	bool						_hasDyldLoadCommand;
	bool						_hasDylibIDLoadCommand;
	bool						_hasThreadLoadCommand;
	bool						_hasEntryPointLoadCommand;
	bool						_hasEncryptionLoadCommand;
	bool						_hasSplitSegInfoLoadCommand;
	bool						_hasRoutinesLoadCommand;
	bool						_hasUUIDLoadCommand;
	bool						_hasSymbolTableLoadCommand;
	bool						_hasDynamicSymbolTableLoadCommand;
	bool						_hasRPathLoadCommands;
	bool						_hasSubFrameworkLoadCommand;
	bool						_hasVersionLoadCommand;
	bool						_hasFunctionStartsLoadCommand;
	bool						_hasDataInCodeLoadCommand;
	bool						_hasSourceVersionLoadCommand;
	bool						_hasOptimizationHints;
	uint32_t					_dylibLoadCommmandsCount;
	uint32_t					_allowableClientLoadCommmandsCount;
	uint32_t					_dyldEnvironExrasCount;
	std::vector<const char*>	_subLibraryNames;
	std::vector<const char*>	_subUmbrellaNames;
	uint8_t						_uuid[16];
	mutable macho_uuid_command<P>*	_uuidCmdInOutputBuffer;
	std::vector< std::vector<const char*> >	 _linkerOptions;
	
	static ld::Section			_s_section;
	static ld::Section			_s_preload_section;
};

template <typename A>
ld::Section HeaderAndLoadCommandsAtom<A>::_s_section("__TEXT", "__mach_header", ld::Section::typeMachHeader, true);
template <typename A>
ld::Section HeaderAndLoadCommandsAtom<A>::_s_preload_section("__HEADER", "__mach_header", ld::Section::typeMachHeader, true);


template <typename A>
HeaderAndLoadCommandsAtom<A>::HeaderAndLoadCommandsAtom(const Options& opts, ld::Internal& state, OutputFile& writer)
	: HeaderAndLoadCommandsAbtract((opts.outputKind() == Options::kPreload) ? _s_preload_section : _s_section, 
				ld::Atom::definitionRegular, ld::Atom::combineNever, 
				ld::Atom::scopeTranslationUnit, ld::Atom::typeUnclassified, 
				ld::Atom::symbolTableNotIn, false, false, false, 
				(opts.outputKind() == Options::kPreload) ? ld::Atom::Alignment(0) : ld::Atom::Alignment(12) ), 
		_options(opts), _state(state), _writer(writer), _address(0), _uuidCmdInOutputBuffer(NULL)
{
	bzero(_uuid, 16);
	_hasDyldInfoLoadCommand = opts.makeCompressedDyldInfo();
	_hasDyldLoadCommand = ((opts.outputKind() == Options::kDynamicExecutable) || (_options.outputKind() == Options::kDyld));
	_hasDylibIDLoadCommand = (opts.outputKind() == Options::kDynamicLibrary);
	_hasThreadLoadCommand = _options.needsThreadLoadCommand();
	_hasEntryPointLoadCommand = _options.needsEntryPointLoadCommand();
	_hasEncryptionLoadCommand = opts.makeEncryptable();
	_hasSplitSegInfoLoadCommand = opts.sharedRegionEligible();
	_hasRoutinesLoadCommand = (opts.initFunctionName() != NULL);
	_hasSymbolTableLoadCommand = true;
	_hasUUIDLoadCommand = (opts.UUIDMode() != Options::kUUIDNone);
	_hasOptimizationHints = (_state.someObjectHasOptimizationHints && (opts.outputKind() == Options::kObjectFile));
	switch ( opts.outputKind() ) {
		case Options::kDynamicExecutable:
		case Options::kDynamicLibrary:
		case Options::kDynamicBundle:
		case Options::kDyld:
		case Options::kKextBundle:
			_hasDynamicSymbolTableLoadCommand = true;
			break;
		case Options::kObjectFile:
			if ( ! state.someObjectFileHasDwarf )
				_hasUUIDLoadCommand = false;
			_hasDynamicSymbolTableLoadCommand = false;
			for (std::vector<ld::Internal::FinalSection*>::iterator it = _state.sections.begin(); it != _state.sections.end(); ++it) {
				if ( (*it)->type() == ld::Section::typeNonLazyPointer ) {
					_hasDynamicSymbolTableLoadCommand = true;
					break;
				}
			}
			for (CStringSet::const_iterator it = _state.linkerOptionFrameworks.begin(); it != _state.linkerOptionFrameworks.end(); ++it) {
				const char* frameWorkName = *it;
				std::vector<const char*>* lo = new std::vector<const char*>();
				lo->push_back("-framework");
				lo->push_back(frameWorkName);
				_linkerOptions.push_back(*lo);
			};
			for (CStringSet::const_iterator it = _state.linkerOptionLibraries.begin(); it != _state.linkerOptionLibraries.end(); ++it) {
				const char* libName = *it;
				std::vector<const char*>* lo = new std::vector<const char*>();
				char * s = new char[strlen(libName)+3];
				strcpy(s, "-l");
				strcat(s, libName);
				lo->push_back(s);
				_linkerOptions.push_back(*lo);
			};
			break;
		case Options::kStaticExecutable:
			_hasDynamicSymbolTableLoadCommand = opts.positionIndependentExecutable();
			break;
		case Options::kPreload:
			_hasDynamicSymbolTableLoadCommand = opts.positionIndependentExecutable();
			break;
	}
	_hasRPathLoadCommands = (_options.rpaths().size() != 0);
	_hasSubFrameworkLoadCommand = (_options.umbrellaName() != NULL);
	_hasVersionLoadCommand = _options.addVersionLoadCommand() ||
							 (!state.objectFileFoundWithNoVersion && (_options.outputKind() == Options::kObjectFile)
							 && ((_options.platform() != Options::kPlatformUnknown) || (state.derivedPlatformLoadCommand != 0)) );
	_hasFunctionStartsLoadCommand = _options.addFunctionStarts();
	_hasDataInCodeLoadCommand = _options.addDataInCodeInfo();
	_hasSourceVersionLoadCommand = _options.needsSourceVersionLoadCommand();
	_dylibLoadCommmandsCount = _writer.dylibCount();
	_allowableClientLoadCommmandsCount = _options.allowableClients().size();
	_dyldEnvironExrasCount = _options.dyldEnvironExtras().size();
	
	if ( ! _options.useSimplifiedDylibReExports() ) {
		// target OS does not support LC_REEXPORT_DYLIB, so use old complicated load commands
		for(uint32_t ord=1; ord <= _writer.dylibCount(); ++ord) {
			const ld::dylib::File* dylib = _writer.dylibByOrdinal(ord);
			if ( dylib->willBeReExported() ) {
				// if child says it is an sub-framework of the image being created, then nothing to do here
				bool isSubFramework = false;
				const char* childInUmbrella = dylib->parentUmbrella();
				if ( childInUmbrella != NULL ) {
					const char* myLeaf = strrchr(_options.installPath(), '/');
					if ( myLeaf != NULL ) {
						if ( strcmp(childInUmbrella, &myLeaf[1]) == 0 )
							isSubFramework = true;
					}
				}
				// LC_SUB_FRAMEWORK is in child, so do nothing in parent 
				if ( ! isSubFramework ) {
					// this dylib also needs a sub_x load command
					bool isFrameworkReExport = false;
					const char* lastSlash = strrchr(dylib->installPath(), '/');
					if ( lastSlash != NULL ) {
						char frameworkName[strlen(lastSlash)+20];
						sprintf(frameworkName, "/%s.framework/", &lastSlash[1]);
						isFrameworkReExport = (strstr(dylib->installPath(), frameworkName) != NULL);
					}
					if ( isFrameworkReExport ) {
						// needs a LC_SUB_UMBRELLA command
						_subUmbrellaNames.push_back(&lastSlash[1]);
					}
					else {
						// needs a LC_SUB_LIBRARY command
						const char* nameStart = &lastSlash[1];
						if ( lastSlash == NULL )
							nameStart = dylib->installPath();
						int len = strlen(nameStart);
						const char* dot = strchr(nameStart, '.');
						if ( dot != NULL )
							len = dot - nameStart;
						char* subLibName = new char[len+1];
						strlcpy(subLibName, nameStart, len+1);
						_subLibraryNames.push_back(subLibName);
					}
				}
			}
		}
	}
}

template <typename A>
uint32_t HeaderAndLoadCommandsAtom<A>::alignedSize(uint32_t size)
{
	if ( sizeof(pint_t) == 4 )
		return ((size+3) & (-4));	// 4-byte align all load commands for 32-bit mach-o
	else
		return ((size+7) & (-8));	// 8-byte align all load commands for 64-bit mach-o
}


template <typename A>
unsigned int HeaderAndLoadCommandsAtom<A>::nonHiddenSectionCount() const
{
	unsigned int count = 0;
	for (std::vector<ld::Internal::FinalSection*>::iterator it = _state.sections.begin(); it != _state.sections.end(); ++it) {
		if ( ! (*it)->isSectionHidden() && ((*it)->type() != ld::Section::typeTentativeDefs) )
			++count;
	}
	return count;
}

template <typename A>
unsigned int HeaderAndLoadCommandsAtom<A>::segmentCount() const
{
	if ( _options.outputKind() == Options::kObjectFile ) {
		// .o files have one anonymous segment that contains all sections
		return 1;
	}
	
	unsigned int count = 0;
	const char* lastSegName = "";
	for (std::vector<ld::Internal::FinalSection*>::iterator it = _state.sections.begin(); it != _state.sections.end(); ++it) {
		if ( _options.outputKind() == Options::kPreload ) {
			if ( (*it)->type() == ld::Section::typeMachHeader )
				continue; // for -preload, don't put hidden __HEADER segment into output
			if ( (*it)->type() == ld::Section::typeLinkEdit )
				continue; // for -preload, don't put hidden __LINKEDIT segment into output
		}
		if ( strcmp(lastSegName, (*it)->segmentName()) != 0 ) {
			lastSegName = (*it)->segmentName();
			++count;
		}
	}
	return count;
}

template <typename A>
bool HeaderAndLoadCommandsAtom<A>::bitcodeBundleCommand(uint64_t &cmdOffset, uint64_t &cmdEnd,
														uint64_t &sectOffset, uint64_t &sectEnd) const
{
	if ( _options.outputKind() == Options::kObjectFile ) {
		return false;
	}
	cmdOffset = sizeof(macho_header<P>);
	const char* lastSegName = "";
	for (std::vector<ld::Internal::FinalSection*>::iterator it = _state.sections.begin(); it != _state.sections.end(); ++it) {
		if ( strcmp(lastSegName, (*it)->segmentName()) != 0 ) {
			lastSegName = (*it)->segmentName();
			cmdOffset += sizeof(macho_segment_command<P>);
		}
		if ( strcmp((*it)->segmentName(), "__LLVM") == 0 && strcmp((*it)->sectionName(), "__bundle") == 0 ) {
			sectOffset = (*it)->fileOffset;
			sectEnd = (*(it + 1))->fileOffset;
			cmdEnd = cmdOffset + sizeof(macho_section<P>);
			return true;
		}
		if ( ! (*it)->isSectionHidden() )
			cmdOffset += sizeof(macho_section<P>);
	}
	return false;
}

template <typename A>
uint64_t HeaderAndLoadCommandsAtom<A>::size() const
{
	uint32_t sz = sizeof(macho_header<P>);
	
	sz += sizeof(macho_segment_command<P>) * this->segmentCount();
	sz += sizeof(macho_section<P>) * this->nonHiddenSectionCount();

	if ( _hasDylibIDLoadCommand )
		sz += alignedSize(sizeof(macho_dylib_command<P>) + strlen(_options.installPath()) + 1);
		
	if ( _hasDyldInfoLoadCommand )
		sz += sizeof(macho_dyld_info_command<P>);
	
	if ( _hasSymbolTableLoadCommand )
		sz += sizeof(macho_symtab_command<P>);
		
	if ( _hasDynamicSymbolTableLoadCommand )
		sz += sizeof(macho_dysymtab_command<P>);
	
	if ( _hasDyldLoadCommand )
		sz += alignedSize(sizeof(macho_dylinker_command<P>) + strlen(_options.dyldInstallPath()) + 1);

	if ( _hasRoutinesLoadCommand ) 
		sz += sizeof(macho_routines_command<P>);
		
	if ( _hasUUIDLoadCommand )
		sz += sizeof(macho_uuid_command<P>);

	if ( _hasVersionLoadCommand )
		sz += sizeof(macho_version_min_command<P>);
	
	if ( _hasSourceVersionLoadCommand )
		sz += sizeof(macho_source_version_command<P>);
		
	if ( _hasThreadLoadCommand )
		sz += this->threadLoadCommandSize();

	if ( _hasEntryPointLoadCommand )
		sz += sizeof(macho_entry_point_command<P>);
		
	if ( _hasEncryptionLoadCommand )
		sz += sizeof(macho_encryption_info_command<P>);

	if ( _hasSplitSegInfoLoadCommand )
		sz += sizeof(macho_linkedit_data_command<P>);
	
	for(uint32_t ord=1; ord <= _writer.dylibCount(); ++ord) {
		sz += alignedSize(sizeof(macho_dylib_command<P>) + strlen(_writer.dylibByOrdinal(ord)->installPath()) + 1);
	}
	
	if ( _hasRPathLoadCommands ) {
		const std::vector<const char*>& rpaths = _options.rpaths();
		for (std::vector<const char*>::const_iterator it = rpaths.begin(); it != rpaths.end(); ++it) {
			sz += alignedSize(sizeof(macho_rpath_command<P>) + strlen(*it) + 1);
		}
	}
	
	if ( _hasSubFrameworkLoadCommand )
		sz += alignedSize(sizeof(macho_sub_framework_command<P>) + strlen(_options.umbrellaName()) + 1);
	
	for (std::vector<const char*>::const_iterator it = _subLibraryNames.begin(); it != _subLibraryNames.end(); ++it) {
		sz += alignedSize(sizeof(macho_sub_library_command<P>) + strlen(*it) + 1);
	}

	for (std::vector<const char*>::const_iterator it = _subUmbrellaNames.begin(); it != _subUmbrellaNames.end(); ++it) {
		sz += alignedSize(sizeof(macho_sub_umbrella_command<P>) + strlen(*it) + 1);
	}

	if ( _allowableClientLoadCommmandsCount != 0 ) {
		const std::vector<const char*>& clients = _options.allowableClients();
		for (std::vector<const char*>::const_iterator it = clients.begin(); it != clients.end(); ++it) {
			sz += alignedSize(sizeof(macho_sub_client_command<P>) + strlen(*it) + 1);
		}
	}
	
	if ( _dyldEnvironExrasCount != 0 ) {
		const std::vector<const char*>& extras = _options.dyldEnvironExtras();
		for (std::vector<const char*>::const_iterator it = extras.begin(); it != extras.end(); ++it) {
			sz += alignedSize(sizeof(macho_dylinker_command<P>) + strlen(*it) + 1);
		}
	}

	if ( _hasFunctionStartsLoadCommand )
		sz += sizeof(macho_linkedit_data_command<P>);

	if ( _hasDataInCodeLoadCommand )
		sz += sizeof(macho_linkedit_data_command<P>);

	if ( !_linkerOptions.empty() ) {
		for (ld::relocatable::File::LinkerOptionsList::const_iterator it = _linkerOptions.begin(); it != _linkerOptions.end(); ++it) {
			uint32_t s = sizeof(macho_linker_option_command<P>);
			const std::vector<const char*>& options = *it;
			for (std::vector<const char*>::const_iterator t=options.begin(); t != options.end(); ++t) {
				s += (strlen(*t) + 1);
			}
			sz += alignedSize(s);
		}
	}
	
	if ( _hasOptimizationHints )
		sz += sizeof(macho_linkedit_data_command<P>);
		
	return sz;
}

template <typename A>
uint32_t HeaderAndLoadCommandsAtom<A>::commandsCount() const
{
	uint32_t count = this->segmentCount();
	
	if ( _hasDylibIDLoadCommand )
		++count;
		
	if ( _hasDyldInfoLoadCommand )
		++count;
	
	if ( _hasSymbolTableLoadCommand )
		++count;
		
	if ( _hasDynamicSymbolTableLoadCommand )
		++count;
	
	if ( _hasDyldLoadCommand )
		++count;
		
	if ( _hasRoutinesLoadCommand ) 
		++count;
		
	if ( _hasUUIDLoadCommand )
		++count;
	
	if ( _hasVersionLoadCommand )
		++count;

	if ( _hasSourceVersionLoadCommand )
		++count;
		
	if ( _hasThreadLoadCommand )
		++count;
	
	if ( _hasEntryPointLoadCommand )
		++count;
		
	if ( _hasEncryptionLoadCommand )
		++count;
	
	if ( _hasSplitSegInfoLoadCommand )
		++count;
	
	count += _dylibLoadCommmandsCount;

	count += _options.rpaths().size();
	
	if ( _hasSubFrameworkLoadCommand )
		++count;
	
	count += _subLibraryNames.size();
	
	count += _subUmbrellaNames.size();

	count += _allowableClientLoadCommmandsCount;
	
	count += _dyldEnvironExrasCount;
	
	if ( _hasFunctionStartsLoadCommand )
		++count;

	if ( _hasDataInCodeLoadCommand )
		++count;

	if ( !_linkerOptions.empty() ) {
		for (ld::relocatable::File::LinkerOptionsList::const_iterator it = _linkerOptions.begin(); it != _linkerOptions.end(); ++it) {
			++count;
		}
	}

	if ( _hasOptimizationHints )
		++count;
		
	return count;
}

template <typename A>
uint32_t HeaderAndLoadCommandsAtom<A>::fileType() const
{
	switch ( _options.outputKind() ) {
		case Options::kDynamicExecutable:
		case Options::kStaticExecutable:
			return MH_EXECUTE;
		case Options::kDynamicLibrary:
			return MH_DYLIB;
		case Options::kDynamicBundle:
			return MH_BUNDLE;
		case Options::kObjectFile:
			return MH_OBJECT;
		case Options::kDyld:
			return MH_DYLINKER;
		case Options::kPreload:
			return MH_PRELOAD;
		case Options::kKextBundle:
			return MH_KEXT_BUNDLE;
	}
	throw "unknonwn mach-o file type";
}

template <typename A>
uint32_t HeaderAndLoadCommandsAtom<A>::flags() const
{
	uint32_t bits = 0;
	if ( _options.outputKind() == Options::kObjectFile ) {
		if ( _state.allObjectFilesScatterable )
			bits = MH_SUBSECTIONS_VIA_SYMBOLS;
	}
	else {
		if ( _options.outputKind() == Options::kStaticExecutable ) {
			bits |= MH_NOUNDEFS;
			if ( _options.positionIndependentExecutable() ) 
				bits |= MH_PIE;
		}
		else if ( _options.outputKind() == Options::kPreload ) {
			bits |= MH_NOUNDEFS;
			if ( _options.positionIndependentExecutable() ) 
				bits |= MH_PIE;
		}
		else {
			bits = MH_DYLDLINK;
			switch ( _options.nameSpace() ) {
				case Options::kTwoLevelNameSpace:
					bits |= MH_TWOLEVEL | MH_NOUNDEFS;
					break;
				case Options::kFlatNameSpace:
					break;
				case Options::kForceFlatNameSpace:
					bits |= MH_FORCE_FLAT;
					break;
			}
			if ( _state.hasWeakExternalSymbols || _writer.overridesWeakExternalSymbols )
				bits |= MH_WEAK_DEFINES;
			if ( _writer.usesWeakExternalSymbols || _state.hasWeakExternalSymbols )
				bits |= MH_BINDS_TO_WEAK;
			if ( _options.prebind() )
				bits |= MH_PREBOUND;
			if ( _options.splitSeg() )
				bits |= MH_SPLIT_SEGS;
			if ( (_options.outputKind() == Options::kDynamicLibrary) 
					&& _writer._noReExportedDylibs 
					&& _options.useSimplifiedDylibReExports() ) {
				bits |= MH_NO_REEXPORTED_DYLIBS;
			}
			if ( _options.positionIndependentExecutable() && ! _writer.pieDisabled ) 
				bits |= MH_PIE;
			if ( _options.markAutoDeadStripDylib() ) 
				bits |= MH_DEAD_STRIPPABLE_DYLIB;
			if ( _state.hasThreadLocalVariableDefinitions )
				bits |= MH_HAS_TLV_DESCRIPTORS;
			if ( _options.hasNonExecutableHeap() )
				bits |= MH_NO_HEAP_EXECUTION;
			if ( _options.markAppExtensionSafe() && (_options.outputKind() == Options::kDynamicLibrary) )
				bits |= MH_APP_EXTENSION_SAFE;
		}
		if ( _options.hasExecutableStack() )
			bits |= MH_ALLOW_STACK_EXECUTION;
	}
	return bits;
}

template <> uint32_t HeaderAndLoadCommandsAtom<x86>::magic() const		{ return MH_MAGIC; }
template <> uint32_t HeaderAndLoadCommandsAtom<x86_64>::magic() const	{ return MH_MAGIC_64; }
template <> uint32_t HeaderAndLoadCommandsAtom<arm>::magic() const		{ return MH_MAGIC; }
template <> uint32_t HeaderAndLoadCommandsAtom<arm64>::magic() const		{ return MH_MAGIC_64; }

template <> uint32_t HeaderAndLoadCommandsAtom<x86>::cpuType() const	{ return CPU_TYPE_I386; }
template <> uint32_t HeaderAndLoadCommandsAtom<x86_64>::cpuType() const	{ return CPU_TYPE_X86_64; }
template <> uint32_t HeaderAndLoadCommandsAtom<arm>::cpuType() const	{ return CPU_TYPE_ARM; }
template <> uint32_t HeaderAndLoadCommandsAtom<arm64>::cpuType() const	{ return CPU_TYPE_ARM64; }



template <>
uint32_t HeaderAndLoadCommandsAtom<x86>::cpuSubType() const
{
	return CPU_SUBTYPE_I386_ALL;
}

template <>
uint32_t HeaderAndLoadCommandsAtom<x86_64>::cpuSubType() const
{
	if ( (_options.outputKind() == Options::kDynamicExecutable) && (_state.cpuSubType == CPU_SUBTYPE_X86_64_ALL) && (_options.macosxVersionMin() >= ld::mac10_5) )
		return (_state.cpuSubType | 0x80000000);
	else
		return _state.cpuSubType;
}

template <>
uint32_t HeaderAndLoadCommandsAtom<arm>::cpuSubType() const
{
	return _state.cpuSubType;
}

template <>
uint32_t HeaderAndLoadCommandsAtom<arm64>::cpuSubType() const
{
	return CPU_SUBTYPE_ARM64_ALL;
}



template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySingleSegmentLoadCommand(uint8_t* p) const
{
	// in .o files there is just one segment load command with a blank name
	// and all sections under it
	macho_segment_command<P>* cmd = (macho_segment_command<P>*)p;
	cmd->set_cmd(macho_segment_command<P>::CMD);
	cmd->set_segname("");
	cmd->set_vmaddr(_options.baseAddress());	
	cmd->set_vmsize(0);		// updated after sections set
	cmd->set_fileoff(0);	// updated after sections set
	cmd->set_filesize(0);	// updated after sections set
	cmd->set_maxprot(VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
	cmd->set_initprot(VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
	cmd->set_nsects(this->nonHiddenSectionCount());
	cmd->set_flags(0);
	// add sections array
	macho_section<P>* msect = (macho_section<P>*)&p[sizeof(macho_segment_command<P>)];
	for (std::vector<ld::Internal::FinalSection*>::iterator sit = _state.sections.begin(); sit != _state.sections.end(); ++sit)  {
		ld::Internal::FinalSection* fsect = *sit;
		if ( fsect->isSectionHidden() ) 
			continue;
		if ( fsect->type() == ld::Section::typeTentativeDefs ) 
			continue;
		msect->set_sectname(fsect->sectionName());
		msect->set_segname(fsect->segmentName());
		msect->set_addr(fsect->address);
		msect->set_size(fsect->size);
		msect->set_offset(fsect->fileOffset);
		msect->set_align(fsect->alignment);
		msect->set_reloff((fsect->relocCount == 0) ? 0 : _writer.sectionRelocationsSection->fileOffset + fsect->relocStart * sizeof(macho_relocation_info<P>));
		msect->set_nreloc(fsect->relocCount);
		msect->set_flags(sectionFlags(fsect));
		msect->set_reserved1(fsect->indirectSymTabStartIndex);	
		msect->set_reserved2(fsect->indirectSymTabElementSize);	
		// update segment info
		if ( cmd->fileoff() == 0 )
			cmd->set_fileoff(fsect->fileOffset);
		cmd->set_vmsize(fsect->address + fsect->size - cmd->vmaddr());
		if ( (fsect->type() != ld::Section::typeZeroFill) && (fsect->type() != ld::Section::typeTentativeDefs) )
			cmd->set_filesize(fsect->fileOffset + fsect->size - cmd->fileoff());
		++msect;
	}
	cmd->set_cmdsize(sizeof(macho_segment_command<P>) + cmd->nsects()*sizeof(macho_section<P>));
	return p + cmd->cmdsize();
}

struct SegInfo {
												SegInfo(const char* n, const Options&);
	const char*									segName;
	uint32_t									nonHiddenSectionCount;
	uint32_t									nonSectCreateSections;
	uint32_t									maxProt;
	uint32_t									initProt;
	std::vector<ld::Internal::FinalSection*>	sections;
};


SegInfo::SegInfo(const char* n, const Options& opts) 
	: segName(n), nonHiddenSectionCount(0), nonSectCreateSections(0), maxProt(opts.maxSegProtection(n)), initProt(opts.initialSegProtection(n))
{ 
}


template <typename A>
uint32_t HeaderAndLoadCommandsAtom<A>::sectionFlags(ld::Internal::FinalSection* sect) const
{
	uint32_t bits;
	switch ( sect->type() ) {
		case ld::Section::typeUnclassified:
			if ( strcmp(sect->segmentName(), "__OBJC") == 0 )
				return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
			else if ( (strcmp(sect->sectionName(), "__objc_classlist") == 0) && (strcmp(sect->segmentName(), "__DATA") == 0) )
				return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
			else if ( (strcmp(sect->sectionName(), "__objc_catlist") == 0) && (strcmp(sect->segmentName(), "__DATA") == 0) )
				return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
			else if ( (strncmp(sect->sectionName(), "__objc_superrefs", 16) == 0) && (strcmp(sect->segmentName(), "__DATA") == 0) )
				return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
			else if ( (strncmp(sect->sectionName(), "__objc_nlclslist", 16) == 0) && (strcmp(sect->segmentName(), "__DATA") == 0) )
				return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
			else if ( (strncmp(sect->sectionName(), "__objc_nlcatlist", 16) == 0) && (strcmp(sect->segmentName(), "__DATA") == 0) )
				return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
			else if (  (_options.outputKind() == Options::kObjectFile) && !sect->atoms.empty() && sect->atoms.front()->dontDeadStripIfReferencesLive() )
				return S_REGULAR | S_ATTR_LIVE_SUPPORT;
			else
				return S_REGULAR;
		case ld::Section::typeCode:
			bits = S_REGULAR | S_ATTR_SOME_INSTRUCTIONS | S_ATTR_PURE_INSTRUCTIONS;
			if ( sect->hasLocalRelocs && ! _writer.pieDisabled )
				bits |= S_ATTR_LOC_RELOC;
			if ( sect->hasExternalRelocs )
				bits |= S_ATTR_EXT_RELOC;
			return bits;
		case ld::Section::typePageZero:
			return S_REGULAR;
		case ld::Section::typeImportProxies:
			return S_REGULAR;
		case ld::Section::typeLinkEdit:
			return S_REGULAR;
		case ld::Section::typeMachHeader:
			return S_REGULAR;
		case ld::Section::typeStack:
			return S_REGULAR;
		case ld::Section::typeLiteral4:
			return S_4BYTE_LITERALS;
		case ld::Section::typeLiteral8:
			return S_8BYTE_LITERALS;
		case ld::Section::typeLiteral16:
			return S_16BYTE_LITERALS;
		case ld::Section::typeConstants:
			return S_REGULAR;
		case ld::Section::typeTempLTO:
			assert(0 && "typeTempLTO should not make it to final linked image");
			return S_REGULAR;
		case ld::Section::typeTempAlias:
			assert(0 && "typeAlias should not make it to final linked image");
			return S_REGULAR;
		case ld::Section::typeAbsoluteSymbols:
			assert(0 && "typeAbsoluteSymbols should not make it to final linked image");
			return S_REGULAR;
		case ld::Section::typeCString:
		case ld::Section::typeNonStdCString:
			return S_CSTRING_LITERALS;
		case ld::Section::typeCStringPointer:
			return S_LITERAL_POINTERS | S_ATTR_NO_DEAD_STRIP;
		case ld::Section::typeUTF16Strings:
			return S_REGULAR;
		case ld::Section::typeCFString:
			return S_REGULAR;
		case ld::Section::typeObjC1Classes:
			return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
		case ld::Section::typeCFI:
			return S_REGULAR;
		case ld::Section::typeLSDA:
			return S_REGULAR;
		case ld::Section::typeDtraceDOF:
			return S_DTRACE_DOF;
		case ld::Section::typeUnwindInfo:
			return S_REGULAR;
		case ld::Section::typeObjCClassRefs:
		case ld::Section::typeObjC2CategoryList:
			return S_REGULAR | S_ATTR_NO_DEAD_STRIP;
		case ld::Section::typeZeroFill:
			if ( _options.optimizeZeroFill() )
				return S_ZEROFILL;
			else
				return S_REGULAR;
		case ld::Section::typeTentativeDefs:
			assert(0 && "typeTentativeDefs should not make it to final linked image");
			return S_REGULAR;
		case ld::Section::typeLazyPointer:
		case ld::Section::typeLazyPointerClose:
			return S_LAZY_SYMBOL_POINTERS;
		case ld::Section::typeStubClose:
		case ld::Section::typeStub:
			if ( sect->hasLocalRelocs )
				return S_SYMBOL_STUBS | S_ATTR_SOME_INSTRUCTIONS | S_ATTR_PURE_INSTRUCTIONS | S_ATTR_LOC_RELOC;
			else
				return S_SYMBOL_STUBS | S_ATTR_SOME_INSTRUCTIONS | S_ATTR_PURE_INSTRUCTIONS;
		case ld::Section::typeNonLazyPointer:
			if ( _options.outputKind() == Options::kKextBundle  )
				return S_REGULAR;
			else if ( (_options.outputKind() == Options::kStaticExecutable) && _options.positionIndependentExecutable() )
				return S_REGULAR;
			else
				return S_NON_LAZY_SYMBOL_POINTERS;
		case ld::Section::typeDyldInfo:
			return S_REGULAR;
		case ld::Section::typeLazyDylibPointer:
			return S_LAZY_DYLIB_SYMBOL_POINTERS;
		case ld::Section::typeStubHelper:
			if ( sect->hasLocalRelocs )
				return S_REGULAR | S_ATTR_SOME_INSTRUCTIONS | S_ATTR_PURE_INSTRUCTIONS | S_ATTR_LOC_RELOC;
			else
				return S_REGULAR | S_ATTR_SOME_INSTRUCTIONS | S_ATTR_PURE_INSTRUCTIONS;
		case ld::Section::typeInitializerPointers:
			// <rdar://problem/11456679> i386 kexts need different section type
			if ( (_options.outputKind() == Options::kObjectFile) 
					&& (strcmp(sect->sectionName(), "__constructor") == 0) 
					&& (strcmp(sect->segmentName(), "__TEXT") == 0) )
				return S_REGULAR;
			else
				return S_MOD_INIT_FUNC_POINTERS;
		case ld::Section::typeTerminatorPointers:
			return S_MOD_TERM_FUNC_POINTERS;
		case ld::Section::typeTLVInitialValues:
			return S_THREAD_LOCAL_REGULAR;
		case ld::Section::typeTLVZeroFill:
			return S_THREAD_LOCAL_ZEROFILL;
		case ld::Section::typeTLVDefs:
			return S_THREAD_LOCAL_VARIABLES;
		case ld::Section::typeTLVInitializerPointers:
			return S_THREAD_LOCAL_INIT_FUNCTION_POINTERS;
		case ld::Section::typeTLVPointers:
			return S_THREAD_LOCAL_VARIABLE_POINTERS;
		case ld::Section::typeFirstSection:
			assert(0 && "typeFirstSection should not make it to final linked image");
			return S_REGULAR;
		case ld::Section::typeLastSection:
			assert(0 && "typeLastSection should not make it to final linked image");
			return S_REGULAR;
		case ld::Section::typeDebug:
			return S_REGULAR | S_ATTR_DEBUG;
		case ld::Section::typeSectCreate:
			return S_REGULAR;
	}
	return S_REGULAR;
}


template <typename A>
bool HeaderAndLoadCommandsAtom<A>::sectionTakesNoDiskSpace(ld::Internal::FinalSection* sect) const
{
	switch ( sect->type() ) {
		case ld::Section::typeZeroFill:
		case ld::Section::typeTLVZeroFill:
			return _options.optimizeZeroFill();
		case ld::Section::typeAbsoluteSymbols:
		case ld::Section::typeTentativeDefs:
		case ld::Section::typeLastSection:
			return true;
		default:
			break;
	}
	return false;
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySegmentLoadCommands(uint8_t* p) const
{
	// group sections into segments
	std::vector<SegInfo> segs;
	const char* lastSegName = "";
	for (std::vector<ld::Internal::FinalSection*>::iterator it = _state.sections.begin(); it != _state.sections.end(); ++it) {
		ld::Internal::FinalSection* sect = *it;
		if ( _options.outputKind() == Options::kPreload ) {
			if ( (*it)->type() == ld::Section::typeMachHeader )
				continue; // for -preload, don't put hidden __HEADER segment into output
			if ( (*it)->type() == ld::Section::typeLinkEdit )
				continue; // for -preload, don't put hidden __LINKEDIT segment into output
		}
		if ( strcmp(lastSegName, sect->segmentName()) != 0 ) {
			SegInfo si(sect->segmentName(), _options);
			segs.push_back(si);
			lastSegName = sect->segmentName();
		}
		if ( ! sect->isSectionHidden() ) 
			segs.back().nonHiddenSectionCount++;
		if ( sect->type() != ld::Section::typeSectCreate )
			segs.back().nonSectCreateSections++;

		segs.back().sections.push_back(sect);
	}
	// write out segment load commands for each section with trailing sections
	for (std::vector<SegInfo>::iterator it = segs.begin(); it != segs.end(); ++it) {
		SegInfo& si = *it;
		ld::Internal::FinalSection* lastNonZeroFillSection = NULL;
		for (int i=si.sections.size()-1; i >= 0; --i) {
			if ( !sectionTakesNoDiskSpace(si.sections[i]) ) {
				lastNonZeroFillSection = si.sections[i];
				break;
			}
		}
		uint64_t vmsize = si.sections.back()->address + si.sections.back()->size - si.sections.front()->address;
		vmsize = ((vmsize+_options.segmentAlignment()-1) & (-_options.segmentAlignment()));
		uint64_t filesize = 0;
		if ( lastNonZeroFillSection != NULL ) {
			filesize = lastNonZeroFillSection->address + lastNonZeroFillSection->size - si.sections.front()->address;
			// round up all segments to page aligned, except __LINKEDIT
			if ( (si.sections[0]->type() != ld::Section::typeLinkEdit) && (si.sections[0]->type() != ld::Section::typeImportProxies) )
				filesize = (filesize + _options.segmentAlignment()-1) & (-_options.segmentAlignment());
		}
		if ( si.sections.front()->type() == ld::Section::typePageZero )
			filesize = 0;
		else if ( si.sections.front()->type() == ld::Section::typeStack )
			filesize = 0;
		macho_segment_command<P>* segCmd = (macho_segment_command<P>*)p;
		segCmd->set_cmd(macho_segment_command<P>::CMD);
		segCmd->set_cmdsize(sizeof(macho_segment_command<P>) + si.nonHiddenSectionCount*sizeof(macho_section<P>));
		segCmd->set_segname(si.sections.front()->segmentName());
		segCmd->set_vmaddr(si.sections.front()->address);		
		segCmd->set_vmsize(vmsize);	
		segCmd->set_fileoff(si.sections.front()->fileOffset);
		segCmd->set_filesize(filesize); 
		segCmd->set_maxprot(si.maxProt);
		segCmd->set_initprot(si.initProt);
		segCmd->set_nsects(si.nonHiddenSectionCount);
		segCmd->set_flags(si.nonSectCreateSections ? 0 : SG_NORELOC); // FIXME, really should check all References

		p += sizeof(macho_segment_command<P>);
		macho_section<P>* msect = (macho_section<P>*)p;
		for (std::vector<ld::Internal::FinalSection*>::iterator sit = si.sections.begin(); sit != si.sections.end(); ++sit) {
			ld::Internal::FinalSection* fsect = *sit;
			if ( ! fsect->isSectionHidden() ) {
				msect->set_sectname(fsect->sectionName());
				msect->set_segname(fsect->segmentName());
				msect->set_addr(fsect->address);
				msect->set_size(fsect->size);
				msect->set_offset(sectionTakesNoDiskSpace(fsect) ? 0 : fsect->fileOffset);
				msect->set_align(fsect->alignment);
				msect->set_reloff(0);		
				msect->set_nreloc(0);
				msect->set_flags(sectionFlags(fsect));
				msect->set_reserved1(fsect->indirectSymTabStartIndex);	
				msect->set_reserved2(fsect->indirectSymTabElementSize);	
				p += sizeof(macho_section<P>);
				++msect;
			}
		}
	}

	return p;
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySymbolTableLoadCommand(uint8_t* p) const
{
	// build LC_SYMTAB command
	macho_symtab_command<P>*   symbolTableCmd = (macho_symtab_command<P>*)p;
	symbolTableCmd->set_cmd(LC_SYMTAB);
	symbolTableCmd->set_cmdsize(sizeof(macho_symtab_command<P>));
	symbolTableCmd->set_nsyms(_writer.symbolTableSection->size/sizeof(macho_nlist<P>));
	symbolTableCmd->set_symoff(_writer.symbolTableSection->size == 0 ? 0 : _writer.symbolTableSection->fileOffset);
	symbolTableCmd->set_stroff(_writer.stringPoolSection->size == 0 ? 0 : _writer.stringPoolSection->fileOffset );
	symbolTableCmd->set_strsize(_writer.stringPoolSection->size);
	return p + sizeof(macho_symtab_command<P>);
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyDynamicSymbolTableLoadCommand(uint8_t* p) const
{
	// build LC_SYMTAB command
	macho_dysymtab_command<P>*   dynamicSymbolTableCmd = (macho_dysymtab_command<P>*)p;
	dynamicSymbolTableCmd->set_cmd(LC_DYSYMTAB);
	dynamicSymbolTableCmd->set_cmdsize(sizeof(macho_dysymtab_command<P>));
	dynamicSymbolTableCmd->set_ilocalsym(0);
	dynamicSymbolTableCmd->set_nlocalsym(_writer._localSymbolsCount);
	dynamicSymbolTableCmd->set_iextdefsym(dynamicSymbolTableCmd->ilocalsym()+dynamicSymbolTableCmd->nlocalsym());
	dynamicSymbolTableCmd->set_nextdefsym(_writer._globalSymbolsCount);
	dynamicSymbolTableCmd->set_iundefsym(dynamicSymbolTableCmd->iextdefsym()+dynamicSymbolTableCmd->nextdefsym());
	dynamicSymbolTableCmd->set_nundefsym(_writer._importSymbolsCount);

	// FIX ME: support for 10.3 dylibs which need modules
	//if ( fWriter.fModuleInfoAtom != NULL ) {
	//	dynamicSymbolTableCmd->set_tocoff(fWriter.fModuleInfoAtom->getTableOfContentsFileOffset());
	//	dynamicSymbolTableCmd->set_ntoc(fWriter.fSymbolTableExportCount);
	//	dynamicSymbolTableCmd->set_modtaboff(fWriter.fModuleInfoAtom->getModuleTableFileOffset());
	//	dynamicSymbolTableCmd->set_nmodtab(1);
	//	dynamicSymbolTableCmd->set_extrefsymoff(fWriter.fModuleInfoAtom->getReferencesFileOffset());
	//	dynamicSymbolTableCmd->set_nextrefsyms(fWriter.fModuleInfoAtom->getReferencesCount());
	//}

	bool hasIndirectSymbols = ( (_writer.indirectSymbolTableSection != NULL) && (_writer.indirectSymbolTableSection->size != 0) );
	dynamicSymbolTableCmd->set_indirectsymoff(hasIndirectSymbols ? _writer.indirectSymbolTableSection->fileOffset : 0);
	dynamicSymbolTableCmd->set_nindirectsyms( hasIndirectSymbols ? _writer.indirectSymbolTableSection->size/sizeof(uint32_t) : 0);

	// FIX ME: support for classic relocations
	if ( _options.outputKind() != Options::kObjectFile ) {
		bool hasExternalRelocs = ( (_writer.externalRelocationsSection != NULL) && (_writer.externalRelocationsSection->size != 0) );
		dynamicSymbolTableCmd->set_extreloff(hasExternalRelocs ? _writer.externalRelocationsSection->fileOffset : 0);
		dynamicSymbolTableCmd->set_nextrel(  hasExternalRelocs ? _writer.externalRelocationsSection->size/8 : 0);
		bool hasLocalRelocs = ( (_writer.localRelocationsSection != NULL) && (_writer.localRelocationsSection->size != 0) );
		dynamicSymbolTableCmd->set_locreloff(hasLocalRelocs ? _writer.localRelocationsSection->fileOffset : 0);
		dynamicSymbolTableCmd->set_nlocrel  (hasLocalRelocs ? _writer.localRelocationsSection->size/8 : 0);
	}
	return p + sizeof(macho_dysymtab_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyDyldInfoLoadCommand(uint8_t* p) const
{
	// build LC_DYLD_INFO command
	macho_dyld_info_command<P>*  cmd = (macho_dyld_info_command<P>*)p;
	
	cmd->set_cmd(LC_DYLD_INFO_ONLY);
	cmd->set_cmdsize(sizeof(macho_dyld_info_command<P>));
	if ( _writer.rebaseSection->size != 0 ) {
		cmd->set_rebase_off(_writer.rebaseSection->fileOffset);
		cmd->set_rebase_size(_writer.rebaseSection->size);
	}
	if ( _writer.bindingSection->size != 0 ) {
		cmd->set_bind_off(_writer.bindingSection->fileOffset);
		cmd->set_bind_size(_writer.bindingSection->size);
	}
	if ( _writer.weakBindingSection->size != 0 ) {
		cmd->set_weak_bind_off(_writer.weakBindingSection->fileOffset);
		cmd->set_weak_bind_size(_writer.weakBindingSection->size);
	}
	if ( _writer.lazyBindingSection->size != 0 ) {
		cmd->set_lazy_bind_off(_writer.lazyBindingSection->fileOffset);
		cmd->set_lazy_bind_size(_writer.lazyBindingSection->size);
	}
	if ( _writer.exportSection->size != 0 ) {
		cmd->set_export_off(_writer.exportSection->fileOffset);
		cmd->set_export_size(_writer.exportSection->size);
	}
	return p + sizeof(macho_dyld_info_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyDyldLoadCommand(uint8_t* p) const
{
	uint32_t sz = alignedSize(sizeof(macho_dylinker_command<P>) + strlen(_options.dyldInstallPath()) + 1);
	macho_dylinker_command<P>* cmd = (macho_dylinker_command<P>*)p;
	if ( _options.outputKind() == Options::kDyld )
		cmd->set_cmd(LC_ID_DYLINKER);
	else
		cmd->set_cmd(LC_LOAD_DYLINKER);
	cmd->set_cmdsize(sz);
	cmd->set_name_offset();
	strcpy((char*)&p[sizeof(macho_dylinker_command<P>)], _options.dyldInstallPath());
	return p + sz;
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyDylibIDLoadCommand(uint8_t* p) const
{
	uint32_t sz = alignedSize(sizeof(macho_dylib_command<P>) + strlen(_options.installPath()) + 1);
	macho_dylib_command<P>* cmd = (macho_dylib_command<P>*)p;
	cmd->set_cmd(LC_ID_DYLIB);
	cmd->set_cmdsize(sz);
	cmd->set_name_offset();
	cmd->set_timestamp(1);	// needs to be some constant value that is different than DylibLoadCommandsAtom uses
	cmd->set_current_version(_options.currentVersion32());
	cmd->set_compatibility_version(_options.compatibilityVersion());
	strcpy((char*)&p[sizeof(macho_dylib_command<P>)], _options.installPath());
	return p + sz;
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyRoutinesLoadCommand(uint8_t* p) const
{
	pint_t initAddr = _state.entryPoint->finalAddress(); 
	if ( _state.entryPoint->isThumb() )
		initAddr |= 1ULL;
	macho_routines_command<P>* cmd = (macho_routines_command<P>*)p;
	cmd->set_cmd(macho_routines_command<P>::CMD);
	cmd->set_cmdsize(sizeof(macho_routines_command<P>));
	cmd->set_init_address(initAddr);
	return p + sizeof(macho_routines_command<P>);
}


template <typename A>
void HeaderAndLoadCommandsAtom<A>::recopyUUIDCommand() 
{
	assert(_uuidCmdInOutputBuffer != NULL);
	_uuidCmdInOutputBuffer->set_uuid(_uuid);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyUUIDLoadCommand(uint8_t* p) const
{
	macho_uuid_command<P>* cmd = (macho_uuid_command<P>*)p;
	cmd->set_cmd(LC_UUID);
	cmd->set_cmdsize(sizeof(macho_uuid_command<P>));
	cmd->set_uuid(_uuid);
	_uuidCmdInOutputBuffer = cmd;	 // save for later re-write by recopyUUIDCommand()
	return p + sizeof(macho_uuid_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyVersionLoadCommand(uint8_t* p) const
{
	macho_version_min_command<P>* cmd = (macho_version_min_command<P>*)p;
	switch (_options.platform()) {
		case Options::kPlatformUnknown:
			assert(_state.derivedPlatformLoadCommand != 0 && "unknown platform");
			cmd->set_cmd(_state.derivedPlatformLoadCommand);
			cmd->set_cmdsize(sizeof(macho_version_min_command<P>));
			cmd->set_version(_state.minOSVersion);
			cmd->set_sdk(0);
			break;
		case Options::kPlatformOSX:
			cmd->set_cmd(LC_VERSION_MIN_MACOSX);
			cmd->set_cmdsize(sizeof(macho_version_min_command<P>));
			cmd->set_version(_state.minOSVersion);
			cmd->set_sdk(_options.sdkVersion());
			break;
		case Options::kPlatformiOS:
			cmd->set_cmd(LC_VERSION_MIN_IPHONEOS);
			cmd->set_cmdsize(sizeof(macho_version_min_command<P>));
			cmd->set_version(_state.minOSVersion);
			cmd->set_sdk(_options.sdkVersion());
			break;
		case Options::kPlatformWatchOS:
			cmd->set_cmd(LC_VERSION_MIN_WATCHOS);
			cmd->set_cmdsize(sizeof(macho_version_min_command<P>));
			cmd->set_version(_state.minOSVersion);
			cmd->set_sdk(_options.sdkVersion());
			break;
#if SUPPORT_APPLE_TV
		case Options::kPlatform_tvOS:
			cmd->set_cmd(LC_VERSION_MIN_TVOS);
			cmd->set_cmdsize(sizeof(macho_version_min_command<P>));
			cmd->set_version(_state.minOSVersion);
			cmd->set_sdk(_options.sdkVersion());
			break;
#endif
	}
	return p + sizeof(macho_version_min_command<P>);
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySourceVersionLoadCommand(uint8_t* p) const
{
	macho_source_version_command<P>* cmd = (macho_source_version_command<P>*)p;
	cmd->set_cmd(LC_SOURCE_VERSION);
	cmd->set_cmdsize(sizeof(macho_source_version_command<P>));
	cmd->set_version(_options.sourceVersion());
	return p + sizeof(macho_source_version_command<P>);
}


template <>
uint32_t HeaderAndLoadCommandsAtom<x86>::threadLoadCommandSize() const
{
	return this->alignedSize(16 + 16*4);	// base size + i386_THREAD_STATE_COUNT * 4
}

template <>
uint8_t* HeaderAndLoadCommandsAtom<x86>::copyThreadsLoadCommand(uint8_t* p) const
{
	assert(_state.entryPoint != NULL);
	pint_t start = _state.entryPoint->finalAddress(); 
	macho_thread_command<P>* cmd = (macho_thread_command<P>*)p;
	cmd->set_cmd(LC_UNIXTHREAD);
	cmd->set_cmdsize(threadLoadCommandSize());
	cmd->set_flavor(1);				// i386_THREAD_STATE
	cmd->set_count(16);				// i386_THREAD_STATE_COUNT;
	cmd->set_thread_register(10, start);
	if ( _options.hasCustomStack() )
		cmd->set_thread_register(7, _options.customStackAddr());	// r1
	return p + threadLoadCommandSize();
}

template <>
uint32_t HeaderAndLoadCommandsAtom<x86_64>::threadLoadCommandSize() const
{
	return this->alignedSize(16 + 42*4);	// base size + x86_THREAD_STATE64_COUNT * 4
}

template <>
uint8_t* HeaderAndLoadCommandsAtom<x86_64>::copyThreadsLoadCommand(uint8_t* p) const
{
	assert(_state.entryPoint != NULL);
	pint_t start = _state.entryPoint->finalAddress(); 
	macho_thread_command<P>* cmd = (macho_thread_command<P>*)p;
	cmd->set_cmd(LC_UNIXTHREAD);
	cmd->set_cmdsize(threadLoadCommandSize());
	cmd->set_flavor(4);				// x86_THREAD_STATE64
	cmd->set_count(42);				// x86_THREAD_STATE64_COUNT
	cmd->set_thread_register(16, start);		// rip 
	if ( _options.hasCustomStack() )
		cmd->set_thread_register(7, _options.customStackAddr());	// r1
	return p + threadLoadCommandSize();
}

template <>
uint32_t HeaderAndLoadCommandsAtom<arm>::threadLoadCommandSize() const
{
	return this->alignedSize(16 + 17 * 4); // base size + ARM_THREAD_STATE_COUNT * 4
}

template <>
uint8_t* HeaderAndLoadCommandsAtom<arm>::copyThreadsLoadCommand(uint8_t* p) const
{
	assert(_state.entryPoint != NULL);
	pint_t start = _state.entryPoint->finalAddress(); 
	if ( _state.entryPoint->isThumb() )
		start |= 1ULL;
	macho_thread_command<P>* cmd = (macho_thread_command<P>*)p;
	cmd->set_cmd(LC_UNIXTHREAD);
	cmd->set_cmdsize(threadLoadCommandSize());
	cmd->set_flavor(1);			
	cmd->set_count(17);	
	cmd->set_thread_register(15, start);		// pc
	if ( _options.hasCustomStack() )
		cmd->set_thread_register(13, _options.customStackAddr());	// sp
	return p + threadLoadCommandSize();
}


template <>
uint32_t HeaderAndLoadCommandsAtom<arm64>::threadLoadCommandSize() const
{
	return this->alignedSize(16 + 34 * 8); // base size + ARM_EXCEPTION_STATE64_COUNT * 4
}

template <>
uint8_t* HeaderAndLoadCommandsAtom<arm64>::copyThreadsLoadCommand(uint8_t* p) const
{
	assert(_state.entryPoint != NULL);
	pint_t start = _state.entryPoint->finalAddress(); 
	macho_thread_command<P>* cmd = (macho_thread_command<P>*)p;
	cmd->set_cmd(LC_UNIXTHREAD);
	cmd->set_cmdsize(threadLoadCommandSize());
	cmd->set_flavor(6);	 // ARM_THREAD_STATE64
	cmd->set_count(68);	 // ARM_EXCEPTION_STATE64_COUNT
	cmd->set_thread_register(32, start);		// pc 
	if ( _options.hasCustomStack() )
		cmd->set_thread_register(31, _options.customStackAddr());	// sp 
	return p + threadLoadCommandSize();
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyEntryPointLoadCommand(uint8_t* p) const
{
	macho_entry_point_command<P>* cmd = (macho_entry_point_command<P>*)p;
	cmd->set_cmd(LC_MAIN);
	cmd->set_cmdsize(sizeof(macho_entry_point_command<P>));
	assert(_state.entryPoint != NULL);
	pint_t start = _state.entryPoint->finalAddress(); 
	if ( _state.entryPoint->isThumb() )
		start |= 1ULL;
	cmd->set_entryoff(start - this->finalAddress());
	cmd->set_stacksize(_options.hasCustomStack() ? _options.customStackSize() : 0 );
	return p + sizeof(macho_entry_point_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyEncryptionLoadCommand(uint8_t* p) const
{
	macho_encryption_info_command<P>* cmd = (macho_encryption_info_command<P>*)p;
	cmd->set_cmd(sizeof(typename A::P::uint_t) == 4 ? LC_ENCRYPTION_INFO : LC_ENCRYPTION_INFO_64);
	cmd->set_cmdsize(sizeof(macho_encryption_info_command<P>));
	assert(_writer.encryptedTextStartOffset() != 0);
	assert(_writer.encryptedTextEndOffset() != 0);
	cmd->set_cryptoff(_writer.encryptedTextStartOffset());
	cmd->set_cryptsize(_writer.encryptedTextEndOffset()-_writer.encryptedTextStartOffset());
	cmd->set_cryptid(0);
	return p + sizeof(macho_encryption_info_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySplitSegInfoLoadCommand(uint8_t* p) const
{
	macho_linkedit_data_command<P>* cmd = (macho_linkedit_data_command<P>*)p;
	cmd->set_cmd(LC_SEGMENT_SPLIT_INFO);
	cmd->set_cmdsize(sizeof(macho_linkedit_data_command<P>));
	cmd->set_dataoff(_writer.splitSegInfoSection->fileOffset);
	cmd->set_datasize(_writer.splitSegInfoSection->size);
	return p + sizeof(macho_linkedit_data_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyDylibLoadCommand(uint8_t* p, const ld::dylib::File* dylib) const
{
	uint32_t sz = alignedSize(sizeof(macho_dylib_command<P>) + strlen(dylib->installPath()) + 1);
	macho_dylib_command<P>* cmd = (macho_dylib_command<P>*)p;
	if ( dylib->willBeLazyLoadedDylib() )
		cmd->set_cmd(LC_LAZY_LOAD_DYLIB);
	else if ( dylib->forcedWeakLinked() || dylib->allSymbolsAreWeakImported() )
		cmd->set_cmd(LC_LOAD_WEAK_DYLIB);
	else if ( dylib->willBeReExported() && _options.useSimplifiedDylibReExports() )
		cmd->set_cmd(LC_REEXPORT_DYLIB);
	else if ( dylib->willBeUpwardDylib() && _options.useUpwardDylibs() )
		cmd->set_cmd(LC_LOAD_UPWARD_DYLIB);
	else
		cmd->set_cmd(LC_LOAD_DYLIB);
	cmd->set_cmdsize(sz);
	cmd->set_timestamp(2);	// needs to be some constant value that is different than DylibIDLoadCommandsAtom uses
	cmd->set_current_version(dylib->currentVersion());
	cmd->set_compatibility_version(dylib->compatibilityVersion());
	cmd->set_name_offset();
	strcpy((char*)&p[sizeof(macho_dylib_command<P>)], dylib->installPath());
	return p + sz;
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyRPathLoadCommand(uint8_t* p, const char* path) const
{
	uint32_t sz = alignedSize(sizeof(macho_rpath_command<P>) + strlen(path) + 1);
	macho_rpath_command<P>* cmd = (macho_rpath_command<P>*)p;
	cmd->set_cmd(LC_RPATH);
	cmd->set_cmdsize(sz);
	cmd->set_path_offset();
	strcpy((char*)&p[sizeof(macho_rpath_command<P>)], path);
	return p + sz;
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySubFrameworkLoadCommand(uint8_t* p) const
{
	const char* umbrellaName = _options.umbrellaName();
	uint32_t sz = alignedSize(sizeof(macho_sub_framework_command<P>) + strlen(umbrellaName) + 1);
	macho_sub_framework_command<P>* cmd = (macho_sub_framework_command<P>*)p;
	cmd->set_cmd(LC_SUB_FRAMEWORK);
	cmd->set_cmdsize(sz);
	cmd->set_umbrella_offset();
	strcpy((char*)&p[sizeof(macho_sub_framework_command<P>)], umbrellaName);
	return p + sz;
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyAllowableClientLoadCommand(uint8_t* p, const char* client) const
{
	uint32_t sz = alignedSize(sizeof(macho_sub_client_command<P>) + strlen(client) + 1);
	macho_sub_client_command<P>* cmd = (macho_sub_client_command<P>*)p;
	cmd->set_cmd(LC_SUB_CLIENT);
	cmd->set_cmdsize(sz);
	cmd->set_client_offset();
	strcpy((char*)&p[sizeof(macho_sub_client_command<P>)], client);
	return p + sz;
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyDyldEnvLoadCommand(uint8_t* p, const char* env) const
{
	uint32_t sz = alignedSize(sizeof(macho_dylinker_command<P>) + strlen(env) + 1);
	macho_dylinker_command<P>* cmd = (macho_dylinker_command<P>*)p;
	cmd->set_cmd(LC_DYLD_ENVIRONMENT);
	cmd->set_cmdsize(sz);
	cmd->set_name_offset();
	strcpy((char*)&p[sizeof(macho_dylinker_command<P>)], env);
	return p + sz;
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySubUmbrellaLoadCommand(uint8_t* p, const char* nm) const
{
	uint32_t sz = alignedSize(sizeof(macho_sub_umbrella_command<P>) + strlen(nm) + 1);
	macho_sub_umbrella_command<P>* cmd = (macho_sub_umbrella_command<P>*)p;
	cmd->set_cmd(LC_SUB_UMBRELLA);
	cmd->set_cmdsize(sz);
	cmd->set_sub_umbrella_offset();
	strcpy((char*)&p[sizeof(macho_sub_umbrella_command<P>)], nm);
	return p + sz;
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copySubLibraryLoadCommand(uint8_t* p, const char* nm) const
{
	uint32_t sz = alignedSize(sizeof(macho_sub_library_command<P>) + strlen(nm) + 1);
	macho_sub_library_command<P>* cmd = (macho_sub_library_command<P>*)p;
	cmd->set_cmd(LC_SUB_LIBRARY);
	cmd->set_cmdsize(sz);
	cmd->set_sub_library_offset();
	strcpy((char*)&p[sizeof(macho_sub_library_command<P>)], nm);
	return p + sz;
}

template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyFunctionStartsLoadCommand(uint8_t* p) const
{
	macho_linkedit_data_command<P>* cmd = (macho_linkedit_data_command<P>*)p;
	cmd->set_cmd(LC_FUNCTION_STARTS);
	cmd->set_cmdsize(sizeof(macho_linkedit_data_command<P>));
	cmd->set_dataoff(_writer.functionStartsSection->fileOffset);
	cmd->set_datasize(_writer.functionStartsSection->size);
	return p + sizeof(macho_linkedit_data_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyDataInCodeLoadCommand(uint8_t* p) const
{
	macho_linkedit_data_command<P>* cmd = (macho_linkedit_data_command<P>*)p;
	cmd->set_cmd(LC_DATA_IN_CODE);
	cmd->set_cmdsize(sizeof(macho_linkedit_data_command<P>));
	cmd->set_dataoff(_writer.dataInCodeSection->fileOffset);
	cmd->set_datasize(_writer.dataInCodeSection->size);
	return p + sizeof(macho_linkedit_data_command<P>);
}


template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyLinkerOptionsLoadCommand(uint8_t* p, const std::vector<const char*>& options) const
{
	macho_linker_option_command<P>* cmd = (macho_linker_option_command<P>*)p;
	cmd->set_cmd(LC_LINKER_OPTION);
	cmd->set_count(options.size());
	char* buffer = cmd->buffer();
	uint32_t sz = sizeof(macho_linker_option_command<P>);
	for (std::vector<const char*>::const_iterator it=options.begin(); it != options.end(); ++it) {
		const char* opt = *it;
		uint32_t len = strlen(opt);
		strcpy(buffer, opt);
		sz += (len + 1);
		buffer += (len + 1);
	}
	sz = alignedSize(sz);
	cmd->set_cmdsize(sz);	
	return p + sz;
}



template <typename A>
uint8_t* HeaderAndLoadCommandsAtom<A>::copyOptimizationHintsLoadCommand(uint8_t* p) const
{
	macho_linkedit_data_command<P>* cmd = (macho_linkedit_data_command<P>*)p;
	cmd->set_cmd(LC_LINKER_OPTIMIZATION_HINTS);
	cmd->set_cmdsize(sizeof(macho_linkedit_data_command<P>));
	cmd->set_dataoff(_writer.optimizationHintsSection->fileOffset);
	cmd->set_datasize(_writer.optimizationHintsSection->size);
	return p + sizeof(macho_linkedit_data_command<P>);
}


template <typename A>
void HeaderAndLoadCommandsAtom<A>::copyRawContent(uint8_t buffer[]) const
{
	macho_header<P>* mh = (macho_header<P>*)buffer;
	bzero(buffer, this->size());

	// copy mach_header
	mh->set_magic(this->magic());
	mh->set_cputype(this->cpuType());
	mh->set_cpusubtype(this->cpuSubType());
	mh->set_filetype(this->fileType());
	mh->set_ncmds(this->commandsCount());
	mh->set_sizeofcmds(this->size()-sizeof(macho_header<P>));
	mh->set_flags(this->flags());

	// copy load commands
	uint8_t* p = &buffer[sizeof(macho_header<P>)];
	
	if ( _options.outputKind() == Options::kObjectFile )
		p = this->copySingleSegmentLoadCommand(p);
	else
		p = this->copySegmentLoadCommands(p);
	
	if ( _hasDylibIDLoadCommand )
		p = this->copyDylibIDLoadCommand(p);
		
	if ( _hasDyldInfoLoadCommand )
		p = this->copyDyldInfoLoadCommand(p);
		
	if ( _hasSymbolTableLoadCommand )
		p = this->copySymbolTableLoadCommand(p);

	if ( _hasDynamicSymbolTableLoadCommand )
		p = this->copyDynamicSymbolTableLoadCommand(p);
	
	if ( _hasDyldLoadCommand )
		p = this->copyDyldLoadCommand(p);
		
	if ( _hasRoutinesLoadCommand ) 
		p = this->copyRoutinesLoadCommand(p);
		
	if ( _hasUUIDLoadCommand )
		p = this->copyUUIDLoadCommand(p);
	
	if ( _hasVersionLoadCommand )
		p = this->copyVersionLoadCommand(p);

	if ( _hasSourceVersionLoadCommand )
		p = this->copySourceVersionLoadCommand(p);

	if ( _hasThreadLoadCommand )
		p = this->copyThreadsLoadCommand(p);
	
	if ( _hasEntryPointLoadCommand )
		p = this->copyEntryPointLoadCommand(p);
		
	if ( _hasEncryptionLoadCommand )
		p = this->copyEncryptionLoadCommand(p);
	
	if ( _hasSplitSegInfoLoadCommand )
		p = this->copySplitSegInfoLoadCommand(p);
		
	for (uint32_t ord=1; ord <= _writer.dylibCount(); ++ord) {
		p = this->copyDylibLoadCommand(p, _writer.dylibByOrdinal(ord));
	}

	if ( _hasRPathLoadCommands ) {
		const std::vector<const char*>& rpaths = _options.rpaths();
		for (std::vector<const char*>::const_iterator it = rpaths.begin(); it != rpaths.end(); ++it) {
			p = this->copyRPathLoadCommand(p, *it);
		}
	}
	
	if ( _hasSubFrameworkLoadCommand )
		p = this->copySubFrameworkLoadCommand(p);
	
	for (std::vector<const char*>::const_iterator it = _subLibraryNames.begin(); it != _subLibraryNames.end(); ++it) {
		p = this->copySubLibraryLoadCommand(p, *it);
	}
	
	for (std::vector<const char*>::const_iterator it = _subUmbrellaNames.begin(); it != _subUmbrellaNames.end(); ++it) {
		p = this->copySubUmbrellaLoadCommand(p, *it);
	}
	
	if ( _allowableClientLoadCommmandsCount != 0 ) {
		const std::vector<const char*>& clients = _options.allowableClients();
		for (std::vector<const char*>::const_iterator it = clients.begin(); it != clients.end(); ++it) {
			p = this->copyAllowableClientLoadCommand(p, *it);
		}
	}

	if ( _dyldEnvironExrasCount != 0 ) {
		const std::vector<const char*>& extras = _options.dyldEnvironExtras();
		for (std::vector<const char*>::const_iterator it = extras.begin(); it != extras.end(); ++it) {
			p = this->copyDyldEnvLoadCommand(p, *it);
		}
	}

	if ( _hasFunctionStartsLoadCommand )
		p = this->copyFunctionStartsLoadCommand(p);

	if ( _hasDataInCodeLoadCommand )
		p = this->copyDataInCodeLoadCommand(p);

	if ( !_linkerOptions.empty() ) {
		for (ld::relocatable::File::LinkerOptionsList::const_iterator it = _linkerOptions.begin(); it != _linkerOptions.end(); ++it) {
			p = this->copyLinkerOptionsLoadCommand(p, *it);
		}
	}
	
	if ( _hasOptimizationHints )
		p = this->copyOptimizationHintsLoadCommand(p);
 
}



} // namespace tool 
} // namespace ld 

#endif // __HEADER_LOAD_COMMANDS_HPP__
                                                                                                                                                                                                                                                                              osxcross/build/cctools-877.5-ld64-253.3_4f8ad51/cctools/ld64/src/ld/InputFiles.cpp                  0100644 0001750 0001750 00000150243 12612724205 025171  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-*
 *
 * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
 

#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/sysctl.h>
#include <fcntl.h>
#include <errno.h>
#include <limits.h>
#include <unistd.h>
#include <mach/mach_time.h>
#include <mach/vm_statistics.h>
#include <mach/mach_init.h>
#include <mach/mach_host.h>
#include <dlfcn.h>
#include <mach-o/dyld.h>
#include <mach-o/fat.h>
#include <sys/sysctl.h>
#include <libkern/OSAtomic.h>

#include <string>
#include <map>
#include <set>
#include <string>
#include <vector>
#include <list>
#include <algorithm>
#include <dlfcn.h>
#include <AvailabilityMacros.h>

#include "Options.h"

#include "InputFiles.h"
#include "macho_relocatable_file.h"
#include "macho_dylib_file.h"
#include "textstub_dylib_file.hpp"
#include "archive_file.h"
#include "lto_file.h"
#include "opaque_section_file.h"
#include "MachOFileAbstraction.hpp"
#include "Snapshot.h"

const bool _s_logPThreads = false;

namespace ld {
namespace tool {

class IgnoredFile : public ld::File {
public:
	IgnoredFile(const char* pth, time_t modTime, Ordinal ord, Type type) : ld::File(pth, modTime, ord, type) {};
	virtual bool						forEachAtom(AtomHandler&) const { return false; };
	virtual bool						justInTimeforEachAtom(const char* name, AtomHandler&) const { return false; };
};


class DSOHandleAtom : public ld::Atom {
public:
									DSOHandleAtom(const char* nm, ld::Atom::Scope sc, 
														ld::Atom::SymbolTableInclusion inc, ld::Section& sect=_s_section)
										: ld::Atom(sect, ld::Atom::definitionRegular,
												   (sect == _s_section_text) ? ld::Atom::combineByName : ld::Atom::combineNever, 
												   // make "weak def" so that link succeeds even if app defines __dso_handle
													sc, ld::Atom::typeUnclassified, inc, true, false, false, 
													 ld::Atom::Alignment(1)), _name(nm) {}

	virtual ld::File*						file() const					{ return NULL; }
  virtual const char*						name() const					{ return _name; }
	virtual uint64_t						size() const					{ return 0; }
	virtual uint64_t						objectAddress() const			{ return 0; }
	virtual void							copyRawContent(uint8_t buffer[]) const
																			{ }
	virtual void							setScope(Scope)					{ }

	virtual									~DSOHandleAtom() {}
	
	static ld::Section						_s_section;
	static ld::Section						_s_section_preload;
	static ld::Section						_s_section_text;
	static DSOHandleAtom					_s_atomAll;
	static DSOHandleAtom					_s_atomExecutable;
	static DSOHandleAtom					_s_atomDylib;
	static DSOHandleAtom					_s_atomBundle;
	static DSOHandleAtom					_s_atomDyld;
	static DSOHandleAtom					_s_atomObjectFile;
	static DSOHandleAtom					_s_atomPreload;
	static DSOHandleAtom					_s_atomPreloadDSO;
private:
	const char*								_name;
};
ld::Section DSOHandleAtom::_s_section("__TEXT", "__mach_header", ld::Section::typeMachHeader, true);
ld::Section DSOHandleAtom::_s_section_preload("__HEADER", "__mach_header", ld::Section::typeMachHeader, true);
ld::Section DSOHandleAtom::_s_section_text("__TEXT", "__text", ld::Section::typeCode, false);
DSOHandleAtom DSOHandleAtom::_s_atomAll("___dso_handle", ld::Atom::scopeLinkageUnit, ld::Atom::symbolTableNotIn);
DSOHandleAtom DSOHandleAtom::_s_atomExecutable("__mh_execute_header", ld::Atom::scopeGlobal, ld::Atom::symbolTableInAndNeverStrip);
DSOHandleAtom DSOHandleAtom::_s_atomDylib("__mh_dylib_header", ld::Atom::scopeLinkageUnit, ld::Atom::symbolTableNotIn);
DSOHandleAtom DSOHandleAtom::_s_atomBundle("__mh_bundle_header", ld::Atom::scopeLinkageUnit, ld::Atom::symbolTableNotIn);
DSOHandleAtom DSOHandleAtom::_s_atomDyld("__mh_dylinker_header", ld::Atom::scopeLinkageUnit, ld::Atom::symbolTableNotIn);
DSOHandleAtom DSOHandleAtom::_s_atomObjectFile("__mh_object_header", ld::Atom::scopeLinkageUnit, ld::Atom::symbolTableNotIn);
DSOHandleAtom DSOHandleAtom::_s_atomPreload("__mh_preload_header", ld::Atom::scopeLinkageUnit, ld::Atom::symbolTableNotIn, _s_section_preload);
DSOHandleAtom DSOHandleAtom::_s_atomPreloadDSO("___dso_handle", ld::Atom::scopeLinkageUnit, ld::Atom::symbolTableNotIn, _s_section_text);



class PageZeroAtom : public ld::Atom {
public:
									PageZeroAtom(uint64_t sz)
										: ld::Atom(_s_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
											ld::Atom::scopeTranslationUnit, ld::Atom::typeZeroFill, 
											symbolTableNotIn, true, false, false, ld::Atom::Alignment(12)),
											_size(sz) {}

	virtual ld::File*						file() const					{ return NULL; }
	virtual const char*						name() const					{ return "page zero"; }
	virtual uint64_t						size() const					{ return _size; }
	virtual uint64_t						objectAddress() const			{ return 0; }
	virtual void							copyRawContent(uint8_t buffer[]) const 
																			{ }
	virtual void							setScope(Scope)					{ }

	virtual									~PageZeroAtom() {}
	
	static ld::Section						_s_section;
	static DSOHandleAtom					_s_atomAll;
private:
	uint64_t								_size;
};
ld::Section PageZeroAtom::_s_section("__PAGEZERO", "__pagezero", ld::Section::typePageZero, true);


class CustomStackAtom : public ld::Atom {
public:
									CustomStackAtom(uint64_t sz)
										: ld::Atom(_s_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
											ld::Atom::scopeTranslationUnit, ld::Atom::typeZeroFill, 
											symbolTableNotIn, false, false, false, ld::Atom::Alignment(12)),
											_size(sz) {}

	virtual ld::File*						file() const					{ return NULL; }
	virtual const char*						name() const					{ return "custom stack"; }
	virtual uint64_t						size() const					{ return _size; }
	virtual uint64_t						objectAddress() const			{ return 0; }
	virtual void							copyRawContent(uint8_t buffer[]) const 
																			{ }
	virtual void							setScope(Scope)					{ }

	virtual									~CustomStackAtom() {}
	
private:
	uint64_t								_size;
	static ld::Section						_s_section;
};
ld::Section CustomStackAtom::_s_section("__UNIXSTACK", "__stack", ld::Section::typeStack, true);



const char* InputFiles::fileArch(const uint8_t* p, unsigned len)
{
	const char* result = mach_o::relocatable::archName(p);
	if ( result != NULL  )
		 return result;

    result = mach_o::dylib::archName(p);
    if ( result != NULL  )
		return result;

#ifdef LTO_SUPPORT
	result = lto::archName(p, len);
	if ( result != NULL  )
		 return result;
#endif /* LTO_SUPPORT */
	
	if ( strncmp((const char*)p, "!<arch>\n", 8) == 0 )
		return "archive";
	
	char *unsupported = (char *)malloc(128);
	strcpy(unsupported, "unsupported file format (");
	for (unsigned i=0; i<len && i < 16; i++) {
		char buf[8];
		sprintf(buf, " 0x%02X", p[i]);
		strcat(unsupported, buf);
	}
	strcat(unsupported, " )");
	return unsupported;
}


ld::File* InputFiles::makeFile(const Options::FileInfo& info, bool indirectDylib)
{
	// map in whole file
	uint64_t len = info.fileLen;
	int fd = ::open(info.path, O_RDONLY, 0);
	if ( fd == -1 )
		throwf("can't open file, errno=%d", errno);
	if ( info.fileLen < 20 )
		throwf("file too small (length=%llu)", info.fileLen);

	uint8_t* p = (uint8_t*)::mmap(NULL, info.fileLen, PROT_READ, MAP_FILE | MAP_PRIVATE, fd, 0);
	if ( p == (uint8_t*)(-1) )
		throwf("can't map file, errno=%d", errno);

	// if fat file, skip to architecture we want
	// Note: fat header is always big-endian
	bool isFatFile = false;
	uint32_t sliceToUse, sliceCount;
	const fat_header* fh = (fat_header*)p;
        sliceCount = 0; // ld64-port
	if ( fh->magic == OSSwapBigToHostInt32(FAT_MAGIC) ) {
		isFatFile = true;
		const struct fat_arch* archs = (struct fat_arch*)(p + sizeof(struct fat_header));
		bool sliceFound = false;
		sliceCount = OSSwapBigToHostInt32(fh->nfat_arch);
		if ( _options.preferSubArchitecture() ) {
			// first try to find a slice that match cpu-type and cpu-sub-type
			for (uint32_t i=0; i < sliceCount; ++i) {
				if ( (OSSwapBigToHostInt32(archs[i].cputype) == (uint32_t)_options.architecture())
				  && (OSSwapBigToHostInt32(archs[i].cpusubtype) == (uint32_t)_options.subArchitecture()) ) {
					sliceToUse = i;
					sliceFound = true;
					break;
				}
			}
		}
		if ( !sliceFound ) {
			// look for any slice that matches just cpu-type
			for (uint32_t i=0; i < sliceCount; ++i) {
				if ( OSSwapBigToHostInt32(archs[i].cputype) == (uint32_t)_options.architecture() ) {
					sliceToUse = i;
					sliceFound = true;
					break;
				}
			}
		}
		if ( sliceFound ) {
			uint32_t fileOffset = OSSwapBigToHostInt32(archs[sliceToUse].offset);
			len = OSSwapBigToHostInt32(archs[sliceToUse].size);
			if ( fileOffset+len > info.fileLen ) {
				// <rdar://problem/17593430> file size was read awhile ago.  If file is being written, wait a second to see if big enough now
				sleep(1);
				uint64_t newFileLen = info.fileLen;
				struct stat statBuffer;
				if ( stat(info.path, &statBuffer) == 0 ) {
					newFileLen = statBuffer.st_size;
				}
				if ( fileOffset+len > newFileLen ) {
					throwf("truncated fat file. Slice from %u to %llu is past end of file with length %llu", 
						fileOffset, fileOffset+len, info.fileLen);
				}
			}
			// if requested architecture is page aligned within fat file, then remap just that portion of file
			// ld64-port: remapping the file on Cygwin fails for an unknown reason, so always go the alternative way there
#ifndef __CYGWIN__
			if ( (fileOffset & 0x00000FFF) == 0 ) {
				// unmap whole file
				munmap((caddr_t)p, info.fileLen);
				// re-map just part we need
				p = (uint8_t*)::mmap(NULL, len, PROT_READ, MAP_FILE | MAP_PRIVATE, fd, fileOffset);
				if ( p == (uint8_t*)(-1) )
					throwf("can't re-map file, errno=%d", errno);
			}
			else {
#endif /* __CYGWIN__ */
				p = &p[fileOffset];
#ifndef __CYGWIN__
			}
#endif /* __CYGWIN__ */
		}
	}
	::close(fd);

	// see if it is an object file
	mach_o::relocatable::ParserOptions objOpts;
	objOpts.architecture		= _options.architecture();
	objOpts.objSubtypeMustMatch = !_options.allowSubArchitectureMismatches();
	objOpts.logAllFiles			= _options.logAllFiles();
	objOpts.warnUnwindConversionProblems	= _options.needsUnwindInfoSection();
	objOpts.keepDwarfUnwind		= _options.keepDwarfUnwind();
	objOpts.forceDwarfConversion= (_options.outputKind() == Options::kDyld);
	objOpts.neverConvertDwarf   = !_options.needsUnwindInfoSection();
	objOpts.verboseOptimizationHints = _options.verboseOptimizationHints();
	objOpts.armUsesZeroCostExceptions = _options.armUsesZeroCostExceptions();
	objOpts.simulator			= _options.targetIOSSimulator();
	objOpts.ignoreMismatchPlatform = ((_options.outputKind() == Options::kPreload) || (_options.outputKind() == Options::kStaticExecutable));
	objOpts.subType				= _options.subArchitecture();
	objOpts.platform			= _options.platform();
	objOpts.minOSVersion		= _options.minOSversion();
	// workaround for strip -S
	// when ld -r has single input file, set the srcKind to kSourceSingle so __LLVM segment will be kept
	if (_options.outputKind() == Options::kObjectFile && _options.getInputFiles().size() == 1)
		objOpts.srcKind			= ld::relocatable::File::kSourceSingle;
	else
		objOpts.srcKind				= ld::relocatable::File::kSourceObj;
	ld::relocatable::File* objResult = mach_o::relocatable::parse(p, len, info.path, info.modTime, info.ordinal, objOpts);
	if ( objResult != NULL ) {
		OSAtomicAdd64(len, &_totalObjectSize);
		OSAtomicIncrement32(&_totalObjectLoaded);
		return objResult;
	}

#ifdef LTO_SUPPORT
	// see if it is an llvm object file
	objResult = lto::parse(p, len, info.path, info.modTime, info.ordinal, _options.architecture(), _options.subArchitecture(), _options.logAllFiles(), _options.verboseOptimizationHints());
	if ( objResult != NULL ) {
		OSAtomicAdd64(len, &_totalObjectSize);
		OSAtomicIncrement32(&_totalObjectLoaded);
		return objResult;
	}
#endif /* LTO_SUPPORT */
	
	// see if it is a dynamic library (or text-based dynamic library)
	ld::dylib::File* dylibResult;
	bool dylibsNotAllowed = false;
	switch ( _options.outputKind() ) {
		case Options::kDynamicExecutable:
		case Options::kDynamicLibrary:
		case Options::kDynamicBundle:	
			dylibResult = mach_o::dylib::parse(p, len, info.path, info.modTime, _options, info.ordinal, info.options.fBundleLoader, indirectDylib);
			if ( dylibResult != NULL ) {
				return dylibResult;
			}
			dylibResult = textstub::dylib::parse(p, len, info.path, info.modTime, _options, info.ordinal, info.options.fBundleLoader, indirectDylib);
			if ( dylibResult != NULL ) {
				return dylibResult;
			}
			break;
		case Options::kStaticExecutable:
		case Options::kDyld:
		case Options::kPreload:
		case Options::kObjectFile:
		case Options::kKextBundle:
			dylibsNotAllowed = true;
			break;
	}

	// see if it is a static library
	::archive::ParserOptions archOpts;
	archOpts.objOpts				= objOpts;
	archOpts.forceLoadThisArchive	= info.options.fForceLoad;
	archOpts.forceLoadAll			= _options.fullyLoadArchives();
	archOpts.forceLoadObjC			= _options.loadAllObjcObjectsFromArchives();
	archOpts.objcABI2				= _options.objCABIVersion2POverride();
	archOpts.verboseLoad			= _options.whyLoad();
	archOpts.logAllFiles			= _options.logAllFiles();
	// Set ObjSource Kind, libclang_rt is compiler static library
	const char* libName = strrchr(info.path, '/');
	if ( (libName != NULL) && (strncmp(libName, "/libclang_rt", 12) == 0) )
		archOpts.objOpts.srcKind = ld::relocatable::File::kSourceCompilerArchive;
	else
		archOpts.objOpts.srcKind = ld::relocatable::File::kSourceArchive;
	ld::archive::File* archiveResult = ::archive::parse(p, len, info.path, info.modTime, info.ordinal, archOpts);
	if ( archiveResult != NULL ) {
		OSAtomicAdd64(len, &_totalArchiveSize);
		OSAtomicIncrement32(&_totalArchivesLoaded);
		return archiveResult;
	}
	
#ifdef LTO_SUPPORT
	// does not seem to be any valid linker input file, check LTO misconfiguration problems
	if ( lto::archName((uint8_t*)p, len) != NULL ) {
		if ( lto::libLTOisLoaded() ) {
			throwf("lto file was built for %s which is not the architecture being linked (%s): %s", fileArch(p, len), _options.architectureName(), info.path);
		}
		else {
#ifdef __APPLE__ // ld64-port
      const char* libLTO = "libLTO.dylib";
#else
      const char* libLTO = "libLTO.so";
#endif /* __APPLE__ */

			char ldPath[PATH_MAX];
			char tmpPath[PATH_MAX];
			char libLTOPath[PATH_MAX];
			uint32_t bufSize = PATH_MAX;
			if ( _options.overridePathlibLTO() != NULL ) {
				libLTO = _options.overridePathlibLTO();
			}
			else if ( _NSGetExecutablePath(ldPath, &bufSize) != -1 ) {
				if ( realpath(ldPath, tmpPath) != NULL ) {
					char* lastSlash = strrchr(tmpPath, '/');
					if ( lastSlash != NULL )
						strcpy(lastSlash, "/../lib/llvm/libLTO.so");
					libLTO = tmpPath;
					if ( realpath(tmpPath, libLTOPath) != NULL ) 
						libLTO = libLTOPath;
				}
			}
			throwf("could not process llvm bitcode object file, because %s could not be loaded", libLTO);
		}
	}
#endif /* LTO_SUPPORT */

	if ( dylibsNotAllowed ) {
		cpu_type_t dummy1;
		cpu_type_t dummy2;
		if ( mach_o::dylib::isDylibFile(p, &dummy1, &dummy2) )
			throw "ignoring unexpected dylib file";
	}

	// error handling
	if ( ((fat_header*)p)->magic == OSSwapBigToHostInt32(FAT_MAGIC) ) {
		throwf("missing required architecture %s in file %s (%u slices)", _options.architectureName(), info.path, sliceCount);
	}
	else {
		if ( isFatFile )
			throwf("file is universal (%u slices) but does not contain a(n) %s slice: %s", sliceCount, _options.architectureName(), info.path);
		else
			throwf("file was built for %s which is not the architecture being linked (%s): %s", fileArch(p, len), _options.architectureName(), info.path);
	}
}

void InputFiles::logDylib(ld::File* file, bool indirect)
{
	if ( _options.traceDylibs() ) {
		const char* fullPath = file->path();
		char realName[MAXPATHLEN];
		if ( realpath(fullPath, realName) != NULL )
			fullPath = realName;
		const ld::dylib::File* dylib = dynamic_cast<const ld::dylib::File*>(file);
		if ( (dylib != NULL ) && dylib->willBeUpwardDylib() ) {
			// don't log upward dylibs when XBS is computing dependencies
			logTraceInfo("[Logging for XBS] Used upward dynamic library: %s\n", fullPath);
		}
		else {
			if ( indirect ) 
				logTraceInfo("[Logging for XBS] Used indirect dynamic library: %s\n", fullPath);
			else 
				logTraceInfo("[Logging for XBS] Used dynamic library: %s\n", fullPath);
		}
	}
	
	if ( _options.dumpDependencyInfo() ) {
		const ld::dylib::File* dylib = dynamic_cast<const ld::dylib::File*>(file);
		if ( file == _bundleLoader ) {
			_options.dumpDependency(Options::depBundleLoader, file->path());
		}
		else if ( (dylib != NULL ) && dylib->willBeUpwardDylib() ) {
			if ( indirect ) 
				_options.dumpDependency(Options::depUpwardIndirectDylib, file->path());
			else 
				_options.dumpDependency(Options::depUpwardDirectDylib, file->path());
		}
		else {
			if ( indirect ) 
				_options.dumpDependency(Options::depIndirectDylib, file->path());
			else 
				_options.dumpDependency(Options::depDirectDylib, file->path());
		}
	}
}

void InputFiles::logArchive(ld::File* file) const
{
	if ( _options.traceArchives() && (_archiveFilesLogged.count(file) == 0) ) {
		// <rdar://problem/4947347> LD_TRACE_ARCHIVES should only print out when a .o is actually used from an archive
		_archiveFilesLogged.insert(file);
		const char* fullPath = file->path();
		char realName[MAXPATHLEN];
		if ( realpath(fullPath, realName) != NULL )
			fullPath = realName;
		logTraceInfo("[Logging for XBS] Used static archive: %s\n", fullPath);
	}
}


void InputFiles::logTraceInfo(const char* format, ...) const
{
	// one time open() of custom LD_TRACE_FILE
	static int trace_file = -1;
	if ( trace_file == -1 ) {
		const char *trace_file_path = _options.traceOutputFile();
		if ( trace_file_path != NULL ) {
			trace_file = open(trace_file_path, O_WRONLY | O_APPEND | O_CREAT, 0666);
			if ( trace_file == -1 )
				throwf("Could not open or create trace file (errno=%d): %s", errno, trace_file_path);
		}
		else {
			trace_file = fileno(stderr);
		}
	}

	char trace_buffer[MAXPATHLEN * 2];
    va_list ap;
	va_start(ap, format);
	int length = vsnprintf(trace_buffer, sizeof(trace_buffer), format, ap);
	va_end(ap);
	char* buffer_ptr = trace_buffer;

	while (length > 0) {
		ssize_t amount_written = write(trace_file, buffer_ptr, length);
		if(amount_written == -1)
			/* Failure to write shouldn't fail the build. */
			return;
		buffer_ptr += amount_written;
		length -= amount_written;
	}
}


ld::dylib::File* InputFiles::findDylib(const char* installPath, const char* fromPath)
{
	//fprintf(stderr, "findDylib(%s, %s)\n", installPath, fromPath);
	InstallNameToDylib::iterator pos = _installPathToDylibs.find(installPath);
	if ( pos != _installPathToDylibs.end() ) {
		return pos->second;
	}
	else {
		// allow -dylib_path option to override indirect library to use
		for (std::vector<Options::DylibOverride>::const_iterator dit = _options.dylibOverrides().begin(); dit != _options.dylibOverrides().end(); ++dit) {
			if ( strcmp(dit->installName,installPath) == 0 ) {
				try {
					Options::FileInfo info = _options.findFile(dit->useInstead);
					_indirectDylibOrdinal = _indirectDylibOrdinal.nextIndirectDylibOrdinal();
					info.ordinal = _indirectDylibOrdinal;
					info.options.fIndirectDylib = true;
					ld::File* reader = this->makeFile(info, true);
					ld::dylib::File* dylibReader = dynamic_cast<ld::dylib::File*>(reader);
					if ( dylibReader != NULL ) {
						addDylib(dylibReader, info);
						//_installPathToDylibs[strdup(installPath)] = dylibReader;
						this->logDylib(dylibReader, true);
						return dylibReader;
					}
					else 
						throwf("indirect dylib at %s is not a dylib", dit->useInstead);
				}
				catch (const char* msg) {
					warning("ignoring -dylib_file option, %s", msg);
				}
			}
		}
		char newPath[MAXPATHLEN];
		// handle @loader_path
		if ( strncmp(installPath, "@loader_path/", 13) == 0 ) {
			strcpy(newPath, fromPath);
			char* addPoint = strrchr(newPath,'/');
			if ( addPoint != NULL )
				strcpy(&addPoint[1], &installPath[13]);
			else
				strcpy(newPath, &installPath[13]);
			installPath = newPath;
		}
		// note: @executable_path case is handled inside findFileUsingPaths()
		// search for dylib using -F and -L paths
		Options::FileInfo info = _options.findFileUsingPaths(installPath);
		_indirectDylibOrdinal = _indirectDylibOrdinal.nextIndirectDylibOrdinal();
		info.ordinal = _indirectDylibOrdinal;
		info.options.fIndirectDylib = true;
		try {
			ld::File* reader = this->makeFile(info, true);
			ld::dylib::File* dylibReader = dynamic_cast<ld::dylib::File*>(reader);
			if ( dylibReader != NULL ) {
				//assert(_installPathToDylibs.find(installPath) !=  _installPathToDylibs.end());
				//_installPathToDylibs[strdup(installPath)] = dylibReader;
				addDylib(dylibReader, info);
				this->logDylib(dylibReader, true);
				return dylibReader;
			}
			else 
				throwf("indirect dylib at %s is not a dylib", info.path);
		}
		catch (const char* msg) {
			throwf("in '%s', %s", info.path, msg);
		}
	}
}


// mark all dylibs initially specified as required, and check if they can be used
void InputFiles::markExplicitlyLinkedDylibs()
{	
	for (InstallNameToDylib::iterator it=_installPathToDylibs.begin(); it != _installPathToDylibs.end(); it++) {
		it->second->setExplicitlyLinked();
		this->checkDylibClientRestrictions(it->second);
	}
}

bool InputFiles::libraryAlreadyLoaded(const char* path) 
{
	for (std::vector<ld::File*>::const_iterator it = _inputFiles.begin(); it != _inputFiles.end(); ++it) {
		if ( strcmp(path, (*it)->path()) == 0 )
			return true;
	}
	return false;
}


void InputFiles::addLinkerOptionLibraries(ld::Internal& state, ld::File::AtomHandler& handler)
{	
    if ( _options.outputKind() == Options::kObjectFile ) 
		return;

	// process frameworks specified in .o linker options
	for (CStringSet::const_iterator it = state.linkerOptionFrameworks.begin(); it != state.linkerOptionFrameworks.end(); ++it) {
		const char* frameworkName = *it;
		Options::FileInfo info = _options.findFramework(frameworkName);
		if ( ! this->libraryAlreadyLoaded(info.path) ) {
			info.ordinal = _linkerOptionOrdinal.nextLinkerOptionOrdinal();
			try {
				ld::File* reader = this->makeFile(info, true);
				ld::dylib::File* dylibReader = dynamic_cast<ld::dylib::File*>(reader);
				if ( dylibReader != NULL ) {
					if ( ! dylibReader->installPathVersionSpecific() ) {
						dylibReader->forEachAtom(handler);
						dylibReader->setImplicitlyLinked();
						this->addDylib(dylibReader, info);
					}
				}
				else {
					throwf("framework linker option at %s is not a dylib", info.path);
				}
			}
			catch (const char* msg) {
				warning("Auto-Linking supplied '%s', %s", info.path, msg);
			}
		}
	}
	// process libraries specified in .o linker options
	for (CStringSet::const_iterator it = state.linkerOptionLibraries.begin(); it != state.linkerOptionLibraries.end(); ++it) {
		const char* libName = *it;
		Options::FileInfo info = _options.findLibrary(libName);
		if ( ! this->libraryAlreadyLoaded(info.path) ) {
			info.ordinal = _linkerOptionOrdinal.nextLinkerOptionOrdinal();
			try {
				//<rdar://problem/17787306> -force_load_swift_libs
				info.options.fForceLoad = _options.forceLoadSwiftLibs() && (strncmp(libName, "swift", 5) == 0);
				ld::File* reader = this->makeFile(info, true);
				ld::dylib::File* dylibReader = dynamic_cast<ld::dylib::File*>(reader);
				ld::archive::File* archiveReader = dynamic_cast<ld::archive::File*>(reader);
				if ( dylibReader != NULL ) {
					dylibReader->forEachAtom(handler);
					dylibReader->setImplicitlyLinked();
					this->addDylib(dylibReader, info);
				}
				else if ( archiveReader != NULL ) {
					_searchLibraries.push_back(LibraryInfo(archiveReader));
					if ( _options.dumpDependencyInfo() )
						_options.dumpDependency(Options::depArchive, archiveReader->path());
					//<rdar://problem/17787306> -force_load_swift_libs
					if (info.options.fForceLoad) {
						archiveReader->forEachAtom(handler);
					}
				}
				else {
					throwf("linker option dylib at %s is not a dylib", info.path);
				}
			}
			catch (const char* msg) {
				warning("Auto-Linking supplied '%s', %s", info.path, msg);
			}
		}
	}
}

void InputFiles::createIndirectDylibs()
{	
	// keep processing dylibs until no more dylibs are added
	unsigned long lastMapSize = 0;
	std::set<ld::dylib::File*>  dylibsProcessed;
	while ( lastMapSize != _allDylibs.size() ) {
		lastMapSize = _allDylibs.size();
		// can't iterator _installPathToDylibs while modifying it, so use temp buffer
		std::vector<ld::dylib::File*> unprocessedDylibs;
		for (std::set<ld::dylib::File*>::iterator it=_allDylibs.begin(); it != _allDylibs.end(); it++) {
			if ( dylibsProcessed.count(*it) == 0 )
				unprocessedDylibs.push_back(*it);
		}
		for (std::vector<ld::dylib::File*>::iterator it=unprocessedDylibs.begin(); it != unprocessedDylibs.end(); it++) {
			dylibsProcessed.insert(*it);
			(*it)->processIndirectLibraries(this, _options.implicitlyLinkIndirectPublicDylibs());
		}
	}
	
	// go back over original dylibs and mark sub frameworks as re-exported
	if ( _options.outputKind() == Options::kDynamicLibrary ) {
		const char* myLeaf = strrchr(_options.installPath(), '/');
		if ( myLeaf != NULL ) {
			for (std::vector<class ld::File*>::const_iterator it=_inputFiles.begin(); it != _inputFiles.end(); it++) {
				ld::dylib::File* dylibReader = dynamic_cast<ld::dylib::File*>(*it);
				if ( dylibReader != NULL ) {
					const char* childParent = dylibReader->parentUmbrella();
					if ( childParent != NULL ) {
						if ( strcmp(childParent, &myLeaf[1]) == 0 ) {
							// mark that this dylib will be re-exported
							dylibReader->setWillBeReExported();
						}
					}
				}
			}
		}
	}
	
}

void InputFiles::createOpaqueFileSections()
{
	// extra command line sections always at end
	for (Options::ExtraSection::const_iterator it=_options.extraSectionsBegin(); it != _options.extraSectionsEnd(); ++it) {
		_inputFiles.push_back(opaque_section::parse(it->segmentName, it->sectionName, it->path, it->data, it->dataLen));
		if ( _options.dumpDependencyInfo() )
			_options.dumpDependency(Options::depSection, it->path);
	}

}


void InputFiles::checkDylibClientRestrictions(ld::dylib::File* dylib)
{
	// Check for any restrictions on who can link with this dylib  
	const char* dylibParentName = dylib->parentUmbrella() ;
	const std::vector<const char*>* clients = dylib->allowableClients();
	if ( (dylibParentName != NULL) || (clients != NULL) ) {
		// only dylibs that are in an umbrella or have a client list need verification
		const char* installName = _options.installPath();
		const char* installNameLastSlash = strrchr(installName, '/');
		bool isParent = false;
		bool isSibling = false;
		bool isAllowableClient = false;
		// There are three cases:
		if ( (dylibParentName != NULL) && (installNameLastSlash != NULL) ) {
			// starts after last slash
			const char* myName = &installNameLastSlash[1];
			unsigned int myNameLen = strlen(myName);
			if ( strncmp(myName, "lib", 3) == 0 )
				myName = &myName[3];
			// up to first dot
			const char* firstDot = strchr(myName, '.');
			if ( firstDot != NULL )
				myNameLen = firstDot - myName;
			// up to first underscore
			const char* firstUnderscore = strchr(myName, '_');
			if ( (firstUnderscore != NULL) && ((firstUnderscore - myName) < (int)myNameLen) )
				myNameLen = firstUnderscore - myName;
		
			// case 1) The dylib has a parent umbrella, and we are creating the parent umbrella
			isParent = ( (strlen(dylibParentName) == myNameLen) && (strncmp(myName, dylibParentName, myNameLen) == 0) );
			
			// case 2) The dylib has a parent umbrella, and we are creating a sibling with the same parent
			isSibling = ( (_options.umbrellaName() != NULL) && (strcmp(_options.umbrellaName(), dylibParentName) == 0) );
		}

		if ( !isParent && !isSibling && (clients != NULL) ) {
			// case 3) the dylib has a list of allowable clients, and we are creating one of them
			const char* clientName = _options.clientName();
			int clientNameLen = 0;
			if ( clientName != NULL ) {
				// use client name as specified on command line
				clientNameLen = strlen(clientName);
			}
			else {
				// infer client name from output path (e.g. xxx/libfoo_variant.A.dylib --> foo, Bar.framework/Bar_variant --> Bar)
				clientName = installName;
				clientNameLen = strlen(clientName);
				// starts after last slash
				if ( installNameLastSlash != NULL )
					clientName = &installNameLastSlash[1];
				if ( strncmp(clientName, "lib", 3) == 0 )
					clientName = &clientName[3];
				// up to first dot
				const char* firstDot = strchr(clientName, '.');
				if ( firstDot != NULL )
					clientNameLen = firstDot - clientName;
				// up to first underscore
				const char* firstUnderscore = strchr(clientName, '_');
				if ( (firstUnderscore != NULL) && ((firstUnderscore - clientName) < clientNameLen) )
					clientNameLen = firstUnderscore - clientName;
			}

			// Use clientName to check if this dylib is able to link against the allowable clients.
			for (std::vector<const char*>::const_iterator it = clients->begin(); it != clients->end(); it++) {
				if ( strncmp(*it, clientName, clientNameLen) == 0 )
					isAllowableClient = true;
			}
		}
	
		if ( !isParent && !isSibling && !isAllowableClient ) {
			if ( dylibParentName != NULL ) {
				throwf("cannot link directly with %s.  Link against the umbrella framework '%s.framework' instead.", 
					dylib->path(), dylibParentName);
			}
			else {
				throwf("cannot link directly with %s", dylib->path());
			}
		}
	}
}


void InputFiles::inferArchitecture(Options& opts, const char** archName)
{
	_inferredArch = true;
	// scan all input files, looking for a thin .o file.
	// the first one found is presumably the architecture to link
	uint8_t buffer[4096];
	const std::vector<Options::FileInfo>& files = opts.getInputFiles();
	for (std::vector<Options::FileInfo>::const_iterator it = files.begin(); it != files.end(); ++it) {
		int fd = ::open(it->path, O_RDONLY, 0);
		if ( fd != -1 ) {
			struct stat stat_buf;
			if ( fstat(fd, &stat_buf) != -1) {
				ssize_t readAmount = stat_buf.st_size;
				if ( 4096 < readAmount )
					readAmount = 4096;
				ssize_t amount = read(fd, buffer, readAmount);
				::close(fd);
				if ( amount >= readAmount ) {
					cpu_type_t type;
					cpu_subtype_t subtype;
					Options::Platform platform;
					if ( mach_o::relocatable::isObjectFile(buffer, &type, &subtype, &platform) ) {
						opts.setArchitecture(type, subtype, platform);
						*archName = opts.architectureName();
						return;
					}
				}
			}
		}
	}

	// no thin .o files found, so default to same architecture this tool was built as
	warning("-arch not specified");
#if __i386__
	opts.setArchitecture(CPU_TYPE_I386, CPU_SUBTYPE_X86_ALL, Options::kPlatformOSX);
#elif __x86_64__
	opts.setArchitecture(CPU_TYPE_X86_64, CPU_SUBTYPE_X86_64_ALL, Options::kPlatformOSX);
#elif __ppc__ // ld64-port
    opts.setArchitecture(CPU_TYPE_POWERPC, CPU_SUBTYPE_POWERPC_ALL, Options::kPlatformOSX);
#elif __ppc64__ // ld64-port
    opts.setArchitecture(CPU_TYPE_POWERPC64, CPU_SUBTYPE_POWERPC_ALL, Options::kPlatformOSX);
#elif __arm__
	opts.setArchitecture(CPU_TYPE_ARM, CPU_SUBTYPE_ARM_V6, Options::kPlatformiOS); // ld64-port: Options::kPlatformOSX -> Options::kPlatformiOS
#elif __arm64__ // ld64-port
	opts.setArchitecture(CPU_TYPE_ARM, CPU_SUBTYPE_ARM64_ALL, Options::kPlatformiOS);
#else
	#error unknown default architecture
#endif
	*archName = opts.architectureName();
}


InputFiles::InputFiles(Options& opts, const char** archName) 
 : _totalObjectSize(0), _totalArchiveSize(0), 
   _totalObjectLoaded(0), _totalArchivesLoaded(0), _totalDylibsLoaded(0),
	_options(opts), _bundleLoader(NULL), 
	_inferredArch(false),
	_exception(NULL), 
	_indirectDylibOrdinal(ld::File::Ordinal::indirectDylibBase()),
	_linkerOptionOrdinal(ld::File::Ordinal::linkeOptionBase())
{
//	fStartCreateReadersTime = mach_absolute_time();
	if ( opts.architecture() == 0 ) {
		// command line missing -arch, so guess arch
		inferArchitecture(opts, archName);
	}
#if HAVE_PTHREADS
	pthread_mutex_init(&_parseLock, NULL);
	pthread_cond_init(&_parseWorkReady, NULL);
	pthread_cond_init(&_newFileAvailable, NULL);
#endif
	const std::vector<Options::FileInfo>& files = _options.getInputFiles();
	if ( files.size() == 0 )
		throw "no object files specified";

	_inputFiles.reserve(files.size());
#if HAVE_PTHREADS
	unsigned int inputFileSlot = 0;
	_availableInputFiles = 0;
	_parseCursor = 0;
#endif
	Options::FileInfo* entry;
	for (std::vector<Options::FileInfo>::const_iterator it = files.begin(); it != files.end(); ++it) {
		entry = (Options::FileInfo*)&(*it);
#if HAVE_PTHREADS
		// Assign input file slots to all the FileInfos.
		// Also chain all FileInfos into one big list to set up for worker threads to do parsing.
		entry->inputFileSlot = inputFileSlot;
		entry->readyToParse = !entry->fromFileList || !_options.pipelineEnabled();
		if (entry->readyToParse)
			_availableInputFiles++;
		_inputFiles.push_back(NULL);
		inputFileSlot++;
#else
		// In the non-threaded case just parse the file now.
		_inputFiles.push_back(makeFile(*entry, false));
#endif
	}
	
#if HAVE_PTHREADS
	_remainingInputFiles = files.size();
	
	// initialize info for parsing input files on worker threads
	unsigned int ncpus;
	int mib[2];
	size_t len = sizeof(ncpus);
	mib[0] = CTL_HW;
	mib[1] = HW_NCPU;
	if (sysctl(mib, 2, &ncpus, &len, NULL, 0) != 0) {
		ncpus = 1;
	}
	_availableWorkers = MIN(ncpus, files.size()); // max # workers we permit
	_idleWorkers = 0;
	
	if (_options.pipelineEnabled()) {
		// start up a thread to listen for available input files
		startThread(InputFiles::waitForInputFiles);
	}

	// Start up one parser thread. More start on demand as parsed input files get consumed.
	startThread(InputFiles::parseWorkerThread);
	_availableWorkers--;
#else
	if (_options.pipelineEnabled()) {
		throwf("pipelined linking not supported on this platform");
	}
#endif
}


#if HAVE_PTHREADS
void InputFiles::startThread(void (*threadFunc)(InputFiles *)) const {
	pthread_t thread;
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	// set a nice big stack (same as main thread) because some code uses potentially large stack buffers
	pthread_attr_setstacksize(&attr, 8 * 1024 * 1024);
	pthread_create(&thread, &attr, (void *(*)(void*))threadFunc, (void *)this);
	pthread_detach(thread);
	pthread_attr_destroy(&attr);
}

// Work loop for input file parsing threads
void InputFiles::parseWorkerThread() {
	ld::File *file;
	const char *exception = NULL;
	pthread_mutex_lock(&_parseLock);
	const std::vector<Options::FileInfo>& files = _options.getInputFiles();
	if (_s_logPThreads) printf("worker starting\n");
	do {
		if (_availableInputFiles == 0) {
			_idleWorkers++;
			pthread_cond_wait(&_parseWorkReady, &_parseLock);
			_idleWorkers--;
		} else {
			int slot = _parseCursor;
			while (slot < (int)files.size() && (_inputFiles[slot] != NULL || !files[slot].readyToParse))
				slot++;
			assert(slot < (int)files.size());
			Options::FileInfo& entry = (Options::FileInfo&)files[slot];
			_parseCursor = slot+1;
			_availableInputFiles--;
			entry.readyToParse = false; // to avoid multiple threads finding this file
			pthread_mutex_unlock(&_parseLock);
			if (_s_logPThreads) printf("parsing index %u\n", slot);
			try {
				file = makeFile(entry, false);
			} 
			catch (const char *msg) {
				if ( (strstr(msg, "architecture") != NULL) && !_options.errorOnOtherArchFiles() ) {
					if ( _options.ignoreOtherArchInputFiles() ) {
						// ignore, because this is about an architecture not in use
					}
					else {
						warning("ignoring file %s, %s", entry.path, msg);
					}
				} 
				else if ( strstr(msg, "ignoring unexpected") != NULL ) {
					warning("%s, %s", entry.path, msg);
				}
				else {
					asprintf((char**)&exception, "%s file '%s'", msg, entry.path);
				}
				file = new IgnoredFile(entry.path, entry.modTime, entry.ordinal, ld::File::Other);
			}
			pthread_mutex_lock(&_parseLock);
			if (_remainingInputFiles > 0)
				_remainingInputFiles--;
			if (_s_logPThreads) printf("done with index %u, %d remaining\n", slot, _remainingInputFiles);
			if (exception) {
				// We are about to die, so set to zero to stop other threads from doing unneeded work.
				_remainingInputFiles = 0;
				_exception = exception;
			} 
			else {
				_inputFiles[slot] = file;
				if (_neededFileSlot == slot)
					pthread_cond_signal(&_newFileAvailable);
			}
		}
	} while (_remainingInputFiles);
	if (_s_logPThreads) printf("worker exiting\n");
	pthread_cond_broadcast(&_parseWorkReady);
	pthread_cond_signal(&_newFileAvailable);
	pthread_mutex_unlock(&_parseLock);
}


void InputFiles::parseWorkerThread(InputFiles *inputFiles) {
	inputFiles->parseWorkerThread();
}
#endif


ld::File* InputFiles::addDylib(ld::dylib::File* reader, const Options::FileInfo& info)
{
	_allDylibs.insert(reader);
	
	if ( (reader->installPath() == NULL) && !info.options.fBundleLoader ) {
		// this is a "blank" stub
		// silently ignore it
		return reader;
	}
	// store options about how dylib will be used in dylib itself
	if ( info.options.fWeakImport )
		reader->setForcedWeakLinked();
	if ( info.options.fReExport )
		reader->setWillBeReExported();
	if ( info.options.fUpward ) {
		if ( _options.outputKind() == Options::kDynamicLibrary ) 
			reader->setWillBeUpwardDylib();
		else 
			warning("ignoring upward dylib option for %s\n", info.path);
	}
	if ( info.options.fLazyLoad )
		reader->setWillBeLazyLoadedDylb();
	
	// add to map of loaded dylibs
	const char* installPath = reader->installPath();
	if ( installPath != NULL ) {
		InstallNameToDylib::iterator pos = _installPathToDylibs.find(installPath);
		if ( pos == _installPathToDylibs.end() ) {
			_installPathToDylibs[strdup(installPath)] = reader;
		}
		else {
			bool dylibOnCommandLineTwice = ( strcmp(pos->second->path(), reader->path()) == 0 );
			bool isSymlink = false;
			// ignore if this is a symlink to a dylib we've already loaded
			if ( !dylibOnCommandLineTwice ) {
				char existingDylibPath[PATH_MAX];
				if ( realpath(pos->second->path(), existingDylibPath) != NULL ) {
					char newDylibPath[PATH_MAX];
					if ( realpath(reader->path(), newDylibPath) != NULL ) {
						isSymlink = ( strcmp(existingDylibPath, newDylibPath) == 0 );
					}
				}
			}
			// remove warning for <rdar://problem/10860629> Same install name for CoreServices and CFNetwork?
			//if ( !dylibOnCommandLineTwice && !isSymlink )
			//      warning("dylibs with same install name: %p %s and %p %s", pos->second, pos->second->path(), reader, reader->path());
		}
	}
	else if ( info.options.fBundleLoader )
		_bundleLoader = reader;

	// log direct readers
	if ( ! info.options.fIndirectDylib ) 
		this->logDylib(reader, false);

	// update stats
	_totalDylibsLoaded++;

	// just add direct libraries to search-first list
	if ( ! info.options.fIndirectDylib ) 
		_searchLibraries.push_back(LibraryInfo(reader));
	
	return reader;
}


#if HAVE_PTHREADS
// Called during pipelined linking to listen for available input files.
// Available files are enqueued for parsing.
void InputFiles::waitForInputFiles()
{
	if (_s_logPThreads) printf("starting pipeline listener\n");
	try {
		const char *fifo = _options.pipelineFifo();
		assert(fifo);
		std::map<const char *, const Options::FileInfo*, strcompclass> fileMap;
		const std::vector<Options::FileInfo>& files = _options.getInputFiles();
		for (std::vector<Options::FileInfo>::const_iterator it = files.begin(); it != files.end(); ++it) {
			const Options::FileInfo& entry = *it;
			if (entry.fromFileList) {
				fileMap[entry.path] = &entry;
			}
		}
		FILE *fileStream = fopen(fifo, "r");
		if (!fileStream)
			throwf("pipelined linking error - failed to open stream. fopen() returns %s for \"%s\"\n", strerror(errno), fifo);
		while (fileMap.size() > 0) {
			char path_buf[PATH_MAX+1];
			if (fgets(path_buf, PATH_MAX, fileStream) == NULL)
				throwf("pipelined linking error - %lu missing input files", fileMap.size());
			int len = strlen(path_buf);
			if (path_buf[len-1] == '\n')
				path_buf[len-1] = 0;
			std::map<const char *, const Options::FileInfo*, strcompclass>::iterator it = fileMap.find(path_buf);
			if (it == fileMap.end())
				throwf("pipelined linking error - not in file list: %s\n", path_buf);
			Options::FileInfo* inputInfo = (Options::FileInfo*)it->second;
			if (!inputInfo->checkFileExists(_options))
				throwf("pipelined linking error - file does not exist: %s\n", inputInfo->path);
			pthread_mutex_lock(&_parseLock);
			if (_idleWorkers)
				pthread_cond_signal(&_parseWorkReady);
			inputInfo->readyToParse = true;
			if (_parseCursor > inputInfo->inputFileSlot)
				_parseCursor = inputInfo->inputFileSlot;
			_availableInputFiles++;
			if (_s_logPThreads) printf("pipeline listener: %s slot=%d, _parseCursor=%d, _availableInputFiles = %d remaining = %ld\n", path_buf, inputInfo->inputFileSlot, _parseCursor, _availableInputFiles, fileMap.size()-1);
			pthread_mutex_unlock(&_parseLock);
			fileMap.erase(it);
		}
	} catch (const char *msg) {
		pthread_mutex_lock(&_parseLock);
		_exception = msg;
		pthread_cond_signal(&_newFileAvailable);
		pthread_mutex_unlock(&_parseLock);
	}
}


void InputFiles::waitForInputFiles(InputFiles *inputFiles) {
	inputFiles->waitForInputFiles();
}
#endif


void InputFiles::forEachInitialAtom(ld::File::AtomHandler& handler, ld::Internal& state)
{
	// add all direct object, archives, and dylibs
	const std::vector<Options::FileInfo>& files = _options.getInputFiles();
	size_t fileIndex;
	for (fileIndex=0; fileIndex<_inputFiles.size(); fileIndex++) {
		ld::File *file;
#if HAVE_PTHREADS
		pthread_mutex_lock(&_parseLock);
		
		// this loop waits for the needed file to be ready (parsed by worker thread)
		while (_inputFiles[fileIndex] == NULL && _exception == NULL) {
			// We are starved for input. If there are still files to parse and we have
			// not maxed out the worker thread count start a new worker thread.
			if (_availableInputFiles > 0 && _availableWorkers > 0) {
				if (_s_logPThreads) printf("starting worker\n");
				startThread(InputFiles::parseWorkerThread);
				_availableWorkers--;
			}
			_neededFileSlot = fileIndex;
			if (_s_logPThreads) printf("consumer blocking for %lu: %s\n", fileIndex, files[fileIndex].path);
			pthread_cond_wait(&_newFileAvailable, &_parseLock);
		}

		if (_exception)
			throw _exception;

		// The input file is parsed. Assimilate it and call its atom iterator.
		if (_s_logPThreads) printf("consuming slot %lu\n", fileIndex);
		file = _inputFiles[fileIndex];
		pthread_mutex_unlock(&_parseLock);
#else
		file = _inputFiles[fileIndex];
#endif
		const Options::FileInfo& info = files[fileIndex];
		switch (file->type()) {
			case ld::File::Reloc:
			{
				ld::relocatable::File* reloc = (ld::relocatable::File*)file;
				_options.snapshot().recordObjectFile(reloc->path());
				if ( _options.dumpDependencyInfo() )
					_options.dumpDependency(Options::depObjectFile, reloc->path());
			}
				break;
			case ld::File::Dylib:
			{
				ld::dylib::File* dylib = (ld::dylib::File*)file;
				addDylib(dylib, info);
			}
				break;
			case ld::File::Archive:
			{
				ld::archive::File* archive = (ld::archive::File*)file;
				// <rdar://problem/9740166> force loaded archives should be in LD_TRACE
				if ( (info.options.fForceLoad || _options.fullyLoadArchives()) && _options.traceArchives() ) 
					logArchive(archive);
				_searchLibraries.push_back(LibraryInfo(archive));
				if ( _options.dumpDependencyInfo() )
					_options.dumpDependency(Options::depArchive, archive->path());
			}
				break;
			case ld::File::Other:
				break;
			default:
			{
				throwf("Unknown file type for %s", file->path());
			}
				break;
		}
		file->forEachAtom(handler);
	}

	markExplicitlyLinkedDylibs();
	addLinkerOptionLibraries(state, handler);
	createIndirectDylibs();
	createOpaqueFileSections();
	
	while (fileIndex < _inputFiles.size()) {
		ld::File *file = _inputFiles[fileIndex];
		file->forEachAtom(handler);
		fileIndex++;
	}
    
    switch ( _options.outputKind() ) {
        case Options::kStaticExecutable:
        case Options::kDynamicExecutable:
            // add implicit __dso_handle label
            handler.doAtom(DSOHandleAtom::_s_atomExecutable);
            handler.doAtom(DSOHandleAtom::_s_atomAll);
            if ( _options.pageZeroSize() != 0 ) 
                handler.doAtom(*new PageZeroAtom(_options.pageZeroSize()));
            if ( _options.hasCustomStack() && !_options.needsEntryPointLoadCommand() ) 
                handler.doAtom(*new CustomStackAtom(_options.customStackSize()));
            break;
        case Options::kDynamicLibrary:
            // add implicit __dso_handle label
            handler.doAtom(DSOHandleAtom::_s_atomDylib);
            handler.doAtom(DSOHandleAtom::_s_atomAll);
            break;
        case Options::kDynamicBundle:
            // add implicit __dso_handle label
            handler.doAtom(DSOHandleAtom::_s_atomBundle);
            handler.doAtom(DSOHandleAtom::_s_atomAll);
            break;
        case Options::kDyld:
            // add implicit __dso_handle label
            handler.doAtom(DSOHandleAtom::_s_atomDyld);
            handler.doAtom(DSOHandleAtom::_s_atomAll);
            break;
        case Options::kPreload:
            // add implicit __mh_preload_header label
            handler.doAtom(DSOHandleAtom::_s_atomPreload);
            // add implicit __dso_handle label, but put it in __text section because 
            // with -preload the mach_header is no in the address space.
            handler.doAtom(DSOHandleAtom::_s_atomPreloadDSO);
            break;
        case Options::kObjectFile:
            handler.doAtom(DSOHandleAtom::_s_atomObjectFile);
            break;
        case Options::kKextBundle:
            // add implicit __dso_handle label
            handler.doAtom(DSOHandleAtom::_s_atomAll);
            break;
	}
}


bool InputFiles::searchLibraries(const char* name, bool searchDylibs, bool searchArchives, bool dataSymbolOnly, ld::File::AtomHandler& handler) const
{
	// Check each input library.
    for (std::vector<LibraryInfo>::const_iterator it=_searchLibraries.begin(); it != _searchLibraries.end(); ++it) {
        LibraryInfo lib = *it;
        if (lib.isDylib()) {
            if (searchDylibs) {
                ld::dylib::File *dylibFile = lib.dylib();
                //fprintf(stderr, "searchLibraries(%s), looking in linked %s\n", name, dylibFile->path() );
                if ( dylibFile->justInTimeforEachAtom(name, handler) ) {
                    // we found a definition in this dylib
                    // done, unless it is a weak definition in which case we keep searching
                    _options.snapshot().recordDylibSymbol(dylibFile, name);
                    if ( !dylibFile->hasWeakExternals() || !dylibFile->hasWeakDefinition(name)) {
                        return true;
                    }
                    // else continue search for a non-weak definition
                }
            }
        } else {
            if (searchArchives) {
                ld::archive::File *archiveFile = lib.archive();
                if ( dataSymbolOnly ) {
                    if ( archiveFile->justInTimeDataOnlyforEachAtom(name, handler) ) {
                        if ( _options.traceArchives() ) 
                            logArchive(archiveFile);
                        _options.snapshot().recordArchive(archiveFile->path());
                        // found data definition in static library, done
                       return true;
                    }
                }
                else {
                    if ( archiveFile->justInTimeforEachAtom(name, handler) ) {
                        if ( _options.traceArchives() ) 
                            logArchive(archiveFile);
                        _options.snapshot().recordArchive(archiveFile->path());
                        // found definition in static library, done
                        return true;
                    }
                }
            }
        }
    }

	// search indirect dylibs
	if ( searchDylibs ) {
		for (InstallNameToDylib::const_iterator it=_installPathToDylibs.begin(); it != _installPathToDylibs.end(); ++it) {
			ld::dylib::File* dylibFile = it->second;
			bool searchThisDylib = false;
			if ( _options.nameSpace() == Options::kTwoLevelNameSpace ) {
				// for two level namesapce, just check all implicitly linked dylibs
				searchThisDylib = dylibFile->implicitlyLinked() && !dylibFile->explicitlyLinked();
			}
			else {
				// for flat namespace, check all indirect dylibs
				searchThisDylib = ! dylibFile->explicitlyLinked();
			}
			if ( searchThisDylib ) {
				//fprintf(stderr, "searchLibraries(%s), looking in implicitly linked %s\n", name, dylibFile->path() );
				if ( dylibFile->justInTimeforEachAtom(name, handler) ) {
					// we found a definition in this dylib
					// done, unless it is a weak definition in which case we keep searching
                    _options.snapshot().recordDylibSymbol(dylibFile, name);
					if ( !dylibFile->hasWeakExternals() || !dylibFile->hasWeakDefinition(name)) {
						return true;
                    }
					// else continue search for a non-weak definition
				}
			}			
		}
	}

	return false;
}


bool InputFiles::searchWeakDefInDylib(const char* name) const
{
	// search all relevant dylibs to see if any have a weak-def with this name
	for (InstallNameToDylib::const_iterator it=_installPathToDylibs.begin(); it != _installPathToDylibs.end(); ++it) {
		ld::dylib::File* dylibFile = it->second;
		if ( dylibFile->implicitlyLinked() || dylibFile->explicitlyLinked() ) {
			if ( dylibFile->hasWeakExternals() && dylibFile->hasWeakDefinition(name) ) {
				return true;
			}
		}
	}
	return false;
}
	
static bool vectorContains(const std::vector<ld::dylib::File*>& vec, ld::dylib::File* key)
{
	return std::find(vec.begin(), vec.end(), key) != vec.end();
}

struct DylibByInstallNameSorter
{	
	 bool operator()(const ld::dylib::File* left, const ld::dylib::File* right)
	 {
          return (strcmp(left->installPath(), right->installPath()) < 0);
	 }
};

void InputFiles::dylibs(ld::Internal& state)
{
	bool dylibsOK = false;
	switch ( _options.outputKind() ) {
		case Options::kDynamicExecutable:
		case Options::kDynamicLibrary:
		case Options::kDynamicBundle:
			dylibsOK = true;
			break;
		case Options::kStaticExecutable:
		case Options::kDyld:
		case Options::kPreload:
		case Options::kObjectFile:
		case Options::kKextBundle:
			dylibsOK = false;
			break;
	}

	// add command line dylibs in order
	for (std::vector<ld::File*>::const_iterator it=_inputFiles.begin(); it != _inputFiles.end(); ++it) {
		ld::dylib::File* dylibFile = dynamic_cast<ld::dylib::File*>(*it);
		// only add 